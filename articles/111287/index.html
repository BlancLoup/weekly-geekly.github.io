<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data storage by the magazine-structured storage algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a rule, if you are developing storage systems - such as a file system or database - one of the main problems is how to store data on a disk. When d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data storage by the magazine-structured storage algorithm</h1><div class="post__text post__text-html js-mediator-article">  As a rule, if you are developing storage systems - such as a file system or database - one of the main problems is how to store data on a disk.  When developing you must take care of a number of tasks.  For example, about allocating space for objects that you intend to store.  And also about indexing data, so that you don‚Äôt have to worry about what happens when you want to expand an existing object (for example, when adding data to a file), and about fragmentation that occurs when old objects are deleted, and new will take their place.  All this leads to a lot of difficulties, and the solution to frequent bugs, or this is always inefficient. <br><a name="habracut"></a><br>  <a href="http://en.wikipedia.org/wiki/Log-structured_file_system">The structured storage method</a> takes care of all these issues.  It appeared in the 1980s, but lately we have been seeing an increasing use of this method as a method of storage structure in database engines.  In its initial use of the file system, it suffers from some flaws that prevent widespread adoption, but, as we will see, they are not so important for a DBMS, and the structured storage log leads to additional benefits for the database. <br><br>  The basis for organizing a structured data storage log system, as the name implies, is a log ‚Äî that is, everything happens by writing data sequentially.  Whenever you have new data to write, instead of finding space for it on disk, you simply add it at the end of the log.  Indexing data is carried out by processing metadata: updating metadata also occur in the log.  This may seem inefficient, but on the disk the index structures are B-trees, as a rule, they are very wide, so the number of index nodes we need to update with each record are usually very small.  Let's look at a simple example.  We start with logs containing only one data item, as well as the index of the node that refers to it: <br><br><img src="https://habrastorage.org/storage1/bae7e357/4a340620/7ee73a31/f4aa9823.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So far so good.  Now suppose we want to add a second element.  We add a new item at the end of the log, and an updated version of the pointer: <br><br><img src="https://habrastorage.org/storage1/5f240af4/430c1602/3c52b735/ec63fd35.png"><br><br>  The original entry with the index (A) is still in the file, but it is no longer used: it has been replaced by the new entry A ', which refers to the original copy of Foo, as well as to the new entry Bar.  When you want to read from our file system, we find the index of the root node, and use it as it would on any other system. <br><br>  Quick root search.  With a simple approach, one could simply look at the last block in the journal, since the last thing we always write is the root index.  However, this is not ideal, as it is possible that at the time of reading the index, another process adds the middle of the magazine.  We can avoid this by having a single block ‚Äî say, at the beginning of the log ‚Äî which contains a pointer to the current root node.  Whenever we update the log, we will rewrite the first record to make sure it points to the new root node. <br><br>  Next, let's see what happens when we update an item.  Let's say we change foo: <br><br><img src="https://habrastorage.org/storage1/ecd49f1d/7643e87a/806d7c6b/1a9ba29d.png"><br><br>  We started recording a brand new copy of Foo at the end of the magazine.  Then we again updated the node index (only in this example) and also recorded it at the end of the log.  Once again, the old copy of Foo remains in the log, but the updated index simply does not refer to it anymore. <br><br>  You probably understand that this system is not sustainable indefinitely.  At some point, old data will just take up space.  In the file system, it is considered as a ring buffer, overwriting old data.  When this happens, the data that remains valid is simply added to the log again, as if it had just been written, and not the necessary old copies will be overwritten. <br><br>  In the file system, one of the shortcomings that I mentioned earlier is not a good block in the header of the log.  When we get complete information from the disk, the file system must spend more and more of its time collecting garbage, and constantly writing data to the log header.  And when you reach 80%, your file system almost stops. <br><br>  If you are using structured log storage for a database, this is not a problem!  If we divide the database into several pieces of fixed length, then when we have to return some space, we can select a piece, rewrite it with new data, and delete the piece.  The first segment in our example begins to look a little freer: <br><br><img src="https://habrastorage.org/storage1/987f6c33/f1cf41d1/0b76aef2/88298fe7.png"><br><br>  All we did here was take an existing copy of ‚ÄúBar‚Äù and write it at the end of the magazine, then update the index of the node (s) as described above.  After we have done this, the first log segment can be safely deleted. <br><br>  This approach has several advantages over the file system approach.  To begin with, we are not limited to the removal of old segments, if the intermediate segment is almost empty, we can simply collect garbage.  This is especially useful for databases if there is some data that is stored for a long time, and which data is overwritten several times.  We do not want to spend too much time rewriting unmodified data.  We also have more flexibility when collecting garbage. <br><br>  The benefits of this approach for the database do not end there.  In order to ensure transaction consistency, databases typically use Write Ahead Log, or WAL.  When a database is saved to disk, it first writes all changes to WAL, then to disk, and then updates the existing database files.  This allows you to recover from the accident changes recorded in WAL.  If we use log structured storage, the WAL database, so we only need to write data once.  When restoring, just open the database, starting with the last recorded index, and search for any missing indexes. <br><br>  Using our recovery scheme from the top, we can continue to optimize our recording.  Instead of writing update index nodes for each record, we can cache them in memory, and only write them periodically to disk.  Our recovery mechanism will take care of the recovery, as long as we suggest it distinguish between normal and incomplete records. <br>  We can also gradually copy our databases with each new log segment to backup media. <br><br>  The last main advantage of this system relates to parallelism and transaction semantics in databases.  In order to ensure transaction consistency, most databases use complex lock systems to control which processes can update data and at what time.  Depending on the level of consistency required, it can attract readers by taking out keys to make sure that the data does not change when they read it, and also write data keys for writing, can cause a significant decrease in performance even at relatively low numbers if enough simultaneous readings. <br><br>  When it comes to writing data, we can use <a href="http://en.wikipedia.org/wiki/Optimistic_concurrency">Optimistic Concurrency</a> .  In typical read-modify-write cycles, we first perform our read operations, as described above.  Then, to record our changes, we lock the records for the database and make sure that none of the data we read is in the first phase.  We can do it quickly, looking at the index, if the address of the data is the same as when we last read.  If it is not recorded, we can proceed with the change.  If everything is different, we just go back and start reading again. </div><p>Source: <a href="https://habr.com/ru/post/111287/">https://habr.com/ru/post/111287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111278/index.html">LESS CSS preprocessor and Ruby on Rails integration</a></li>
<li><a href="../111280/index.html">Android 3.0 Preview Video</a></li>
<li><a href="../111283/index.html">Sentry - monitoring errors in Django</a></li>
<li><a href="../111284/index.html">1C: Enterprise, or how I ran into a rake interface</a></li>
<li><a href="../111285/index.html">HTPC creation experience</a></li>
<li><a href="../111288/index.html">Where to go? Where to go?</a></li>
<li><a href="../111289/index.html">Infographics: how data center works</a></li>
<li><a href="../111290/index.html">Using objects for beautiful code structure in javascript</a></li>
<li><a href="../111291/index.html">HTML5 application for iPhone on the example of the Tetris game</a></li>
<li><a href="../111292/index.html">Test Automation: Cons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>