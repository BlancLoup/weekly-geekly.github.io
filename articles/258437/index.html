<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: Kicks to common sense (part 7)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Do you know your main sin? 
 - What the heck? I adore all seven ... 
 but now ... I'm ready to give vent to anger! 

 Malcolm Reynolds " Mission Ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: Kicks to common sense (part 7)</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <i><b>- Do you know your main sin?</b></i> <i><b><br></b></i>  <i><b>- What the heck?</b></i>  <i><b>I adore all seven ...</b></i> <i><b><br></b></i>  <i><b>but now ... I'm ready to give vent to anger!</b></i> <i><b><br><br></b></i>  <i><b>Malcolm Reynolds " <a href="http://www.kinopoisk.ru/film/61455/">Mission Serenity</a> "</b></i> <i><b><br></b></i> <br><br>  As my personal ‚Äú <a href="http://habrahabr.ru/post/248639/">trouble rating</a> ‚Äù is rapidly moving toward completion, it is becoming increasingly difficult to get the desired behavior from <a href="http://www.zillions-of-games.com/">Zillions of Games</a> .  Some rules are very easy to formulate, but they can spoil a lot of blood for the developer.  The ‚Äúrule of wrath‚Äù is one of them. <br><a name="habracut"></a><br><h4>  <b>4. For the fook!</b> </h4><br>  The possibility of removing figures from the board (yours or your opponent) is very useful.  There is no need to go far for examples.  I already <a href="http://habrahabr.ru/post/255621/">wrote</a> about the game " <a href="http://www.di.fc.ul.pt/~jpn/gv/focus.htm">Focus</a> ", described by Martin Gardner in his " <a href="http://www.twirpx.com/file/67840/">Mathematical Leisure</a> ".  Playing it is not easy, but the fun of the game can somewhat overshadow the fact of having a very simple win-win strategy for the second player.  Repeating each opponent's turn symmetrically about the center of the board, he can delay the game to infinity: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/IS1cVXGUTSQ%3Ffeature%3Doembed&amp;xid=17259,1500001,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhisLQvWL2ECWWRDshq-A8WW-b-wBg" frameborder="0" allowfullscreen=""></iframe><br><br>  With each move, the second player restores the central symmetry, broken by the previous move.  Since the figures cannot move along the diagonals, the first player cannot break the symmetry in an unrecoverable (in one move) way, hence his opponent cannot lose, repeating all the moves exactly.  Obviously, this deficiency can be dealt with only by breaking the initial symmetrical arrangement of the figures. <br><br>  As the first move, each player can remove one piece from the board (of course, you should prohibit the second player from deleting a piece symmetrically located in relation to the move made by the first player).  In ZRF, there is no possibility of forming moves that are limited only to removing some pieces from the board, but you can cheat.  This code will produce the desired result: <br><br><div class="spoiler">  <b class="spoiler_title">Removing a figure</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> capture-enemy ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> is-protected?)) mark sym (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-protected? true) back capture add )) ... (<span class="hljs-name"><span class="hljs-name">piece</span></span> ... (<span class="hljs-name"><span class="hljs-name">drops</span></span> (<span class="hljs-name"><span class="hljs-name">move-type</span></span> capturing) (<span class="hljs-name"><span class="hljs-name">capture-enemy</span></span>) ) )</code> </pre> <br></div></div><br>  Here <b>sym</b> is the direction connecting the board fields in pairs symmetrically.  In fact, we are not deleting, but putting some kind of auxiliary figure on the board.  The figure that was previously placed on the target field is automatically deleted, and we delete the added figure itself with the <b>capture</b> command, before the completion of the move with the <b>add</b> command.  In ZSG notation, such a move looks like this: <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. White <span class="hljs-literal"><span class="hljs-literal">t</span></span> e6 x e6</code> </pre><br>  It is even easier to perform the "switching" of the figure by changing the color of the enemy to your own (just commenting out the <b>capture</b> command in the above code snippet), but here the first ambush lays in us.  You can put your piece on top of the opponent, but not vice versa!  ZoG allows you to play only your own pieces.  Fortunately, in this case, this is not a very significant limitation.  Voluntary removal of your pieces from the board (and even more so replacing them with enemy pieces) is not the best idea.  Since we are unlikely to succeed in convincing the adversary to do so nobly, the matter will end in a gigantic imbalance at the very beginning of the game. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b69/1f8/75b/b691f875b7e540179223fb64c5d91092.jpg"></div><br>  Of course, ‚ÄúFocus‚Äù is not the only game in which moves that perform the removal of arbitrary pieces are in demand.  In the 30s of the last century, the game " <a href="http://gest.livejournal.com/889387.html%3Fthread%3D3121963">Shahboy</a> " was actively promoted in the USSR, in which the figures on the playing field symbolized the forces of infantry, aviation and artillery.  Artillery, in this game, was a formidable force, since it could destroy enemy figures, literally ‚Äúon the spot‚Äù.  This could completely destroy the game balance, but the problem was solved in a very original way. <br><br>  The weakest figure of the "infantryman" in this game, reaching the opposite edge of the board, did not turn into any other figure.  In fact, the game would have looked very strange if an infantryman, having reached the enemy‚Äôs camp, would turn into a tank or plane (not to mention the ‚Äúheadquarters‚Äù).  After going through the entire battlefield, the "infantryman" was removed from the board, but had the right to "carry out sabotage" - remove any opponent from the board to choose from (except for the "headquarters", of course).  Another rule allowed the ‚Äúinfantryman‚Äù to jump over the black fields of the board (not occupied by other figures), which allowed him to effectively ‚Äúseep‚Äù through artillery barriers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e11/966/89e/e1196689e66b4990a264133d0ba7efb2.gif"></div><br><br>  In various versions of " <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B0_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Mills</a> ", which is a transitional form between " <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B8-%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25B8%25D0%25BA%25D0%25B8">tic-tac-toe</a> " and games of the family of <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">checkers</a> , the removal of arbitrary enemy pieces is performed when you line up three of your chips.  At the beginning of the game, the chips belonging to the players are alternately laid out on an empty board, after which they are allowed to move along the lines of the board.  In existing ZoG implementations, the removal of the opponent's piece is combined with the move building the ‚Äúmill‚Äù (a line of 3 pieces in a row). <br><br><div class="spoiler">  <b class="spoiler_title">Taking an arbitrary shape in the Mill</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> take-piece a1 (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? next) (<span class="hljs-name"><span class="hljs-name">if</span></span> enemy? mark (<span class="hljs-name"><span class="hljs-name">not-in-a-mill</span></span> ns) back (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? eatit) (<span class="hljs-name"><span class="hljs-name">not-in-a-mill</span></span> ew) back (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? eatit) (<span class="hljs-name"><span class="hljs-name">not-in-a-mill</span></span> in out) back (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? eatit) capture add (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> writeit false) ) ) ) ) next ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> check-mill (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> mill false) (<span class="hljs-name"><span class="hljs-name">check-dir1</span></span> ns)(<span class="hljs-name"><span class="hljs-name">check-dir2</span></span> ns)(<span class="hljs-name"><span class="hljs-name">check-dir3</span></span> ns) (<span class="hljs-name"><span class="hljs-name">check-dir1</span></span> ew)(<span class="hljs-name"><span class="hljs-name">check-dir2</span></span> ew)(<span class="hljs-name"><span class="hljs-name">check-dir3</span></span> ew) (<span class="hljs-name"><span class="hljs-name">check-dir1</span></span> in out)(<span class="hljs-name"><span class="hljs-name">check-dir2</span></span> in out)(<span class="hljs-name"><span class="hljs-name">check-dir3</span></span> in out) to (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? mill) (<span class="hljs-name"><span class="hljs-name">take-piece</span></span>) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> shift ( <span class="hljs-name"><span class="hljs-name">mark</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> writeit true) (<span class="hljs-name"><span class="hljs-name">check-mill</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? writeit) add ) ) )</code> </pre><br></div></div><br>  Here you should pay attention to the use of the <b>writeit</b> flag.  The formation of a ‚Äúquiet‚Äù move (with the <b>add</b> command) in the macro of moving the token ( <b>shift</b> ) occurs only if no option has been found to remove the enemy token.  In turn, each <b>add</b> command, executed after a capture ( <b>capture</b> ) in the <b>take-piece</b> macro, leads to the formation of an independent variant of the move (at the same time prohibiting the formation of a ‚Äúquiet‚Äù move). <br><br>  This is a very interesting implementation of the Mill algorithm, which, unfortunately, does not cover all possible situations of this game.  According to some variants of the rules, the simultaneous alignment of several rows of chips should ensure the possibility of removing the corresponding number of opponent's chips.  An attempt to solve this problem by the above algorithm leads to a ‚Äúcombinatorial explosion‚Äù.  In my <a href="">implementation of the</a> similar African game " <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BE%25D0%25BB%25D0%25BE%25D1%2582%25D1%2583%25D0%25B4%25D1%2583">Bolotud</a> " I decided to use a different approach: <br><br><div class="spoiler">  <b class="spoiler_title">Taking figures in the '' Marsh ''</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> my-friend? (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? inner $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? from? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">friend</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> check-side (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> is-checked? false) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">my-friend</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) mark $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">my-friend</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> is-checked? true) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> is-accepted? false) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">3</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">3</span></span>) ) back (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? is-checked?) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">3</span></span>) ) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> check-middle (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">my-friend</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">my-friend</span></span>? $<span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> is-accepted? false) mark $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">4</span></span>) $<span class="hljs-number"><span class="hljs-number">2</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">4</span></span>) back (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> is-marked? true $<span class="hljs-number"><span class="hljs-number">4</span></span>) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> shift-man ( (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? inner)) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">in-zone</span></span>? inner)) (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> is-accepted? true) (<span class="hljs-name"><span class="hljs-name">check-side</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span> $<span class="hljs-number"><span class="hljs-number">4</span></span>) (<span class="hljs-name"><span class="hljs-name">check-side</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">check-side</span></span> $<span class="hljs-number"><span class="hljs-number">4</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">check-middle</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span> $<span class="hljs-number"><span class="hljs-number">4</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-flag</span></span>? is-accepted?) mark a0 (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? next) next (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> enemy? (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? is-marked?)) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-capturing? true) ) ) back ) add )) ... (<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Man) ... (<span class="hljs-name"><span class="hljs-name">attribute</span></span> is-capturing? false) (<span class="hljs-name"><span class="hljs-name">drops</span></span> (<span class="hljs-name"><span class="hljs-name">move-type</span></span> droptype) (<span class="hljs-name"><span class="hljs-name">drop-man</span></span>) ) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">move-type</span></span> normaltype) (<span class="hljs-name"><span class="hljs-name">shift-man</span></span> nesw) (<span class="hljs-name"><span class="hljs-name">shift-man</span></span> eswn) (<span class="hljs-name"><span class="hljs-name">shift-man</span></span> swne) (<span class="hljs-name"><span class="hljs-name">shift-man</span></span> wnes) ) )</code> </pre><br></div></div><br>  In this game, the alignment of a series of three figures, as well as in the "Mill", gives the opportunity to fight the enemy figure, but not any, but only "adjacent to the three from the side."  In order to understand what is meant by this, we had to play the game of this game by the following <a href="http://worldofchildren.ru/vospitatelyam-uchitelyam-pedagogam.html%3Fid%3D1362">entry</a> .  I must say that the quality of this notation is terrible.  Scan from some unknown book I did not bother to clean up from recognition errors.  However, having a board in front of my eyes, <a href="">it was possible to</a> restore the game‚Äôs turn (some of the players‚Äôs moves did not seem particularly clever to me). <br><br>  The code snippet above is based on an analysis of this batch.  <b>Check-side</b> and <b>check-middle</b> macros not only check the formation of triples, but also mark fields that are ‚Äúunder attack‚Äù with the <b>is-marked</b> positional flag <b>?</b>  .  Since all flags (including positional flags) are automatically cleared at the beginning of each turn, it is not necessary to perform any kind of ‚Äúgarbage clearance‚Äù after the turn calculation has been completed.  For the same reason, do you have to transfer the received information about a possible combat to the next turn, by setting the <b>is-capturing</b> attribute <b>?</b>  .  In the next move, it is allowed to remove any piece that has this attribute set.  This approach seems to me more flexible, moreover, the deletion of a piece, performed in a separate move, is more obvious than the choice from a long list of possible moves formed by the ‚ÄúMill‚Äù. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/HI-Qsg8kz34%3Ffeature%3Doembed&amp;xid=17259,1500001,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhjHVGKHYTnC-Vt5M-kNv_6MTeOH8Q" frameborder="0" allowfullscreen=""></iframe><br><br>  I took graphic resources from the <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D960">implementation of</a> another African <a href="http://en.wikipedia.org/wiki/Yot%25C3%25A9">game</a> .  The situation was completely anecdotal.  When I almost completely implemented the game algorithm, ZoG presented a surprise: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> Black) (<span class="hljs-name"><span class="hljs-name">pieces-remaining</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre><br>  The party in ‚ÄúBolotuda‚Äù begins with the installation of figures in pairs on an empty board.  The above line ended the game when any of the players added a second piece.  It was necessary to implement a one-time "reserve" in order for the figures to be taken into account by ZoG already at the stage of adding figures to the board.  Since there was already no strength to draw and customize a board with a ‚Äúreserve‚Äù of forces, I took the appropriate definition of a board from Yotai. <br><br>  By the way, "Yotai" also fits the topic of today's conversation.  This game is even more like checkers.  The captures in it are carried out by the usual "jumping over" through the figure of the enemy.  As in checkers, several take-offs are allowed ‚Äúper chain‚Äù per turn.  The difference is that for each piece taken, the player has the right to take <b>another</b> (any) opponent's piece.  Such a ‚Äúpositive feedback‚Äù leads to the fact that any advantage gained quickly leads to victory (draws in this game are rare), and the very nature of the game is very suitable for temperamental inhabitants of the African continent. <br><br>  But one should not think that such rules are found only in exotic games.  Many of those who played checkers as a child will surely remember the rule that a figure who ‚Äúmissed‚Äù the possibility of a fight could be removed from the board for a fook.  This rule is by no means the invention of ‚ÄúRussian drafts‚Äù!  Likewise, a ‚Äúhuffing‚Äù shape can be made in the English <a href="http://en.wikipedia.org/wiki/Huff_(board_games)">Checkers</a> .  Many researchers agree that a similar ‚Äúrule of anger‚Äù already existed in the progenitor of all drafts games - <a href="http://skyruk.livejournal.com/249847.html">Alquerque</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a89/64d/049/a8964d0490c545d5a4ba5a6bcb5025a8.jpg"></div><br><br>  With regard to the ‚Äúrule of anger‚Äù itself, the story delivered a practically unequivocal sentence.  The application of this rule in drafts makes it almost impossible at least some complex combinational game.  Indeed, in most cases, it is much more profitable for a player to give one piece ‚Äúfor a fook‚Äù than to allow himself to be lured into a trap, as a result of which he may lose much more!  Not surprisingly, in most modern versions of drafts, the ‚Äúrule of anger‚Äù was abolished. <br><br>  Currently, it is used only in some African variants, such as <a href="http://docslide.us/documents/damii-ghana-draughts-history-rules.html">Damii</a> , which is played on the territory of the Republic of <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B0%25D0%25BD%25D0%25B0">Ghana</a> .  Like many other African games, this version of checkers is played ‚Äúfor speed‚Äù and ‚Äúyawn‚Äù in it - an important element of tactics.  As for the rest, the Damii rules are similar to the " <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B6%25D0%25B4%25D1%2583%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">International Drafts</a> ". <br><br>  As a kind of ‚Äúintellectual gymnastics‚Äù, I decided to <a href="">implement</a> checkers ‚Äúwith blunders‚Äù on ZRF.  The first step was obvious - since the player was required to ensure maximum freedom of choice, I turned off take priorities, the majority rule and allowed interruption of the take chain.  In this game, the player is <b>not obliged to</b> ‚Äúeat‚Äù the opponent's pieces, but if his checkers are ‚Äúunderweight‚Äù, the opponent has the right to remove any of them from the board.  I decided to mark the figures subject to the ‚Äúrules of anger‚Äù with attributes.  Immediately formed the following simple algorithm: <br><br><ol><li>  At the end of your turn, for all enemy pieces, perform a check on the possibility of fighting your pieces (pieces that can perform a battle, mark with an attribute) </li><li>  When the enemy takes a take, clear the attributes on all of his pieces (when performing a quiet move, do not touch the attributes) </li><li>  If any of the opponent‚Äôs pieces is marked with an attribute, take it (clearing the attributes on all other pieces) </li><li>  Make your next move </li></ol><br>  On paper everything was smooth.  Of course, ZoG immediately began to make its own adjustments.  The first thing you have to deal with when implementing something more or less complicated in ZRF is not a very intelligible model of moving figures.  Up to the end of the move, the figure in ZoG remains ‚Äúas if‚Äù in its initial position and, in most cases, it is devilishly uncomfortable.  It is necessary to ‚Äúremember‚Äù that the starting field is ‚Äúin fact‚Äù empty, and the final one is filled with a moving figure.  The result is the following macros: <br><br><div class="spoiler">  <b class="spoiler_title">ZoG Fight</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> my-friend? (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? from? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? to? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">friend</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) ) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> my-empty? (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? to? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? from? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) ) ) )</code> </pre><br></div></div><br>  Of course, positional flags <b>from?</b>  and <b>to?</b>  it is also required to fill in correctly, and the macros themselves <a href="https://github.com/GlukKazan/ZoG/commit/ff1099c8c062e155248e41ea0c08dc51331b5d76">did not immediately</a> come to their final version.  The next was the problem of deleting marked shapes.  Taking the figure ‚Äúfor the fuk‚Äù, the player must make one more move, without transferring the move to the opponent.  I did not want to change the order of moves in <b>turn-order</b> (there were reasons for that) and I decided to <a href="https://github.com/GlukKazan/ZoG/commit/94ed96a13cb00df6a9d936bea0acbed450542bf8">block the</a> possibility of a subsequent move by placing a special invisible figure on the field (deleted after the normal move).  In order for the player to skip a move, he had to activate the corresponding option: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"pass turn"</span></span> forced)</code> </pre><br>  Further, one pulled another.  The " <b>pass turn</b> " option controls the player's ability to pass a move (that is, adds a blank move to the list of generated moves).  When you set the value " <b>forced</b> ", its action is even more cunning - the pass is possible only in the absence of any other possible moves (and the skip of a move, in this case, is performed automatically).  Unfortunately, by its very nature, this option is completely incompatible with the following condition for completing the game: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">First</span></span> Second) stalemated)</code> </pre><br>  And this is very bad, since the completion of the game by the defeat of the player, in the absence of the possibility of a move, is perhaps the most important thing from the checkers.  Somewhere in another, more ideal world, I would like the following construction to work (but these are empty dreams): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">First</span></span> Second) (<span class="hljs-name"><span class="hljs-name">and</span></span> stalemated (<span class="hljs-name"><span class="hljs-name">total-piece-count</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Lock) ) )</code> </pre><br>  Skip the move had to do "manually."  Actually, it's <a href="https://github.com/GlukKazan/ZoG/commit/133c7738a0ca0720d9c46b479d10495e88944962">not as scary</a> as it sounds.  It is only required to implement the ‚Äúbutton‚Äù, which the player will press on, performing ‚Äúskipping a turn‚Äù.  The <b>a8</b> field (on a 64-square board) is a suitable place to place it (since normal figures do not enter it).  There is one minus truth - in contrast to the honest " <b>pass turn forced</b> ", this button itself will not be "pressed".  On the other hand, in the processing code of this move, you can put any additional logic, such as clearing attributes (in the current implementation, this was not needed, but not always so lucky).  In the end, with the " <a href="http://en.wikipedia.org/wiki/English_draughts">English drafts</a> " everything turned out, but long-range queens - is another matter: <br><br><div class="spoiler">  <b class="spoiler_title">Russian checkers (with '' blunders '')</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> check-huff (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">my-friend</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">my-empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> is-huffing? true) ) $<span class="hljs-number"><span class="hljs-number">2</span></span> ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> check-huff-2 (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> is-huffing? false) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">check-huff</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span>) $<span class="hljs-number"><span class="hljs-number">2</span></span> ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? is-huffing?) (<span class="hljs-name"><span class="hljs-name">not</span></span> is-huff?)) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? true) ) ) ... (<span class="hljs-name"><span class="hljs-name">define</span></span> check-huff-6 (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> is-huffing? false) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">check-huff-5</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span>) $<span class="hljs-number"><span class="hljs-number">2</span></span> ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? is-huffing?) (<span class="hljs-name"><span class="hljs-name">not</span></span> is-huff?)) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? true) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> check-long-enemies (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> to? true) mark a0 (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">on-board</span></span>? next) next (<span class="hljs-name"><span class="hljs-name">if</span></span> enemy? (<span class="hljs-name"><span class="hljs-name">if</span></span> is-huff? (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? false) ) (<span class="hljs-name"><span class="hljs-name">check-huff-1</span></span> sw ne) (<span class="hljs-name"><span class="hljs-name">check-huff-1</span></span> se nw) (<span class="hljs-name"><span class="hljs-name">check-huff-1</span></span> ne sw) (<span class="hljs-name"><span class="hljs-name">check-huff-1</span></span> nw se) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">piece</span></span>? King) (<span class="hljs-name"><span class="hljs-name">check-huff-2</span></span> sw ne) (<span class="hljs-name"><span class="hljs-name">check-huff-2</span></span> se nw) (<span class="hljs-name"><span class="hljs-name">check-huff-2</span></span> ne sw) (<span class="hljs-name"><span class="hljs-name">check-huff-2</span></span> nw se) (<span class="hljs-name"><span class="hljs-name">check-huff-3</span></span> sw ne) (<span class="hljs-name"><span class="hljs-name">check-huff-3</span></span> se nw) (<span class="hljs-name"><span class="hljs-name">check-huff-3</span></span> ne sw) (<span class="hljs-name"><span class="hljs-name">check-huff-3</span></span> nw se) (<span class="hljs-name"><span class="hljs-name">check-huff-4</span></span> sw ne) (<span class="hljs-name"><span class="hljs-name">check-huff-4</span></span> se nw) (<span class="hljs-name"><span class="hljs-name">check-huff-4</span></span> ne sw) (<span class="hljs-name"><span class="hljs-name">check-huff-4</span></span> nw se) (<span class="hljs-name"><span class="hljs-name">check-huff-5</span></span> sw ne) (<span class="hljs-name"><span class="hljs-name">check-huff-5</span></span> se nw) (<span class="hljs-name"><span class="hljs-name">check-huff-5</span></span> ne sw) (<span class="hljs-name"><span class="hljs-name">check-huff-5</span></span> nw se) (<span class="hljs-name"><span class="hljs-name">check-huff-6</span></span> sw ne) (<span class="hljs-name"><span class="hljs-name">check-huff-6</span></span> se nw) (<span class="hljs-name"><span class="hljs-name">check-huff-6</span></span> ne sw) (<span class="hljs-name"><span class="hljs-name">check-huff-6</span></span> nw se) ) ) ) back ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump ( (<span class="hljs-name"><span class="hljs-name">check-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">enemy</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? (<span class="hljs-name"><span class="hljs-name">clear-enemy-huffs</span></span>) mark (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? (<span class="hljs-name"><span class="hljs-name">opposite</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture back (<span class="hljs-name"><span class="hljs-name">clear-huffs</span></span>) (<span class="hljs-name"><span class="hljs-name">clear-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> more-captures false) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? true) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">check-long-enemies</span></span>) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? false) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> notype) ) $<span class="hljs-number"><span class="hljs-number">1</span></span> ) )) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-shift ( (<span class="hljs-name"><span class="hljs-name">check-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">clear-enemy-huffs</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">check-long-enemies</span></span>) (<span class="hljs-name"><span class="hljs-name">clear-lock</span></span>) add ) ))</code> </pre><br></div></div><br>  This option even worked until it came to the ladies.  The ladies behaved mysteriously: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/b-AFRVPb16Q%3Ffeature%3Doembed&amp;xid=17259,1500001,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgS_DUqsyTW8PvEVck8bqh-ldl8Tg" frameborder="0" allowfullscreen=""></iframe><br><br>  The riddle was solved simply.  The long-distance queen can stop on any field along the route, therefore for each of them a check of the possibility of a battle by enemy figures must be carried out.  The flag, for the queen on <b>h8</b> , was set when the black lady passed the <b>b2</b> field, but was not reset at the beginning of the next iteration of the cycle.  Similar games with attribute values ‚Äã‚Äãhave no place in the turn generation cycle.  Good old "copy-paste" once again came to the rescue: <br><br><div class="spoiler">  <b class="spoiler_title">Corrected implementation</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-1 ( (<span class="hljs-name"><span class="hljs-name">check-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">enemy</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) $<span class="hljs-number"><span class="hljs-number">1</span></span> capture (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">clear-huffs</span></span>) (<span class="hljs-name"><span class="hljs-name">clear-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> more-captures false) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? true) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">check-long-enemies</span></span>) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? false) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> notype) ) )) ... (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-6 ( (<span class="hljs-name"><span class="hljs-name">check-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">empty</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">enemy</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>)) $<span class="hljs-number"><span class="hljs-number">1</span></span> capture (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">clear-huffs</span></span>) (<span class="hljs-name"><span class="hljs-name">clear-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> more-captures false) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">king-captured-find</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag</span></span>? more-captures) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? true) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">check-long-enemies</span></span>) (<span class="hljs-name"><span class="hljs-name">set-attribute</span></span> is-huff? false) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> notype) ) )) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-shift-1 ( (<span class="hljs-name"><span class="hljs-name">check-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">check-long-enemies</span></span>) (<span class="hljs-name"><span class="hljs-name">clear-lock</span></span>) add )) ... (<span class="hljs-name"><span class="hljs-name">define</span></span> king-shift-7 ( (<span class="hljs-name"><span class="hljs-name">check-lock</span></span>) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> from? true) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">check-long-enemies</span></span>) (<span class="hljs-name"><span class="hljs-name">clear-lock</span></span>) add )) (<span class="hljs-name"><span class="hljs-name">variant</span></span> (<span class="hljs-name"><span class="hljs-name">title</span></span> <span class="hljs-string"><span class="hljs-string">"Russian Checkers (with huffs)"</span></span>) <span class="hljs-comment"><span class="hljs-comment">; (option "maximal captures" true) ; AI Bug ; (option "pass partial" false) (piece (name Checker) (image First "images/wiedem/CheckerWhite.bmp" Second "images/wiedem/CheckerBlack.bmp") (attribute is-huff? false) (drops (move-type normaltype) (capture-huff) ) (moves (move-type jumptype) (long-checker-jump nw sw ne) (long-checker-jump ne se nw) (long-checker-jump sw se nw) (long-checker-jump se ne sw) (move-type normaltype) (long-checker-jump nw sw ne) (long-checker-jump ne se nw) (long-checker-jump sw se nw) (long-checker-jump se ne sw) (long-checker-shift nw) (long-checker-shift ne) (move-type notype) ) ) (piece (name King) (image First "images/wiedem/CheckerKingWhite.bmp" Second "images/wiedem/CheckerKingBlack.bmp") (attribute is-huff? false) (moves (move-type jumptype) (king-jump-1 nw sw ne) (king-jump-1 ne se nw) (king-jump-1 sw se nw) (king-jump-1 se ne sw) (king-jump-2 nw sw ne) (king-jump-2 ne se nw) (king-jump-2 sw se nw) (king-jump-2 se ne sw) (king-jump-3 nw sw ne) (king-jump-3 ne se nw) (king-jump-3 sw se nw) (king-jump-3 se ne sw) (king-jump-4 nw sw ne) (king-jump-4 ne se nw) (king-jump-4 sw se nw) (king-jump-4 se ne sw) (king-jump-5 nw sw ne) (king-jump-5 ne se nw) (king-jump-5 sw se nw) (king-jump-5 se ne sw) (king-jump-6 nw sw ne) (king-jump-6 ne se nw) (king-jump-6 sw se nw) (king-jump-6 se ne sw) (move-type normaltype) (king-jump-1 nw sw ne) (king-jump-1 ne se nw) (king-jump-1 sw se nw) (king-jump-1 se ne sw) (king-jump-2 nw sw ne) (king-jump-2 ne se nw) (king-jump-2 sw se nw) (king-jump-2 se ne sw) (king-jump-3 nw sw ne) (king-jump-3 ne se nw) (king-jump-3 sw se nw) (king-jump-3 se ne sw) (king-jump-4 nw sw ne) (king-jump-4 ne se nw) (king-jump-4 sw se nw) (king-jump-4 se ne sw) (king-jump-5 nw sw ne) (king-jump-5 ne se nw) (king-jump-5 sw se nw) (king-jump-5 se ne sw) (king-jump-6 nw sw ne) (king-jump-6 ne se nw) (king-jump-6 sw se nw) (king-jump-6 se ne sw) (king-shift-1 ne) (king-shift-1 nw) (king-shift-1 se) (king-shift-1 sw) (king-shift-2 ne) (king-shift-2 nw) (king-shift-2 se) (king-shift-2 sw) (king-shift-3 ne) (king-shift-3 nw) (king-shift-3 se) (king-shift-3 sw) (king-shift-4 ne) (king-shift-4 nw) (king-shift-4 se) (king-shift-4 sw) (king-shift-5 ne) (king-shift-5 nw) (king-shift-5 se) (king-shift-5 sw) (king-shift-6 ne) (king-shift-6 nw) (king-shift-6 se) (king-shift-6 sw) (king-shift-7 ne) (king-shift-7 nw) (king-shift-7 se) (king-shift-7 sw) (move-type notype) ) ) )</span></span></code> </pre><br></div></div><br>  It may seem that this was the end of my troubles and I received a correct working implementation of Russian Checkers with Yaws, but everything is not so simple.  First, the inclusion of the " <b>maximal captures</b> " option brought the bug I described in one of the previous <a href="http://habrahabr.ru/post/254947/">articles</a> to life.  At some point in the game, under AI control, the program ceased to see the possibility of taking its pieces (and since the code that performed the check for the enemy had seen such an opportunity, he took checkers "for the fuk" out of the blue). <br><br>  I have already learned how to deal with a similar bug in the Checkers Collection and even posted the appropriate <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2351">correction</a> , but for some reason this method did not work in the ‚Äúwith yawns‚Äù version. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/009/318/6ed/0093186eda064c49aab2aaf9afe62457.PNG"></div><br><br>  But this is only part of the problem.  In the illustration above, the white woman should take the pieces on <b>d6</b> and <b>f6</b> , hitting the battle of <b>h8</b> .  Of course, she can ‚Äúyawn‚Äù by completing a quiet move or remaining in place, but in this case, it can be taken ‚Äúfor a fook.‚Äù  The difficulty lies in the fact that with any technical means I cannot ‚Äúforce‚Äù the white lady to continue the fight.  She can go to <b>f4</b> or <b>g3</b> and the ‚Äúyawn‚Äù mark will still be cleared.  Some things to implement on the ZRF correctly simply impossible. <br></div><p>Source: <a href="https://habr.com/ru/post/258437/">https://habr.com/ru/post/258437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258423/index.html">PSR-7 adopted</a></li>
<li><a href="../258427/index.html">Jancy - scripting language for system / network programmers</a></li>
<li><a href="../258429/index.html">.NET-conference. NEXT 2015 Piter: A short tour of the reports - part 1</a></li>
<li><a href="../258431/index.html">More IT professions for kids, even more</a></li>
<li><a href="../258433/index.html">We test Chinese iron and find out how cheap and angry it is</a></li>
<li><a href="../258439/index.html">The new issue of the magazine "Radio Annual" number 35 (2015)</a></li>
<li><a href="../258441/index.html">Dynamic Meta Objects (part 1, study)</a></li>
<li><a href="../258443/index.html">Kubernetes Basics</a></li>
<li><a href="../258445/index.html">Keeping recordings of conversations in mp3 in FreePBX / Asterisk</a></li>
<li><a href="../258447/index.html">We manage AB400S Wireless Switch socket without remote control</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>