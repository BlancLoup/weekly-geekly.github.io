<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Know your JIT: closer to the car</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before the code we write is executed, it goes a long way. Andrei Melikhov, in his report on RHS ++ 2018, analyzed every step along the way using the e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Know your JIT: closer to the car</h1><div class="post__text post__text-html js-mediator-article">  Before the code we write is executed, it goes a long way.  <strong>Andrei Melikhov,</strong> in his report on RHS ++ 2018, analyzed every step along the way using the example of the V8 engine.  Come under the cat to find out what gives us a deep understanding of the principles of the compiler and how to make JavaScript code more productive. <br><br><img src="https://habrastorage.org/webt/iy/2r/ke/iy2rkenolmtnchwu_whyurlrw80.jpeg"><br><br>  Find out whether WASM is a silver bullet to improve code performance, and whether optimization is always justified. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong><em>Spoiler:</em></strong> "Premature optimization is the root of all ills," Donald Knut. <br><br><img src="https://habrastorage.org/webt/rd/-o/q7/rd-oq7q2m9bjipzyqo1l3jrlqti.jpeg"><br><br>  <strong><em>About the speaker:</em></strong> Andrei Melikhov works at Yandex.Money, actively writes on Node.js, and less in the browser, therefore server JavaScript is closer to him.  Andrei supports and develops the devShacht community, go to meet <a href="https://github.com/devSchacht">GitHub</a> or <a href="https://medium.com/devschacht">Medium</a> . <br><a name="habracut"></a><br><h2>  <strong>Motivation and Glossary</strong> </h2><br>  Today we will talk about JIT compilation.  I think you are interested, since you are reading this.  Nevertheless, let's clarify why you need to know what JIT is and how V8 works, and why it‚Äôs not enough to write to React in a browser. <br><br><ul><li>  Allows you <strong>to write more efficient code</strong> , because we have a specific language. </li><li>  <strong>Reveals riddles</strong> why in foreign libraries the code is written this way and not otherwise.  Sometimes we come across old libraries and see what is written there strangely, but it‚Äôs necessary, it‚Äôs not necessary ‚Äî it‚Äôs not clear.  When you know how it works, you understand why it was done. <br></li><li>  <strong>This is just interesting</strong> .  In addition, it makes it possible to understand what Axel Rauschmayer, Benedict Meurer and Dan Abramov are tweeting about. <br></li></ul><br><img src="https://habrastorage.org/webt/le/oy/yg/leoyyg4b8ru_n_2djyzkg6hbe1a.jpeg"><br><br>  Wikipedia says that JavaScript is a high-level interpreted programming language with dynamic typing.  We will deal with these terms. <br><br>  <strong>Compilation and interpretation</strong> <br><br>  Compilation - when the program is delivered in binary code, and initially optimized for the environment in which it will work. <br><br>  Interpretation - when we deliver the code as is. <br><br>  JavaScript comes as it is - it is an interpreted language, as it is written on Wikipedia. <br><br>  <strong>Dynamic and static typing</strong> <br><br>  Static and dynamic typing are often confused with weak and strong typing.  For example, C is a language with static weak typing.  JavaScript has a weak dynamic typing. <br><br>  What is the best of it?  If the program is compiled, it is sharpened to the environment in which it will be executed, which means it will work better.  Static typing allows you to make this code more efficient.  In JavaScript, the opposite is true. <br><br>  But at the same time, our application becomes more and more complicated: huge clusters on Node.js appear on both the client and the server, which work fine and come to replace Java-based applications. <br><br>  But how does all this work, if initially it seems that it is the loser. <br><br><blockquote>  JIT all reconcile!  Or at least try. </blockquote><br>  We have a JIT (Just In Time Compilation) that occurs during program execution.  We will talk about it. <br><br><h3>  <strong>JS engines</strong> </h3><br><ul><li>  All unloved Chakra, which is in Internet Explorer.  It even works not with JavaScript, but with Jscript - there is such a subset. <br></li><li>  Modern Chakra and ChakraCore, who work in the Edge; <br></li><li>  SpiderMonkey in FireFox; </li><li>  JavaScriptCore in WebKit.  It is also used in React Native.  If you have an RN-application for Android, then it is also executed on JavaScriptCore - the engine comes bundled with the application. <br></li><li>  V8 - my favorite.  It is not the best, I just work with Node.js, in which it is the main engine, as in all Chrome Based browsers. <br></li><li>  Rhino and Nashorn are engines that are used in Java.  With their help, JavaScript can also be executed there. <br></li><li>  JerryScript - for embedded devices; <br></li><li>  other... </li></ul><br>  You can write your own engine, but if you move to effective execution, you will come up with about the same scheme, which I will show later. <br><br>  Today we will talk about the V8, and yes, it is named after the 8-cylinder engine. <br><br><h2>  <strong>We climb under the hood</strong> </h2><br>  How is javascript executed? <br><br><ul><li>  There is a code written in javascript that is being delivered. <br></li><li>  he parses; </li><li>  performed; </li><li>  the result is obtained. <br></li></ul><br><img src="https://habrastorage.org/webt/wj/n0/us/wjn0ustvepwu4kmulit2v6xxtsy.jpeg"><br><br>  Parsing turns the code into an <strong>abstract syntax tree</strong> .  AST is a display of the syntactic structure of a code in the form of a tree.  In fact, it is convenient for the program, although it is hard to read. <br><img src="https://habrastorage.org/webt/3i/1p/y-/3i1py-dcnwj6enma0zveqcv67tq.jpeg"><br><br>  Receiving an element of an array with index 1 in the form of a tree is represented as an operator and two operands: load the property by key and these keys. <br><br><h3>  <strong>Where is AST used</strong> </h3><br>  AST is not only in engines.  With the use of AST, extensions are written in many utilities, including: <br><br><ul><li>  ESLint; </li><li>  Babel; </li><li>  Prettier; </li><li>  Jscodeshift </li></ul><br>  For example, the cool thing Jscodeshift, about which not everyone knows, allows you to write transformations.  If you change the API of a function, you can set these transformations on it and make changes in the whole project. <br><br><img src="https://habrastorage.org/webt/wl/ct/8e/wlct8ejmclt1hoqiinm9jwbayyg.jpeg"><br><br>  Moving on.  The processor does not understand the abstract syntax tree, it needs <strong>machine code</strong> .  Therefore, further transformation occurs through the interpreter, because the language is interpretable. <br><img src="https://habrastorage.org/webt/i6/cj/zh/i6cjzhohklmcdyenrvrjmdw6fyk.jpeg"><br><br>  So it was, while browsers had a little javascript - highlight the line, open something, close.  But now we have applications - SPA, Node.js, and the <strong>interpreter becomes a bottleneck</strong> . <br><br><h2>  <strong>Optimizing JIT compiler</strong> </h2><br>  Instead of the interpreter, an optimizing JIT compiler appears, that is, a Just-in-time compiler.  Ahead-of-time compilers work before application execution, and JIT - on time.  In the optimization question, the JIT compiler tries to guess how the code will be executed, what types will be used, and optimize the code so that it works better. <br><br>  Such optimization is called <strong>speculative</strong> , because it speculates on knowledge of what happened to the code before.  That is, if something with the number type was called 10 times, the compiler thinks that it will be this way all the time and optimizes for this type. <br><br>  Naturally, if Boolean goes to the input, deoptimization occurs.  Consider a function that adds numbers. <br><br> <code>const foo=(a, b) =&gt; a + b; <br> foo (1, 2); <br> foo (2, 3);</code> <br> <br>  Folded once, the second time.  The compiler builds a prediction: ‚ÄúThese are numbers, I have a cool solution for adding numbers!‚Äù And you write <code>foo('WTF', 'JS')</code> , and pass strings to the function - we have JavaScript, we can also add a string with a number . <br><br>  At this point, de-optimization occurs. <br><br><img src="https://habrastorage.org/webt/h4/bf/d-/h4bfd-9twvmsqlk-euvv34he48u.jpeg"><br><br>  So, the interpreter has been replaced by the compiler.  It seems that the diagram above is a very simple pipeline.  In reality, everything is a little different. <br><br><img src="https://habrastorage.org/webt/zp/ma/oo/zpmaoosvxia3btjyxstyyaq5nnc.jpeg"><br><br>  That was until last year.  Last year you could hear a lot of reports from Google that they launched a new pipeline with TurboFan and now the scheme looks simpler. <br><br><img src="https://habrastorage.org/webt/qz/wo/2x/qzwo2xg_2ju3fafi6hb4y8ssm24.jpeg"><br><br>  Interestingly, an interpreter appeared here. <br><br><img src="https://habrastorage.org/webt/w5/tu/u4/w5tuu4i3irrzbsck7e2ohdnzgai.jpeg"><br><br>  An interpreter is needed to turn an abstract syntax tree into bytecode, and to transfer bytecode to a compiler.  In case of de-optimization, he again goes to the interpreter. <br><br><h2>  <strong>Interpreter Ignition</strong> </h2><br>  Earlier in the interpreter scheme Ignition was not.  Google initially said that the interpreter is not needed - JavaScript is already quite compact and interpretable - we won‚Äôt win anything. <br><br>  But the team that worked on mobile apps faced the following problem. <br><br><img src="https://habrastorage.org/webt/7e/ms/yd/7emsydqevnntiujqhsa_rtrvdec.jpeg"><br><br>  In 2013-2014, people began to more often use mobile devices to access the Internet than desktop.  Basically, this is not an iPhone, but from devices simpler - they have little memory and a weak processor. <br><br><img src="https://habrastorage.org/webt/8b/0l/zi/8b0lzi2wb8mqqbsetc88t2lsale.jpeg"><br><br>  Above is the primary analysis graph of 1 MB code before the interpreter is launched.  It can be seen that the desktop wins very much.  The iPhone is also good, but it has a different engine, and now we are talking about the V8, which works in Chrome. <br><br><blockquote>  Did you know that if you put Chrome on the iPhone, it will still work on JavaScriptCore? </blockquote><br>  Thus, time is wasted - and this is only analysis, not execution - your file has been loaded, and it is trying to understand what is written in it. <br><img src="https://habrastorage.org/webt/kx/kv/l5/kxkvl5nr4j2cxe5d6kuhwegffnk.jpeg"><br><br>  When de-optimization occurs, you need to take the source code again, i.e.  it must be stored somewhere.  It took a lot of memory. <br><br>  Thus, the interpreter had two tasks: <br><br><ol><li>  reduce the overhead of parsing; <br></li><li>  reduce memory consumption. <br></li></ol><br>  The tasks were solved by switching to the bytecode interpreter. <br><img src="https://habrastorage.org/webt/yr/ky/sk/yrkyskmi_annr0w3jnps13y5alc.jpeg"><br><br>  <strong>Bytecode in Chrome is a register machine with a battery</strong> .  In SpiderMonkey, the stack machine, there all the data are on the stack, but there are no registers.  Here they are. <br><br>  We will not fully understand how this works, just look at the code snippet. <br><br><img src="https://habrastorage.org/webt/vu/is/fh/vuisfhp0lin_et7pozzqny-g6q0.jpeg"><br><br>  It says: take the value that lies in the battery, and add to the value that lies in the register <strong>a0</strong> , that is, in the variable <strong>a</strong> .  There is still nothing known about the types.  If this were a real assembly code, then it would be written with an understanding of what shifts in memory are, what is in it.  Here is just an instruction - take what lies in the register <strong>a0</strong> and add to the value lying in the battery. <br><br>  Of course, the interpreter does not just take an abstract syntax tree and translate it into bytecode. <br><img src="https://habrastorage.org/webt/vv/4g/i6/vv4gi6zw_zrtlsgl5lsb7ebqqza.jpeg"><br><br>  There are also optimizations, for example, dead code elimination. <br>  If a piece of code is not called, it is discarded and no longer stored.  If Ignition sees the addition of two numbers, he will add them and leave them in such a way as not to store excess information.  Only after that it turns out baytkod. <br><br><h2>  <strong>Optimization and deoptimization</strong> </h2><br><h3>  Cold and hot functions </h3><br>  This is the simplest topic. <br><br>  Cold functions are those that were called once or not called at all, hot functions are those that were called several times.  How many times, it is impossible to say - at any time it can alter.  But at some point the function becomes hot, and the engine understands that it needs to be optimized. <br><br><img src="https://habrastorage.org/webt/mk/1t/vr/mk1tvrgq5h2l7mp72g4p6vg6wlm.jpeg"><br><br>  Scheme of work. <br><br><ul><li>  Ignition (interpreter) collects information.  It not only transforms JavaScript into bytecode, but also understands which types came to the input, which functions became hot, and tells the compiler about all this. </li><li>  Optimization occurs. </li><li>  The compiler executes the code.  Everything works well, but a type arrives here that he did not expect, he does not have code to work with this type. </li><li>  Deoptimization occurs.  The compiler refers to the interpreter Ignition for this code. </li></ul><br>  This is a normal cycle that happens all the time, but it is not infinite.  At some point, the engine says: ‚ÄúNo, this cannot be optimized,‚Äù and starts performing without optimization.  It is important to understand that it is necessary to observe monomorphism. <br><br>  <strong>Monomorphism</strong> is when the same types always come to the input of your function.  That is, if you have a string all the time, you do not need to pass a boolean there. <br><br>  But what to do with objects?  Objects are all object.  We have classes, but they are not real - it‚Äôs just sugar over the prototype model.  But inside the engine there are so-called hidden classes. <br><br><h3>  Hidden classes </h3><br>  Hidden classes are in all engines, not only in V8.  Everywhere they are called differently, in terms of V8 is Map. <br><br>  All objects you create have hidden classes.  If you <br>  look in the memory profiler, you will see that there are elements, where the list of elements is stored, properties, where property is stored, and map (usually the first parameter), where the reference to its hidden class is indicated. <br><br>  Map describes the structure of objects, because in JavaScript typing is possible in principle only structural, not nominal.  We can describe how our object looks like, what is behind it. <br><br>  When deleting / adding properties of Hidden classes objects, the object is changed, a new one is assigned.  Let's look at the code. <br><img src="https://habrastorage.org/webt/4i/ia/bs/4iiabsuemjg-7nu0yiywvlsd9hc.jpeg"><br><br>  We have a constructor that creates a new object of type Point. <br><br><ul><li>  Create an object. </li><li>  We bind to it a hidden class that says that it is an object of type Point. </li><li>  Added field x - a new hidden class, which says that it is an object of type Point, in which the first is the value of x. </li><li>  Added y - new Hidden classes, in which x, and then y. </li><li>  Created another object - the same thing happens.  That is, it also binds what has already been created.  At this moment, these two objects are of the same type (via Hidden classes). </li><li>  When a new field is added to the second object, the object has a new Hidden classes.  Now for the p1 and p2 engine, these are objects of different classes, because they have different structures </li><li>  If you pass the first object somewhere, then when you pass the second object there, deoptimization will occur.  The first refers to one hidden class, the second to the other. </li></ul><br>  <strong>How can I check Hidden classes?</strong> <br><br>  In Node.js, you can run node ‚Äîallow-natives-syntax.  Then you will be able to write commands in a special syntax, which, of course, cannot be used in production.  It looks like this: <br><br><pre> <code class="javascript hljs">%HaveSameMap({<span class="hljs-string"><span class="hljs-string">'a'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'b'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>})</code> </pre> <br>  No one guarantees that tomorrow these commands will work, they are not in the ECMAScript specification, this is all for debugging. <br><br>  What do you think will be the result of calling the% HaveSameMap function for two objects?  The correct answer is false, because one has a field called <strong>a</strong> , and the second one has <strong>b</strong> .  These are different objects.  This knowledge can be used for Inline Caches. <br><br><h3>  Inline caches </h3><br>  Call a very simple function that returns a field from an object.  It seems to return the unit is very simple.  But if you look at the ECMAScript specification, you will see that there is a huge list of what needs to be done to get the field from the object.  Because if the field is not in the object, perhaps it is in its prototype.  Maybe it's setter, getter, and so on.  All this needs to be checked. <br><img src="https://habrastorage.org/webt/02/dn/nj/02dnnjtvkqa7fn87e8ioa3kwgpy.jpeg"><br><br>  In this case, the object has a link to the map, which says: to get the field <strong>x</strong> , you need to make an offset by one, and we get <strong>x</strong> .  No need to climb anywhere, in any prototypes, everything is close by.  Inline Caches uses this. <br><br><img src="https://habrastorage.org/webt/ck/53/ny/ck53nyrhuj7ihixe7vi7ds_vjvc.jpeg"><br><br><ul><li>  If we call the function the first time, everything is fine, the interpreter did the optimization </li><li>  For the second call, the monomorphic state is preserved. </li><li>  I call the function a third time, passing a slightly different object {x: 3, y: 1}.  De-optimization occurs, if appears, we move to the polymorphic state.  Now the code that performs this function knows that two different types of objects can fly to it. </li><li>  If we transfer different objects several times, it remains in a polymorphic state, adding new if.  But at some point it gives up and goes into a megamorphic state, i.e.  when: ‚ÄúThere are too many different types of arrivals at the entrance - I don‚Äôt know how to optimize it!‚Äù </li></ul><br>  It seems that 4 polymorphic states are now allowed, but tomorrow there may be eight. This is decided by the engine developers.  We'd better stay in monomorphic, in extreme cases, in a polymorphic state.  The transition between monomorphic and polymorphic states is expensive, because you will need to go to the interpreter, get the code again, and re-optimize it. <br><br><h3>  Arrays </h3><br>  In JavaScript, apart from the specific Typed Arrays, there is one type <br>  array.  In the V8 engine there are 6 of them: <br><br>  1. [1, 2, 3, 4] // PACKED_SMI_ELEMENTS - just packed array small integer.  For him there is optimization. <br><br>  2. [1.2, 2.3, 3.4, 4.6] // PACKED_DOUBLE_ELEMENTS is a packed array of double elements, for it there are optimizations too, but slower ones. <br><br>  3. [1, 2, 3, 4, 'X'] // PACKED_ELEMENTS - packed array in which there are objects, strings and everything else.  For him, too, there is optimization. <br><br>  The following three types are arrays of the same type as the first three, but with holes: <br><br>  4. [1, / * hole * /, 2, / * hole * /, 3, 4] // HOLEY_SMI_ELEMENTS <br><br>  5. [1.2, / * hole * /, 2, / * hole * /, 3, 4] // HOLEY_DOUBLE_ELEMENTS <br><br>  6. [1, / * hole * /, 'X'] // HOLEY_ELEMENTS <br><br>  When holes appear in your arrays, optimizations become less efficient.  They start to work badly, because it is impossible to go through this array in a row, going through it with iterations.  Each subsequent type is worse optimized. <br><br><img src="https://habrastorage.org/webt/qb/rw/zf/qbrwzflusrdjbboqwgsth1ezozu.jpeg"><br><br>  On the diagram, everything above is faster optimized.  That is, all your native methods ‚Äî map, reduce, sort ‚Äî are well optimized inside.  But with each type of optimization it gets worse. <br><br>  For example, a simple array [ <strong>1</strong> , <strong>2</strong> , <strong>3</strong> ] (type - packed small integer) came to the input.  Slightly changed this array by adding a double to it - switched to the PACKED_DOUBLE_ELEMENTS state.  Add an object to it - moved to the next state, the green rectangle PACKED_ELEMENTS.  Add holes to it - go to the HOLEY_ELEMENTS state.  We want to restore it to its previous state, so that it becomes ‚Äúgood‚Äù again - we delete everything we have written, and we remain in the same state ... with holes!  That is, HOLEY_ELEMENTS at the bottom right in the diagram.  Back it doesn't work.  Your arrays can only get worse, but not vice versa. <br><br><h2>  <strong>Array-Like Object</strong> </h2><br>  We often encounter Array-Like Object - these are objects that look like arrays, because they have a sign of length.  In fact, they are like a pirate cat, that is, they seem to be similar, but in the efficiency of rum consumption, the cat will be worse than the pirate.  Similarly, an Array-Like Object is similar to an array, but not efficient. <br><img src="https://habrastorage.org/webt/uf/f4/u_/uff4u_bbjb3elwmhhor3lv2tiwm.jpeg"><br><br>  Our two most favorite Array-Like Objects are arguments and document.querySelectorAII.  There are such beautiful functional pieces. <br><img src="https://habrastorage.org/webt/i7/_j/ul/i7_juluulfkpnerhxwnif4tjnoa.jpeg"><br><br>  We have a map - we tore it from the prototype and we can seem to use it.  But if the array did not come to its input, there will be no optimization.  Our engine does not know how to optimize objects. <br><br>  What should be done? <br><br><ul><li>  Old school version - through slice.call () to turn into a real array. </li><li>  The modern version is even better: write (... rest), get a clean array ‚Äî not arguments ‚Äî everything is fine! </li></ul><br>  With querySelectorAll, the same thing - due to the spread, we can turn it into a full-fledged array and work with all the optimizations. <br><br><h2>  <strong>Large arrays</strong> </h2><br><blockquote>  <strong>Riddle:</strong> new Array (1000) vs array = [] <br>  Which option is better: create a large array at once and fill it with 1000 objects in a loop, or create an empty one and fill it gradually? <br></blockquote><br>  <strong>The correct answer:</strong> depends on. <br><br>  What's the Difference? <br><br><ul><li>  When we create an array in the first way and fill 1000 elements, we create 1000 holes.  This array will not be optimized.  But it will quickly write. <br></li><li>  Creating an array according to the second variant, a little memory is allocated, we write, for example, 60 elements, a little more memory is allocated, etc. </li></ul><br>  That is, in the first case we write quickly - we are slowly working;  in the second we write slowly - we work quickly. <br><br><h2>  <strong>Garbage collector</strong> </h2><br>  The garbage collector also eats a little time and resources.  Without plunging deeply, I will give the most common base. <br><br><img src="https://habrastorage.org/webt/fg/8e/1c/fg8e1csx9x1mo4y2hlvuzzjvgem.jpeg"><br><br>  In our generative model there is a <strong>space of young and old objects</strong> .  The created object falls into the space of young objects.  After some time, the cleaning starts.  If the object cannot be reached by links from the root, then it can be collected in the trash.  If the object is still in use, it moves to the space of old objects, which is cleaned less often.  However, at some point old objects are also deleted. <br><img src="https://habrastorage.org/webt/ac/rd/1l/acrd1lqmylajg5b3crff97j-9h8.jpeg"><br><br>  This is how the automatic garbage collector works - it cleans up objects itself, based on the fact that there are no links to them.  These are two different algorithms. <br><br><ol><li>  <strong>Scavenge</strong> is fast, but not effective. <br></li><li>  <strong>Mark-Sweep</strong> is slow but effective. <br></li></ol><br>  If you start memory consumption profiling in Node.js, you‚Äôll get something like this. <br><br><img src="https://habrastorage.org/webt/yp/uj/1b/ypuj1bus74-w473vsmczkvgwi0s.jpeg"><br><br>  At first it grows abruptly - this is the work of the Scavenge algorithm.  Then there is a sharp drop - this Mark-Sweep algorithm collected garbage in the space of old objects.  At this point, everything starts to slow down a bit.  <strong>You cannot control this</strong> because you do not know when this will happen.  You can only customize the sizes. <br><br>  Therefore, in the pipeline there is a stage of garbage collection, which consumes time. <br><br><img src="https://habrastorage.org/webt/zi/_3/ya/zi_3yao0kydtrtagdizs4oklcr0.jpeg"><br><br><h2>  <strong>Even faster?</strong> </h2><br>  Let's look into the future.  What to do next, how to be faster? <br><img src="https://habrastorage.org/webt/ts/vc/fz/tsvcfzihzzewt_udo-39cjqea8c.jpeg"><br><br>  On this lineup, block sizes are roughly related to the time it takes. <br><br>  The first thing that comes to mind to people who have heard about baytkod is to immediately go on bytecode to the input and decode it, and not to parse - it will be faster! <br><br><img src="https://habrastorage.org/webt/7i/lf/xd/7ilfxdfdm0dbkdknw0ecpushflo.jpeg"><br><br>  The problem is that the bytecode is different now.  As I said: in Safari one, in FireFox the other, in Chrome the third.  Nevertheless, developers from Mozilla, Bloomberg and Facebook have put forward such a <a href="https://github.com/binast/ecmascript-binary-ast">Proposal</a> , but this is the future. <br><br>  There is another problem - compilation, optimization, and re-optimization, if the compiler did not guess.  Imagine that there is a statically typed input language that produces effective code, and therefore no re-optimization is needed, because what we have received is already effective.  Such an input can only be compiled and optimized once.  The resulting code will be more efficient and faster. <br><br>  What else can you do?  Imagine that there is manual memory management in this language.  Then do not need a garbage collector.  The line has become shorter and faster. <br><br><img src="https://habrastorage.org/webt/e0/36/ut/e036utlk16ybet20xbica5qziey.jpeg"><br><br>  Guess what it looks like?  <strong>WebAssembly is</strong> approximately <br>  and works: manual memory management, statically typed <br>  languages ‚Äã‚Äãand fast execution. <br><img src="https://habrastorage.org/webt/qf/cd/8h/qfcd8hamo_iv_fznbksf35whw9q.jpeg"><br><br>  Is WebAssembly a silver bullet? <br><img src="https://habrastorage.org/webt/ke/ip/pd/keippdq9hmpt3ueb7-kgd-zt1ig.jpeg"><br><br>  No, because it is behind JavaScript.  WASM cannot do anything by itself.  It does not have access to the DOM API.  It is inside the engine for javascript - inside the same engine!  It does everything through JavaScript, so <strong>WASM will not speed up your code</strong> .  It can speed up individual computations, but your exchange between JavaScript and WASM will be a bottleneck. <br><br>  Therefore, so far our language is JavaScript and only it, and some help from the black box. <br><br><h2>  <strong>Total</strong> </h2><br>  There are three types of optimization. <br><br>  ‚óè <strong>Algorithmic optimizations</strong> <br><br>  There is an article " <a href="https://habr.com/post/350018/">Perhaps you do not need Rust to speed up your JS</a> " by Vyacheslav Egorov, who once developed the V8, and is now developing the Dart.  Briefly retell her story. <br><br>  There was a JavaScript library that didn't work very quickly.  Some guys copied it to Rust, compiled it and got WebAssembly, and the application started to work faster.  Vyacheslav Egorov as an experienced JS-developer decided to answer them.  He applied algorithmic optimizations, and the JavaScript solution became much faster than the Rust solution.  In turn, those guys saw it, did the same optimizations, and won again, but not much - it depends on the engine: they won in Mozilla, in Chrome they did not. <br><br>  Today we didn‚Äôt talk about algorithmic optimizations, and front-endiers usually don‚Äôt talk about them.  This is very bad, because the <strong>algorithms also allow the code to run faster</strong> .  You simply remove unnecessary cycles. <br><br>  ‚óè <strong>Language-specific optimizations</strong> <br><br>  This is what we talked about today: our language is interpreted dynamically typed.  Understanding how arrays, objects work, monomorphism <strong>allows you to write efficient code</strong> .  It is necessary to know and write correctly. <br><br>  ‚óè <strong>Engine-specific optimizations</strong> <br><br>  This is the most dangerous optimization.  If your very smart, but not very sociable, developer who applied a lot of such optimizations, and did not tell anyone about them, did not write the documentation, then if you open the code, you will see not JavaScript, but, for example, Crankshaft Script.  That is, JavaScript, written with a deep understanding of how the Crankshaft engine worked two years ago.  It all works, but now is no longer necessary. <br><br>  Therefore, such optimizations must be documented, covered with tests proving their effectiveness at the moment.  They need to follow.  You need to go to them only at the moment when you really slowed down somewhere - you just can‚Äôt do without the knowledge of such deep devices.  Therefore, the famous phrase by Donald Knut seems logical. <br><img src="https://habrastorage.org/webt/yx/xo/1u/yxxo1uda9lkq9fim_uy9zzylxlw.jpeg"><br><br>  No need to try to introduce some kind of tough optimization just because you read positive reviews about them. <br><br>  Such optimizations must be feared, be sure to document and leave the metrics.  In general, always collect metrics.  <strong>Metrics are important!</strong> <br><br>  <strong>Useful links:</strong> <br><br><ul><li>  <a href="http://frontendconf.ru/moscow-rit/2018/abstracts/3386">Theses and presentation of the report</a> </li><li>  <a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">What's up with monomorphism?</a> </li><li>  <a href="https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/">What makes WebAssembly fast?</a> </li><li>  <a href="https://habr.com/company/ruvds/blog/336294/">Understanding the V8 bytecode</a> </li><li>  <a href="https://medium.com/devschacht/hardcore/home">Devshakhta: Hardcore</a> </li></ul><br><blockquote>  <a href="http://frontendconf.ru/moscow/2018/">Frontend Conf Moscow</a> <strong>4  5 </strong>               . <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dfc2018-moscow"> </a> <strong> 15 </strong> ,  ,     : <br><br><ul><li> <strong> </strong> (KeepSolid)  <a href="http://frontendconf.ru/moscow/2018/abstracts/3851"></a> ,    Offline First    Persistent Storage </li><li> <strong> </strong> (TradingView)  <a href="http://frontendconf.ru/moscow/2018/abstracts/3757"></a>    WebGL  WebAssembly  ,        ,  <strong>  API</strong> . </li><li>  <a href="http://frontendconf.ru/moscow/2018/abstracts/3802"></a> <strong> </strong>  ,          Google Docs. <br></li></ul></blockquote></div><p>Source: <a href="https://habr.com/ru/post/417459/">https://habr.com/ru/post/417459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417447/index.html">Expedition to the mysterious fairy circles in the Namib Desert</a></li>
<li><a href="../417449/index.html">Jurassic World: Can we really resurrect dinosaurs?</a></li>
<li><a href="../417451/index.html">Five common mistakes novice managers</a></li>
<li><a href="../417453/index.html">Organization of internships for students: rakes and tricks</a></li>
<li><a href="../417457/index.html">Frontend Conf Moscow - client-side and deep and wide</a></li>
<li><a href="../417461/index.html">Ivan Tulup: asynchronism in JS under the hood</a></li>
<li><a href="../417463/index.html">Unexpected meeting. Chapter 17</a></li>
<li><a href="../417465/index.html">Overview of text entry binding methods</a></li>
<li><a href="../417469/index.html">Five selfish reasons to work reproducibly</a></li>
<li><a href="../417471/index.html">Simple Solder MK936 SMD. DIY soldering station on SMD components</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>