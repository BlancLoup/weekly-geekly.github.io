<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Digest AI Cup. Five strategies for Code Wizards 2016</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In December, the Russian AI Cup 2016 was completed - the annual artificial intelligence programming championship organized by us. Championship for cla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Digest AI Cup. Five strategies for Code Wizards 2016</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/fbc/701/916/fbc7019160844b029eed8d017d912e9e.jpg" alt="image"></p><br><p>  In December, the <a href="http://russianaicup.ru/">Russian AI Cup 2016 was completed</a> - the annual artificial intelligence programming championship organized by us.  Championship for clarity, clarity and simplicity is held in a game format. </p><br><p>  This year, participants created an algorithm - a game strategy for a MOBA game.  The resulting bot fought with others of the same, and the best of them won the round.  Thus, a series of rounds turned out a tournament that takes place in several stages. </p><a name="habracut"></a><br><p>  The alignment of the main prizes at the end of the championship looked like this: </p><br><ol><li>  Anton Chumachenko (Moscow, Russia).  Took first place and won a MacBook Pro. </li><li>  Alexey Dichkovsky ( <a href="https://habrahabr.ru/users/DragoonXen/">@DragoonXen</a> , Grodno, Belarus).  Second place and MacBook Air. </li><li>  Maxim Posazhennikov (Baranovichi, Belarus).  Third place, Apple iPad Air 2. </li></ol><br><p>  Two of the participants have already posted articles on Habr based on RAIC2016 - <a href="https://habrahabr.ru/post/318878/">1</a> , <a href="https://habrahabr.ru/post/318946/">2</a> . </p><br><p>  In addition, there is a special <a href="http://russianaicup.ru/forum/index.php%3Ftopic%3D763.0">thread</a> on the championship forum, where participants shared their experience in writing strategies and told about the key points of their algorithms.  Some of the algorithms turned out to be very interesting, and we are in a hurry to share them with you.  We also selected several understandable articles for you explaining the key principles on which strategies are built. </p><br><p>  It is very difficult to consider a game strategy without knowing the rules of the game.  If you have never heard of the Russian AI Cup, then we recommend to see our first article about it.  Or look at the short rules under the spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Rules of the game</b> <div class="spoiler_text"><p>  To better understand the mechanics of the process, read the brief rules of the championship.  You can view the full version <a href="http://russianaicup.ru/s/1478476322946/assets/documentation/codewizards2016-docs-ru.pdf%3Frnd">on our website</a> . </p><br><p>  The game world is <u>two-dimensional</u> , and all units in it are round.  The game area is bounded by a square, the upper left corner of which has coordinates (0.0, 0.0), and the side length is 4000.0.  No live unit can leave the game area. </p><br><p>  <u>Time in the game is discrete</u> and is measured in ticks.  At the beginning of each tick, the game receives from strategies the desired actions of wizards in this tick and updates the state of wizards in accordance with these desires and limitations of the world.  Then the calculation of the change in the world and objects in it for this tick occurs.  The process is repeated again - with updated data.  The maximum duration of any game is 20,000 ticks, however the game can be terminated early if the team goal of one of the factions is achieved or if the strategies of all the participants have ‚Äúfallen‚Äù.  The "fallen" strategy can no longer control the wizard. </p><br><p>  Detection of units on the map is limited by the <u>fog of war</u> .  The participant's strategy will only receive data about those units that are within the range of view of the wizard himself or any other unit from his faction. </p><br><p>  In the world of Code Wizards, there are <u>six classes of units</u> , some of which, in turn, are divided into types: wizards;  projectiles (magic missile, ice arrow, fireball and dart);  bonuses (gain, acceleration and shield);  buildings (faction base and guard tower): minions (orc-woodcutter and fetish with darts);  trees </p><br><p>  Wizards, buildings, minions, and trees are <u>living units</u> .  Their main characteristics are the current and maximum amount of vital energy.  In the general case, when the vital energy drops to zero, the unit is considered dead and is removed from the game world.  Wizards - the only living units with the ability to regenerate health.  For each tick, they automatically restore a certain amount of vital energy.  The regeneration rate is a real number, as a rule, less than one.  A wizard is considered lost if the integral part of his vital energy drops to zero. </p><br><p>  Every 750 ticks, the base of each faction <u>generates three detachments of minions</u> : one per track.  Each squad consists of three orcs and one fetish.  The detachment immediately rushes along its path to the base of the opposite faction, attacking all opponents on the way.  Wizards use minions as cannon fodder, try to keep themselves in a safe zone and attack the enemy from a distance. </p><br><p>  With a certain probability, <u>neutral minions</u> can appear in forest areas.  Usually they are not aggressive, but when they damage one of them, all neutral minions in the vicinity rush to the offender, attacking anyone who stands in their way. </p><br><p>  Every 2500 ticks on the card may receive a <u>bonus</u> .  If there is already at least one bonus on the card, then a new one will not appear.  The bonus is created at a randomly selected point of the two possible: (1200, 1200) or (2800, 2800).  If any part of the bonus appearance area is already occupied by the wizard, then the simulator will try to create a bonus at the second point.  If unsuccessful, the creation of a bonus will be postponed until the end of the next interval. </p><br><p>  <u>The collision of live units</u> between themselves and with the borders of the card is not allowed by the game simulator.  If the distance from the center of the live unit to the center of the projectile is less than or equal to the sum of their radii, then the live unit takes damage and the projectile is removed from the game world.  In doing so, the fireball explodes and causes damage to all living units nearby.  If the distance from the center of the wizard to the center of the bonus is less than or equal to the sum of their radii, then the wizard for 2400 ticks acquires a magic status depending on the type of bonus. </p></div></div><br><p>  And then - interesting algorithms from the words of the participants themselves: </p><br><h2 id="tyamginhttpshabrahabrruuserstyamgin--ivan-tyamgin-6-e-mesto-v-finale">  <a href="https://habrahabr.ru/users/tyamgin/">@tyamgin</a> - Ivan Tyamgin, 6th place in the final </h2><br><p>  In my strategy, like many, positioning in combat works on <a href="https://habrahabr.ru/post/262181/">potential fields</a> .  This is the simplest thing that could come to mind.  What it looks like: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pTVXVW2sYcI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>(4x acceleration)</em> </p><br><p>  At each point of the map are attracting (+) and repelling (-) fields.  Linear functions depending on the distance to the point / segment.  Here are the main ones: </p><br><p>  (-) enemy wizards <br>  (+) enemy wizards that need to be finished <br>  (-) enemy towers <br>  (+) enemy towers that need to finish <br>  (+) (-) enemy minions to retreat when too close and run up for melee <br>  (-) allied units: just in case there is room for maneuver <br>  (+) place behind the enemy throne <br>  (-) respawn minion points <br>  (+) Point indicating the direction to the bonus: so as not to run towards him at breakneck speed, but to take into account dangerous zones in battle <br>  (-) forest (just repulsive triangles, so as not to go there once again) <br>  (-) map walls and corners <br>  (-) places where they can clamp between the wall and the tower </p><br><p>  At each tick, an offset was chosen to the point where the potential is greater.  The best I‚Äôve come up with to avoid getting into local maxima is to take into account not only the next tick, but 15 ticks ahead (in the chosen direction).  The further the prediction, the less it affected (exponentially decayed). </p><br><p>  <a href="https://habrahabr.ru/post/111361/">Dijkstra's algorithm was</a> used to find the path, the code of which moves from year to year.  The entire map is marked up with an 80 √ó 80 grid. You can navigate in eight directions (adjacent diagonally and laterally).  The fins on which there are trees were fined in proportion to the health of these trees.  Further, after the path is built, it is ‚Äúsmoothed out‚Äù to remove the effects of the partition into the grid, and a list of trees to be cut is built. </p><br><p>  It also took into account the penalty for moving to another Lane, entering deep into the forest, the number of enemies along the way, the final position (as it is advisable to stand on the line behind your minions, and not on the side of the trees). </p><br><p>  For the first round, a more or less finished version of the dodge was used.  Moved 20 directions of departure, and then, whether at the same time to turn.  Then it seemed that everything was taken into account, but later I rewrote everything two times and almost every day I found bugs and shortcomings.  If several projectiles or Fireballs are flying at the same time, then a departure was chosen with minimization of the total damage. </p><br><p>  The main branch of pumping became Fireball.  I went through the angle from which he would be released, and determined what range he should fly.  Also, the Allies were given info about the firebolt just released.  Theoretically, this could be done in a normal way, but I did it through ‚Äúdancing‚Äù: I rounded move.Turn to five characters, the other three decimal places were at my disposal. </p><br><p>  The second branch of the rocked Range, but for the finals made only RangeBonusPassive1, then Haste. </p><br><p>  For the finals to the last did not want to use the scheme 0-5-0.  Began to try with the scheme 2-2-1.  At the beginning of the final week, it even won consistently (for everyone except Commandos, Antmsu, Recar: 50 to 50 with them), but I understood that this was not for long.  Since 0-5-0 did not go, I decided to develop what is.  As a result, in the final, I played the version from 1-3-1 with rebuilding ‚Äúaccording to the situation‚Äù. </p><br><p>  ‚Üí <a href="https://github.com/tyamgin/AiCup/tree/master/CodeWizards">Code</a> </p><br><h2 id="antmsu--anton-chumachenko-1-e-mesto-v-finale">  Antmsu - Anton Chumachenko, 1st place in the final </h2><br><p>  <strong>1st round.</strong>  I went only to the center due to the fact that it is more convenient to take bonuses plus the line is wider.  Since the strategy was implemented through potential fields, in order to avoid lagging between bonuses, a weak attraction force for each of them began to act 700‚Äì800 ticks before their appearance. </p><br><p>  Depending on the location of the minions, the enemy and allied wizards, as well as the enemy tower and its cooldown (I did not take into account these dependencies directly), my wizard chose one of the parties to take the bonus.  And for about 300‚Äì400 ticks, the weaker bonus turned off. </p><br><p>  Near the bonus itself, when there was my wizard and another allied one (if there were more enemies, I still went for the bonus to the last and often died, since the bonus was considered a higher priority than everything else), I used a small ‚Äúkiller feature‚Äù ": I got up at the point between the bonus and the allied wizard, and when he tried to get around me to get closer to the bonus before his appearance, I moved along a smaller radius to be back between the allied wizard and the bonus.  If there were more allies, then it was impossible to do so. </p><br><p>  Also in the first round, he implemented the dodgers, at that time they worked well: most of the wizards fired exactly at the center, and it was easy to run off during the flight of the projectile to the side.  He began to run at the moment of the shot, but not when he saw the enemy magic missile. </p><br><p>  In fact, the more advantageous point for shooting is shifted by about 7-8 pixels from the center towards the turn of the wizard (due to the difference in the speed of movement in different directions).  Later, in order to choose the best point to shoot (within one wizard), I simply went through the corners, starting from the center of +/‚Äì a couple of degrees, just for the case when the enemy wizard is sideways at the moment of the shot. </p><br><p>  At some point, many began to dodge in the top 30 sandboxes, and I also noticed that many are starting to dodge the magic missile at the moment of the shot.  Initially I wanted to collect statistics, who runs a tick earlier, to dodge, and who does not (it depends on whether it is worth shifting the shooting point to move.speed).  But he came up with a simpler solution, which was the chip giving such an advantage in micro.  At that moment, when I could shoot at an enemy wizard, I did not shoot, but waited for one tick.  In most cases, this allowed me to guess the direction of movement in the next moment and get into the evading wizards from a little more distance. </p><br><p>  It is also worth saying that from the very beginning I wrote my own strategy visualizer, without which debugging would take much longer. </p><br><p>  <strong>2nd round.</strong>  The Fireball spell had an indisputable advantage in terms of causing the amount of damage per unit of time, and besides, you can dodge it only if you stand very far away.  Also from the first round, I implemented a melee with minions, so this branch was just perfect compared to others. </p><br><p>  Accordingly, the enemy main building was able to destroy, on average, a little faster than the enemies did.  At the time when I just learned to use this spell, in 35 games out of 42 I won (in 10 * 1 + mode).  Of course, then this branch began to be chosen by many, and there was almost no advantage. </p><br><p>  For the rest, he began to go for the bonuses more carefully, to die less often on them, plus at the beginning of the game he chose the line, where he had the least number of allies, in order to gain experience as quickly as possible.  The micro at that time was not yet finalized, so I did not choose another development branch with the numerical advantage of the enemy on the line, although this would have brought a little more points in the round. </p><br><p>  Most of the time of the second round I spent on simulating all the units on the map to predict whether it is worth going to defend the base or whether it is more profitable to convey the enemy, and also to determine who will shoot the tower at. </p><br><p>  The simulation worked quickly and more or less accurately, but not enough, and in the end I took advantage of it only to throw the Fireball with a lead in the minions for inflicting maximum damage. </p><br><p>  Inaccuracies appeared due to the fact that I did not finish the wizards' behavior.  And besides, the balance turned out to be such that it was rarely beneficial to go to defend oneself.  Also, this simulation could be used to predict whether it is worthwhile to attack or retreat in a mass battle.  In fact, this is solved quite well with the help of the less resource-intensive method ‚Äî the Influence map, which takes into account the effective number of lives, the cooldowns of shots, the auras, the characteristics of the characters, but I managed to implement this method even to the final. </p><br><p>  <strong>The final.</strong>  Right up to the last day, I didn‚Äôt want to go to the 5th by the midpoint, so I tried 1-3-1.  Against the active rush I tried to minimize the time of passage on the side (here the melee branch was the most profitable), and it turned out to be done in about 6 thousand ticks. </p><br><p>  Literally one day before the final, we managed to correct several shortcomings that were present in the strategy from the very beginning: get up in one line in a mass brawl, do not go for bonuses with all wizards, move correctly at increased speed, take into account the effect of speed auras on enemy units to make less misses when fired, and do not chop off extra trees. </p><br><p>  These corrections allowed to fight well 5 √ó 5. Plus, the micro improved slightly due to different coefficients.  I also noticed one feature: the wider the construction, the better on average it was possible to conduct battles, but most likely this was due to the fact that the command selection of the target was not realized and one enemy wizard my five were afraid just like one ( kept at a distance of approximately enemyCastRange + 20). </p><br><p>  ‚ÄúArtificially‚Äù I increased the level of aggression depending on the number of enemy wizards on the line with me.  Before the second part of the final, I couldn‚Äôt manage to get into micro NighTurs, so if several conditions were met by one of the wizards, I would go to another line in the hope that he would destroy the enemy‚Äôs building faster than my opponent‚Äôs five wards would push the four of them along the center line. </p><br><p>  But in the end it worked with a bug, plus luck was not on my side, because before the final with the same versions against NighTurs the score was 5: 0 in my favor, but during the final - 1: 4 in favor of NighTurs (after the final - 2: 0 again in my favor). </p><br><p>  After the finals there was no joyful feeling of the winner: it seemed that the strategy was far from ideal, and the gap from the second and third place was so small that the victory was largely due to luck. </p><br><p>  And the last ‚Äúkiller feature‚Äù: during the years of studying at the university I played a lot of DotA and was not bad at it :) Of course, I joked about the feature, because the playing skills gave only heightened interest at the beginning of the competition. </p><br><h2 id="m0rtidohttpshabrahabrruusersm0rtido--aleksandr-kiselev-12-e-mesto-v-finale">  <a href="https://habrahabr.ru/users/m0rtido/">@ m0rtido</a> - Alexander Kiselev, 12th place in the final </h2><br><p>  The basis of the algorithm is potential fields: we look at 32 points around + below us, we are moving in the best direction.  Initially, the points were not taken at the same distance, but at the maximum step, but I turned in the same direction (and not the direction of the gradient), and the bot very reluctantly walked diagonally.  As a result, I began to always walk in the direction of the antigradient, although now I already think that it was only necessary to turn there, and go to the best available point for the maximum step. </p><br><p>  In order not to fall into a local minimum when walking (he turned off in battle), he added "hills" to his past positions.  The idea is taken from the video: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/22rG3IRuV5U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  In principle, I had four types of fields: the current ‚Äúgoal‚Äù (waypoint, bonus), ‚Äúobstacles‚Äù - the field grew quickly around them, but almost did not grow at a distance, ‚Äúdanger‚Äù and ‚Äútarget‚Äù.  The last field turned off the ‚Äútarget‚Äù field and was a tricky formula that took into account the position of the target and the point of retreat (so as not to run into the forest). </p><br><p>  Danger was calculated for all units differently, but took into account my speed, their cd, attack range, current minion targets, current tower targets, magicians, and turn time for me. </p><br><p><img src="https://habrastorage.org/files/212/cca/49d/212cca49d4a642f0acebd92d592ebdc1.jpg" alt="image"><br>  <em>T1 - the point of retreat, T2 - the goal to which it is drawn, plus its danger</em> </p><br><p>  Like many, for optimization I ‚Äúchopped off‚Äù the world, leaving only significant obstacles and objects. </p><br><p>  I walked along the waypoints + Dijkstra's algorithm, but upgraded them to points that had the "influence" of the teams and the "owner".  To capture a point, it was necessary to hold the influence over it for a certain time with a certain force. </p><br><p><img src="https://habrastorage.org/files/aa9/ff5/4c0/aa9ff54c037f43c2b427c2b47aed6189.gif" alt="image"><br>  <em>Dodges: the most interesting and problematic.</em>  <em>I had three versions.</em> </p><br><p>  First version.  On potential fields, he added a repulsive danger field to every future position of a searchlight.  The main problem: if two projectiles fly at you, then the magician gets up in the middle and catches both. </p><br><p>  The second version.  I modeled a departure in 32 directions + to stand still until I‚Äôve got my head up / put myself up / put up, took where I get less damage (for the dies, the damage was too high).  The remaining directions served the function of walking along potential fields - and lived so happily until the end of the second round. </p><br><p>  Main problem: does not evaluate not yet released projectors.  More danger fields from magicians took into account the caste of hedge, but did not consider that if I am very fast, I can come closer and still dodge everything.  I later used this version of dodging to assess whether to shoot at an enemy or not.  If the damage on it before the addition of the "probabilistic" MM to the world is less than after, then I shot. </p><br><p>  Then he began to add more projectors from Allied wizards, ready to shoot the next 5 ticks.  This slightly increased the accuracy and cunning of shooting in groups.  I fired not at the center, but at a point from which to run in all directions the same time: </p><br><pre><code class="html hljs xml">public static V2d getShootPoint(V2d aimPos, V2d aimAngle, double projectileRadius) { return aimAngle.copy().mul((projectileRadius + 35.0d) / 7.0d).add(aimPos); }</code> </pre> <br><p>  Third version.  In the collection of projectors added those that can be released by magicians in the next 50 ticks.  For each direction, they generated their own, so that the magician would always shoot at the most inconvenient point. </p><br><p>  Went around like this: </p><br><ul><li>  first tried to dodge all real projectiles in 32 (+1) directions, while creating projectiles, "probabilistic" as you move; </li><li>  if the projectile hit me in that direction - added its damage; </li><li>  if I got into the field of the tower, and I was there a target, and cd = 0, then I added more damage from the tower; </li><li>  if no projectile hit me anymore, then from this direction I would start a new search again in 32 (+1) directions of already ‚Äúprobabilistic‚Äù projectiles until I dodge all of them or face an obstacle. </li></ul><br><p>  I added damage from ‚Äúprobabilistic‚Äù projectiles with exponential attenuation over the distance that the projectile would fly over, so that the magician would run away from the too close mages, but did not think: ‚ÄúWhat difference does it make that they fall on the border one pixel from the safe zone?‚Äù . </p><br><p>  This is the most difficult and the most crutch part of the project, because you had to edit a lot, finish, remove extra fearfulness, check when you can turn for a shot, and when you need to dodge 100% (if I couldn‚Äôt dodge real project files, then I didn‚Äôt even rip ).  Do crutches on the fact that the magician may slightly run up. </p><br><p><img src="https://habrastorage.org/files/d17/254/b47/d17254b47e4e4a2daac04b428b42dc0d.gif" alt="image"></p><br><p>  Here is the third version allowed to remove the field of danger of the wizard, come closer to it and still dodge the shots (even those that have not yet been made). </p><br><p>  This is probably the basis of the algorithm.  Of course, there were a lot of ticks, I fell in time with the third failures, a lot of errors and bugs in the constants, some bugs in the constants made me rise almost instantly 10-20 places higher (in the top 100). </p><br><h2 id="ivlevastefhttpshabrahabrruusersivlevastef--aleksandr-ivlev-proshel-vo-vtoroy-raund">  <a href="https://habrahabr.ru/users/ivlevAstef/">@ivlevAstef</a> - Alexander Ivlev, passed to the second round </h2><br><p>  Conventionally, I will divide the algorithm into two parts. </p><br><p>  The first part of the algorithm is obstacle avoidance.  The second part uses the first, but solves problems with cutting down trees and estimating the length of the path (the first was able to bypass, but could not estimate the distance to the point). </p><br><p>  First: <br>  In fact, this is not a search for a path - this is a quality bypass of obstacles.  The algorithm is built around groups of related objects and tangents to them. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lHjqjRJodog" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  If you watch the video, you can see that there are a lot of purple lines between the trees.  These lines are not present in the algorithm, but they were created to visualize groups.  At the very beginning of the video and at the 40th second, where the magician goes into the forest, it is very clearly seen that we have two large groups in the ‚Äúleft‚Äù forests, the magician between them and passes at the 40th second. </p><br><h3 id="algoritm-postroeniya-grupp">  Algorithm for building groups </h3><br><p>  We have a set of objects and a set of groups, which is initially empty. </p><br><p>  We take an object from a variety of objects and check if it falls into one group (it is close to one of the group objects) - then we add it there.  If more than one, then we merge these groups and add a new object to the new group. </p><br><p>  Next, we determine where to move in the current tick.  At the entrance we have a lot of groups, a mage and a point where we want to go.  I would call this algorithm this way - throwing rays, although in reality, all the same, these are not rays, but segments: they have a maximum length. </p><br><p>  First, we throw the beam to the point where we want to go.  We find the intersection with the group (object from the group), which is closest to us.  We pass through all the objects of the group, consider both internal tangents to each object of the group and find those that will give the maximum angle of deviation from the current beam - there will be two (one to the left, the other to the right). </p><br><p>  Further, according to the magic logic (in the first variant of the algorithm, the function of choosing from two tangents was difficult, because choosing the one that gives the smallest deflection angle is very bad: when you come close to the edge of the group, this angle often becomes maximum) choose one of the two.  The touch point (taking into account, however, the radius of the magician) will be our new point to go.  After that, we again throw the beam, but at a new point, after removing the group with which we have already crossed. </p><br><p>  The first algorithm had several flaws.  I did not like the function, which tangent to take from two;  I could not estimate the distance to the point;  did not cut trees. </p><br><p>  The second algorithm used the same function to bypass obstacles, but before that he considered an approximate path and removed trees from it. </p><br><p>  First, I took <a href="https://habrahabr.ru/post/264189/">the Lee algorithm</a> (wave) and built a wave from myself on the whole map (the map is represented by a 125 √ó 125 grid).  Buildings and minions were considered impassable, but the trees simply had an overpriced passage price depending on their hp and distance from the center (the tree can fall on several cells at the same time, and it would be illogical to mark all these cells with the same weight). </p><br><p>  Those who are familiar with the Lee algorithm will be indignant: this algorithm is able to find a way, but not take into account the cost of the transition, and they will be right.  For this reason: <br>  a) I considered the wave to the whole map; <br>  b) the algorithm was slightly crossed with Dijkstra.  In fact, it can even be called Dykstra, but not Lee, where the graph is represented as a 2d-array. </p><br><p>  In general, it is difficult to say that this is Lee or Dijkstra, for the detour I used is from Dijkstra, but with optimization, and I kept the data as for Lee. </p><br><p>  As a result, we have a map, we can find from any point the best way to the mage.  Since we sometimes need to look at several paths for a tick, this also had an advantage over a *, which for each path needs to be recalculated again.  And for full optimization, I also update the card itself every 60 ticks.  If a cell changed over 60 ticks (which always happened several times), then I used a quick update: the previous cell overestimated the weight, and the new one underestimated it. </p><br><p>  The next stage is to cross it with part one ... Everything is simple, take our path, cross it with a circle with a radius of 300 (I don‚Äôt remember why I chose this one, at first it was 600);  the intersection point is the point to which we will consider obstacle avoidance.  The solution helped to simplify the old bypass algorithm, since now it was possible to take the minimum angle of displacement from the direction vector: the vector itself was short and already indicated where to go. </p><br><p>  The last stage is felling the forest.  At the entrance there is a path represented as a segment of small length (built on the basis of a 125 √ó 125 grid), and a multitude of trees.  Task: to find trees that can be quickly cut down, which cannot be passed around and next to which (or through which) the path passes.  The algorithm is simple, but there is a bug in it - sometimes it cuts too much.  When I did it, I already understood all the meaninglessness of what was written and did not catch up with him to the ideal. </p><br><p>  Algorithm: go along the path and find the tree that is closest to our current segment.  We are convinced that this tree actually suits us (it cannot be bypassed).  To do this, figuratively divide the playing field into two parts: on one side of the path and on the other.  If there is such a tree that belongs to the other side of the path, and if it is impossible to pass between these two trees, then the current tree must be demolished. </p><br><p>  There is a problem: in places where the path passes close to the middle of a tree, the tree ends up in the wrong half of the way.  As a result, simply did not solve this problem, because it is not fatal. </p><br><p>  Why does all this work?  When a path is built, it passes in such a way that the radius of the tree affects the price non-linearly.  Therefore, trees that are easily cut down are estimated as if there are almost none (very small price), and large trees are comparable to almost impassable points.  And as the weight of the tree fades with time, in most cases the path goes between the trees, but closer to the smaller ones.  Due to this, a small tree is chosen as a log house.  Traversing now goes not globally, but locally (radius 300), and those trees that need to be cut down, I delete when searching for groups (so that the obstacle was calculated without them), so the first part of the algorithm shows itself even more: it does not need go around obstacles for miles, she passes them here and now. </p><br><p>  Almost the final version of the movement can be viewed on the video: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VUH_yNDKNXw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  But in real life is not so good.  Sometimes the point where to run changes right in the middle of the forest, sometimes the creeps are chasing you and you have to choose: either to chop down the forest, or to beat the creep ... and many more minor factors. </p><br><p>  ‚Üí <a href="https://github.com/ivlevAstef/CodeCupAI2016MOBA">Link to code</a> </p><br><p>  The path search is in the Algorithms / A_PathFinder files.  Obstacle avoidance - in Algorithms / A_Move.  Building groups is in Environment / E_World. <br>  Various 2D mathematics - in Common / C_Math. </p><br><p>  And a couple of words about the other side of the Olympiad - about time: </p><br><ul><li>  first week - 26 hours; </li><li>  second week - 26 hours; </li><li>  third week - 27 hours; </li><li>  fourth week - 34.5 hours; </li><li>  the fifth week is 38.5 hours; </li><li>  in the sixth week I scored, there is very little - 10 hours; </li><li>  last week - 8 hours. </li></ul><br><p>  Total: 170 hours. </p><br><p>  On the search path I killed: 49 hours. <br>  To maintain its architecture in a more or less normal state (about 70 classes - 140 C ++ files): 28 hours. <br>  Turns off: 26 hours. </p><br><p>  Everything else: 67 hours - edits of bugs, adjusting coefficients and other more boring things (line selection, danger map, understanding when to attack and when to run away). </p><br><h2 id="alexks--aleksandr-kolganov-proshel-vo-vtoroy-raund">  ALEXks - Alexander Kolganov, passed to the second round </h2><br><p>  <strong>Concept: it</strong> was based on a set of states in which a strategy can move depending on the conditions and the current situation.  Such states can be: movement to a bonus, attack, finishing with a tower, dodging from an attack, etc. Each state can affect other states ‚Äî in most cases, override (cancel) the effect of the state.  Since the code is actually linear, all the states are simply checked each time and those that have the conditions are activated.  For example, if we are standing on the line and it is time to take a bonus, then in addition to the time, various conditions are checked: is the upcoming front coming, are we having advantages, are we within the zone where we can withdraw for the bonus, or bring the base. </p><br><p>  <strong>Some mistakes:</strong> it is possible that because of this amount of properties, there was really not enough time for detailed implementation, so almost until the last moment the movement was very clumsy: the key points from the quick start strategy + the ability to move back, but then it was fixed. </p><br><p>  Also, for some reason I did not think that damage could be inflated further than the distance of the caste, and much further.  Almost before the start of the second round, many did not take into account this fact, and everything was OK, but then my stratum began to lose, and I began to notice that I could attack from a greater distance, and also somewhere on the forum it sounded too. </p><br><p>  <strong>Movement: the</strong> main point is the recursive function, which allowed calculating to a depth of 6 ticks on a 7 √ó 6 grid and a threshold of 25%.  The essence is this: we go through all the steps to the maximum distance around us on the grid, seven steps along the long side (forward and back) and six along the short side (left and right) and evaluate this position: can we stand on it, and if so, do we impose different fines and bonuses - this is exactly the place where there is a use of PP.  Next on the threshold we screen out this set of points according to the evaluation function and repeat the recursion for the remaining ones.  The evaluation functions are linear depending on the distance, and the attack of the opponents, the cooldown before the attack, the radius of the trees were taken into account - and even an attempt was made to take the Allied minions into account so as not to get stuck.  Also, the movements of all other units are also simulated for 6 ticks, but in the direction and with the same speeds that were recorded before the recursive procedure was started.  The trees were also fine.  If there were no enemy units around, the miscalculation was simplified to save time. </p><br><p>  Some wrote above that recursion is a long process due to nesting and multiple distance calculations.  Through the profiler, I saw that the hypot (x, y) function took all the time in this procedure and, having run the net, I found that it works much longer (about 40 times) than the simple sqrt (x <em>x + y</em> y).  In this case, where the coordinates lie in the range 0 ... 5000, the hypot function is not needed at all (I suggest the reader to look for himself why hypot is better than sqrt).  And in the end I decided to abandon the extraction of the root, where it is possible, and thus translated everything to the sum of squares.  After all, even the distance between units can be estimated without calculating the root: the sum of squares is sufficient.  Multiplications and additions are performed faster than root extraction; as a result, it became possible to count to 6‚Äì7 ticks with a sufficiently detailed grid (or tree), and at the last level there could be 3-6 points. </p><br><p>  The only negative - I could be in a local minimum between the trees and often stuck.  The reason is that the allowable distance to the trees themselves is too close, as well as a small number of ticks of the recursive function.  I did not struggle with this, but decided to make sure that my magician would destroy trees that might prevent him in the future. </p><br><p>  After changing the balance after the first round, I kept around the top 30-50.  For 5 √ó 5 battles, I also tried many tactics, but I stopped at five in the center, and this was both better and faster.  But again - there was a lack of a more accurate assessment of the opponent.  The penalties were too rough for the top 20. </p><br><p>  Strangely enough, for some reason I decided that fire was not the best option, because if you do not give the enemy fire on the line and speed up the attack speed and speed of attack, then you become positive.  I tried different tactics, and through speed + frieze, and through fire + range.  All of them are in the code.  For 5 √ó 5, I wore one mage for a range + speed, the rest for fire. </p><br><p>  <a href="https://bitbucket.org/ALEXks/wizards/overview">Link to the code</a> (for some reason, in this project and only in this I decided to write Russian comments; there is quite a lot of commerce, and I think you can figure it out very easily, wrote in C ++). </p><br><h2 id="russian-ai-cup-zakonchilsya-chto-dalshe">  Russian AI Cup is over.  What's next? </h2><br><p>  Now we are conducting a series of ML championships on our <a href="http://mlbootcamp.ru/">ML Boot Camp</a> platform.  In it there is a place for everyone: from a beginner to a professional.  For beginners, we offer training articles on machine learning, and the pros - a serious test of strength by our task.  <a href="http://mlbootcamp.ru/signup/">Join us</a> , the next championship in a couple of weeks! </p><br><p>  The latest news about all the championships organized by the Mail.Ru Group can be found in the <a href="https://t.me/mailrucontests">official telegram group</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325050/">https://habr.com/ru/post/325050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325034/index.html">IL2CPP: Garbage Collector Integration</a></li>
<li><a href="../325036/index.html">Regular expression search with suffix array</a></li>
<li><a href="../325040/index.html">Good trigger, bad trigger: how we monitor hundreds of servers around the world</a></li>
<li><a href="../325042/index.html">Welcome to Go meetup April 14</a></li>
<li><a href="../325046/index.html">What would i change in go</a></li>
<li><a href="../325052/index.html">Technocup: results of the final round and task analysis</a></li>
<li><a href="../325054/index.html">25 interesting books for designers in the public domain</a></li>
<li><a href="../325056/index.html">‚ÄúIt is expensive for us‚Äù - retail about acquiring</a></li>
<li><a href="../325058/index.html">User Interface Cards</a></li>
<li><a href="../325062/index.html">How to collect statistics from the website and not to fill yourself cones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>