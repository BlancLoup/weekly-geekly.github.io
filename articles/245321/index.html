<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating World of Tanks Blitz based on your own engine DAVA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 
 This story began more than three years ago. Our small company DAVA became part of Wargaming, and we began to think about what projects to d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating World of Tanks Blitz based on your own engine DAVA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/438/1e6/5c8/4381e65c8f988e178164483a1fc51f43.jpg" alt="image"><br><br><h4>  Prologue </h4><br>  This story began more than three years ago.  Our small company DAVA became part of Wargaming, and we began to think about what projects to do next.  To remind you how mobile it was three years ago, I‚Äôll say that at that time there was neither Clash Of Clans, Puzzle &amp; Dragons, nor many projects that are very well-known today.  Mid-core then just started.  The market was several times smaller than today. <br><br>  Initially, it seemed to everyone that it would be a very good idea to make several small games that would attract new users to large ‚Äútanks‚Äù.  After a series of experiments, it turned out that this does not work.  Despite excellent conversions in mobile applications, the transition from mobile phone to PC turned out to be an abyss for users. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Then we had a few games in development.  One of them bore the working name "Sniper".  The main gameplay-idea was shooting in a sniper mode from a tank standing in defense, at other tanks that were controlled by AI and which could attack in response. <br><br>  At some point, it seemed to us that standing tank was very boring, and in a week we made a multiplayer prototype, where tanks could already drive and attack each other. <br><br>  Since this all started! <br><br>  When we started developing the Sniper, we looked at technologies that were then available for mobile platforms.  At that time, Unity was still at a fairly early stage of its development: in fact, we did not have the technology needed. <br><br>  The main thing that we lacked was the rendering of the landscape with dynamic detailing, which is vital for creating a game with open spaces.  There were several third-party libraries for Unity, but their quality left something to be desired. <br><br>  We also understood that in C # we will not be able to squeeze the most out of the devices we are developing for, and we will always be limited. <br>  Unreal Engine 3 also did not fit for a number of similar reasons. <br><br>  As a result, we decided to refine our engine! <br><a name="habracut"></a><br>  He was at that time already used in our previous casual projects.  The engine had a fairly well written low level of work with platforms and supported iOS, PC, Mac, plus work began on Android.  Much functionality has been written to create 2D games.  That is, there was a good UI and a lot of things to work with 2D.  It was the first steps in the 3D part, since one of our games was completely three-dimensional. <br><br>  <b>What we had in the 3D part of the engine:</b> <br><br><ul><li>  The simplest scene graph. </li><li>  The ability to draw static meshes. </li><li>  The ability to draw animated meshes with skeletal animation. </li><li>  Exporting objects and animations from the Collada format. </li></ul><br>  In general, if we talk about the functionality of a serious modern engine, there was very little in it. <br><br><h4>  Beginning of work </h4><br>  It all started with the proof of the possibility to draw the landscape on mobile devices: then it was the iPhone 4 and iPad 1. <br><br>  After several days of work, we got quite a functional dynamic landscape, which worked quite tolerably, required about 8MB of memory and gave 60fps on these devices.  After that, we began a full development of the game. <br><br>  About half a year has passed, and the small mini-project has turned into what Blitz is now.  There were completely new requirements: MMO, AAA-quality and other requirements that the engine in its original form at that time could not provide.  But work was in full swing.  The game worked and worked well.  However, the performance was average, there were few objects on the maps, and, in fact, there were many other limitations. <br><br>  At this stage, we began to understand that the foundation that we laid in the engine will not sustain the press of a real project. <br><br><h5>  How it all worked at that time </h5><br>  All scene rendering was based on the simple concept of Scene Graph. <br><br>  The main concepts were two classes: <br><br><ul><li>  Scene - the container of the scene, inside which all the actions took place. </li><li>  above the stage. </li><li>  SceneNode is the base class of the scene node, from which all classes that were in the scene inherit: </li><li>  MeshInstanceNode - class for drawing meshes. </li><li>  LodNode is a class for switching LODs. </li><li>  SwitchNode - class for switching switch objects. </li><li>  about 15 more classes of SceneNode heirs. </li></ul><br>  The SceneNode class allowed redefining a set of virtual methods to implement some kind of custom functionality: <br>  The main functions that could be overridden are: <br><br><ul><li>  Update - the function that was called for each node in order to make Update-scenes. </li><li>  Draw is a function that was called for each node in order to draw this node. </li></ul><br>  The main problems we encountered. <br><br>  First, the performance: <br><br><ul><li>  When the number of nodes in the level reached 5000, it turned out that it would take about 3ms to simply go through all the empty Update functions. </li><li>  Similar time was spent on empty nodes that did not require Draw. </li><li>  A huge number of cache-misses, since the work was always done with different types of data. </li><li>  The inability to parallelize work on multiple cores. </li></ul><br>  Secondly, unpredictability: <br><br><ul><li>  Changing the code in the base classes influenced the entire system, that is, every SceneNode :: Update change could break anything, anywhere.  Dependencies became harder and harder, and every change inside the engine almost guaranteed to require testing all the related functionality. </li><li>  It was impossible to make a local change, for example, in transformations, so as not to hurt the rest of the scene.  Very often, the slightest changes in LodNode (node ‚Äã‚Äãfor switching Lods) broke something in the game. </li></ul><br><h4>  First steps to improve the situation </h4><br>  To begin, we decided to treat performance problems and do it quickly. <br><br>  Actually, we did this by entering an additional NEED_UPDATE flag in each node.  It determined whether such a node should call Update.  This really improved performance, but created a whole bunch of problems.  In fact, the Update function code looked like this: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SceneNode::Update(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeElapsed) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(flags &amp; NEED_UPDATE))<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// the rest of the update function // process children }</span></span></code> </pre> <br>  This returned some of the performance to us, but many logical problems started where they were not expected. <br><br>  LodNode, and SwitchNode ‚Äî nodes that are responsible for switching Lods (by distance) and switching objects (for example, destroyed and intact), respectively ‚Äî began to break down regularly. <br><br>  Periodically, the one who tried to fix the breakdowns did the following: disconnected NEED_UPDATE in the base class (after all, it was a simple solution), and completely imperceptibly the FPS fell again. <br><br>  When the code checking the NEED_UPDATE flag was commented out three times, we decided to make radical changes.  We understood that we could not do everything at once, so we decided to act in stages. <br><br>  The very first step was to lay the architecture, which will allow in the future to solve all the problems we have. <br><br><h5>  Goals </h5><br><ul><li>  Minimizing dependencies between independent subsystems. </li><li>  Changes in transformations should not break the system of Lods, and vice versa. </li><li>  Ability to put code on multi-core. </li><li>  That there were no functions Update or similar, in which the heterogeneous independent code was executed.  Easy extensibility of the system with new functionality without full retesting of the old one.  Changes in some subsystems do not affect others.  Maximum independence of subsystems. </li><li>  The ability to arrange data linearly in memory for maximum performance. </li></ul><br>  The main goal at the first stage was to redesign the architecture so that all these goals could be fulfilled. <br><br><h4>  Combining the component and data-driven approach </h4><br>  The solution to this problem was a component approach, combined with a data-driven approach.  Further on, I will use the data-driven approach because I have not found a successful translation. <br><br>  In general, the understanding of the component approach for many people is very different.  Same with data-driven. <br><br>  In my understanding, the <b>component approach</b> is when some necessary functionality is built on the basis of independent components.  The simplest example is electronics.  There are chips, each chip has inputs and outputs.  If the chips fit together, they can be connected.  Based on this approach, the entire electronics industry has been built.  There are thousands of different components: connecting them together, you can get completely different things. <br><br>  The main advantages of this approach are that each component is isolated, and with more independent.  I do not take into account the fact that the component can submit incorrect data, and the board will burn.  The advantages of this approach are obvious.  Today you can take a huge number of ready-made chips and assemble a new device. <br><br>  What is <b>data-driven</b> ?  In my understanding, this is an approach to software design, when data, rather than logic, is taken as the basis for the program flow. <br><br>  In our example, we represent the following class hierarchy: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SceneNode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//      Matrix4 localTransform; Matrix4 worldTransform; virtual void Update(); virtual void Draw(); Vector&lt;SceneNode*&gt; children; } class LodNode { //  c    LodDistance lods[4]; virtual void Update(); //   Update,       ,    -    virtual void Draw(); //      }; class MeshNode { RenderMesh * mesh; virtual void Draw(); //   };</span></span></code> </pre><br>  The bypass code for this hierarchy hierarchically looks like this: <br><br><pre> <code class="cpp hljs">Main Loop: rootNode-&gt;Update(); rootNode-&gt;Draw();</code> </pre><br>  In this hierarchy of C ++ inheritance, we have three different independent data streams: <br><br><ul><li>  Transformations </li><li>  Lody </li><li>  Meshes </li></ul><br>  Nodes only unite them in a hierarchy, but it is important to understand that it is better to process each data stream sequentially.  The practical need for processing across the hierarchy is only needed for transformations. <br><br>  Let's imagine how this should look like in a data-driven approach.  I will write in pseudocode so that the idea is clear: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Transform Data Loop: for (each localTransform in localTransformArray) { worldTransform = parent-&gt;worldTransform * localTransform; } // Lod Data Loop: for (each lod in lodArray) { // calculate lod distance and find nearest lod nearestRenderObject = GetNearestRenderObject(lod); renderObjectIndex = GetLodObjectRenderObjectIndex(lod); renderObjectArray[renderObjectIndex] = renderObject; } // Mesh Render Data Loop: for (each renderObject in renderObjectArray) { RenderMesh(renderObject); }</span></span></code> </pre><br>  In fact, we expanded the program's work cycles, having done this in such a way that everything was repelled by the data. <br><br>  Data in a data-driven approach is a key element of the program.  Logic is only data processing mechanisms. <br><br><h4>  New architecture </h4><br>  At some point, it became clear that we had to go towards the Entity-based approach to organizing the scene, where Entity was an entity consisting of many independent components.  I wanted the components to be completely arbitrary and easily combined with each other. <br><br>  Reading the information on this topic, I came across the <a href="http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/">blog T-Machine</a> . <br><br>  He gave me many answers to my questions, but the main answer was the following: <br><br>  ‚Ä¢ Entity contains no logic, it is just an ID (or pointer). <br>  ‚Ä¢ Entity knows only the ID components that belong to it (or the pointer). <br>  ‚Ä¢ A component is only data, that is.  component does not contain any logic. <br>  ‚Ä¢ A system is a code that can process a specific data set and output another data set at the output. <br><br>  When I realized this, in the process of further studying various information I came across the <a href="http://gamadu.com/artemis/">Artemis Framework</a> and saw a good implementation of this approach. <br>  Sources here if the previous link does not work: <a href="https://code.google.com/p/artemis-framework/">Artemis Original Java Source Code</a> <br><br>  If you are developing in Java, I highly recommend looking at it.  Very simple and conceptually correct Framework.  Today it is sported in a bunch of languages. <br><br>  What Artemis is is called ECS (Entity Component System) today.  There are quite a few options for organizing scenes based on Entity, components and data-driven, but we finally came to the ECS architecture.  It is difficult to say how common the term is, but ECS means that there are the following entities: <a href="http://en.wikipedia.org/wiki/Entity_component_system">Entity, Component, System.</a> <br><br>  The most important difference from other approaches is: The <b>obligatory absence of logic of behavior in the components, and the separation of code in the systems.</b> <br><br>  This point is very important in the ‚ÄúOrthodox‚Äù component approach.  If you break the first principle, there will be a lot of temptations.  One of the first is to make component inheritance. <br><br>  Despite the flexibility, it usually ends in pasta. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7f/bed/326/b7fbed326513c263ca2d0d2912b2ee27.jpg" alt="image"><br><br>  Initially, it seems that with this approach it will be possible to make a lot of components that behave in a similar way, but a little differently.  Common component interfaces.  In general, you can again fall into the trap of inheritance.  Yes, it will be slightly better than the classical inheritance, but try not to fall into this trap. <br><br>  ECS is a cleaner approach, and solves more problems. <br><br>  To see an example of how this works in Artemis, you can look <a href="http://gamadu.com/artemis/tutorial.html">here</a> . <br><br>  I will show you with an example of how this works for us. <br><br>  <b>The main container class is Entity.</b>  This is the class that contains the array of components. <br><br>  <b>The second class is Component.</b>  In our case, this is just data. <br><br>  Here is a list of components used in our engine today: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> eType { TRANSFORM_COMPONENT = <span class="hljs-number"><span class="hljs-number">0</span></span>, RENDER_COMPONENT, LOD_COMPONENT, DEBUG_RENDER_COMPONENT, SWITCH_COMPONENT, CAMERA_COMPONENT, LIGHT_COMPONENT, PARTICLE_EFFECT_COMPONENT, BULLET_COMPONENT, UPDATABLE_COMPONENT, ANIMATION_COMPONENT, COLLISION_COMPONENT, <span class="hljs-comment"><span class="hljs-comment">// multiple instances PHYSICS_COMPONENT, ACTION_COMPONENT, // actions, something simplier than scripts that can influence logic, can be multiple SCRIPT_COMPONENT, // multiple instances, not now, it will happen much later. USER_COMPONENT, SOUND_COMPONENT, CUSTOM_PROPERTIES_COMPONENT, STATIC_OCCLUSION_COMPONENT, STATIC_OCCLUSION_DATA_COMPONENT, QUALITY_SETTINGS_COMPONENT, // type as fastname for detecting type of model SPEEDTREE_COMPONENT, WIND_COMPONENT, WAVE_COMPONENT, SKELETON_COMPONENT, //debug components - note that everything below won't be serialized DEBUG_COMPONENTS, STATIC_OCCLUSION_DEBUG_DRAW_COMPONENT, COMPONENT_COUNT };</span></span></code> </pre><br>  <b>The third class is the SceneSystem:</b> <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/** \brief This function is called when any entity registered to scene. It sorts out is entity has all necessary components and we need to call AddEntity. \param[in] entity entity we've just added */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity * entity)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** \brief This function is called when any entity unregistered from scene. It sorts out is entity has all necessary components and we need to call RemoveEntity. \param[in] entity entity we've just removed */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity * entity)</span></span></span></span>;</code> </pre><br>  The functions RegisterEntity, UnregisterEntity are called for all systems in the scene when we add or remove Entity from the scene. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/** \brief This function is called when any component is registered to scene. It sorts out is entity has all necessary components and we need to call AddEntity. \param[in] entity entity we added component to. \param[in] component component we've just added to entity. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity * entity, Component * component)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** \brief This function is called when any component is unregistered from scene. It sorts out is entity has all necessary components and we need to call RemoveEntity. \param[in] entity entity we removed component from. \param[in] component component we've just removed from entity. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity * entity, Component * component)</span></span></span></span>;</code> </pre><br>  The functions RegisterComponent, UnregisterComponent are called for all systems in the scene, then when we add or remove the Component in the Entity in the scene. <br>  Also for convenience, there are two more functions: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/** \brief This function is called only when entity has all required components. \param[in] entity entity we want to add. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity * entity)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** \brief This function is called only when entity had all required components, and don't have them anymore. \param[in] entity entity we want to remove. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity * entity)</span></span></span></span>;</code> </pre><br>  These functions are called when an ordered set of components has already been created using the SetRequiredComponents function. <br><br>  For example, we can order to get only those Entities that have ACTION_COMPONENT and SOUND_COMPONENT.  I transfer it in SetRequiredComponents and - voila. <br><br>  In order to understand how this works, I will sign off with examples of what systems we have: <br><br><ul><li>  TransformSystem - a system that is responsible for the hierarchy of transformations. </li><li>  SwitchSystem is a system that is responsible for switching objects that may be in several states, such as destroyed and undestroyed. </li><li>  LodSystem is a system that is responsible for switching lods by distance. </li><li>  ParticleEffectSystem - a system that updates the effects of particles. </li><li>  RenderUpdateSystem is a system that updates render objects from the scene graph. </li><li>  LightUpdateSystem is a system that updates light sources from a scene graph. </li><li>  ActionUpdateSystem is a system that updates actions. </li><li>  SoundUpdateSystem is a system that updates sounds, their position and orientation. </li><li>  UpdateSystem - the system that causes custom user updates. </li><li>  StaticOcclusionSystem - a system for applying static occlusion. </li><li>  StaticOcclusionBuildSystem - a system for building a static occluded. </li><li>  SpeedTreeUpdateSystem - Speed ‚Äã‚ÄãTree update system. </li><li>  WindSystem - a system for calculating wind. </li><li>  WaveSystem - a system for calculating oscillations from vzirvov. </li><li>  FolliageSystem - a system for calculating vegetation over the landscape. </li></ul><br>  The most important result that we have achieved is a high decomposition of the code responsible for dissimilar things.  Now in the TransformSystem :: Process function, all the code that concerns transformations is clearly localized.  He is very simple.  It is easy to decompose into several cores.  And most importantly, it is difficult to break something in another system by making a logical change in the system of transformations. <br><br>  In almost any system, the code looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (  ) { <span class="hljs-comment"><span class="hljs-comment">//    //      //     }</span></span></code> </pre><br>  Systems can be classified according to how they process objects: <br><br><ul><li>  The processing of all objects that are in the system is required: <ul><li>  Physics </li><li>  Collisions </li></ul><br></li><li>  Only the handling of tagged objects is required: <ul><li>  Transformation system </li><li>  System of actions </li><li>  Sound processing system </li><li>  Particle handling system </li></ul><br></li><li>  Work with your specially optimized data structure: <ul><li>  Static Occlusion System </li></ul></li></ul><br>  With this approach, in addition to the fact that it is very easy to process objects into several kernels, it is very easy to do what is quite difficult to do in the usual polymorphism-paradigm.  For example, you can easily take and process not all lod-switches per frame.  If there are a lot of objects in a large open world, you can make each frame process one third of the objects.  However, this does not affect other systems. <br><br><h4>  Total </h4><br><ul><li>  We greatly increased the FPS, as with the component approach things became more independent and we were able to untie and optimize them separately. </li><li>  The architecture has become more simple and understandable. </li><li>  It became easy to expand the engine, almost without breaking neighboring systems. </li><li>  There are fewer bugs from the series ‚Äúhaving done something with LODs, they broke the switches‚Äù, and vice versa </li><li>  Now it is possible to parallelize everything into several cores. </li><li>  At the moment, we are already working to run all systems on all available cores. </li></ul><br>  The code of our engine is in Open Source.  The engine in the form in which it is used in World of Tanks Blitz, is <a href="https://github.com/dava/dava.framework">fully available online on github</a> . <br><br>  Accordingly, if there is a desire, you can go and look at our implementation in detail. <br><br>  Consider the fact that everything was written in a real project, and, of course, this is not an academic implementation. <br><br><h4>  Future plans: </h4><br><ul><li>  More efficient management of these components, that is, decomposing these components linearly in memory, to minimize cache missions </li><li>  Transition to multitasking in all systems. </li></ul><br>  All useful links from the text last: <br><br><ul><li>  <a href="http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/">Why entity systems are good</a> </li><li>  <a href="http://gamadu.com/artemis/tutorial.html">A beautiful academic example of the Entity-Component-System-approach</a> </li><li>  <a href="https://github.com/dava/dava.framework">Our engine</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/245321/">https://habr.com/ru/post/245321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245307/index.html">How ‚Äúdon't know‚Äù the game did</a></li>
<li><a href="../245311/index.html">Extending large missing parts of the image in photoshop: multigradient</a></li>
<li><a href="../245315/index.html">How to vote directly in PowerPoint?</a></li>
<li><a href="../245317/index.html">The dynamics of the situation: how it was in 2008</a></li>
<li><a href="../245319/index.html">Peter Thiel: Competition - the lot of losers</a></li>
<li><a href="../245323/index.html">IPv6 addresses via EUI-64: Points above i</a></li>
<li><a href="../245325/index.html">Navigation in rooms with iBeacon and INS</a></li>
<li><a href="../245331/index.html">Down with the absolute units in the icons, sprites</a></li>
<li><a href="../245333/index.html">How to rasp the class file</a></li>
<li><a href="../245335/index.html">Hotel rakes: what you need to know in advance if you are doing a conference room</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>