<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A revolution in javascript. Literally</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today is April 22, the anniversary of 2017, the birthday of a person, without which the events would not have happened a hundred years ago. So, there ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A revolution in javascript. Literally</h1><div class="post__text post__text-html js-mediator-article">  Today is April 22, the anniversary of 2017, the birthday of a person, without which the events would not have happened a hundred years ago.  So, there is a reason to talk about revolutionary history.  But where is Habr?  - It turned out that everything in this world can have the most unexpected connection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c6/575/61c/3c657561ce33972affe4bcfad8889745.jpg" alt="Vladimir Ilyich Lenin"></div><a name="habracut"></a><br>  As we know, JavaScript can be considered as an object-oriented language in the sense that ‚Äúit all comes down to objects‚Äù (in fact, to the prototype of an object).  On the other hand, in the broad philosophical question, we also now and then deal with objects and prototypes.  For example, when considering the object of the Revolution and its prototype, described in the "Capital".  So let's just talk about those events in modern language! <br><br><blockquote>  With all the revolutionary directness, just trumps on the table! <br>  This article is essentially a brief explanation of the mechanism of inheritance in JavaScript, that is, one of the parties to the PLO.  The advanced proletarians-developers will find absolutely nothing new in it.  However, I hope the material can serve as a memorable, figurative reminder for a wide range of people interested in developing JS.  In addition, it is possible that someone will tighten their knowledge of national history. <br></blockquote><br>  Create two objects: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stalin = { <span class="hljs-attr"><span class="hljs-attr">gulag</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">mustache</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">hero</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lenin = { <span class="hljs-attr"><span class="hljs-attr">baldHead</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">armand</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">criticalImperialism</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  We point out that one object is the heir of another through the <i>__proto__</i> property (this form of recording is available in all browsers except IE10-, and is <a href="http://www.ecma-international.org/ecma-262/6.0/">included in ES2015</a> ).  One heir, and the other - a prototype.  We check the properties of the heir object, __proto__ appeared there: <br><br><pre> <code class="javascript hljs">stalin.__proto__ = lenin; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(stalin);</code> </pre> <br>  If the property is not detected directly in the object, it is searched in the parent object (prototype).  Let's try: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(stalin.baldHead); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Yes, the property is available, but its value does not suit us.  Overwrite it, but the property of the parent object does not change: <br><br><pre> <code class="javascript hljs">stalin.baldHead = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(lenin.baldHead); <span class="hljs-comment"><span class="hljs-comment">// true -     </span></span></code> </pre> <br>  By the way, what is the prototype of the prototype? <br><br>  In JS, an object, except for one case (about this below), inherits from Object .__ proto__ (look in the console).  This includes standard methods that are available by default: for example, Object.toString (), Object.valueOf (), and so on. <br><br>  And how do we enumerate the properties of the object itself, without the properties of its parent, in order not to perform unnecessary operations?  - For this, there is hasOwnProperty: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> stalin) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stalin.hasOwnProperty(key)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(key + <span class="hljs-string"><span class="hljs-string">": "</span></span> + stalin[key]) }</code> </pre> <br>  By the way, if the object already has its own property, after assigning the prototype, it will not be overwritten by the value from the prototype, but will remain as it was: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dzerjinskiy = { <span class="hljs-attr"><span class="hljs-attr">mustache</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">baldHead</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } dzerjinskiy.__proto__ = lenin; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(dzerjinskiy.baldHead); <span class="hljs-comment"><span class="hljs-comment">// false -      </span></span></code> </pre> <br>  Finally, you may need a simple dummy object with no properties, which is only needed for writing values.  Then we should not have to check hasOwnProperty when listing its properties: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zyuganov = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); zyuganov.experience = <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(zyuganov.toString); <span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre> <br>  When checking, it turns out that the empty object does not even have standard methods, such as toString ().  By the way, the Object.create method (prototype [, {}]) was used above. It is a method that allows you to create an object with a mandatory indication of the prototype (including null) and properties (optional). <br><br>  <b>F.prototype and new</b> <br><br>  You can create a constructor to make it easier to create instances whose parent is a single object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> marks = { <span class="hljs-attr"><span class="hljs-attr">marxism</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">engels</span></span>: <span class="hljs-string"><span class="hljs-string">"friend"</span></span>, <span class="hljs-attr"><span class="hljs-attr">beard</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Marksist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__proto__ = marks; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kamenev = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Marksist(<span class="hljs-string"><span class="hljs-string">"kamenev"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(kamenev);</code> </pre> <br>  We see that Comrade.  Kamenev also has a beard <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b93/84b/f96/b9384bf96ab1c7c75b13726c00719641.jpg" alt="Lev B. Kamenev"><br><br>  However, what about the Revolution?  You can add a new value and method to the prototype, then a child can use this method: <br><br><pre> <code class="javascript hljs">marks.revolution = <span class="hljs-string"><span class="hljs-string">"future"</span></span>; marks.deal = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.revolution}; <span class="hljs-comment"><span class="hljs-comment">// this    marks</span></span></code> </pre> <br>  New value appeared in the descendant: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(kamenev.revolution); <span class="hljs-comment"><span class="hljs-comment">// "future"</span></span></code> </pre> <br>  <b>We add a property or method to the prototype, and it appears in descendants without the need to redefine them.</b>  <b>The power of prototype inheritance!</b> <br><br>  Naturally, the value in the descendant can be modified, the remaining descendants of the prototype will not be affected: <br><br><pre> <code class="javascript hljs">kamenev.revolution = <span class="hljs-string"><span class="hljs-string">"now"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(kamenev.deal()); <span class="hljs-comment"><span class="hljs-comment">// "now"</span></span></code> </pre> <br>  As you can see, the object did not initially have a method, however, after adding the method to the prototype, we can call it, moreover, with the values ‚Äã‚Äãmodified in the child. <br><br>  For support in all browsers, incl.  old, there is another way: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Marksist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name; } Marksist.prototype = marks; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kamenev = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Marksist(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(kamenev); <span class="hljs-comment"><span class="hljs-comment">//         marks  __proto__</span></span></code> </pre> <br>  <i>Prototype</i> makes sense only in constructors (written in capital letters to JS), it essentially performs only one action, namely: it indicates where to refer to the __proto__ property when initializing the constructor function. <br><br>  If after the creation of the first object we want to create a second one, pointing to it a different prototype, the prototype of the first object will not change: <br><br><pre> <code class="javascript hljs">Marksist.prototype = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chicherin = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Marksist(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chicherin.marxism); <span class="hljs-comment"><span class="hljs-comment">// undefined,   __proto__    Object console.log(kamenev.marxism); // - true,   __proto__   marks</span></span></code> </pre> <br>  It is seen that the new object with an empty prototype does not have inherited properties, like the first object.  But everything can be replayed on the fly: <br><br><pre> <code class="javascript hljs">Marksist.prototype = marks; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zinovev = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Marksist(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(zinovev.marksizm); <span class="hljs-comment"><span class="hljs-comment">// true console.log(zinovev.deal()); // future</span></span></code> </pre> <br>  <b>It should be noted that changing prototypes is considered to be a very expensive operation, so playing with prototypes on the fly is not recommended!</b> <br><br>  In the prototype, we can also define methods that all descendants will use: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> marks = { <span class="hljs-attr"><span class="hljs-attr">marxism</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">engels</span></span>: <span class="hljs-string"><span class="hljs-string">"friend"</span></span>, <span class="hljs-attr"><span class="hljs-attr">beard</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">shout</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"   "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name + <span class="hljs-string"><span class="hljs-string">"!"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Marksist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name; } Marksist.prototype = marks; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dzerjinskiy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Marksist(<span class="hljs-string"><span class="hljs-string">""</span></span>); dzerjinskiy.shout(); <span class="hljs-comment"><span class="hljs-comment">//    !</span></span></code> </pre><br>  Here this is the object whose function is called from the prototype, in this case Dzerzhinsky. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d5/f97/6c5/6d5f976c5136738deaf3eba67d61bd92.jpg" alt="Felix Edmundovich Dzerzhinsky" width="300"><br><blockquote>  Correctly Felix Edmundovich warns us: in JavaScript you should always be vigilant about where the keyword this is currently pointing. </blockquote><br>  You can check whether the object is a constructor heir by using the instanceof operator: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zemlyachka = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tov</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tov <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Marksist) res = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(zemlyachka(zinovev)); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  We cite an opportunist who will have in practice all the same properties and methods as an ordinary Marxist: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> opportunist = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">marxism</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">engels</span></span>: <span class="hljs-string"><span class="hljs-string">"friend"</span></span>, <span class="hljs-attr"><span class="hljs-attr">beard</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">shout</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"   "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name + <span class="hljs-string"><span class="hljs-string">"!"</span></span>) } }; opportunist.shout();</code> </pre> <br>  We can even tell him the same unique property, and determine the rest in his prototype, that is, keep exactly the same structure as the previous objects: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plehanov = { <span class="hljs-attr"><span class="hljs-attr">marxism</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">engels</span></span>: <span class="hljs-string"><span class="hljs-string">"friend"</span></span>, <span class="hljs-attr"><span class="hljs-attr">beard</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">shout</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-string"><span class="hljs-string">"   "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name + <span class="hljs-string"><span class="hljs-string">"!"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Socialist</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name; } Socialist.prototype = plehanov; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> opportunist = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Socialist(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(opportunist); <span class="hljs-comment"><span class="hljs-comment">//        var zinovev = new Marksist,    </span></span></code> </pre><br>  However, on checking it will be filled up: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(zemlyachka(opportunist)); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/c26/990/ee4/c26990ee4a5c647033feb4effa38586e.jpg" alt="Rosalia Samoylovna Zemlyachka" width="300"><br><blockquote>  Rosalia Samoilovna sees the object through.  There is another approach to checking objects - <div class="spoiler">  <b class="spoiler_title">Duck typing</b> <div class="spoiler_text">  If it looks like a duck, swims like a duck and quacks like a duck, then it may be the duck. <br></div></div>  If the <s>subject</s> object behaves as we need, then we consider it a <s>communist</s> who we should consider, despite its origin </blockquote><br><br>  However, proven communists can sometimes be mistaken.  The instanceof operator compares only the prototypes of the object and the constructor, so collisions like this are possible: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> troczkiy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Marksist(<span class="hljs-string"><span class="hljs-string">""</span></span>); Marksist.prototype = {}; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(troczkiy <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Marksist); <span class="hljs-comment"><span class="hljs-comment">// , 1940-   !</span></span></code> </pre> <br>  And of course, we remember that everything in JS is an object (or rather, in the prototype chain, all objects, except special empty ones, come to <i>Object.prototype</i> ), so the test will return <i>true</i> both times: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> john_reed = [<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(john_reed <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true console.log(john_reed instanceof Object); // true</span></span></code> </pre> <br>  <b>Constructor property</b> <br><br>  Constructor functions (and indeed all functions) have a <i>prototype</i> property in which the <i>constructor is</i> written: it returns a reference to the function that created the instance prototype.  It can be easily lost in further transformations, since  JS is not required to maintain this link.  Let's say we decided to find out the political roots of Lev Davydovich: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> marks = { <span class="hljs-attr"><span class="hljs-attr">marxism</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">engels</span></span>: <span class="hljs-string"><span class="hljs-string">"friend"</span></span>, <span class="hljs-attr"><span class="hljs-attr">beard</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Marksist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name; } Marksist.prototype = marks; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> troczkiy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Marksist(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Congress = troczkiy.constructor; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> retrospective = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Congress(<span class="hljs-string"><span class="hljs-string">"My life"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(retrospective); <span class="hljs-comment"><span class="hljs-comment">//  ,     ,     !</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/728/3e8/cc6/7283e8cc6d4d30a8dad9b48fd5d8391e.png" alt="Lev Davidovich Trotsky" width="300"><br><br>  Obviously, we could not call the same constructor function that would create a new object identical to the first one (although the <i>constructor</i> , in theory, should have pointed to it!).  To get the desired result, simply save the <i>constructor</i> property in the Marksist prototype: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> marks = { <span class="hljs-attr"><span class="hljs-attr">marxism</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">engels</span></span>: <span class="hljs-string"><span class="hljs-string">"friend"</span></span>, <span class="hljs-attr"><span class="hljs-attr">beard</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Marksist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name; } Marksist.prototype = marks; Marksist.prototype.constructor = Marksist; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> troczkiy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Marksist(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Congress = troczkiy.constructor; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> retrospective = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Congress(<span class="hljs-string"><span class="hljs-string">"My life"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(retrospective); <span class="hljs-comment"><span class="hljs-comment">//     !</span></span></code> </pre> <br>  Thus, it is not necessary for us to know how the designer created the instance, from which we now create a new instance.  This information is recorded in the copy. <br><br>  Looking at these transformations, the thought may come to override the properties and methods of embedded JavaScript prototypes.  Speaking in a revolutionary language, move to a global, earthy level <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52c/8fb/8fe/52c8fb8fe9be9b60b8540de8dd942b65.png" alt="The first emblem of the USSR 1924" width="400"><br><br>  Nothing will stop us from, for example, changing the Object.prototype method: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ alert(<span class="hljs-string"><span class="hljs-string">" !"</span></span>) }</code> </pre> <br>  Or even a non-extremist example: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.manifest= <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"    -  "</span></span>; }</code> </pre> <br>  This style of class change (it would be more accurate to say prototypes here) is called monkey patching. <br><br>  There are two dangers.  First, by expanding or modifying the built-in prototypes, we make changes available to all objects lying down the property inheritance chain (for the Object.prototype, these are all JS entities).  Then, using such a method, we risk calling the new property the old name, thereby wiping it.  If within the same prototype chain we can remember the names of properties in a large project, where, besides, other scripts can be connected, the contents of the prototypes of basic entities, like the global object, are better not to touch, otherwise the consequences will be unpredictable. <br><br>  And secondly, redefinition in the course of program execution can lead to unobvious results: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pss = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">author</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">length</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Books = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{}; Books.prototype = pss; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstEdition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Books; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(firstEdition.length); <span class="hljs-comment"><span class="hljs-comment">// 20 var extendLenin = function(year){ if (!year) var year = new Date().getFullYear(); if (year &gt; 1925 &amp;&amp; year &lt; 1932) pss.length = 30; if (year &gt; 1941 &amp;&amp; year &lt; 1966) pss.length = 35; if (year &gt; 1966) pss.length = 55; } extendLenin(); var fourthEdition = new Books; console.log(fourthEdition.length); // ??</span></span></code> </pre> <br>  The behavior of the properties of objects inheriting from the prototype (the so-called "class instances") may not be the same as we assume. <br><br>  <b>Functional inheritance</b> <br><br>  In JavaScript, besides the prototype inheritance paradigm, functional is also used.  On the example of one of the heroes of the Revolution, let's see how it is implemented. <br><br>  Create a constructor that: <br><br>  a) Accepts parameters <br>  b) It has public methods that are supposed to be used outside the constructor and its derivatives. <br>  c) Has private methods that are supposed to be used only inside the constructor and its derivatives. <br><br>  Before us is a typical communist: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Kommunist = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">principles</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!principles) principles = {}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._start = <span class="hljs-number"><span class="hljs-number">1902</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (principles &amp;&amp; principles.start) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._start = principles.start; <span class="hljs-comment"><span class="hljs-comment">//  ,     this.response = function() { alert("  !") } //  ,         this._experience = function() { return (this._start); } this.principles = (Object.keys(principles).length &gt; 0 ? principles : {fidelity: 100}); this._getPrinciples = function() { return this.principles } }</span></span></code> </pre><br>  Private methods are usually written starting from the underscore. <br><br>  So, we have a constructor with a set of methods, ready to accept and process arguments.  Create an instance of the class: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e8/c4f/c0d/1e8c4fc0d152f9d1fd8388039b75752c.jpg" alt="Kliment Yefremovich Voroshilov" width="500"><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Voroshilov</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">principles</span></span></span><span class="hljs-function">) </span></span>{ Kommunist.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    var parentExperience = this._experience; this._experience = function() { return ("  ()  " + parentExperience.apply(this, arguments)); } //  ,     //  this.getPrinciples = function() { var p = this._getPrinciples(); var char = { fidelity: p.fidelity, persistence: p.persistence || "!" } console.log(": " + char.fidelity + ", : " + char.persistence) } this.getExperience = function() { console.log(this._experience()); alert(" -!"); } //  this.setExperience = function() { this._experience = function() { return ("  ()   "); } } } var ke = {fidelity: 101, persistence: 100, start: 1903} var voroshilov = new Voroshilov(ke);</span></span></code> </pre><br>  Note: the constructor is called relative to <i>this</i> to write all its methods into it, and with the <i>arguments</i> array, which contains all the arguments specified during the call ( <i>ke</i> object). <br><br>  Then we can observe how the getter and setter work, as well as other public methods: <br><br><pre> <code class="javascript hljs">voroshilov.getExperience(); <span class="hljs-comment"><span class="hljs-comment">//   voroshilov.setExperience(); //       voroshilov.getExperience(); //    voroshilov.getPrinciples(); //        </span></span></code> </pre><br>  For variety, you can call the constructor without parameters. <br><br>  <b>Class entity</b> <br><br>  Finally, with the release of ES6 (ES2015), we have the opportunity to use the <i>class</i> instruction directly in JavaScript.  In fact, nothing has changed in the prototype inheritance device, but now JS supports syntactic sugar, which will be more familiar to many programmers who come from other languages. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Marksist</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name } enemy() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"capitalism"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> revolution(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span> } }</code> </pre><br>  JS classes have three kinds of methods: <br><br>  - constructor (performed when initializing an instance of a class); <br>  - static (static methods available when calling a class, but not available in instances); <br>  - conventional methods. <br><br>  Now let us remember in the constant (ES6 admits this type of variables) a very important date, and then we define a Menshevik who is a Marxist heir: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cleavage = <span class="hljs-number"><span class="hljs-number">1903</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Menshevik</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Marksist</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> revolution() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.revolution(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r + <span class="hljs-string"><span class="hljs-string">",  "</span></span>; } [<span class="hljs-string"><span class="hljs-string">"che"</span></span> + cleavage]() { alert(<span class="hljs-string"><span class="hljs-string">" !"</span></span>) } hurt() { alert(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chkheidze = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Menshevik(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/e66/cae/8b7/e66cae8b7d7cc1ab76d04a7d6a2e0e83.jpg" alt="image" width="300"><br><br>  There are two innovations here: <br><br>  - <i>super ()</i> in the first case initializes the constructor of the base class, in the second it calls the method to which we add new behavior to the child; <br>  - calculated method names ( <i>[‚Äúche‚Äù + cleavage]</i> ), now we don‚Äôt need to immediately know the name of the method. <br><br>  The static method is available when the class is called, but not when the instance is called: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(Menshevik.revolution()); <span class="hljs-comment"><span class="hljs-comment">//  console.log(chkheidze.revolution()); // is not a function,    </span></span></code> </pre><br>  The result of the following code is already clear: <br><br><pre> <code class="javascript hljs">chkheidze.hurt(); <span class="hljs-comment"><span class="hljs-comment">//    console.log(chkheidze.enemy()); //     chkheidze.che1903(); //     </span></span></code> </pre><br>  Above, the most basic features of inheritance through classes ( <i>class</i> ) in JavaScript have been shown.  Conscious proletarian with proper revolutionary perseverance will find in the network a lot of articles, more fully covering the issue of innovations in ES6. </div><p>Source: <a href="https://habr.com/ru/post/324640/">https://habr.com/ru/post/324640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324628/index.html">Schr√∂dinger data center</a></li>
<li><a href="../324632/index.html">On the market, a cow man sold (computational solution)</a></li>
<li><a href="../324634/index.html">Visa has allowed banks to charge an additional fee from a client for withdrawing cash at ‚Äúforeign‚Äù ATMs.</a></li>
<li><a href="../324636/index.html">UX for application localization: a developer's guide</a></li>
<li><a href="../324638/index.html">90+ free resources for self-study online</a></li>
<li><a href="../324642/index.html">Error Handling in C</a></li>
<li><a href="../324644/index.html">On technical aspects of external and internal motivation</a></li>
<li><a href="../324646/index.html">Rust, Eclipse and STM32</a></li>
<li><a href="../324648/index.html">How I started programming better</a></li>
<li><a href="../324650/index.html">Count to three: two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>