<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software graphic coprocessor on STM32</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A year has passed and many evenings have been stunned by the writing of the next, much larger and this time useful project. Last time, everywhere I ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software graphic coprocessor on STM32</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/026/8b1/63d/0268b163dac34711b77acfaf93106385.png"><br><br>  A year has passed and many evenings have been stunned by the writing of the next, much larger and this time useful project.  Last time, everywhere I had to squeeze as soon as possible.  I began to miss the resources of that long-suffering stone and at some point an interesting solution came.  Give some of the tasks to another controller.  (Like last time, there is a lot of water and images under the cut.) <br><a name="habracut"></a><br>  Despite the presence of such projects as Nextion HMI and Gameduino, I decided to make my decision for a number of reasons.  Gameduino, though it seemed like an interesting solution (VGA output and FPGA on board), but the inability to get the second version of this board made me buy its first revision.  It was pain and suffering: <br><br><ul><li>  incomprehensible protocol; </li><li>  a small number of examples in the network; </li><li>  storing graphics in the host (you can on the SD card, but then you need FatFS, and it eats much more, and the meaning is lost); </li><li>  a set of magic numbers that only the Guru will understand, etc. </li><li>  in general, this project is more dead than alive. <br></li></ul><br>  Despite the explosive popularity of Nextion now, the project began to appear before such widespread and other reasons for refusal: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  I did not want to deal with nextion (starting with IDE); </li><li>  the danger of running into a non-European fee (although this seems to be cured); </li><li>  only pre-programmed actions from the IDE are available (correct, if it is not right); </li><li>  need to write for both host and display; </li><li>  a large overhead in the protocol (which, however, is explicable). </li></ul><br>  And most importantly, in both cases there is no possibility to add something of your own. <br><br><div class="spoiler">  <b class="spoiler_title">Offtop</b> <div class="spoiler_text"><h3>  What is it for? </h3><hr><br>  It may seem that sGPU is very similar to the Nextion display, but it is not.  It is much simpler and appeared out of interest, but eventually swelled so much that I wanted to share with the community, especially after a few requests. <br><br>  Some of the ideas were borrowed from all sorts of libraries, personal on trifles and old consoles (after reading a bunch of manuals on the device, but not all that we would like). <br>  Describing all the possibilities in one article clearly will not work, moreover, all the available commands can be viewed in the source code for the host (Arduino library) or in the file ‚ÄúcommandDiscriptions.txt‚Äù. <br><br><h3>  There was nothing to do </h3><hr><br>  What if there is a good display and a simple stm32 controller?  Obviously!  Throw all the interaction with the screen on it! <br>  The first thing was taken by the library to work with the display from Adafruit and almost completely rewritten, then screwed DMA.  There are graphic primitives, text output is, <br><br><div class="spoiler">  <b class="spoiler_title">and everything is quite good:</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/Nm0DjkwCZAc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  It would be possible to dwell on this and write already under stm32, but it‚Äôs so hard to resist the next trolleybus! <br></div></div><br><h3>  Controller for sGPU </h3><hr><br>  From the STM32F4xx series, he refused immediately, due to the absurdity of the idea (use such a controller for such nonsense! <s>If only for pro2 ...</s> ). <br><br>  STM32F103C8T6 with 20 KB of RAM (hereinafter referred to as the mini version) and STM32F103VET6 with 64 KB of RAM (hereinafter the pro version) were chosen. <br><br>  Since mini is much more common thanks to the Chinese and their cheap and beloved clone maple mini, it was decided to choose it as the main core, despite some limitations described below (the board with the pro version is also released as a ministm32 clone). <br><br>  Not just wrote the core, just change the type of controller in the project and change a couple of inclusions and get sGPU with a large memory and the FSMC controller (low cost and prevalence of the mini version, do not give rest to not use it). <br><br><h3>  Screen </h3><hr><br>  The screen was used, based on the ILI9341 driver (screen resolution 320x240).  Interaction with the screen is using SPI (there is also a possibility for FSMC, but it was not possible to test for various reasons) at the maximum possible speed for this controller - 36 Mbps (from actually measured, approximately 2.7 Mb / s or 22 Mbps), but only with DMA transmission, as indicated in the Reference manual (RM0008 for F101-F107). <br><br>  After futile attempts, it was not possible to start SPI at a higher speed.  The SPI block in the controller simply goes crazy (a stable maximum of 80 MHz for F_CPU, instead of 72 MHz, gives a little more than 36 Mbit / s not overclocked). <br><br><h3>  Interface </h3><hr><br>  The most interesting thing started when the choice appeared before the host and sGPU communication interface. <br>  Interface requirements were as follows: <br><br><ul><li>  Support by almost any controller; </li><li>  Easy to implement; </li><li>  It has sufficient bandwidth; </li><li>  It has a minimum number of used lines. </li></ul><br>  The choice fell on the UART.  With the choice of speed it was no longer so obvious, since not all devices can support the exchange rate in 1MBd.  Without thinking, I just made four possible speeds: 9600, 57600, 115200 and 1M.  It is also made possible to select the speed by hardware, using 3 GPIO (matching GPIO and speeds can be found in STM32_GPU_GPIO_Pinout.txt), which gives 8 possible values. <br><br>  Of these, only 4 are used, the rest is in reserve (at least 1200 Bod can be made). <br><br>  The speed is selected by mask, by <br><div class="spoiler">  <b class="spoiler_title">read port status:</b> <div class="spoiler_text"><pre><code class="hljs bash">switch(GPIOA-&gt;IDR &amp; 0x07) //   GPIO { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> 0x01: { init_UART1(USART_BAUD_9600); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(T_BAUD_9600); } <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> 0x02: { init_UART1(USART_BAUD_57600); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(T_BAUD_57K); } <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> 0x03: { init_UART1(USART_BAUD_115200); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(T_BAUD_115K); } <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> 0x04: { init_UART1(USART_BAUD_1M); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(T_BAUD_1M); } <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; /* * params 0x05-0x07 and 0x00: reserved * */ default: { init_UART1(USART_BAUD_57600); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(T_DAUD_DEFAULT); } <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; }</code> </pre> <br></div></div><br><h3>  Tiles </h3><hr><br>  This is the first thing sGPU should be able to do. <br><br>  Each tile is just an array of bytes with color indices in the current color palette. <br><br><div class="spoiler">  <b class="spoiler_title">This is how an 8x8 tile looks like (increased 10 times):</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/647/f1b/517/647f1b517ef14ee6ac0674dd8b79d972.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">And this is how the tile file looks higher:</b> <div class="spoiler_text"> <code>0E 0E 0E 0E 0E 0E 0E 0E 0E 38 38 0E 0E 38 38 0E 0E 38 28 0E 0E 28 38 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E 38 0E 0E 0E 0E 38 0E 0E 0E 38 38 38 38 0E 0E 0E 0E 0E 0E 0E 0E 0E 0E <br></code> <br></div></div><br>  I will definitely not describe in more detail what tiles are, I will hope for your ability to find information on the network, the amount of information is painfully large. <br><br>  Since there can be hundreds and thousands of tiles, they will occupy insane amounts of ROM.  It is completely illogical to transfer them from the host side (as done in Gameduino first revision). <br><br>  The output was to cling the memory card over SPI, <s>SDIO is not there yet</s> .  It turned out to be the hardest to raise FatFS.  Since everything is written with the help of the SPL library, not HAL and CubeMX, and it is possible because the power supply connection for the SD card was badly checked (they are terribly scary to the power supply), at some point everything just worked. <br><br>  Ultimately, on the part of the host, it is enough to send the file name and how many tiles to load into the sGPU RAM. <br><br><div class="spoiler">  <b class="spoiler_title">Like this:</b> <div class="spoiler_text"> <code>gpu.loadTile8x8("pcs8x8", TILE_SET_W, RAM_POS, 1); <br> // pcs8x8 ‚Äì     (  ); <br> // TILE_SET_W ‚Äì     ; <br> //        ; <br> // RAM_POS ‚Äì    RAM,     ; <br> // 1 ‚Äì     . <br></code> <br></div></div><br>  Agree that a command of 5 bytes in size (this is the minimum size for loading one tile at the moment of writing this article) is much smaller than the cumbersome FatFS library that eats up a significant part of both operational and permanent memory, which is not noticeable on the stm32 level controller. <br><br>  The following tile sizes are supported: <br><br><ul><li>  8x8 - the smallest, using only 64 bytes of RAM; </li><li>  16x16 - medium type, use 4 times more RAM (256 bytes); </li><li>  32x32 is the largest, again 4 times more and requires 4 times more RAM (1024 bytes). </li></ul><br>  The latter type of tiles is available only for the pro version, since only 10 of these eat up half the memory of the mini version, which is quite obvious - unacceptable. <br><br>  I also mention that I used the trick when displaying them on the screen.  In addition to using DMA (there is a buffer for one converted tile in RGB565), I check the index of each tile, and if it matches the previous one, then the conversion is skipped, and the old tile is output to the new coordinates.  Despite such a waste of memory, it has an undeniable advantage when the same tiles are displayed on the screen in a row.  There is no time for conversion, so the tile is displayed almost immediately. <br><br><div class="spoiler">  <b class="spoiler_title">Example of 8x8 tile output:</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/KLRuwGkdmYk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  A fly in the ointment - on the video above, the code for the host uses the C version of the library (the same can be achieved only if you use STM32 under the Arduino). <br><br><div class="spoiler">  <b class="spoiler_title">Here is an oscillogram of tile output:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d6c/916/cd3/d6c916cd34354d718fc90649832f583b.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">A bigger piece:</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/071/f7b/6d4/071f7b6d4c7c4fb782292925c0efd703.png"><br></div></div><br>  On it you can see a lot of voids while setting the address window.  These voids are mostly DC line switching (data or command selection, second channel red line) and waiting for the SPI buffer (waiting for all data to be transmitted).  With this because of the features of the display you can hardly do anything (only 9 bit mode or FSMC). <br><br><h3>  Creating tiles </h3><hr><br>  Before any tile gets sGPU RAM, it must first be downloaded from the SD card, but before that it must be placed there. <br><br>  Creating a tile is not so difficult, just do the following: <br><br><ul><li>  In GIMP, the finished image is rendered into an indexed mode; </li><li>  export as raw data (standard R, G, B); </li><li>  rename the file by mask 8.3 (8 characters maximum for the file name and 3 for the extension, this is a limitation of the current FatFS settings), I usually use the * .tle extension (sGPU substitutes the extension itself, so the host will not have to transfer it); </li><li>  place the * .tle file on the SD card in the root; </li><li>  <s>- ???;</s> </li><li>  <s>- PROFIT !!!</s> </li></ul><br>  Not really, because you need to create the tile image itself or the tile set.  Among the many tools for pixel art, I chose PixelEdit (again I will hope for your ability to find information on the web). <br><br>  Having made an image there, it is enough to export it as * .png and feed it to GIMP (as described above). <br><br><div class="spoiler">  <b class="spoiler_title">A very important point:</b> <div class="spoiler_text"><h4>  <font color="#cc0000">most importantly, do not forget to transfer the correct, finite width of the image in the tiles, otherwise sGPU will load the garbage!</font>  <font color="#cc0000">You also need to comply with the multiplicity of tiles size to 8 (8x8, 16x16, 32x32).</font>  <font color="#cc0000">This is true for a set of tiles.</font> <font color="#cc0000"><br></font> </h4><br></div></div><br><h3>  Sprites </h3><hr><br>  The second thing that should be able to sGPU: create sprites from tiles.  Sprite is the union of tiles into a group (if simplified). <br><br><div class="spoiler">  <b class="spoiler_title">Those who are not aware of one of the secrets of Mario is better not to watch:</b> <div class="spoiler_text">  Mario sprite consists of four 8x8 tiles. </div></div><br>  The number of mini sprites is 56, while for the pro version there is a little more - 63. Their number for the mini and pro versions was calculated differently.  So for mini this is the sum of half the maximum number of tiles of each type, whereas for pro this is the sum of quarters of <s>63 sprites is enough for everyone</s> . <br><br>  Sprites can consist of any, but identical type of tiles, i.e.  you can't make a sprite from 8x8 and 16x16 tiles at the same time, but you can have two sprites from 8x8 and 16x16 tiles.  Each sprite consists of four tiles (maximum) of the <s>64x64 sprite is enough for everyone, for everything else there is a * .bmp output</s> . <br><br>  The following combinations of sizes are possible: <br><br><ul><li>  1x1; </li><li>  1x2; </li><li>  2x1; </li><li>  2x2 </li></ul><br>  where the first digit is the height in the tiles, and the second width in the tiles. <br><br>  In addition, each sprite contains coordinates in pixels, where it will be drawn (it can help to calculate collisions of two sprites, but this is also there). <br><br><div class="spoiler">  <b class="spoiler_title">Sprite structure:</b> <div class="spoiler_text"><pre> <code class="hljs ruby">typedef struct { uint16_t posX; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> \_<span class="hljs-number"><span class="hljs-number">_</span></span>      uint16_t posY; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> / uint8_t type; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ( <span class="hljs-number"><span class="hljs-number">1</span></span>x1, <span class="hljs-number"><span class="hljs-number">1</span></span>x2‚Ä¶ <span class="hljs-number"><span class="hljs-number">8</span></span>x8, <span class="hljs-number"><span class="hljs-number">16</span></span>x16‚Ä¶) uint8_t visible;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       uint8_t tle[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    } sprite_t;</code> </pre><br></div></div><br><h3>  Tile background </h3><hr><br>  The third thing that should be able to sGPU. <br><br>  The memory contains an array of 1200 bytes (40x30 tiles) with tile indices of only 8x8 in size (in the future there may be a choice). <br><br>  The tile map is stored in RAM and loaded from an SD card (extension * .map).  Currently there are no tools to create a map file. <br><br><div class="spoiler">  <b class="spoiler_title">Rather, there is, but only a set of crutches ...</b> <div class="spoiler_text">  The only way is to export the map from PixelEdit to * .txt, erase all the beginning to the tile indices and give to tilemapConverter (I wrote on Qt on the principle that it was).  I recommend to write my version of the converter, as my curve, but if you need it, write in the comments. </div></div><br>  An example of a tile background can be seen during power up. <br><br><div class="spoiler">  <b class="spoiler_title">These 18 tiles are 8x8 pixels in size (magnified 10 times):</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/410/29e/0a6/41029e0a669a46428e451bbc068ef62d.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Allow you to do this (increased 2 times):</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/e60/6bd/3ce/e606bd3ceda94b8b971b4ff785f8894f.png"><br></div></div><br>  Now the most unpleasant.  Sprites and tile backgrounds use the same 8x8 tiles.  This means that you need to use different tiles for the background and sprites (yes, there are not so many mini versions). <br><br><h3>  Memory allocation </h3><hr><br>  Obviously, stm32's RAM memory is limited and you can't cram a lot into it.  For reasons unknown to me, I decided to give the memory for mini tiles - 7680 bytes, for pro - 40960 bytes. <br><br>  But I did not want to give all this memory for one type of tiles.  The problem arose with the distribution of this memory, more precisely, how many of which tiles to use. <br><br>  Earlier, when I read articles about old consoles, I came across the fact that, depending on the console, there was always a lack of some type of tiles. <br><br>  Therefore, taking into account a bunch of possible scenarios, it was decided to distribute as follows: <br><br><ul><li>  80 8x8 tiles, as the most used resource; </li><li>  10 16x16 tiles, unfortunately there are few of them, since this is all that remains of the free memory. </li></ul><br>  Do not forget about a larger controller, in which 64 kb of RAM, for it the distribution will already be as follows: <br><br><ul><li>  160 8x8 tiles, again as the most used resource; </li><li>  80 tiles 16x16, this time there are a lot more; </li><li>  10 tiles 32x32, they are few again, but this time it is worth considering their size. </li></ul><br>  Until now, I doubt the correctness of the distribution (the dynamics are not an option).  The rest can be found in the file "RAMmath.txt". <br><br><h3>  Color palette </h3><hr><br>  To reduce the memory used, tiles do not use the color entirely for each pixel (it‚Äôs a pity there is not so much memory) that would significantly increase performance, but only color indices from the color palette.  This decision reduced the memory requirement by half and made it possible to use the trick to change the palette and display the same tiles (no need to load new ones). <br><br>  A similar trick was used in all the old consoles.  The most notable and famous <br><div class="spoiler">  <b class="spoiler_title">example (for those who are not aware of another of the secrets of Mario is better not to look, it can change life)</b> <div class="spoiler_text">  In the game Super Mario Bros.  Tiles for clouds and bushes are identical, only the colors of the palette change.  Just like the palette of Mario and Luigi. <br></div></div><br>  As the simplest palette, the NES palette was used, but its failure was discovered. <br><br>  Armed with a GIMP and a built-in colorimeter in the system, I expanded the color set to 76 (4 black colors for the reserve). <br><br>  Not being a person with perfect color perception, I, of course, could not make an adequate palette of 76 colors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7fd/921/510/7fd9215106a6407fa07af8bc0187ea1d.png"></div><br>  I would be very grateful if anyone can find or make a more adequate palette of 256 colors (with one color for the future alpha channel). <br><br>  If you need to use a different palette, you can download it from an SD card.  The sGPU RAM has as many as 512 bytes for this (256 colors, two bytes per color, just like in the GameBoy Advance, but only in RGB565). <br><br>  Exporting a palette from GIMP is very simple, it is enough to export any indexed image (like raw data), and GIMP next to the image file will create another one with the extension * .pal.  It should be placed on the SD card (do not forget about the size of the name up to 8 characters). <br><br><h3>  Protocol </h3><hr><br>  The protocol was written so that the size of any team was as small as possible.  Strictly defined dimensions and parameters of teams, and the complete lack of control of the correctness of the command.  All for maximum speed of command execution (after all, everything is done programmatically, if you remember). <br><br>  Any command begins with a byte of its code.  The final size of the whole team depends on its code.  So to fill the entire screen with a single color, you only need 3 bytes, but in order to draw a triangle already 15 bytes. <br><br>  Command codes are neatly divided into ranges (sections), there are a large number of unused codes.  In total, 255 teams are available in the current protocol implementation; not even half of them are used (there is a free field for creativity). <br><br><h3>  Host side </h3><hr><br>  On the host side, sGPU looks like a normal screen, but only via the UART interface. <br><br>  In spite of the large input buffer for sGPU commands, there is still the risk of its overflow.  Therefore, there are two options for protection (in fact 1): <br><br><ul><li>  The programmatic answer to the host.  Slow, but widely supported option (you can use at least USB &lt;-&gt; UART and only 3 lines to share); </li><li>  Hardware response to the host.  Much faster, since GPIO is used, and it is enough for the host to monitor the status of this pin and there is less chance that the buffer will be full. </li></ul><br>  There are two versions of libraries under Arduino.  The version of the library, completely sharpened by Arduino (in C ++), of course, although it has an insane amount of advantages, but it has one huge and side disadvantage - it‚Äôs very thick and slow (see the tile section).  In other words, an empty sketch, let's say this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;STMsGPU.h&gt; STMsGPU gpu; void setup() {} void loop() {}</span></span></span></span></code> </pre><br>  eats up 1634 bytes of ROM and 217 bytes of RAM, and this is without the method of synchronization with sGPU!  Moreover, if you use STM32, then these numbers will already be 10 (at least) times higher - 16732 bytes of ROM and 3960 bytes of RAM! <br><br>  Therefore, there is a version in C. Unfortunately, while sharpened by atmega328p (and others like it) and deprived of almost all the advantages of the Arduino.  These shortcomings are compensated by both increased speed and a much smaller size: 922 bytes of ROM and 46 bytes of RAM (you can do less of course) only with synchronization. <br><br>  Most importantly, if you used the library for Adafruit ili9341 screens, you won't have to rewrite almost anything!  There is almost complete compatibility with all methods. <br><br><h3>  disadvantages </h3><hr><br>  There is not a large amount of memory, because of this it is impossible to make a framebuffer, since the required amount of memory for one frame of the entire screen will take 180 kilobytes.  Because of this, there is currently no alpha channel for tiles and sprites. <br><br>  Slow.  Against FPGA (FT800, RA8875 and the like), a simple 72 MHz controller does not have the slightest chance to resist.  It is clear that running the FSMC on the pro version will help the situation, but not as much as we would like. <br><br><h3>  Sources </h3><hr><br>  All source codes and even firmware for stm32 are on Github (if suddenly you do not have a programmer, then you can flash through STM32 Flash Loader Demonstrator on UART1). <br><br>  <a href="https://github.com/Bismuth208/STMGPU">Here is the link to the project repository</a> (I hope I won‚Äôt get a ban / mute account because of the habraeffect traffic, if it still exists).  In the source code you will find a project for sGPU (under IAR ARM version 7.40), code for AVR and Arduino (the tautology is still available), there are also descriptions of the connections and much more. <br><br><hr><br>  In general, the project is very raw, despite the existing opportunities.  <s>Not many steps left before the console with the audio coprocessor on the YM2149F.</s> <br><br>  If you have questions, ask, I will be glad to answer.  I can also write more, highlighting any moments where more detail (just let me know whether it is necessary or not).  In one article, as already mentioned above, do not cram everything. </div><p>Source: <a href="https://habr.com/ru/post/357914/">https://habr.com/ru/post/357914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357904/index.html">Smart LED flashing in Arduino</a></li>
<li><a href="../357906/index.html">Arduino C ++ 11 library for managing LED arrays</a></li>
<li><a href="../357908/index.html">All lessons on Arduino</a></li>
<li><a href="../357910/index.html">Using Template Metaprogramming for AVR Microcontrollers</a></li>
<li><a href="../357912/index.html">We program Arduino using Sublime + Stino on MacOS</a></li>
<li><a href="../357916/index.html">Determining that you are at home using a WiFi router (to automate the smart home)</a></li>
<li><a href="../357918/index.html">I2C sniffer</a></li>
<li><a href="../357920/index.html">Arduino <-> STM32 HAL, or there and back</a></li>
<li><a href="../357922/index.html">As I wrote code for Arduino using Python</a></li>
<li><a href="../357924/index.html">Keyboard layout indicator in the form of a color cube on the table using Arduino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>