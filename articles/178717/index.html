<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interoperability: Fortran and C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, in the world there are millions and millions of lines of Legacy code. The first place in the Legacy, of course, belongs to Kobol, but als...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interoperability: Fortran and C #</h1><div class="post__text post__text-html js-mediator-article">  As you know, in the world there are millions and millions of lines of Legacy code.  The first place in the Legacy, of course, belongs to Kobol, but also Fortran got a lot.  And, mainly, computing modules. <br><br>  Not so long ago, they brought me a small program (less than 1000 lines, more than a quarter - comments and blank lines) with the task ‚Äúto make something beautiful, for example, graphics and interface‚Äù.  Although the program is small, but I did not want to redo it - for two more months it will diligently run it in and make adjustments. <br><br>  The results of the work in the form of several pieces of code and car text carefully set out under the cut. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Formulation of the problem </h2><br>  There is a program on FORTRAN that counts something.  The task: to correct it as little as possible, preferably - without getting into the logic of work - and to put the input parameters and output the results into a separate module. <br><br>  To do this, we need to learn how to do the following things: <br><ul><li>  compile dll on FORTRAN; </li><li>  find exported from dll methods; </li><li>  pass in the parameters of the following types: <ul><li> atomic ( <code>int</code> , <code>double</code> ); </li><li>  strings; </li><li>  callbacks ( <code>Action&lt;&gt;</code> ); </li><li>  arrays ( <code>double[]</code> ); </li></ul></li><li>  call methods from a managed environment (in our case, C #). </li></ul><br>  We will do the front-end on C # - first of all, due to WPF, and cross-platform functionality is not necessary. <br><br><h2>  Environment </h2><br>  To begin, prepare the environment. <br><br>  As a compiler, I used gfortran from the GCC package (you can take it <a href="http://gcc.gnu.org/wiki/GFortranBinariesWindows">from here</a> ).  Also GNU make is useful to us (it lies <a href="http://gnuwin32.sourceforge.net/packages/make.htm">nearby</a> ).  Anything can be used as a source editor;  I put the <a href="http://www.eclipse.org/downloads/packages/eclipse-classic-422/junosr2">Eclipse</a> with the plugin Photran. <br><br>  Eclipse plug-in is installed from standard repositories via the ‚ÄúHelp‚Äù / ‚ÄúInstall New Software ...‚Äù menu item from the Juno base repository (enter Photran in the filter). <br><br>  After installing all the software, you need to register the paths to the gfortran and make binaries to the standard path. <br><br>  The programs are all written in the old dialect of Fortran, that is, they require a mandatory indent of 6 spaces at the beginning of each line.  Lines are limited to 72 familiarity.  File extension - for.  Not that I'm so old-school and hardcore, but that is, so we work. <br><br>  With C #, everything is clear - the studio.  I worked in VS2010. <br><br><h2>  First program </h2><br><h3>  Fortran </h3><br>  To begin with we will collect the simple program on a Fortran. <br><pre> <code class="matlab hljs"> module test contains subroutine hello() print *, <span class="hljs-string"><span class="hljs-string">"Hello, world"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> module test program test_main use test call hello() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> program</code> </pre>  We will not analyze the details, we are still not learning Fortran, but we will briefly highlight the moments that we will have to face. <br><br>  First, the modules.  They can do, you can not do.  In the test project, I used modules, this affected the names of the exported methods.  In the combat mission, everything is written sploshnyakom, and there are no modules.  In short, it depends on what came to you as an inheritance. <br><br>  Secondly, the FORTRAN syntax is such that the spaces in it are optional.  You can write <code>endif</code> , you can - <code>end if</code> .  You can <code>do1i=1,10</code> , but you can humanly - <code>do 1 i = 1, 10</code> .  So this is just a storehouse of errors.  I spent half an hour looking for a line <br><pre> <code class="matlab hljs"> callback()</code> </pre>  gave the error ‚Äúthe <code>_back()</code> character was not found‚Äù until it realized what to write <br><pre> <code class="matlab hljs"> call callback()</code> </pre>  So be careful. <br><br>  Thirdly, the f90 and f95 dialects do not require padding at the beginning of lines.  Here everything again depends on what has come to you. <br><br>  But okay, back to the program.  It is compiled either from eclipse (if the makefile is configured correctly), or from the command line.  First, let's work from the command line: <br><pre> <code class="bash hljs">&gt; gfortran -o bin\test.exe src\test.for</code> </pre><br>  The launched exe file will a) require a run-time dll from Fortran, and b) display the string "Hello, world". <br><br>  In order to get an exe that does not require runtime, compilation must be done with the <code>-static</code> key: <br><pre> <code class="bash hljs">&gt; gfortran -static -o bin\test.exe src\test.for</code> </pre><br>  To get the same dll, you need to add the <code>-shared</code> key: <br><pre> <code class="bash hljs">&gt; gfortran -static -shared -o bin\test.dll src\test.for</code> </pre><br>  On this with the Fortran, let's finish it for now, and move on to C #. <br><br><h3>  C # </h3><br>  Create a completely standard console application.  Immediately add another class - <code>TestWrapper</code> and write some code: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestWrapper</span></span> { [DllImport(<span class="hljs-string"><span class="hljs-string">"test.dll"</span></span>, EntryPoint = <span class="hljs-string"><span class="hljs-string">"__test_MOD_hello"</span></span>, CallingConvention = CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre><br>  The entry point to the procedure is determined using the standard <code>dumpbin</code> VS-utility: <br><pre> <code class="bash hljs">&gt; dumpbin /exports test.dll</code> </pre><br>  This command gives a long dump in which you can find the lines of interest to us: <br><pre> <code class="bash hljs"> 3 2 000018CC __test_MOD_hello</code> </pre><br>  You can search or <code>grep</code> ohm, or dump <code>dumpbin</code> output to a file, and go search for it.  The main thing - we saw the symbolic name of the entry point, which can be placed in our call. <br><br>  Further - easier.  In the main module of Program.cs we make the call: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { TestWrapper.hello(); }</code> </pre><br>  By running the console application, you can see our line ‚ÄúHello, world‚Äù, displayed by means of Fortran.  Of course, we must not forget to throw the test.dll compiled in Fortran into the <code>bin/Debug</code> (or <code>bin/Release</code> ) <code>bin/Release</code> . <br><br><h2>  Atomic parameters </h2><br>  But all this is not interesting, it is interesting - to transfer the data there and get something back.  To this end, we will conduct the second iteration.  Let it be, for example, a procedure that adds the number 1 to the first parameter, and passes the result to the second parameter. <br><br><h3>  Fortran </h3><br>  The procedure is simple to ugliness: <br><pre> <code class="matlab hljs"> subroutine add_one(inVal, retVal) integer, intent(in) :: inVal integer, intent(out) :: retVal retVal = inVal + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine</code> </pre><br>  In Fortran, the call looks something like this: <br><pre> <code class="matlab hljs"> integer :: inVal, retVal inVal = <span class="hljs-number"><span class="hljs-number">10</span></span> call add_one(inVal, retVal) print *, inVal, <span class="hljs-string"><span class="hljs-string">' + 1 equals '</span></span>, retVal</code> </pre><br>  Now we need to compile and test this code.  In general, you can continue to compile from the console, but we also have a makefile.  Let's get it attached to the case. <br><br>  Since we are doing exe (for testing) and dll (for the ‚Äúproduction option‚Äù), it makes sense to first compile into object code, then assemble dll / exe from it.  To do this, open the makefile in the eclipse and write something in the spirit of: <br><pre> <code class="cmake hljs">FORTRAN_COMPILER = gfortran all: src\<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.for $(FORTRAN_COMPILER) -O2 \ -c -o obj\<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.obj \ src\<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.for $(FORTRAN_COMPILER) -static \ -o bin\<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.exe \ obj\<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.obj $(FORTRAN_COMPILER) -static -shared \ -o bin\<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.dll \ obj\<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.obj clean: del /Q bin\*.* obj\*.* *.mod</code> </pre><br>  Now we can humanly compile and clear the project using the eclipse button.  But this requires that the path to make be set in environment variables. <br><br><h3>  C # </h3><br>  Next in line is the refinement of our shell in C #.  First, we import another method from the dll into the project: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test.dll"</span></span></span><span class="hljs-meta">, EntryPoint = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__test_MOD_add_one"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The entry point is defined as before, through <code>dumpbin</code> .  Since we have variables, we need to specify a calling <code>cdecl</code> (in this case, <code>cdecl</code> ).  Variables are passed by reference, so <code>ref</code> required.  If we omit the <code>ref</code> , then when we call, we get AV: ‚ÄúUnhandled exception: <code>System.AccessViolationException</code> : Attempt to read or write to protected memory.  This often indicates that the other memory is damaged. ‚Äù <br><br>  In the main program we write about the following: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inVal = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outVal; TestWrapper.add_one(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> inVal, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> outVal); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0} add_one equals {1}"</span></span>, inVal, outVal);</code> </pre><br>  In general, everything, the problem is solved.  If it were not for one ‚Äúbut‚Äù - again you need to copy <code>test.dll</code> from the Fortran folder.  The procedure is mechanical, it would be necessary to automate it.  To do this, right-click on the project, ‚ÄúProperties‚Äù, select the ‚ÄúConstruction Events‚Äù tab, and write something in the spirit in the ‚ÄúCommand line of the event before construction‚Äù window <br><pre> <code class="bash hljs">make -C $(SolutionDir)..\Test.for clean make -C $(SolutionDir)..\Test.for all copy $(SolutionDir)..\Test.for\bin\test.dll $(TargetDir)\test.dll</code> </pre>  Ways, of course, it would be necessary to substitute. <br><br>  So, after compiling and running, if everything went well, we get a working program of the second version. <br><br><h2>  Strings </h2><br>  Let us assume that to transfer the initial parameters to the called dll-module of the written code, we will be satisfied.  But it is often necessary to throw a string in one way or another.  There is one ambush with which I did not understand - encodings.  Therefore all my examples are given for Latin. <br><br><h3>  Fortran </h3><br>  It's simple (well, for hardcore): <br><pre> <code class="matlab hljs"> subroutine progress(text, l) character*(l), intent(in) :: text integer, intent(in) :: l print *, <span class="hljs-string"><span class="hljs-string">'progress: '</span></span>, text <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine</code> </pre><br>  If we wrote an intra-Fortran method, without dll and other interoperability, then the length could not be transmitted.  And since we need to transfer data between modules, we will have to work with two variables, a pointer to a string and its length. <br><br>  Calling the method is also not difficult: <br><pre> <code class="matlab hljs"> character(<span class="hljs-number"><span class="hljs-number">50</span></span>) :: strVal strVal = <span class="hljs-string"><span class="hljs-string">"hello, world"</span></span> call progress(strVal, len(trim(strVal)))</code> </pre><br>  <code>len(trim())</code> is specified for the purpose of truncating spaces at the end (as 50 characters are allocated per line, and only 12 are used). <br><br><h3>  C # </h3><br>  Now you need to call this method from C #.  To this end, we finalize <code>TestWrapper</code> : <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test.dll"</span></span></span><span class="hljs-meta">, EntryPoint = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__test_MOD_progress"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">progress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[MarshalAs(UnmanagedType.LPStr</span></span></span><span class="hljs-function">)]</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> txt, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> strl)</span></span>;</code> </pre><br>  This is where another import parameter is added - the <code>CharSet</code> used.  Also there is an instruction to the compiler on line passing - <code>MarshalAs</code> . <br><br>  The call looks trite, with the exception of the verbosity caused by the requirement to pass all parameters by reference ( <code>ref</code> ): <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = <span class="hljs-string"><span class="hljs-string">"hello from c#"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strLen = str.Length; TestWrapper.progress(str, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> strLen);</code> </pre><br><h2>  Kolbeki </h2><br>  We come to the most interesting thing - callbacks, or passing methods inside dll to track what is happening. <br><br><h3>  Fortran </h3><br>  To begin with, we will write the actual method that takes a function as a parameter.  In Fortran, it looks like this: <br><pre> <code class="matlab hljs"> subroutine run(fnc, times) integer, intent(in) :: times integer :: <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> character(<span class="hljs-number"><span class="hljs-number">20</span></span>) :: str, temp, cs interface subroutine fnc(text, l) character(l), intent(in) :: text integer, intent(in) :: l <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> interface temp = <span class="hljs-string"><span class="hljs-string">'iter: '</span></span> do <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, times write(str, <span class="hljs-string"><span class="hljs-string">'(i10)'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> call fnc(trim(temp)//trim(str), len(trim(temp)//trim(str))) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> do <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> module test</code> </pre><br>  Here we should pay attention to the new section of the <code>interface</code> describing the prototype of the transmitted method.  Pretty verbose, but, in general, nothing new. <br><br>  The call of this method is absolutely banal: <br><pre> <code class="matlab hljs"> call run(progress, <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><br>  As a result, the <code>progress</code> method written on the previous iteration will be called 10 times. <br><br><h3>  C # </h3><br>  Moving to C #.  Here we need to do more work - declare a delegate with the correct attribute in the <code>TestWrapper</code> class: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">UnmanagedFunctionPointer(CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> txt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strl</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  After that, you can define a prototype of the called <code>run</code> method: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test.dll"</span></span></span><span class="hljs-meta">, EntryPoint = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__test_MOD_run"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Progress w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> times</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The entry point is traditionally determined from the <code>dumpbin</code> issue;  the rest is familiar to us too. <br><br>  Calling this method is also not difficult.  You can send there both a native Fortran method (such as <code>TestWrapper.progress</code> , described at the last iteration), and C # lambda: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rpt = <span class="hljs-number"><span class="hljs-number">5</span></span>; TestWrapper.run(TestWrapper.progress, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> rpt); TestWrapper.run((<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _txt, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _strl) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inner = _txt.Substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, _strl); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello from c#: {0}"</span></span>, inner); }, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> rpt);</code> </pre><br>  So, we already have sufficient tools to remake the code in such a way as to pass into the callback method to display the progress of the execution of capacious operations.  The only thing we do not know how to do is pass the arrays. <br><br><h2>  Arrays </h2><br>  With them a little harder than with strings.  If for strings it is enough to write a couple of attributes, then for arrays you will have to work a little with pens. <br><br><h3>  Fortran </h3><br>  To begin with, we will write the procedure for printing an array, with a small margin for the future in the form of a line feed: <br><pre> <code class="matlab hljs"> subroutine print_arr(str, strL, arr, arrL) integer, intent(in) :: strL, arrL character(strL), intent(in) :: str <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>*<span class="hljs-number"><span class="hljs-number">8</span></span>, intent(in) :: arr(arrL) integer :: <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> print *, str do <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, arrL print *, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-string"><span class="hljs-string">" elem: "</span></span>, arr(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> do <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine</code> </pre><br>  An array declaration from <code>double</code> (or <code>real</code> double precision) is added, and its size is also passed. <br>  The call from FORTRAN is also trivial: <br><pre> <code class="matlab hljs"> character(<span class="hljs-number"><span class="hljs-number">50</span></span>) :: strVal <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>*<span class="hljs-number"><span class="hljs-number">8</span></span> :: arr(<span class="hljs-number"><span class="hljs-number">4</span></span>) strVal = <span class="hljs-string"><span class="hljs-string">"hello, world"</span></span> arr = (/<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159265</span></span>, <span class="hljs-number"><span class="hljs-number">2.718281828</span></span>, <span class="hljs-number"><span class="hljs-number">8.539734222</span></span>/) call print_arr(strVal, len(trim(strVal)), arr, <span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(arr))</code> </pre><br>  At the output we get a printed string and an array. <br><br><h3>  C # </h3><br>  There <code>TestWrapper</code> nothing special about <code>TestWrapper</code> : <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test.dll"</span></span></span><span class="hljs-meta">, EntryPoint = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__test_MOD_print_arr"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_arr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> titles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> titlesl, IntPtr values, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> qnt</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  But inside the program you will have to work a little and use the <code>System.Runtime.InteropServices</code> assembly: <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"abcd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sLen = s.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] { <span class="hljs-number"><span class="hljs-number">1.01</span></span>, <span class="hljs-number"><span class="hljs-number">2.12</span></span>, <span class="hljs-number"><span class="hljs-number">3.23</span></span>, <span class="hljs-number"><span class="hljs-number">4.34</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrLen = arr.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = Marshal.SizeOf(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * arrLen; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pntr = Marshal.AllocHGlobal(size); Marshal.Copy(arr, <span class="hljs-number"><span class="hljs-number">0</span></span>, pntr, arr.Length); TestWrapper.print_arr(s, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> sLen, pntr, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> arrLen);</code> </pre><br>  This is due to the fact that a pointer to an array must be passed into the Fortran program, that is, it is necessary to copy data from the managed area to the unmanaged, and, accordingly, memory allocation in it.  In this regard, it makes sense to write shells of the following type: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintArr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _titles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _values</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> titlesLen = _titles.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrLen = _values.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = Marshal.SizeOf(_values[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * arrLen; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pntr = Marshal.AllocHGlobal(size); Marshal.Copy(_values, <span class="hljs-number"><span class="hljs-number">0</span></span>, pntr, _values.Length); TestWrapper.print_arr(_titles, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> titlesLen, pntr, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> arrLen); }</code> </pre><br><h2>  Putting it all together </h2><br>  The complete source codes of all iterations (and a little more bonus in the form of transferring an array to a callback function) are in the repository on the <a href="https://bitbucket.org/norritt/fortran-sharp-interop">bit package</a> (hg).  If someone has additions - welcome in comments. <br><br>  Traditionally, I thank everyone who read to the end, for something very much text came out. </div><p>Source: <a href="https://habr.com/ru/post/178717/">https://habr.com/ru/post/178717/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178703/index.html">Cutting into two equal parts, the second part of the second part</a></li>
<li><a href="../178705/index.html">Dvelum or how I searched for a silver bullet</a></li>
<li><a href="../178707/index.html">I'm still here: return to the Network a year later without the Internet</a></li>
<li><a href="../178711/index.html">Source related translations</a></li>
<li><a href="../178713/index.html">RE: How to deal with low-quality Android applications</a></li>
<li><a href="../178721/index.html">Smart player nearly collapsed EVE Online economy</a></li>
<li><a href="../178723/index.html">Google recognized Palestine</a></li>
<li><a href="../178725/index.html">Scientists have embedded radio chips in paper</a></li>
<li><a href="../178727/index.html">geoDNS using Powerdns and nginx</a></li>
<li><a href="../178733/index.html">Modify Chrome Logger - a post as an incentive to study Google Chrome extensions and write your own</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>