<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CI & CD Fengshun Automation with Jenkins and Jira</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We haven't talked about development automation for a long time. Therefore, this time I will talk about how we have reduced the release time from three...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CI & CD Fengshun Automation with Jenkins and Jira</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/df5/386/611/df5386611bb54c2283462122cc5b2df3.png" alt="image alt text"></p><br><p>  We haven't talked about development automation for a long time.  Therefore, this time I will talk about how we have reduced the release time from three days to one and removed from the process the participation of a person with his possible mistakes. </p><br><p>  To talk about the long and thorny path is always difficult.  However, in recent years, the Yandex.Money development infrastructure has made a big step towards automating the most important process for us, the release, which is simply not a sin to tell.  In fact, we got a complete solution of Continuous Integration and Continuous Delivery based on the <a href="https://bitbucket.org/">Bitbucket</a> , <a href="https://jenkins.io/">Jenkins</a> and <a href="https://ru.atlassian.com/software/jira">Jira</a> bundles. <a name="habracut"></a></p><br><h1 id="komu-vse-eto-nuzhno">  Who needs all this </h1><br><p>  Continuous Integration and Continuous Delivery (CI / CD) processes have been used for a relatively long time in the development of Yandex.Money, which allows delivering changes to the production in small portions and maintaining a high release rate. </p><br><div class="spoiler">  <b class="spoiler_title">A bit about the ideas of Continuous Delivery &amp; Continuous Integration.</b> <div class="spoiler_text"><p>  In essence, this is just an approach to software development: </p><br><ul><li><p>  <strong>Continuous Integration</strong> implies frequent automated project builds to quickly identify integration problems.  You will always have an up-to-date and test-ready version of the product. </p><br></li><li>  <strong>Continuous Delivery</strong> implies frequent delivery of updates to the ‚Äúcombat‚Äù system.  The product is supported in the current version, and any errors during the upgrade are easier to track, since with each release the amount of changes is small. </li></ul><br></div></div><br><p>  In general, a complex process for releases is not necessary for everyone and not always.  For example, it is hardly useful for start-ups because of the many unnecessary stages - it is easier for them to get together and discuss everything in a narrow circle.  But if it doesn‚Äôt work out so well in your structure, and an insufficiently fast release process threatens with a dozen critical changes in production at a time ‚Äî you should think about automating the development. </p><br><p>  In addition, an automated process can significantly reduce the workload of teams.  Without CI / CD automation, you risk becoming bogged down in human error and a lot of manual operations.  For example, we use the popular Jira task tracker, which is perfectly suited for task management and integration with the Bitbucket repository, but it is difficult to automate the release cycle with it.  Therefore, our development process before Jenkins looked like this: </p><br><p><img src="https://habrastorage.org/web/643/526/35e/64352635efa94d07819983cfccde4b9c.png" alt="image alt text"></p><br><p>  <em>Release process Yandex.Money.</em> </p><br><p>  Development tasks and bug fixes were performed by the <a href="http://nvie.com/posts/a-successful-git-branching-model">Successful Git Branching Model</a> , and testing took place at the Feature Branch.  The whole hell of manual operations took place just as the Release Candidate was being prepared for acceptance tests.  The developer needed to complete the following steps: </p><br><ol><li><p>  Cut the release branch from <strong>dev</strong> to prepare the next release; </p><br></li><li><p>  Collect future release code; </p><br></li><li><p>  According to the comments to the commits, find all the tasks included in the release of Jira and make connections for them with the release in Jira; </p><br></li><li><p>  Create tickets to Jira for load and acceptance testing; </p><br></li><li>  Finally, the release manager needed to check that all the tasks associated with the ticket were tested and did not appear after or during the tests. </li></ol><br><p>  Working out these five points and coordinating the release with the responsible persons took us from 1 day to a week.  It could not go on forever, so the automation of this process on <strong>Jenkins</strong> soon appeared. </p><br><h1 id="chto-budem-avtomatizirovat">  What we will automate </h1><br><p>  Four years ago, we realized that it was time to change something: the size of the system, the number of employees and changes on the combat servers were growing before our eyes.  Since 2014, the number of releases has increased 3 times - from 45 to 150 pieces per month. </p><br><p><img src="https://habrastorage.org/web/cb7/cf9/74b/cb7cf974b3384f40ae0ef325c9c73dea.png" alt="image alt text"></p><br><p>  At that moment we ran with the following baggage: </p><br><ul><li><p>  The payment service consisted of several monoliths; </p><br></li><li><p>  There were no mandatory autotests; </p><br></li><li>  There was no automated code review and application deployment. </li></ul><br><p>  After the release was approved for deployment in production, a team of operating engineers took up the case.  Since the components of the payment service work in cluster configurations for us, the update deployment for each component resulted in a dozen iterations.  Only the deployment of releases on several environments daily engaged 5 people. </p><br><p>  With all this, you can live when there are a few releases and the staff is such that you can get together in a negotiation room and quickly discuss and coordinate everything.  But at some point it became a serious problem and a brake in the increasing pace of releases.  We have begun a long journey of rethinking the development process, which can be briefly summarized as follows: </p><br><p><img src="https://habrastorage.org/web/0ea/dd0/b25/0eadd0b25aec4d2da55f85f03984a628.png" alt="image alt text"></p><br><p>  In fact, even a fully automated release preparation process will not significantly increase the pace, since we are pushing into the performance of the operations department - at one point in time at production we have decided to deploy only one update.  This is done to make it easier to diagnose possible errors due to a release. </p><br><p>  It turns out that you need to automate not only the <strong>formation</strong> and <strong>testing of the release</strong> for the transfer into operation, but also the <strong>deployment</strong> itself.  That is, to improve the processes of development and operation.  The first attempt to automate the operation is described in <a href="https://habrahabr.ru/post/322302/">one of the previous articles</a> - the experience was useful, and the mistakes made allowed to bring to the technical solution.  Now it is being implemented for most components and in the future, most likely, will be the reason for another publication. </p><br><h1 id="pochemu-imenno-jenkins">  Why Jenkins </h1><br><p>  We used to use the JetBrains Teamcity code to build, while the growth in the number of developers and services has not shown the economic inexpediency of such a solution for Yandex.Money.  Therefore, they turned to OpenSource and, as a ‚Äúsecond version,‚Äù made something comparable based on open and free <a href="https://jenkins.io/">Jenkins</a> . </p><br><p>  Tasks under automation turned out the following: </p><br><ol><li><p>  <strong>Dynamic generation of Jenkins tasks.</strong>  Allows you to create and maintain up to date tasks at the component level and the branches inside them; </p><br></li><li><p>  <strong>Preparation for testing</strong> : </p><br><ol><li><p>  Cutting the release branch.  A button in the Jenkins panel in Bitbucket creates a new release branch from the dev branch, to which all changes from developers have already been added; </p><br></li><li><p>  Build for testing.  A separate script builds the package for testing.  Jenkins creates an RL ticket in Jira and binds to it the descriptive tasks for developers; </p><br></li><li>  The script generates tasks for acceptance and integration testing.  Jenkins sends an email with release information to all observers of the released tasks; </li></ol><br></li><li><p>  <strong>Production Deployment</strong> : </p><br><ol><li><p>  Build for production deployment.  At the team of the developer, Jenkins adds the release branch code to master, and from master to dev (for the developers to have the current version), then builds a package for deployment; </p><br></li><li>  After assembling, the Jenkins script creates a task for Jira in deploying a release for the operations department and sends it to the person in charge of the post office - you can upload it to production. </li></ol><br></li></ol><br><p>  Let us examine in more detail each of the stages. </p><br><h1 id="dinamicheskaya-generaciya-zadach-jenkins">  Dynamic Jenkins Task Generation </h1><br><p>  When adding a new file with a description of the task to the repository of the component, Jenkins will automatically create an assembly task for it.  This is the responsibility of our SyncBitbucket mechanism, a working example of which lies on <a href="https://gist.github.com/f0y/bf7ff6570699cc368613c0dd60cd9c69">Github</a> . </p><br><p>  Interaction with Bitbucket occurs through the API, and with Jenkins - using the Job DSL plugin. </p><br><p>  The steps for dynamic generation are as follows: </p><br><ol><li><p>  Manually create a Bitbucket synchronization task (file <a href="https://gist.github.com/f0y/bf7ff6570699cc368613c0dd60cd9c69">synchronizeBitbucket.groovy</a> ).  The task goes over our Bitbucket projects and generates tasks for synchronizing individual projects.  A project is a set of repositories in which we have entities similar in purpose: services, libraries, and grad-plugins.  The launch of this task takes place on schedule, because we cannot track the appearance of new projects. </p><br></li><li><p>  The project synchronization task (the <a href="https://gist.github.com/f0y/bf7ff6570699cc368613c0dd60cd9c69">synchronizeProject.groovy</a> file) is also launched according to a schedule, searches for repositories and creates a task to synchronize each of them. </p><br></li><li>  The task of synchronizing the repository (file <a href="https://gist.github.com/f0y/bf7ff6570699cc368613c0dd60cd9c69">synchronizeRepo.groovy</a> ) is the main part of our mechanism.  Its purpose is to bypass all the branches, find in them the script files for generating the task and launch them for execution.  The task is launched by committing to the repository. </li></ol><br><p>  The scripts for generating tasks are written in the format of <a href="https://wiki.jenkins-ci.org/display/JENKINS/Job%2BDSL%2BPlugin">JobDSLplugin</a> .  In order for a developer to add a new type of task to Jenkins, it is enough to place the file with the prefix <strong>jenkins_</strong> in the <strong>\ Jenkins</strong> folder of the root directory of the repository.  In the task creation script, you can use the data supplied by the repository synchronization mechanism, for example: the name of the branch, the address of the repository, and the address of the directory in Jenkins. </p><br><p>  Example of the description of the task for cutting the release brunch: </p><br><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">folder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jobParams.jenkinsDirectory)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jobParams.gitBranch != </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"dev"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">job</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jobParams.jenkinsDirectory + </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/createReleaseBranch"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jdk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('jdk1.</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">')</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scm</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">git</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">url</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jobParams.gitRepoUrl)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refspec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('refs/remotes/origin/*')</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">branches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"**/$jobParams.gitBranch"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> } } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">steps</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gradle</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeExecutable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(true)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">description</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('  ')</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tasks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(':createReleaseBranch')</span></span></span><span class="hljs-function"> } } }</span></span></code> </pre> <br><p>  Such a mechanism allowed introducing the stages of the release cycle with minimal effort and for each component separately.  It turns out an analogue of <a href="https://travis-ci.org/">Travis CI</a> , and you can create your own set of assemblies for each branch. </p><br><h1 id="podgotovka-k-testirovaniyu">  Preparation for testing </h1><br><p>  To automate the Jenkins release cycle, it was necessary to create several scripts that look like ‚Äúlaunch buttons‚Äù for each stage of the release cycle: </p><br><ul><li><p>  <strong>createReleaseBranch</strong> - cutting the release branch; </p><br></li><li>  <strong>prepareReleaseForTesting</strong> - build a test release, setting a task for testers. </li></ul><br><p>  Scripts are created just at the stage of dynamic generation of tasks for each component.  That is, the start of one or another stage of the release cycle means the launch of a specific script of the component being prepared for release. </p><br><p>  After launching <strong>createReleaseBranch</strong> , a release branch is formed from the dev branch in Bitbucket, and a separate folder is created in Jenkins.  The name for the folder is automatically selected according to the ‚Äúrelease_version‚Äù scheme. </p><br><p><img src="https://habrastorage.org/web/72e/4de/a90/72e4dea90d0d4d678088c3b0bb02b359.png" alt="image alt text"></p><br><p>  Next, the programmer needs to go to a new folder and run a separate <strong>prepareReleaseForTesting</strong> script <strong>there</strong> , which will assemble the update package and send out release build notifications to all interested.  In addition, Jira creates tasks for acceptance and load testing. </p><br><p>  Immediately after sending a new release for testing, you need to tell all interested parties about this.  So the product manager will be able to agree in advance with marketing and PR about the public announcement, the leaders of the directions will be aware of what is happening, and technical support will be able to work out the answers to possible questions from users. </p><br><p><img src="https://habrastorage.org/web/8a7/4a2/46f/8a74a246ff6243208b63ed8d62dd52e2.png" alt="image alt text"></p><br><div class="spoiler">  <b class="spoiler_title">A small digression about our ticket types in Jira.</b> <div class="spoiler_text"><ul><li><p>  <strong>An RL</strong> is a release description ticket containing references to the tasks included in this release; </p><br></li><li><p>  <strong>INT</strong> - task for acceptance testing of the release; </p><br></li><li>  <strong>LOAD</strong> is a load testing task. </li></ul><br></div></div><br><p>  For all this to happen, it was important to make Jenkins friends with Jira.  Here the whole question rested on the organizational aspects, since such developers are often encountered when changing code in Bitbucket: </p><br><ul><li><p>  "The button sometimes got out of the screen - corrected"; </p><br></li><li><p>  "Added a strip on top"; </p><br></li><li>  "Corrected checking for numbers, should no longer swear." </li></ul><br><p>  With such descriptions, it is difficult to understand to which task in Jira are code changes.  Therefore, it was agreed with the developers that, first of all, a comment on changes in Bitbucket will contain the task number (for example, ‚ÄúBACKEND-186 Fixed sending email‚Äù).  This number was before, as the developer needs it to analyze history in Git and Bitbucket, but now it has become critical. </p><br><p>  If the human factor comes into force and someone forgets about it - Jenkins will add a comment ‚Äúas is‚Äù to the general release letter, and then the project manager will bind the task to RL in Jira. </p><br><h1 id="razvertyvanie">  Deployment </h1><br><p>  During the deployment process are the following two tasks in Jenkins: </p><br><ul><li><p>  <strong>mergeToMaster</strong> - merging the tested code in the release branch with master; </p><br></li><li>  <strong>prepareReleaseForProduction</strong> - build the release from master and set the deployment task for the operation team. </li></ul><br><p>  After testing, the person responsible goes to the release folder in Jenkins and runs the mergeToMaster script, which executes the following in Bitbucket: merge release-&gt; master and master-&gt; dev. </p><br><p><img src="https://habrastorage.org/web/7e1/771/8c3/7e17718c317445b693f4917081e04227.png" alt="image alt text"></p><br><p>  It remains the final stage - assembly for production.  This is the responsibility of the <strong>prepareReleaseForProduction</strong> script, which assembles the .DEB package, sets the task in Jira to the operations department and notifies the person in charge that the release is ready and can be uploaded. </p><br><p>  As a development project for the automation of the release cycle, we are now building a link with integration tests in the testing department, in order to make the testing stage fully automatic in the future.  In order for developers to release more often, we taught Jenkins once a day to automatically send notifications about new tasks in the dev branches.  In addition, it is hoped that this will prepare developers, testers and system administrators for future automatic release clipping. </p><br><p>  <strong>It is curious to know about your approach to releases - how do you struggle with human errors, do you support any stable release rate?</strong> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/328092/">https://habr.com/ru/post/328092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328082/index.html">Stress test teams: how to make a GPU benchmark and do not overheat</a></li>
<li><a href="../328084/index.html">On the issue of restrictions</a></li>
<li><a href="../328086/index.html">Distributed data structures [part 1, overview]</a></li>
<li><a href="../328088/index.html">Using the KOMPAS-3D API ‚Üí Lesson 1 ‚Üí Basics</a></li>
<li><a href="../328090/index.html">.NET API in web development: past and future</a></li>
<li><a href="../328094/index.html">Learn and love Xdebug</a></li>
<li><a href="../328096/index.html">Why is your email list ineffective?</a></li>
<li><a href="../328098/index.html">Headquarters Touch Instinct. Tour of the St. Petersburg office</a></li>
<li><a href="../328100/index.html">Security Week 18: A hole in all systems with Intel Core, Apple took away a certificate from a Trojan, ran the wizard flooded the planet</a></li>
<li><a href="../328102/index.html">Phase modulation of the radio signal in the FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>