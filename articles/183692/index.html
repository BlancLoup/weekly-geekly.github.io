<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TCP (syn-flood) -netmap-generator with a performance of 1.5 mpps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Given: 


# pciconf -lv | grep -i device | grep -i network device = I350 Gigabit Network Connection # dmesg | grep CPU: CPU: Intel(R) Core(TM)2 Duo CP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TCP (syn-flood) -netmap-generator with a performance of 1.5 mpps</h1><div class="post__text post__text-html js-mediator-article">  <b>Given:</b> <br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># pciconf -lv | grep -i device | grep -i network device = I350 Gigabit Network Connection # dmesg | grep CPU: CPU: Intel(R) Core(TM)2 Duo CPU E7300 @ 2.66GHz (2666.69-MHz K8-class CPU) # uname -orp FreeBSD 9.1-RELEASE amd64</span></span></code> </pre> <br>  <b>Task:</b> <br>  It is necessary to create a load plug in the form of a tcp (syn) traffic generator with a capacity of at least 500kpps on this hardware and OS. <br><br>  <b>Decision:</b> <br><a name="habracut"></a><br>  In a first approximation, an attempt was made to use <a href="http://www.hping.org/">hping</a> . <br>  We collect with tcl support.  We write a small script: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-string"><span class="hljs-string">{1}</span></span> { hping <span class="hljs-keyword"><span class="hljs-keyword">send</span></span> <span class="hljs-string"><span class="hljs-string">"ip(saddr=10.0.0.1,daddr=10.0.0.2)+tcp(sport=14000,dport=80,flags=s)"</span></span> }</code> </pre><br>  Run: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># hping exec ./synflood1.htcl</span></span></code> </pre><br>  We look at the performance: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># netstat -w1 -I igb0 input (igb0) output packets errs idrops bytes packets errs bytes colls 21384 0 0 1283040 21582 0 1165428 0 21264 0 0 1275840 21464 0 1159056 0 21361 0 0 1281660 21559 0 1164186 0</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The launched 10 copies were able to "shake" to 55kpps, while both cores were disposed of. <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># top -PSCH last pid: 1691; load averages: 10.02, 6.83, 3.32 up 0+00:59:11 12:31:18 125 processes: 13 running, 86 sleeping, 26 waiting CPU 0: 77.2% user, 0.0% nice, 17.1% system, 5.7% interrupt, 0.0% idle CPU 1: 76.4% user, 0.0% nice, 10.6% system, 13.0% interrupt, 0.0% idle</span></span></code> </pre><br>  Tuning the system allowed to increase the rate of fire a little more, but the final figures stopped at ~ 125kpps. <br><br>  The result does not meet the requirements.  In the second approximation, we consider the <a href="http://info.iet.unipi.it/~luigi/netmap/">netmap</a> framework from Luigi Rizzo actively advertised in the 9-ki reviews, but I did not find the discussion and results of its practical application in runet. <br>  To work, you need to rebuild the kernel with the parameter: <br><pre> <code class="bash hljs">device netmap</code> </pre><br>  The source code is taken from the author‚Äôs source with the addition of the formation of a tcp-package.  It is fully operational, without cuts. <br><div class="spoiler">  <b class="spoiler_title">tcp-gen.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *    * tcp-   netmap */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *default_payload = <span class="hljs-string"><span class="hljs-string">"netmap pkt-gen Luigi Rizzo and Matteo Landi\n"</span></span> <span class="hljs-string"><span class="hljs-string">"http://info.iet.unipi.it/~luigi/netmap/ "</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pthread.h&gt; /* pthread_* */ #include &lt;pthread_np.h&gt; /* pthread w/ affinity */ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;inttypes.h&gt; /* PRI* macros */ #include &lt;string.h&gt; /* strcmp */ #include &lt;fcntl.h&gt; /* open */ #include &lt;unistd.h&gt; /* close */ #include &lt;ifaddrs.h&gt; /* getifaddrs */ #include &lt;sys/mman.h&gt; /* PROT_* */ #include &lt;sys/ioctl.h&gt; /* ioctl */ #include &lt;sys/poll.h&gt; #include &lt;arpa/inet.h&gt; /* ntohs */ #include &lt;sys/sysctl.h&gt; /* sysctl */ #include &lt;net/ethernet.h&gt; #include &lt;net/if.h&gt; /* ifreq */ #include &lt;net/if_dl.h&gt; /* LLADDR */ #include &lt;netinet/in.h&gt; #include &lt;netinet/ip.h&gt; #include &lt;netinet/tcp.h&gt; #include &lt;net/netmap.h&gt; #include &lt;net/netmap_user.h&gt; static inline int min(int a, int b) { return a &lt; b ? a : b; } /* debug support */ #define D(format, ...) \ fprintf(stderr, "%s [%d] " format "\n", \ __FUNCTION__, __LINE__, ##__VA_ARGS__) #ifndef EXPERIMENTAL #define EXPERIMENTAL 0 #endif #define MAX_QUEUES 64 /* no need to limit */ #define SKIP_PAYLOAD 1 /* do not check payload. */ inline void prefetch(const void *x) { __asm volatile("prefetcht0 %0" :: "m"(*(const unsigned long *)x)); } /* * sum_w() * * Do the one's complement sum thing over a range of words * Ideally, this should get replaced by an assembly version. */ static u_int32_t /* static inline u_int32_t */ sum_w(u_int16_t *buf, int nwords) { register u_int32_t sum = 0; while (nwords &gt;= 16) { sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); sum += (u_int16_t) ntohs(*buf++); nwords -= 16; } while (nwords--) sum += (u_int16_t) ntohs(*buf++); return (sum); } int tcp_csum(struct ip *ip, struct tcphdr * const tcp) { // struct tcphdr *const tcp = (struct tcphdr *) ((long *) ip + ip-&gt;ip_hl); u_int32_t sum; int tcp_len; /* Calculate total length of the TCP segment */ tcp_len = (u_int16_t) ntohs(ip-&gt;ip_len) - (ip-&gt;ip_hl &lt;&lt; 2); /* Do pseudo-header first */ sum = sum_w((u_int16_t*)&amp;ip-&gt;ip_src, 4); sum += (u_int16_t) IPPROTO_TCP; sum += (u_int16_t) tcp_len; /* Sum up tcp part */ sum += sum_w((u_int16_t*) tcp, tcp_len &gt;&gt; 1); if (tcp_len &amp; 1) sum += (u_int16_t)(((u_char *) tcp)[tcp_len - 1] &lt;&lt; 8); /* Flip it &amp; stick it */ sum = (sum &gt;&gt; 16) + (sum &amp; 0xFFFF); sum += (sum &gt;&gt; 16); sum = ~sum; tcp-&gt;th_sum = htons(sum); return tcp-&gt;th_sum; } // XXX only for multiples of 32 bytes, non overlapped. static inline void pkt_copy(void *_src, void *_dst, int l) { uint64_t *src = _src; uint64_t *dst = _dst; #define likely(x) __builtin_expect(!!(x), 1) #define unlikely(x) __builtin_expect(!!(x), 0) if (unlikely(l &gt;= 1024)) { bcopy(src, dst, l); return; } for (; l &gt; 0; l -= 64) { *dst++ = *src++; *dst++ = *src++; *dst++ = *src++; *dst++ = *src++; *dst++ = *src++; *dst++ = *src++; *dst++ = *src++; *dst++ = *src++; } } struct pkt { struct ether_header eh; struct ip ip; struct tcphdr tcp; uint8_t body[2048]; // XXX hardwired } __attribute__((__packed__)); /* * global arguments for all threads */ struct glob_arg { const char *src_ip; const char *dst_ip; const char *src_mac; const char *dst_mac; int pkt_size; int burst; int nthreads; int cpus; }; struct mystat { uint64_t containers[8]; }; /* * Arguments for a new thread. The same structure is used by * the source and the sink */ struct targ { struct glob_arg *g; int used; int completed; int fd; struct nmreq nmr; struct netmap_if *nifp; uint16_t qfirst, qlast; /* range of queues to scan */ uint64_t count; struct timeval tic, toc; int me; pthread_t thread; int affinity; uint8_t dst_mac[6]; uint8_t src_mac[6]; u_int dst_mac_range; u_int src_mac_range; uint32_t dst_ip; uint32_t src_ip; u_int dst_ip_range; u_int src_ip_range; struct pkt pkt; }; static struct targ *targs; static int global_nthreads; /* control-C handler */ static void sigint_h(__unused int sig) { for (int i = 0; i &lt; global_nthreads; i++) { /* cancel active threads. */ if (targs[i].used == 0) continue; D("Cancelling thread #%d\n", i); pthread_cancel(targs[i].thread); targs[i].used = 0; } signal(SIGINT, SIG_DFL); } /* sysctl wrapper to return the number of active CPUs */ static int system_ncpus(void) { int mib[2], ncpus; size_t len; mib[0] = CTL_HW; mib[1] = HW_NCPU; len = sizeof(mib); sysctl(mib, 2, &amp;ncpus, &amp;len, NULL, 0); return (ncpus); } /* * locate the src mac address for our interface, put it * into the user-supplied buffer. return 0 if ok, -1 on error. */ static int source_hwaddr(const char *ifname, char *buf) { struct ifaddrs *ifaphead, *ifap; int l = sizeof(ifap-&gt;ifa_name); if (getifaddrs(&amp;ifaphead) != 0) { D("getifaddrs %s failed", ifname); return (-1); } for (ifap = ifaphead; ifap; ifap = ifap-&gt;ifa_next) { struct sockaddr_dl *sdl = (struct sockaddr_dl*)ifap-&gt;ifa_addr; uint8_t *mac; if (!sdl || sdl-&gt;sdl_family != AF_LINK) continue; if (strncmp(ifap-&gt;ifa_name, ifname, l) != 0) continue; mac = (uint8_t*)LLADDR(sdl); sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]); break; } freeifaddrs(ifaphead); return ifap ? 0 : 1; } /* set the thread affinity. */ static int setaffinity(pthread_t me, int i) { cpuset_t cpumask; if (i == -1) return 0; /* Set thread affinity affinity. */ CPU_ZERO(&amp;cpumask); CPU_SET(i, &amp;cpumask); if (pthread_setaffinity_np(me, sizeof(cpuset_t), &amp;cpumask) != 0) { D("Unable to set affinity"); return 1; } return 0; } /* Compute the checksum of the given ip header. */ static uint16_t checksum(const void *data, uint16_t len) { const uint8_t *addr = data; uint32_t sum = 0; while (len &gt; 1) { sum += addr[0] * 256 + addr[1]; addr += 2; len -= 2; } if (len == 1) sum += *addr * 256; sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff); sum += (sum &gt;&gt; 16); sum = htons(sum); return ~sum; } /* * Fill a packet with some payload. */ static void initialize_packet(struct targ *targ) { struct pkt *pkt = &amp;targ-&gt;pkt; struct ether_header *eh; struct ip *ip; struct tcphdr *tcp; // uint16_t paylen = targ-&gt;g-&gt;pkt_size - sizeof(*eh) - sizeof(*ip); uint16_t paylen = targ-&gt;g-&gt;pkt_size -sizeof(*eh)-sizeof(*ip); int i, l, l0 = strlen(default_payload); char *p; for (i = 0; i &lt; paylen;) { l = min(l0, paylen - i); bcopy(default_payload, pkt-&gt;body + i, l); i += l; } pkt-&gt;body[i - 1] = '\0'; tcp = &amp;pkt-&gt;tcp; tcp-&gt;th_sport = htons(14000); // Contains the source port. tcp-&gt;th_dport = htons(80); // Contains the destination port. tcp-&gt;th_seq = ntohl(rand()); // Contains the sequence number. tcp-&gt;th_ack = rand(); // Contains the acknowledgement number. tcp-&gt;th_x2 = 0; // Unused. tcp-&gt;th_off = 5; // Contains the data offset. tcp-&gt;th_flags = TH_SYN; // Contains one of the following values: /* Flag Value Description TH_FIN 0x01 Indicates that the transmission is finishing. TH_SYN 0x02 Indicates that sequence numbers are being synchronized. TH_RST 0x04 Indicates that the connection is being reset. TH_PUSH 0x08 Indicataes that data is being pushed to the application level. TH_ACK 0x10 Indicates that the acknowledge field is valid. TH_URG 0x20 Indicates that urgent data is present. */ tcp-&gt;th_win = htons(512); // Contains the window size. // tcp-&gt;th_sum = 0; // Contains the checksum. tcp-&gt;th_urp = 0; // Contains the urgent pointer. ip = &amp;pkt-&gt;ip; ip-&gt;ip_v = 4; ip-&gt;ip_hl = 5; ip-&gt;ip_id = 0; ip-&gt;ip_tos = IPTOS_LOWDELAY; ip-&gt;ip_len = ntohs(sizeof(struct ip)+sizeof(struct tcphdr)); ip-&gt;ip_off = htons(IP_DF); /* Don't fragment */ ip-&gt;ip_ttl = IPDEFTTL; // ip-&gt;ip_ttl = 255; ip-&gt;ip_p = IPPROTO_TCP; inet_aton(targ-&gt;g-&gt;src_ip, (struct in_addr *)&amp;ip-&gt;ip_src); inet_aton(targ-&gt;g-&gt;dst_ip, (struct in_addr *)&amp;ip-&gt;ip_dst); targ-&gt;dst_ip = ip-&gt;ip_dst.s_addr; targ-&gt;src_ip = ip-&gt;ip_src.s_addr; p = index(targ-&gt;g-&gt;src_ip, '-'); if (p) { targ-&gt;dst_ip_range = atoi(p + 1); D("dst-ip sweep %d addresses", targ-&gt;dst_ip_range); } ip-&gt;ip_sum = checksum(ip, sizeof(*ip)); tcp-&gt;th_sum = tcp_csum(ip, tcp); eh = &amp;pkt-&gt;eh; bcopy(ether_aton(targ-&gt;g-&gt;src_mac), targ-&gt;src_mac, 6); bcopy(targ-&gt;src_mac, eh-&gt;ether_shost, 6); p = index(targ-&gt;g-&gt;src_mac, '-'); if (p) targ-&gt;src_mac_range = atoi(p + 1); bcopy(ether_aton(targ-&gt;g-&gt;dst_mac), targ-&gt;dst_mac, 6); bcopy(targ-&gt;dst_mac, eh-&gt;ether_dhost, 6); p = index(targ-&gt;g-&gt;dst_mac, '-'); if (p) targ-&gt;dst_mac_range = atoi(p + 1); eh-&gt;ether_type = htons(ETHERTYPE_IP); } /* * create and enqueue a batch of packets on a ring. * On the last one set NS_REPORT to tell the driver to generate * an interrupt when done. */ static int send_packets(struct netmap_ring *ring, struct pkt *pkt, int size, u_int count) { u_int sent, cur = ring-&gt;cur; if (ring-&gt;avail &lt; count) count = ring-&gt;avail; for (sent = 0; sent &lt; count; sent++) { struct netmap_slot *slot = &amp;ring-&gt;slot[cur]; char *p = NETMAP_BUF(ring, slot-&gt;buf_idx); pkt_copy(pkt, p, size); slot-&gt;len = size; if (sent == count - 1) slot-&gt;flags |= NS_REPORT; cur = NETMAP_RING_NEXT(ring, cur); } ring-&gt;avail -= sent; ring-&gt;cur = cur; return (sent); } static void * sender_body(void *data) { struct targ *targ = (struct targ*) data; struct pollfd fds[1]; struct netmap_if *nifp = targ-&gt;nifp; struct netmap_ring *txring; int i, sent = 0; D("start"); if (setaffinity(targ-&gt;thread, targ-&gt;affinity)) goto quit; /* setup poll(2) mechanism. */ memset(fds, 0, sizeof(fds)); fds[0].fd = targ-&gt;fd; fds[0].events = (POLLOUT); /* main loop. */ gettimeofday(&amp;targ-&gt;tic, NULL); { while (1) { /* * wait for available room in the send queue(s) */ if (poll(fds, 1, 2000) &lt;= 0) { D("poll error/timeout on queue %d\n", targ-&gt;me); goto quit; } /* * scan our queues and send on those with room */ for (i = targ-&gt;qfirst; i &lt; targ-&gt;qlast; i++) { // int m, limit = targ-&gt;g-&gt;burst; int m, limit = 512; txring = NETMAP_TXRING(nifp, i); if (txring-&gt;avail == 0) continue; m = send_packets(txring, &amp;targ-&gt;pkt, targ-&gt;g-&gt;pkt_size, limit); sent += m; targ-&gt;count = sent; } } /* flush any remaining packets */ ioctl(fds[0].fd, NIOCTXSYNC, NULL); /* final part: wait all the TX queues to be empty. */ for (i = targ-&gt;qfirst; i &lt; targ-&gt;qlast; i++) { txring = NETMAP_TXRING(nifp, i); while (!NETMAP_TX_RING_EMPTY(txring)) { ioctl(fds[0].fd, NIOCTXSYNC, NULL); usleep(1); /* wait 1 tick */ } } } gettimeofday(&amp;targ-&gt;toc, NULL); targ-&gt;completed = 1; targ-&gt;count = sent; quit: /* reset the ``used`` flag. */ targ-&gt;used = 0; return (NULL); } static void usage(void) { const char *cmd = "pkt-gen"; fprintf(stderr, "Usage:\n" "%s arguments\n" "\ti interface interface name\n" "\tl pkts_size in bytes excluding CRC\n" "\td dst-ip end with %%n to sweep n addresses\n" "\ts src-ip end with %%n to sweep n addresses\n" "\tD dst-mac end with %%n to sweep n addresses\n" "\tS src-mac end with %%n to sweep n addresses\n" "", cmd); exit(0); } int main(int arc, char **argv) { int i, fd; struct glob_arg g; struct nmreq nmr; void *mmap_addr; /* the mmap address */ void *(*td_body)(void *) = sender_body; int ch; int report_interval = 1000; /* report interval */ char *ifname = NULL; // int wait_link = 2; int devqueues = 1; /* how many device queues */ /* initialize random seed: */ srand(time(NULL)); bzero(&amp;g, sizeof(g)); g.src_ip = "10.0.0.1"; g.dst_ip = "10.0.0.2"; g.dst_mac = "ff:ff:ff:ff:ff:ff"; // g.dst_mac = NULL; g.src_mac = NULL; g.pkt_size = 60; g.burst = 512; // default g.nthreads = 2; //   2  // g.cpus = 1; g.cpus = system_ncpus(); //     while ((ch = getopt(arc, argv, "i:l:d:s:D:S:v")) != -1) { switch (ch) { default: D("bad option %c %s", ch, optarg); usage(); break; case 'i': /* interface */ ifname = optarg; break; case 'l': /* pkt_size */ g.pkt_size = atoi(optarg); break; case 'd': g.dst_ip = optarg; break; case 's': g.src_ip = optarg; break; case 'D': /* destination mac */ g.dst_mac = optarg; struct ether_addr *mac = ether_aton(g.dst_mac); D("ether_aton(%s) gives %p", g.dst_mac, mac); break; case 'S': /* source mac */ g.src_mac = optarg; break; } } if (ifname == NULL) { D("missing ifname"); usage(); } { int n = system_ncpus(); if (g.cpus &lt; 0 || g.cpus &gt; n) { D("%d cpus is too high, have only %d cpus", g.cpus, n); usage(); } if (g.cpus == 0) g.cpus = n; } if (g.pkt_size &lt; 16 || g.pkt_size &gt; 1536) { D("bad pktsize %d\n", g.pkt_size); usage(); } if (td_body == sender_body &amp;&amp; g.src_mac == NULL) { static char mybuf[20] = "ff:ff:ff:ff:ff:ff"; /* retrieve source mac address. */ if (source_hwaddr(ifname, mybuf) == -1) { D("Unable to retrieve source mac"); // continue, fail later } g.src_mac = mybuf; } { bzero(&amp;nmr, sizeof(nmr)); nmr.nr_version = NETMAP_API; /* * Open the netmap device to fetch the number of queues of our * interface. * * The first NIOCREGIF also detaches the card from the * protocol stack and may cause a reset of the card, * which in turn may take some time for the PHY to * reconfigure. */ fd = open("/dev/netmap", O_RDWR); if (fd == -1) { D("Unable to open /dev/netmap"); // fail later } else { if ((ioctl(fd, NIOCGINFO, &amp;nmr)) == -1) { D("Unable to get if info without name"); } else { D("map size is %d Kb", nmr.nr_memsize &gt;&gt; 10); } bzero(&amp;nmr, sizeof(nmr)); nmr.nr_version = NETMAP_API; strncpy(nmr.nr_name, ifname, sizeof(nmr.nr_name)); if ((ioctl(fd, NIOCGINFO, &amp;nmr)) == -1) { D("Unable to get if info for %s", ifname); } devqueues = nmr.nr_rx_rings; } /* validate provided nthreads. */ if (g.nthreads &lt; 1 || g.nthreads &gt; devqueues) { D("bad nthreads %d, have %d queues", g.nthreads, devqueues); // continue, fail later } /* * Map the netmap shared memory: instead of issuing mmap() * inside the body of the threads, we prefer to keep this * operation here to simplify the thread logic. */ D("mmapping %d Kbytes", nmr.nr_memsize &gt;&gt; 10); mmap_addr = (struct netmap_d*) mmap(0, nmr.nr_memsize, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0); if (mmap_addr == MAP_FAILED) { D("Unable to mmap %d KB", nmr.nr_memsize &gt;&gt; 10); // continue, fail later } /* * Register the interface on the netmap device: from now on, * we can operate on the network interface without any * interference from the legacy network stack. * * We decide to put the first interface registration here to * give time to cards that take a long time to reset the PHY. */ nmr.nr_version = NETMAP_API; if (ioctl(fd, NIOCREGIF, &amp;nmr) == -1) { D("Unable to register interface %s", ifname); // continue, fail later } /* Print some debug information. */ fprintf(stdout, "%s %s: %d queues, %d threads and %d cpus.\n", (td_body == sender_body) ? "Sending on" : "Receiving from", ifname, devqueues, g.nthreads, g.cpus); if (td_body == sender_body) { fprintf(stdout, "%s -&gt; %s (%s -&gt; %s)\n", g.src_ip, g.dst_ip, g.src_mac, g.dst_mac); } /* Exit if something went wrong. */ if (fd &lt; 0) { D("Aborting"); usage(); } } // "Wait 3 secs for phy reset" // sleep(wait_link); sleep(3); D("Ready..."); /* Install ^C handler. */ global_nthreads = g.nthreads; signal(SIGINT, sigint_h); targs = calloc(g.nthreads, sizeof(*targs)); /* * Now create the desired number of threads, each one * using a single descriptor. */ for (i = 0; i &lt; g.nthreads; i++) { struct netmap_if *tnifp; struct nmreq tifreq; int tfd; /* register interface. */ tfd = open("/dev/netmap", O_RDWR); if (tfd == -1) { D("Unable to open /dev/netmap"); continue; } bzero(&amp;tifreq, sizeof(tifreq)); strncpy(tifreq.nr_name, ifname, sizeof(tifreq.nr_name)); tifreq.nr_version = NETMAP_API; tifreq.nr_ringid = (g.nthreads &gt; 1) ? (i | NETMAP_HW_RING) : 0; if ((ioctl(tfd, NIOCREGIF, &amp;tifreq)) == -1) { D("Unable to register %s", ifname); continue; } tnifp = NETMAP_IF(mmap_addr, tifreq.nr_offset); /* start threads. */ bzero(&amp;targs[i], sizeof(targs[i])); targs[i].g = &amp;g; targs[i].used = 1; targs[i].completed = 0; targs[i].fd = tfd; targs[i].nmr = tifreq; targs[i].nifp = tnifp; targs[i].qfirst = (g.nthreads &gt; 1) ? i : 0; targs[i].qlast = (g.nthreads &gt; 1) ? i + 1 : tifreq.nr_tx_rings; targs[i].me = i; targs[i].affinity = g.cpus ? i % g.cpus : -1; if (td_body == sender_body) { /* initialize the packet to send. */ initialize_packet(&amp;targs[i]); } if (pthread_create(&amp;targs[i].thread, NULL, td_body, &amp;targs[i]) == -1) { D("Unable to create thread %d", i); targs[i].used = 0; } } { uint64_t my_count = 0, prev = 0; uint64_t count = 0; struct timeval tic, toc; gettimeofday(&amp;toc, NULL); for (; ;) { struct timeval now, delta; uint64_t pps; int done = 0; delta.tv_sec = report_interval / 1000; delta.tv_usec = (report_interval % 1000) * 1000; select(0, NULL, NULL, NULL, &amp;delta); gettimeofday(&amp;now, NULL); timersub(&amp;now, &amp;toc, &amp;toc); my_count = 0; for (i = 0; i &lt; g.nthreads; i++) { my_count += targs[i].count; if (targs[i].used == 0) done++; } pps = toc.tv_sec * 1000000 + toc.tv_usec; if (pps &lt; 10000) continue; pps = (my_count - prev) * 1000000 / pps; D("%" PRIu64 " pps", pps); prev = my_count; toc = now; if (done == g.nthreads) break; } timerclear(&amp;tic); timerclear(&amp;toc); for (i = 0; i &lt; g.nthreads; i++) { /* * Join active threads, unregister interfaces and close * file descriptors. */ pthread_join(targs[i].thread, NULL); ioctl(targs[i].fd, NIOCUNREGIF, &amp;targs[i].nmr); close(targs[i].fd); if (targs[i].completed == 0) continue; /* * Collect threads output and extract information about * how long it took to send all the packets. */ count += targs[i].count; if (!timerisset(&amp;tic) || timercmp(&amp;targs[i].tic, &amp;tic, &lt;)) tic = targs[i].tic; if (!timerisset(&amp;toc) || timercmp(&amp;targs[i].toc, &amp;toc, &gt;)) toc = targs[i].toc; } } ioctl(fd, NIOCUNREGIF, &amp;nmr); munmap(mmap_addr, nmr.nr_memsize); close(fd); return (0); } /* end of file */</span></span></span></span></code> </pre><br></div></div><br>  Compile, run. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ./tcp-gen -i igb0 -d 10.0.0.2 -D 00:1b:21:a3:5f:fc -s 10.0.0.1 -l 60 main [543] ether_aton(00:1b:21:a3:5f:fc) gives 0x800fac8d2 main [600] map size is 207712 Kb main [622] mmapping 207712 Kbytes Sending on igb0: 2 queues, 2 threads and 2 cpus. 10.0.0.1 -&gt; 10.0.0.2 (a0:36:9f:06:81:d6 -&gt; 00:1b:21:a3:5f:fc) main [663] Ready... sender_body [422] start sender_body [422] start main [746] 1003502 pps main [746] 1488140 pps main [746] 1488132 pps main [746] 1488135 pps main [746] 1488136 pps main [746] 1488137 pps main [746] 1488141 pps main [746] 1488132 pps main [746] 1488134 pps main [746] 1488134 pps ^Csigint_h [215] Cancelling thread #0 sigint_h [215] Cancelling thread #1 main [746] 1296740 pps</span></span></code> </pre><br>  The utility reports almost 1.5mpps.  Load is: <br><pre> <code class="bash hljs">last pid: 1789; load averages: 1.17, 0.43, 0.95 up 0+01:23:20 12:55:27 108 processes: 5 running, 77 sleeping, 26 waiting CPU 0: 5.9% user, 0.0% nice, 90.9% system, 3.1% interrupt, 0.0% idle CPU 1: 0.0% user, 0.0% nice, 95.3% system, 4.7% interrupt, 0.0% idle Mem: 18M Active, 14M Inact, 313M Wired, 14M Buf, 3545M Free Swap: 2572M Total, 2572M Free PID USERNAME PRI NICE SIZE RES STATE C TIME CPU COMMAND 1765 root 102 0 217M 6040K RUN 1 0:53 99.46% pkt-gen{pkt-gen} 1765 root 102 0 217M 6040K CPU0 0 0:53 99.37% pkt-gen{pkt-gen} 12 root -92 - 0K 416K WAIT 0 0:14 2.29% intr{irq256: igb0:que} 12 root -92 - 0K 416K WAIT 1 0:43 1.86% intr{irq257: igb0:que} 11 root 155 ki31 0K 32K RUN 0 74:15 0.00% idle{idle: cpu0} 11 root 155 ki31 0K 32K RUN 1 74:04 0.00% idle{idle: cpu1}</code> </pre><br>  We look at the arriving packages: <br><pre> <code class="bash hljs">tcpdump -i em1 -n -vvv 13:14:44.814897 IP (tos 0x10, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40) 10.0.0.1.14000 &gt; 10.0.0.2.80: Flags [S], cksum 0x4ae2 (correct), seq 1103125611, win 512</code> </pre><br>  Measurement performance on the generated machine is not possible.  The attacked system, in turn, reports only about 700kpps, but there is a suspicion that it is simply unable to process the traffic, therefore we set up an intermediate switch and see if someone is lying: <br><img src="http://nord.by/files/des3612.PNG" alt="image"><br>  As can be seen on the switch, the generator actually ‚Äúproduced‚Äù almost half a million packets.  Thus, the received traffic 3 times overlaps the task, for which I express my deep gratitude to Mr. Luigi Rizzo. <br><br>  During operation, one drawback was found: when starting up, netmap disconnects the map from the network stack, transferring it to a special netmap-mode.  Sometimes the adapter does not exit this mode.  To do this, you have to do it down / up.  I note that this problem occurred only on igb cards (em and re were also tested).  Perhaps this is the problem of this particular card / party. <br><br>  References: <br>  <a href="http://info.iet.unipi.it/~luigi/netmap/">Framework</a> Site - <a href="http://info.iet.unipi.it/~luigi/netmap/">info.iet.unipi.it/~luigi/netmap</a> <br>  GoogleTechTalks video on netmap - <a href="http://www.youtube.com/watch%3Fv%3DSPtoXNW9yEQ">www.youtube.com/watch?v=SPtoXNW9yEQ</a> </div><p>Source: <a href="https://habr.com/ru/post/183692/">https://habr.com/ru/post/183692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../183680/index.html">Moisture meter from scrap materials</a></li>
<li><a href="../183682/index.html">Trial versions of Adobe Creative Cloud are available.</a></li>
<li><a href="../183686/index.html">The method of optimization of the tasks of creating and maintaining the same type of Xen VM</a></li>
<li><a href="../183688/index.html">Walkers: The game of walkers</a></li>
<li><a href="../183690/index.html">Investigation of the properties of a model printed on a 3D printer</a></li>
<li><a href="../183694/index.html">Google's first WordPress plugin</a></li>
<li><a href="../183696/index.html">We are waiting for Android for consumer electronics</a></li>
<li><a href="../183700/index.html">History of one highload project</a></li>
<li><a href="../183704/index.html">Yandex.Browser for Android smartphones and iPads</a></li>
<li><a href="../183706/index.html">Moscow.pm at the Mail.Ru Group office: about Play Perl and the prejudices of Perl programmers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>