<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automate testing of iOS applications using Calabash and Cucumber</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of developing any application, there comes a time when, due to the growth of functionality, labor costs for regression testing become e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automate testing of iOS applications using Calabash and Cucumber</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/mailru/blog/244807/"><img src="https://habrastorage.org/files/35e/677/6d8/35e6776d894c4e0e9f04d98012b6f5e4.png"></a> <br><br>  In the process of developing any application, there comes a time when, due to the growth of functionality, labor costs for regression testing become excessively large.  Another reason for the considerable labor intensity of testing iOS applications (as well as any other mobile applications) is the diversity of the line of supported devices and OS versions, the need to test in landscape and portrait modes, as well as under different conditions of connection to the Internet.  The desire to optimize the testing process leads us to the need for its full or partial automation. <br><br>  In this article I will talk about how we automate the testing of our applications (ICQ and Agent Mail.Ru), share our best practices in this area and mention the problems that we face. <br><a name="habracut"></a><br><h1>  About pumpkin and cucumbers </h1><br>  Our project for autotests uses a bunch of <a href="http://calaba.sh/">Calabash</a> + <a href="http://cukes.info/">Cucumber</a> .  Calabash is a framework for automating functional testing, which, in essence, is the driver that controls the operation of an application on a device or simulator.  Cucumber provides a test infrastructure (running tests, parsing scripts, generating reports). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Architecturally, Calabash consists of two parts - client and server.  The server part is an HTTP server that is embedded in the application under test and accepts requests to perform certain actions in the application, the client part is written in Ruby and implements an API for interacting with the server. <br><br>  Cucumber uses the Gherkin language and the Given / When / Then pattern to describe the scenarios, where the <code>Given</code> keyword specifies the initial conditions, <code>When</code> is the operation, <code>Then</code> is the final result.  All scripts are placed in a special <code>.feature</code> file, which contains scripts related to a particular project feature. <br><br>  A typical test script looks like this: <br><br><pre> <code class="ruby hljs">@Login <span class="hljs-symbol"><span class="hljs-symbol">Feature:</span></span> Login (IMIOS-<span class="hljs-number"><span class="hljs-number">4898</span></span>) @ICQ @myChat @Agent @ALL_DEVICES @en Scenario <span class="hljs-symbol"><span class="hljs-symbol">Outline:</span></span> Login with empty uin/password (IMIOS-<span class="hljs-number"><span class="hljs-number">4898</span></span> <span class="hljs-comment"><span class="hljs-comment">#6) Given I go on "LoginScreen" When I login with username "&lt;username&gt;" and password "&lt;password&gt;" Then I view alert with text "&lt;text&gt;" Examples: | username | password | text | | | passz | [_auth_wrong_data] | | 442657876 | | [_auth_wrong_data] | | | | [_auth_wrong_data] |</span></span></code> </pre> <br>  For each scenario, you can specify a set of control tags.  In particular, the applications for which this script should be run, the list of devices and the interface language are indicated.  How to transfer the list of required tags at the start of the run, I will tell below. <br><br>  It is obvious that a simple description of the script in a language understandable to man is completely inadequate for its use.  In the next step, we need to implement each of its steps using Ruby, a Given-When-Then BDD pattern, and regular expressions. <br><br><pre> <code class="ruby hljs">Given /^I go on <span class="hljs-string"><span class="hljs-string">"(.*)"</span></span>$/ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|screen|</span></span> @page=page(Kernel.const_get(screen)) <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> element_exists(@page.trait) cur_screen=Utils.current_screen <span class="hljs-comment"><span class="hljs-comment"># return current screen of application Utils.go_to(cur_screen, </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@page</span></span></span><span class="hljs-comment">) # transition from screen1 to screen2 else print("Already on #{screen}\n") end </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@page</span></span></span><span class="hljs-comment">.await(:timeout=&gt;10) end Then /^I login with username "(.*)" and password "(.*)"(?: by (.*))?$/ do |username, password, protocol| if $App=="Agent" protocol||='mrim' steps %Q{Given I go on "PhoneLoginScreen"} </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@page</span></span></span><span class="hljs-comment"> = </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@page</span></span></span><span class="hljs-comment">.go_to_login(protocol) else steps %Q{Given I go on "LoginScreen"} end </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@page</span></span></span><span class="hljs-comment"> = </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@page</span></span></span><span class="hljs-comment">.login(username, password) End Then /^I view alert with text "(.*)"$/ do |text| </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@page</span></span></span><span class="hljs-comment">.check_alert(text) end</span></span></code> </pre> <br>  When running the tests, Cucumber takes one step of the script and searches for the desired implementation using a regular expression, substituting the parameters from the <code>Examples</code> section, executes this implementation, and proceeds to the next step.  If during the execution of the script there are no errors, then it is marked as <code>PASS</code> , otherwise - <code>FAILED</code> . <br><br>  These are the general principles for the execution of test scenarios.  An attentive reader has already had a question regarding the mythical object <code>@page</code> , so we smoothly proceed to the examination of the Page Object design pattern. <br><br><h1>  Page object and what it eats </h1><br>  Page Object is a term derived from the scope of UI testing of web applications.  For iOS, the name Screen Object is sometimes found.  We will use the first option as the most commonly used. <br><br>  Page Object is a design pattern that is widely used in automated testing and allows you to separate the logic of test execution from their implementation.  Page Object models the screens (or pages) of the application under test as objects.  As a result, we get a set of classes, each of which is responsible for working with a separate screen of the application.  This approach significantly reduces the amount of duplicate code, because the same screen objects can be used in different tests.  The main advantage of Page Object is that if the user interface changes, you can only perform a fix in one place, and not fix every test in which this interface is used. <br><br><img src="https://habrastorage.org/files/e7d/daf/019/e7ddaf019b7141d6a20c34e8e9d22091.gif"><br><br>  Methods of screen classes can be divided into three logical parts: <br><ol><li>  Locators - return locators by which Calabash finds the right interface elements. </li><li>  Actions - implement all possible user actions on the screen </li><li>  Assertions - implement screen checks </li></ol><br>  Below is a snippet of code for the <code>CreateGroupChatScreen</code> class: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'calabash-cucumber/ibase'</span></span> require_relative <span class="hljs-string"><span class="hljs-string">'BaseScreen'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateGroupChatScreen</span></span></span><span class="hljs-class"> &lt; BaseScreen </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># Locators ******************************************************************** def title "UINavigationBar NavigationTitleView" end def back_button "view:'UINavigationBar' view:'MRButtonWithTintedImage' index:0" end def create_button "view:'UINavigationBar' view:'MRButtonWithTintedImage' index:1" end # ... # Actions ********************************************************************* # touch create button ant return ChatScreen def create mtouch(create_button) page(ChatScreen).await end # remove last member from members list def remove_selected mtouch(remove_button) self end # remove all members from members list def remove_all_selected until get_selected_members.empty? remove_selected end self end # ... # Assertions ****************************************************************** def check_selected_members(expected_members) actual_members=get_selected_members expected_members=expected_members.split(',') unless expected_members.empty? fail("Incorrect members list") unless actual_members.sort.eql?(expected_members.sort) self end def check_title(title) fail("Incorrect title") if get_title!=title self end def check_cl(cl) cl=cl.split(',') fail("Incorrect CL (actual - #{get_cl}, expected - #{cl})") unless get_cl.eql?(cl) self end # ... end</span></span></span></span></code> </pre> <br>  When implementing screen classes, you need to pay attention to some aspects.  The locators used in the above example are ‚Äúfragile‚Äù and unreliable, and when they change the interface, they are more likely to stop working.  Therefore, in the project we assign <code>accessibilityIdentifier</code> each UI element, unique within the application and uniquely identifying the desired element.  In this case, locators take on this form and are no longer afraid of UI changes: <br><br><pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">title</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accessibilityIdentifier</span></span></span><span class="hljs-function">:'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conference_captionLabel</span></span></span><span class="hljs-function">'" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">back_button</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accessibilityIdentifier</span></span></span><span class="hljs-function">:'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conference_backButton</span></span></span><span class="hljs-function">'" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_button</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accessibilityIdentifier</span></span></span><span class="hljs-function">:'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conference_createButton</span></span></span><span class="hljs-function">'" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Screen classes are inherited from the base class <code>BaseScreen</code> , which implements common functionality for all screens (input in text fields, clicks with checking for the existence of an element, etc.). <br><br>  All screen class methods return pointers to Page Object.  If the method call does not change the current screen, <code>self</code> returned, otherwise a pointer to the desired Page Object is returned.  This approach allows you to record the steps of the script in a convenient form, sequentially calling the necessary methods. <br><br><pre> <code class="ruby hljs">Then /^I invite contact <span class="hljs-string"><span class="hljs-string">"(.*)"</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|contact|</span></span> steps <span class="hljs-string"><span class="hljs-string">%Q{Given I go on "ContactsScreen"}</span></span> @page = @page.show_all_contacts <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> @page.contact_exist?(contact) @page .chat(contact) .chat_info .invite <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print(<span class="hljs-string"><span class="hljs-string">"Contact </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{contact}</span></span></span><span class="hljs-string"> not exists"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h1>  Test bench management </h1><br>  The joy of testing automation would be incomplete without automating the process of preparing the build, running test scripts and sending test reports. <br><br>  Our first attempts to run autotests on the server with TeamCity failed because Calabash refused to work in a monitorless configuration.  Therefore, a forced measure was the launch of tests on a separate machine using Mac OS Automator scripts. <br><br><img src="//habrastorage.org/files/8a0/d59/476/8a0d59476b894dd9a7866f50907ebb4a.png"><br><br>  The main stages of the script: <br><ol><li>  According to the configuration ID (for example, <code>ImIOS_ICQ00Develop</code> ) requests the number of the last build and the current version number to TeamCity </li><li>  Makes <code>git checkout</code> from the Git repository on the <code>teamcity-build-ios-&lt;   .1&gt;</code> tag (with this tag, TeamCity marks the collected commits) </li><li>  Download and link to the project the latest version of Calabash.framework </li><li>  Performs branding and starts building a project using xcodebuild.  Branding refers to setting up a project and loading the necessary resources to further build a specific application.  The assembly is made both for the simulator ( <code>-sdk iphonesimulator</code> ), and for devices ( <code>-sdk iphoneos</code> ). </li><li>  Runs tests directly by calling a bash script. </li></ol><br>  Running a test is very simple: <br><br><pre> <code class="bash hljs">$ cucumber tests/features</code> </pre><br>  We need to ensure the launch of tests on all models of devices (simulators) and with all supported interface languages.  To run test scripts on a specific simulator, you must pass the <code>DEVICE_TARGET</code> parameter with the UDID of the desired simulator.  With the installation of the desired language, the situation is more complicated.  At the moment, Calabash-iOSs does not support the installation of the desired language on the iOS-simulator version 8.  But if you delve into the depths of iOS Simulator, you can find the <code>.GlobalPreferences.plist</code> file, which contains the <code>AppleLanguages</code> parameter, which defines the interface language.  You can set its value using the following script using the CFPropertyList gems. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Utils</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_language_in_iossim8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lang)</span></span></span></span> <span class="hljs-string"><span class="hljs-string">`find ~/Library/Developer/CoreSimulator/Devices/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$TargetUDID}</span></span></span><span class="hljs-string"> -type f -name ".GlobalPreferences.plist"`</span></span>.split(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>).each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|fn|</span></span> plist = CFPropertyList::List.new(<span class="hljs-symbol"><span class="hljs-symbol">:file</span></span> =&gt; fn) data = CFPropertyList.native_types(plist.value) data[<span class="hljs-string"><span class="hljs-string">"AppleLanguages"</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]=lang plist.value = CFPropertyList.guess(data) plist.save(fn, CFPropertyList::List::FORMAT_BINARY) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Also in the Cucumber call command, a list of tags is specified, which determines which scripts need to be run.  The start script consistently performs runs on each of the specified simulators and with each interface language, passing this data in the form of tags, and Cucumber executes only those test scripts that correspond to the specified tags. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#simulators list for launch sim=(\ 'iPhone 4s (7.1 Simulator)'\ 'iPhone 5 (7.1 Simulator)'\ 'iPhone 5s (7.1 Simulator)'\ 'iPad 2 (7.1 Simulator)'\ 'iPad Retina (7.1 Simulator)'\ 'iPad Air (7.1 Simulator)'\ 'iPhone 4s (8.0 Simulator)'\ 'iPhone 5 (8.0 Simulator)'\ 'iPhone 5s (8.0 Simulator)'\ 'iPhone 6 (8.0 Simulator)'\ 'iPhone 6 Plus (8.0 Simulator)'\ 'iPad 2 (8.0 Simulator)'\ 'iPad Retina (8.0 Simulator)'\ 'iPad Air (8.0 Simulator'\ ) #languages list for launch lang=(\ en\ cs\ de\ es\ pt\ ru\ tr\ uk\ zh-Hans\ ja\ vi\ ) for i in "${sim[@]}"; do for j in "${lang[@]}"; do case "$i" in ... 'iPad Retina (8.0 Simulator)' ) profile='-t </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@ALL</span></span></span><span class="hljs-comment">_DEVICES,</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@iPadRetina</span></span></span><span class="hljs-comment">_iOS8' ;; ... esac DEVICE_TARGET='$i' cucumber tests/features -t @$j -t @ ${profile} done done</span></span></code> </pre> <br>  Thus, if we have a certain script with tags <code>@iPadRetina_iOS8 @en</code> , then it will run only on iPad Retina simulator with iOS 8 and installed English. <br><br>  Almost everything is ready to launch autotests, but a necessary condition for their correct operation is to reset the simulator data and settings, which corresponds to a hard reset device.  Thus, we get rid of the side effects of previous runs and set identical initial conditions.  In the simulator menu there is a corresponding item, but according to the good old tradition we will have to choose it without the help of hands and the cursor, writing a small apple script. <br><br><pre> <code class="ruby hljs">tell application <span class="hljs-string"><span class="hljs-string">"iOS Simulator"</span></span> activate <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tell tell application <span class="hljs-string"><span class="hljs-string">"System Events"</span></span> tell process <span class="hljs-string"><span class="hljs-string">"iOS Simulator"</span></span> tell menu bar <span class="hljs-number"><span class="hljs-number">1</span></span> tell menu bar item <span class="hljs-string"><span class="hljs-string">"iOS Simulator"</span></span> tell menu <span class="hljs-string"><span class="hljs-string">"iOS Simulator"</span></span> click menu item <span class="hljs-string"><span class="hljs-string">"Reset Content and Settings‚Ä¶"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tell <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tell <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tell tell window <span class="hljs-number"><span class="hljs-number">1</span></span> click button <span class="hljs-string"><span class="hljs-string">"Reset"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tell <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tell <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> tell</code> </pre> <br>  One of the pillars of testing mobile applications is testing work with different types and quality of communication.  The smartphone is almost always located with the owner - and the office with a fast WI-FI network, and in the country with a barely perceptible 3G.  Therefore, in conclusion of this paragraph, I want to talk about the mechanism of network quality emulation on a test bench.  On devices with Developer Mode enabled and on Mac OS, the Network Link Conditioner tool is available, which allows you to set network quality using a graphical interface.  But we need the ability to change the quality of the network "on the fly" during the autotests and manage this process through the command line.  For these purposes, the <code>ipfw</code> utility, included in the standard Mac OS delivery package, is suitable.  The following commands set the speed of receiving / sending to 1 Mbit / s, packet loss of 10% and delay in receiving / sending packets of 500 ms. <br><br><pre> <code class="bash hljs">$ sudo ipfw add pipe 1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $ sudo ipfw add pipe 2 out $ sudo ipfw pipe 1 config bw 1Mbit/s plr 0.1 delay 500ms $ sudo ipfw pipe 2 config bw 1Mbit/s plr 0.1 delay 500ms</code> </pre> <br>  After manipulating <code>ipfw</code> it is necessary to reset all installed settings. <br><br><pre> <code class="bash hljs">$ sudo ipfw delete pipe 1 $ sudo ipfw delete pipe 2 $ sudo ipfw -f flush</code> </pre> <br><h1>  Functional testing </h1><br>  Based on the test run results, the following report is generated. <br><br><img src="//habrastorage.org/files/ca9/99f/80c/ca999f80c9e24e1788835c5825302f40.png"><br><br>  The report shows in which scenarios errors occurred.  For failed scripts, a screenshot is taken at the time of the error - it sometimes allows you to immediately determine the cause of the file.  If during the manual reproduction of the test scenario, the bug repeats, it starts up in the bug tracker. <br><br><h1>  Migration testing </h1><br>  With the active development of the application and the release of new versions, testers face the challenge of checking data migration from older versions.  Constant installation of old versions, filling the database with data and updating to the tested version are very time-consuming tasks that cause despondency even for the most diligent tester.  To facilitate this process, we collect sandboxes for each version of the application with an already filled (manually) database and then reuse them to verify the correctness of the migration.  With this approach, it is possible to automate this type of testing. <br><br>  Downloading the sendboxes to the simulator is easy and boils down to copying files into the correct directory of the simulator.  To download the sendboxes to the device, the <code>ifuse</code> utility is <code>ifuse</code> , which allows you to mount the device's file system. <br><br><pre> <code class="bash hljs">$ ifuse --udid <span class="hljs-comment"><span class="hljs-comment">#{$Udid} --container #{$Bundle_app} /Volumes/iphone</span></span></code> </pre><br>  Migration testing is as follows.  The application is installed on the simulator or device, then the desired sandbox rolls.  The implementation of the corresponding step of the script is as follows: <br><br><pre> <code class="ruby hljs">Given /^upload database from <span class="hljs-string"><span class="hljs-string">"(.*)"</span></span>$/ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|path|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> simulator? path=File.expand_path(path.gsub(<span class="hljs-string"><span class="hljs-string">' '</span></span>,<span class="hljs-string"><span class="hljs-string">'\ '</span></span>)) sand=<span class="hljs-string"><span class="hljs-string">`find ~/Library/Developer/CoreSimulator/Devices/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$Udid}</span></span></span><span class="hljs-string"> -type d -name "</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$App}</span></span></span><span class="hljs-string">.app"`</span></span>.gsub(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$App}</span></span></span><span class="hljs-string">.app"</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>) FileUtils.rm_rf(Dir.glob(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{sand}</span></span></span><span class="hljs-string">Documents/*"</span></span>)) FileUtils.rm_rf(Dir.glob(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{sand}</span></span></span><span class="hljs-string">Library/*"</span></span>)) FileUtils.cp_r(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{path}</span></span></span><span class="hljs-string">/Documents/."</span></span>, <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{sand}</span></span></span><span class="hljs-string">/Documents"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:verbose</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>) FileUtils.cp_r(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{path}</span></span></span><span class="hljs-string">/Library/."</span></span>, <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{sand}</span></span></span><span class="hljs-string">/Library"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:verbose</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> path=path.gsub(<span class="hljs-string"><span class="hljs-string">' '</span></span>,<span class="hljs-string"><span class="hljs-string">'\ '</span></span>) system(<span class="hljs-string"><span class="hljs-string">"umount -f /Volumes/iphone"</span></span>) system(<span class="hljs-string"><span class="hljs-string">"rm -rf /Volumes/iphone"</span></span>) system(<span class="hljs-string"><span class="hljs-string">"mkdir /Volumes/iphone"</span></span>) <span class="hljs-string"><span class="hljs-string">`ifuse --udid </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$Udid}</span></span></span><span class="hljs-string"> --container </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{$Bundle_app}</span></span></span><span class="hljs-string"> /Volumes/iphone`</span></span> FileUtils.rm_rf(Dir.glob(<span class="hljs-string"><span class="hljs-string">"/Volumes/iphone/Documents/*"</span></span>)) FileUtils.rm_rf(Dir.glob(<span class="hljs-string"><span class="hljs-string">"/Volumes/iphone/Library/*"</span></span>)) FileUtils.cp_r(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{path}</span></span></span><span class="hljs-string">/Documents/."</span></span>, <span class="hljs-string"><span class="hljs-string">"/Volumes/iphone/Documents/"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:verbose</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>) FileUtils.cp_r(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{path}</span></span></span><span class="hljs-string">/Library/."</span></span>, <span class="hljs-string"><span class="hljs-string">"/Volumes/iphone/Library/"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:verbose</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  After launching and updating the application, the corresponding checks occur (the number of chats, unread messages, saving the login). <br><br>  Automation has reduced the laboriousness of migration testing.  At the moment, an increase in the list of checks and the number of sandboxes being checked is required, which ideally will allow us to completely eliminate the manual component of testing. <br><br><h1>  Design and testing by screenshots </h1><br>  Testing an application based on a comparison of screenshots has its advantages and disadvantages.  On the one hand, it, in addition to functional bugs, reveals all the problems with the design, such as, for example, the ‚Äúslid‚Äù buttons, on the other hand, it has a number of features that limit the full transition to testing by screenshots.  With several applications and a wide range of supported devices, a huge base of reference screenshots is required for all possible screen resolutions.  In addition, it is not always easy to provide the required type of application.  For example, the area of ‚Äã‚Äãthe screen that displays the clock or the quality of communication will change on each particular run. <br><br>  An API has been added to autotests, allowing you to perform screenshots of the application.  This functionality is implemented using the ImageMagick library and allows you to compare the specified area of ‚Äã‚Äãthe screenshot with the standard, as well as perform a fuzzy search by pattern. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_path, etalon_path, x=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, w=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, h=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> img = Magick::ImageList.new(File.expand_path(image_path)) et = Magick::ImageList.new(File.expand_path(etalon_path)) img = img.crop(x, y, w, h, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w!=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; h!=<span class="hljs-number"><span class="hljs-number">0</span></span> res=img.signature&lt;=&gt;et.signature <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res==<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search_subimage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_path, subimage_path, fuzzy=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'20%'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> img = Magick::ImageList.new(File.expand_path(image_path)) sub = Magick::ImageList.new(File.expand_path(subimage_path)) img.fuzz=fuzzy sub.fuzz=fuzzy <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> img.find_similar_region(sub)==<span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The functionality is used to check the logo of the application.  Screening testing has a lot of potential and its use will expand. <br><br><h1>  Faster, higher, stronger, or performance testing </h1><br>  The user expects from the mobile application not only reliable operation without failures and wide functionality, but also an instant reaction to its actions.  Speed ‚Äã‚Äãand response time are important factors for increasing the competitiveness of an application.  Therefore, monitoring the time for performing basic operations (such as launching an application, the time for receiving offline messages, displaying a contact list, etc.) is an urgent need.  This process is associated with routine (and multiple) actions to reproduce the operations to be measured, the subsequent analysis of logs and the recording of data in the report.  That is why it turned out to be a natural contender for automation. <br><br>  Performance tests consist of two stages: <br><ol><li>  Run test scripts from Performance.feature, which collected scripts to perform those actions, the time of which we want to measure.  Each script is executed 5 times to minimize random deviations of values. </li><li>  Collecting logs, searching for relevant metrics, averaging values ‚Äã‚Äãand generating a report </li></ol><br><img src="//habrastorage.org/files/5e0/eea/422/5e0eea4226f34478b5568f05d3e31fc9.gif"><br><br>  To generate a report, a library is written that implements the API for quickly adding new values ‚Äã‚Äãto the report.  The library uses the nokogiri gem to work with html. <br><br>  Obviously, this type of testing should be carried out on physical devices.  In fact, to run the test on the device, and not on the simulator, you need to change the UDID and add the IP address of the Wi-Fi connection. <br><br>  The main testing artifact is a report by which one can judge the dynamics of changes in certain metrics.  In case of exceeding the specified limits, a ‚Äúdebriefing‚Äù takes place to find out the reasons for the deterioration of performance. <br><br><h1>  Plans and prospects </h1><br>  The main direction of the further development of autotests is to reduce the influence of external factors and the introduction of "plugs".  This will speed up the execution of scripts and eliminate the effect of server errors on the test results of the client application. <br><br>  There are two possible options, different location of the "stub": <br><ol><li>  inside the application </li><li>  outside application </li></ol><br>  The first option is the most flexible and convenient, but it has one major drawback - the potential impact of the test plugs on the application;  in other words, the release application and the test will differ from each other. <br><br>  The second option involves the implementation of the fake server, which implements only the interaction protocol and works locally with the client.  With this approach, the application does not experience side effects, however, additional labor costs are required to implement the fake server. <br><br>  Surely many of those reading this article have something to share in the field of test automation.  I propose to share developments in this area in the comments. </div><p>Source: <a href="https://habr.com/ru/post/244807/">https://habr.com/ru/post/244807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244791/index.html">Polymer: transcript video from Google I \ O</a></li>
<li><a href="../244797/index.html">HackDay for Superheroes</a></li>
<li><a href="../244799/index.html">Business Analytics Toolkit: Personal Experience</a></li>
<li><a href="../244801/index.html">The development of technology in the new decade: from the cloud to the disappearance of computers and the heyday of the era of robots</a></li>
<li><a href="../244805/index.html">How clouds change data centers</a></li>
<li><a href="../244811/index.html">The new graphical desktop shell is included in the main code base ReactOS</a></li>
<li><a href="../244813/index.html">Github is locked again</a></li>
<li><a href="../244815/index.html">Optimizing web page performance: CSS</a></li>
<li><a href="../244817/index.html">21 million measurements showed who has the fastest internet access in Moscow</a></li>
<li><a href="../244821/index.html">Effective JSON with functional concepts and generics in Swift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>