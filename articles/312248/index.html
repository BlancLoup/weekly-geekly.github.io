<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Feedback on Growing Object-Oriented Software, Guided by Tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a review of Growing Object-Oriented Software, Guided by Tests (GOOS for short). In it, I will show how you can implement a sample proj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Feedback on Growing Object-Oriented Software, Guided by Tests</h1><div class="post__text post__text-html js-mediator-article">  This article is a review of <a href="https://www.amazon.com/gp/product/0321503627/">Growing Object-Oriented Software, Guided by Tests</a> (GOOS for short).  In it, I will show how you can implement a sample project from a book without using mocks. <br><br>  The purpose of the article is to show how the use of mocks can harm the code and how much simpler the same code becomes if you get rid of mocks.  The secondary goal is to single out the advice from the book that personally seems reasonable to me and those that, conversely, do more harm than good.  The book is quite a lot of those and others. <br><br>  English version: <a href="http://enterprisecraftsmanship.com/2016/07/05/growing-object-oriented-software-guided-by-tests-without-mocks/">link</a> . <br><a name="habracut"></a><br><h2>  Good parts </h2><br>  Let's start with the good stuff.  Most of them are in the first two sections of the book. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The authors define the purpose of automatic testing as the creation of a safety net (safety net), which helps to detect regressions in the code.  In my opinion, this is indeed the most important advantage that the availability of tests gives us.  Safety net helps to achieve confidence that the code works as expected, which, in turn, allows you to quickly add new features and refactor existing ones.  A team becomes much more productive if it is confident that changes made to the code do not lead to breakdowns. <br><br>  The book also describes the importance of setting up the deployment environment in its early stages.  This should be the first priority of any new project, since  allows you to identify potential integration errors in the early stages, before a significant amount of code is written. <br><br>  To do this, the authors propose to start with the construction of a ‚Äúwalking skeleton‚Äù - the simplest version of the application, which at the same time in its implementation affects all layers of the application.  For example, if this is a web application, the skeleton may show a simple HTML page that requests a string from a real database.  This skeleton should be covered by the end-to-end test, from which the test suite will begin. <br><br>  This technique also allows you to focus on deploying the deployment pipeline without paying much attention to the application architecture. <br><br>  The book offers a two-level TDD cycle: <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/getpro/habr/post_images/b55/1af/fa1/b551affa1268f9f01de8ac01070a036f.png" alt="image"></div><br>  In other words, start each new functionality with an end-to-end test and work your way towards successfully passing this test through the usual red-green-refactor cycle. <br><br>  End-to-end here appear more as a measure of progress.  Some of these tests may be in the "red" state, because  The feature is not yet implemented, this is normal.  Unit tests at the same time act as a safety net and should be green all the time. <br><br>  It is important that the end-to-end tests affect as many external systems as possible, this will help to identify integration errors.  At the same time, the authors recognize that some external systems will have to be replaced with plugs in any case.  The question of what to include in end-to-end tests should be decided for each project separately, there is no universal answer. <br><br>  The book proposes to extend the classic 3-step TDD cycle, adding a fourth step to it: make the error message more understandable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92e/0c2/bbb/92e0c2bbbe7274f6ca0f568193dc9262.png" alt="image"></div><br>  This will help to ensure that if the test fails, you can understand that it‚Äôs not so easy to look at the error message without starting the debugger. <br><br>  The authors recommend developing the application in a ‚Äúvertical way‚Äù (end to end) from the very beginning.  Do not spend too much time polishing the architecture, start with some kind of request coming from the outside (for example, from the UI) and process this request completely, including all application layers (UI, logic, DB) with the minimum possible amount of code.  In other words, do not build the architecture in advance. <br><br>  Another great tip is to test behavior, not methods.  Very often this is not the same thing, because  a unit of behavior can affect several methods or even classes. <br><br>  Another interesting point is the recommendation to make the system under test (SUT) context-independent: <br><br>  <i>"No object should have an idea about the system in which it is running."</i> <br><br>  This is essentially the concept of domain model isolation.  Domain classes should not be dependent on external systems.  Ideally, you should be able to completely snatch them from the current environment and run without any additional effort.  In addition to the obvious advantages associated with better code testability, this method allows you to simplify your code, because  You are able to focus on the domain without paying attention to aspects that are not related to your domain (database, network, etc.). <br><br>  The book is the original source of the fairly well-known rule of ‚ÄúReplace only the types that you own‚Äù (‚ÄúOnly mock types that you own‚Äù).  In other words, use mocks only for types that you wrote yourself.  Otherwise, you cannot guarantee that your mocks correctly model the behavior of these types. <br><br>  Interestingly, during the book, the authors themselves break this rule a couple of times and use mocks for types from external libraries.  Those types are pretty simple, so there really isn‚Äôt much point in creating your own wrappers over them. <br><br><h2>  Bad parts </h2><br>  Despite a lot of valuable advice, the book also provides potentially harmful recommendations, and there are quite a few such recommendations. <br><br>  The authors are advocates of a mockist approach to unit testing (for more on differences here: <a href="http://martinfowler.com/articles/mocksArentStubs.html">mockist vs classicist</a> ) even when it comes to communication between individual objects within a domain model.  In my opinion, this is the greatest shortcoming of the book, all the others are a consequence of it. <br><br>  To substantiate their approach, the authors give the definition of OOP, given by Alan Kay: <br><br>  <i>‚ÄúThe main idea is messaging.</i>  <i>The key to creating a good and expandable application lies in the design of how its various modules communicate with each other, and not how they are built inside. ‚Äù</i> <br><br>  They then conclude that the interactions between objects are what you should focus on primarily when unit testing.  By this logic, communication between classes is what ultimately makes the system what it is. <br><br>  There are two problems with this view.  First, the definition of OOP, given by Alan Kay, is inappropriate here.  It is rather vague to draw such far-reaching conclusions based on it and has little to do with modern OOP languages. <br><br>  Here is another famous quote from him: <br><br>  <i>"I came up with the phrase" object-oriented ", and I did not mean C ++."</i> <br><br>  And of course, you can safely replace here C ++ with C # or Java. <br><br>  The second problem with this approach is that the individual classes are too small (fine-grained) to be treated as independent communicators.  The way they communicate with each other often changes and has little to do with the final result, which we should ultimately check in tests.  The communication pattern between objects is an implementation detail and becomes part of the API only when communication crosses the system‚Äôs boundaries: when your domain model begins to communicate with external services.  Unfortunately, the book does not make these differences. <br><br>  The disadvantages of the approach suggested by the book become obvious if you look at the project code from Chapter 3.  The focus on communication between the objects not only leads to fragile tests because of their sticking to implementation details, but also leads to an over-complicated design with cyclic dependencies, header interfaces and an excessive number of layers of abstractions. <br><br>  In the rest of the article, I'm going to show how a project from a book can be modified and what effect it has on unit tests. <br><br>  The original codebase is written in Java, the modified version is in C #.  I rewrote the project completely, including unit tests, end-to-end tests, UI, and an emulator for the XMPP server. <br><br><h2>  Project </h2><br>  Before plunging into code, let's look at the subject area.  Project from the book - Auction Sniper.  Bot that participates in auctions on behalf of the user.  Here is its interface: <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/423/664/b53/423664b536e5ae6a4894ea70fc022240.png" alt="image"></div><br>  Item Id - identifier of the item that is currently being sold.  Stop Price - the maximum price you are willing to pay for it as a user.  Last Price - the last price you or other bidders offered for this item.  Last Bid is the last price you made.  State - the state of the auction.  In the screenshot above, you can see that the application has won both subjects, which is why both prices are the same in both cases: they came from your application. <br><br>  Each line in the list represents a separate agent that listens to messages coming from the server and responds to them by sending commands in response.  Business rules can be summarized as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/747/f91/cc6/747f91cc69546307f86f39778af58759.png" alt="image"></div><br>  Each agent (they are also called Auction Sniper) starts from the top of the picture, in the Joining state.  He then waits until the server sends an event with the current state of the auction ‚Äî the last price, the user name of the bidder and the minimum price increase required to outbid the last bid.  This type of event is called Price. <br><br>  If the required bid is less than the stop price that the user has set for the item, the application sends its bid (bid) and enters the Bidding state.  If a new Price event shows that our bid is in the lead, Sniper does nothing and goes into the Winning state.  Finally, the second event sent by the server is the Close event.  When it comes, the application looks in what status it is now for this item.  If in Winning, then goes to Won, all other statuses go to Lost. <br><br>  That is, in fact, we have a bot that sends commands to the server and supports the internal state machine. <br><br>  Let's look at the architecture of the application proposed by the book.  Here is her diagram (click to enlarge): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b1c/e19/3cd/b1ce193cd8d9ce12b62e823a0a5d5155.png" alt="image"></a> <br><br>  If you think that it is over-complicated for such a simple task, it is because it is.  So, what problems do we see here? <br><br>  The very first remark, striking, is a large number of header interfaces.  This term refers to an interface that completely copies a single class that implements this interface.  For example, XMPPAuction is one to one correlated with the Auction interface, AcutionSniper with the AuctionEventListener, and so on.  Interfaces with a single implementation are not an abstraction and are considered to be ‚Äú <a href="http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/">design smell</a> ‚Äù. <br><br>  Below is the same diagram without interfaces.  I removed them to make the structure of the diagram more understandable. <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/969/049/f1d/969049f1d8a23266ca2dad214262321e.png" alt="image"></div><br>  The second problem here is cyclical dependencies.  The most obvious of these is between XMPPAuction and AuctionSniper, but it is not the only one.  For example, AuctionSniper refers to SnipersTableModel, which in turn refers to SniperLauncher, and so on until the link comes back to AuctionSniper. <br><br>  Cyclic dependencies in the code load our brains when we try to read and understand this code.  The reason is that with such dependencies you do not know where to start.  To understand the purpose of one of the classes, you need to put in your head a whole graph of classes, cyclically connected with each other. <br><br>  Even after I completely rewrote the project code, I often had to refer to diagrams in order to understand how different classes and interfaces relate to each other.  We, people, understand hierarchies well, we often have difficulties with cyclical graphs.  Scott Wlaschin wrote a great article on this topic: <a href="https://fsharpforfunandprofit.com/posts/cyclic-dependencies/">Cyclic dependencies are evil</a> . <br><br>  The third problem is the lack of isolation of the domain model.  Here‚Äôs what the architecture looks like in terms of DDD: <br><br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/3c2/eba/c82/3c2ebac8227fc454c8d763b521076275.png" alt="image"></div><br>  Classes in the middle make up a domain model.  At the same time, they communicate with the auction server (left) and with the UI (right).  For example, SniperLauncher communicates with XMPPAuctionHouse, AuctionSniper - with XMPPAcution and SnipersTableModel. <br><br>  Of course, they do this using interfaces, not real classes, but, again, adding interfaces to the header model does not mean that you automatically begin to follow Dependency Inversion principles. <br><br>  Ideally, the domain model should be self-sufficient, the classes inside it should not talk to classes from the outside world, neither using specific implementations, nor their interfaces.  Proper isolation means that a domain model can be tested using a functional approach without involving mocks. <br><br>  All these shortcomings are a common consequence of the situation where developers focus on testing the interactions between the classes within the domain model, rather than their public API.  This approach leads to the creation of header interfaces, since  otherwise, it becomes impossible to ‚Äúlock in‚Äù the neighboring classes, to a large number of cyclic dependencies, and the domain classes that communicate directly with the outside world. <br><br>  Let's now take a look at the unit tests themselves.  Here is an example of one of them: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportsLostIfAuctionClosesWhenBidding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ allowingSniperBidding(); ignoringAuction(); context.checking(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Expectations() {{ atLeast(<span class="hljs-number"><span class="hljs-number">1</span></span>).of(sniperListener).sniperStateChanged( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SniperSnapshot(ITEM_ID, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">168</span></span>, LOST)); when(sniperState.is(‚Äúbidding‚Äù)); }}); sniper.currentPrice(<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>, PriceSource.FromOtherBidder); sniper.auctionClosed(); }</code> </pre> <br>  First, this test focuses on communication between classes, which leads to the need to create and maintain a significant amount of code associated with the creation of mocks, but this is not the most important thing here.  The main disadvantage here is that this test contains information about the implementation details of the test object.  The when clause here means that the test knows about the internal state of the system and simulates this state in order to test it. <br><br>  Here is another example: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Mockery context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mockery(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SniperLauncher launcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SniperLauncher(auctionHouse, sniperCollector); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> States auctionState = context.states(‚Äúauction state‚Äù).startsAs(‚Äúnot joined‚Äù); <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addsNewSniperToCollectorAndThenJoinsAuction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Item item = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Item(‚Äúitem <span class="hljs-number"><span class="hljs-number">123</span></span>‚Äù, <span class="hljs-number"><span class="hljs-number">456</span></span>); context.checking(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Expectations() {{ allowing(auctionHouse).auctionFor(item); will(returnValue(auction)); oneOf(auction).addAuctionEventListener(with(sniperForItem(item))); when(auctionState.is(‚Äúnot joined‚Äù)); oneOf(sniperCollector).addSniper(with(sniperForItem(item))); when(auctionState.is(‚Äúnot joined‚Äù)); one(auction).join(); then(auctionState.is(‚Äújoined‚Äù)); }}); launcher.joinAuction(item); }</code> </pre><br>  This code is a clear example of a leak of knowledge about system implementation details.  The test in this example implements a full-fledged state machine to verify that the class under test calls the methods of its neighbors in this particular order (the last three lines): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SniperLauncher</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRequestListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">joinAuction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Item item)</span></span></span><span class="hljs-function"> </span></span>{ Auction auction = auctionHouse.auctionFor(item); AuctionSniper sniper = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuctionSniper(item, auction); auction.addAuctionEventListener(sniper); <span class="hljs-comment"><span class="hljs-comment">// These collector.addSniper(sniper); // three auction.join(); // lines } }</span></span></code> </pre><br>  Because of the high coherence with the internals of the system under test, tests like this are very fragile.  Any non-trivial refactoring will lead to their fall, regardless of whether this refactoring is broken or not.  This in turn significantly reduces their value, because  tests often give false positives and because of this they are no longer perceived as part of a reliable safety net. <br><br>  The complete project source code from the book can be found here: <a href="https://github.com/sf105/goos-code">link</a> . <br><br><h2>  Alternative implementation without mocks </h2><br>  All of the above are rather serious statements, and obviously I need to back them up with an alternative solution.  The full source code for this alternative solution can be found <a href="https://github.com/vkhorikov/Goos">here</a> . <br><br>  In order to understand how a project can be implemented with proper isolation of the domain domain, without cyclic dependencies and without an excessive amount of unnecessary abstractions, let's look at the functions of the application.  It receives events from the server and responds to them with some commands, maintaining an internal state machine: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05d/104/f4d/05d104f4ddcebcbffae6908d94e753a9.png" alt="image"></div><br>  And that's essentially all.  In reality, this is almost an ideal functional (functional programming) architecture, and nothing prevents us from implementing it as such. <br><br>  Here‚Äôs how the alternative solution looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/c5d/a8a/a9ec5da8acc79a9a2fb4d5156fdee580.png" alt="image"></div><br>  Let's look at some important differences.  First, the domain model is completely isolated from the outside world.  The classes in it do not speak directly with the view model or with the XMPP Server, all links are directed <b><i>to the</i></b> domain classes, and not vice versa. <br><br>  All communication with the outside world, be it a server or a UI, is given to the Application Services layer, the role of which in our case is performed by AuctionSniperViewModel.  It acts as a shield that protects the domain model from the unwanted influence of the outside world: it filters incoming events and interprets outgoing commands. <br><br>  Secondly, the domain model does not contain cyclic dependencies.  The structure of classes here is tree-like, which means that a potential new developer has a clear place from which he can start reading this code.  He can start from casting the tree and move up the tree step by step, without having to place the entire class diagram in his head at a time.  The code from this particular project is pretty simple, of course, so I'm sure you would have no problem reading it even if there are circular dependencies.  However, in more complex scenarios, a clear tree structure is a big plus in terms of simplicity and readability. <br><br>  By the way, the well-known DDD pattern - Aggregate - is aimed at solving this particular problem.  By grouping several entities into a single unit, we reduce the number of links in the domain model and thus make the code easier. <br><br>  The third important point here is that the alternative version contains no interfaces.  This is one of the advantages of having a fully isolated domain model: you just do not need to add interfaces to the code if they do not represent a real abstraction.  In this example, we have no such abstractions. <br><br>  Classes in the new implementation are clearly divided according to their purpose.  They either contain business knowledge - these are classes within the domain model, - or they communicate with the outside world - classes outside the domain model, - but never both.  This separation of duties allows us to focus on one problem at a time: we either think about domain logic, or decide how to respond to incentives from the UI and the auction server. <br><br>  Again, this simplifies the code, and therefore makes it more supported.  Here‚Äôs what the most important part of the <a href="">Application Services layer</a> looks like: <br><br><pre> <code class="hljs cmake">_chat.MessageReceived += ChatMessageRecieved; private void ChatMessageRecieved(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>) { AuctionEvent ev = AuctionEvent.From(<span class="hljs-keyword"><span class="hljs-keyword">message</span></span>); AuctionCommand <span class="hljs-keyword"><span class="hljs-keyword">command</span></span> = _auctionSniper.Process(ev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">command</span></span> != AuctionCommand.None()) { _chat.SendMessage(<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>.ToString()); } }</code> </pre><br>  Here we get the string from the auction server, transform it into event (validation is included in this step), pass it to the sniper and if the resultant command is not None, send it back to the server.  As you can see, the lack of business logic makes the Application Services layer trivial. <br><br><h2>  Tests without mokov </h2><br>  Another advantage of an isolated domain model is the ability to test it using a functional approach.  We can look at each part of the behavior in isolation from each other and check the end result it generates without paying attention to how this result was achieved. <br><br>  For example, the following test checks how the Sniper, who has just joined the auction, responds to receiving the Close event: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Joining_sniper_loses_when_auction_closes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sniper = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuctionSniper(‚Äú‚Äù, <span class="hljs-number"><span class="hljs-number">200</span></span>); AuctionCommand command = sniper.Process(AuctionEvent.Close()); command.ShouldEqual(AuctionCommand.None()); sniper.StateShouldBe(SniperState.Lost, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  It checks that the resultant command is empty, which means the sniper is not taking any action, and that the state becomes Lost after that. <br><br>  Here is another example: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sniper_bids_when_price_event_with_a_different_bidder_arrives</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sniper = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuctionSniper(‚Äú‚Äù, <span class="hljs-number"><span class="hljs-number">200</span></span>); AuctionCommand command = sniper.Process(AuctionEvent.Price(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ‚Äúsome bidder‚Äù)); command.ShouldEqual(AuctionCommand.Bid(<span class="hljs-number"><span class="hljs-number">3</span></span>)); sniper.StateShouldBe(SniperState.Bidding, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre><br>  This test checks that the sniper sends a request when the current price and the minimum increment is less than the set price limit. <br><br>  The only place where mocks can potentially be justified is when testing the Application Services layer, which communicates with external systems.  But this part is covered with end-to-end tests, so in this particular case there is no need for this.  By the way, the end-to-end tests in the book are great, I did not find anything that could be changed or improved in them. <br><br>  The source code for the alternative implementation can be found <a href="https://github.com/vkhorikov/Goos">here</a> . <br><br><h2>  Conclusion </h2><br>  Focusing on communication between individual classes leads to fragile tests, as well as damage to the project architecture itself. <br><br>  To avoid these disadvantages: <br><br><ul><li>  Do not create header interfaces for domain classes. <br></li><li>  Minimize the number of circular dependencies in the code. <br></li><li>  Isolate the domain model: do not allow domain classes to communicate with the outside world. <br></li><li>  Reduce the number of unnecessary abstractions. <br></li><li>  Focus on checking the status and the final result when testing a domain model, not communication between classes. <br></li></ul><br><h2>  Pluralsight course </h2><br>  I just got a new course on Pluralsight on pragmatic unit testing.  In it, I tried to talk about the practice of building unit tests, leading to the best result with the least effort.  The guidelines from the article above became part of this course and are discussed in detail, with a multitude of examples. <br><br>  I also have several dozen trial codes that give unlimited access to Pluralsight for a period of 30 days (to the entire library, not just my course).  If someone needs - write in a personal, happy to share. <br><br>  Course link: <a href="https://www.pluralsight.com/courses/pragmatic-unit-testing">Building a Pragmatic Unit Test Suite</a> . </div><p>Source: <a href="https://habr.com/ru/post/312248/">https://habr.com/ru/post/312248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312232/index.html">4 main lessons that we learned when starting our first service</a></li>
<li><a href="../312234/index.html">Kryptonomicon: great accordion, hello from the 90s and the best book about techies</a></li>
<li><a href="../312236/index.html">How MikroTik sees neighbors. Neighbor discovery update in RouterOS 6.38</a></li>
<li><a href="../312238/index.html">Bram Cohen: I wrote BitTorrent sitting in the living room, unemployed, in shorts</a></li>
<li><a href="../312240/index.html">Filter events by categories in the Event Map report</a></li>
<li><a href="../312250/index.html">Open access to the tool for compiling lists of English words from films, books and articles</a></li>
<li><a href="../312256/index.html">LINQ: Dynamic Query Filtering</a></li>
<li><a href="../312258/index.html">A sysadmin with delusions of automation and a big remake of processes</a></li>
<li><a href="../312260/index.html">A bit about security in the "cloud": Experience IaaS-provider "1cloud"</a></li>
<li><a href="../312262/index.html">Live Webcast Progressive Web Apps Day Begins</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>