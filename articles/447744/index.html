<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Climbing Elbrus - Reconnaissance. Technical Part 2. Interrupts, exceptions, system timer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to explore Elbrus by porting Embox to it. 

 This article is the second part of the technical article on the architecture of Elbrus. The f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Climbing Elbrus - Reconnaissance. Technical Part 2. Interrupts, exceptions, system timer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  We continue to explore <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D1%258C%25D0%25B1%25D1%2580%25D1%2583%25D1%2581_2000">Elbrus</a> by porting <a href="https://github.com/embox/embox">Embox</a> to it. <br><br>  This article is the second part of the technical article on the architecture of Elbrus.  The <a href="https://habr.com/ru/company/embox/blog/447704/">first part</a> dealt with stacks, registers, and so on.  Before reading this part, we recommend to study the first one, since it tells about the basic things of the Elbrus architecture.  This part deals with timers, interrupts and exceptions.  This, again, is not official documentation.  She should contact the developers of Elbrus in the <a href="http://www.mcst.ru/">MCST</a> . <a name="habracut"></a><br>  Starting the study of Elbrus, we wanted to quickly start the timer, because, as you understand, preemptive multitasking does not work without it.  For this, it seemed enough to implement the interrupt controller and the timer itself, but we ran into <s>unexpected</s> expected difficulties, but without them.  We began to look for debugging opportunities and found out that the developers took care of this by entering several commands that allow us to raise various exceptions.  For example, you can generate a special type exception using the PSR (Processor Status Register) and UPSR (User processor status register) registers.  For PSR, the exc_last_wish bit is the exc_last_wish flag for generating an exception when returning from the procedure, and for the UPSR is exc_d_interrupt, this is the pending interrupt flag generated by the VFDI operation (Check pending interrupt flag). <br><br>  The code is as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPSR_DI (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   .h  */</span></span></span><span class="hljs-meta"> rrs %upsr, %r1 ors %r1, UPSR_DI, %r1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* upsr |= UPSR_DI; */</span></span></span><span class="hljs-meta"> rws %r1, %upsr vfdi </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre> <br>  Launched.  But nothing happened, the system was hanging somewhere, nothing was output to the console.  Actually, this is what we saw when we tried to start an interruption from the timer, but then there were many components, but it was clear that something interrupted the sequential execution of our program, and control was transferred to the exception table (in terms of the Elbrus architecture, it‚Äôs more correct to speak not about the table interrupts on exception table).  We assumed that the processor nevertheless produced an exception, but there, where he transferred control, is some kind of ‚Äúgarbage‚Äù.  As it turned out, he transfers control to the very place where we put the Embox image, which means there was an entry point - the entry function. <br><br>  To check we did the following.  Brought the entry counter to entry ().  Initially, all CPUs start with interrupts turned off, enter entry (), after which we leave only one core active, all others go into an infinite loop.  After the counter has reached the number of CPUs, we consider that all subsequent hits on the entry are exceptions.  I remind you that it used to be as described in <a href="https://habr.com/ru/company/embox/blog/421441/">our very first article about Elbrus</a> <br><br><pre> <code class="cpp hljs"> cpuid = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;last_cpuid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpuid &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* copy of trap table */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;_t_entry, <span class="hljs-number"><span class="hljs-number">0x1800</span></span>); kernel_start();</code> </pre> <br>  Did so <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); ... } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> cpu_idle(); } e2k_kernel_start(); }</code> </pre> <br>  And finally, we saw the reaction to the input to the interrupt (just with the help of printf, the line was output). <br><br>  Here it is worth explaining that initially in the first version we hoped to copy the table of exceptions, but first, it turned out that it is located at our address, and second, we did not manage to make a correct copy.  I had to rewrite the linker scripts, the entry point into the system, and of the interrupt handler, that is, the assembler part was needed, about it a bit later. <br><br>  This is how the part of the modified linker script now looks like: <br><br><pre> <code class="cpp hljs">.text : { _start = .; _t_entry = .; <span class="hljs-comment"><span class="hljs-comment">/* Interrupt handler */</span></span> *(.ttable_entry0) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Syscall handler */</span></span> *(.ttable_entry1) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* longjmp handler */</span></span> *(.ttable_entry2) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1800</span></span>; _t_entry_end = .; *(.e2k_entry) *(.cpu_idle) <span class="hljs-comment"><span class="hljs-comment">/* text */</span></span> }</code> </pre><br>  that is, we removed the entry section for the exception table.  There is also a cpu_idle section for those CPUs that are not used. <br><br>  This is what the login function for our active kernel looks like on which Embox will run: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> psr; <span class="hljs-comment"><span class="hljs-comment">/*    CPU ‚Äú‚Äù */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idled_cpus_count &lt; CPU_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) ; ... <span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> e2k_upsr_write(e2k_upsr_read() &amp; ~UPSR_FE); kernel_start(); <span class="hljs-comment"><span class="hljs-comment">/*   Embox */</span></span> }</code> </pre> <br>  Well, according to the VFDI instructions, an exception has been made.  Now you need to get his number to make sure that this is the correct exception.  For this purpose there are TIR (Trap Info registers) interrupt information registers in Elbrus.  They contain information about the last several commands, that is, the final part of the trace (trace).  Trace is collected during program execution and ‚Äúfrozen‚Äù when entering an interrupt.  TIR includes the younger (64 bits) and older (64 bits) parts.  The low word contains exception flags, and the high word is a pointer to the instruction that led to the exception and the number of the current TIR'a.  Accordingly, in our case, exc_d_interrupt is the 4th bit. <br><br>  Note we still have some misunderstanding regarding the depth (count) of TIRs.  The documentation provides: <br><blockquote>  ‚ÄúThe TIR memory depth, i.e. the number of trap info registers, is determined by <br>  TIR_NUM macro, equal to the number of processor pipeline stages required for <br>  issuing all possible special situations.  TIR_NUM = 19; " </blockquote>  In practice, we see depth = 1, and therefore we use only the TIR0 register. <br><br>  Specialists at the MCST explained to us that everything is correct, and for ‚Äúaccurate‚Äù interruptions there will be only TIR0, and for other situations there may be more.  But since so far we are talking only about interrupts from the timer, this does not prevent us. <br><br>  Ok, now let's see what is needed for the correct entry / exit from the exception handler.  In fact, it is necessary to save on input and restore on output 5 of the following registers.  The three control transfer preparation registers are ctpr [1,2,3], and the two cycle control registers are the ILCR (Cycle Counter Original Value Register) and LSR (Cycle Status Register). <br><br><pre> <code class="cpp hljs">.type ttable_entry0,@function ttable_entry0: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">1</span></span>; rrd %ctpr1, %dr1 rrd %ctpr2, %dr2 rrd %ctpr3, %dr3 rrd %ilcr, %dr4 rrd %lsr, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* sizeof pt_regs */</span></span> getsp -(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>), %dr0 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + PT_CTRP1] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr1 = ctpr1 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + PT_CTRP2] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr2 = ctpr2 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + PT_CTRP3] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr3 = ctpr3 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + PT_ILCR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ilcr = ilcr */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + PT_LSR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;lsr = lsr */</span></span> disp %ctpr1, e2k_entry ct %ctpr1</code> </pre> <br>  Actually, that's all, after exiting the exception handler, you need to restore these 5 registers. <br><br>  We do this with a macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_COMMON_REGS(regs) \ ({ \ uint64_t ctpr1 = regs-&gt;ctpr1, ctpr2 = regs-&gt;ctpr2, \ ctpr3 = regs-&gt;ctpr3, lsr = regs-&gt;lsr, \ ilcr = regs-&gt;ilcr; \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ctpr2 is restored first because of tight time constraints \ * on restoring ctpr2 and aaldv. */</span></span></span><span class="hljs-meta"> \ E2K_SET_DSREG(ctpr1, ctpr1); \ E2K_SET_DSREG(ctpr2, ctpr2); \ E2K_SET_DSREG(ctpr3, ctpr3); \ E2K_SET_DSREG(lsr, lsr); \ E2K_SET_DSREG(ilcr, ilcr); \ })</span></span></code> </pre> <br>  It is also important not to forget, after register recovery, to call operation DONE (Return from the hardware interrupt handler).  This operation is needed in particular in order to correctly handle the interrupted control transfer operations.  We do this using a macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_DONE \ do { \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{nop 3} {done}"</span></span></span><span class="hljs-meta"> ::: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ctpr3"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  We actually do the return from the interrupt directly in the C code using these two macros. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE;</code> </pre> <br><h3>  External interrupts </h3><br>  Let's start with how to enable external interrupts.  In Elbrus, APIC (more precisely, its counterpart) is used as an interrupt controller, Embox already had this driver.  Therefore, it was possible to pick up a system timer to it.  There are two timers, one kind of very similar to the <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">PIT</a> , the other <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">LAPIC Timer</a> , also quite standard, so it makes no sense to talk about them.  Both that, and that looked simply, and that and that in Embox already was, but the driver of the LAPIC-timer looked more promising, besides, the implementation of the PIT timer seemed to us more non-standard.  Consequently, it seemed easier to finish.  In addition, in the official documentation, the APIC and LAPIC registers were described, which differed slightly from the originals.  It makes no sense to bring them, because you can see in the original. <br><br>  In addition to enabling interrupts in APIC, you must enable interrupt handling through the PSR / UPSR registers.  Both registers have permission flags for external interrupts and nonmaskable interrupts.  <i>But</i> it is very important to note here that the PSR register is <i>local</i> to the function (this was mentioned in the <a href="https://habr.com/ru/company/embox/blog/447704/">first technical part</a> ).  And this means that if you set it inside a function, then when you call all subsequent functions, it will be inherited, but when you return from the function it will return its original state.  Hence the question, but how to manage interrupts? <br><br>  We use the following solution.  The PSR allows you to enable management via UPSR, which is already global (which is what we need).  Therefore, we allow management via UPSR directly (important!) Before the Embox kernel login function: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PSR is local register and makes sense only within a function, * so we set it here before kernel start. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rrs %%psr, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr) :)</span></span></span></span>; psr |= (PSR_IE | PSR_NMIE | PSR_UIE); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rws %0, %%psr"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ri"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr))</span></span></span></span>; kernel_start();</code> </pre> <br>  Somehow by chance, after refactoring, I took and rendered these lines into a separate function ... And the register is local to the function.  It is clear that everything is broken :) <br><br>  So, in the processor, everything you need is supposedly turned on, go to the interrupt controller. <br><br>  As we already sorted out above, information about the exception number is in the TIR register.  Further, the 32nd bit in this register reports that an external interrupt has occurred. <br><br>  After turning on the timer followed a couple of days of torment, since no interruption could be obtained.  The reason was funny enough.  In Elbrus 64-bit pointers, and the address of the register in the APIC is in uint32_t, so we used them.  But it turned out that if you need, for example, to lead 0xF0000000 to a pointer, then you will receive not 0xF0000000, but 0xFFFFFFFFF0000000.  That is, the compiler will extend your unsigned int sign. <br><br>  Here, of course, it was necessary to use uintptr_t, therefore, as it turned out, in the C99 standard this kind of type conversion was implementation defined. <br><br>  After we finally saw the raised 32nd bit in TIR, we began to look for how to get the interrupt number.  It turned out to be quite simple, although not at all like on x86, this is one of the differences between LAPIC implementations.  For Elbrus, in order to get the interruption number, you need to climb into the special LAPIC register: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APIC_VECT (0xFEE00000 + 0xFF0)</span></span></code> </pre> <br>  where 0xFEE00000 is the base address of the LAPIC registers. <br><br>  That's all, it turned out to pick up the system timer and LAPIC timer. <br><br><h3>  Conclusion </h3><br>  The information given in the first two technical parts of the article about the Elbrus architecture is enough to implement hardware interrupts and preemptive multitasking in any OS.  Actually, the above screenshots show this. <br><br><img src="https://habrastorage.org/webt/qm/qz/3p/qmqz3pbvuvohscm_qon1edf5jno.png"><br><br>  This is not the last technical part about the architecture of Elbrus.  Now we are mastering memory management (MMU) in Elbrus, we hope we will soon tell you about it.  We need this not only for the implementation of virtual address spaces, but also for normal work with peripherals, because through this mechanism you can disable or enable caching of a specific area of ‚Äã‚Äãthe address space. <br><br>  Everything that is written in the article can be found in the <a href="https://github.com/embox/embox">Embox</a> repository.  You can also build and run, if of course there is a hardware platform.  True, this requires a compiler, and it can only be obtained in the <a href="http://www.mcst.ru/">MCST</a> .  Official documentation can be requested there. </div><p>Source: <a href="https://habr.com/ru/post/447744/">https://habr.com/ru/post/447744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447730/index.html">The evolution of email marketing: from QWERTYUIOP to GDPR</a></li>
<li><a href="../447734/index.html">Why the front-end should understand the principles of UI</a></li>
<li><a href="../447736/index.html">Video from the drone - a new trend of social networks</a></li>
<li><a href="../447738/index.html">Julian Assange arrested by British police</a></li>
<li><a href="../447742/index.html">What is DevOps methodology and who needs it</a></li>
<li><a href="../447746/index.html">Business logic in a database using SchemaKeeper</a></li>
<li><a href="../447748/index.html">Linux Virtual File Systems: Why Do They Need It and How Do They Work? Part 2</a></li>
<li><a href="../447750/index.html">New processors for data centers - parse announcements of recent months</a></li>
<li><a href="../447754/index.html">Application in the menu bar for macOS</a></li>
<li><a href="../447756/index.html">New Gartner Application Monitoring Solution (APM) quadrant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>