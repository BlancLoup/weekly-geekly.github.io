<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.1 of 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content of the main course 


- Article 1: Bresenham algorithm 
- Article 2: rasterization of the triangle + clipping of the rear faces 
- Article 3: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.1 of 6</h1><div class="post__text post__text-html js-mediator-article"><h1>  Content of the main course </h1><br><ul><li>  <a href="http://habrahabr.ru/post/248153/">Article 1: Bresenham algorithm</a> </li><li>  <a href="http://habrahabr.ru/post/248159/">Article 2: rasterization of the triangle + clipping of the rear faces</a> </li><li>  <a href="http://habrahabr.ru/post/248179/">Article 3: Removing invisible surfaces: z-buffer</a> </li><li>  Article 4: Required Geometry: Matrix Festival <br><ul><li>  <a href="http://habrahabr.ru/post/248611/">4a: Construction of perspective distortion</a> </li><li>  <a href="http://habrahabr.ru/post/248723/">4b: we move the camera and what follows from this</a> </li><li>  <a href="http://habrahabr.ru/post/249467/">4c: a new rasterizer and perspective distortion correction</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/248963/">Article 5: We write shaders for our library</a> </li><li>  <a href="http://habrahabr.ru/post/249139/">Article 6: A little more than just a shader: shadow rendering</a> </li></ul><h3>  Code enhancement </h3><br><ul><li>  <a href="http://habrahabr.ru/post/248909/"><b>Article 3.1: It‚Äôs time to refactor</b></a> </li><li>  <a href="http://habrahabr.ru/post/249101/">Article 3.14: Beautiful Matrix Class</a> </li><li>  how does the new rasterizer work </li></ul><br><h3>  Communication outside Habr </h3>  If you have questions and do not want to ask them in the comments, or simply do not have the opportunity to write in the comments, join the jabber conference 3d@conference.sudouser.ru <br><br>  This article was written in close cooperation (thanks to the creators of XMPP) with <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> , the author of this course. We began a massive code refactoring aimed at achieving maximum compactness and readability.  We deliberately chose to abandon a number of possible and even obvious optimizations for obtaining the most accessible code for learning examples. <br>  P. S <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> just the other day will post an article about shaders! <br><a name="habracut"></a><br>  <b>UPD: ATTENTION!</b>  <b>The section, starting with numbers 3.1, 3.14 and 3.141 and on, will be about the intricacies of the implementation of the basis of the basics of computer graphics - linear algebra and computational geometry.</b>  <b>About the principles of graphics writes <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> , but I will write about how it can be clearly programmed!</b> <br>  UPD2: I express special thanks to <a href="https://habrahabr.ru/users/lemelisk/" class="user_link">lemelisk</a> for careful study of the article and the indicated inaccuracies. <br><img src="https://habrastorage.org/getpro/habr/post_images/f2b/f83/c59/f2bf83c5994b9051aaba499cb05e65bf.png" alt="image"><br><h4>  1. General Provisions </h4><br>  The previous articles of the cycle show that to write a software renderer you need to implement a fair share of algorithms and mathematical objects related to linear algebra and geometry.  First of all, we are talking about vectors and matrices, of course.  We use vectors and matrices of small dimensions, so it is convenient for us to place them on the stack.  We implemented them using the <code>vec&lt;size_t Dim, typename number_t&gt;</code> and <code>mat&lt;size_t size, typename number_t&gt;</code> .  In the <a href="http://habrahabr.ru/post/243011/">comments</a> to one of the articles, I showed that (at least when in the role of the GCC compiler), the use of cycles even in such small cases gives a shorter and more compact machine code, and also insures against silly typos (note the important study - <a href="http://habrahabr.ru/company/pvs-studio/blog/224783/">"Effect of the last line"</a> ) when element-wisely typed, for example, matrix multiplication operations. <br>  The code in this article is written for the standard version of C ++ 98, so scary (return me auto!).  Perhaps I will prepare a separate article with the same code, but using the latest standard.  Hold on, templates with a variable number of parameters, there will be a job for you! <br><h4>  2 What is interesting in the process of merging and refactoring? </h4><br><h5>  2.1 Universal use of size_t for array indices </h5><br>  Recall that clause 18.1 of the C ++ standard, referring to clause 7.11 of <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">the C standard</a> , defines size_t as an unsigned integer type.  For us, this is convenient, because, firstly, it directly corresponds to the meaning of the index in the array, and secondly, to verify the fact that i really is within the array, we only need to check one condition: <code>(i &lt; _)</code> instead two: <code>(i &gt;= 0) &amp;&amp; (i &lt; _).</code>  Inappropriate int will be removed from all places. <br><h5>  2.2 Strange for loop </h5><br>  Here is a for loop, which some might find odd: <code>for(size_t i=Dim;i--;) {};</code>  This cycle will iterate over all values ‚Äã‚Äãof i from Dim-1 to 0. The enumeration will start from Dim-1, because before entering the cycle body, it will first be checked that i is non-zero, then decrement i, and only after that - the entrance to the cycle .  After the final iteration, we get i = 0 (the cycle should end), but we still need (in the sense of the operation i--) to subtract the unit from the unsigned i.  This action is well defined by the standard, so nothing bad will happen - we just get a value equal to <code>std::numeric_limits&lt;size_t&gt;::max()</code> .  Why was this cycle made, and not the traditional <code>for(size_t i=0;i&lt;Dim;i++)</code> ?  Two reasons.  First: to show an example of the correct passage along i to the decreasing direction with an unsigned variable.  You can often find an error: <code>for(size_t i=Dim-1;i&gt;=0;i--)</code> compiler, seeing the identically true expression [unsigned integer]&gt; = 0, will simply replace it with true: <code>for(size_t i=Dim-1;true;i--)</code> , which will lead to infinite looping.  The second: such a record is shorter by as many as three characters.  We will return to the for loop (as well as to the question ‚ÄúWhich is faster, ++ i or i ++‚Äù). <br><h6>  We can go further: </h6>  the fact is that most of our operations are very trivial, and the body of the loop that executes them consists of one line.  <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> suggested doing this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Number&gt;vec&lt;Dim,Number &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-(vec&lt;Dim,Number &gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;Dim,Number &gt;&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--; lhs[i]-=rhs[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; }</code> </pre><br>  In fact, we put our operation inside the loop header, making the loop body empty. <br><h5>  2.3 Template code for the vector </h5><br>  In our template for a vector, five methods are currently defined, two of which are operators: these are operators of taking constant and non-constant references to the vector element [].  Using the assert macro from <a href="http://www.cplusplus.com/reference/cassert/assert/">&lt;assert.h&gt;,</a> they check that the index passed to them remains within the array, which is very important for detecting completely stupid errors.  In the release version, we will add -D NDEBUG to the compiler keys, which will remove the macro from the code.  According <abbr title="If any trouble can happen, it will happen.">to Murphy's law</abbr> , after that everything will have to break, but we will overcome it. <br><div class="spoiler">  <b class="spoiler_title">Source code of index operators</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index) { assert(index&lt;Dim); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[index]; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> [](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[index]; }</code> </pre><br></div></div><br>  The fill method (const number_t &amp; val = 0) fills the vector with a constant.  The default is zero. <br><div class="spoiler">  <b class="spoiler_title">Source method fill</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; fill(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&amp; val=<span class="hljs-number"><span class="hljs-number">0</span></span>) { vec&lt;Dim, <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--; ret[i]=val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br></div></div><br>  The methods norm () and normalize () are designed to calculate the length of the vector and its normalization, respectively. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> norm() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>( (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) * (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ); }</code> </pre><br>  To calculate the norm, we use the fact that this is just a square root of the scalar product of a vector with itself.  Very briefly, capaciously, and at the same time closely connected with theory. <br>  Now normalization of the vector: <br><pre> <code class="cpp hljs">vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; normalize() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)/norm(); }</code> </pre><br>  Again, everything is exactly by definition: taken themselves and divided by their own length.  Please note that this function returns a normalized copy of the original vector, and does not change its coordinates so that it becomes single. <br>  Also note the widespread use of const in this code.  This, on the one hand, protects against stupid mistakes, even at the compilation stage.  On the other hand, const gives the compiler more information for optimizations.  Also note that there are no inline directives here.  This is due to the fact that we will do all the optimization later.  In addition, with -O3 GCC becomes so smart that it performs embedding itself.  Whether it will automatically embed our functions without explicit inline, we will again be considered in subsequent articles. <br><h5>  2.4 Binary operations on vectors and scalars </h5><br>  Operators of binary operations are outside the class vec.  They fully comply with the definitions of these operations in theory: <br><div class="spoiler">  <b class="spoiler_title">View source</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp;lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> ret=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--; ret+=lhs[i]*rhs[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--; lhs[i]+=rhs[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-(vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--; lhs[i]-=rhs[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--; lhs[i]*=rhs); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; }</code> </pre><br></div></div><br>  I draw your attention to the tactics of applying the left operand (lhs) in the last three implementations.  We receive a copy of it at the entrance, after which we work on this copy and return it.  If we received it via a constant link, we would have to do the copying on our own.  Here, the properties of our vectors and C ++ language coincided very well, which we used.  In the implementation of scalar multiplication, we don‚Äôt need to copy vectors at all - we do all the work with a constant link. <br><h5>  2.5 Separately - on the implementation of the division of a vector by a scalar </h5><br>  Since we all know mathematics, we can say with pleasure: ‚ÄúTo divide a vector by a scalar, we can use multiplication by the amount opposite to this scalar.‚Äù  And set up this: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/////////////////////////////    template&lt;size_t Dim,typename Number&gt;vec&lt;Dim,Number&gt; operator/(vec&lt;Dim,Number &gt; lhs, const Number&amp; rhs) { return(lhs*(static_cast&lt;Number&gt;(1)/rhs)); }</span></span></code> </pre><br>  The important point - as we did with the unit - we wrapped it in static_cast &lt;&gt; so that it always had the correct type when dividing.  However, having a simple test: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; int main() { const double a=100.8765; const double b=1.2345; cout.precision(100); cout &lt;&lt; a/b &lt;&lt;'\n' &lt;&lt; a*(1.0/b)&lt;&lt;'\n'; return 0; }</span></span></span></span></code> </pre><br>  We can see that the results did not agree: <br><pre> <code class="bash hljs">81.7144592952612 356384634040296077728271484375 81.7144592952612 498493181192316114902496337890625</code> </pre><br>  We obtain a more accurate value of the relationship using maxima: <br><pre> <code class="matlab hljs">(<span class="hljs-comment"><span class="hljs-comment">%i5) fpprec:100; (%i6) bfloat(100.8765/1.2345); (%o6) 8.17144592952612 356384634040296077728271484375b1</span></span></code> </pre><br>  We see that the value obtained by direct division is more accurate.  This is due to the accumulation of error in arithmetic operations.  Therefore, we will not be greedy, but write a separate implementation of the division operator: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/(vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&amp; rhs) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--; lhs[i]/=rhs); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; }</code> </pre><br><h5>  2.6 Operation of immersing a vector in a space of higher dimension </h5><br>  We need it in one of the versions of the rasterizer.  The essence of the operation is that we form a vector of higher dimension, fill the method fill it with a constant, which we passed, and then we copy into it the coordinates of our vector of smaller dimension. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; vec&lt;len,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; embed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; &amp;v,<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&amp; fill=<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   vec&lt;len,number_t&gt; ret = vec&lt;len,number_t&gt;::fill(fill); for (size_t i=Dim; i--; ret[i]=v[i]); return ret; }</span></span></code> </pre><br><h5>  2.7 Vector design operation </h5><br>  This operation, on the contrary, from a vector of higher dimension makes a vector of a smaller dimension, the extra coordinates are simply discarded: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; vec&lt;len,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; proj(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; &amp;v) { <span class="hljs-comment"><span class="hljs-comment">//  vec&lt;len,number_t&gt; ret; for (size_t i=len; i--; ret[i]=v[i]); return ret; }</span></span></code> </pre><br><h5>  2.8 Redefining the operator &lt;&lt; to output vectors into the ostream stream </h5><br>  For debugging it was necessary to implement the output of our vectors to the terminal.  To do this, we have further defined the &lt;‚Äå&lt; operator for the case when the left argument is a reference to ostream, and the right argument is our vector or matrix.  Now we can simply and habitually write cout &lt;‚Äå &lt;myvec: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; out,<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;Dim,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; v) { out&lt;&lt;<span class="hljs-string"><span class="hljs-string">"{ "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;Dim; i++) { out&lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setw(<span class="hljs-number"><span class="hljs-number">6</span></span>)&lt;&lt;v[i]&lt;&lt;<span class="hljs-string"><span class="hljs-string">" "</span></span>; } out&lt;&lt;<span class="hljs-string"><span class="hljs-string">"} "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out; }</code> </pre><br><h4>  3 Conclusion </h4><br>  In the subsequent clarifying articles of section 3.1 ... we will show the details of the implementation of working with matrices.  There will even be recursion on the templates.  See you soon article! <br>  And yes, I remind you that soon <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> will <a href="https://habrahabr.ru/users/haqreu/" class="user_link">post</a> an article about shaders! </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/248909/">https://habr.com/ru/post/248909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248897/index.html">C ++ 11 variadic templates and long arithmetic at compile time</a></li>
<li><a href="../248899/index.html">We write extensions with Roslyn by 2015 studios (part 1)</a></li>
<li><a href="../248901/index.html">Annotation to "Effective Modern C ++" by Scott Myers. Part 2</a></li>
<li><a href="../248903/index.html">Launch Linux in Microsoft Azure</a></li>
<li><a href="../248907/index.html">Software routing with VyOS</a></li>
<li><a href="../248911/index.html">CSS Report 2014: Testing the use of CSS in the ‚Äúfield‚Äù</a></li>
<li><a href="../248913/index.html">We write extensions with Roslyn by 2015 studios (part 2)</a></li>
<li><a href="../248917/index.html">CSRF in my home router and how I closed it</a></li>
<li><a href="../248919/index.html">Keyboard layout indicator with taskbar color and window title in modern versions of Windows using DWM</a></li>
<li><a href="../248933/index.html">Linux DDoS Trojan is hidden behind a built-in rootkit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>