<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Map-Reduce on the example of MongoDB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, a family of data processing approaches and methodologies, united under the common names Big Data and NoSQL, is gaining popularity. One of th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Map-Reduce on the example of MongoDB</h1><div class="post__text post__text-html js-mediator-article">  Recently, a family of data processing approaches and methodologies, united under the common names Big Data and NoSQL, is gaining popularity.  One of the computational models applied to large amounts of data is Map-Reduce technology, developed in the depths of Google.  In this post I will try to talk about how this model is implemented in a non-relational MongoDB DBMS. <br><br>  As for the future of non-relational bases in general and the Map-Reduce technology in particular, one can argue on this subject ad infinitum, and the post is completely not about that.  In any case, familiarity with alternative traditional DBMS data processing methods is useful for the general development of any programmer, as well as, for example, familiarity with functional programming languages ‚Äã‚Äãcan be useful for programmers working exclusively with imperative languages. <br><br>  MongoDB non-relational DBMS presents data in the form of collections from documents in JSON format and provides various ways of processing this data.  Including, there is own implementation of the Map-Reduce model.  How practical it is to use this implementation for practical purposes will be discussed below, but for now we will confine ourselves to the fact that this implementation fits perfectly into familiarity with the Map-Reduce paradigm itself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, what's so special about Map-Reduce? <br><a name="habracut"></a><br>  Suppose we are developing a large online application whose data is stored in a distributed way on several servers in all corners of the globe.  In addition, the user has his interests listed.  We decided to calculate the popularity of each interest by simply determining the number of users sharing this interest.  If we used a relational DBMS and stored all users on a single server, then a simple query using the <i>group by</i> operation would help us to get an answer.  In the case of different nodes, we would like this grouping to be performed in parallel, loading all servers evenly.  In the world of relational DBMS and SQL queries it is quite difficult to imagine this, but with the help of Map-Reduce this task is completely solvable. <br><br>  Suppose there is a collection of <b>users</b> in our database whose elements are of the form: <br><br><pre><code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">name</span></span> : <span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span> : <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">interests</span></span> : [<span class="hljs-string"><span class="hljs-string">"football"</span></span>, <span class="hljs-string"><span class="hljs-string">"IT"</span></span>, <span class="hljs-string"><span class="hljs-string">"women"</span></span>] }</code> </pre> <br>  At the output, we want to get a collection of this type: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">"football"</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1349</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">"MongoDB"</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">58</span></span> }, <span class="hljs-comment"><span class="hljs-comment">//...</span></span></code> </pre><br>  During execution, the system performs Map and Reduce operations on the data, which are determined by the programmer.  In MongoDB, these operations have the form of functions written in Javascript.  That is, the programmer himself writes the functions, and Mongo manages their call. <br><br>  At the beginning, an operation <b>Map</b> is applied to each document of the collection, which forms pairs <i>&lt;key, value&gt;</i> .  These pairs are then passed to the <b>reduce</b> function in a key grouped form.  The <b>Reduce</b> operation forms one pair <i>&lt;key, value&gt;</i> .  Both as a key and as a value can be any variables, including objects. <br><br>  Consider the <b>map</b> function for our example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interests) { emit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interests[i], <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  As you can see, the document to which the <b>Map</b> operation is applied is available by the pointer <b>this</b> .  The <b>emit</b> function is used to transmit the next pair <i>&lt;key, value&gt;</i> for further processing.  As you can see, the <b>Map</b> operation for one document may produce several pairs <i>&lt;key, value&gt;</i> .  In this example, everything is simple - we transfer interest as the key, and unit as the value - since in this case the interest met exactly once. <br><br>  Formed pairs are grouped by key and passed to the <b>reduce</b> function as <i>&lt;key, list of values&gt;</i> .  The <b>reduce</b> function for our example looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> values) { sum += values[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br>  To get the total value, we summarize all the values ‚Äã‚Äãthat we have in the <b>values</b> array.  The change of the key by the <b>Reduce</b> operation is not provided, so the function simply returns the resulting value as its result. <br><br>  A clever reader may ask the following question - why run through the entire <b>values</b> array and add its elements if we know that they are equal to one?  Is not it easier to return the length of the array?  The answer to this question is negative, and an explanation sheds light on a key feature of Map-Reduce. <br><br>  The fact is that MongoDB runs a <b>Reduce</b> operation to perform intermediate aggregations.  Once several pairs have been formed with the same key, MongoDB can perform <b>Reduce</b> for them, thereby obtaining one pair of <i>&lt;key, value&gt;</i> , which is then processed along with the rest, as if it were obtained using the <b>Map</b> operation. <br><br>  This imposes certain requirements on the implementation of the <b>reduce</b> function.  Here they are: <br><br><ol><li>  The type of the return value of the <b>reduce</b> function must match the type of the value that is issued by the <b>map</b> function (the second parameter of the <b>emit</b> function) </li><li>  The following equality must be fulfilled: <b>reduce (key, [A, reduce (key, [B, C])]) == reduce (key, [A, B, C])</b> </li><li>  Repeated application of the <b>Reduce</b> operation to the resulting pair <i>&lt;key, value&gt;</i> should not affect the result (idempotency) </li><li>  The order of the values ‚Äã‚Äãpassed to the <b>reduce</b> function should not affect the result. </li></ol><br>  The second requirement is also an illustration of what might happen.  If the <i>&lt;key, B&gt;</i> and <i>&lt;key, C&gt;</i> pairs were received on one node, and <i>&lt;key, A&gt;</i> on the other, the preliminary execution of the <b>Reduce</b> operation on the first node will reduce network traffic and increase concurrency.  But the price for this is a significant restriction on the function of <b>reduce</b> , due to the need to maintain the above identity. <br><br>  After all the <b>Map</b> and <b>Reduce</b> operations are completed, a collection of elements of the form is formed at the output <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">key</span></span>:<span class="hljs-string"><span class="hljs-string">"football"</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1349</span></span> },</code> </pre><br>  To run such an operation, you need to declare these two functions in the mongo shell console, and then execute the command: <br><br><pre> <code class="javascript hljs">db.users.mapReduce(map, reduce,{<span class="hljs-attr"><span class="hljs-attr">out</span></span>:<span class="hljs-string"><span class="hljs-string">"interests"</span></span>})</code> </pre><br>  Consider another task.  Suppose we want to know the average number of interests of people of different ages.  The <b>map</b> function in this case can be: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ emit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age, {<span class="hljs-attr"><span class="hljs-attr">interests_count</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interests.length, <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}); }</code> </pre><br>  The key here is age, and the object is transferred as a value - the number of interests and the number of people of a given age, which divide these interests (for one document is one). <br><br>  If you look closely at the requirements for the <b>reduce</b> function, it becomes clear that within its framework the arithmetic average cannot be calculated, since this mathematical operation does not satisfy the second requirement.  Therefore, all that we can do in the framework of the <b>reduce</b> function is to add the number of interests and the number of users separately: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> values){ count += values[i].count; sum += values[i].interests_count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">interests_count</span></span>: sum, <span class="hljs-attr"><span class="hljs-attr">count</span></span>: count}; }</code> </pre><br>  In order to get the arithmetic average in the final collection, you can use the <b>Finalize</b> operation - it is applied to the final <i>&lt;key, value&gt;</i> pair obtained after performing all <b>Reduce</b> operations with the key <b>key</b> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, reducedValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reducedValue.interests_count / reducedValue.count; }</code> </pre><br>  Command to call: <br><br><pre> <code class="javascript hljs"> db.users.mapReduce(map, reduce, {<span class="hljs-attr"><span class="hljs-attr">finalize</span></span>: finalize, <span class="hljs-attr"><span class="hljs-attr">out</span></span>:<span class="hljs-string"><span class="hljs-string">"interests_by_age"</span></span>})</code> </pre><br>  It should be noted that in other implementations of Map-Reduce, including Apache Hadoop, there are no such restrictions on the operation of <b>Reduce</b> .  There, the input of the <b>reduce</b> function will always be a complete list of values ‚Äã‚Äãrelated to the key.  And intermediate aggregation can be accomplished through another operation, <b>Combine</b> , semantically similar to <b>Reduce</b> . <br><br>  Now a few words about the feasibility of the practical application of the native implementation of MapReduce in Mongo.  To perform aggregations in this DBMS, there is a powerful tool called Aggregation Framework, which performs the same aggregations approximately 5-10 times faster than Map-Reduce.  But concurrency in this case ends where sorting and grouping begin.  There are also certain limitations on the RAM consumed by the operation. <br><br>  In general, the Aggregation Framework should be used where fast response is required, while Map-Reduce is intended for preprocessing raw information.  Mongo provides opportunities to interact with Hadoop, whose Map-Reduce implementation works more efficiently than the native one.  Anyway, MongoDB allows you to familiarize yourself with the Map-Reduce model without the need to install and configure such a relatively heavyweight tool like Apache Hadoop. </div><p>Source: <a href="https://habr.com/ru/post/184130/">https://habr.com/ru/post/184130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184116/index.html">Connecting fonts in your project</a></li>
<li><a href="../184118/index.html"># MBLT13: Mobile Trends from Japan</a></li>
<li><a href="../184120/index.html">Disputes about domain abbreviations</a></li>
<li><a href="../184124/index.html">Troj / JSRedir-LK Trojan and WordPress Vulnerability</a></li>
<li><a href="../184126/index.html">Is there life in the world of PostPC? Copy music from iTunes Store without a stationary computer</a></li>
<li><a href="../184132/index.html">Mobile Backhaul for a small mobile operator</a></li>
<li><a href="../184138/index.html">Yandex.Algorithm 2013: new Yandex.Contest platform and TCM / Time rules</a></li>
<li><a href="../184142/index.html">PHP 5.5.0 Final Release Released</a></li>
<li><a href="../184144/index.html">Sickly Dill and Man-Made Sun</a></li>
<li><a href="../184146/index.html">Interview with Monty Taylor, OpenStack Continuous Integration Project Manager</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>