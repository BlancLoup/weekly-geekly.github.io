<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to prepare TCP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When someone or something becomes bad, something more is needed than just a statement of this fact. 

 The first is to diagnose the problem, determine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to prepare TCP</h1><div class="post__text post__text-html js-mediator-article"><img width="300" src="https://habrastorage.org/files/5b6/eda/336/5b6eda33666c425ba1729903945ac0c8.jpg"><br><br>  When someone or something becomes bad, something more is needed than just a statement of this fact. <br><a name="habracut"></a><br>  The first is to diagnose the problem, determine the cause of the failure. <br>  Take and measure pressure, make palpation, check engine oil level, and so on and so forth. <br><br>  What if problems arose when transferring data to the Internet / Intranet network? <br>  Here, apparently, will require special diagnostic tools. <br>  In particular, tools that allow statistical analysis of a large amount of data will be useful. <br>  There are many different tools. <br>  Some of them can be found in such a wonderful program like Wireshark. <br>  The Statistics menu of Wireshark provides a rich set of functionality. <br>  At the same time, the results can be presented not only in general, but also in graphical form. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Just about the graphic form and I want to talk. <br>  Tell about a set of five graphs of TCP StreamGraph statistics. <br>  Allow you to easily and efficiently analyze and diagnose TCP connections. <br><br>  But before we start talking about graphs, for a better understanding of them, let‚Äôs look at the basics of TCP theory. <br><br><h2>  The minimum required for a general understanding of TCP StreamGraph </h2><br><br><ul><li>  TCP ( <a href="https://ru.wikipedia.org/wiki/TCP">Transmission Control Protocol</a> ) is a transport layer protocol that is responsible for guaranteed delivery of data from one node to another.  Over TCP, application layer protocols such as <a href="https://ru.wikipedia.org/wiki/HTTP">HTTP</a> , <a href="https://ru.wikipedia.org/wiki/FTP">FTP</a> , <a href="https://ru.wikipedia.org/wiki/SMTP">SMTP</a> , <a href="https://ru.wikipedia.org/wiki/Telnet">TELNET</a> and others work. <br></li><li>  Guaranteed delivery in TCP is achieved through the use of mechanisms for confirmation and repetition. <br>  After sending a piece of data, the sender waits for confirmation from the recipient of the delivery.  If no confirmation is received, a resubmission is performed. <br></li><li>  The data to be sent at the TCP level is represented by a stream of bytes, where each byte is sequentially numbered.  TCP divides the stream into parts ‚Äî <a href="https://ru.wikipedia.org/wiki/TCP">segments</a> ‚Äî and forwards them to a lower (network) layer for sending to the receiver.  The segment header indicates its number ( <a href="http://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/">Sequence number</a> , Seq) - the number of the first byte of the segment in the general stream. <br></li><li>  The recipient receives the segments and collects from them the original continuous stream of bytes, sends a confirmation. <br>  In the header indicates the confirmation number ( <a href="http://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/">Acknowledgment number</a> , Ack) - the sequence number of the next segment, expected from the sender.  The Ack value means that the entire continuous sequence of bytes from the first to Ack-1 is received successfully.  According to the specification, confirmation for each segment is not required.  One confirmation can be sent immediately to several received segments. <br></li><li>  The recipient not only confirms the incoming data, but also controls the intensity of their receipt. <br>  The confirmation header indicates the size of the receive window ( <a href="http://packetlife.net/blog/2010/aug/4/tcp-windows-and-window-scaling/">Window</a> , Win). <br>  The sender transmits segments with data that does not exceed the size of Win. <br>  If the recipient reports zero Win, data transfer is suspended until a larger size is indicated. <br></li><li>  The transfer of data between two network applications is preceded by the establishment of a TCP connection. <br>  When the exchange is completed, the connection is closed. <br>  A connection is uniquely identified by a pair of host IP address values ‚Äã‚Äãand the port number of the application. <br>  The application initiating the connection (client) receives an arbitrary port number in the OS each time and releases it after the end of the data transfer session. <br>  An application waiting for connections (server) always uses a fixed port number until it completes its work. <br></li></ul><br><br>  Below is a picture of a special case of TCP data exchange. <br>  Should be considered as a simplified version. <br><br><blockquote>  In the example, the numbering of the segments starts from one. <br>  Although in reality it is not so. <br>  However, the same shows Wireshark with <a href="https://wiki.wireshark.org/TCP_Relative_Sequence_Numbers">default</a> settings. <br></blockquote><br>  The sender sends two segments (Seq = 1 and Seq = 6), each containing five bytes of data. <br>  The receiver responds that all bytes to 10 are received successfully and the next 11th segment is expected (Ack = 11). <br>  The sender transmits two more (Seq = 11 and Seq = 16), one of which is lost in the network (Seq = 11). <br>  The recipient states that a gap has appeared in the stream of received data. <br>  Reports that only 10 bytes have been continuously received since the first byte and it is still waiting for the 11th segment (Ack = 11). <br>  However, at the same time in the confirming segment indicates the SACK ( <a href="http://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack">Selective</a> Acknowledgment, selective acknowledgment) block, with a range of bytes received after the break.  Thanks to SACK, the sender will re-transmit only the missing segment (Seq = 11).  Without SACK, you would need to repeat Seq = 16 too.  The use of SACK must be supported by both parties to the exchange. <br><br><img src="https://habrastorage.org/files/0b0/68d/27e/0b068d27eb264894a3772206dd4ec997.png"><br><br>  Now consider the process of transferring data in a TCP connection via TCP StreamGraph to Wireshark. <br><br>  However, in order not to describe graphics just like that, I will do it with a simple and clear example. <br>  Download the file from the test server to your computer using the HTTP protocol. <br>  To do this, use the curl utility, and not a web browser. <br>  curl will help create some problems that we will see on the charts. <br>  Problems will arise due to the fact that the download will be conducted directly to the console, and not to the file. <br><br>  So, I launch Wireshark, turn on traffic capturing. <br>  I load with the curl utility a 10Mb test file from the <a href="http://v4.speedtest.reliableservers.com/">v4.speedtest.reliableservers.com</a> server (10MBtest.bin). <br><br>  <b>curl 'http://v4.speedtest.reliableservers.com/10MBtest.bin'</b> <br><br><img width="300" src="https://habrastorage.org/files/ac8/4f1/7a4/ac84f17a44db47f38f20dc8a6439b1e8.png"><br><br>  I stop capturing traffic. <br>  In the received Wireshark network dump, I look for an HTTP packet with a GET request for the 10MBtest.bin file and determine the number of the TCP connection in which it was loaded.  Or look for the filter <b>tcp contains "10MBtest.bin"</b> . <br><br><img src="https://habrastorage.org/files/78a/cb2/d94/78acb2d949a441dc8503f9628e866632.png"><br><br>  I filter all traffic by the TCP connection number in which the test file <b>tcp.stream == 5</b> was loaded. <br><br><img width="952" src="https://habrastorage.org/files/9cb/7ad/58f/9cb7ad58fdbb47d58e23b12cbf1eed01.png"><br><br>  And now we are looking at TCP StreamGraph. <br><br>  It is important to know that all the graphics from TCP StreamGraph are built on one TCP connection and are directed. <br>  The direction indicates in which direction the analyzed data stream moved from the client to the server or vice versa. <br><br>  The direction and connection is determined by the packet selected in the Wireshark interface. <br>  In the case of the above example, I choose any package from the connection in which the test file 10MBtest.bin was downloaded. <br>  The direction was from the server to the client, so the Source of the package must match the IP address of the server. <br>  All graphics are in the Wireshark Statistics -&gt; TCP StreamGraph menu. <br><br><h2>  Time-Sequence Graph (Stevens) </h2><br><img width="700" src="https://habrastorage.org/files/60e/c72/7e1/60ec727e1b464e2dae1258e78df16ac9.png"><br><br>  Time-Sequence Graph (Stevens) looks like a sloping curve consisting of points. <br>  The coordinates of each point of the graph are the value of the Sequence number of the TCP segment (Y-axis - Bytes) and its capture time (X-axis - seconds). <br><br>  Accordingly, as mentioned earlier, only segments with data from a single TCP connection moving in a certain direction from server to client (download, download) or vice versa (upload, upload) are taken into account. <br>  According to the theory of Sequence number, this is the number of the first byte of data of a segment in the general data stream. <br>  Therefore, we can say that the graph shows the dynamics of loading / unloading bytes of data in a TCP connection over time. <br><br>  At any site, the data transfer rate is easily calculated, (Sequence number divided by Time, we get Byte / sec). <br>  As a result, changes in the slope of the curve can be judged on changes in the data transfer rate. <br><br>  Under ideal conditions, the graph looks like a diagonal line with a large angle of inclination. <br>  However, in practice this is not always the case. <br>  By anomalies on the curve of the graph, you can identify delays in data transmission, the loss of segments and their re-sending (Retransmission). <br>  In the example of the graph below, during loading the file, two similar problems arose with stopping the transfer of data and loss of segments. <br><br><img src="https://habrastorage.org/files/be7/c3e/b31/be7c3eb3128e40b3b6e779f8ab603f37.png"><br><br><blockquote>  <b>Windows hotkeys (quick reference):</b> <br>  Step-by-step zooming in or out of the graph is performed via the i / o keys or by direct selection of the area with the mouse.  Return to the original scale, the Home key. <br>  Spacebar - turns the cursor into a crosshair with vertical and horizontal auxiliary lines. <br>  Number keys 1 to 5 - select a different graphic from the set. <br>  Ctrl + right mouse button - a window appears with an enlarged image of the plot of the graph from under the cursor. <br><br>  Clicking on any point of the graph leads to a transition in the Wireshark interface to the corresponding TCP packet. <br></blockquote><br><br><h2>  Time-Sequence Graph (tcptrace) </h2><br><br><img width="700" src="https://habrastorage.org/files/534/aff/eca/534affeca8b64900856ed4bc3c96e59c.png"><br><br>  In appearance, the Time-Sequence Graph (tcptrace) resembles the previous graph and is intended for a more complete analysis of possible problems.  It still displays the values ‚Äã‚Äãof the Sequence number of data flow segments on the timeline. <br>  However, another segment attribute has been added - its size (TCP Segment Len). <br>  Therefore, the segments are no longer shown by points, but by vertical sections with serifs at the ends, like the English letter I - "ah."  The base of the segment is the Sequence number, and the length is the size of the segment in bytes. <br><br>  The graph also displays information from the backflow confirming segments, Window (Win), Acknowledgment number (Ack) and SACK.  Ack values ‚Äã‚Äãare displayed by a stepped curve that runs below the data segments. <br>  Each stage, its vertex is the instant of arrival of confirmation of the total number of continuously received bytes by the receiver. <br><br>  Similarly, ‚Äústepwise‚Äù displays the size of the Win host window. <br>  The curve passes above the data stream. <br>  The top of the step is the sum of the Ack and Win values ‚Äã‚Äãof the confirming segment. <br><br><img src="https://habrastorage.org/files/163/036/c97/163036c975a34783ab968541bd148e73.png"><br><br>  Blue vertical lines are visualized by SACK blocks. <br>  SACK may be present in the acknowledgment if gaps have occurred in the continuous stream of received data. <br>  The blue line is the range of bytes received after the break. <br><br><img src="https://habrastorage.org/files/8ed/4a9/b0b/8ed4a9b0bd9a48c2a0d9deca48cb9b32.png"><br><br>  In general, the graph is a ‚Äúcorridor‚Äù of two step curves, within which segments with data are moved.  The narrowing of the ‚Äúcorridor‚Äù indicates a decrease in the size of the reception window (Win), the extension indicates the opposite. <br><br>  On the previous graph, two problems were found with stopping the transfer of data. <br>  Time-Sequence Graph (tcptrace) clarified the causes of the incident. <br>  The window size (Win) on the receiving side has decreased. <br>  The sender transmitted the maximum allowable number of data segments so as not to overwhelm the window, and stopped. <br>  After the recipient reported an increase in window size (Window Update), data transfer resumed. <br><br><img src="https://habrastorage.org/files/894/3ba/bb4/8943babb44964e37b97945c52548e2d4.png"><br><br><h2>  Throughput Graph </h2><br><br><img width="700" src="https://habrastorage.org/files/bdc/07e/e30/bdc07ee30e8d4ab0990a4f9b86c156ac.png"><br><br>  Throughput Graph looks like a set of points, sometimes located very chaotically. <br>  The coordinates of each point are the estimated speed of movement of the segment in the data stream (Y-axis - Byte / sec) and its capture time (X-second axis). <br><br>  To be precise, to smooth the oscillations on the graph, not real, but average speed values ‚Äã‚Äãare fixed. <br>  The averaging function of the moving average ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25BE%25D0%25BB%25D1%258C%25D0%25B7%25D1%258F%25D1%2589%25D0%25B0%25D1%258F_%25D1%2581%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BD%25D1%258F%25D1%258F">Moving Average</a> , MA) is used by 20 values ‚Äã‚Äãfor the previous period. <br>  According to the Wireshark code, the average speed of the N-th segment is equal to the sum of the lengths of all the segments from N to N-20 divided by the delta over the time between their capture. <br><br>  As a result, two delays in data transfer, caused by a decrease in the window size (Win), led to a drop in Throughput at problematic points in time.  The rest of the time, the download speed varied within the range from 1.4 to 3.4 MB. <br><br><img width="700" src="https://habrastorage.org/files/544/d45/bb3/544d45bb33ab4478acecb5b0204bee82.png"><br><br><h2>  Round Trip Time Graph </h2><br><br>  <a href="http://en.wikipedia.org/wiki/Round-trip_delay_time">Round Trip Time</a> (RTT) is the time elapsed between sending a segment with data and receiving confirmation of its successful delivery. <br><br><img width="500" src="https://habrastorage.org/files/927/431/8dd/9274318dde1e412083e4ac06308130cf.png"><br><br>  Round Trip Time Graph shows RTT (Y axis - seconds) for each segment of the data stream. <br>  The segment identifier is its Sequence number (X-axis - Bytes). <br><br><img width="700" src="https://habrastorage.org/files/d4f/c54/4ee/d4fc544ee14a45e2a2470ccbb835fde4.png"><br><br>  Under normal conditions, most of the points are concentrated at the bottom of the graph. <br><br>  In the RTT example, almost all the time does not exceed 0.1 seconds, except for the problematic moments when the RTT jumped to 0.4 seconds. <br><br>  All graphics are interconnected by the formula <b>Throughput = Window size / RTT</b> <br><br><img width="700" src="https://habrastorage.org/files/51c/2c3/41f/51c2c341f27c4131aafb9961ed0cebbf.png"><br><br><h2>  Window Scaling Graph </h2><br><br><img width="700" src="https://habrastorage.org/files/b65/9a6/d0c/b659a6d0c96e45dd8cea10d21175c46d.png"><br><br>  The coordinates of each Window Scaling Graph point is the size of the Windowsize window (Y axis - Bytes) of the segment at the time it was captured (X axis is seconds). <br><br>  In the current graph, the focus has been changed to reverse the flow of data (client -&gt; server).  It only analyzes confirmatory segments. <br><br>  In the Window Scaling Graph there is information about two problematic cases of reducing the size of the window to critical sizes. <br>  This fully confirms the indications on the Time-Sequence Graph. <br><br><img width="700" src="https://habrastorage.org/files/0ab/564/2d0/0ab5642d0d5f4bcf96b24933bbbeac1a.png"><br><br><h2>  Conclusion </h2><br>  Well, it seems that's all.  What I wanted - said. <br>  Information on the topic is much more.  The article outlined only the basics to help better understand the graphics from TCP StreamGraph, Wireshark. <br>  These graphs are very useful in their practical application and allow you to make a comprehensive overview of any TCP connection, identify network problems. <br><br>  Of course, there are other tools like TCP StreamGraph, for example, <a href="http://www.tcptrace.org/">tcptrace</a> , <a href="http://research.protocollabs.com/captcp/index.html">captcp</a> . <br>  Do not forget about <a href="https://www.wireshark.org/docs/wsug_html_chunked/ChStatIOGraphs.html">IO Graph of</a> the same Wireshark.  It has more extensive functionality extending far beyond TCP StreamGraph. <br><br>  I hope this article will be useful to all those who are interested in network technologies or studying the TCP protocol. </div><p>Source: <a href="https://habr.com/ru/post/252819/">https://habr.com/ru/post/252819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252803/index.html">Coub API Tutorial</a></li>
<li><a href="../252805/index.html">Hardware Shared DAS or why LSI Syncro is needed</a></li>
<li><a href="../252809/index.html">Restart daemon in PHP without losing connections to it</a></li>
<li><a href="../252813/index.html">Can you trust the code in the editor? bi-directional text</a></li>
<li><a href="../252817/index.html">Automation of financial statements</a></li>
<li><a href="../252821/index.html">Nginx and https. We get class A +</a></li>
<li><a href="../252823/index.html">Custom SQLite Android functions or its own LOWER_FNC ()</a></li>
<li><a href="../252829/index.html">Sound effects in Windows Phone 8 applications</a></li>
<li><a href="../252831/index.html">Track devices via passive WiFi listening</a></li>
<li><a href="../252833/index.html">Calculation of prescaler parameters for 8250-compatible USART</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>