<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reinforcement training never worked</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR: Training with reinforcements (RL) has always been difficult. Do not worry if the standard depth learning techniques do not work. 

 The articl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reinforcement training never worked</h1><div class="post__text post__text-html js-mediator-article">  <b>TL; DR:</b> Training with reinforcements (RL) has always been difficult.  Do not worry if the standard depth learning techniques do not work. <br><br>  The <a href="https://habrahabr.ru/post/349800/">article by Alex Irpan</a> well outlines many of the current problems of deep-seated RL.  But most of them are not new - they have always existed.  In fact, these are the fundamental problems underlying RL since its inception. <br><br>  In this article, I hope to bring you two thoughts: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Most of the flaws described by Alex come down to two main problems with RL. </li><li>  Neural networks help solve only a small part of the problems while simultaneously creating new ones. </li></ol><br><blockquote>  <b>Note</b> : the article in no way disproves Alex‚Äôs claims.  On the contrary, I support most of his conclusions and I believe that researchers should more clearly explain the existing limitations of RL. </blockquote><a name="habracut"></a><br><h1>  Two main problems of RL </h1><br>  At the highest level, reinforcement learning is the maximization of some form of long-term return from action in a given environment.  There are two fundamental difficulties in solving RL problems: exploration-vs-exploitation balance and long-term credit assignment. <br><br>  As noted on the first page of the first chapter <a href="http://incompleteideas.net/book/bookdraft2018jan1.pdf">of Sutton and Barto‚Äôs book on reinforcement learning</a> , these are unique learning problems with reinforcement. <br><br>  There are related varieties of basic RL problems that manifest themselves with their own scary monsters, such as partial observability, multi-agent environments, learning from people and with people, etc.  We will omit all this for now. <br><br><img src="https://habrastorage.org/webt/-p/a-/cs/-pa-cshiwdhvocwjzkn8btokb0w.gif"><br>  <i><font color="gray">The constant state of the researcher in the field of RL.</font></i>  <i><font color="gray">[Caption: "This is normal"]</font></i> <br><br>  On the other hand, learning with a teacher deals with the problem of generalization.  Generalization is the assignment of labels to invisible data, given that we already have a bunch of visible data with labels.  Some parts of the fundamental problems of RL can be solved by good generalization.  If you generalize the model well to invisible states, then such extensive intelligence will not be required.  This is where deep learning usually comes up. <br><br>  As we will see, reinforcement learning is another and fundamentally more difficult problem than learning with a teacher.  There is nothing strange in that an extremely successful teaching method with a teacher, such as in-depth training, does not fully solve all problems.  In fact, deep learning while improving generalization introduces its own demons here. <br><br>  What is <i>really</i> strange is the surprise of the current limitations of RL.  The inability of DQN to work in the long run or a million steps when learning in an environment is nothing new here, it is not some mysterious feature of depth learning with reinforcement.  All this is due to the very nature of the problem - and it has always been so. <br><br>  Let's take a closer look at these two fundamental problems, and then it will become clear: there is nothing surprising in the fact that reinforcement training is not working yet. <br><br><h1>  Intelligence vs exploitation </h1><br>  <b>Sampling inefficiency, reproducibility and exit from local optima</b> <br><br>  Every agent must learn to answer the question from the very beginning: whether to continue to follow this strategy, which gives good results, or to take some relatively non-optimal actions that can increase the gain in the future?  This question is so complicated because there is no one right answer to it - there is always a compromise here. <br><br><h3>  Good start </h3><br>  Bellman equations guarantee convergence to the optimal value of the function <br>  only if each state is checked infinitely many times, and every action infinitely many times tested on it.  So from the very beginning we need an infinite number of samples for training, and they are needed everywhere! <br><br>  You might ask: ‚ÄúWhy dwell so much on optimality?‚Äù <br><br>  Fair  In most cases, if a successful strategy is developed relatively quickly and does not spoil too many things, then this is enough.  Sometimes in practice we are happy that a good policy can be learned in a finite number of steps (20 million is much less than infinity).  But it is difficult to define these subjective concepts without numbers to maximize / minimize a certain parameter.  Even harder to guarantee something.  More on that later. <br><br>  So, we agree on the fact that we will be happy about the optimal solution (whatever that means).  The number of samples for obtaining the same approximation increases exponentially with the space of actions and states. <br><br><h3>  But hey, it gets worse </h3><br>  If you do not make any assumptions, the best way to explore would be random.  You can add heuristics, such as <a href="http://people.idsia.ch/~juergen/interest.html">curiosity</a> , and in some cases they work well, but so far we do not have a complete solution.  In the end, you have no reason to believe that an action in a certain state will bring more or less reward if you do not try it. <br><br>  Moreover, model-free model-free learning algorithms with reinforcement usually try to solve the problem in the most general form.  We have few assumptions about the form of distribution, the dynamics of medium transition or optimal strategies (for example, see <a href="https://arxiv.org/abs/1707.06347">this paper</a> ). <br><br>  And it makes sense.  A one-time large reward does not mean that you will receive it every time in this state as a result of the same actions.  Here, the only sensible behavior is not to trust too much any particular reward, and slowly raise an assessment of how good this action is in this state. <br><br>  So, you make small conservative updates of functions that try to bring expectations of arbitrarily complex probability distributions across an arbitrarily large number of states and actions. <br><br><h3>  But hey, it really gets worse. </h3><br>  Talk about continuous states and actions. <br><br>  The world of our size seems mostly continuous.  But for RL, this is a problem.  How to take an infinite number of states an infinite number of times and perform an infinite number of actions an infinite number of times?  If only to generalize some acquired knowledge into invisible states and actions.  Training with the teacher! <br><br>  Let me explain a little. <br><br>  A generalization in RL is an <i>approximation of a function</i> .  Approximation of the function reflects the idea that the state and actions can be transferred to a function that calculates their values ‚Äã‚Äã- and then there is no need to store the values ‚Äã‚Äãof each state and actions in a giant table.  You teach a function on data - and you actually study with a teacher.  Mission Complete. <br><br><h3>  Not so fast </h3><br>  Even this is not done elementary in RL. <br><br>  To begin with, let's not forget that neural networks have their own unreasonable inefficiency of sampling due to the slow pace of gradient descent. <br><br><h3>  But hey, the situation is actually even worse. </h3><br>  In RL, the data for network learning must arrive on the fly during interaction with the environment.  As exploration and data collection changes, the evaluation of the utility function Q changes. <br><br>  Unlike teaching with a teacher, ground truth labels are not fixed here!  Imagine that at the beginning of your ImageNet training you mark an image as a cat, but later you change your perception and see a dog, car, tractor, etc. in it.  The only way to get closer to the true assessment of the objective function is to continue exploration. <br><br>  In fact, even in the training kit, you will never get samples of a true objective function, which is the optimal value of a function or policy.  Nevertheless, you are still able to learn!  <i>That is the</i> reason for <a href="https://twitter.com/jacobandreas/status/924356906344267776">the popularity of</a> training with reinforcements. <br><br>  To date, we have two very unstable things that need to be changed slowly to prevent complete collapse.  Rapid reconnaissance can lead to sudden changes in the target landscape, which the network so painstakingly tries to meet.  Such a double blow from the intelligence and training of the network leads to the complexity of the sample compared to the usual tasks of training with a teacher. <br><br>  Unstable dynamics intelligence also explains why RL is more sensitive to hyperparameters and random initial values ‚Äã‚Äãthan training with a teacher.  There are no fixed data sets on which neural networks are trained.  Learning data directly depends on the output of the neural network, the exploration mechanism used and the randomness of the environment.  Thus, with the same algorithm on the same environment in different runs, you can get completely different sets for training, which will lead to a <a href="https://arxiv.org/abs/1709.06560">strong performance difference</a> .  Again, the main problem in controlled intelligence is to see similar state distributions ‚Äî and the most general algorithms make no assumptions about this. <br><br><h3>  But wait!  The situation becomes even ... </h3><br>  For spaces of continuous action, <i>on-policy</i> methods are most popular.  These methods can use only samples that comply with the already implemented rules (policy).  It also means that as soon as you update the current rules, all experience learned in the past will immediately become unusable.  Most of the algorithms that are mentioned in connection with strange yellow people and animals in the form of a bundle of tubes ( <a href="http://www.mujoco.org/">Mujoco</a> ) fall into the category of on-policy. <br><br><img src="https://habrastorage.org/webt/g3/te/dk/g3tedkofex9uzzrkl5ow0l-dtf4.gif"><br>  <i><font color="gray">Cheetah</font></i> <br><br><img src="https://habrastorage.org/webt/n_/go/mq/n_gomqvcz4uzoi-yuinej3pzwfk.gif"><br>  <i><font color="gray">Tube model</font></i> <br><br>  On the other hand, off-policy methods can learn the optimal rules by monitoring the implementation of any other rules.  Obviously, so much better, but we are still not good enough in this, unfortunately. <br><br><h3>  But wait! </h3><br>  No, actually already everything.  However, it will be worse after all, but in the next chapter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be2/5cd/36c/be25cd36c9af4278a6966108664cbc1d.jpg"><br>  <i><font color="gray">It starts to look simple.</font></i> <br><br>  Summing up, these questions arise because of the main problem of learning with reinforcement, and in a broader sense of all AI systems: because of intelligence. <br><br>  RainbowDQN requires training for 83 hours, because it has no prior knowledge of what a video game is, that enemies shoot bullets at you, that bullets are bad, that a bunch of pixels on the screen that move all the time together are bullets, that bullets exist in the same world as the objects, that the world is organized according to some principles, it is not just the maximum distribution of entropy.  All these priors (presets) help us humans to sharply limit intelligence to a small set of high-quality states.  DQN must learn all this by random intelligence.  The fact that after training he is able to beat the real masters and surpass the centuries-old wisdom of the game, as in the case of AlphaZero, still seems surprising. <br><br><h1>  Long term merit assignment </h1><br>  <b>Functions of remuneration, their design and assignment</b> <br><br>  Do you know how some people scratch lottery tickets with just a lucky coin, because once they did it - and won a lot of money?  RL agents essentially play the lottery at every turn - trying to figure out exactly what they did to hit the jackpot.  They maximize one indicator resulting from actions over multiple steps, mixed with a high degree of environmental randomness.  Finding out what specific actions actually brought a high reward is the task of assigning credit (credit assignment). <br><br>  You want to easily determine the reward.  Training with reinforcements promises that you tell the robot about the right actions - and over time he will learn the right behavior safely.  You yourself in reality do not need to know the correct behavior and do not need to provide supervision at every step. <br><br>  In fact, the problem arises for the reason that the scale of possible rewards for intelligent tasks is much wider than today's algorithms are capable of handling.  The robot works on a much tighter time scale.  He has to regulate the speed of each hinge every millisecond, and the person will reward him only when he makes a good sandwich.  There are many events between these awards, and if the gap between the important choice and the award is too large, then any modern algorithm will simply fail. <br><br>  There are two options.  One of them is to reduce the scale of rewards, i.e.  issue them more smoothly and often.  As usual, if you show the optimization algorithm some weak spot, it will begin to constantly exploit it.  If the reward is not well thought out, then this can result in a <a href="https://blog.openai.com/faulty-reward-functions/">hack of reward</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e55/c4d/0ac/e55c4d0acea7d3bf8d102cb2c381be58.jpg"></div><br><br>  Ultimately, we fall into such a trap, because we forget: the agent optimizes the entire landscape of value, and not just the immediate reward.  Thus, even if the structure of immediate rewards seems harmless, the landscape picture may be unintuitive and contain many of these exploits, if not shown to be sufficiently accurate. <br><br>  This begs the question, why are rewards primarily used?  Remuneration is a way to set goals that allow you to use optimization opportunities to make good rules.  Formation of rewards is a way to introduce more specific knowledge in this area from above. <br><br>  Is there a better way to set goals?  In simulation training, you can slyly bypass the entire RL problem by requesting tags directly from the target distribution, i.e.  optimal policy.  There are <a href="https://dl.acm.org/citation.cfm%3Fid%3D1015430">other ways of teaching without direct reward</a> , it is possible <a href="https://arxiv.org/abs/1608.03824">to give agents remuneration in the form of images</a> (do not miss the IMCL workshop on target specification in RL!) <br><br>  Another promising way to cope with the long-term perspective (strongly delayed remuneration) is hierarchical learning with reinforcement.  I was surprised that Alex did not mention it in his article, because this is the most intuitively suitable solution to the problem (although I may be <a href="http://himanshusahni.github.io/2017/12/26/reusability-in-ai.html">biased</a> in this regard!) <br><br>  Hierarchical RL tries to decompose the long-term task into a number of goals and subtasks.  Expanding the problem, we effectively expand the time frame in which decisions are made.  Really interesting things happen when rules are learned in subtasks that are applicable to other goals. <br><br>  In general, the hierarchy can be as deep as you want.  The canonical example is a <a href="http://www-anw.cs.umass.edu/~barto/courses/cs687/Sutton-Precup-Singh-AIJ99.pdf">trip to another city</a> .  The first choice is the decision to go or not.  After this, it is necessary to determine how each stage of the journey will be completed.  Boarding the train to the airport, flight, taxi ride to the hotel seem reasonable stages.  For the railway phase, we single out subtasks: viewing the schedule, buying tickets, etc.  Calling a taxi involves a lot of movements to pick up the phone and activate the vibration of the vocal cords. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/2e3/e32/5192e3e3252210f384d3564982a2eb97.jpg"></div><br>  <i><font color="gray">Legal request in the RL study</font></i> <br><br>  Although a bit simplistic, this is a convincing example in the old-fashioned spirit of the 1990s.  A single scalar reward for getting to the desired city can be extended through the Markov chain to different levels of hierarchy. <br><br>  The hierarchy promises great benefits, but we are still far from them.  Most of the best systems consider hierarchies of only one level of depth, and transferring acquired knowledge to other tasks is difficult to achieve. <br><br><h1>  Conclusion </h1><br>  My conclusion is generally the same as that of Alex. <br><br>  I am very pleased that in this area such activity, and we finally took up the problems that I always wanted to solve.  Training with reinforcements has finally gone beyond the limits of a primitive simulator! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/a59/7f9/7e1a597f9c429bcb35801b7876b15fcd.jpg"></div><br>  <i><font color="gray">Do not panic!</font></i> <br><br>  I want to add only one thing: do not despair, if the standard methods of deep learning do not kill the monsters of training with reinforcements.  Reinforcement learning has two fundamental difficulties that are missing in teacher-training - intelligence and long-term merit-taking.  They have always been there, and solving them will require more than a really good function approximator.  Much better ways of exploring, using samples from past explorations, transferring experience between tasks, learning from other agents (including people), acting at different time scales and solving difficult problems with scalar rewards should be found. <br><br>  Despite the extremely difficult problems in RL, I still think that today it is the best framework for developing strong artificial intelligence.  Otherwise I would not do this.  When DQN played atari according to visual data, and AlphaGo defeated the world champion in go - at these moments we actually observed small steps on the way to a strong AI. <br><br>  I admire the future of learning with reinforcement and artificial intelligence. </div><p>Source: <a href="https://habr.com/ru/post/350328/">https://habr.com/ru/post/350328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350318/index.html">There is a job for chatbot: virtual assistant help desk</a></li>
<li><a href="../350320/index.html">Rocket straight in the AppStore</a></li>
<li><a href="../350322/index.html">Gentleman's set in the field of marketing and sales of the company-developer of custom software</a></li>
<li><a href="../350324/index.html">Unity 2018 and ProBuilder: create, edit and texture 3D models directly in the editor</a></li>
<li><a href="../350326/index.html">Cheat Sheet for Technical Interview</a></li>
<li><a href="../350332/index.html">Vue.js + Asp.Net Core MVC + TypeScript and more Bootstrap4</a></li>
<li><a href="../350334/index.html">One day at Alfa-Bank: mobile development</a></li>
<li><a href="../350336/index.html">System crafting in the Cursed Lands</a></li>
<li><a href="../350338/index.html">Setting up the proftpd + {mysql / postgresql} bundle with storing passwords in md5 + salt</a></li>
<li><a href="../350340/index.html">The history of one automation project, or how to implement a mixed accounting of fixed assets with a single tool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>