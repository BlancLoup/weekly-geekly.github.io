<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Predicting Random Numbers in Ethereum Smart Contracts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ethereum has gained immense popularity as a platform for the primary placement of coins (ICO). However, it is not only used for ERC20 tokens. Roulette...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Predicting Random Numbers in Ethereum Smart Contracts</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ce9/d9b/6ca/ce9d9b6ca2d53c87dc13d76d36fc4ecb.jpg"><br><br>  Ethereum has gained immense popularity as a platform for the primary placement of coins (ICO).  However, it is not only used for ERC20 tokens.  Roulettes, lotteries and card games - all this can be implemented on the Ethereum blockchain.  Like any implementation, the Ethereum blockchain defies fake; it is decentralized and transparent.  Ethereum allows the execution of turing-full programs, which are usually written in the programming language Solidity.  According to the founders of the platform, this turns the system into a ‚Äúglobal supercomputer.‚Äù  These characteristics are useful in gambling applications, where user trust is especially important. <br><br>  Ethereum blockchain is deterministic and therefore presents certain difficulties when writing a pseudo-random number generator (PRNG) - an integral part of any gambling application.  We decided to investigate smart contracts in order to assess the safety of the PRNG for Solidity and to highlight the characteristic design errors that lead to the appearance of vulnerabilities and the ability to predict the future state of PRNG. <br><a name="habracut"></a><br>  Our research was conducted in several stages: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  On etherscan.io and GitHub information on 3649 smart contracts is collected. </li><li>  Contracts were imported into the free Elasticsearch search engine. </li><li>  Using the Kibana web interface for functional search and filtering, 72 unique PRNG implementations were found. </li><li>  After a manual evaluation, 43 smart contracts are deemed vulnerable. </li></ol><br><h1>  Vulnerable applications </h1><br>  The analysis revealed four categories of vulnerable PRNG: <br><br><ul><li>  PRNG using block variables as a source of entropy. </li><li>  PRNG based on the hash of some previous block. </li><li>  PRNG based on the hash of the previous block in combination with the supposedly secret initial number (seed). </li><li>  PRNG affected front-running vulnerabilities. </li></ul><br>  Look at the examples of vulnerable code in each category. <br><br><h3>  PRNG using variable groups </h3><br>  Here are some block variables that are mistaken for the source of entropy: <br><br><ul><li> <code>block.coinbase</code> is the address of the miner who found the current block. </li><li>  <code>block.difficulty</code> is a relative indicator of the difficulty in mining the current block. </li><li>  <code>block.gaslimit</code> - maximum gas consumption for transactions in the block. </li><li>  <code>block.number</code> is the height of the current block. </li><li>  <code>block.timestamp</code> is the timestamp when a block is found. </li></ul><br>  First of all, miners can manipulate all block variables, so for this reason alone they cannot be used as a source of entropy.  More importantly, block variables are obviously identical within a block.  So if an intruder‚Äôs contract accesses the victim‚Äôs contract through an internal message, then the same PRNG in both contracts will produce the same result. <br><br>  Example 1 ( <a href="https://etherscan.io/address/0x80ddae5251047d6ceb29765f38fed1c0013004b7">0x80ddae5251047d6ceb29765f38fed1c0013004b7</a> ): <br><br><pre> <code class="hljs vhdl">// Won <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> even // (<span class="hljs-literal"><span class="hljs-literal">note</span></span>: this <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a terrible source <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> randomness, please don<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> real money) bool won = (<span class="hljs-keyword"><span class="hljs-keyword">block</span></span>.number % <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Example 2 ( <a href="https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172">0xa11e4ed59dc94e69612f3111942626ed513cb172</a> ): <br><br><pre> <code class="hljs pgsql">// Compute <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> *almost random* <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> selecting winner <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>. var random = uint(sha3(block.timestamp)) % <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Example 3 ( <a href="https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870">0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870</a> ): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">address</span></span> seed1 = contestants[uint(block.coinbase) % totalTickets].addr; <span class="hljs-attribute"><span class="hljs-attribute">address</span></span> seed2 = contestants[uint(msg.sender) % totalTickets].addr; <span class="hljs-attribute"><span class="hljs-attribute">uint</span></span> seed3 = block.difficulty; <span class="hljs-attribute"><span class="hljs-attribute">bytes32</span></span> randHash = keccak256(seed1, seed2, seed3); <span class="hljs-attribute"><span class="hljs-attribute">uint</span></span> winningNumber = uint(randHash) % totalTickets; <span class="hljs-attribute"><span class="hljs-attribute">address</span></span> winningAddress = contestants[winningNumber].addr;</code> </pre> <br><h3>  GPSN on block hash </h3><br>  Each block in the Ethereum chain has a verification hash.  Ethereum Virtual Machine (EVM) allows you to get these hashes using the <code>block.blockhash()</code> function.  The function receives as input a numeric argument indicating the block number.  In the course of this study, we found that the results of the execution of the <code>block.blockhash()</code> function are often incorrectly used in <code>block.blockhash()</code> implementations. <br><br>  There are three main varieties of such vulnerable PRNGs: <br><br><ul><li>  <code>block.blockhash(block.number)</code> , hash of the current block. </li><li>  <code>block.blockhash(block.number - 1)</code> , hash of the last block. </li><li>  <code>block.blockhash()</code> , a hash of a block that is at least 256 blocks away from the current one. </li></ul><br>  Let's look at each of these cases. <br><br>  <b>block.blockhash (block.number)</b> <br><br>  The state variable <code>block.number</code> allows <code>block.number</code> to find out the height of the current block.  When a miner takes a transaction that executes the contract code, the <code>block.number</code> variable of the future block with this transaction is known, so the contract can reliably get its value.  However, at the time a transaction is executed in EVM, the hash of the block being created is not yet known for obvious reasons, and EVM will always return zero. <br><br>  Some contracts incorrectly interpret the expression <code>block.blockhash(block.number)</code> .  In these contracts, the hash of the current block is considered known at run time and is used as a source of entropy. <br><br>  Example 1 ( <a href="https://etherscan.io/address/0xa65d59708838581520511d98fb8b5d1f76a96cad">0xa65d59708838581520511d98fb8b5d1f76a96cad</a> ): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deal(address player, uint8 cardNumber) <span class="hljs-type"><span class="hljs-type">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> (uint8) { uint b = block.number; uint <span class="hljs-type"><span class="hljs-type">timestamp</span></span> = block.timestamp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint8(uint256(keccak256(block.blockhash(b), player, cardNumber, <span class="hljs-type"><span class="hljs-type">timestamp</span></span>)) % <span class="hljs-number"><span class="hljs-number">52</span></span>); }</code> </pre> <br>  Example 2 ( <a href="https://github.com/axiomzen/eth-random/issues/3">https://github.com/axiomzen/eth-random/issues/3</a> ): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> random(uint64 upper) <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> (uint64 randomNumber) { _seed = uint64(sha3(sha3(block.blockhash(block.number), _seed), now)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _seed % upper; }</code> </pre> <br>  <b>block.blockhash (block.number-1)</b> <br><br>  In some contracts, another version of the CREF is used based on the block hash: the hash of the previous block rather than the current one is taken there.  Needless to say, such an approach is also unacceptable: an attacker can create an exploit contract with the same PRNG code in order to trigger a target contract through an internal message.  Both contracts will have the same "random" numbers. <br><br>  Example 1 ( <a href="https://etherscan.io/address/0xF767fCA8e65d03fE16D4e38810f5E5376c3372A8">0xF767fCA8e65d03fE16D4e38810f5E5376c3372A8</a> ): <br><br><pre> <code class="hljs lua">//Generate <span class="hljs-built_in"><span class="hljs-built_in">random</span></span> number between <span class="hljs-number"><span class="hljs-number">0</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> uint256 constant private FACTOR = <span class="hljs-number"><span class="hljs-number">1157920892373161954235709850086879078532699846656405640394575840079131296399</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint max)</span></span></span></span> constant private returns (uint256 result){ uint256 factor = FACTOR * <span class="hljs-number"><span class="hljs-number">100</span></span> / <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>; uint256 lastBlockNumber = block.number - <span class="hljs-number"><span class="hljs-number">1</span></span>; uint256 hashVal = uint256(block.blockhash(lastBlockNumber)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint256((uint256(hashVal) / factor)) % <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>; }</code> </pre> <br>  <b>Future block hash</b> <br><br>  A better idea is to use the hash of some future block.  You can implement this script as follows: <br><br><ul><li>  The player bets, and the office stores a <code>block.number</code> transaction. </li><li>  When the contract is recalled, the player asks the office to announce the winning number. </li><li>  The office retrieves the stored <code>block.number</code> from the storage and receives its hash, which is then used to generate a pseudo-random number. </li></ul><br>  This approach only works if one important requirement is met.  Solidity documentation warns about the limit of block hashes that EVM can store: <br><br><blockquote>  <i>For reasons of scalability, hashes are not available for all blocks.</i>  <i>You can access hashes of only the last 256 blocks, and all other values ‚Äã‚Äãwill be zero.</i> </blockquote><br>  Therefore, if there is no second call within 256 blocks with a hash check, then a pseudo-random number can be predicted in advance ‚Äî the hash will be zero. <br><br>  The most famous case of exploitation of this vulnerability is <a href="https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked/">hacking the SmartBillions lottery</a> .  The contract did not check the age of the <code>block.number</code> , due to which 400 ETH went to an unknown player who waited 256 blocks before disclosing a predictable winning number. <br><br>  <b>Secret hash block hash</b> <br><br>  To increase entropy, some contracts use an additional seed number (seed), which is considered secret.  One of the examples is the lottery Slotthereum.  Here is the corresponding code: <br><br><pre> <code class="hljs matlab">bytes32 _a = block.blockhash(block.number - pointer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((uint8(_a[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &gt;= <span class="hljs-number"><span class="hljs-number">48</span></span>) &amp;&amp; (uint8(_a[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt;= <span class="hljs-number"><span class="hljs-number">57</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint8(_a[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) - <span class="hljs-number"><span class="hljs-number">48</span></span>; } }</code> </pre> <br>  The variable pointer is declared secret, that is, other contracts cannot access it.  After each game, this variable is assigned a winning number from 1 to 9, and then it is used to offset the <code>block.number</code> when receiving a block hash. <br><br>  The blockchain, which is transparent by nature, should not be used to store secrets in clear text.  Although secret variables are protected from other contracts, you can get the contents of the off-line contract repository.  For example, in the popular Ethereum client web3, there is an API method <code>web3.eth.getStorageAt()</code> that allows you to get storage records at specified indices. <br><br>  Given this fact, it becomes a trivial task to extract the value of a secret variable from the contract repository and use it as an argument in the exploit code: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address a, uint8 n)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Slotthereum</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Slotthereum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pointer</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint8</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">win</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(getBlockHash(pointer)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">placeBet</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg.value)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(win, win)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><h3>  Transaction Ahead </h3><br>  To get the maximum reward, miners choose transactions to create a new block based on the cumulative gas (fuel) that each transaction spends.  The order of transactions in the block is determined by the price of gas.  The first will be the transaction with the maximum price of gas.  So, by changing the price of gas, it is possible to achieve that the necessary transaction is executed before all the others in the current block.  This can be a security problem - commonly called front-running, when the execution of a contract depends on its position in the block. <br><br>  Consider the following example.  The lottery uses an external oracle to obtain pseudo-random numbers, which are used to select the winner among the players who have bet in the current round.  These numbers are sent in clear text.  An attacker could watch a pool of pending transactions and wait for a number from an oracle.  As soon as the transaction from the oracle appears in the transaction pool, the attacker makes a bet with a higher price of gas.  The attacker's attack came last in the current round, but thanks to the highest price of gas, it will actually be executed before the oracle transaction, which will bring the player victory.  Such a task was performed by the participants of the <a href="https://blog.positive.com/zeronights-ico-hacking-contest-writeup-63afb996f1e3">hacker contest ZeroNights ICO</a> . <br><br>  Another example of a contract that is subject to early transaction vulnerability is a game called <a href="https://etherscan.io/address/0x5d9b8fa00c16bcafae47deed872e919c8f6535bf">Last is me!</a>  Every time a player buys a ticket, he takes the last place and the countdown of the timer begins.  If no one buys a ticket for a certain number of blocks, then the last ‚Äúranked‚Äù player wins the jackpot.  When the round is nearing completion, the attacker can observe the pool of transactions of other participants and assign the jackpot, setting a higher price for gas. <br><br><h1>  Safer PRNG </h1><br>  There are several approaches for implementing safer PRNG in the Ethereum blockchain: <br><br><ul><li>  External oracles </li><li>  Signidice </li><li>  The commit-disclosure scheme </li></ul><br><h3>  External oracles: Oraclize </h3><br>  <a href="http://www.oraclize.it/">Oraclize</a> is a service for distributed applications that establish a bridge between the blockchain and the external environment (the Internet).  When using Oraclize, smart contracts can request data from the API on the web, such as currency rates, weather forecasts, stock quotes.  One of the most famous use cases is the ability of Oraclize to work as PRNG.  Some of the contracts that were analyzed during our work used Oraclize to get random numbers from random.org through the URL connector.  This diagram is shown in Fig.  one. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/534/15c/bb0/53415cbb048e427f7db4fb932d8bbee0.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">1. Oraclize work pattern</font></i> <br><br>  The main disadvantage of this approach is centralization.  Can we believe that the Oraclize daemon does not interfere with the results?  Can we trust random.org and the entire infrastructure underlying this service?  Although Oraclize verifies the results through the TLSNotary auditing service, it can only be used outside the chain of blocks - in the case of lotteries, only after the winner is announced.  It is better to use Oraclize as a source of ‚Äúrandom‚Äù data using <a href="https://blog.oraclize.it/welcoming-our-brand-new-ledger-proof-649b9f098ccc">Ledger evidence</a> , which can be tested in a chain. <br><br><h3>  External oracles: BTCRelay </h3><br>  <a href="http://btcrelay.org/">BTCRelay</a> is a bridge between the chains of Ethereum and Bitcoin blocks.  When using BTCRelay, smart contracts in the Ethereum blockchain can request hashes of future Bitcoin blocks and use them as a source of entropy.  One of the projects that use BTCRelay as the PRNG is the <a href="https://etherscan.io/address/0x302fE87B56330BE266599FAB2A54747299B5aC5B">Ethereum Lottery</a> lottery. <br><br>  The BTCRelay method is not protected from the problem of stimulating miners.  Although here the barrier is higher than in the case of Ethereum blocks, but only because of the higher price of Bitcoin.  So this approach reduces, but does not eliminate, the likelihood of fraud by the miners. <br><br><h3>  Signidice </h3><br>  <a href="">Signidice</a> is an algorithm based on cryptographic signatures.  It can be used as a PRNG in smart contracts involving two parties: the player and the office.  The algorithm works as follows: <br><br><ul><li>  The player bets by calling a smart contract. </li><li>  The office sees the bid, signs it with its secret key and sends the signature to the smart contract. </li><li>  The smart contract verifies the signature using a known public key. </li><li>  This signature is then used to generate a random number. </li></ul><br>  Ethereum has a built-in <code>ecrecover()</code> function to check ECDSA signatures in a chain.  However, ECDSA cannot be used in Signidice, since an office can manipulate input parameters (in particular, parameter <i>k</i> ) and so affect the resulting signature.  Alexey Pertsev showed a <a href="https://github.com/pertsev/web3_utilz/tree/master/ECDSA%2520signature%2520generating%2520%2528cheating%2529">demo of</a> such fraud. <br><br>  Fortunately, with the release of the hard fork of Metropolis, <a href="https://github.com/ethereum/EIPs/pull/198">a modular exponentiation operator</a> appeared.  This allows for the implementation of RSA signature verification.  Unlike ECDSA, it does not allow the manipulation of the input parameters to find a suitable signature. <br><br><h3>  The commit-disclosure scheme </h3><br>  As the name implies, the commit-reveal scheme (commit ‚Äì reveal) consists of two stages: <br><br><ul><li>  The commit stage is when the parties send their cryptographically protected secrets to the smart contract. </li><li>  The disclosure stage, when the parties declare the initial numbers in clear text, the smart contract verifies that they are correct, and they are used to generate a random number. </li></ul><br>  A properly implemented commit-disclosure scheme should not rely on a single side.  Although players do not know the original starting number submitted by the owner, and their chances are equal, the owner can also be a player, so players cannot trust him. <br><br>  The commit-disclosure scheme is more correctly implemented in the <a href="https://github.com/randao/randao">Randao</a> service.  The PRNG collects hashes of initial numbers from several parties, and each of them receives a reward for participation.  No one knows someone else's initial numbers, so the result is absolutely random.  However, if at least one party refuses to announce its initial number, the service fails. <br><br>  The commit-disclosure scheme can be combined with the use of future block hashes.  In this case, three sources of entropy are involved: <br><br><ul><li>  owner's sha3 (seed1) </li><li>  sha3 player (seed2) </li><li>  future block hash </li></ul><br>  Then a random number is generated as follows: <code>sha3(seed1, seed2, blockhash)</code> .  Therefore, the ‚Äúcommit-disclosure‚Äù scheme solves the problem of stimulating miners: the miner may affect the block hash, but he does not know the initial numbers of the owner and the player.  It also solves the problem of stimulating the owner: he knows only his own initial number, but does not know the initial number of the player and the hash of the future block.  In addition, this scheme is suitable for situations where a person acts as both the owner and the miner: he determines the hash of the block, knows the initial number of the owner, but does not know the initial number of the player. <br><br><h1>  Conclusion </h1><br>  The secure implementation of PRNG in the Ethereum blockchain is still an unsolved task.  As our research has shown, due to the lack of ready-made solutions, developers tend to implement their own PRNG implementations.  But it‚Äôs easy to make a mistake, since there are few entropy sources in the block chain.  When developing the PRNG, the developer should make sure that he understands the motivation of each party - and then choose the appropriate approach. </div><p>Source: <a href="https://habr.com/ru/post/348838/">https://habr.com/ru/post/348838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348824/index.html">Google Chrome will start tagging all http pages as ‚Äúnot protected‚Äù with the release of Chrome 68 in July 2018</a></li>
<li><a href="../348828/index.html">Prototyping is easy how to assemble a puzzle. Multicomponent System Design in Figma</a></li>
<li><a href="../348830/index.html">Evolution of War: Total War II Series AI (Part 2)</a></li>
<li><a href="../348832/index.html">Service control panel. Part 3. Reconnaissance</a></li>
<li><a href="../348836/index.html">The digest of interesting materials for the mobile developer # 240 (February 5 ‚Äî February 11)</a></li>
<li><a href="../348840/index.html">CC1101 running a PIC controller or building a peer-to-peer network for a radio engineer (part 2, continued)</a></li>
<li><a href="../348842/index.html">Information architecture and technology DITA. Based on a lecture in Yandex</a></li>
<li><a href="../348844/index.html">Release 3CX v15.5 Update 3 with new features and important changes.</a></li>
<li><a href="../348846/index.html">Nutanix Flow - Virtual Network Microsegmentation</a></li>
<li><a href="../348848/index.html">Machine learning content manager</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>