<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A simple graphic editor using OpenCV</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will explain how to quickly and simply write an image editor in C ++ using the opencv computer vision library. Implemented effects s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A simple graphic editor using OpenCV</h1><div class="post__text post__text-html js-mediator-article">  In this article I will explain how to quickly and simply write an image editor in C ++ using the opencv computer vision library.  Implemented effects such as saturation, exposure, sharpness, contrast, and others.  No magic! <br><br><img src="https://habrastorage.org/files/6c4/b8c/05c/6c4b8c05ceb140f7a1cb06ee92291772.jpg" alt="image"><br><br>  Attention!  Under the cut a lot of graphics and code. <br><a name="habracut"></a><br>  So, let's begin‚Ä¶ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Saturation </h4><br>  Ingredients: <br>  - HSV color system, <br>  - the function of splitting into layers ¬´split¬ª, <br>  - merge layer merging function. <br><br>  To change the saturation, the image is converted to an HSV color system and split into layers.  A step is added to the ‚ÄúSature‚Äù layer values.  Layers are combined.  It's simple: <br><br><div class="spoiler">  <b class="spoiler_title">Saturation</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CImageEditor::Sature(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Mat&gt; hsv; cv::cvtColor(*m_imgEdit, *m_imgEdit, cv::ColorConversionCodes::COLOR_RGB2HSV_FULL); cv::split(*m_imgEdit, hsv); hsv[<span class="hljs-number"><span class="hljs-number">1</span></span>] += step * <span class="hljs-number"><span class="hljs-number">5</span></span>; cv::merge(hsv, *m_imgEdit); cv::cvtColor(*m_imgEdit, *m_imgEdit, cv::ColorConversionCodes::COLOR_HSV2RGB_FULL); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/files/7e7/738/bc2/7e7738bc263b43eca33b20f1567119cc.JPG" alt="Before"><img src="https://habrastorage.org/files/3ba/4af/fad/3ba4affadbee4159bc4095e45f11b13d.jpg" alt="After"><br><br><h4>  Exposition </h4><br>  Ingredients: <br>  - HSV color system, <br>  - the function ‚Äúsplit‚Äù, ‚Äúmerge‚Äù, and also the transformation function by the histogram ‚ÄúLUT‚Äù, <br>  - histogram transformed by the function x + sin (x * 0.01255) * step * 10, <br>  - protection against overflow byte values ‚Äã‚Äãof the histogram. <br>  As with saturation, the image is converted to HSV and split into layers.  For the ‚ÄúValue‚Äù layer, we perform the transformation using the histogram specified by the function i + sin (i * 0.01255) * step * 10. At the same time, we do not forget to protect ourselves from overflowing the byte number. <br><div class="spoiler">  <b class="spoiler_title">Exposition</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CImageEditor::Expo(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Mat&gt; hsv; cv::cvtColor(*m_imgEdit, *m_imgEdit, cv::ColorConversionCodes::COLOR_RGB2HSV_FULL); Mat lut = GetGammaExpo(step); cv::split(*m_imgEdit, hsv); cv::LUT(hsv[<span class="hljs-number"><span class="hljs-number">2</span></span>], lut, hsv[<span class="hljs-number"><span class="hljs-number">2</span></span>]); cv::merge(hsv, *m_imgEdit); cv::cvtColor(*m_imgEdit, *m_imgEdit, cv::ColorConversionCodes::COLOR_HSV2RGB_FULL); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { } } cv::Mat CImageEditor::GetGammaExpo(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-function"><span class="hljs-function">Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span><span class="hljs-function"><span class="hljs-params">, CV_8UC1)</span></span></span></span>; uchar* p = result.data; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; i++) { p[i] = AddDoubleToByte(i, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(i * <span class="hljs-number"><span class="hljs-number">0.01255</span></span>) * step * <span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } byte CImageEditor::AddDoubleToByte(byte bt, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d) { byte result = bt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>(result) + d &gt; <span class="hljs-number"><span class="hljs-number">255</span></span>) result = <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>(result) + d &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result += d; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><img src="https://habrastorage.org/files/7e7/738/bc2/7e7738bc263b43eca33b20f1567119cc.JPG" alt="Before"><img src="https://habrastorage.org/files/377/5ec/be6/3775ecbe6a0c40a9921caf9e7b8805b1.JPG" alt="After"><br>  Graph of the function x + sin (x * 0.01255) * step * 10 <br><img src="https://habrastorage.org/files/37d/e50/613/37de50613dc44027939a9066390bb53f.jpg" alt="image"><br>  The function mainly affects the middle of the range. <br><br><h4>  Tint </h4><br>  Ingredients: <br>  - RGB color system <br>  - function "split", "merge" and "LUT", <br>  - histograms transformed by the exposure function for the red, blue and green channels, <br>  - protection against histogram overflow. <br><br>  The hue parameter indicates the presence of green and purple in the image.  In the RGB color system, you can control the green layer, but you must not forget to compensate for the drop in brightness of the other two layers.  A positive gamma exposure function is used to transform the red and blue layers, negative for the green. <br><br><div class="spoiler">  <b class="spoiler_title">Tint</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CImageEditor::Hue(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Mat&gt; rgb; Mat lut0 = GetGammaExpo(step), lut1 = GetGammaExpo(-step), lut2 = GetGammaExpo(step); cv::split(*m_imgEdit, rgb); LUT(rgb[<span class="hljs-number"><span class="hljs-number">0</span></span>], lut0, rgb[<span class="hljs-number"><span class="hljs-number">0</span></span>]); LUT(rgb[<span class="hljs-number"><span class="hljs-number">1</span></span>], lut1, rgb[<span class="hljs-number"><span class="hljs-number">1</span></span>]); LUT(rgb[<span class="hljs-number"><span class="hljs-number">2</span></span>], lut2, rgb[<span class="hljs-number"><span class="hljs-number">2</span></span>]); cv::merge(rgb, *m_imgEdit); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { } }</code> </pre><br></div></div><br><img src="https://habrastorage.org/files/7e7/738/bc2/7e7738bc263b43eca33b20f1567119cc.JPG" alt="Before"><img src="https://habrastorage.org/files/dd2/030/f12/dd2030f12ad84ec39080a076b698b1ee.jpg" alt="After"><br><br><h4>  Colour temperature </h4><br>  Ingredients: the same as in shade, but histograms for red and green are positive, and for the blue layer, double negative. <br><br>  The color temperature indicates the presence in the image of yellow and blue colors.  So we will "turn" blue. <br><br><div class="spoiler">  <b class="spoiler_title">Colour temperature</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CImageEditor::Temperature(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Mat&gt; rgb; Mat lut0 = GetGammaExpo(-step*<span class="hljs-number"><span class="hljs-number">2</span></span>), lut1 = GetGammaExpo(step), lut2 = GetGammaExpo(step); cv::split(*m_imgEdit, rgb); LUT(rgb[<span class="hljs-number"><span class="hljs-number">0</span></span>], lut0, rgb[<span class="hljs-number"><span class="hljs-number">0</span></span>]); LUT(rgb[<span class="hljs-number"><span class="hljs-number">1</span></span>], lut1, rgb[<span class="hljs-number"><span class="hljs-number">1</span></span>]); LUT(rgb[<span class="hljs-number"><span class="hljs-number">2</span></span>], lut2, rgb[<span class="hljs-number"><span class="hljs-number">2</span></span>]); cv::merge(rgb, *m_imgEdit); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { } }</code> </pre><br></div></div><br><img src="https://habrastorage.org/files/7e7/738/bc2/7e7738bc263b43eca33b20f1567119cc.JPG" alt="Before"><img src="https://habrastorage.org/files/d91/5b9/4ea/d915b94ea0c945dfa8c9f096ce07469a.jpg" alt="After"><br><br><h4>  Light and shade </h4><br>  Ingredients: <br>  - HSV color system, <br>  - function "split", "merge", "LUT", <br>  - the histogram of shadows transformed by the function (0.36811145 * e) ^ (- (x ^ 1.7)) * 0.2x * step, <br>  - histogram of lights, transformed by the function (0.36811145 * e) ^ (- (256 - x) ^ 1.7) * 0.2 (256-x) * step, <br>  - protection against histogram overflow. <br><br>  The ‚Äúlight‚Äù parameter characterizes the brightness of the bright areas of the image, and the ‚Äúshadow‚Äù parameter defines the brightness of the dark areas.  We will convert the channel brightness. <br><br>  &lt;img src = " <img src="https://habrastorage.org/files/993/f4b/384/993f4b38469a4cc2b34de7b91a2198b8.jpg">  "alt =" image "/&gt; <br><br>  In the graph, the shadow conversion function is indicated by a red line, the light function by a green line. <br><br><div class="spoiler">  <b class="spoiler_title">Light and shade</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CImageEditor::White(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Mat&gt; hsv; cv::cvtColor(*m_imgEdit, *m_imgEdit, cv::ColorConversionCodes::COLOR_RGB2HSV_FULL); cv::split(*m_imgEdit, hsv); Mat lut = GetGammaLightShadow(step, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); LUT(hsv[<span class="hljs-number"><span class="hljs-number">2</span></span>], lut, hsv[<span class="hljs-number"><span class="hljs-number">2</span></span>]); cv::merge(hsv, *m_imgEdit); cv::cvtColor(*m_imgEdit, *m_imgEdit, cv::ColorConversionCodes::COLOR_HSV2RGB_FULL); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { AfxMessageBox(CString(CStringA(ex.msg.begin()))); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CImageEditor::Shadow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Mat&gt; hsv; cv::cvtColor(*m_imgEdit, *m_imgEdit, cv::ColorConversionCodes::COLOR_RGB2HSV_FULL); cv::split(*m_imgEdit, hsv); Mat lut = GetGammaLightShadow(step, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); LUT(hsv[<span class="hljs-number"><span class="hljs-number">2</span></span>], lut, hsv[<span class="hljs-number"><span class="hljs-number">2</span></span>]); cv::merge(hsv, *m_imgEdit); cv::cvtColor(*m_imgEdit, *m_imgEdit, cv::ColorConversionCodes::COLOR_HSV2RGB_FULL); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { AfxMessageBox(CString(CStringA(ex.msg.begin()))); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } Mat CImageEditor::GetGammaLightShadow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reverse) { <span class="hljs-function"><span class="hljs-function">Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span><span class="hljs-function"><span class="hljs-params">, CV_8UC1)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; i++) { *(result.data + i) = AddDoubleToByte(i, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">0.36811145</span></span>*M_E, -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>((reverse ? <span class="hljs-number"><span class="hljs-number">256</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) - i), <span class="hljs-number"><span class="hljs-number">1.7</span></span>))*<span class="hljs-number"><span class="hljs-number">0.2</span></span>*step*<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>((reverse ? <span class="hljs-number"><span class="hljs-number">256</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) - i)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><img src="https://habrastorage.org/files/73a/bb3/abd/73abb3abde7c4d31bc56decd2b941e9f.jpg" alt="Shine"><img src="https://habrastorage.org/files/af4/914/b2f/af4914b2f46e4ee6861515b90da64292.jpg" alt="Shadows"><br><br><h4>  Contrast </h4><br>  Ingredients: <br>  - RGB color system <br>  - function "split", "merge", "LUT", <br>  - contrast level "(100 + step) / 100", <br>  - contrast histogram obtained from the formula ((x / 255 - 0.5) * constrastLevel + 0.5) * 255. <br><br>  The contrast is determined by the difference in brightness.  Those.  to increase the contrast we need to push the range of brightness from the center to the edges.  Conversion is performed for all layers. <br><br><div class="spoiler">  <b class="spoiler_title">Contrast</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CImageEditor::Contrast(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Mat&gt; rgb; cv::split(*m_imgEdit, rgb); <span class="hljs-function"><span class="hljs-function">Mat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span><span class="hljs-function"><span class="hljs-params">, CV_8UC1)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> contrastLevel = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span> + step) / <span class="hljs-number"><span class="hljs-number">100</span></span>; uchar* p = lut.data; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; i++) { d = ((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>(i) / <span class="hljs-number"><span class="hljs-number">255</span></span> - <span class="hljs-number"><span class="hljs-number">0.5</span></span>)*contrastLevel + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d &gt; <span class="hljs-number"><span class="hljs-number">255</span></span>) d = <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) d = <span class="hljs-number"><span class="hljs-number">0</span></span>; p[i] = d; } LUT(rgb[<span class="hljs-number"><span class="hljs-number">0</span></span>], lut, rgb[<span class="hljs-number"><span class="hljs-number">0</span></span>]); LUT(rgb[<span class="hljs-number"><span class="hljs-number">1</span></span>], lut, rgb[<span class="hljs-number"><span class="hljs-number">1</span></span>]); LUT(rgb[<span class="hljs-number"><span class="hljs-number">2</span></span>], lut, rgb[<span class="hljs-number"><span class="hljs-number">2</span></span>]); cv::merge(rgb, *m_imgEdit); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { AfxMessageBox(CString(CStringA(ex.msg.begin()))); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre><br></div></div><br><img src="https://habrastorage.org/files/a39/396/63d/a3939663de504c849dcf687d3b82b14e.jpg" alt="image"><br><br>  Red line - increased contrast, green - reduced. <br><br><img src="https://habrastorage.org/files/7e7/738/bc2/7e7738bc263b43eca33b20f1567119cc.JPG" alt="Before"><img src="https://habrastorage.org/files/e89/f36/65f/e89f3665fa4b4252bfece58e3dc239ed.jpg" alt="After"><br><br><h4>  Sharpness </h4><br>  Ingredients: <br>  - blur function "blur", <br>  - convolution matrix, with calculated coefficients, <br>  - the transformation function by the convolution matrix ‚Äúfilter2D‚Äù, <br>  - a copy of the image. <br><br>  Sharpness (clarity) is determined by the selection of individual elements, their contours.  The inverse of the sharpness is blurring. <br>  In opencv, for blurring an image, we use the blur function, which takes as parameters the original image, the output image, and the size of the blur matrix.  The size of the blur matrix and the strength of the blur.  This size must be even so as not to manually specify the center of the matrix. <br><br>  The clarity in opencv is easiest to enhance with a convolution matrix, using a special matrix for this.  The ‚Äúfilter2D‚Äù function, which receives the original image, the resulting image, the number of bits per convolution matrix value, the convolution matrix, performs the conversion directly.  So, how the method of increase / decrease of clearness will look. <br><br><div class="spoiler">  <b class="spoiler_title">Sharpness</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CImageEditor::Clarity(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (step &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cv::blur(*m_imgEdit, *m_imgEdit, cv::Size(-step * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, -step * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Mat dst = m_imgEdit-&gt;clone(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> matr[<span class="hljs-number"><span class="hljs-number">9</span></span>] { <span class="hljs-number"><span class="hljs-number">-0.0375</span></span> - <span class="hljs-number"><span class="hljs-number">0.05</span></span>*step, <span class="hljs-number"><span class="hljs-number">-0.0375</span></span> - <span class="hljs-number"><span class="hljs-number">0.05</span></span>*step, <span class="hljs-number"><span class="hljs-number">-0.0375</span></span> - <span class="hljs-number"><span class="hljs-number">0.05</span></span>*step, <span class="hljs-number"><span class="hljs-number">-0.0375</span></span> - <span class="hljs-number"><span class="hljs-number">0.05</span></span>*step, <span class="hljs-number"><span class="hljs-number">1.3</span></span> + <span class="hljs-number"><span class="hljs-number">0.4</span></span>*step, <span class="hljs-number"><span class="hljs-number">-0.0375</span></span> - <span class="hljs-number"><span class="hljs-number">0.05</span></span>*step, <span class="hljs-number"><span class="hljs-number">-0.0375</span></span> - <span class="hljs-number"><span class="hljs-number">0.05</span></span>*step, <span class="hljs-number"><span class="hljs-number">-0.0375</span></span> - <span class="hljs-number"><span class="hljs-number">0.05</span></span>*step, <span class="hljs-number"><span class="hljs-number">-0.0375</span></span> - <span class="hljs-number"><span class="hljs-number">0.05</span></span>*step }; Mat kernel_matrix = Mat(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, CV_32FC1, &amp;matr); cv::filter2D(*m_imgEdit, dst, <span class="hljs-number"><span class="hljs-number">32</span></span>, kernel_matrix); m_imgEdit = make_shared&lt;Mat&gt;(dst); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { AfxMessageBox(CString(CStringA(ex.msg.begin()))); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre><br></div></div><br><img src="https://habrastorage.org/files/7e7/738/bc2/7e7738bc263b43eca33b20f1567119cc.JPG" alt="Before"><img src="https://habrastorage.org/files/7df/45f/d26/7df45fd262b9423fa0b7ecac1f0012d4.jpg" alt="After"><br><br><h4>  Total </h4><br>  Almost no magic.  Well, the magic numbers are found empirically, so you can use your own, the most appropriate ones instead. <br>  <a href="https://github.com/alex-v-93/Editor">Link to the demo application.</a> </div><p>Source: <a href="https://habr.com/ru/post/268115/">https://habr.com/ru/post/268115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268105/index.html">New Exchange Server 2016 has been released</a></li>
<li><a href="../268107/index.html">Fantasy on WebDAV</a></li>
<li><a href="../268109/index.html">jQuery plugin for organizing components on the page</a></li>
<li><a href="../268111/index.html">Selection of useful articles for iOS developers for the current week</a></li>
<li><a href="../268113/index.html">Secure crypto programming. Part 1</a></li>
<li><a href="../268117/index.html">IntelliJ IDEA 15 Preview available</a></li>
<li><a href="../268119/index.html">Creating loadable Zabbix modules on the example of adding the Modbus protocol</a></li>
<li><a href="../268123/index.html">Fantasy on WebDAV. Regular Client</a></li>
<li><a href="../268125/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 15. "UBuyWeRush"</a></li>
<li><a href="../268127/index.html">How does the radio interface work in GSM networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>