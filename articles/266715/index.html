<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Borrowing and time in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I present to you the translation of the article ‚ÄúRust Borrow and Lifetimes‚Äù from the blog of Arthur Liao, an engineer for Yahoo! 

 Rust is a new prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Borrowing and time in Rust</h1><div class="post__text post__text-html js-mediator-article">  <i>I present to you the translation of the <a href="http://arthurtw.github.io/2014/11/30/rust-borrow-lifetimes.html">article ‚ÄúRust Borrow and Lifetimes‚Äù</a> from the blog of Arthur Liao, an engineer for Yahoo!</i> <br><br>  Rust is a new programming language that has been <a href="http://blog.rust-lang.org/2014/09/15/Rust-1.0.html">actively developed since version 1.0</a> .  I can write another blog about Rust and why it is cool, but today I will focus on its borrowing system and time of existence, which confuses many newbies, including myself.  This post assumes that you have a basic understanding of Rust.  If not, you can first read the <a href="http://doc.rust-lang.org/guide.html">Guide</a> itself and the <a href="http://doc.rust-lang.org/guide-pointers.html">Guide to Pointers</a> . <br><a name="habracut"></a><br><h2>  Resource Ownership and Borrowing </h2><br>  In Rust, memory security is ensured without garbage collection through the use of a sophisticated borrowing system.  There is at least one owner for any resource that is engaged in the release of its resources.  You can create new bonds to refer to a resource using &amp; or mut, which are called borrowing (borrow) and mutable borrow.  The compiler monitors the proper behavior of all owners (owners) and borrowers (borrowers). <br><br><h4>  Copy and Move </h4><br>  Before we go to the borrowing system, we need to know how the copy and move methods are processed in Rust.  This <a href="http://stackoverflow.com/a/24253573">answer from StackOverflow</a> just needs to be read.  In general, in assignments and in a function, they are called: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. If the value is copied (with only primitive types, without the involvement of resources, such as processing memory or a file), the compiler copies by default. <br>  2. Otherwise, the compiler transfers (transfers) ownership and invalidates the original binding. <br><br>  In short, pod (readable old data) =&gt; copy, non-pod (linear types) =&gt; move. <br><br>  Here are some additional notes for reference: <br><br>  * The Rust copy method is similar to C.  Each use is byte-by-copy (shady memcpy copy) instead of semantic copying or cloning. <br>  * To make the pod structure uncopyable, you can use the NoCopy marker field or implement a Drop type. <br><br>  After moving, ownership is transferred to the next owner. <br><br><h4>  Resource release </h4><br>  In Rust, any object is released as soon as its ownership disappears, for example, when: <br><br>  1. The owner will be out of the area or <br>  2. Ownership of the binding changes (thus, the original binding becomes void) <br><br><h4>  Privileges and restrictions of the owner (owner) and the borrower (borrower) </h4><br>  This section is based on the Rust Guide with reference to the copy and move methods in terms of privileges. <br><br>  The owner has some privileges.  And may: <br><br>  1. To control the resource allocation <br>  2. To borrow a resource unchangeably (multiple borrowings) or changeable (exclusive) and <br>  3. Transfer ownership (with transfer). <br><br>  The owner also has some limitations: <br><br>  1. In the process of borrowing, the owner cannot (a) change the resource or (b) occupy it in a modified form. <br>  2. In the process of variable borrowing, the owner cannot (a) have access to the resource or (b) occupy it. <br><br>  The borrower also has some privileges.  In addition to accessing or modifying a borrowed resource, the borrower may also share another borrower: <br><br>  1. The borrower may allocate (copy) the immutable borrow pointer <br>  2. A variable borrower can transfer (move) a variable borrowing.  (Note that the mutable reference has been moved). <br><br><h4>  Code examples </h4><br>  Enough talk.  Let's take a look at some code (you can run the Rust code at play.rust-lang.org).  In all of the following examples, we use "struct Foo", a Foo structure that is not replicable, because it contains a packed (dynamically distributed) value.  The use of uncopyable resources limits the possibilities of operations, which is a good idea during the study phase. <br><br>  Each code sample is also given a ‚Äúregion chart‚Äù to illustrate the owner‚Äôs areas, borrowers, etc. The curly brackets in the title bar are the same as the curly brackets in the code itself. <br><br><h5>  The owner can not access the resource in the process of variable borrowing </h5><br>  The following code will not compile unless we uncomment the last line "println:": <br><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { f: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;int&gt;, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = Foo { f: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//   let x = &amp;mut a; // :    `af`  , . . `a`     // println!("{}", af); } { ax * }  a |_____|  x |___| x = &amp;mut a  af | </span></span></code> </pre> <br>  This violates the restriction of owner # 2 (a).  If we put "let x = &amp; mut a;" in a nested block, borrowing ends before the println line!  and it might work: <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = Foo { f: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> }; { <span class="hljs-comment"><span class="hljs-comment">//   let x = &amp;mut a; //     } println!("{}", af); } { a { x } * }  a |_________|  x |_| x = &amp;mut a  af | OK</span></span></code> </pre><br><h5>  Borrower can move changeable borrowing to a new borrower. </h5><br>  This code illustrates borrower privileges # 2: a changeable borrower x can transfer (move) changeable borrowing to a new borrower y. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = Foo { f: <span class="hljs-keyword"><span class="hljs-keyword">box</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//   let x = &amp;mut a; //       y let y = x; // :   : `xf` // println!("{}", xf); } { axy * }  a |_______|  x |_| x = &amp;mut a  y |___| y = x  xf | </span></span></code> </pre><br>  After the move, the original borrower x no longer has access to the borrowed resource. <br><br><h2>  Area of ‚Äã‚Äãborrowing </h2><br>  Everything becomes interesting if we pass links here (&amp; &amp; &amp; mut), and then many newbies get confused. <br><br><h4>  Time of existence </h4><br><br>  In the entire history of borrowing, it is important to know where borrowing of a borrower begins and where it ends.  In the <a href="http://doc.rust-lang.org/guide-lifetimes.html">Guide to Lifetime,</a> this is called Lifetime: <br><br>  The lifetime is a static estimate of the execution distance, during which the pointer is valid: it always corresponds to an expression or block within a program. <br><br><h4>  &amp; = borrowing </h4><br>  A few words about borrowing.  First, just remember that &amp; = borrowing, and &amp; mut = variable borrowing.  Wherever you see the &amp; symbol is borrowing. <br><br>  Secondly, if the &amp; symbol is shown in every structure (in its field) or in a function / closure (in its return type or captured links), then such a structure / function / closure is a borrower and all borrowing rules apply to it. <br><br>  Thirdly, for each borrowing there is an owner and a single borrower or multiple borrowers. <br><br><h4>  Expansion of the loan area </h4><br>  A few words about the area of ‚Äã‚Äãthe loan.  First, the loan area: <br>  - this is the area where borrowing is effective, and <br>  - the borrower can expand the area of ‚Äã‚Äãthe loan (see below). <br><br>  Secondly, the borrower can expand the loan area through a copy (unchangeable borrowing) or relocate (a variable loan), which occurs in assignments or in function calls.  The receiver (this may be a new connection, structure, function, or closure) then becomes a new borrower. <br><br>  Thirdly, the loan area is a <i>consolidation</i> of all borrowers from the areas, and the borrowed resource must be valid for the entire area of ‚Äã‚Äãthe loan. <br><br><h4>  Loan formula </h4><br>  Now, we have a loan formula: <br>  resource area&gt; = loan area = consolidation of all borrowers areas <br><br><h4>  Code example </h4><br>  Let's take a look at some examples of expanding the loan area.  The struct Foo structure is the same as before: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = Foo { f: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y: &amp;Foo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  let x = &amp;a; //     y,    y = x; } // :     `af`, ,    // af = Box::new(1); } { a { xy } * }  a |___________|  x |___| x = &amp;a  y |_____| y = x   |=======|  af | </span></span></code> </pre><br>  Even though the loan occurs inside the if block, and the borrower x goes beyond the if block, he expanded the borrowing sphere by assigning y = x ;, so there are two borrowers: x and y.  According to the loan formula, the loan area is the union of borrower x and borrower y, which is located between the first loan let x = &amp; a;  until the end of the main unit.  (Note that leth: &amp; Foo; is not a borrower) <br><br>  You may have noticed that the if block will never be executed, since the condition is always false, but the compiler still denies the owner of the resource `a` access to the resource.  This is because all loan checks take place at compile time, you cannot do anything at run time. <br><br><h2>  Borrowing multiple resources </h2><br>  So far, we have focused only on borrowing from one resource.  Can a borrower take multiple resources?  Of course!  For example, a function can take two links and return one of them depending on certain criteria, for example, which of the links is greater than the other: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span></span>(x: &amp;Foo, y: &amp;Foo) -&gt; &amp;Foo</code> </pre><br>  The max function returns a pointer &amp;, therefore, it is a borrower.  The return result can be any of the inbound links, so it borrows two resources. <br><br><h4>  Named loan area </h4><br>  If there are several pointers &amp; as inbound, we must specify their relationship using the time of lives with the name defined in <a href="http://doc.rust-lang.org/guide-lifetimes.html">the lifetime manual</a> .  But for now, let's just call them the named loan area. <br><br>  The above code will not be accepted by the compiler without specifying the relationship between borrowers, that is, those borrowers who are grouped in their area of ‚Äã‚Äãcredit.  This implementation will be correct: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo, y: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xf &gt; yf { x } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { y } } (        <span class="hljs-string"><span class="hljs-string">'a'</span></span>.) max( { } )  *x &lt;--------------&gt;  *y &lt;--------------&gt;   <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> &lt;==============&gt;  x |___|  y |___|   |___|   </code> </pre><br>  In this function, we have one loan area 'a' and three borrowers: two input parameters and the result returned by the function.  The above borrowing formula is still applied, but now each borrowed resource must satisfy the formula.  See the example below. <br><br><h4>  Code example </h4><br>  Let's use the max function in the following code to select the most from a and b: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = Foo { f: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">1</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y: &amp;Foo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = Foo { f: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = max(&amp;a, &amp;b); <span class="hljs-comment"><span class="hljs-comment">// : `b`     // y = x; } } { a { bx ( ) y } }  a |________________|   b |__________|    |==========|   |_| &amp;a   |_| &amp;b  x |________| x = max(&amp;a, &amp;b)  y |___| y = x</span></span></code> </pre><br>  To let x = max (&amp; a, &amp; b);  everything is good, because &amp; a and &amp; b are temporary references that are only valid in the expression, and the third borrower x borrows two resources (either a or b but checking the borrower if both are borrowed) to the end of the if block, thus The loan is in let x = max (&amp; a, &amp; b);  to the end of the if block.  Resources a and b are valid throughout the entire loan area, therefore, they satisfy the loan formula. <br><br>  Now, if we uncomment the last value y = x ;, y will become the fourth borrower, and the loan area will increase to the end of the main block, resulting in resource b failing the loan formula test. <br><br><h2>  Structure as a borrower </h2><br>  In addition to functions and closures, a structure can also occupy several resources, retaining several references in its area (s).  Let's look at the example below, and how the loan formula is applied.  Let's use the Link structure to store the reference (immutable borrow): <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Link</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { link: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo, }</code> </pre><br><h4>  Structure borrows several resources </h4><br>  Even with only one field, a Link structure can take several resources: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = Foo { f: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = Link { link: &amp;a }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = Foo { f: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">1</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// : `b`     // x.link = &amp;b; } } { ax { b * } }  a |___________|   b |___|    |=========|  x |_________| x.link = &amp;a  x |___| x.link = &amp;b</span></span></code> </pre><br>  In the example above, borrower x borrows resources from owner a, and the loan area goes to the end of the main unit.  So far, so good.  If we uncomment the last line x.link = &amp; b ;, x also tries to borrow a resource from the owner of b, and then the resource b fails the test for a loan formula. <br><br><h4>  Function to expand the loan area without return value </h4><br>  A function without a return value can also expand the loan area through its input parameters.  For example, the store_foo function accepts a variable link to Link, and stores the Foo (immutable borrow) link in it: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">store_foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Link&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, y: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo) { x.link = y; }</code> </pre><br>  In the following code, borrowed resources have taken possession of resources;  The Link structure is mutable to the borrower x (i.e. * x is the borrower)  The loan area goes to the end of the main block. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = Foo { f: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Link { link: &amp;a }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = Foo { f: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">1</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// store_foo(x, &amp;b); } } { ax { b * } }  a |___________|   b |___|    |=========|  *x |_________| x.link = &amp;a  *x |___| x.link = &amp;b</span></span></code> </pre><br>  If we uncomment the last line store_foo (x, &amp; b);  the function will try to store &amp; b at x.link, making resource b another borrowed resource and failing the loan formula test, since the resource area b does not cover the entire loan area. <br><br><h4>  Multiple loan areas </h4><br>  A function may have several named loan areas.  For example: <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">superstore_foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;(x: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Link&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, y: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo, x2: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Link&lt;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;, y2: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> Foo) { x.link = y; x2.link = y2; }</code> </pre><br>  In this (probably not very useful) function, two disparate loan areas are involved.  Each loan area will have its own borrowing formula. <br><br><h2>  Why time of existence is confusing </h2><br>  Finally, I want to explain why I think that the term ‚Äúlifetime‚Äù used by Rust's loan system is confusing (and thus avoid using the term in this blog). <br><br>  When we talk about a loan, there are three types of ‚Äútime to live‚Äù: <br><br>  A: the lifetime of the owner of the resource (or owning / borrowed resource) <br>  B: ‚Äúlifetime‚Äù of the whole loan, i.e.  from first loan to return <br>  C: the lifetime of a single borrower or borrowed index <br><br>  When someone speaks of the term "lifetime", he can mean any of the above.  If there are more resources and borrowers involved, then everything becomes even more confusing.  For example, what does a ‚Äúnamed lifetime‚Äù do in a function or structure declaration?  Does this mean A, B or C? <br><br>  In our previous max function: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo, y: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Foo { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xf &gt; yf { x } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { y } }</code> </pre><br>  What does 'a' lifetime mean?  This should not be A, since the two resources are involved and have different times of existence.  This can not be with C, because there are three borrowers: x, y and the return value of the function and they all have different lifetimes.  Does this mean B?  Probably.  But the whole area of ‚Äã‚Äãthe loan is not a specific object, how can it have a ‚Äúlifetime‚Äù?  To call this a time of existence is to err. <br><br>  Some may say that this means the minimum lifetime requirements for borrowed resources.  In some cases, this may be important, but how can we call them "time of existence"? <br><br>  The concept of ownership / borrowing itself is complex.  I would say that the confusion in what ‚Äúlife time‚Äù gives makes mastering even more incomprehensible. <br><br>  PS With the use of A, B, and C, as defined above, the loan formula becomes: <br><br><pre> <code class="rust hljs"> A &gt;= B = C1 U C2 U ‚Ä¶ U Cn</code> </pre><br><h2>  Learning Rust is worth your time! </h2><br>  Although it is time consuming to study loan and acquisition, it is interesting to study.  Rust will try to achieve security without garbage collection, and he still does it very well.  Some people say that mastering Haskell changes your programming style.  I think mastering Rust is also worth your time. <br><br>  Hope this post helps you. </div><p>Source: <a href="https://habr.com/ru/post/266715/">https://habr.com/ru/post/266715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266701/index.html">Notes from Intel System Studio Developer: Debugging Android Linux Core with Intel JTAG Debugger and MinnowBoard MAX</a></li>
<li><a href="../266703/index.html">Microservices without servers (cloud version)</a></li>
<li><a href="../266705/index.html">Basics of preparing applications for deployment (Application packaging)</a></li>
<li><a href="../266707/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 10. "Cris Aragon"</a></li>
<li><a href="../266713/index.html">Design unification from the backend: JavaScript on the server</a></li>
<li><a href="../266717/index.html">Study: Almost all popular firewalls miss XSS attacks</a></li>
<li><a href="../266719/index.html">Screentendo - Generate levels for Super Mario Bros based on screen content.</a></li>
<li><a href="../266721/index.html">Z-Desk - geometric constructions in space</a></li>
<li><a href="../266727/index.html">About a Data Science Problem</a></li>
<li><a href="../266729/index.html">We log context of exceptions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>