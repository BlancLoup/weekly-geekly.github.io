<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go Planner</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's Preamble: This is a fairly free translation, albeit not the most recent (June 2013), but an intelligible publication about a new planner ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go Planner</h1><div class="post__text post__text-html js-mediator-article">  <b>Translator's Preamble:</b> This is a fairly free translation, albeit not the most recent (June 2013), but an intelligible publication about a new planner of parallel branches of execution in Go.  The advantage of this note is that it is quite simple, "on the fingers" describes a new planning mechanism for review.  For those who are not satisfied with the explanation "on the fingers" and who would like a detailed presentation, I recommend <a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling Multithreaded Computations by Work Stealing</a> - 29 pages of presentation with a strict and complex mathematical apparatus for analyzing performance, 48 bibliography positions. <br><br><h1>  Introduction </h1><br>  One of the biggest innovations in Go 1.1 was a new dispatcher designed by Dmitry Vyukov.  The new scheduler gave such a dramatic increase in performance for parallel programs without changing the code that I decided to write something about it. <br><a name="habracut"></a><br>  Most of what is written here is already described in the original text from the author.  This text is rather detailed, but it is purely technical. <br><br>  Everything you need to know about the new planner is contained in this author's text, but my description is illustrative, which exceeds it for understanding. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Why go planner at all? </h1><br>  Before we take a look at the new planner, we need to figure out why we need it at all.  Why create a user-space scheduler when the operating system schedules threads for you? <br><br>  The POSIX threading APIs are a very logical continuation of the process model existing in the Unix operating system, and, if so, threads are received by many of those controls as processes. <br><br>  Threads have their own signal mask, can be assigned to processors using an affinity mask, can be entered into groups, and can be tested for what resources they use.  All these elements add overhead for objects, and since they are simply not needed for Go programs using Go-routines, these overhead costs avalanche add up when you have 100,000 threads in your program. <br><br>  Another problem is that the operating system cannot make meaningful planning decisions based on the Go model.  For example, the garbage collector requires all threads to be stopped when the collector starts and their memory must be in a synchronized state.  This implies waiting for running threads to reach a point where we know for sure that the memory is in an adequate state. <br><br>  When you have many threads planned at random points, there is a high probability that you will have to wait for most of them to reach a consistent state.  The Go scheduler, on the other hand, can only decide to re-plan in places where he knows that the memory is in consistent states.  This means that when we stop for garbage collection, we are forced to expect only those threads that are actively running on the processor cores. <br><br><h1>  Characters </h1><br>  Usually there are 3 models for cutting calculations into threads.  The first is N: 1, where several user threads are running on a single kernel thread of the operating system.  This method has the advantage of very fast context switching, but it is not possible to take advantage of multi-core systems.  The second method is 1: 1, where each user thread of execution coincides with one thread of the operating system.  It uses all the kernels automatically, but context switching is slow because it requires interruptions in the operating system. <br><br>  Go tries to take the best of both worlds using the M: N planner.  At the same time, an arbitrary number of Go-routines (M) is planned for an arbitrary number of threads (N) of the operating system.  This way you get both a fast context switch and the ability to use all the cores on your system.  The main disadvantage of this approach is the complexity of its inclusion in the scheduler. <br><br>  To perform the scheduling task, the Go scheduler uses 3 basic entities: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7f/950/7f2/b7f9507f25478708df83be3e4243f2a3.jpg"><br><br>  The triangle represents the flow of the operating system.  The execution of such a thread is controlled by the operating system, and it works in much the same way as your standard POSIX threads.  In executable code, this is called the M machine. <br><br>  The circle represents the go-routine.  It includes a stack, a command pointer, and other important information for planning a go-routine, such as a channel that may be blocked on it.  In the executable code, this is denoted as G. <br><br>  The rectangle represents the planning context.  You can understand it as a localized version of the scheduler that executes Go-rutin code in a single kernel thread.  This is the important part that allows us to get away from the N: 1 scheduler and the M: N scheduler.  At runtime, the context is denoted as P for the processor.  In general, this is all, briefly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed6/195/c49/ed6195c49aad3cfa29b163492bd9cb0f.jpg"><br><br>  The figure shows 2 kernel threads (M), each owning a context (P), each of which performs a Go-routine.  For the purposes of the Go routine, the thread must hold the context.  The number of contexts is set at the start from the value of the GOMAXPROCS environment variable, or by the GOMAXPROCS () runtime function.  Normally this value does not change during the execution of your program. <br><br>  The fact of a fixed number of contexts means that only GOMAXPROCS of Go code areas are executed simultaneously at any time.  We can use this to configure the Go process call for an individual computer, for example, on a 4-core PC, execute the Go code in 4 threads. <br><br>  Tinted gray in the figure Go-routines are not performed, but are ready for planning.  They are placed in lists called run queues.  Go-routines are added to the end of the execution queue each time the next go-routine is executed by the go operator.  Each time the context has to perform the next Go-routine from the planning point, it pushes the Go-routine out of its execution queue, sets its stack and instruction pointer, and the Go-routine begins. <br><br>  To prevent disagreement between mutexes, each context has its own local execution queue.  The previous version of the Go scheduler had only a global execution queue, with protection by its mutex.  Threads were often blocked waiting for the mutex to be released.  It was very unfortunate when you use a 32-core machine, wanting to get the maximum performance out as much as possible. <br><br>  The scheduler keeps scheduling in such a stable state as long as all contexts have running Go routines.  However, there are several scenarios that can change this behavior. <br><br><h1>  Who will you call (system)? </h1><br>  You might be wondering, why do we need contexts at all?  Can't we just attach execution queues to threads and get rid of contexts?  Unreal.  The point is that we have contexts so that we can pass them to other threads if the current thread has to block for some reason. <br><br>  An example of when we need to block is when we make a system call.  Since the thread cannot simultaneously execute code and be blocked on a system call, we need to pass the context, because it can delay scheduling. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/142/6e5/1e7/1426e51e773a9b36338cc3a36f9fe0ea.jpg"><br><br>  Here we see a thread abandoning its context, so another thread can start it.  The scheduler will make sure that there are enough threads to execute all the contexts.  M1 in the figure above can be specially created only for processing a system call, or it can come from some thread pool.  The system call that executes the thread will be frozen on the Go-routine that makes the system call, since it is technically still running, although it is blocked in the operating system. <br><br>  When the system call returns, the thread should attempt to get a context in order to start the returning Go routine.  The normal mode of action is to borrow the context from one of the other threads.  If the thread cannot borrow, it will put the Go-routine into the global execution queue, returning to the pool of free streams, or going to sleep. <br><br>  The global execution queue is the execution queue from where contexts are retrieved (jobs) when they end in their local queues.  Contexts also periodically check the global queue for Go-Wireout.  Otherwise, the go-routines in the global queue may never start and die of starvation. <br><br>  Such system call processing explains why Go programs run in multiple threads, even when GOMAXPROCS is set to 1. The runtime uses Go routines for system calls, leaving threads following them. <br><br><h1>  Borrowing work </h1><br>  Another way that the stable state of the system can change is when the context falls out of the Go-Route schedule.  This can occur if the amounts of work on the execution queues of the contexts are unbalanced.  This can happen when the context, in the end, exhausts its turn of execution, despite the fact that there is still work to be done in the system.  To continue executing Go code, the context may take Go rouins from the global execution queue, but if there are none and there, it must receive them from another location. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bca/2a7/d77/bca2a7d7718c42eff6f2390e6cfd7bf1.jpg"><br><br>  This is somewhere in other contexts.  When the context is exhausted, it will attempt to borrow about half of the execution queue from another context.  This ensures that there is always work to be performed on each of the contexts, which in turn confirms that all threads are working at the limit of their capabilities. <br><br><h1>  What's next? </h1><br>  There are many more details in the scheduler, like cgo threads, LockOSThread () function, and integration with network pulling.  They go beyond these notes, but still deserve to be studied.  I may write about them later.  Of course, many interesting constructs can be found in the Go runtime libraries. </div><p>Source: <a href="https://habr.com/ru/post/269271/">https://habr.com/ru/post/269271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269259/index.html">Emoji Encryption</a></li>
<li><a href="../269261/index.html">Back to the future, or Hello World today and thirty years ago</a></li>
<li><a href="../269263/index.html">Alpha version of SocketPush - universal notifications for all browsers + 3 million free notifications</a></li>
<li><a href="../269267/index.html">Knowledge Management with KCS</a></li>
<li><a href="../269269/index.html">Let's Encrypt is now trusted</a></li>
<li><a href="../269273/index.html">Algorithm for extracting information in ABBYY Compreno. Part 2</a></li>
<li><a href="../269275/index.html">Creating a MySQL database within Microsoft Azure for students</a></li>
<li><a href="../269281/index.html">Oracle, typical SQL tasks. Guaranteed choice</a></li>
<li><a href="../269285/index.html">3 ways to use the operator? .. wrong in C # 6</a></li>
<li><a href="../269287/index.html">Multiklet became more accessible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>