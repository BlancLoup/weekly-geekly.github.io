<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Regular expressions for the smallest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. 

 My name is Vitaly Kotov and I know a little about regular expressions. Under the cut, I'll tell you the basics of working with them. Many...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Regular expressions for the smallest</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr. <br><br>  My name is Vitaly Kotov and I know a little about regular expressions.  Under the cut, I'll tell you the basics of working with them.  Many theoretical articles have been written on this topic.  In this article, I decided to focus on the number of examples.  It seems to me that this is the best way to show the capabilities of this tool. <br><br>  Some of them, for clarity, will be shown on the example of the programming languages ‚Äã‚ÄãPHP or JavaScript, but in general they work independently of PL. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      From the title it is clear that the article is focused on the very initial level - those who have never used regular expressions in their programs or did it without proper understanding. <br><br>  At the end of the article, I will briefly tell you which tasks cannot be solved by regular expressions and which tools should be used for this. <br><br>  Go! <br><br><img src="https://habrastorage.org/webt/h1/9i/4n/h19i4ng_7n8_7mpap5spiy-fe8o.jpeg"><br><a name="habracut"></a><br><h2>  Introduction </h2><br>  <b>Regular expressions</b> - the search language substring or substrings in the text.  A pattern (pattern, mask) consisting of characters and metacharacters (characters that mean not themselves, but a set of characters) is used for the search. <br><br>  This is quite a powerful tool that can be useful in many cases - search, check for correct string, etc.  The spectrum of its capabilities is difficult to fit into one article. <br><br>  In PHP, working with regular expressions consists of a set of functions, of which I most often use the following: <br><br><ul><li>  preg_match ( <a href="http://php.net/manual/en/function.preg-match.php">http://php.net/manual/en/function.preg-match.php</a> ) </li><li>  preg_match_all ( <a href="http://php.net/manual/en/function.preg-match-all.php">http://php.net/manual/en/function.preg-match-all.php</a> ) </li><li>  preg_replace ( <a href="http://php.net/manual/en/function.preg-replace.php">http://php.net/manual/en/function.preg-replace.php</a> ) </li></ul><br>  To work with them, you need a text in which we will search for or replace the substrings, as well as the regular expression that describes the search rule. <br><br>  Match functions return the number of substrings found or false in case of errors.  The replace function returns a modified string / array or null if an error occurs.  The result can be brought to bool (false if no values ‚Äã‚Äãwere found and true if it was) and used together with if or assertTrue to handle the result of the work. <br><br>  In JS, I most often have to use: <br><br><ul><li>  match ( <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match</a> ) </li><li>  test ( <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test</a> ) </li><li>  replace ( <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace</a> ) </li></ul><br>  All further examples I suggest to look at <a href="https://regex101.com/">https://regex101.com/</a> .  This is a convenient and intuitive interface for working with regular expressions. <br><br><h2>  An example of using functions </h2><br>  In PHP, a regular expression is a string that begins and ends with a delimiter character.  Everything between delimiters is a regular expression. <br><br>  Often used separators are slashes ‚Äú/‚Äù, pound signs ‚Äú#‚Äù and tildes ‚Äú~‚Äù.  The following are examples of templates with valid delimiters: <br><br><ul><li>  / foo bar / </li><li>  # ^ [^ 0-9] $ # </li><li>  % [a-zA-Z0-9 _-]% </li></ul><br>  If you need to use a separator inside the template, you need to screen it with a backslash.  If a separator is often used in a template, for readability purposes, it is better to choose another separator for this template. <br><br><ul><li>  / http: \ / \ // </li><li>  #http: // # </li></ul><br>  In JavaScript, regular expressions are implemented by a separate RegExp object and integrated into string methods. <br><br>  You can create a regular expression like this: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> regexp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br>  Or a shorter version: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> regexp = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> regexp = <span class="hljs-regexp"><span class="hljs-regexp">//gmi</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   gmi (  )</span></span></code> </pre><br>  An example of the simplest regular expression to find: <br><br><pre> <code class="php hljs">RegExp: /o/ Text: hello world</code> </pre><br>  In this example, we are simply looking for all the characters ‚Äúo‚Äù. <br><br>  In PHP, the difference between preg_match and preg_match_all is that the first function will only find the first match and end the search, while the second function will return all entries. <br><br>  Sample PHP code: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $text = <span class="hljs-string"><span class="hljs-string">'hello world'</span></span>; $regexp = <span class="hljs-string"><span class="hljs-string">'/o/'</span></span>; $result = preg_match($regexp, $text, $match); var_dump( $result, $match );</code> </pre><br><pre> <code class="php hljs">int(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    , ..     array(1) { [0]=&gt; string(1) "o" //   ,  ,        }</span></span></code> </pre><br>  We try the same for the second function: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $text = <span class="hljs-string"><span class="hljs-string">'hello world'</span></span>; $regexp = <span class="hljs-string"><span class="hljs-string">'/o/'</span></span>; $result = preg_match_all($regexp, $text, $match); var_dump( $result, $match );</code> </pre><br><pre> <code class="php hljs">int(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"o"</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"o"</span></span> } }</code> </pre><br>  In the latter case, the function returned all entries that are in our text. <br><br>  The same javascript example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = str.match(<span class="hljs-regexp"><span class="hljs-regexp">/o/</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result);</code> </pre><br><pre> <code class="php hljs">[<span class="hljs-string"><span class="hljs-string">"o"</span></span>, index: <span class="hljs-number"><span class="hljs-number">4</span></span>, input: <span class="hljs-string"><span class="hljs-string">"Hello world"</span></span>]</code> </pre><br><h2>  Template Modifiers </h2><br>  For regular expressions, there is a set of modifiers that change the search operation.  They are denoted by a single letter of the Latin alphabet and are put at the end of a regular expression, after the closing ‚Äú/‚Äù. <br><br><ul><li>  i - the characters in the pattern correspond to the characters of both upper and lower case. </li><li>  m - by default, the text is processed as a single-line character string.  The metacharacter of the beginning of the string '^' matches only the beginning of the text being processed, while the metacharacter of the end of the string '$' corresponds to the end of the text.  If this modifier is used, the metacharacters ‚Äúbeginning of line‚Äù and ‚Äúend of line‚Äù also correspond to positions before an arbitrary translation character and line and, respectively, after, as at the very beginning, and at the very end of the line. </li></ul><br>  About the other modifiers used in PHP, you can <a href="http://php.net/manual/en/reference.pcre.pattern.modifiers.php">read here</a> . <br><br>  In javascript - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">here</a> . <br><br>  You can <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">read about</a> modifiers in general <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">here</a> . <br><br>  An example of a previous regular expression with a JavaScript modifier: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-string"><span class="hljs-string">"hello world \ How is it going?"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = str.match(<span class="hljs-regexp"><span class="hljs-regexp">/o/g</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result);</code> </pre><br><pre> <code class="php hljs">[<span class="hljs-string"><span class="hljs-string">"o"</span></span>, <span class="hljs-string"><span class="hljs-string">"o"</span></span>, <span class="hljs-string"><span class="hljs-string">"o"</span></span>, <span class="hljs-string"><span class="hljs-string">"o"</span></span>]</code> </pre><br><h2>  Regex metacharacters </h2><br>  At first, the examples will be rather primitive, because we are familiar with the basics.  The more we learn, the closer to reality there will be examples. <br><br>  Most often, we do not know in advance what text we will have to parse.  Only an approximate set of rules is known in advance.  Be it a pincode in SMS, email in a letter, etc. <br><br>  First example, we need to get all the numbers from the text: <br><br><pre> <code class="php hljs">: ‚Äú,   <span class="hljs-number"><span class="hljs-number">1528.</span></span>  .‚Äù</code> </pre><br>  To select any number, you need to collect all the numbers by specifying ‚Äú[0123456789]‚Äù.  In short, you can set it like this: ‚Äú[0-9]‚Äù.  For all digits there is a metacharacter ‚Äú\ d‚Äù.  It works identically. <br><br>  But if we specify the regular expression ‚Äú/ \ d /‚Äù, then only the first digit will return to us.  Of course, we can use the ‚Äúg‚Äù modifier, but in this case, each digit will return as a separate element of the array, since it will be considered a new entry. <br><br>  In order to display a substring as a single occurrence, there are symbols plus ‚Äú+‚Äù and an asterisk ‚Äú*‚Äù.  The first one indicates that a substring is suitable for us, where there is at least one suitable character for the set.  The second is that this set of characters may or may not be, and this is normal.  In addition, we can specify the exact value of the appropriate characters like this: ‚Äú{N}‚Äù, where N is the desired number.  Or set ‚Äúfrom‚Äù and ‚Äúto‚Äù by pointing like this: ‚Äú{N, M}‚Äù. <br><br>  Now there will be a couple of examples for it to fit in the head: <br><br><pre> <code class="php hljs">: ‚Äú     <span class="hljs-number"><span class="hljs-number">2</span></span>   .‚Äù     . RegExp: ‚Äú/\d/‚Äù</code> </pre><br><pre> <code class="php hljs">: ‚Äú : <span class="hljs-number"><span class="hljs-number">24356</span></span>‚Äù  ‚Äú   .‚Äù     ,   . RegExp: ‚Äú/\d*/‚Äù</code> </pre><br><pre> <code class="php hljs">: ‚Äú  <span class="hljs-number"><span class="hljs-number">89091534357</span></span>‚Äù    <span class="hljs-number"><span class="hljs-number">11</span></span> ,  <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>,   . RegExp: ‚Äú/\d{<span class="hljs-number"><span class="hljs-number">11</span></span>}/‚Äù</code> </pre><br>  In a similar way, we work with letters, without forgetting that they have a register.  This is how letters can be set: <br><br><ul><li>  [az] </li><li>  [a-zA-Z] </li><li>  [aaaa-za] </li></ul><br>  With Cyrillic, the specified range works differently for different encodings.  In Unicode, for example, the letter ‚Äúe‚Äù is not included in this range.  More on this <a href="https://unicode-table.com/en/blocks/cyrillic/">here</a> . <br><br>  A couple of examples: <br><br><pre> <code class="php hljs">: ‚Äú  ‚Äù  ‚Äú  ‚Äù     ‚Äú‚Äù,   ‚Äú‚Äù. RegExp: ‚Äú/[--]+/‚Äù</code> </pre><br>  Such an expression will select all the words that are in the sentence and written in Cyrillic.  We need the third word. <br><br>  In addition to letters and numbers, we may also have important symbols, such as: <br><br><ul><li>  \ s - space </li><li>  ^ - beginning of line </li><li>  $ - end of line </li><li>  |  - "or" </li></ul><br>  The previous example has become simpler: <br><br><pre> <code class="php hljs">: ‚Äú  ‚Äù  ‚Äú  ‚Äù    ‚Äú‚Äù,  ‚Äú‚Äù. RegExp: ‚Äú/[--]+$/‚Äù</code> </pre><br>  If we know for sure that the search word is the last one, we put $ and the result will be only that character set, after which the end of the line follows. <br><br>  The same with the beginning of the line: <br><br><pre> <code class="php hljs">: ‚Äú ‚Äù  ‚Äú ‚Äù    ‚Äú‚Äù,  ‚Äú‚Äù. RegExp: ‚Äú/^[--]+/‚Äù</code> </pre><br>  Before getting acquainted with the meta characters further, you need to discuss the ‚Äú^‚Äù symbol separately, because it goes to two works at once (this is to make it more interesting).  In some cases, it denotes the beginning of a line, but in some - negation. <br><br>  This is necessary for those cases where it is easier to specify characters that do not suit us than those that suit us. <br><br>  Suppose we have collected a set of characters that suit us: ‚Äú[a-z0-9]‚Äù (we are satisfied with any small Latin letter or digit).  Now suppose that we are satisfied with any character except this one.  This will be indicated like this: ‚Äú[^ a-z0-9]‚Äù. <br><br>  Example: <br><br><pre> <code class="php hljs">: ‚Äú   ‚Äù    . RegExp: ‚Äú[^\s]+‚Äù</code> </pre><br>  We select all "not spaces". <br><br>  So, here is a list of basic metacharacters: <br><br><ul><li>  \ d - matches any digit;  equivalent [0-9] </li><li>  \ D - matches any non-numeric character;  equivalent [^ 0-9] </li><li>  \ s - matches any whitespace character;  equivalent to [\ t \ n \ r \ f \ v] </li><li>  \ S - matches any non-whitespace character;  equivalent [^ \ t \ n \ r \ f \ v] </li><li>  \ w - matches any letter or number;  equivalent of [a-zA-Z0-9_] </li><li>  \ W - vice versa;  equivalent [^ a-zA-Z0-9_] </li><li>  .  - (just a dot) any character except the translation of the ‚Äúcarriage‚Äù </li></ul><br><h2>  Operators [] and () </h2><br>  As described above, it was possible to guess that [] is used to group several characters together.  So we say that we are satisfied with any character from the set. <br><br>  Example: <br><br><pre> <code class="php hljs">: ‚Äú   I dont know, !‚Äù     . RegExp: ‚Äú/[A-Za-z\s]{<span class="hljs-number"><span class="hljs-number">2</span></span>,}/‚Äù</code> </pre><br>  Here we gathered in the group (between the characters []) all Latin letters and a space.  With the help of {} indicated that we are interested in occurrences, where <i>at least</i> 2 characters, to exclude occurrences from empty spaces. <br><br>  Similarly, we could get all the Russian words by inverting: ‚Äú[^ A-Za-z \ s] {2,}‚Äù. <br><br>  Unlike [], characters () collect marked expressions.  They are sometimes called ‚Äúcapture‚Äù. <br><br>  They are needed in order to transfer the selected piece (which may consist of several occurrences of [] in the output result). <br><br>  Example: <br><br><pre> <code class="php hljs">: <span class="hljs-string"><span class="hljs-string">'Email you sent was ololo@example.com Is it correct?'</span></span>    email.</code> </pre><br>  There are many solutions.  The example below is an <i>approximate</i> version that simply shows the possibilities of regular expressions.  Actually there is an <a href="https://en.wikipedia.org/wiki/Request_for_Comments">RFC</a> that determines the correctness of an email.  And there are "regulars" for RFC - <a href="https://fightingforalostcause.net/content/misc/2006/compare-email-regex.php">here are examples</a> . <br><br>  We choose everything that is not a space (because the first part of the email can contain any character set), then there should be an @ symbol, then anything except a dot and a space, then a dot, then any Latin character in lower case ... <br><br>  So, let's go: <br><br><ul><li>  we select everything that is not a space: ‚Äú[^ \ s] +‚Äù </li><li>  we select the @ sign: ‚Äú@‚Äù </li><li>  we choose anything except a period and a space: ‚Äú[^ \ s \.] +‚Äù </li><li>  we select the point: ‚Äú\.‚Äù (the backslash is needed for the escape of the metacharacter, since the dot character describes any character - see above) <br></li><li>  we select any lowercase Latin character: ‚Äú[az] +‚Äù </li></ul><br>  It turned out not so difficult.  Now we have email assembled in parts.  Consider the example of the result of the work in PHP preg_match: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $text = <span class="hljs-string"><span class="hljs-string">'Email you sent was ololo@example.com. Is it correct?'</span></span>; $regexp = <span class="hljs-string"><span class="hljs-string">'/[^\s]+@[^\s\.]+\.[az]+/'</span></span>; $result = preg_match_all($regexp, $text, $match); var_dump( $result, $match );</code> </pre><br><pre> <code class="php hljs">int(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-string"><span class="hljs-string">"ololo@example.com"</span></span> } }</code> </pre><br>  Happened!  But what if now we need to separately get the domain and name by email?  And somehow use further in the code?  This is where the ‚Äúcapture‚Äù will help us.  We simply choose what we need and wrap them with signs (), as in the example: <br><br>  It was: <br><br><pre> <code class="php hljs">/[^\s]+@[^\s\.]+\.[az]+/</code> </pre><br>  It became: <br><br><pre> <code class="php hljs">/([^\s]+)@([^\s\.]+\.[az]+)/</code> </pre><br>  We try: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $text = <span class="hljs-string"><span class="hljs-string">'Email you sent was ololo@example.com. Is it correct?'</span></span>; $regexp = <span class="hljs-string"><span class="hljs-string">'/([^\s]+)@([^\s\.]+\.[az]+)/'</span></span>; $result = preg_match_all($regexp, $text, $match); var_dump( $result, $match );</code> </pre><br><pre> <code class="php hljs">int(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-string"><span class="hljs-string">"ololo@example.com"</span></span> } [<span class="hljs-number"><span class="hljs-number">1</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-string"><span class="hljs-string">"ololo"</span></span> } [<span class="hljs-number"><span class="hljs-number">2</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-string"><span class="hljs-string">"example.com"</span></span> } }</code> </pre><br>  In the match array, the zero element is always a full occurrence of a regular expression.  And then take turns ‚Äúcaptures‚Äù. <br><br>  In PHP, you can call it ‚Äúcaptures‚Äù using the following syntax: <br><br><pre> <code class="php hljs">/(?&lt;mail&gt;[^\s]+)@(?&lt;domain&gt;[^\s\.]+\.[az]+)/</code> </pre><br>  Then the array of the match will become associative: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $text = <span class="hljs-string"><span class="hljs-string">'Email you sent was ololo@example.com. Is it correct?'</span></span>; $regexp = <span class="hljs-string"><span class="hljs-string">'/(?&lt;mail&gt;[^\s]+)@(?&lt;domain&gt;[^\s\.]+\.[az]+)/'</span></span>; $result = preg_match_all($regexp, $text, $match); var_dump( $result, $match );</code> </pre><br><pre> <code class="php hljs">int(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-string"><span class="hljs-string">"ololo@example.com"</span></span> } [<span class="hljs-string"><span class="hljs-string">"mail"</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-string"><span class="hljs-string">"ololo"</span></span> } [<span class="hljs-string"><span class="hljs-string">"domain"</span></span>]=&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-string"><span class="hljs-string">"example.com"</span></span> } }</code> </pre><br>  This immediately +100 to readability and code, and regular. <br><br><h2>  Real life examples </h2><br><h3>  Parsim a letter searching for a new password: </h3><br>  There is a letter with HTML-code, you need to pull out of it a new password.  The text can be either in English or in Russian: <br><br><pre> <code class="php hljs">: ‚Äú: &lt;b&gt;f23f43tgt4&lt;/b&gt;‚Äù  ‚Äúpassword: &lt;b&gt;wh4k38f4&lt;/b&gt;‚Äù RegExp: ‚Äú(password|):\s&lt;b&gt;([^&lt;]+)&lt;\/b&gt;‚Äù</code> </pre><br>  First, we say that the text before the password can be of two options, using the ‚Äúor‚Äù. <br>  You can list as many options as you like: <br><br><pre> <code class="php hljs">(password|)</code> </pre><br>  Next we have a colon and one space: <br><br><pre> <code class="php hljs">:\s</code> </pre><br>  Next sign b tag: <br><br><pre> <code class="php hljs">&lt;b&gt;</code> </pre><br>  And then we are interested in everything that is not a ‚Äú&lt;‚Äù symbol, since it will indicate that the b tag is closed: <br><br><pre> <code class="php hljs">([^&lt;]+)</code> </pre><br>  We wrap it in a grip, because we need him. <br>  Next, we write the closing tag b, escaping the ‚Äú/‚Äù symbol, as this is a special character: <br><br><pre> <code class="php hljs">&lt;\/b&gt;</code> </pre><br>  It's pretty simple. <br><br><h3>  Parsim URL: </h3><br>  In PHP, there is a cool function that helps to work with the URL, breaking it down into its component parts: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $URL = <span class="hljs-string"><span class="hljs-string">"https://hello.world.ru/uri/starts/here?get_params=here#anchor"</span></span>; $parsed = parse_url($URL); var_dump($parsed);</code> </pre><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) { [<span class="hljs-string"><span class="hljs-string">"scheme"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-string"><span class="hljs-string">"https"</span></span> [<span class="hljs-string"><span class="hljs-string">"host"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-string"><span class="hljs-string">"hello.world.ru"</span></span> [<span class="hljs-string"><span class="hljs-string">"path"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-string"><span class="hljs-string">"/uri/starts/here"</span></span> [<span class="hljs-string"><span class="hljs-string">"query"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-string"><span class="hljs-string">"get_params=here"</span></span> [<span class="hljs-string"><span class="hljs-string">"fragment"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-string"><span class="hljs-string">"anchor"</span></span> }</code> </pre><br>  Let's do the same, just regular?  :) <br><br>  Any url begins with the scheme.  For us, this is the http / https protocol.  One could make a logical ‚Äúor‚Äù: <br><br><pre> <code class="php hljs">(http|https)</code> </pre><br>  But you can cheat and do this: <br><br><pre> <code class="php hljs">http[s]?</code> </pre><br>  In this case, the symbol ‚Äú?‚Äù Means that ‚Äús‚Äù can eat, maybe not ... <br><br>  Next we have ‚Äú: //‚Äù, but we have to escape the ‚Äú/‚Äù symbol (see above): <br><br><pre> <code class="php hljs">‚Äú:\/\/‚Äù</code> </pre><br>  Next we have the domain before the ‚Äú/‚Äù sign or the end of the line.  It may consist of numbers, letters, underscores, dashes and periods: <br><br><pre> <code class="php hljs">[\w\.-]+</code> </pre><br>  Here we have put together the metacharacter ‚Äú\ w‚Äù, the dot ‚Äù\.‚Äù And the dash ‚Äù-‚Äù. <br><br>  Next comes the URI.  Everything is simple, we take everything up to the question mark or the end of the line: <br><br><pre> <code class="php hljs">[^?$]+</code> </pre><br>  Now a question mark, which may or may not be: <br><br><pre> <code class="php hljs">[?]?</code> </pre><br>  Then everything is up to the end of the line or the beginning of the anchor (the # character) ‚Äîdo not forget that this part may also not be: <br><br><pre> <code class="php hljs">[^<span class="hljs-comment"><span class="hljs-comment">#$]+</span></span></code> </pre><br>  Further, it may be #, or it may not be: <br><br><pre> <code class="php hljs">[<span class="hljs-comment"><span class="hljs-comment">#]?</span></span></code> </pre><br>  Then everything is up to the end of the line, if there is: <br><br><pre> <code class="php hljs">[^$]+</code> </pre><br>  All the beauty in the end looks like this (unfortunately, I didn‚Äôt figure out how to insert this part so that Habr would not consider part of the line as a comment): <br><br><pre> <code class="php hljs">/(?&lt;scheme&gt;http[s]?):\/\/(?&lt;domain&gt;[\w\.-]+)(?&lt;path&gt;[^?$]+)?(?&lt;query&gt;[^<span class="hljs-comment"><span class="hljs-comment">#$]+)?[#]?(?&lt;fragment&gt;[^$]+)?/</span></span></code> </pre><br>  The main thing is not to blink!  :) <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $URL = <span class="hljs-string"><span class="hljs-string">"https://hello.world.ru/uri/starts/here?get_params=here#anchor"</span></span>; $regexp = ‚Äú/(?&lt;scheme&gt;http[s]?):\/\/(?&lt;domain&gt;[\w\.-]+)(?&lt;path&gt;[^?$]+)?(?&lt;query&gt;[^<span class="hljs-comment"><span class="hljs-comment">#$]+)?[#]?(?&lt;fragment&gt;[^$]+)?/‚Äù; $result = preg_match($regexp, $URL, $match); var_dump( $result, $match );</span></span></code> </pre><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">11</span></span>) { [<span class="hljs-number"><span class="hljs-number">0</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">61</span></span>) <span class="hljs-string"><span class="hljs-string">"https://hello.world.ru/uri/starts/here?get_params=here#anchor"</span></span> [<span class="hljs-string"><span class="hljs-string">"scheme"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-string"><span class="hljs-string">"https"</span></span> [<span class="hljs-string"><span class="hljs-string">"domain"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-string"><span class="hljs-string">"hello.world.ru"</span></span> [<span class="hljs-string"><span class="hljs-string">"URI"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-string"><span class="hljs-string">"/uri/starts/here"</span></span> [<span class="hljs-string"><span class="hljs-string">"params"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-string"><span class="hljs-string">"get_params=here"</span></span> [<span class="hljs-string"><span class="hljs-string">"anchor"</span></span>]=&gt; string(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-string"><span class="hljs-string">"anchor"</span></span> }</code> </pre><br>  It turned out about the same thing, only with their own hands. <br><br><img src="https://habrastorage.org/webt/qf/qo/1o/qfqo1ogxyrwja740mtg4en7de7e.png"><br><br><h2>  What tasks are not solved by regular expressions </h2><br>  At first glance, it seems that regular text can describe and parse any text.  But, unfortunately, it is not. <br><br>  Regular expressions are a subspecies of formal languages, which in Chomsky‚Äôs hierarchy belong to the 3rd type, the simplest.  About this <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B5%25D1%2580%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%258F_%25D0%25A5%25D0%25BE%25D0%25BC%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE">here</a> . <br><br>  With the help of this language, we cannot, for example, parse the syntax of programming languages ‚Äã‚Äãwith a nested grammar.  Or HTML code. <br><br><h3>  Examples of tasks: </h3><br>  We have a span, within which there are many other span and we do not know how much.  You have to choose everything inside this span: <br><br><pre> <code class="php hljs">&lt;span&gt; &lt;span&gt;ololo1&lt;/span&gt; &lt;span&gt;ololo2&lt;/span&gt; &lt;span&gt;ololo3&lt;/span&gt; &lt;span&gt;ololo4&lt;/span&gt; &lt;span&gt;ololo5&lt;/span&gt; &lt;...&gt; &lt;/span&gt;</code> </pre><br>  Of course, if we parse HTML, where there is not only this span.  :) <br><br>  The bottom line is that we cannot start at some point ‚Äúcounting‚Äù the symbols span and / span, meaning that there should be an equal number of opening and closing symbols.  And to ‚Äúunderstand‚Äù that the closing symbol, for which there was previously no pair, is the same closing symbol, which separates the block. <br><br>  Same with the code and {} characters. <br><br>  For example: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{&lt;...&gt;} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> () {&lt;...&gt;} } }</code> </pre><br>  In such a structure, we cannot, using only a regular expression, distinguish the closing brace inside the code from the one that completes the initial function (if the code consists not only of this function). <br><br>  To solve such problems using higher level languages. <br><br><h2>  Conclusion </h2><br>  I tried to tell in some detail about the basics of the world of regular expressions.  Of course it is impossible to fit everything into one article.  Further work with them is a matter of experience and ability to google. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/343310/">https://habr.com/ru/post/343310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343300/index.html">We compare what is impossible: cheap hosting and cloud on the VMware stack</a></li>
<li><a href="../343302/index.html">ScadaPy JSON server</a></li>
<li><a href="../343304/index.html">Binary Matrix Neural Network</a></li>
<li><a href="../343306/index.html">How to deal with cheaters and not rewrite all code</a></li>
<li><a href="../343308/index.html">Quantum versus classical: why do we need so many digits</a></li>
<li><a href="../343312/index.html">Setting up an environment for web development in Windows based on VMware Player virtual machine</a></li>
<li><a href="../343314/index.html">Atomic icebreaker Lenin - almost like a spaceship, only an icebreaker</a></li>
<li><a href="../343316/index.html">What is hidden behind the term modeling</a></li>
<li><a href="../343318/index.html">How to describe layout in code</a></li>
<li><a href="../343320/index.html">"Without further ado": the shortest scientific articles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>