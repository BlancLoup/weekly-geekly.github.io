<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A few words about pattern recognition</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long wanted to write a general article that contains the very basics of Image Recognition, a guide on basic methods, telling when to use them, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A few words about pattern recognition</h1><div class="post__text post__text-html js-mediator-article">  I have long wanted to write a general article that contains the very basics of Image Recognition, a guide on basic methods, telling when to use them, what tasks they decide what to do in the evening on their knees, and what is better not to think without having a team in 20. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/e3d/36e/ae7e3d36eb6c065eb592ca44d59d51f3.jpg" alt="image"></div><br>  I have been writing some articles on Optical Recognition for a long time, so a couple of times a month various people write to me with questions on this topic.  Sometimes it creates the feeling that you live with them in different worlds.  On the one hand, you understand that a person is most likely a professional in a related topic, but he knows very little in OCR methods.  And the most annoying thing is that he is trying to apply a method from a nearby area of ‚Äã‚Äãknowledge, which is logical, but in Image Recognition does not work completely, but does not understand it and is very offended if he starts telling something from the very foundations.  And considering that telling from the basics - a lot of time, which is often not there, is still sadder. <br><a name="habracut"></a><br>  This article is designed so that a person who has never worked on image recognition methods, within 10-15 minutes, can create in his head a certain basic picture of the world, relevant to the subject, and understand in which direction to dig.  Many of the methods described here are applicable to radar and audio processing. <br>  I will start with a couple of principles that we always begin to tell a potential customer, or a person who wants to start practicing Optical Recognition: <br><ul><li>  When solving a problem, always go from the simplest.  It is much easier to hang an orange label on a person than to follow a person, highlighting him in cascades.  It is much easier to take a camera with a higher resolution than to develop a superresolving algorithm. </li><li>  A rigorous formulation of the problem in optical recognition methods is orders of magnitude more important than in system programming problems: one extra word in the TOR can add 50% of the work. </li><li>  There are no universal solutions for recognition tasks.  You can not make an algorithm that will simply "recognize any inscription."  A sign on the street and a sheet of text are fundamentally different objects.  Probably, you can make a general algorithm ( <a href="http://habrahabr.ru/post/208330/">here is a</a> good example from Google), but this will require the great work of a large team and consist of dozens of different subroutines. </li><li>  OpenCV is a bible in which there are many methods, and with the help of which 50% of almost any task can be solved, but OpenCV is only a small part of what can be done in reality.  In one study, the conclusions were written: "The problem is not solved by OpenCV methods, therefore, it is unsolvable."  Try to avoid this, not be lazy and soberly assess the current task from scratch every time, without using OpenCV templates. </li></ul><br>  It is very difficult to give some kind of universal advice, or tell you how to create some kind of structure around which you can build a solution to arbitrary computer vision tasks.  The purpose of this article is to structure what can be used.  I will try to break the existing methods into three groups.  The first group is the pre-filtering and image preparation.  The second group is the logical processing of filtering results.  The third group is decision-making algorithms based on logical processing.  The boundaries between the groups are very conditional.  To solve a problem, it is not always necessary to apply methods from all groups, it is enough two, and sometimes even one. <br><br>  The list of methods given here is not complete.  I propose in the comments to add critical methods that I have not written and to assign 2-3 to each of the accompanying words. <br><br><h4>  Part 1. Filtering </h4><br>  In this group I put methods that allow you to highlight areas of interest in images, without analyzing them.  Most of these methods apply a single transformation to all points in the image.  At the filtering level, image analysis is not performed, but the points that pass filtering can be considered as areas with special characteristics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Threshold binarization, histogram area selection </h5><br>  The simplest transformation is the binarization of the image on the threshold.  For RGB images and grayscale images, the threshold is the color value.  There are ideal problems in which such a transformation is sufficient.  Suppose you need to automatically highlight items on a white sheet of paper: <br><img src="https://habrastorage.org/getpro/habr/post_images/b22/e12/c6d/b22e12c6d33eb898e34b373475be35d8.jpg" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/488/3fc/968/4883fc968b29368610812ce4069374bd.jpg" alt="image"><br>  The choice of the threshold by which binarization occurs largely determines the process of binarization itself.  In this case, the image was binarized according to the average color.  Usually, binarization is performed using an algorithm that adaptively selects a threshold.  Such an algorithm can be the choice of <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D0%25BE%25D0%25B6%25D0%25B8%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">expectation</a> or <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">mode</a> .  And you can choose the largest peak of the histogram. <br><img src="https://habrastorage.org/getpro/habr/post_images/218/61b/6f8/21861b6f804cbee1bb4d114e5172ba25.png" alt="image"><br>  Binarization can give very interesting results when working with histograms, including in a situation if we consider the image not in RGB, but in <a href="http://ru.wikipedia.org/wiki/HSV_(%25D1%2586%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C)">HSV</a> .  For example, segment the colors of interest.  On this principle, it is possible to build both a <a href="http://robocraft.ru/blog/computervision/402.html">tag</a> detector and a human <a href="http://wiki.technicalvision.ru/index.php/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2586%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">skin</a> detector. <br><img src="https://habrastorage.org/getpro/habr/post_images/e74/fa9/aab/e74fa9aab389c80be4e817b979536be1.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/060/88f/03f/06088f03f4428973e5820898caa5b22b.jpg" alt="image"><br><br><h5>  Classical filtering: Fourier, LPF, HPF </h5><br>  Classical filtering techniques from radar and signal processing can be successfully applied in a variety of Pattern Recognition tasks.  The traditional method in radar, which is almost not used in images in its pure form, is the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5">Fourier transform</a> (more specifically, <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%259F%25D0%25A4">FFT</a> ).  One of the few exceptions in which the one-dimensional Fourier transform is used is <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BA%25D0%25BE%25D1%2581%25D0%25B8%25D0%25BD%25D1%2583%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">image compression</a> .  For image analysis, one-dimensional transformation is usually not enough, you need to use a much more resource <a href="http://wiki.technicalvision.ru/index.php/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5._%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25B2_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">-</a> intensive <a href="http://wiki.technicalvision.ru/index.php/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5._%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25B2_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">two</a> - <a href="http://wiki.technicalvision.ru/index.php/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5._%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25B2_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B0%25D1%2581%25D1%2582%25D0%25B8">dimensional transformation</a> . <br><img src="https://habrastorage.org/getpro/habr/post_images/82a/cb7/df3/82acb7df3dd93ca01b7b06d44d7024f7.png" alt="image"><br>  Few people actually count it, usually, where it is much faster and easier to use a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BA%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7)">convolution of</a> the region of interest with a ready-made filter tuned to high (HPF) or low (LPF) frequencies.  This method, of course, does not allow for spectrum analysis, but in a particular video processing task, it is usually not the analysis that is needed, but the result. <br><img src="https://habrastorage.org/getpro/habr/post_images/afb/21e/10e/afb21e10e2fe6350aabf6e5e9fc07527.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/044/d41/3df044d411cdbb4b3489a7e38c0752ab.png" alt="image"><br>  The most simple examples of filters that implement the underscore of low frequencies ( <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%2593%25D0%25B0%25D1%2583%25D1%2581%25D1%2581%25D0%25B0">Gaussian filter</a> ) and high frequencies ( <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%2593%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2580%25D0%25B0">Filter Gabor</a> ). <br>  For each point of the image, a window is selected and multiplied with a filter of the same size.  The result of such a convolution is a new point value.  When implementing a low-pass filter and high-pass filter, images of this type are obtained: <br><img src="https://habrastorage.org/getpro/habr/post_images/40c/7f0/e01/40c7f0e012381013b5405ae7dae3faab.jpg" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/222/113/772/2221137721f1b755fd4c0410c491c671.jpg" alt="image"><br><h5>  Wavelets </h5><br>  But what if we use for the convolution of a signal with some arbitrary characteristic function?  Then it will be called " <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582">Wavelet Transformation</a> ".  This definition of wavelets is not correct, but it has traditionally been established that in many teams the wavelet analysis is the search for an arbitrary pattern in an image using a convolution with a model of this pattern.  There is a set of classical functions used in wavelet analysis.  These include the <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25B9%25D0%25B2%25D0%25BB%25D0%25B5%25D1%2582_%25D0%25A5%25D0%25B0%25D0%25B0%25D1%2580%25D0%25B0">Haar</a> <a href="http://en.wikipedia.org/wiki/Morlet_wavelet">wavelet</a> , <a href="http://en.wikipedia.org/wiki/Mexican_hat_wavelet">Morlah wavelet, Mexican hat wavelet</a> , etc.  The Haar primitives, about which there were several of my past articles ( <a href="http://habrahabr.ru/post/208092/">1</a> , <a href="http://habrahabr.ru/post/198338/">2</a> ), refer to such functions for two-dimensional space. <br><img src="https://habrastorage.org/getpro/habr/post_images/dd0/3af/963/dd03af9639fa83ed93d60e3d92402a25.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/508/e71/2d2508e71a8ad542e7cd1f9265936298.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/8ec/7c9/513/8ec7c951329026bdb3fa107c8962a170.png" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/55e/e9b/1d9/55ee9b1d9d489a87a7ead47c03b38615.png" alt="image"><br>  Above are 4 examples of classic wavelets.  3-dimensional Haar wavelet, 2-dimensional Meyer wavelet, Mexican Hat wavelet, Dobeshi wavelet.  A good example of the use of extended interpretation of wavelets is the problem of finding the glare in the eye, for which the wavelet is the glare itself: <br><img src="https://habrastorage.org/getpro/habr/post_images/fa0/dbb/528/fa0dbb5283a281adb910d7a1b9860bdd.jpg" alt="image"><br>  Classic wavelets are usually used to <a href="http://habrahabr.ru/post/169615/">compress images</a> , or to classify them (described below). <br><br><h5>  Correlation </h5><br>  After such a free interpretation of wavelets, on my part, it is worth mentioning the correlation proper, which underlies them.  When filtering images it is an indispensable tool.  A classic application is the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2580%25D1%2580%25D0%25B5%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F_%25D1%2586%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D1%258B%25D1%2585_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">correlation of a</a> video stream for finding shifts or optical flows.  The simplest shear detector is also in some sense a difference correlator.  Where the images do not correlate - there was movement. <br><img src="https://habrastorage.org/getpro/habr/post_images/64f/21f/2b1/64f21f2b185d9e6ae442a81140599b48.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/650/7d6/0f3/6507d60f3c2d772be9a46923164e214f.jpg" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/c9f/196/cfd/c9f196cfd69ec31a9e337c8fd13cf5b8.jpg" alt="image"><br><br><h5>  Filtering features </h5><br>  An interesting class of filters is filtering functions.  These are purely mathematical filters that allow you to detect a simple mathematical function in an image (direct, parabola, circle).  An accumulating image is built, in which for each point of the original image a multitude of functions are generated that generate it.  The most classical transformation is the <a href="http://ru.wikipedia.org/wiki/%25CF%25F0%25E5%25EE%25E1%25F0%25E0%25E7%25EE%25E2%25E0%25ED%25E8%25E5_%25D5%25E0%25F4%25E0">Hough</a> transformation for straight lines.  In this transformation, for each point (x; y), the set of points (a; b) of the line y = ax + b, for which equality holds, is drawn.  Beautiful pictures turn out: <br><img src="https://habrastorage.org/getpro/habr/post_images/f4d/046/1f8/f4d0461f88459af23e8505b5ddfee8ec.jpg" alt="image"><br>  (the first plus to the one who first finds the catch in the picture and that definition and explains it, the second plus to the one who first says what is shown here) <br>  Hough Transformation allows you to find any parameterizable functions.  For example a <a href="http://locv.ru/wiki/6.6.2_%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A5%25D0%25B0%25D1%2584%25D0%25B0_%25D0%25B4%25D0%25BB%25D1%258F_%25D0%25BE%25D0%25BA%25D1%2580%25D1%2583%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">circle</a> .  There is a modified transformation that allows you to search for any <a href="http://habrahabr.ru/post/141438/">shapes</a> .  This transformation is terribly fond of mathematics.  But when processing images, it unfortunately does not always work.  Very slow speed, very high sensitivity to binarization quality.  Even in ideal situations, I preferred to use other methods. <br>  <a href="http://wiki.technicalvision.ru/index.php/%25D0%25A1%25D0%25B2%25D1%258F%25D0%25B7%25D1%258C_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25A5%25D0%25B0%25D1%2584%25D0%25B0_%25D1%2581_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC_%25D0%25A0%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BD%25D0%25B0">An analogue of</a> the Hough transform for straight lines is the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A0%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BD%25D0%25B0">Radon transform</a> .  It is calculated through the FFT, which gives a performance gain in a situation where there are a lot of points.  In addition, it is possible to apply it to a non-binarized image. <br><br><h5>  Contour filtering </h5><br>  A separate class of filters - filtering boundaries and <a href="http://ru.wikipedia.org/wiki/%25C2%25FB%25E4%25E5%25EB%25E5%25ED%25E8%25E5_%25E3%25F0%25E0%25ED%25E8%25F6">contours</a> .  Outlines are very useful when we want to move from working with an image to working with objects in this image.  When an object is rather complicated, but well distinguished, then often the only way to work with it is to select its contours.  There are a number of algorithms that solve the problem of filtering circuits: <br><ul><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%259A%25D1%258D%25D0%25BD%25D0%25BD%25D0%25B8">Operator kanny</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25BB%25D1%258F">Sobel operator</a> </li><li>  <a href="http://wiki.technicalvision.ru/index.php/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D1%258B_%25D0%259C%25D0%25B0%25D1%2580%25D1%2580%25D0%25B0_%25D0%25B8_%25D0%259B%25D0%25B0%25D0%25BF%25D0%25BB%25D0%25B0%25D1%2581%25D0%25B0">Laplace operator</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D1%258E%25D0%25B8%25D1%2582%25D1%2582">Operator prewitt</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BA%25D1%2580%25D1%2591%25D1%2581%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25A0%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582%25D1%2581%25D0%25B0">Roberts operator</a> </li></ul><br>  The most commonly used is Kenny, who works well and has an implementation in OpenCV (Sobel is also there, but he is less interested in contours). <br><img src="https://habrastorage.org/getpro/habr/post_images/72c/1b1/ec6/72c1b1ec63f3c30867bd7b9745f7e482.jpg" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/a4e/1ca/144/a4e1ca1441026ec7f96395b714a1adc0.jpg" alt="image"><br><br><h5>  Other filters </h5><br>  Above are filters whose modifications help solve 80-90% of problems.  But besides them there are more rare filters used in local problems.  There are dozens of such filters, I will not give them all.  Interesting are iterative filters (for example, the <a href="http://habrahabr.ru/post/155759/">active model of appearance</a> ), as well as a <a href="http://www.myshared.ru/slide/103352/">ridgelet</a> and a transformation <a href="http://fetmag.mrsu.ru/2009-2/pdf/curvelet-irlyanov.pdf">curvelet</a> , which are a fusion of classical wavelet filtering and analysis in the radon transform field.  <a href="http://yudin-niip-rggru.narod.ru/htm/pdf/BeamletsMultiscaleImageAnal.pdf">The beamlet transform</a> works beautifully on the border of the wavelet transform and logical analysis, allowing you to select the contours: <br><img src="https://habrastorage.org/getpro/habr/post_images/19b/6bc/73e/19b6bc73eafb6f9f3556a04beb2513e2.png" alt="image"><br>  But these transformations are very specific and sharpened for rare tasks. <br><br><h4>  Part 2. Logical processing of filtering results </h4><br>  Filtering gives a set of data suitable for processing.  But it is often impossible to simply take and use this data without processing it.  In this section there will be several classical methods that allow you to move from an image to the properties of objects, or to the objects themselves. <br><br><h5>  Morphology </h5><br>  The transition from filtering to logic, in my opinion, are the methods of mathematical morphology ( <a href="http://ru.wikipedia.org/wiki/%25CC%25E0%25F2%25E5%25EC%25E0%25F2%25E8%25F7%25E5%25F1%25EA%25E0%25FF_%25EC%25EE%25F0%25F4%25EE%25EB%25EE%25E3%25E8%25FF">1</a> , <a href="http://habrahabr.ru/post/113626/">2</a> , <a href="http://wiki.technicalvision.ru/index.php/%25D0%259C%25D0%25BE%25D1%2580%25D1%2584%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8_%25D0%25BD%25D0%25B0_%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%25D1%2585">3</a> ).  In fact, these are the simplest operations for building and eroding binary images.  These methods allow you to remove noise from a binary image by increasing or decreasing existing elements.  On the basis of mathematical morphology, there are contouring algorithms, but usually some kind of hybrid or combination algorithms are used. <br><img src="https://habrastorage.org/getpro/habr/post_images/e55/34d/6bf/e5534d6bf4f92bb6dcfab74c740bf210.jpg" alt="image"><br><br><h5>  Contour analysis </h5><br>  In the section on filtering algorithms for obtaining boundaries have already been mentioned.  The resulting bounds are simply converted into contours.  For the Kany algorithm, this happens automatically; for the other algorithms, additional binarization is required.  You can get a contour for a binary algorithm, for example, a <a href="http://wiki.technicalvision.ru/index.php/%25D0%2592%25D1%258B%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B8_%25D0%25BE%25D0%25BF%25D0%25B8%25D1%2581%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2583%25D1%2580%25D0%25BE%25D0%25B2">bug</a> algorithm. <br>  The contour is a unique feature of the object.  Often this allows you to identify the object on the contour.  There is a powerful mathematical tool to do this.  The device is called contour analysis ( <a href="http://habrahabr.ru/post/118486/">1</a> , <a href="http://robocraft.ru/blog/computervision/640.html">2</a> ). <br><img src="https://habrastorage.org/getpro/habr/post_images/254/667/6b9/2546676b92cc3e1e41b07fded672288e.png" alt="image"><br>  To be honest, I never once managed to apply contour analysis in real-world problems.  Too perfect conditions are required.  That border is not there, the noise is too much.  But, if you need to recognize something in ideal conditions, then contour analysis is a great option.  It works very fast, beautiful math and understandable logic. <br><br><h5>  Special points </h5><br>  <a href="http://en.wikipedia.org/wiki/Feature_detection_(computer_vision)">Special points</a> are unique characteristics of an object that allow you to map an object to itself or to similar classes of objects.  There are several dozen ways to select such points.  Some methods highlight specific points in adjacent frames, some through a long period of time and when lighting changes, some allow you to find special points that remain so even when the object turns.  Let's start with the methods that allow you to find special points that are not so stable, but they are quickly calculated, and then we go in increasing complexity: <br>  <b>First grade.</b>  <b>Singular points that are stable for seconds.</b>  Such points are used to lead the object between adjacent frames of video, or to reduce the image from neighboring cameras.  These points include local maxima of the image, <a href="http://en.wikipedia.org/wiki/Corner_detection">angles in the image</a> (the best of the detectors, perhaps, <a href="http://www.intuit.ru/studies/courses/10621/1105/lecture/17983">Haris</a> detector), points at which the dispersion maximums are reached, certain gradients, etc. <br>  <b>Second class.</b>  <b>Special points that are stable when changing lighting and small movements of the object.</b>  Such points serve primarily for learning and the subsequent classification of object types.  For example, a pedestrian classifier or a face classifier is a product of a system built on such points.  Some of the previously mentioned wavelets may be the basis for such points.  For example, Haar primitives, search for glare, search for other specific functions.  These points are points found by the histogram method of directional gradients ( <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%25BD%25D0%25B0%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25B4%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2">HOG</a> ). <br>  <b>Third class.</b>  <b>Stable points.</b>  I know only about two methods that give complete stability and about their modifications.  This is <a href="http://habrahabr.ru/post/103107/">SURF</a> and <a href="http://habrahabr.ru/post/106302/">SIFT</a> .  They allow you to find particular points even when you rotate the image.  The calculation of such points is longer compared to other methods, but for a rather limited time.  Unfortunately, these methods are patented.  Although, in Russia, patent the algorithms nizya, so use for the domestic market. <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/v-869dTqeV0%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhhhqAbijavWATCZzu06uQnBeFUSWQ" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  Part 3. Training </h4><br>  This part of the story will be devoted to methods that do not work directly with the image, but which allow you to make decisions.  These are mainly different methods of machine learning and decision making.  Recently Yandyks laid out a <a href="http://habrahabr.ru/company/yandex/blog/208034/">course</a> on this topic on Habr, there is a very good selection.  Here it is in the text version.  For serious study topics strongly recommend to see them.  Here I will try to identify several basic methods used specifically in pattern recognition. <br>  In 80% of situations, the essence of learning in the recognition problem is as follows: <br>  There is a test sample on which there are several classes of objects.  Let it be the presence / absence of a person in the photo.  For each image there is a set of features that were highlighted by some feature, be it Haar, HOG, SURF, or any wavelet.  The learning algorithm should construct such a model, according to which it will be able to analyze a new image and decide which of the objects is in the image. <br>  How it's done?  Each of the test images is a point in the feature space.  Its coordinates are the weight of each of the features in the image.  Let our signs be: "Presence of eyes", "Presence of nose", "Presence of two hands", "Presence of ears", itd ... All these signs we will highlight with our existing detectors, who are trained in body parts, similar to human  For a person in such a space, the point [1; 1; 1; 1; ..] will be correct.  For the monkey, the point [1; 0; 1; 0 ...] for the horse [1; 0; 0; 0 ...].  The qualifier is trained in a sample of examples.  But not all the photographs stood out hands, others did not have eyes, and on the third, the monkey had a human nose because of a classifier error.  A trained person classifier automatically splits the feature space so as to say: if the first sign is in the range 0.5 &lt;x &lt;1, the second is 0.7 &lt;y &lt;1, etc., then this is a person. <br>  Essentially, the purpose of the classifier is to draw in the feature space the regions characteristic for the objects of classification.  This is how a consistent approximation to the answer for one of the classifiers (AdaBoost) in two-dimensional space will look like: <br><img src="http://img-fotki.yandex.ru/get/6730/6107910.16/0_746ae_ecf49235_M.png" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/8c9/170/ced/8c9170ced44434893558479b0fb621c4.png" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/f73/6a6/7ecf736a6d7b99d851f8f406dddfc973.png" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/01f/89f/a0e01f89f928f26d28dce8868705d902.png" alt="image"><br>  There are so many classifiers.  Each of them works better in some of its task.  The task of selecting a classifier for a specific task is in many ways an art.  Here are <a href="http://download.yandex.ru/company/experience/seminars/l_Object_Localization_in_Photographs.pdf">a</a> few beautiful pictures on the subject. <br><br><h5>  Simple case, one dimensional separation </h5><br>  Let us analyze by example the simplest case of classification, when the space of a sign is one-dimensional, and we need to separate 2 classes.  The situation is more common than can be introduced: for example, when you need to distinguish between two signals, or to compare the pattern with the sample.  Suppose we have a training set.  This results in an image where the X axis is the measure of similarity, and the Y axis is the number of events with such a measure.  When the desired object looks like itself, the left Gaussian is obtained.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When not like - right. </font><font style="vertical-align: inherit;">A value of X = 0.4 divides the samples so that the wrong decision minimizes the likelihood of making any wrong decision. </font><font style="vertical-align: inherit;">The search for such a separator is the task of classification. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/27c/11b/960/27c11b960e46d4c38bbb71e42f32c111.png" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little remark. </font><font style="vertical-align: inherit;">Not always the optimal criterion that minimizes the error will be. </font><font style="vertical-align: inherit;">The next graph is the graph of the real iris recognition system. </font><font style="vertical-align: inherit;">For such a system, the criterion is chosen such as to minimize the probability of a false pass of an unauthorized person to the object. </font><font style="vertical-align: inherit;">This probability is called the ‚Äúfirst kind error‚Äù, ‚Äúfalse alarm probability‚Äù, ‚Äúfalse alarm‚Äù. </font><font style="vertical-align: inherit;">In the English literature "False Access Rate".</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/ce6/d35/fdb/ce6d35fdbec30f6903ca88177ba631b9.gif" alt="image"><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What to do if there are more than two measurements? </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many algorithms. Even a lot. If you want to know in detail about each of them, read the course of Vorontsov, the link to which is given above, and watch the lectures of Yandyks. To say which algorithm is better for which task is often impossible in advance. Here I will try to identify the main ones, which in 90% will help a beginner with the first task and the implementation of which in your programming language you will reliably find on the Internet. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k-means</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="http://ru.wikipedia.org/wiki/K-means"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://habrahabr.ru/post/67078/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://habrahabr.ru/post/146556/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) is one of the simplest learning algorithms. Of course, it is mainly for clustering, but it is also possible to train through it. It works in a situation where groups of objects have a well-spaced center of mass and do not have a large intersection. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AdaBoost</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="http://habrahabr.ru/post/80323/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><a href="http://ru.wikipedia.org/wiki/AdaBoost"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://cmp.felk.cvut.cz/~sochmj1/adaboost_talk.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) AdaBusta is one of the most common classifiers. For example, the Haar cascade is built exactly on it. Usually used when binary classification is needed, but nothing prevents to train for more classes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SVM ( </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25BE%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B2%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3DSVM"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://www.ccas.ru/voron/download/SVM.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://habrahabr.ru/post/105220/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) One of the most powerful classifiers, having many implementations. In principle, on the learning tasks that I encountered, he worked in the same way as Adabust. It is considered fast enough, but its learning is more complicated than that of Adabusta and the choice of the correct core is required. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are also neural networks and regression. But in order to briefly classify them and show how they differ, we need an article much more than this.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">________________________________________________ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope I managed to make a cursory review of the methods used without immersion in math and description. </font><font style="vertical-align: inherit;">Maybe it will help someone. </font><font style="vertical-align: inherit;">Although, of course, the article is incomplete and there is not a word about working with stereo images, nor about the MNC with the Kalman filter, nor about the adaptive Bayesian approach. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you like the article, I will try to make the second part with a selection of examples of how the existing ImageRecognition problems are solved.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And finally </font></font></h4><br>  What to read? <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Once I really liked the book ‚ÄúDigital Image Processing‚Äù by B. Yana, which was written simply and clearly, but at the same time almost all the mathematics was given. Good for getting familiar with existing methods. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) The classic of the genre is R Gonzalez, R. Woods "Digital Image Processing". For some reason she gave me more difficult than the first. Much less mathematics, but more methods and pictures.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) ‚ÄúProcessing and analysis of images in computer vision problems‚Äù - written on the basis of a course taught at one of the departments of PhysTech. A lot of methods and their detailed description. But in my opinion there are two big drawbacks in the book: the book is strongly focused on the software package that is attached to it, in the book too often the description of a simple method turns into a mathematical jungle from which it is difficult to take a block diagram of the method. But the authors have made a convenient site, where almost all the content is </font><a href="http://wiki.technicalvision.ru/"><font style="vertical-align: inherit;">presented</font></a><font style="vertical-align: inherit;"> - </font></font><a href="http://wiki.technicalvision.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki.technicalvision.ru</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) For some reason, it seems to me that a good book that structures and links the picture of the world that occurs during the occupation of Image Recognition and Machine Learning is ‚ÄúOn the Intelligence‚Äù of Jeff Hawkins. </font><font style="vertical-align: inherit;">There are no direct methods, but there are many thoughts to think about where direct image processing methods come from. </font><font style="vertical-align: inherit;">When you read it, you understand that you have already seen the methods of the human brain, but in video processing tasks.</font></font></div><p>Source: <a href="https://habr.com/ru/post/208090/">https://habr.com/ru/post/208090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208078/index.html">Google‚Äôs VP9 video codec has received support from most manufacturers.</a></li>
<li><a href="../208080/index.html">Winamp will not die: there was a buyer on the player</a></li>
<li><a href="../208082/index.html">Do not rely on color when designing interfaces</a></li>
<li><a href="../208086/index.html">NSA is working on creating a quantum computer for hacking any type of encryption (but so far away from success)</a></li>
<li><a href="../208088/index.html">Solomon's Sort</a></li>
<li><a href="../208092/index.html">Learning OpenCV Cascade Haar</a></li>
<li><a href="../208094/index.html">Making a simple level editor based on the Inkscape plugin.</a></li>
<li><a href="../208096/index.html">Disable RC4 encryption in Firefox</a></li>
<li><a href="../208100/index.html">How to choose a name for an IT product and IT company</a></li>
<li><a href="../208104/index.html">Restoring open files but deleted from the linux file system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>