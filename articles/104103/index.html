<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel tasks. The case of "perfect parallelism." Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suggested Solutions in .NET 4 
 This is the second part of an article devoted to parallelizing ideal loops. In the first part , the problems arising f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel tasks. The case of "perfect parallelism." Part 2</h1><div class="post__text post__text-html js-mediator-article"><h3>  Suggested Solutions in .NET 4 </h3><br>  This is the second part of an article devoted to parallelizing ideal loops.  In the <a href="http://habrahabr.ru/blogs/net/104078/" title="Parallel tasks. The case of &quot;perfect parallelism.&quot; Part 1">first part</a> , the problems arising from this and the general approaches to their solution were considered.  In this we will talk about the specific library components provided by .NET 4.0 to support these tasks. <br><br>  The following options are provided for parallelization of ‚Äúideal‚Äù cycles: <br><ul><li>  System.Threading.Tasks.Parallel class with methods For (), ForEach () </li><li>  Parallel LINQ with AsParallel () extension method. </li></ul><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Parallel.For and Parallel.ForEach methods </h4><br>  We start by considering the Parallel class and its methods of looping. <br><br>  The first method we are considering has a signature (this is the base one, one of many overloads): <br><br><blockquote><ol><li> <code><font color="black"><font color="#0600FF">public</font> <font color="#0600FF">static</font> ParallelLoopResult <font color="#0600FF">For</font> <font color="#000000">(</font> <font color="#FF0000">int</font> fromInclusive, <font color="#FF0000">int</font> toExclusive, Action <font color="#008000">&lt;</font> <font color="#FF0000">int</font> <font color="#008000">&gt;</font> body <font color="#000000">)</font> <font color="#008000">;</font></font></code> </li> </ol></blockquote><br><br>  It is in many respects similar to the signatures of our experimental methods from the <a href="http://habrahabr.ru/blogs/net/104078/" title="Parallel tasks. The case of &quot;perfect parallelism.&quot; Part 1">first part of the article</a> , except for the type of the return value. <br><br>  The second ‚Äúin the basic configuration‚Äù looks like: <br><br><blockquote><ol><li>  <font color="#0600FF">public</font> <font color="#0600FF">static</font> ParallelLoopResult <font color="#0600FF">ForEach</font> <font color="#008000">&lt;</font> TSource <font color="#008000">&gt;</font> <font color="#000000">(</font> IEnumerable <font color="#008000">&lt;</font> TSource <font color="#008000">&gt;</font> source, Action <font color="#008000">&lt;</font> TSource <font color="#008000">&gt;</font> body <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  Let's consider what Parallel.For and Parallel.ForEach methods can do. <br><br>  <strong>Exception Handling.</strong>  When an exception occurs in one of the iterations, the new iterations no longer start.  Already started, however, can finish their work, and after they are completed, all exceptions (initial and possible subsequent exceptions in the iterations that were finalized) are aggregated into one exception of type AggregateException and it is thrown away. <br><br>  <strong>Early cycle interruption.</strong>  The corresponding overloads of the For method provide the ability to interrupt execution by calling the Stop or Break methods on the context object (passed to each iteration). <br><br>  The difference between Stop and Break is that Stop signals the need to stop starting new iterations in general, and Break to stop starting new iterations following (in order) after the one in which the Break was caused.  That is, when calling Break at the 5th iteration, it is guaranteed, despite parallelism, that iterations from the 1st to the 4th will still be executed.  And when you call Stop at 5 iterations, if iteration 4 has not yet started, then it will not start. <br><br>  The current iterations that have already been started at the time of the Stop or Break call can check the interrupt status of the cycle, and end prematurely if they learn about the interruption of the entire cycle.  To do this, they can check the relevant properties of the context object: IsStopped and LowestBreakIteration. <br><br>  <strong>Supports data storage at stream level</strong> .  Some method overloads allow you to store intermediate results of calculations in a data warehouse that is local to each stream.  This allows, for example, when aggregating the result, first to aggregate the results of the work of a separate stream, and only then to aggregate them among all the threads that worked.  This eliminates unnecessary synchronization costs during the calculation process. <br><br>  <strong>The ability to configure the level of parallelism</strong> .  You can specify the maximum number of threads to use for execution. <br><br>  <strong>Support call nesting</strong> .  Due to the use of a thread pool, excessive multithreading does not occur both with nested calls to For and ForEach methods, as well as with their parallel execution. <br><br>  <strong>Dynamic change in the number of threads</strong> .  Parallel.For was designed on the basis of time-varying load, and given that some elements of the work may require more calculations than others.  Therefore, the number of threads used may vary during the operation of the method. <br><br>  <strong>Sophisticated thread loading management</strong> .  The method was implemented logic load balancing threads, which takes into account a large number of different factors.  Also, the block size (‚Äúportions of data‚Äù for processing) increases in the process of work, which allows to obtain better load balancing for a small number of iterations (it is assumed that more ‚Äúheavy‚Äù in this case), and lower costs for synchronizing the ‚Äúdistribution of tasks‚Äù with a large number of iterations. <br><br>  <strong>Support cancel the execution of a loop outside of it.</strong>  To do this, use the CancellationTokenSource class.  When starting a cycle, you must pass the Token property to it, and then to request the cancellation of the cycle from the outside, you simply need to call the Cancel () method on the CancellationTokenSource object, which will prevent the start of new iterations of the cycle, and upon completion of all current ones, it will throw an OperationCanceledException.  The current iterations, by the way, can check the status of the cancellation in order to ‚Äúvoluntarily‚Äù end prematurely if they find out that the whole cycle has been canceled. <br><br><h4>  Parallel LINQ </h4><br><br>  Available back in .NET 3.5 as an extension, Parallel LINQ is available in .NET 4.0 right away in System.Core.  The idea of ‚Äã‚Äãusing it is very simple: we add a .AsParallel () call to the chain of LINQ queries, and all subsequent calls in the chain are executed in parallel.  For example: <br><br><blockquote><ol><li>  var doubled <font color="#008000">=</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> <font color="#FF0000">1</font> , <font color="#FF0000">2</font> , <font color="#FF0000">3</font> , <font color="#FF0000">4</font> <font color="#000000">}</font> .  <font color="#0000FF">AsParallel</font> <font color="#000000">(</font> <font color="#000000">)</font> .  <font color="#0000FF">Select</font> <font color="#000000">(</font> i <font color="#008000">=&gt;</font> i <font color="#008000">*</font> <font color="#FF0000">2</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  It may not be obvious that the order of the elements in the resulting collection can be arbitrary, as they are processed in parallel.  To preserve the order of the elements in the collection, we can modify our first fragment like this: <br><br><blockquote><ol><li>  var doubled <font color="#008000">=</font> <font color="#008000">new</font> <font color="#000000">[</font> <font color="#000000">]</font> <font color="#000000">{</font> <font color="#FF0000">1</font> , <font color="#FF0000">2</font> , <font color="#FF0000">3</font> , <font color="#FF0000">4</font> <font color="#000000">}</font> .  <font color="#0000FF">AsParallel</font> <font color="#000000">(</font> <font color="#000000">)</font> .  <font color="#0000FF">AsOrdered</font> <font color="#000000">(</font> <font color="#000000">)</font> .  <font color="#0000FF">Select</font> <font color="#000000">(</font> i <font color="#008000">=&gt;</font> i <font color="#008000">*</font> <font color="#FF0000">2</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  Processing will still take place in parallel, but the aggregation stage (assembling the results from each thread) can take longer, since you will have to wait for the first threads that count the ‚Äúfirst‚Äù elements, take their result, and only then take the result from the threads that read the ‚Äúlast‚Äù items. <br><br>  It is important to realize, when working with PLINQ, that there are additional overhead costs for <ol><li>  distribution of incoming elements of the original enumeration by stream </li><li>  aggregation of calculated elements into the general collection. </li></ol><br>  Moreover, there is no way to get away from the distribution of work among the streams, but you can try to delay the aggregation, or even do without it, if the task is not to get a new collection, but simply to process the elements of the existing one. <br><br>  The AsParallel () method returns not IEnumerable, but ParallelEnumerable, after which all other LINQ methods (Select, Where, etc.) also return the same type.  As long as the ParallelEnumarable is passed in the chain, the results of the calculation of each of the threads are not necessarily aggregated, and a pipeline is built. <br><br>  It is important to understand that when the pipeline breaks, concurrency stops and the data is aggregated into a single resulting collection.  For example, this code does not work in the way that one might mistakenly assume: <br><br><blockquote><ol><li>  List <font color="#008000">&lt;</font> InputData <font color="#008000">&gt;</font> inputData <font color="#008000">=</font> ... <font color="#008000">;</font> </li><li>  <font color="#0600FF">foreach</font> <font color="#000000">(</font> var o <font color="#0600FF">in</font> inputData. <font color="#0000FF">AsParallel</font> <font color="#000000">(</font> <font color="#000000">)</font> . <font color="#0000FF">Select</font> <font color="#000000">(</font> i <font color="#008000">=&gt;</font> <font color="#008000">new</font> OutputData <font color="#000000">(</font> i <font color="#000000">)</font> <font color="#000000">)</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  ProcessOutput <font color="#000000">(</font> o <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li></ol></blockquote><br><br>  In parallel, only the creation of OutputData objects will be performed here, after which all threads will collect these objects and a resulting collection will be formed from them, which will consistently deal with the call to ProcessOutput () for each element. <br><br>  To avoid unnecessary aggregation here, you can use the ParallelEnumarable.ForAll () method: <br><br><blockquote><ol><li>  List <font color="#008000">&lt;</font> InputData <font color="#008000">&gt;</font> inputData <font color="#008000">=</font> ... <font color="#008000">;</font> </li><li>  inputData.  <font color="#0000FF">AsParallel</font> <font color="#000000">(</font> <font color="#000000">)</font> .  <font color="#0000FF">Select</font> <font color="#000000">(</font> i <font color="#008000">=&gt;</font> <font color="#008000">new</font> OutputData <font color="#000000">(</font> i <font color="#000000">)</font> <font color="#000000">)</font> .  <font color="#0000FF">ForAll</font> <font color="#000000">(</font> o <font color="#008000">=&gt;</font> </li><li>  <font color="#000000">{</font> </li><li>  ProcessOutput <font color="#000000">(</font> o <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  In this case, after the ‚Äúnew OutputData (i)‚Äù stage, the ‚ÄúProcessOutput (o)‚Äù stage will also be executed in parallel, without the aggregation stage between them. <br><br>  It should be noted that the Parallel.ForEach () call for ‚ÄúinputData.AsParallel () .Select (i =&gt; new OutputData (i))‚Äù will have the same drawback as the first example with the usual foreach: in Parallel.ForEach () IEnumerable is passed, not ParallelEnumerable - therefore, before passing the collection to Parallel.ForEach (), it will be aggregated.  To avoid this, there is the ParallelEnumerable.ForAll () method, which should be used in this case. <br><br><h4>  Typical problems and errors </h4><br>  Consider possible problems when working with these components. <br><br><h5>  Native code thread safety </h5><br>  First of all, you need to understand that using Parallel.ForEach alone will not make your code thread-safe - you must make sure that the iterations are independent of each other, or, if they are dependent, you must clearly provide thread-safe work with shared resources. <br><br>  Also, when working with Parallel.For, downward loops and loops with non-standard (not equal to one) increment of the counter are not directly supported.  If your original algorithms are written in this way, you need to carefully analyze them, because often non-standard cycles are written just because of the existence of dependencies between iterations (referring to the previous array element calculated in the previous step, etc.). <br><br><h5>  Cycle body sizes </h5><br>  Using the Parallel class implies an overhead of at least <br><ul><li>  to call a delegate to perform the body of the loop, and </li><li>  for synchronization between threads during the distribution of tasks. </li></ul><br><br>  If the body of the cycle is long enough, these additional costs play a small role.  However, if we parallelize something very simple like ‚Äúi = i * i‚Äù, the overhead in this case exceeds the useful work.  To get rid of this disadvantage, it is necessary to ‚Äúenlarge‚Äù the body of the cycle.  It is very easy to do by including not one, but many iterations. <br><br>  You can do this manually by explicitly breaking the input sequence into a set of blocks, and start a parallel loop on this set, and in the body of this parallel loop, each block is already sequentially processed.  However, there will have to decide on the number of these blocks.  You can assign it to the library and use the class specifically created to create subsets of the input sequence: System.Concurrent.Collections.Partitioner. <br><br>  Using it loop <br><br><blockquote><ol><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> i <font color="#008000">&lt;</font> length <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  result <font color="#000000">[</font> i <font color="#000000">]</font> <font color="#008000">=</font> i <font color="#008000">*</font> i <font color="#008000">;</font> </li></ol></blockquote><br><br>  instead of the naive version: <br><br><blockquote><ol><li>  Parallel.  <font color="#0600FF">For</font> <font color="#000000">(</font> from, to, i <font color="#008000">=&gt;</font> </li><li>  <font color="#000000">{</font> </li><li>  result <font color="#000000">[</font> i <font color="#000000">]</font> <font color="#008000">=</font> i <font color="#008000">*</font> i <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  you can effectively parallelize like this: <br><br><blockquote><ol><li>  Parallel.  <font color="#0600FF">ForEach</font> <font color="#000000">(</font> Partitioner. <font color="#0000FF">Create</font> <font color="#000000">(</font> from, to <font color="#000000">)</font> , range <font color="#008000">=&gt;</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> range. <font color="#0000FF">Item1</font> <font color="#008000">;</font> i <font color="#008000">&lt;</font> range. <font color="#0000FF">Item2</font> <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  result <font color="#000000">[</font> i <font color="#000000">]</font> <font color="#008000">=</font> i <font color="#008000">*</font> i <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  Partitioner.Create (from, to) creates the same set of blocks, in which we pass in parallel, inside the loop body, sequentially processing each block.  Thus, we provide a parallel body with a long body, and distribute overhead costs for more useful work. <br><br><h5>  Nested loop processing </h5><br>  When processing nested loops, the question arises, how deep is the parallelization.  Take an example of processing a rectangular image: <br><br><blockquote><ol><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> y <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> y <font color="#008000">&lt;</font> screenHeight <font color="#008000">;</font> y <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> stride <font color="#008000">=</font> y <font color="#008000">*</font> screenWidth <font color="#008000">;</font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> x <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> x <font color="#008000">&lt;</font> screenWidth <font color="#008000">;</font> x <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  rgb <font color="#000000">[</font> x <font color="#008000">+</font> stride <font color="#000000">]</font> <font color="#008000">=</font> calcColor <font color="#000000">(</font> x, y <font color="#000000">)</font> <font color="#008000">;</font>  <font color="#008080"><i>// calculate color</i></font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#000000">}</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  You can replace only the outer loop with a call to Paralllel.For, or both.  If you make both cycles parallel, won't the body be too small?  If we keep the internal one consistent, do we precisely load all our cores with work? <br><br>  The answer to these questions can only give performance testing.  Probably, if the color calculations are not too complicated, it is worthwhile to leave the inner loop consistent.  But if we work with a wide but low image, it is quite possible that parallelization of the outer loop alone will not load all the processor cores. <br><br>  An alternative way is to expand two nested loops into one, and parallelize it already: <br><br><blockquote><ol><li>  <font color="#FF0000">int</font> totalPixels <font color="#008000">=</font> screenHeight <font color="#008000">*</font> screenWidth <font color="#008000">;</font> </li><li>  Parallel.  <font color="#0600FF">For</font> <font color="#000000">(</font> <font color="#FF0000">0</font> , totalPixels, i <font color="#008000">=&gt;</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> y <font color="#008000">=</font> i <font color="#008000">/</font> screenWidth, x <font color="#008000">=</font> i <font color="#008000">%</font> screenWidth <font color="#008000">;</font> </li><li>  rgb <font color="#000000">[</font> i <font color="#000000">]</font> <font color="#008000">=</font> calcColor <font color="#000000">(</font> x, y <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  If calcColor () is too simple, then in order to enlarge the body of the cycle, you can use the Partitioner class, as in the previous example: <br><br><blockquote><ol><li>  <font color="#FF0000">int</font> totalPixels <font color="#008000">=</font> screenHeight <font color="#008000">*</font> screenWidth <font color="#008000">;</font> </li><li>  Parallel.  <font color="#0600FF">ForEach</font> <font color="#000000">(</font> Partitioner. <font color="#0000FF">Create</font> <font color="#000000">(</font> <font color="#FF0000">0</font> , totalPixels <font color="#000000">)</font> , range <font color="#008000">=&gt;</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> range. <font color="#0000FF">Item1</font> <font color="#008000">;</font> i <font color="#008000">&lt;</font> range. <font color="#0000FF">Item2</font> <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> y <font color="#008000">=</font> i <font color="#008000">/</font> screenWidth, x <font color="#008000">=</font> i <font color="#008000">%</font> screenWidth <font color="#008000">;</font> </li><li>  rgb <font color="#000000">[</font> i <font color="#000000">]</font> <font color="#008000">=</font> calcColor <font color="#000000">(</font> x, y <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br><h5>  IList non-safe implementations </h5><br>  Both mechanisms ‚Äî Parallel.ForEach and PLINQ ‚Äî accept IEnumerable as input, but try to find the fastest interface for working with it for the collection given to them.  In particular, the IList interface is better suited for parallelization than IEnumerable, since it has an indexer for random access to any element.  Therefore, if an IList is defined for the transferred collection, then work with it occurs through this interface.  This reduces synchronization costs, <b>but the library code relies on the thread-safe implementation of the indexer</b> . <br><br>  If the used collection does not provide a thread-safe indexer, which can often be the case if the elements are stored in a complex form for indexing, or are loaded in general lazily, then you need to explicitly tell the system that it does not need to use IList, but restrict IEnumerable. <br><br>  To do this, fit two options.  The first is to create for the System.Collections.Concurrent.Partitioner collection: <br><br><blockquote><ol><li>  <font color="#008080"><i>// IList &lt;T&gt; can be used here if it is supported by the collection</i></font> </li><li>  IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;</font> source <font color="#008000">=</font> ... <font color="#008000">;</font> </li><li>  Parallel.  <font color="#0600FF">ForEach</font> <font color="#000000">(</font> source, item <font color="#008000">=&gt;</font> <font color="#000000">{</font> <font color="#008080"><i>/*...*/</i></font> <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li></li><li>  <font color="#008080"><i>// And here IEnumerable &lt;T&gt; is guaranteed to be used</i></font> </li><li>  IEnumerable <font color="#008000">&lt;</font> T <font color="#008000">&gt;</font> source <font color="#008000">=</font> ... <font color="#008000">;</font> </li><li>  Parallel.  <font color="#0600FF">ForEach</font> <font color="#000000">(</font> Partitioner. <font color="#0000FF">Create</font> <font color="#000000">(</font> source <font color="#000000">)</font> , item <font color="#008000">=&gt;</font> <font color="#000000">{</font> <font color="#008080"><i>/*...*/</i></font> <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  The second method is obvious, and familiar in the usual LINQ: just call for the collection ".Select (item =&gt; item)".  It is suitable for both Parallel.For and PLINQ: <br><br><blockquote><ol><li>  <font color="#008080"><i>// IEnumerable &lt;T&gt; will also be used here</i></font> </li><li>  source.  <font color="#0000FF">Select</font> <font color="#000000">(</font> i <font color="#008000">=&gt;</font> i <font color="#000000">)</font> .  <font color="#0000FF">AsParallel</font> <font color="#000000">(</font> <font color="#000000">)</font> .  <font color="#0000FF">Select</font> <font color="#000000">(</font> i <font color="#008000">=&gt;</font> <font color="#000000">{</font> <font color="#008080"><i>/*...*/</i></font> <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br><h5>  Presence of affinity for the thread (thread affinity) in the original collection </h5><br>  When Parallel.ForEach and PLINQ are working, each of the worker threads itself calls the MoveNext () from the original collection.  If the collection is such that access to it is possible only from one specific stream (possesses "affinity to the stream"), as, for example, happens when working with UI components in Windows Forms or WPF, then you cannot use these mechanisms directly for it. <br><br>  To provide parallel processing of such a collection, you need to use the Producer-Consumer template, the main ‚Äúbrick‚Äù for which in .NET 4.0 is the BlockingCollection class, which I will write about later on separately.  You can read more about it in English in the ‚ÄúProducer-Consumer‚Äù section on page 53 of the original document. <br><br>  PS This article is written under the impression of the book " <a href="http://www.microsoft.com/downloads/en/details.aspx%3Fdisplaylang%3Den%26FamilyID%3D86b3d32b-ad26-4bb8-a3ae-c1637026c3ee" title="Original document in English">PATTERNS OF PARALLEL PROGRAMMING: UNDERSTANDING AND APPLYING PARALLEL PATTERNS WITH THE .NET FRAMEWORK 4 AND VISUAL C #</a> " and can be considered its free translation with recycling. <br><br><h4>  Conclusion </h4><br>  I hope this excursion will help you make less of your own mistakes when paralleling your code.  But still, successful debugging, and with the holiday :) <br><br><h4>  For the future </h4><br>  I can continue the topic of parallelism in the 4 framework, if there is interest.  It can be about: <br><ul><li>  Task class and infrastructure for parallel computing with dependencies </li><li>  new thread-safe collections, </li><li>  laziness and concurrency </li><li>  shared data and sync. </li></ul><br>  Write what is interesting to this extent :) </div><p>Source: <a href="https://habr.com/ru/post/104103/">https://habr.com/ru/post/104103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../104098/index.html">All solutions to the task for the Day of the Programmer</a></li>
<li><a href="../104099/index.html">Important changes in Oracle Database Patch Sets from 11.2.0.2</a></li>
<li><a href="../104100/index.html">Switch from Windows Mobile to Android. Application list</a></li>
<li><a href="../104101/index.html">Happy Programmer's Day</a></li>
<li><a href="../104102/index.html">Digital lock on the room</a></li>
<li><a href="../104104/index.html">Compilation. 10: compile in ELF</a></li>
<li><a href="../104106/index.html">Limb framework version 2010.1 RC2</a></li>
<li><a href="../104108/index.html">Boris Bobrovnikov: IT business today by itself</a></li>
<li><a href="../104109/index.html">The art of programming under Unix (and not only). Part six, the ‚Äúcode-saving rule‚Äù</a></li>
<li><a href="../104114/index.html">Photo review of HP Proliant DL980 G7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>