<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We collect Mini Bedlam Cube</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I wrote the program solving the ‚Äúpentamino‚Äù puzzle as one of my first programs. It was a long time ago, the program somehow worked, I did not have tim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We collect Mini Bedlam Cube</h1><div class="post__text post__text-html js-mediator-article">  I wrote the program solving the ‚Äúpentamino‚Äù puzzle as one of my first programs.  It was a long time ago, the program somehow worked, I did not have time to find all the options ... In general, I wrote and forgot. <br><br>  The other day, putting things in order on the table, I decided that it was time to remove the puzzle ‚ÄúMini Bedlam Cube‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74c/189/f9a/74c189f9a7e47b883c27d7b25db8d129.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And before that it would be nice to collect it.  The puzzle consists of 13 figures - 12 are made up of 5 cubes, one of four;  six figures are symmetrical, three of them are flat.  Figures need to be placed in a 4x4x4 box.  I must say that from time to time I remembered these dice, I tried to cope with them, but nothing happened.  Therefore, an idea arose - to write a program that solves a puzzle, and to spend as little effort as possible, and then to solve the old question: what is more profitable - to sort out shapes or cells, and in what order. <br><br><a name="habracut"></a><br><br><h2>  Data presentation and simplest search </h2><br><br>  Since the number of cells in the box quite accidentally turned out to be no more than the number of bits in one of the representations of integers, it was this representation that was chosen as the main one: both the current state of the field and each position of each figure is stored as an unsigned __int64 bitmask (for C # - ulong).  The number of orientations of each figure is no more than 24, the number of positions for this orientation is no more than 27. Total, maybe no more than 648 positions of each figure we can easily afford to keep them in memory.  It is only necessary to get these provisions somehow. <br><br>  It would be possible to explicitly specify 24 orientations of the cube, indicating the order of the axes and their direction, but this is a long time.  It is easier to do this: choose two generators in the cube rotation group (one, unfortunately, cannot be found), and apply them to one state until the results stabilize.  I chose the transformations (x, y, z) -&gt; (y, z, x) and (x, y, z) -&gt; (-x, z, y). <br>  Such code turned out: <br><pre><code class="hljs vala">typedef unsigned __int64 <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> XLOW=<span class="hljs-number"><span class="hljs-number">0x1111111111111111</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> YLOW=<span class="hljs-number"><span class="hljs-number">0xF000F000F000F</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> ZLOW=<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> XHIGH=<span class="hljs-number"><span class="hljs-number">0x8888888888888888</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> YHIGH=<span class="hljs-number"><span class="hljs-number">0xF000F000F000F000</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> ZHIGH=<span class="hljs-number"><span class="hljs-number">0xFFFF000000000000</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Fig{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NF; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> *Arr; Fig(){ Arr=<span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Init(<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> fig0); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Init(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nf,<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> *arr); ~Fig(){ delete Arr; } }; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> Turn(<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> v,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rt){ <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> res=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>;a&lt;<span class="hljs-number"><span class="hljs-number">64</span></span>;a++){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=rt==<span class="hljs-number"><span class="hljs-number">0</span></span> ? (a&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>)|((a&amp;<span class="hljs-number"><span class="hljs-number">3</span></span>)&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>) : (~a&amp;<span class="hljs-number"><span class="hljs-number">3</span></span>)|((a&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">12</span></span>)|((a&lt;&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">48</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((v&gt;&gt;a)&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>) res|=<span class="hljs-number"><span class="hljs-number">1</span></span>LL&lt;&lt;b; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rt) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((res&amp;XLOW)==<span class="hljs-number"><span class="hljs-number">0</span></span>) res&gt;&gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> arr0[<span class="hljs-number"><span class="hljs-number">648</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Fig::Init(<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> fig0){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p=<span class="hljs-number"><span class="hljs-number">0</span></span>,q=<span class="hljs-number"><span class="hljs-number">1</span></span>; arr0[<span class="hljs-number"><span class="hljs-number">0</span></span>]=fig0; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(p&lt;q){ <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> a=arr0[p++]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u=<span class="hljs-number"><span class="hljs-number">0</span></span>;u&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>;u++){ <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> b=Turn(a,u); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;q;i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(arr0[i]==b) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i==q) arr0[q++]=b; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(p=<span class="hljs-number"><span class="hljs-number">0</span></span>;p&lt;q;p++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((arr0[p]&amp;XHIGH)==<span class="hljs-number"><span class="hljs-number">0</span></span>) arr0[q++]=arr0[p]&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(p=<span class="hljs-number"><span class="hljs-number">0</span></span>;p&lt;q;p++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((arr0[p]&amp;YHIGH)==<span class="hljs-number"><span class="hljs-number">0</span></span>) arr0[q++]=arr0[p]&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(p=<span class="hljs-number"><span class="hljs-number">0</span></span>;p&lt;q;p++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((arr0[p]&amp;ZHIGH)==<span class="hljs-number"><span class="hljs-number">0</span></span>) arr0[q++]=arr0[p]&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; Init(q,arr0); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Fig::Init(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q,<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> *arr){ NF=q; Arr=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>[q]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p=<span class="hljs-number"><span class="hljs-number">0</span></span>;p&lt;q;p++) Arr[p]=arr[p]; }</code> </pre> <br>  The Turn () function performs one of two turns.  Constants XHIGH, XLOW, etc.  correspond to the faces of the cube, and allow you to determine whether you can move the shape in one direction or another.  Initializing the entire set of shapes now looks completely simple: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> Cross[<span class="hljs-number"><span class="hljs-number">2</span></span>]={<span class="hljs-number"><span class="hljs-number">0x4E40000000000000</span></span>LL,<span class="hljs-number"><span class="hljs-number">0x4E4000000000</span></span>LL}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NFig=<span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> Figs0[NFig]={<span class="hljs-number"><span class="hljs-number">0x4E4</span></span>,<span class="hljs-number"><span class="hljs-number">0x136</span></span>,<span class="hljs-number"><span class="hljs-number">0x263</span></span>,<span class="hljs-number"><span class="hljs-number">0x10027</span></span>,<span class="hljs-number"><span class="hljs-number">0x20027</span></span>,<span class="hljs-number"><span class="hljs-number">0x20063</span></span>,<span class="hljs-number"><span class="hljs-number">0x10063</span></span>,<span class="hljs-number"><span class="hljs-number">0x30062</span></span>,<span class="hljs-number"><span class="hljs-number">0x10047</span></span>, <span class="hljs-number"><span class="hljs-number">0x100017</span></span>,<span class="hljs-number"><span class="hljs-number">0x10017</span></span>,<span class="hljs-number"><span class="hljs-number">0x20072</span></span>,<span class="hljs-number"><span class="hljs-number">0x10031</span></span>}; Fig Figs[NFig]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FState[NFig]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitFigs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ Figs[<span class="hljs-number"><span class="hljs-number">0</span></span>].Init(<span class="hljs-number"><span class="hljs-number">2</span></span>,Cross); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>;i&lt;NFig;i++){ Figs[i].Init(Figs0[i]); } }</code> </pre><br><br>  Here I consider that the cross can occupy only two essentially different positions.  This ensures that all solutions found in the future will be different. <br><br>  We will look for solutions in depth.  At each step, we can either choose some cell and sort through all the free shapes with which it can be closed, or vice versa - choose some shape and place it on the field in all possible ways.  In addition, we can check whether there is a cell that can no longer be closed or a figure that cannot be placed at all - in both cases the analysis of the branch can be stopped.  The complexity of the algorithm depends on which strategy we choose and whether we will check the situations for impossibility. <br><br>  In the simplest version - iteration over the figures in a fixed order - the search for solutions is written in 20 lines: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Solve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n==NFig){ NSolve++; Print(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Fig &amp;F=Figs[n]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;F.NF;i++){ <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> s=F.Arr[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((s&amp;x)==<span class="hljs-number"><span class="hljs-number">0</span></span>){ FState[n]=i; Solve(n+<span class="hljs-number"><span class="hljs-number">1</span></span>,x|s); FState[n]=<span class="hljs-number"><span class="hljs-number">-1</span></span>; } } NBack++; }</code> </pre><br><br>  The positions of the figures are saved in the FState array, and the Print () function can easily print the solution found. <br><br><h2>  Results and optimization </h2><br><br>  Total - the program in 110 lines turned out. <br><br>  The program found the first solution in a couple of seconds, but then thought about it.  The ‚Äú19186 Solutions‚Äù is written on the box, and I, of course, wanted to find them all (and at the same time to check whether the authors considered it right).  Printing statistics showed the following: <br><br>  The first 500 million calls to Solve ran for 295 seconds, and only 44 solutions were found.  This gives 1.7 million calls per second, and 6.7 seconds for one solution.  Approximate working time for finding all solutions is 36 hours. <br><br>  Too much. <br><br>  The first optimization that comes to mind is to check whether there is an isolated empty cell on the field, and if there is, not to consider this situation further.  The check turned out to be quite simple: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HaveIsolPoint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> y=((x&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>)|XHIGH)&amp;((x&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>)|XLOW)&amp; ((x&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>)|YHIGH)&amp;((x&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)|YLOW)&amp; ((x&gt;&gt;<span class="hljs-number"><span class="hljs-number">16</span></span>)|ZHIGH)&amp;((x&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>)|ZLOW); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (~x&amp;y)!=<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  After its inclusion in Solve, the result was an order of magnitude better: 1.9 million calls per second and about 1.8 solutions per second!  You can meet at 3 o'clock.  It was also possible to try to look for isolated areas of 2 and 3 cells, but here it is difficult to cope with the morphology, we need a full three-dimensional fill. <br><br>  The next attempt is to search for a cell that is closed by the smallest possible number of methods, and a search through these methods.  The Solve function began to work about 20 times slower, but the overall solution search speed remained <br><br>  former - 1.8 solutions per second. <br><br>  In order not to waste time searching for the optimal empty cell, I decided to sort through them in order.  Obviously, if the cells 0..N-1 are already filled, and the cell N is empty, then this cell can be filled only with those positions of the figures to which the cell N belongs, and at the same time is the minimum number of all cells of the figure.  So, sorting out the figures according to the number of the minimum cell, you can significantly reduce the search. <br><br>  The code is as follows (only changed functions are shown): <br><br><pre> <code class="hljs vala"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Fig{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NF; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> *Arr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Ind[<span class="hljs-number"><span class="hljs-number">65</span></span>]; Fig(){ Arr=<span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Init(<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> fig0); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Init(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nf,<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> *arr); ~Fig(){ delete Arr; } }; extern <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i64cmp(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *a,<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *b){ <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> A=*(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>*)a,B=*(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>*)b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A&lt;B ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : A==B ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Fig::Init(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q,<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> *arr){ NF=q; Arr=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>[q]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p=<span class="hljs-number"><span class="hljs-number">0</span></span>;p&lt;q;p++) Arr[p]=CVT(arr[p]); qsort(Arr,q,sizeof(<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>),i64cmp); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p=<span class="hljs-number"><span class="hljs-number">0</span></span>;p&lt;q;p++){ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(Arr[p]&amp;(<span class="hljs-number"><span class="hljs-number">-1</span></span>LL&lt;&lt;j)) Ind[j++]=p; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(j&lt;=<span class="hljs-number"><span class="hljs-number">64</span></span>) Ind[j++]=q; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Solve(<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> x){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mb=<span class="hljs-number"><span class="hljs-number">63</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(mb&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((x&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; x&gt;&gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>; mb--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mb&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ NSolve++; Print(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f=<span class="hljs-number"><span class="hljs-number">0</span></span>;f&lt;NFig;f++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(FState[f]&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ Fig &amp;F=Figs[f]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r1=F.Ind[mb],r2=F.Ind[mb+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u=r1;u&lt;r2;u++){ <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> s=F.Arr[u]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((x&amp;s)==<span class="hljs-number"><span class="hljs-number">0</span></span>){ FState[f]=u; Solve(x|s,mb,z); } } FState[f]=<span class="hljs-number"><span class="hljs-number">-1</span></span>; } NBack++; }</code> </pre><br><br>  Surprisingly, this option turned out to be more than 50 times faster than the previous one - it finds 95 solutions per second, and a complete bust of the entire puzzle occurs in 203 seconds.  The cause has not yet been understood.  Any attempt to change the iteration order results in an increase in the number of calls to Solve ().  But on the other hand, time can be reduced by half if we look for a free cell, starting with the one found last time: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Solve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mb,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(z!=<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((x&amp;z)==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; z&gt;&gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>; mb--; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mb&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ NSolve++; Print(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f=<span class="hljs-number"><span class="hljs-number">0</span></span>;f&lt;NFig;f++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(FState[f]&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ Fig &amp;F=Figs[f]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r1=F.Ind[mb],r2=F.Ind[mb+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> *aa=F.Arr+r1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u=r1;u&lt;r2;u++){ <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> s=*aa++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((x&amp;s)==<span class="hljs-number"><span class="hljs-number">0</span></span>){ FState[f]=u; Solve(x|s,mb,z); } } FState[f]=<span class="hljs-number"><span class="hljs-number">-1</span></span>; } NBack++; }</code> </pre><br><br>  The total running time is 102 seconds, approximately 1250 times shorter than in the first considered variant.  At the same time, the program was lengthened slightly: about 130 lines for everything. <br><br><h2>  Open questions </h2><br><br>  The first question is technical.  There is a stream of 64-bit numbers in the amount of from 10 to 10,000 pieces.  In each number no more than 5 raised bits.  It is required to determine which bit is raised in the greatest number of these numbers.  How to do it most effectively? <br><br>  The second question is rather philosophical.  Why is the most effective filling of cells exactly in rows, then in layers?  I tried to fill the vertices, then the edges ... The result was several orders of magnitude worse than in the case of the lexicographic order.  What could be wrong here? </div><p>Source: <a href="https://habr.com/ru/post/114457/">https://habr.com/ru/post/114457/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114450/index.html">Assessing the harmfulness of files using sandboxes, Part 2. Analysis offline</a></li>
<li><a href="../114452/index.html">Algorithms for image contour selection</a></li>
<li><a href="../114453/index.html">Belarus faces 38 years in prison for setting up CallService.biz</a></li>
<li><a href="../114454/index.html">Initializr - HTML5 based project generator</a></li>
<li><a href="../114456/index.html">Thunderbolt - like a bolt from the blue</a></li>
<li><a href="../114459/index.html">Little coders</a></li>
<li><a href="../114460/index.html">What do people do to make the computer faster</a></li>
<li><a href="../114463/index.html">Yahoo will close the service MyBlogLog</a></li>
<li><a href="../114464/index.html">Wacom Intuos3: eliminate pen play</a></li>
<li><a href="../114465/index.html">Google launched recipe search</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>