<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code generation during application operation: real examples and techniques</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Code generation in runtime is a very powerful and well-studied technique, but many developers are still reluctant to use it. Usually the study of Expr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code generation during application operation: real examples and techniques</h1><div class="post__text post__text-html js-mediator-article"><p>  Code generation in runtime is a very powerful and well-studied technique, but many developers are still reluctant to use it.  Usually the study of Expression Trees begins with some simple example of how to create a predicate (filter) or a mathematical expression.  But not a Expression Trees single .NET developer is alive.  Most recently, it was possible to generate code using the compiler itself ‚Äî this is done using the Roslyn / CodeAnalisys library APIs, which, among other things, also provide parsing, crawling, and source generation. </p><br><p>  This article is based on the Raffaele Rialdi report (Twitter: <a href="https://twitter.com/raffaeler">@raffaeler</a> ) at the DotNext 2017 Moscow conference.  Together with Raphael, we will analyze the real ways of using code generation.  In some cases, they allow to greatly improve the performance of the application, which in turn leads us to a dilemma - if the generated code is so useful and we are going to use it often, how can we debug this code?  This is one of the fundamental questions that arise in real projects. </p><br><p>  Rafael is a practicing architect, consultant and speaker with MVP in the Developer Security category since 2003, which right now has been involved in enterprise project backends, specializing in code generation and cross-platform development for C # and C ++. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/j0qGQruRX1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><p>  What is code generation?  Suppose you need to demonstrate performance.  If you just show a benchmark - it would be a kind of trick, a cunning trick.  Articles and reports should avoid showing benchmarks - not because it is dangerous for the author, but because the benchmark demonstrates only one scenario, and it is hardly useful to all readers.  The reader is forced to try the proposed technologies and decide whether or not they are suitable for his particular scenarios.  Therefore, do not exaggerate the value of benchmarks.  For myself, I make them, they show decent results. </p><br><p>  We know that a reflection program will by definition be slow.  She needs to download the <a href="https://www.ecma-international.org/publications/standards/Ecma-335.htm">ECMA-335</a> metadata and interpret it.  They are a very compact set of binary data, their reading is quite complicated.  They should be compact because they should not take up too much memory after assembly.  After these artifacts are deployed, performance is unsatisfactory because we are dealing with a very low-level API.  By the way, reflection can be avoided by downloading all these artifacts directly from the assemblies.  I will not speak about this in today's report, but, if you are interested, I have already used this method to avoid constant loading and assembly in memory;  you can free up memory from everything except type information. </p><br><p>  When exactly should the code be generated?  On that part of the application life cycle, when there is enough information to simplify the algorithm.  It is, for example, about information that can be obtained from the user interface for a filter that would reduce the number of records obtained from the database.  Or information about the types loaded in the plugin.  It is extremely undesirable to spend time on creating with the help of reflection a general algorithm that would take into account all possible options.  Unfortunately, developers have a tendency to try to make the solutions they develop as general as possible, working in all possible and impossible cases.  For our programming mind, this is a natural train of thought.  I suggest exactly the opposite approach: patiently wait until there is enough information to generate the most concise code. </p><br><p>  In which cases it may be necessary to generate code?  For example, when using LINQ predicates.  Predicate builders have been available for a long time.  Or using formulas from, say, Excel.  Either when loading types from a plugin, or using Reactive Extensions.  Which of you is familiar with Reactive Extensions?  This is a great library that allows you to create data streams and use expressions that can filter groups and change this data.  I will show many of these examples to demonstrate the possibilities of reflection. </p><br><p><img src="https://habrastorage.org/webt/uw/sw/pk/uwswpkbjrvm9ifkxffphwrdflto.png"><br></p><br><p> Let's start with Expression in C #.  The screen shows a simple example of code in which a call to <code>Console.WriteLine</code> generated.  Perhaps someone will ask - why use reflection if you have just pointed out the disadvantages of using reflection?  The answer is not to abandon reflection in general, but to remove it from the most used sections of the code.  You need to find a point in time at which, using reflection, you can extract the required amount of data, generate code and, for example, use delegation within the loop, so as not to wait until the code is executed. </p><br><p>  In the code, I start by getting an exact <code>WriteLine</code> overload, then I create a parameter that will later become an input message.  After that, I create the equivalent of the <code>Call</code> method.  In a call to <code>Expression.Call(null, methodInfo, message)</code> , <code>null</code> denotes a static method ( <code>WriteLine</code> is a static method).  In addition, this call also requires arguments with information about the method, and with the message. </p><br><p>  After this is created lambda.  It's very simple, you need to specify the parameters and the body of the lambda.  A very useful <code>.Compile()</code> method is called on an already created lambda.  It is good in that it directly and in a very simple way creates instruction in memory.  There is no source code, there is nothing that would need to be processed in the ways described in the "Dragon Book".  There is no first stage of compilation, that is, a long and complex analysis of the text.  It is not needed, because in the case of Expression, we already know that it is syntactically correct.  It is very important.  That is why the expression tree is so bulky, it has an extremely unpleasant strict typification.  If you have once tried to make several expressions with each other, you know what a jerk it is.  But having a formed expression, it can really be compiled.  The compiler simply takes the nodes of the tree (that is, certain expressions), and creates the corresponding node for the code we want to call.  Ultimately, we form a delegate, that is, the fastest available means for executing code. </p><br><p><img src="https://habrastorage.org/webt/b0/yb/kg/b0ybkghyt3dz-kwtodli2o1kc6w.png"><br></p><br><p>  I will show an example in which the predicate will be created.  A very simple function that takes an integer as an input and returns a boolean value.  Let's look at its code.  For the first input value, a parameter is created there: <code>Expression.Parameter(typeof(int), "x")</code> .  One of the input arguments of this method is <code>"x"</code> , do not pay attention to it, it is needed only for debugging.  The variable <code>left</code> denotes the left part of the expression <code>x &gt; -10</code> , <code>right</code> - the right.  From these two variables, a binary comparison expression is created.  Finally, the <code>Lambda</code> expression is returned.  In this case, this is preferable to returning the delegate, since, if necessary, it will be possible to make changes to it.  To do this, you can use the Visitor pattern, which enumerates all the nodes within the expression, and changes it in a very precise way.  No work with the text is needed, the transition to the necessary node occurs immediately. </p><br><p><img src="https://habrastorage.org/webt/jl/uv/0n/jluv0nq3aozmx0v_ajjn8n4tslk.png"><br></p><br><p>  I will give an example in which it is necessary to attend some challenge.  Suppose there is a retrieval of predicates from the <code>where</code> node, since the code is written in LINQ.  Having the necessary Expression, you can write Visitor to it.  And you can find this Expression, because <code>where</code> is a call to an extension method.  The first <code>where</code> parameter is <code>IQueryable&lt;T&gt;</code> , and returns a boolean value.  So we know exactly what form we need.  If you need to add something to this Expression, you can do it at the place where the dots are written on the screen. </p><br><p><img src="https://habrastorage.org/webt/sm/sn/qs/smsnqs8ebupvz6evi3oye3mrz80.png"><br></p><br><p>  In order not to get bored, let's move on to the demonstrations.  Initially, I did not want to write a tool for parsing, because it‚Äôs boring, such a program usually turns out slow, and there are libraries that perform this task better than self-written code.  I needed something small and easily changeable.  And when writing parsing tools you come to the fact that you need to write grammar, you have to use a lot of libraries.  In addition, I wanted to write a tool in such a way that the nodes created after the analysis were similar to what Expressions actually express.  In the end, I came to represent, for example, the expression <code>x + y</code> (which you see in the code) in the form of a text, and then recognize it. </p><br><p><img src="https://habrastorage.org/webt/8q/d0/up/8qd0upjlthgg9s4rc6m84vde2j4.png"><br></p><br><p>  That is, I tried to express the parameters manually.  I did it for simplicity, and perhaps this can be avoided.  At the very least, it is important to specify the types, since Expression cannot use the first stage of compilation.  For example, automatic type conversion or implicit type conversion is not available, <code>integer</code> to <code>double</code> conversion is not available.  All this has to be done manually. </p><br><p>  If you run the code that you see on the screen in the debugger, it will return an Expression.  Lambda is presented in the Visual Studio debugger in a rather strange way, but that's okay.  It looks difficult, but in the end, it's just <code>x + y</code> , you can live with it. </p><br><p><img src="https://habrastorage.org/webt/7e/-e/wy/7e-ewy_upysydy_mesyr31xxqyq.png"><br></p><br><p>  Let's see how you can translate the <code>SUM()</code> function written by me in text.  The text visualizer shows us the variable <code>e</code> , which currently contains the result of the translation.  You can see that I defined <code>FunctionsHelper</code> with a predefined function, just like Excel does.  Such applications should predetermine a sort of dictionary of functions.  All this is quite simple. </p><br><p><img src="https://habrastorage.org/webt/fu/kz/fa/fukzfatsiig3svyxp1v6w2fm4ao.png"><br></p><br><p>  Let's try to go a little further in the code.  There is a <code>GetFilter()</code> function. </p><br><p><img src="https://habrastorage.org/webt/aq/6p/z3/aq6pz3krsqupgr-m9qmtwuicdzc.png"><br></p><br><p>  As you can see, it is lambda.  Usually in such cases, it returns <code>Func&lt;int, bool&gt;</code> and nothing else.  But the compiler has a special feature, which allows, in the absence of square brackets in the function body, to return <code>Expression&lt;Func&lt;int, bool&gt;&gt;</code> .  That is, an Expression is automatically created for this view.  This is very convenient because it can still be changed.  If you want to remove the number and replace it with something else, you can simply write Visitor to express it and make all the necessary changes with it. </p><br><p><img src="https://habrastorage.org/webt/g0/-9/ep/g0-9ep6y3mjg832jsp1lvbcwzls.png"><br></p><br><p>  Let's look at the second demonstration.  In it, from the very beginning, we have the <code>Expression&lt;Func&lt;int, bool&gt;&gt; predicate</code> . </p><br><p>  I want to make an injection into it that would output to the command line.  I pass predicates and two lambdas to the injector and, when receiving the value of <code>x</code> indicate to output <code>{x} =&gt; YES</code> or <code>{x} =&gt; NO</code> each time.  If we look at how the <code>injected</code> variable <code>injected</code> after the application starts, we will see a function with the <code>If</code> operator, it has been changed quite a lot compared to its initial value. </p><br><p><img src="https://habrastorage.org/webt/jp/wl/j-/jpwlj-b_rlymo6rljnvelzntqu8.png"><br></p><br><p>  So, here an integer is fed into the input, <code>If</code> is injected, <code>YES</code> or <code>NO</code> is output to the console depending on the value, and finally the value returned by the expression is returned.  This kind of code changes have already been put into practice, and they are very powerful. </p><br><p>  There is a problem that you probably already noticed - the visualizer, in which I showed you the generated code so far, presents information in a rather strange form.  Programming with expressions gives certain advantages, but from the point of view of the developer, the code is ‚Äúdirty‚Äù. </p><br><p>  Let's return to the demonstration.  I have already spoken about deferred execution: until the enumeration of numbers is completed, the following code will not be executed.  If we reach <code>toList</code> right now, we will get both the list and <code>Console.WriteLine</code> for them, which in this case will be executed automatically. </p><br><p><img src="https://habrastorage.org/webt/a4/mk/9r/a4mk9r-nlzcffxolyohyzryjick.png"><br></p><br><p><img src="https://habrastorage.org/webt/uw/wr/t8/uwwrt89qhezaz9ihwr1wvikxhle.png"><br></p><br><p>  It all looks good, but I want to try something more complicated.  The following example came to me in a dream.  I want to create a lambda, which, when compiled, converts the data in a dictionary (possibly JSON) in a specific order.  The task is quite ordinary. </p><br><p><img src="https://habrastorage.org/webt/h7/4l/pw/h74lpw8srawkeyhmtbgccsznjyi.png"><br></p><br><p>  If you execute this code with the help of reflection, the result will be the one that you now see on the screen. </p><br><p><img src="https://habrastorage.org/webt/wp/v7/zp/wpv7zptnderqqwanc9omxspyor8.png"><br></p><br><p>  There is an iteration on the properties of the display, the search for a match in the dictionary for each property and copying.  Obviously, this code will be slow.  If it is executed only once, this is not a problem, but if it needs to be performed a million times - well, you understand.  If this happens in a server application that consumes server resources, someone might not like it. </p><br><p>  Let's try to solve this problem in another way.  Here the code creates an object `Order, the elements of which will be matched with the incoming dictionary. </p><br><p><img src="https://habrastorage.org/webt/ev/wm/a7/evwma7had5rf1ktyvksvfsaux_g.png"><br></p><br><p>  Values ‚Äã‚Äãare extracted from the dictionary, then they are reduced to the required type, copied, and this is all completely creepy and boring. </p><br><p>  But what if I create a lambda that already knows the <code>Order</code> object? </p><br><p><img src="https://habrastorage.org/webt/7w/vn/p6/7wvnp6_lzgajea-2kprmoou5v10.png"><br></p><br><p>  It is important that I specify the type of this object.  Notice that I do not use <code>&lt;Order&gt;</code> .  That would be great, but what if we don't know this type?  What if <code>Order</code> is defined in a deferred plugin?  In some cases, generics can help, but in this case, their use would be undesirable because we may need to abstract from this information. </p><br><p>  So, look at our lambda after compilation. </p><br><p><img src="https://habrastorage.org/webt/uh/al/t6/uhalt6vbwvlvo87sxxvwrb5yimo.png"><br></p><br><p>  Is she really good?  Code nice to read.  It was generated using Expressions.  Let's look at how they are written in the <code>ExpressionGeneration</code> class. </p><br><p><img src="https://habrastorage.org/webt/wl/pr/ey/wlpreyw8g34y4xxha2spqapue3s.png"><br></p><br><p>  We see that the code is similar to what I wrote with the help of reflection.  It is determined by <code>Expression.Parameter()</code> , the <code>result</code> variable is defined, a new <code>newEntityType</code> is created using <code>Activator.CreateInstance</code> , a new instance is assigned to the assign variable.  Everything is very boring.  Then I get the method through <code>type.getMethod()</code> and then <code>entityProps</code> around the <code>entityProps</code> properties. </p><br><p><img src="https://habrastorage.org/webt/3m/4j/kt/3m4jktsau270rjohwd2fdqrnuy4.png"><br></p><br><p>  In this case, it is not necessary to create a cycle, since we know how many properties there will be.  Thus, exactly those calls are generated here that are needed to extract the necessary value for <code>callTryGetValue</code> . </p><br><p><img src="https://habrastorage.org/webt/uk/ve/9w/ukve9wlfayn37sgnyzhrd3ec3rm.png"><br></p><br><p>  The next line calls the <code>Expression.Convert()</code> method, it needs to be cast to the type, since the types can be different.  Next, to access the property, a call is made to <code>Expression.MakeMemberAccess()</code> .  After that, a call is made to <code>Expression.IfThen()</code> for the try-catch construct.  Finally, a block is created, that is, an opening and closing parenthesis.  And as a result, we get lambda. </p><br><p><img src="https://habrastorage.org/webt/95/2x/a_/952xa_ake2rdnfuvnzjxy3v2bzc.png"><br></p><br><p>  I wrote the <i>ExpressionsSorcerer</i> tool.  You can take its code and place it in the <code>%USERPROFILE%/Visual Studio 2017/Visualizers</code> directory, and start debugging the code just discussed again.  This time I can see the lambda through the visualizer, it will be presented in the form of a tree. </p><br><p><img src="https://habrastorage.org/webt/c2/om/w6/c2omw670y_8qqeuyohycwnpyl9e.png"><br></p><br><p>  This kind of operation can be very useful, it helps to think, and what the hell am I writing here?  When you select a separate tree node in the window on the right, properties and their values ‚Äã‚Äãappear, which is very convenient.  Open the ‚ÄúShow the decompiled source‚Äù tab.  Before us is a code that I would write if I had the information that was passed to the code generator. </p><br><p><img src="https://habrastorage.org/webt/db/fk/t3/dbfkt3hnseanjyzexabjablwgqi.png"><br></p><br><p>  But I did not touch the code with this finger.  I did not even generate a C # code.  I wrote Expressions, i.e. there were only syntax nodes in memory, and I needed to decompile.  Thanks to Roslyn, there is also a color marking here, if necessary, it can be changed.  In addition, I added the <code>DebuggableAttribute</code> attribute, since I do not need optimizations that may arise during compilation.  You might ask, why don't I need them?  And in response, I will have another surprise for you. </p><br><p>  If we compile with debugging (by pressing "F11"), we will enter the automatically generated method, which we did not write with our own hands.  Impressive, isn't it?  Here you can see the current values ‚Äã‚Äãof the variables, you can check if there are any errors in Expressions.  As you can see, the <code>Description</code> value in the input argument was not, so the <code>TryGetValue</code> method was used for a reason. </p><br><p><img src="https://habrastorage.org/webt/4l/3p/wr/4l3pwrr_irtrbvb134hwyuwwkwg.png"><br></p><br><p>  At the end of the function in question, we get the <code>order</code> variable with the correct number of values. </p><br><p>  Summarize the interim.  Expressions cover almost the entire language, with the help of them you can generate <code>if</code> , <code>throw</code> , <code>catch</code> , you can create complex structures.  But for this, most likely, you will need a special tool.  In my tool, the most difficult part to write was implicit type conversions.  If you create a <code>double x</code> variable, and try to assign its value to a variable with <code>integer</code> type, you will get an <code>InvalidCastException</code> exception.  The reason is that the implicit conversion is performed by the compiler, but we did not have it.  So we had to do some things that the compiler usually does. </p><br><p>  Let me demonstrate some more complex expressions.  On the screen is a code in which a very simple object is created <code>var newObject = ExpressionInterop.BuildNewObject(ctor)</code> . </p><br><p><img src="https://habrastorage.org/webt/8l/w2/j2/8lw2j2ikphxvr7gnoiimp79qkis.png"><br></p><br><p>  If you look at it in the renderer, you will see how to create a new object <code>new Order()</code> . </p><br><p><img src="https://habrastorage.org/webt/fm/85/ay/fm85aynx8tmtmnypefgerwwpas8.png"><br></p><br><p>  For the reasons already mentioned, I always recommend using the <code>typeof()</code> method.  Next, through the <code>GetConstructor</code> method <code>GetConstructor</code> I get the constructor I need, and then through the <code>GetMethod</code> methods, the desired methods.  After this, a new object is created to which information about the constructor is passed: <code>ExpressionInterop.BuildNewObject(ctor)</code> .  And so on. </p><br><p>  I will not elaborate on this.  But I would like to show you what the expression looks like when you assign a value to a property ... </p><br><p>  Here are the compilation artifacts: </p><br><p><img src="https://habrastorage.org/webt/kj/te/gt/kjtegt7z7wm18w5nrfwvl2dvi7i.png"><br></p><br><p><img src="https://habrastorage.org/webt/qv/h3/vc/qvh3vcrejj8peekrubojvecwwyk.png"><br></p><br><p>  But if we go back to this Expression, it looks quite confusing.  One of the most complex Expressions created by me is used for marshaling.  I generated code that allows me to execute asynchronous code for <code>AddAsync</code> ... </p><br><p><img src="https://habrastorage.org/webt/nr/qd/ow/nrqdows6zdfykl4y5cnbtyfu7no.png"><br></p><br><p>  ... even if there is no code in the expression that could represent <code>Task&lt;T&gt;</code> . </p><br><p><img src="https://habrastorage.org/webt/xi/kb/a2/xikba22nl_ywxmzx6w54jf3t79c.png"><br></p><br><p>  The code is quite confusing; it will not be possible to recompile it, since the compiler, <i>Mono.Cecil</i> , cannot create the perfect decompilation.  Perhaps he will be able to do it in the future.  In addition, the problem here is that for <code>Task&lt;int&gt;</code> it is necessary to inject an external function.  This is because Expressions were created before asynchronous libraries and before changes in the compiler to support async / await.  Therefore, it is impossible to generate with the compiler and use await.  The compiler does all the magic, so if you use ILSpy and look at an artifact created with await, you will see a colback with a continuation there.  The code is very complicated. </p><br><p>  So where are we staying?  We created Expressions to generate certain predicates, functions, fairly complex pieces of code with if-then-else, throw-catch, and more.  Let's talk now about Roslyn. </p><br><p><img src="https://habrastorage.org/webt/jn/10/jq/jn10jqbj83c7ygop8c0bygshg2i.png"><br></p><br><p>  Roslyn is a .NET compiler platform that for several years now has been working as the main compiler for C #.  In other words, he rules our world.  Before, we could do little, but Roslyn opened the API for us.  Now, using the API of this compiler, we can directly do a lot of things.  We have formatting, character information, you can compile different things, interpret characters, get into the metadata behind the assembler, and much more.  As for the color marking, Roslyn does not control it directly.  He does not indicate: "it must be green, and that - blue."  Simply, there is a classification of the analyzed tokens, and they can be displayed in different ways. </p><br><p>  Thus, we have a lot of tools available, but there is a problem.  Roslyn does not have strict typing.  There are syntax nodes, and they are very easy to use, since any element is a syntax node.  There is no need to waste attention on connecting nodes with each other.  But this has a downside.  Without the very hard typing that gets on your nerves so much when you work with Expressions, we never know for sure whether the code we write will work correctly.  Therefore, Roslyn has more chances of errors than in the code written with Expressions. <br>  And yet, the benefits of Roslyn are great.  They cover the whole language, i.e. any constructions can be created.  For example, Roslyn can be accessed if you need to create new types during program execution.  Suppose I want to create a DTO (Data Transfer Objects) of a non-existent object at runtime.  I do not want to resort to using AutoMapper, since AutoMapper is usually used during development.  The type created should be able to filter events, each of which will be of a different type.  If you want to specify an Expression, you must create it and then work with the type representing this data.  And for their deserialization, you need DTO. </p><br><p>  The first and easiest way to generate code with Roslyn is a parser that has an API. </p><br><p><img src="https://habrastorage.org/webt/rf/r5/vt/rfr5vtgep2iiuiokjqu1ev0cfxe.png"><br></p><br><p>  It analyzes the text, creates a syntax tree, with which you can continue to perform a variety of operations: change the format, make beautiful indents, convert.  Suppose you need to refactor the API, change the names of variables, or replace the call, say, <code>Console.WriteLine</code> with <code>Console.Write</code> .  Instead of creating everything from scratch, you can read the existing code, use it as a template, and replace only the necessary.  The Visitor template is very well suited for this purpose.  You can visit some of the tokens in the application, and, having found one, replace it.  As you can see from the slide, formatting is very simple. </p><br><p>  If this functionality is not enough, you can use SyntaxGenerator.  This is a powerful high-level API, with a syntax factory under it.  It can declare namespaces, classes, attributes, parameters, in other words, it is a full-fledged language.  And using the <code>node.AdjustWhitespace()</code> command, you can make standard spaces between nodes. </p><br><p><img src="https://habrastorage.org/webt/ls/4-/if/ls4-ifo5ngzjwsu8xyih2v1ltgk.png"><br></p><br><p>  For a start, look at a few examples of how this tool works.  In the first one, we use <code>SyntaxFactory</code> , from which we get <code>SyntaxTrivia</code> , <code>QualifiedName</code> , <code>CompilationUnit</code> , <code>UsingDirective</code> .  Perhaps you say - this is even worse than the trees Expressions.  But what you see here is a low-level API.  Knowing him is useful and can be explored using the Roslyn SDK.  In it you can see how the syntax code tree is created, how the nodes in Roslyn are connected to each other.   , ,    ,    ,   ,     -,     ,    . ,   ,          . </p><br><p>    ,      .         .  ,          ,   , ,        .   ,        . -,     .   ,      . -,      .        -  .      . </p><br><p>    Roslyn   . </p><br><p><img src="https://habrastorage.org/webt/dp/mf/b4/dpmfb4hlisir_x2dklnytftddnw.png"><br></p><br><p><img src="https://habrastorage.org/webt/vo/es/6o/voes6ovxhecjqf7cqjwatrh7nf8.png"><br></p><br><p>        <code>text</code> : </p><br><p><img src="https://habrastorage.org/webt/a_/-5/ih/a_-5ihumt1dflrvzx5qnzhs-ary.png"><br></p><br><p>  ,       ( <code>text2</code> ): </p><br><p><img src="https://habrastorage.org/webt/ye/ra/zv/yerazv5kadg698wkkaky-o5cpuy.png"><br></p><br><p>  ,      <code>StringBuilder</code> -   . </p><br><p>  . </p><br><p><img src="https://habrastorage.org/webt/5y/qx/ic/5yqxicvi26fufaw_uq5zrjop3t4.png"><br></p><br><p>     : </p><br><p><img src="https://habrastorage.org/webt/it/bu/km/itbukmq7qbuhrfyvei2cvlhdqoa.png"><br></p><br><p>      <code>PostProcess(SyntaxNode root)</code> .    ,  LINQ  ,   ,     . ,     <code>Console.WriteLine</code>  <code>Console.Write</code> .           <code>Console.ReadKey()</code> .       <code>Console.Write</code>     <code>Console.ReadKey</code> . </p><br><p><img src="https://habrastorage.org/webt/nv/qw/c3/nvqwc3-bods9u6gvxmxxx7ji-bm.png"><br></p><br><p>  ,       .       . </p><br><p>    . </p><br><p><img src="https://habrastorage.org/webt/pn/ld/in/pnldin8yshf454nvhk3xe7xncyu.png"><br></p><br><p>     ,   <code>CodeGenerationHelper()</code> .   SyntaxGenerator  ,   ,    . </p><br><p><img src="https://habrastorage.org/webt/5y/lu/0o/5ylu0ow36wgio8raewg6ehhogho.png"><br></p><br><p>     POCO   DTO,  . </p><br><p>        ,  . </p><br><p><img src="https://habrastorage.org/webt/sn/ed/6z/sned6zr34cc90gp60laatxth094.png"><br></p><br><p>    ,   ?  ,    ,  ,    .          .      .       ,     ‚Äî    .      . </p><br><p><img src="https://habrastorage.org/webt/l6/ow/ms/l6owmsscyxdzlpvxx2vqb5ze3yk.png"><br></p><br><p>     ,   ,    ,   ,  , DTO.    ,     .    ,     . ,    . </p><br><p>         <code>AddImplementINotifyPropertyChanged()</code> . </p><br><p><img src="https://habrastorage.org/webt/da/on/k8/daonk8t05piownjgpr6-v2szwcc.png"><br></p><br><p><img src="https://habrastorage.org/webt/uk/52/g1/uk52g15rkqoaysrj-downulpkza.png"><br></p><br><p>  ,       <code>result.DiagnosticReport</code> ,      <code>INotifyPropertyChanged</code> . </p><br><p><img src="https://habrastorage.org/webt/o6/do/g3/o6dog3sabieif-f_dvcjhe-dxoq.png"><br></p><br><p>    ,   <code>string _name</code>   <code>OnPropertyChanged()</code> ,    <code>OnPropertyChanged</code> ,  <code>[CallerMemberName]</code> ‚Äî . . ,    .    .        GitHub,       . </p><br><p>   ‚Äî      ?        ,   ‚Äî     ,        SyntaxGenerator.       , ,  ,    .  ,          .    <code>SimpleClassGenerator</code> . </p><br><p><img src="https://habrastorage.org/webt/ho/xi/-5/hoxi-5_rmzowunep8f4u_hppndm.png"><br></p><br><p>    ,   <code>HashSet&lt;PortableExecutableReference&gt; Reference</code>   ,  <code>System.Runtime</code> .  ,         .NET Core,   .NET Framework,   ‚Äî  .NET Core,       . </p><br><p><img src="https://habrastorage.org/webt/ou/l7/y8/oul7y8ooxo-qfkara6q8jiwgtd4.png"><br></p><br><p>    <code>SimpleClassGenerator</code> ,      <code>IDictionary&lt;string, Properties&gt; Properties</code> ,       .   <code>GetSource()</code>        , <code>BuildClass()</code> ,         . </p><br><p><img src="https://habrastorage.org/webt/e6/h9/q0/e6h9q0x1ymwpzyucdv74eaqlmrq.png"><br></p><br><p>            -,      <code>CreateProperty()</code> . </p><br><p><img src="https://habrastorage.org/webt/hi/hy/jp/hihyjpnwchlbqchty0b1ysna0gi.png"><br></p><br><p> ,   ,    .   ,   ,   .   .     backfield.               .      <code>Accessor</code>    . </p><br><p>        .       ,      IL? , , ,       <code>Reflection.Emit</code> ,         . ,   .    .     x86-.       ,     ,         .     .  -  .     ,    ,     ¬´   ¬ª. -  ,    . </p><br><p>    IL , ,   . ,     .dll,    ,   .   ILSpy        .     :   ,    ,       .    ,     .  - ,    Visual Studio   IL,          .        ¬´F11¬ª,          ,       . </p><br><p>  ,      . ,  ,       . Mono.Cecil ‚Äî   .    , , , ,   ,   .  ,          .    ,  GitHub  ,   . ,         .   ,     ¬´F11¬ª   ,      IL,   . </p><br><p>     ?     <code>sample1.dll</code> ,    <code>DataHelper</code> ,      . </p><br><p><img src="https://habrastorage.org/webt/nd/d4/ng/ndd4ngwpllz-pijghez59koti2u.png"><br></p><br><p>  <code>Employee</code>  DTO.   <code>Person</code> ,  <code>Printer</code> ,    . , ,  <code>Main</code> ,           . </p><br><p><img src="https://habrastorage.org/webt/i2/l0/js/i2l0jsc_vwer9tilve3k8qayo0g.png"><br></p><br><p>  <code>Start1</code>    <code>Person</code>  . <code>Start2</code>  ,  -,      , ,   ,       <code>Printer</code> .  ,   for-each   <code>ToList()</code>   .      Linq , `Enumerable   . </p><br><p> ,    .   <code>AssemblyHooker</code> ,      (trap)   .dll.    VisualStudio Code,         .     ,     sample1.dll. </p><br><p><img src="https://habrastorage.org/webt/iq/va/gh/iqvaghuid4aatmemu-k-e_vywcs.png"><br></p><br><p>          .      ,       .   ,   <i>PlantUML</i> ?   ,      ,     ,   . </p><br><p><img src="https://habrastorage.org/webt/vf/mx/3c/vfmx3cspqd1tv7qsucyxbe831rc.png"><br></p><br><p>       ,      .    ,     .  ,     .     ,       ,  ,   <code>WriteLine</code> ,         .       : <code>Program</code> , <code>Person</code> , <code>Console</code> .   ,   . </p><br><p><img src="https://habrastorage.org/webt/64/xc/0a/64xc0am60prswkb25sb72yiutby.png"><br></p><br><p>         <code>Main</code>  sample1.dll.     .   ,       .    ,     ,   <i>PlantUML</i> .  ,        <code>Enumerable</code> , . .    ,    .       ,     ,    .          <code>Main</code> . </p><br><p> ,  ,   ,    IL .     , -,  ,      .      IL     . </p><br><p>   , ,   ,          . ,     .    :       ,    ,    ,  .      .    ?   .      ,         ,    . </p><br><p>  .      ,        .   ,      ‚Äî <a href="https://roslynquoter.azurewebsites.net/">Roslyn Quoter</a> .      ,   ,   Roslyn,    .      ,    <i>Roslyn Quoter</i>     ,        . </p><br><blockquote>  .  , , ,   .    .NET ‚Äî <a href="https://dotnext-piter.ru/">DotNext 2018 Piter</a> .   22-23  2018   -.     ‚Äî    <a href="https://www.youtube.com/watch%3Fv%3DMpFEkVPbgiU%26amp%3Blist%3DPLtWrKx3nUGBeYn-pSCjEgBPL90SvpylZL">   YouTube</a> .             .NET       . , ,   . </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353458/">https://habr.com/ru/post/353458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353438/index.html">Features of setting up and launching PVS-Studio in Docker using the example of Azure Service Fabric code</a></li>
<li><a href="../353440/index.html">Shine and Poverty Java for Desktop</a></li>
<li><a href="../353444/index.html">We write the plugin for Unity correctly. Part 2: Android</a></li>
<li><a href="../353446/index.html">Operators?. ?? and |>: future JavaScript features you'll like</a></li>
<li><a href="../353448/index.html">Great, we are going to devOps-ping. So, 15 years of planning?</a></li>
<li><a href="../353460/index.html">RTCP REMB: we twist the video call settings in the browser</a></li>
<li><a href="../353462/index.html">How to get into Microsoft, Amazon or Twitter without a prestigious college diploma</a></li>
<li><a href="../353464/index.html">Online statistics in Telegram</a></li>
<li><a href="../353466/index.html">Uncountable: in search of a finite number</a></li>
<li><a href="../353468/index.html">What's new in AppCode 2018.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>