<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Convolutions in Intel Cilk Plus</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suppose for some reason we need to find the sum of the elements of the array. We can split the array into two parts, sum each part separately and add ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Convolutions in Intel Cilk Plus</h1><div class="post__text post__text-html js-mediator-article">  Suppose for some reason we need to find the sum of the elements of the array.  We can split the array into two parts, sum each part separately and add the results.  At the same time, these parts can be summed up in parallel.  But the summation of the part of the array is exactly the original problem, and each part can again be divided into two parts and summed each part separately, and then add the results, etc. This computational strategy is called ‚Äú <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide and conquer</a> ‚Äù. <br><br>  In this way, many other functions from arrays can be computed; in the first part of the article, a mathematical explanation of this idea will be given, and in the second, how to use this idea in your programs using Intel Cilk Plus. <br><br>  So, if there is a desire to look at the mathematical formulas and pieces of code in C ++ in the last days of summer, then welcome to habrakat. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Monoids and homomorphisms </h4><br>  The definition of a monoid with a multitude of examples and a very detailed explanation can be found in habrastiat <a href="http://habrahabr.ru/blogs/algorithm/112394/">Monoids and their applications: monoidal calculations in trees</a> , so we confine ourselves to definition and a couple of examples. <br><br>  <i>A monoid</i> is a triple ( <i>M</i> , ‚ãÖ, <i>e</i> ), where <i>M</i> is a non-empty set, ‚ãÖ is a binary associative operation on the set <i>M</i> , <i>e</i> is an element of the set <i>M</i> that is neutral with respect to the operation ‚ãÖ. <br><br>  Since the operation ‚ãÖ is associative, that is, for any <i>x</i> , <i>y</i> and <i>z</i> from <i>M</i> , it is true that <i>x</i> ‚ãÖ ( <i>y</i> <i>z</i> ) = ( <i>x</i> ‚ãÖ <i>y</i> ) ‚ãÖ <i>z</i> , the result of evaluating the expression <i>x</i> <sub>1</sub> <i>x</i> <sub>2</sub> ... ‚ãÖ <i>x</i> <sub><i>n</i></sub> does not depend on the arrangement of brackets, therefore, it is possible not to write brackets at all.  The proof of this simple, but important fact (as well as all subsequent simple, but important facts) can be found in some textbook on higher algebra or to invent it yourself. <br><br>  There are a lot of examples of monoids, for example, from the sixth grade of school, anyone knows that the set of integers by addition ( <b>Z</b> , +, 0) is a monoid.  Another example of a monoid is a list monoid.  Namely, let X be an arbitrary set, denote by <i>X</i> <sup>‚àó the</sup> set of all finite sequences of elements of <i>X</i> , including the empty sequence [], and the symbol ++ denote the concatenation of lists.  Then, as it is not difficult to be convinced, the triple ( <i>X</i> <sup>‚àó</sup> , ++, []) is a monoid. <br><br>  Next we need the concept of a homomorphism.  Let ( <i>M</i> , ‚ãÖ <sub><i>M</i></sub> , <i>e</i> <sub><i>M</i></sub> ) and ( <i>N</i> , <sub><i>N</i></sub> , <i>e</i> <sub><i>N</i></sub> ) be two arbitrary monoids.  A function <i>h</i> : <i>M</i> ‚Üí <i>N</i> is called a <i>homomorphism</i> if <i>h</i> ( <i>x</i> ‚ãÖ <sub><i>M</i></sub> <i>y</i> ) = <i>h</i> ( <i>x</i> ) <sub><i>N</i></sub> <i>h</i> ( <i>y</i> ) for any <i>x</i> and <i>y</i> from <i>M</i> , and h ( <i>e</i> <sub><i>M</i></sub> ) = <i>e</i> <sub><i>N.</i></sub> <br><br>  Note that, strictly speaking, a function is a homomorphism if it can be dragged through the sign of a binary operation.  It is clear that the identity mapping is a homomorphism, but from the school and university mathematics courses everyone knows some more interesting examples of homomorphisms.  For example, the <i>logarithm of a product is equal to the sum of logarithms</i> , ln ( <i>xy</i> ) = ln <i>x</i> + ln <i>y</i> , and in our terms this means that the mapping ln is a homomorphism from a monoid of positive real numbers by multiplication ( <b>R</b> <sub>+</sub> ,, 1) into a monoid of real numbers by addition ( <b>R</b> , +, 0).  Further, the <i>determinant of the product of matrices is equal to the product of the determinants of these matrices</i> , det ( <i>AB</i> ) = det <i>A</i> ‚ãÖ det <i>B</i> , that is, the map det is a homomorphism from a monoid of square matrices by multiplication (Mat <sub><i>n</i></sub> ( <b>R</b> ),, <b>I</b> ) into a monoid real multiplication numbers ( <b>R</b> , ‚ãÖ, 1).  I hope the idea is clear.  We now turn to list homomorphisms. <br><br>  Any homomorphism <i>h</i> from a list monoid ( <i>X</i> <sup>‚àó</sup> , ++, []) into an arbitrary monoid ( <i>M</i> ,, <i>e</i> ) is called a <i>list homomorphism</i> .  List homomorphisms have the following useful property.  Let [ <i>x</i> <sub>1</sub> , <i>x</i> <sub>2</sub> , ..., <i>x</i> <sub><i>n</i></sub> ] be an arbitrary list, then <i>h</i> ([ <i>x</i> <sub>1</sub> , <i>x</i> <sub>2</sub> , ..., <i>x</i> <sub><i>n</i></sub> ]) = <i>h</i> ([ <i>x</i> <sub>1</sub> ] ++ [ <i>x</i> <sub>2</sub> ] ++ ... + + [ <i>x</i> <sub><i>n</i></sub> ]) = <i>h</i> ([ <i>x</i> <sub>1</sub> ]) ‚ãÖ <i>h</i> ([ <i>x</i> <sub>2</sub> ]) ‚ãÖ‚Ä¶ ‚ãÖ <i>h</i> ([ <i>x</i> <sub><i>n</i></sub> ]).  Thus, any list homomorphism is uniquely determined by its values ‚Äã‚Äãon singleton lists.  So, let <i>f</i> : <i>X</i> ‚Üí <i>M be</i> a function such that <i>f</i> ( <i>x</i> ) = <i>h</i> ([ <i>x</i> ]), then the uniquely defined list homomorphism <i>h</i> will be written in the form hom (, <i>f</i> , <i>e</i> ). <br><br>  Now a few examples. <br><ol><li>  Summation of the elements of the list of numbers, the product of the elements of the list of numbers, finding the minimum and maximum elements of the list of numbers can be considered as list homomorphisms hom (+, id, 0), hom (, id, 1), hom (max, id, ‚àí‚àû) and hom (min, id, + ‚àû), respectively.  Similar list homomorphisms, in which the second parameter is the identity map id, we will briefly write reduce (, e). </li><li>  The function length, which calculates the length of the list, is a list homomorphism hom (+, one, 0), where one ( <i>x</i> ) = 1. </li><li>  A function that applies a certain function <i>f</i> to each element of the list is also a list homomorphism, namely hom (++, <i>g</i> , []), where <i>g</i> ( <i>x</i> ) = [ <i>f</i> ( <i>x</i> )].  Such functions will be briefly written as map ( <i>f</i> ). </li><li>  The sort function can also be represented as a list homomorphism.  Namely, let merge be a merge function of two ordered lists, list ( <i>x</i> ) = [ <i>x</i> ] is a function that turns an element into a single-element list.  Then the homomorphism hom (merge, list, []) is the desired list homomorphism. </li></ol><br>  Note that, although the homomorphism is called a list, a list can be understood as arrays, strings, or in general, sequences generated on the fly.  Now, we formulate three useful statements, known as theorems on homomorphism. <br><br>  <b>The first theorem on homomorphism.</b>  <i>Any list homomorphism can be represented as a composition</i> hom (, <i>f</i> , <i>e</i> ) = reduce (, e) ‚àò map ( <i>f</i> ). <br><br>  It is on this simple observation that the idea of ‚Äã‚ÄãMapReduce is based.  A simple introduction to MapReduce can be found in <a href="http://habrahabr.ru/blogs/algorithm/103467/">MapReduce</a> habrastatyah <a href="http://habrahabr.ru/blogs/algorithm/103467/">or calculations outside of the memory and processor (try without any zaumi)</a> and <a href="http://habrahabr.ru/blogs/algorithm/103490/">MapReduce: more advanced examples, we will try without any zaumi</a> . <br><br>  Let [ <i>x</i> <sub>1</sub> , <i>x</i> <sub>2</sub> , ..., <i>x</i> <sub><i>n</i></sub> ] be an arbitrary list, the <i>left fold</i> is the function foldl (‚ãÖ <sub>L</sub> , <i>e</i> <sub>L</sub> ) ([ <i>x</i> <sub>1</sub> , <i>x</i> <sub>2</sub> , ..., <i>x</i> <sub><i>n</i></sub> ]) = (... ((e <sub>L</sub> ‚ãÖ <sub>L</sub> <i>x</i> <sub>1</sub> ) ‚ãÖ <sub>L</sub> <i>x</i> <sub>2</sub> ) ‚ãÖ <sub>L</sub> ... ‚ãÖ <sub>L</sub> <i>x</i> <sub><i>n</i></sub> ), and the <i>right folding</i> is the function foldr ( <sub>R</sub> , <i>e</i> <sub>R</sub> ) ([ <i>x</i> <sub>1</sub> , <i>x</i> <sub>2</sub> , ..., <i>x</i> <sub><i>n</i></sub> ]) = ( <i>x</i> <sub>1</sub> ‚ãÖ <sub>R</sub> ( <i>x</i> <sub>2</sub> ‚ãÖ <sub>R</sub> ... ‚ãÖ <sub>R</sub> ( <i>x</i> <sub><i>n</i></sub> ‚ãÖ <sub>R</sub> <i>e</i> <sub>R</sub> ) ...)).  The second theorem on homomorphism states the following. <br><br>  <b>The second theorem on homomorphism</b> .  <i>Any list homomorphism is expressed as a left and a right convolution, i.e.</i> hom (, <i>f</i> , <i>e</i> ) = foldl ( <sub>L</sub> , <i>e</i> ) = foldr ( <sub>R</sub> , <i>e</i> ), <i>where</i> <i>x</i> ‚ãÖ <sub>L</sub> <i>y</i> = <i>x</i> = <i>f</i> ( <i>y</i> ), <i>x</i> ‚ãÖ <sub>R</sub> <i>y</i> = <i>f</i> ( <i>x</i> ) ‚ãÖ <i>y</i> . <br><br>  This theorem indicates two successive ways to calculate list homomorphisms - in the form of the left and in the form of the right convolution.  How the functions that compute these convolutions are called in specific programming languages ‚Äã‚Äãcan be found in the <a href="http://en.wikipedia.org/wiki/Fold_%2528higher-order_function%2529">Fold</a> article of Wikipedia <a href="http://en.wikipedia.org/wiki/Fold_%2528higher-order_function%2529">(higher-order function)</a> .  More information about convolutions can be found in the article by Evgeny Kirpichev <a href="http://fprog.ru/2009/issue3/eugene-kirpichov-elements-of-functional-languages/">Elements of functional languages</a> . <br><br>  For us, a more interesting method is the parallel computation of the list homomorphism <i>h</i> = hom (, <i>f</i> , e).  Recall that, by definition, the list homomorphism <i>h</i> ( <i>x</i> ++ <i>y</i> ) = <i>h</i> ( <i>x</i> ) ‚ãÖ <i>h</i> ( <i>y</i> ), in other words, you can independently, and, therefore, in parallel, calculate <i>h</i> ( <i>x</i> ) and <i>h</i> ( <i>y</i> ), and then calculate the final value of <i>h</i> ( <i>x</i> ++ <i>y</i> ).  But we can also split each of the <i>x</i> and <i>y</i> lists into two parts, and, using the definition of a homomorphism, calculate the values ‚Äã‚Äãof <i>h</i> for them independently, and then collect the result, etc. This is nothing more than a <a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide-and-conquer strategy</a> . <br><br>  Suppose that the operation ‚ãÖ is calculated in constant time <i>C</i> , and the list <i>x</i> consists of <i>n</i> elements.  To calculate the left convolution, it is necessary to calculate the operation ‚ãÖ exactly <i>n</i> times, that is, it takes <i>Cn of</i> time.  If we have <i>p</i> processors, then we divide the list of <i>x</i> into <i>p</i> equal parts <i>x</i> <sub><i>i</i></sub> and use the left convolution for each <i>x</i> <sub><i>i to</i></sub> calculate <i>h</i> in the time of <i>Cn</i> / <i>p</i> , and then in the time of <i>C</i> log <sub>2</sub> <i>p we</i> calculate the final result.  Thus, the total time is <i>C</i> ( <i>n</i> / <i>p</i> + log <sub>2</sub> <i>p</i> ). <br><br>  Finally, we formulate the third theorem on a homomorphism, which says when a function is a list homomorphism. <br><br>  <b>The third homomorphism theorem.</b>  <i>If some function from a list monoid to some monoid is expressed as a left</i> foldl (‚ãÖ <sub>L</sub> , <i>e</i> ) <i>and as a right convolution</i> foldr ( <sub>R</sub> , <i>e</i> ) <i>, then it is a list homomorphism.</i> <br><br>  Evidence for these three theorems can be found in Jeremy Gibbons' article <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Bjsessionid%3DF0607FBCAE78F9482C460A32ED76C011%3Fdoi%3D10.1.1.45.2247%26rep%3Drep1%26type%3Dpdf">The Third Homomorphism Theorem</a> , and we turn to Intel Cilk Plus. <br><br><h4>  Convolutions in Intel Cilk Plus </h4><br>  Intel Cilk Plus is an extension of the C ++ language for writing multi-threaded programs, which among other things includes the following: <br><ol><li> keywords <code>cilk_spawn</code> and <code>cilk_sync</code> (the first indicates that the function can be executed in parallel, the second is used for synchronization), </li><li>  the <code>cilk_for</code> keyword for parallelizing loops </li><li>  hotspots for thread-safe data separation, </li><li>  special syntax for writing arrays and operations on arrays, for example, elementwise addition of arrays will be written as <code>c[:] = a[:] + b[:]</code> . </li></ol><br>  Only the second and third points will be affected here.  Documentation and other materials about Intel Cilk Plus can be found at <a href="http://software.intel.com/en-us/articles/intel-cilk-plus/">http://software.intel.com/en-us/articles/intel-cilk-plus/</a> . <br><br>  So, suppose that we need to calculate the sum of the elements of an array of integers.  A possible consistent implementation is shown below. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { sum += a[i]; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Note that this is nothing but the implementation of the left convolution.  But the sum of the elements of the array is a list homomorphism, and, therefore, also admits a parallel implementation, as explained above.  Intel Cilk Plus allows you to make such an implementation without any effort, it is enough to do the following: <br><ol><li>  include <code>cilk/reducer_opadd.h</code> and <code>cilk/cilk.h</code> header files, </li><li>  change <code>sum</code> type to <code>reducer_opadd&lt;int&gt;</code> , </li><li>  change <code>for</code> to <code>cilk_for</code> , </li><li>  use <code>get_value()</code> to get the result. </li></ol><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cilk/cilk.h&gt; #include &lt;cilk/reducer_opadd.h&gt; ... cilk::reducer_opadd&lt;int&gt; sum; cilk_for (int i = 0; i &lt; n; ++i) { sum += a[i]; } std::cout &lt;&lt; sum.get_value() &lt;&lt; std::endl;</span></span></span></span></code> </pre><br><br>  In this case, something like the following will happen.  The compiler converts the body of the <code>cilk_for</code> loop into a function that implements the "divide and conquer" strategy; in pseudo-code, this is written as follows. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first, last)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((last - first) &lt; grainsize) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = first; i &lt; last; ++i) { LOOP_BODY; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mid = (last - first) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-function">cilk_spawn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first, mid)</span></span></span></span>; run_loop(mid, last); } }</code> </pre><br>  And since the sum variable is a reducer, then if the thread is split into two and their parallel execution, the daughter will use the old view, and the sequel will receive a new view, initialized to zero, while synchronizing, both views will be added. <br><br>  In addition to <code>reducer_opadd</code> Intel Cilk Plus provides a large set of reducers: <code>reducer_list_append</code> , <code>reducer_list_prepend</code> , <code>reducer_min</code> , <code>reducer_max</code> , <code>reducer_min_index</code> , <code>reducer_max_index</code> , <code>reducer_opor</code> , <code>reducer_opand</code> , <code>reducer_opxor</code> , <code>reducer_basic_string</code> , <code>reducer_string</code> , <code>reducer_wstring</code> , <code>reducer_ostream</code>  If none of them fit, then you can create your own reducer. <br><br>  To create a reducer, you need to create a <code>Monoid</code> class that implements a monoid.  This class should contain the following functions: <br><ul><li>  <code>reduce(T *left, T *right)</code> calculates <code>*left = *left OP *right</code> , </li><li>  <code>identity(T *p)</code> creates a neutral element in the memory area pointed to by <code>p</code> , </li><li>  <code>destroy(T *p)</code> calls the destructor for the object pointed to by <code>p</code> , </li><li>  <code>allocate(size)</code> returns a pointer to a memory region of <code>size</code> bytes, </li><li>  <code>deallocate(p)</code> frees the memory pointed to by <code>p</code> . </li></ul><br>  In most cases, all these methods need not be implemented, it suffices to inherit from the class <code>cilk::monoid_base&lt;T&gt;</code> and implement <code>reduce()</code> and, possibly, <code>identity()</code> . <br><br>  Further, the class that implements a reducer should contain the <code>cilk::reducer&lt;Monoid&gt; imp_</code> hot <code>cilk::reducer&lt;Monoid&gt; imp_</code> as a hidden member and methods for accessing and changing the hot <code>cilk::reducer&lt;Monoid&gt; imp_</code> . <br><br>  We write a reducer to find the product of the elements of an array of numbers. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cilk/reducer.h&gt; #include &lt;cilk/cilk.h&gt; #include &lt;iostream&gt; class reducer_prod { public: struct Monoid: cilk::monoid_base&lt;double&gt; { void reduce(double *left, double *right) const { *left *= *right; } void identity(double* p) const { new ((void*) p) double(1.0); } }; reducer_prod(): imp_(1.0) { } reducer_prod &amp;operator*=(const double &amp;v) { imp_.view() *= v; return *this; } double get_value() const { return imp_.view(); } private: cilk::reducer&lt;Monoid&gt; imp_; };</span></span></span></span></code> </pre><br><br><pre> <code class="cpp hljs">reducer_prod prod; cilk_for (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { prod *= a[i]; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; prod.get_value() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/126275/">https://habr.com/ru/post/126275/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../126266/index.html">Silicon Cocktail</a></li>
<li><a href="../126268/index.html">Artillery shooting math functions</a></li>
<li><a href="../126270/index.html">Apple patents the printing system without a printer driver.</a></li>
<li><a href="../126273/index.html">Place your price - it's easy</a></li>
<li><a href="../126274/index.html">Who are Anonymous</a></li>
<li><a href="../126276/index.html">Listen to Pandora.com using free VPN</a></li>
<li><a href="../126278/index.html">Oatmeal - Be the Apple Owner</a></li>
<li><a href="../126279/index.html">Nintendo received a patent for a "single-player gaming universe"</a></li>
<li><a href="../126282/index.html">New Apple Motherboard Renders</a></li>
<li><a href="../126286/index.html">Do you have a financial crisis?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>