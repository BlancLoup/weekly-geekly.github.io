<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New attachments in Yandex.Mail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We strive to ensure that all parts of Yandex.Mail work equally well for all users. Today we will tell you about how and why the block for adding attac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New attachments in Yandex.Mail</h1><div class="post__text post__text-html js-mediator-article">  We strive to ensure that all parts of Yandex.Mail work equally well for all users.  Today we will tell you about how and why the block for adding attachments was completely rewritten.  In this article - about the rejection of flash, support for the capabilities of modern browsers and, as a result, an increase in the speed and reliability of downloading files. <br><br><h1>  Problem </h1><img src="https://habrastorage.org/getpro/habr/post_images/86d/8d0/851/86d8d0851ec8b084c55aa28669f574b2.png" align="right">  Previously, we divided the whole Yandex audience. Mail users into users with a flash and without. <br><br>  With the first, everything was simple: users with a flash installed attached files to the letter via a flash loader.  He allowed to download several files at once, determined their size and controlled the download process. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But with users without a flash (8-10% of the daily audience) was more difficult.  We offered them to upload files through the usual form with <code>/&gt;</code> .  Files from it were sent via the iframe along with the contents of the letter itself, and it took a lot of time.  Pressing the "Send" button, the user waited a long time until the files are loaded. <br><a name="habracut"></a><br>  And if small files (up to 25 MB) did not cause any particular difficulties, then large ones created a new problem: if the file size exceeded the allowed limit, you had to use the Yandex.Narod service, and then Yandex.Disk (with the new attachments we changed the file storage) *. <br><br>  <i>* The limit on the size of sent files is explained not so much by technological limitations in Yandex. Mail, as by problems with third-party mail servers.</i>  <i>Not all of them are ready to accept and store letters of large sizes.</i>  <i>To ensure that such letters reach the addressee, we save attachments of more than 25 MB in size on Yandex.Disk and add links to the letter.</i> <br><br>  To determine the size of files for users without a flash, we raised an internal service that worked like this: the client sent a POST file with a request to a special url, the server read the request Content-Length header and closed the connection. <br><br>  The implementation of downloading files in all browsers is designed so that it does not wait for a response from the server until it has completely sent the file.  Therefore, the server cannot immediately report the file size.  To solve this problem, we made a second GET request, in which the server passed to the client a Content-Length header value equal to the size of the downloaded file. <br><br>  Problems with attaching files to the letter could arise for both categories of users.  For example, the flash loader allows you to select several files and is able to determine their size, but: <br><ol><li>  This is a third-party plugin that must be installed on the user's computer, and it can be blocked by other plug-ins or extensions; </li><li>  There are problems with SSL connections and security; </li><li>  Difficult to solve problems and errors when downloading files. </li></ol><br>  And the usual <code>/&gt;</code> at least does not have multiattaching. <br><br>  Of course, we were not satisfied with this state of affairs, and we did not stop searching for an effective solution to these problems. <br><br><h1>  Opportunity </h1>  Over the past year, all browsers have learned independently (without connecting third-party plug-ins) to organize work with files.  Take a closer look at all their modern capabilities in the article on the <a href="https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications">Mozilla Developer Network</a> . <br><br>  Here are the new features that appeared during the development of HTML5: <br>  - multiple attribute in the input tag (starting with Chrome 4, Firefox 3.6, IE 10, Opera 11, Safari 5); <br>  - <a href="https://developer.mozilla.org/en-US/docs/DragDrop/Drag_and_Drop">Drag and Drop API</a> (Chrome 4, Firefox 3.5, IE 5.5, Opera 12, Safari 3); <br>  - <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/FormData">FormData</a> (Chrome 7, Firefox 4, IE 10, Opera 12, Safari 5); <br>  - <a href="http://www.w3.org/TR/XMLHttpRequest/">XMLHttpRequest level 2</a> + <a href="http://www.w3.org/TR/cors/">CORS</a> + <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest">progress events</a> (Chrome 7, Firefox 4, IE 10, Opera 12, Safari 5). <br><br>  Theoretically, we could have introduced them a year and a half ago, but the changes would affect only Chrome and Firefox.  These browsers had a good share in total, but were not monopolists.  Opera and IE by that time did not yet support these features.  So, half the audience would still have to leave on a flash. <br><br>  Therefore, we waited.  And before the June release of Opera 12, in which the introduction of the necessary technologies became possible, began its development. <br><br>  As for IE10, its release is expected soon. <br><br><h1>  Implementation </h1>  As mentioned above, we must separate files into large and small ones.  For example, a user tries to attach ten files to a letter, nine of which in total fit into the allowed limit, and the tenth is twice as large as the rest.  Without the ability to download files individually, all ten files would go to Yandex.Disk.  However, this does not seem reasonable - it is better to send only one file to the Disk, the last one, and upload all the rest to the letter.  So we decided to download each file separately. <br><br>  Usually files are uploaded through the standard form: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/upload"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"post"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">multiple</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"submit"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Suppose we send a form to a hidden iframe.  In this case, the browser will read all the selected files from the input (even if there are many) and send a POST request to / upload.  But here the files are loaded all together, but it does not suit us. <br><br>  Let's see how AJAX will help us.  To send files via AJAX, we need FormData support.  Without it, you cannot read the files in input and add them to the query.  Let's try this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"myFormElement"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-string"><span class="hljs-string">"/upload"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhr.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormData(formElement));</code> </pre><br>  But in this case, all the files still go from input.  It turns out that you need to take each file separately and determine where to download it (to Disk or to a letter), that is, process it independently. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = input.files.length; i &lt; j; i++) { upload(input.files[i]); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upload</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.size &gt; MESSAGE_LIMIT) { url = <span class="hljs-string"><span class="hljs-string">"uploader.disk.yandex.ru"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { url = <span class="hljs-string"><span class="hljs-string">"uploader.mail.yandex.ru"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormData(); data.append(<span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, file); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhr.send(data); }</code> </pre><br>  Downloading files individually is also convenient because the error in loading one file does not prevent others. <br><br>  We support all popular browsers, but not all of them support modern technologies.  According to the feature detection policy, we have added four checks to enable new features: <br><ol><li>  No support FormData ‚Üí use iframe. </li><li>  There is support for FormData ‚Üí use AJAX. </li><li>  There is support for Drag-n-Drop and FormData ‚Üí enable the ability to drag and drop files from the file manager.  For example, in IE there is the first, but there is no second, therefore we cannot send the dragged files in any way. </li><li>  There is support for multiple input and FormData ‚Üí we enable the ability to select many files.  For example, in Opera 11.6 there are multiple inputs, but there is no FormData, respectively, we cannot send files one by one. </li></ol><br>  The third and fourth checks resulted in tests for <a href="http://modernizr.com/">Modernizr</a> : <br><pre> <code class="javascript hljs">Modernizr .addTest(<span class="hljs-string"><span class="hljs-string">'draganddrop-files'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!(Modernizr[<span class="hljs-string"><span class="hljs-string">'draganddrop'</span></span>] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">'FormData'</span></span>] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">'FileReader'</span></span>]); }) .addTest(<span class="hljs-string"><span class="hljs-string">'input-multiple'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!(Modernizr[<span class="hljs-string"><span class="hljs-string">'input'</span></span>][<span class="hljs-string"><span class="hljs-string">'multiple'</span></span>] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">'FormData'</span></span>] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">'FileReader'</span></span>]); });</code> </pre><br>  In Safari 5.1 for Windows, a bug was immediately found: when selecting several files, they all turned out to be zero in size and sent to the server empty.  In this browser, all new features had to be disabled. <br><br>  In addition to AJAX transport, we started using <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest">Progress events</a> to draw a beautiful progress bar. <br><br>  We use it like this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-string"><span class="hljs-string">'/upload'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.upload) { xhr.upload.addEventListener(<span class="hljs-string"><span class="hljs-string">'progress'</span></span>, processProgressEvent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { drawCommonProgressbar() }</code> </pre><br>  Note that when loading data to the server, an event handler must be hung on the xhr.upload property, and when loading data from the server, on xhr itself. <br><br>  In browsers that support the File API, the size of the files can be obtained from the File object.  In older specifications, the property was called fileSize, and now just size. <br><br>  In browsers without File API support (and there are less and less of them), we are degrading before using the internal file sizing service. <br><br>  By the way, with the transition to new technologies, we were able to implement our long-standing idea: drag-and-drop upload attachments.  The drag-and-drop API is very common.  It concerns not only files, but any drag and drop of objects on the page.  Accordingly, absolutely everything can be moved to the file area. <br><br>  We had to solve this problem: how to leave in the mail only the ability to download files? <br><br>  Much does the browser itself, but not all.  In the drop event in the event.dataTransfer.files property, of course, there will be only objects from the file system.  But these objects can be both folders and files.  To prevent downloading folders (not all browsers can load files from folders - <a href="http://updates.html5rocks.com/2012/07/Drag-and-drop-a-folder-onto-Chrome-now-available">Chrome 21</a> was the first, and Firefox <a href="https://hacks.mozilla.org/2012/07/why-no-filesystem-api-in-firefox/">refused</a> to do it with the principle) we use FileReader.  This API allows you to read a file from disk and work with it in JavaScript.  And if the object is read, then this is a file.  A small function that implements this method can be found on <a href="https://github.com/doochik/check-if-i-drop-folder">GitHub</a> . <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isRegularFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,  4,     if (file.size &gt; 4096) { callback(true); return; } if (!window['FileReader']) { //   callback(null); } else { try { var reader = new FileReader(); reader.onerror = function() { reader.onloadend = reader.onprogress = reader.onerror = null; // Chrome (Linux/Win), Firefox (Linux/Mac), Opera 12.01 (Linux/Mac/Win) callback(false); }; reader.onloadend = reader.onprogress = function() { reader.onloadend = reader.onprogress = reader.onerror = null; //   abort     if (e.type != 'loadend') { //      reader.abort(); } callback(true); }; reader.readAsDataURL(file); } catch(e) { // Firefox/Win callback(false); } } }</span></span></code> </pre><br>  However, this check is not needed for all browsers - Chrome for Mac and IE10 for Windows 8 themselves filter out folders. <br><br>  You should be very careful with FileReader, especially in Chrome, which is not stable: up to the 21st version there were tab drops when reading a file of several hundred megabytes, and in the 21st it began to fall on small files.  We even had to stop using FileReader for this browser. <br><br>  Among other things, we have slightly modified the logic of the appearance of the area for dragging files.  Here again, the problem arose: the user can drag the label onto the letter or, for example, accidentally start dragging a picture from the interface. <br><br>  To solve this problem in the dragover and dragenter handlers, we did the following check: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> types = event.dataTransfer.types; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (types) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = types.length; i &lt; j; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (types[i] == <span class="hljs-string"><span class="hljs-string">'Files'</span></span>) { showDragArea(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre><br>  The ‚ÄúFiles‚Äù type means that there are real files in the dragged objects, and ‚Äúreturn false‚Äù - the beginning of the <a href="https://developer.mozilla.org/en-US/docs/DragDrop/Drag_Operations">drag and drop</a> process.  This check does not work in all browsers, but slightly improves the interface. <br><br>  It also turned out that dragenter, dragover and dragleave events, if you hang them on a document, are subject to the same problems as mouseover, mouseout: they are thrown every time you move between DOM nodes. <br><br>  The problem was solved by a timeout for handling these events. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> processTimer = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; $(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>).on({ <span class="hljs-string"><span class="hljs-string">'dragover dragenter'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.clearTimeout(processTimer); showDragArea(); }. <span class="hljs-string"><span class="hljs-string">'dragleave'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ processTimer = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ hideDragArea(); }, <span class="hljs-number"><span class="hljs-number">50</span></span>); } });</code> </pre><br><h1>  Cross Domain Queries </h1>  To upload to the Disk, support for cross-domain queries was needed, which can be checked as follows: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>[<span class="hljs-string"><span class="hljs-string">'XMLHttpRequest'</span></span>] &amp;&amp; <span class="hljs-string"><span class="hljs-string">'withCredentials'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest()</code> </pre><br>  The definition of transport policy remains the same. <br><br>  For cross-domain queries, it is necessary to do the correct processing of the ‚Äúpreflight‚Äù OPTIONS requests.  In these requests, the browser asks the remote server if it can be accessed from the current domain.  They look like this: <br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">OPTIONS</span></span> /upload HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> Host: disk-storage42.mail.yandex.net Origin: https://mail.yandex.ru Access-Control-Request-Method: POST Access-Control-Request-Headers: origin, content-type</code> </pre><br>  To this, the server must respond with permissive headers, for example, like this: <br><pre> <code class="nginx hljs">Access-Control-Allow-Origin: https://mail.yandex.<span class="hljs-attribute"><span class="hljs-attribute">ru</span></span> Allow: POST, PUT, TRACE, OPTIONS</code> </pre><br>  Such requests do not always occur, but they must be remembered and verified that they are processed correctly. <br><br>  If the browser does not receive permission for a cross-domain request, the request will end with status = 0 (this can be processed in onreadystatechange).  It may also mean that the request was interrupted by the user or server.  In any case, it is worth making a fallback to the iframe download. <br><br>  The process of uploading files to Yandex.Disk itself looks like this: first, a request is made in which the Disk backend returns us the url for which the file should be uploaded to the repository, as well as the oid (operation id) for which you can request the status of the operation.  Downloading is not a synchronous operation, and the end of sending a file from the client does not mean that the file is ready on the server, it must be saved in the right place, checked by antivirus, written to the database. <br><br>  If there is support for progress events, then the status of the operation is not requested until the file download is completed, and the progress bar is drawn by the browser.  This allows you to significantly reduce the load on the server and draw a smoother progress. <br><br>  If progress events are not supported, we request the download status every one or two seconds until the server says that the file is ready. <br><br><h1>  Success </h1>  In our opinion, the game was worth the candle.  We are completely satisfied with the current solution, including because we solved a number of problems without losing the advantages that the flash has: <br><ul><li>  eliminated "underwater knocks" - problems of users with sending emails and downloading attachments; </li><li>  refused to use the flash; </li><li>  subjectively - reduced the time that users spent on sending letters with attachments; </li><li>  twice increased the number of file downloads on the disk compared with the people. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/154151/">https://habr.com/ru/post/154151/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154131/index.html">Like-A-Hug vest integrated with Facebook embraces while getting likes</a></li>
<li><a href="../154133/index.html">Introduction to working with AppHarbor - a cloud for ASP.NET applications</a></li>
<li><a href="../154139/index.html">Surprisingly simple but beautiful CSS effect.</a></li>
<li><a href="../154141/index.html">HP Dynamic VPN technology. Part 1</a></li>
<li><a href="../154149/index.html">Digest news JetBrains from September 11 to October 9</a></li>
<li><a href="../154155/index.html">Lecture number 02: MSP430. Cities and Registers</a></li>
<li><a href="../154165/index.html">The future of the process, or when the law of Moore "die"?</a></li>
<li><a href="../154167/index.html">Optimize complex MySQL queries</a></li>
<li><a href="../154169/index.html">Using the capabilities of Wolfram Mathematica in .NET applications</a></li>
<li><a href="../154177/index.html">TeamLab - reboot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>