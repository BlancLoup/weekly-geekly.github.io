<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET in an unmanaged environment: platform invoke or what LPTSTR is</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The technique is the same - a minimum of explanations, a maximum of recipes. For a deep understanding of the processes taking place, I recommend to re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET in an unmanaged environment: platform invoke or what LPTSTR is</h1><div class="post__text post__text-html js-mediator-article">  The technique is the same - a minimum of explanations, a maximum of recipes.  For a deep understanding of the processes taking place, I recommend to refer to the <a href="http://msdn.microsoft.com/ru-ru/library/fzhhdwae.aspx">documentation in MSDN</a> - this section has already been translated into Russian. <br><a name="habracut"></a><br><h1>  Strings and enums </h1><br><br>  We will learn from concrete examples.  Naturally, as is customary, we begin with the simplest application - hello, world!  To display this text, we interpose the MessageBox function from WinAPI, using which we will examine in detail the strings and the encoding using an example. <br><br>  So, who said MessageBox.Show?  I do not like your pink blouse, your boobs and your microphone, got up and went away.  Come back with smart tips when we marshall the arrays of structures.  So that the others do not have temptations, we will work within the framework of the console project, without connecting Windows.Forms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, example one, trivial.  We create a static class, write the definition of a function with extern, indicate what kind of function we want to get, and then everything is exactly the same as in my previous article - we define the marshalling parameters with the appropriate attributes. <br><br><blockquote><code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> PInvoke <br> { <br> [DllImport( <font color="#A31515">"User32.dll"</font> , EntryPoint= <font color="#A31515">"MessageBox"</font> , CharSet=CharSet.Auto)] <br> <font color="#0000ff">public</font> <font color="#0000ff">extern</font> <font color="#0000ff">static</font> <font color="#0000ff">int</font> MsgBox( <br> [MarshalAs(UnmanagedType.I4)] <font color="#0000ff">int</font> hwnd, <br> [MarshalAs(UnmanagedType.LPTStr)] <font color="#0000ff">string</font> text, <br> [MarshalAs(UnmanagedType.LPTStr)] <font color="#0000ff">string</font> caption, <br> [MarshalAs(UnmanagedType.U4)] <font color="#0000ff">uint</font> type); <br> }</font></code> </blockquote> <br><br>  Attention should be paid to the task EntryPoint and CharSet.  EntryPoint is the exported name of the function we want to call, and CharSet is the encoding used.  If you are a little familiar with WinAPI, then you know that most of the functions have two versions - ANSI and Unicode.  The first ones chew and issue ANSI strings, the second, respectively, Unicode.  They differ by the suffix - for example, the MessageBox function that works with Unicode strings (which, by the way, we call) in the library is named MessageBoxW.  However, a smart .NET Marshalller knows about this WinAPI feature (I wondered if he didn‚Äôt), and therefore, when processing the DllImport attribute, it automatically substitutes the suffix depending on the encoding. <br><br>  However, we can specify the encoding used directly.  For example: <br><blockquote> <code><font color="black">[DllImport( <font color="#A31515">"User32.dll"</font> , EntryPoint= <font color="#A31515">"MessageBoxA"</font> , CharSet=CharSet.ANSI)]</font></code> </blockquote> <br><br>  Here we work with ANSI-coding.  However, by raising the window with the messagebox, which is defined in this way, you will see that only the first characters are left from the transmitted lines.  What is the matter? <br><br>  The point is in the marshalling of the rows, or rather in the LPTStr type.  Let us dwell on it in more detail. <br><br>  The fact is that in C ++, in contrast to C #, where its majesty reigns supreme, there are also ANSI strings.  In C ++ terms, the type used for the ANSI string is called LPSTR (long pointer to string), the Unicode string is LPWSTR (long pointer to wide string), and LPTSTR is a special type that is defined as follows: <br><br><blockquote> <code>#ifdef UNICODE <br> typedef LPCWSTR LPCTSTR; <br> #else <br> typedef LPCSTR LPCTSTR; <br> #endif</code> </blockquote> <br><br>  That is, depending on how we compile, we have this or that type of string substituted - either Unicode or ANSI.  This was done in order to ensure compatibility at the code level with OS versions that do not support Unicode.  Now it certainly looks like an atavism, but Microsoft has to drag this solution for compatibility with older versions. <br><br>  And what is LPTStr in .NET?  MSDN helpfully suggests that this type is equivalent to either LPStr for Windows 98, or LPWStr for Windows NT and later.  Thus, theoretically, the function defined in this way will work in Windows 98. However, if we recall that only version 1.1 of the framework is available for Win98, then everything that I wrote can be thrown out of my head, and always marshall functions like Unicode in the following way: <br><br><blockquote> <code><font color="black"><font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> PInvoke <br> { <br> [DllImport( <font color="#A31515">"User32.dll"</font> , EntryPoint= <font color="#A31515">"MessageBox"</font> , CharSet=CharSet.Unicode)] <br> <font color="#0000ff">public</font> <font color="#0000ff">extern</font> <font color="#0000ff">static</font> <font color="#0000ff">int</font> MsgBox( <br> [MarshalAs(UnmanagedType.I4)] <font color="#0000ff">int</font> hwnd, <br> [MarshalAs(UnmanagedType.LPWStr)] <font color="#0000ff">string</font> text, <br> [MarshalAs(UnmanagedType.LPWStr)] <font color="#0000ff">string</font> caption, <br> [MarshalAs(UnmanagedType.U4)] <font color="#0000ff">uint</font> type); <br> }</font></code> </blockquote> <br><br>  Well, if you suddenly come across a tricky library that only understands Ansi - calmly prescribe CharSet.Ansi and use LPStr for strings.  That's all the magic. <br><br>  By the way, EntryPoint can also not be set - by default it is equivalent to the function name that you specify in the code, so if they match, then ignore this parameter. <br><br>  If the function takes an enumeration as an input parameter (for example, the MessageBox has a type parameter), then you can define the corresponding enum in C #, inheriting it from the desired type, and pass it as a parameter, for example, <br><br><blockquote> <code><font color="black">[Flags] <br> <font color="#0000ff">public</font> <font color="#0000ff">enum</font> MBoxStyle : <font color="#0000ff">uint</font> <br> { <br> MB_OK = 0, <br> MB_OKCANCEL = 1, <br> MB_RETRYCANCEL = 2, <br> MB_YESNO = 4, <br> MB_YESNOCANCEL = 8, <br> MB_ICONEXCLAMATION = 16, <br> MB_ICONWARNING = 32, <br> MB_ICONINFORMATION = 64 ... <br> } <br> <br> [DllImport( <font color="#A31515">"User32.dll"</font> , EntryPoint= <font color="#A31515">"MessageBox"</font> , CharSet=CharSet.Unicode)] <br> <font color="#0000ff">public</font> <font color="#0000ff">extern</font> <font color="#0000ff">static</font> <font color="#0000ff">int</font> MsgBox( <br> [MarshalAs(UnmanagedType.I4)] <font color="#0000ff">int</font> hwnd, <br> [MarshalAs(UnmanagedType.LPWStr)] <font color="#0000ff">string</font> text, <br> [MarshalAs(UnmanagedType.LPWStr)] <font color="#0000ff">string</font> caption, <br> [MarshalAs(UnmanagedType.U4)] MBoxStyle type);</font></code> </blockquote> <br><br>  Now we can use not numeric constants, but a normal enum. <br><br>  In order to determine the string returned from the function, simply write out or ref to the function parameter.  However, there is one trick here that many functions require a fixed-size buffer to return rows.  So, for example, the GetWindowText function, which is defined as follows: <br><br><blockquote> <code>int GetWindowText(HWND hWnd, LPTSTR lpString, INT nMaxCount);</code> </blockquote> <br><br>  When you call a function from C ++, something like this is done: <br><br><blockquote> <code>const int BUFF_SIZE = 200; <br> LPTSTR buff = new TCHAR[BUFF_SIZE]; <br> GetWindowText(hwnd, buff, BUFF_SIZE);</code> </blockquote> <br><br>  The GetWindowText function fills the received buffer with the required data, and with the help of nMaxCount ensures that the buffer does not overflow. <br><br>  If we try to use the standard methodology: <br><br><blockquote> <code><font color="black">[DllImport( <font color="#A31515">"User32.dll"</font> , EntryPoint = <font color="#A31515">"GetWindowText"</font> , CharSet = CharSet.Unicode)] <br> <font color="#0000ff">public</font> <font color="#0000ff">extern</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> GetWindowText( <font color="#0000ff">int</font> hWnd, [MarshalAs(UnmanagedType.LPWStr)] <font color="#0000ff">ref</font> <font color="#0000ff">string</font> lpString, <font color="#0000ff">int</font> nMaxCount);</font></code> </blockquote> <br><br>  That attempt to call such a function will result in failure.  The fact is that strings in C # are fundamentally unchangeable - with any operation, like concatenation, searching for a substring, and the like, a new object is created in memory.  Then how to be? <br><br>  Exit - use StringBuilder. <br><br><blockquote> <code><font color="black">[DllImport( <font color="#A31515">"User32.dll"</font> , EntryPoint = <font color="#A31515">"GetWindowText"</font> , CharSet = CharSet.Unicode)] <br> <font color="#0000ff">public</font> <font color="#0000ff">extern</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> GetWindowText( <font color="#0000ff">int</font> hWnd, [MarshalAs(UnmanagedType.LPWStr)] <font color="#2B91AF">StringBuilder</font> lpString, <font color="#0000ff">int</font> nMaxCount);</font></code> </blockquote> <br><br>  And call the function as follows: <br><br><blockquote> <code><font color="black"><font color="#2B91AF">StringBuilder</font> sb = <font color="#0000ff">new</font> <font color="#2B91AF">StringBuilder</font> (256); <br> PInvoke.GetWindowText(handle, sb, sb.Capacity); <br></font></code> </blockquote><br><br>  By the way, if you pay attention, then the StringBuilder object has no ref modifier.  It is not needed - the fact is that the .NET Marshalller understands that in such situations StringBuilder is used for the return value. <br><br>  Marshalling the return value of a function is done in the same way as I showed in the previous article - setting the attribute [return: MarshalAs (...)]. <br><br><h1>  Structures and unions. </h1><br><br>  When marshalling structures, they must be aligned (LayoutKind.Sequential). <br><br>  If the structure has a string buffer of a fixed length, then the marshalller should specifically indicate this, otherwise the structure will ‚Äúsprawl‚Äù in memory and you will get at the output what that line is. <br><br>  Consider both of these rules on the example of the function GetVersionEx.  Its full definition in C ++ is as follows: <br><br><blockquote> <code>typedef struct _OSVERSIONINFO <br> { <br> DWORD dwOSVersionInfoSize; <br> DWORD dwMajorVersion; <br> DWORD dwMinorVersion; <br> DWORD dwBuildNumber; <br> DWORD dwPlatformId; <br> TCHAR szCSDVersion[128]; <br> } OSVERSIONINFO; <br> <br> BOOL GetVersionEx(LPOSVERSIONINFO lpVersionInfo);</code> </blockquote> <br><br>  So, we see that the structure contains a fixed-length string buffer.  Accordingly, our actions will be such.  Determine the structure <br><br><blockquote> <code><font color="black">[StructLayout(LayoutKind.Sequential)] <br> <font color="#0000ff">public</font> <font color="#0000ff">struct</font> OSVERSIONINFO <br> { <br> [MarshalAs(UnmanagedType.I4)] <font color="#0000ff">public</font> <font color="#0000ff">int</font> dwOSVersionInfoSize; <br> [MarshalAs(UnmanagedType.I4)] <font color="#0000ff">public</font> <font color="#0000ff">int</font> dwMajorVersion; <br> [MarshalAs(UnmanagedType.I4)] <font color="#0000ff">public</font> <font color="#0000ff">int</font> dwMinorVersion; <br> [MarshalAs(UnmanagedType.I4)] <font color="#0000ff">public</font> <font color="#0000ff">int</font> dwBuildNumber; <br> [MarshalAs(UnmanagedType.I4)] <font color="#0000ff">public</font> <font color="#0000ff">int</font> dwPlatformId; <br> [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)] <font color="#0000ff">public</font> <font color="#0000ff">string</font> szCSDVersion; <font color="#008000">//    </font> <br> }</font></code> </blockquote> <br><br>  And a function. <br><blockquote> <code><font color="black">[DllImport( <font color="#A31515">"kernel32"</font> , EntryPoint = <font color="#A31515">"GetVersionEx"</font> , CharSet=CharSet.Unicode)] <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">extern</font> <font color="#0000ff">bool</font> GetVersionEx2( <font color="#0000ff">ref</font> OSVERSIONINFO osvi);</font></code> </blockquote> <br><br>  However, besides structures in C ++, there is such a thing as a union.  Combining is when the same amount of binary data in memory is interpreted differently, depending on some external or internal factors.  The most famous type of union is the type VARIANT. <br><br>  Combinations are good because they save memory while maintaining the enormous flexibility of the internal representation. <br><br>  In .NET, you can also create a join.  It will look like this - in the StructLayout attribute, we set the LayoutKind.Explicit parameter, which says that we ourselves determine how the structure is placed in memory, and we specify the offset of each field in bytes from the beginning of the structure. <br><blockquote> <code><font color="black">[StructLayout(LayoutKind.Explicit)] <br> <font color="#0000ff">public</font> <font color="#0000ff">struct</font> TestStruct <br> { <br> [FieldOffset(0)] <br> <font color="#0000ff">public</font> <font color="#0000ff">int</font> a; <br> [FieldOffset(0)] <br> <font color="#0000ff">public</font> <font color="#0000ff">float</font> b; <br> }</font></code> </blockquote> <br><br>  This thing looks wildly funny. <br><br><blockquote> <code><font color="black">TestStruct s = <font color="#0000ff">new</font> TestStruct(); <br> sb = 5.2f; <br> <font color="#2B91AF">Console</font> .WriteLine(sb); <br> <font color="#2B91AF">Console</font> .WriteLine(sa); <br> sa = 99; <br> <font color="#2B91AF">Console</font> .WriteLine(sb); <br> <font color="#2B91AF">Console</font> .WriteLine(sa); <br> <font color="#2B91AF">Console</font> .ReadLine();</font></code> </blockquote> <br><br>  The result of the program: <br><br> <code>5,2 <br> 1084647014 <br> 1,387285E-43 <br> 99</code> <br> <br>  It would seem that the problem with associations was solved, but it was not there.  Attempting to add a reference type to the join (for example, a string) <br><br><blockquote> <code><font color="black">[StructLayout(LayoutKind.Explicit)] <br> <font color="#0000ff">public</font> <font color="#0000ff">struct</font> TestStruct <br> { <br> [FieldOffset(0)] <br> <font color="#0000ff">public</font> <font color="#0000ff">int</font> a; <br> [FieldOffset(0)] <br> <font color="#0000ff">public</font> <font color="#0000ff">float</font> b; <br> [FieldOffset(0)] <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> c; <br> }</font></code> </blockquote> <br><br>  You will get a deafening ‚Äúboom‚Äù on the head. <br><br>  <strong>Could not load type 'TestStruct' from assembly 'TestPInvoke, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = null' it can be corrected by the non-object field.</strong> <br><br>  The problem is that the reference fields in memory are arranged as pointers.  Overlapping (overlap) a pointer with a type-value, we get the possibility of memory manipulation.  For example, so. <br><br><blockquote> <code><font color="black">sc = <font color="#A31515">""</font> ; <br> sa = 0xA000; <br> <font color="#2B91AF">Console</font> .WriteLine(sc);</font></code> </blockquote> <br><br>  In this case, the contents of the memory at 0xA000 to the first double zero would be displayed on the screen.  Using as a reference type a class containing value types (for example, int), we can manipulate memory directly.  Naturally, this disgrace CLR can not allow, and therefore such actions are clearly prohibited. <br><br>  What to do?  Starting to beat your head against the wall, because the only way out is to define as many types of structures as necessary so that all field-values ‚Äã‚Äãdo not overlap with reference fields, and to call functions use overload with fortune telling on coffee grounds, what kind of result will return us function.  Horror.  Scary horror.  Therefore, whenever possible, avoid such associations where the reference fields are adjacent to the value fields.  And if it doesn't work out - study MSDN, this topic is too big for our review. <br><br><h1>  Work with HANDLE. </h1><br><br>  Many WinAPI functions require or return HANDLE.  To put it simply, HANDLE is a pointer to an object of the OS kernel, and in fact it is a four-byte integer that remains unchanged from the moment we request the object to the moment we release it. <br><br>  To work with HANDLE in C #, the SafeHandle class is intended.  However, passing this class directly to functions via p / invoke is not possible.  We'll have to dodge. <br><br>  Let's take as an example the function SetSecutiryInfo ( <a href="http://msdn.microsoft.com/en-us/library/aa379588(VS.85).aspx">function description on MSDN</a> ).  While not paying attention to all sorts of left-wing things, let's focus on the main thing. <br><br><blockquote> <code><font color="black">[DllImport( <font color="#A31515">"advapi32.dll"</font> , SetLastError = <font color="#0000ff">true</font> , CallingConvention = CallingConvention.Winapi)] <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">extern</font> <font color="#2B91AF">Int32</font> SetSecurityInfo <br> ( <br> <font color="#2B91AF">IntPtr</font> handle, <br> SE_OBJECT_TYPE ObjectType, <br> SECURITY_INFORMATION SecurityInfo, <br> <font color="#2B91AF">IntPtr</font> psidOwner, <br> <font color="#2B91AF">IntPtr</font> psidGroup, <br> <font color="#2B91AF">IntPtr</font> pDacl, <br> <font color="#2B91AF">IntPtr</font> pSacl <br> );</font></code> </blockquote> <br><br>  The scenario of working with SafeHandle is demonstrated on the example of FileStream. <br><br><blockquote> <code><font color="black"><font color="#2B91AF">FileStream</font> fs = <font color="#0000ff">new</font> <font color="#2B91AF">FileStream</font> ( <font color="#A31515">"c:\test.txt"</font> ); <br> <font color="#0000ff">bool</font> success = <font color="#0000ff">false</font> ; <br> <font color="#008000">//     -    GC     .</font> <br> fs.SafeFileHandle.DangerousAddRef( <font color="#0000ff">ref</font> success); <br> <font color="#0000ff">if</font> (success) <br> { <br> <font color="#008000">//  handle  IntPtr</font> <br> <font color="#2B91AF">IntPtr</font> h = fs.SafeFileHandle.DangerousGetHandle(); <br> <font color="#008000">//  native-</font> <br> PInvoke.SetSecutiryInfo(h, &lt; &gt;); <br> <font color="#008000">//  handle        -   .</font> <br> fs.SafeFileHandle.DangerousRelease(); <br> } <br> <font color="#0000ff">else</font> <br> { <br> <font color="#008000">//  HANDLE,  .</font> <br> }</font></code> </blockquote> <br><br>  The script should be executed up to a line of code.  Work with unmanaged-resources requires accuracy and accuracy in order to prevent memory leak. <br><br>  Here we are faced with two previously unknown parameters of the DllImport attribute.  The first - SetLastError when set to true allows, in case of an error, to save its code, after which it can be obtained using Marshal.GetLastWin32Error.  If the description of the function says that the error value can be obtained via GetLastError, then this flag should be set.  The second, CallingConvention, establishes a function call convention - PASCAL (aka stdcall, aka WinApi) or cdecl.  The only difference is who clears the stack ‚Äî the calling code or the called function.  All WinAPI functions use the stdcall convention. <br><br>  However, the article has already outgrown all imaginable limits and I have to stop.  Outside of our consideration were such interesting things as manual parsing of structures from IntPtr and back, wrapping returned from HANDLE, GlobalAlloc and buffers, complex data types and manual marshalling using the Marshall class.  Honestly, this topic seems to me to be too specific for the audience of Habr, so I most likely will not consider it.  These methods are quite sufficient for most typical tasks that require p / invoke, but if you get a more complicated task, then MSDN will have to do it. <br><br>  UPD: From the audience suggest that on Win98 it is possible to install .NET up to version 2.0, which does not change much, but nevertheless, it is worth noting this fact. </div><p>Source: <a href="https://habr.com/ru/post/58582/">https://habr.com/ru/post/58582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../58571/index.html">The hunt for viruses in the clouds</a></li>
<li><a href="../58572/index.html">Happy birthday, Mandriva Linux 2009.1!</a></li>
<li><a href="../58575/index.html">Personal time management</a></li>
<li><a href="../58579/index.html">Conference "Site-2009"</a></li>
<li><a href="../58580/index.html">Why don't you love them?</a></li>
<li><a href="../58584/index.html">Blogs for your children</a></li>
<li><a href="../58585/index.html">New e-paper type created</a></li>
<li><a href="../58586/index.html">Freedom, equality, piracy!</a></li>
<li><a href="../58591/index.html">HFS is a small and convenient HTTP file server.</a></li>
<li><a href="../58595/index.html">Yslow 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>