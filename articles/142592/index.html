<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Perlin Noise</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. I bring to your attention the translation of the article about Perlin noise ( this one ). Links to this article already flashed on Habr√© ( h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Perlin Noise</h1><div class="post__text post__text-html js-mediator-article">  Good day.  I bring to your attention the translation of the article about Perlin noise ( <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">this one</a> ).  Links to this article already flashed on Habr√© ( <a href="http://habrahabr.ru/post/128368/">here</a> ), but I did not get a translation of the article.  So I hope someone can be useful. <br><br>  Many people had to use random number generator in programs to create unpredictability, to make the movement and behavior of objects more natural or generate textures.  Random number generators, of course, have their own uses, but sometimes their output can be too ‚Äúhard‚Äù to seem natural.  In this article, we present a feature that has a very wide range of applications, more than I could think, but mostly wherever you need something to look natural.  In addition, the output can be easily customized to your needs. <br><br>  If you look at many things in nature, you will notice that they are fractal.  They have different levels of detail.  A typical example is the outline of a mountain range.  It contains significant differences in altitude (mountains), medium variations (hills), small variations (boulders), tiny variations (stones), and so on.  Look at anything: spreading grass spots on the field, waves in the sea, the movement of ants, the movement of the branches of a tree, patterns of marble, wind.  All these phenomena lend themselves to the same pattern, in large and small variations.  The Perlin noise function recreates this by simply folding the noise functions at various scales. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To create the Perlin noise function, you need two things, the noise function and the interpolation function. <br><a name="habracut"></a><br><h4>  Noise function </h4><br>  The noise function is essentially a random number generator sample.  It takes an integer as a parameter, and returns a random number based on this parameter.  If you pass the same parameter twice, it will give the same number twice.  It is very important that she behaves in this way, otherwise there will be no sense from her. <br><br>  Here is a graph showing an example of the noise function. A random value from 0 to 1 is assigned to each point on the X axis. <br><img src="https://habrastorage.org/getpro/habr/post_images/11f/cc4/ffe/11fcc4ffea96d84d6209bfa729b1dc9e.gif" alt="image"><br>  By smooth interpolation between values, we can define a continuous function that takes a non-integer as a parameter. <br><img src="https://habrastorage.org/getpro/habr/post_images/8c7/584/ed8/8c7584ed8a03db9563cca27c39381bf6.gif" alt="image"><br>  Different ways of interpolating values ‚Äã‚Äãwill be later in this article. <br><br><h4>  Definitions </h4><br>  Before I go any further, let me determine what I mean by amplitude and frequency.  If you studied physics, you could well meet the concept of amplitude and frequency as applied to a sine-wave. <br><br><h5>  Sine wave </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/330/298/456/330298456af00711319fe45284aa1932.gif" alt="image"><br>  (amplitude - amplitude, wavelength - wavelength, frequency - frequency) <br>  Wavelength is the distance from one vertex to another.  The amplitude is the height of the wave.  Frequency is defined as 1 / (wavelength). <br><h5>  Noise wave </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/bfb/6f6/24a/bfb6f624a672f4584ae6187dc2906a1a.gif" alt="image"><br>  On the graph of this noise function, for example, red dots indicate random values ‚Äã‚Äãdetermined from the dimension of the function. <br>  In this case, the amplitude is the difference between the minimum and maximum values ‚Äã‚Äãthat the function may have.  The wavelength is the distance from one red spot to another.  Again, the frequency is defined as 1 / (wavelength). <br><h4>  Creating the Perlin Noise Function </h4><br>  Now, if you take a lot of such smooth functions, with different frequency and amplitude, you can add them all together to create a well-noisy function.  This is the Perlin noise function. <br>  Take the following noise function <br><img src="https://habrastorage.org/getpro/habr/post_images/ba4/2ba/dfb/ba42badfb55be162a15c6e5ac061922b.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/03a/e99/2b4/03ae992b4a48f12bb2460a5319e9aa25.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/f89/644/566/f89644566040c04692e9df44491092bb.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/383/a7d/709/383a7d709fcf1c02ca03e26b3bba52c8.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/c8d/865/753/c8d865753b985f626f3409decda8e5af.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/8d3/c91/60c/8d3c9160c33d475263a71dd07ddacae7.gif" alt="image"><br>  Match them together and that's what you get in the end. <br><img src="https://habrastorage.org/getpro/habr/post_images/c82/f0e/8b1/c82f0e8b15ba8cf7b6e7e497b960ead2.gif" alt="image"><br>  You can see that this feature has large, medium and small variations.  You can even imagine that it looks a bit like a mountain range.  In fact, many computer landscapes are made using this method.  Of course they use the 2D noise I received at the moment. <br>  You, of course, can do the same for two dimensions.  Some noise functions in 2D <br><img src="https://habrastorage.org/getpro/habr/post_images/58f/d85/b67/58fd85b673e5294f9ab2b9ccf8159e82.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/dc0/d7f/016/dc0d7f0165ae235b122b5c81cf7c4cd2.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/comment_images/5e1/48f/e1f/5e148fe1f4484cbf731a095dd2b42176.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/273/3e8/cb62733e8f9dd162ff8bc9974945b5cf.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/886/ef8/41d/886ef841dd4e5f80034e6d91a56cb30d.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/59d/c65/7b0/59dc657b051cac5ee980ba6422a64078.jpg" alt="image"><br>  Putting all these functions together we get a noise picture. <br><img src="https://habrastorage.org/getpro/habr/comment_images/c71/254/759/c712547595eb8a222c29e4595e0bfba1.jpg" alt="image"><br><h4>  Persistence </h4><br>  When you add these noise functions together, you may wonder what exactly the amplitude and frequency is used for each of them.  In the one-dimensional example, the frequency and half amplitude are used twice for each subsequent added noise function.  This is quite common.  Thus, in fact, many people do not even consider using the rest.  However, you can create noise Perlin functions with different characteristics and using different frequencies and amplitudes at each step.  For example, to create smooth hills, you can use the Perlin noise function with large amplitudes at low frequencies, and very small amplitudes at high frequencies.  Or you could make a flat, but very rocky plane by choosing small amplitudes for low frequencies. <br>  To explain it more simply, and to avoid repeating the words ‚Äúamplitude‚Äù and ‚Äúfrequency‚Äù all the time, a single number is used to determine each amplitude and each frequency.  This value is called persistence.  There is some uncertainty about its exact meaning.  This term was originally coined by Mandelbrot, one of those who are behind the discovery of fractals.  He identified noise with a lot of high frequencies with low durability.  My friend Matt also came up with the concept of perseverance, but determined it the other way around.  Honestly, I prefer the definition of Matt. <br>  Sorry, Mandelbrot. <br>  Thus, our definition of perseverance is as follows: <br><pre><code class="tex hljs">frequency() = 2^i amplitude() = persistence()^i</code> </pre> <br>  Where i is the i-th noise function added. <br>  To illustrate the effect of perseverance on the output of Perlin noise, take a look at the diagrams below. <br>  They show the noise component of the function that is added, the effect of storing the value, and, as a consequence, the Perlin noise function. <br><br><h5>  resistance = 1/4 </h5><br>  frequencies: 1, 2, 4, 8, 16, 32 <br><img src="https://habrastorage.org/getpro/habr/post_images/f27/efc/9c4/f27efc9c42986744c4100c9612955f63.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/14f/7c0/3e3/14f7c03e3ec0355194b8a11643699d95.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/20a/4d8/45f/20a4d845fe95ab2a5130c0cf98e29d1a.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/1c2/680/e7a/1c2680e7ae3867752b8e0efa82c3c04d.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/2f4/cf8/19a/2f4cf819a5461e7c1072131c14fbd57a.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/2f4/cf8/19a/2f4cf819a5461e7c1072131c14fbd57a.gif" alt="image">  = <img src="https://habrastorage.org/getpro/habr/post_images/a0b/0a7/3cf/a0b0a73cf4b2d84b8613e0d78a075c10.gif" alt="image"><br>  Amplitudes: 1, 1/4, 1/16, 1/64, 1/256, 1/1024 <br><br><h5>  resistance = 1/2 </h5><br>  frequencies: 1, 2, 4, 8, 16, 32 <br><img src="https://habrastorage.org/getpro/habr/post_images/f27/efc/9c4/f27efc9c42986744c4100c9612955f63.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/e80/29d/ee0/e8029dee039fe9c25670b7527e340cff.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/122/2b9/862/1222b98623abace6ea295eb789e19b1d.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/885/b77/f15/885b77f151f36c8838c16fe4b8c1f357.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/2e1/6fc/b3d/2e16fcb3d192cab31a2063164536ca1f.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/f51/b85/6ba/f51b856bafce23c409a8db69a19222ef.gif" alt="image">  = <img src="https://habrastorage.org/getpro/habr/post_images/572/2d9/936/5722d99368189f74031fe7f11906cd0e.gif" alt="image"><br>  Amplitudes: 1, 1/2, 1/4, 1/8, 1/16, 1/32 <br><br><h5>  resistance = 1 / root2 </h5><br>  frequencies: 1, 2, 4, 8, 16, 32 <br><img src="https://habrastorage.org/getpro/habr/post_images/f27/efc/9c4/f27efc9c42986744c4100c9612955f63.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/9e5/bdb/be4/9e5bdbbe437d438f0b19b9ce3df19b92.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/ed8/00a/ab0/ed800aab013c87095dfbae8a5d4b9793.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/f14/7f0/b04/f147f0b049c2e1164c74d3c1aff2fb91.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/428/c6a/4a0/428c6a4a06e16e69e9cb433d39c4d6c9.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/69b/9c5/0f1/69b9c50f1ed00091765916d2ed3bd939.gif" alt="image">  = <img src="https://habrastorage.org/getpro/habr/post_images/7a4/ba3/ba7/7a4ba3ba72dd0d50f645290423c501d9.gif" alt="image"><br>  Amplitudes: 1, 1 / 1.414, 1/2, 1 / 2.828, 1/4, 1 / 5.656 <br><br><h5>  resistance = 1 </h5><br>  frequencies: 1, 2, 4, 8, 16, 32 <br><img src="https://habrastorage.org/getpro/habr/post_images/f27/efc/9c4/f27efc9c42986744c4100c9612955f63.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/73f/468/f9e73f46894f7b6365e081921b12051c.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/90a/9c6/af4/90a9c6af40234530f2e96347d19d82b3.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/b27/d82/d3e/b27d82d3edd339670bb091bea44ea1e5.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/fd3/0e7/ddcfd30e779b4ef08168161957498935.gif" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/0cc/82b/c56/0cc82bc5688b965e5ad7b842ff61749a.gif" alt="image">  = <img src="https://habrastorage.org/getpro/habr/post_images/c3e/209/f5b/c3e209f5bf139bde697d3c73609fe17d.gif" alt="image"><br>  Amplitudes: 1, 1, 1, 1, 1, 1 <br><br><h4>  Octave </h4><br>  Each subsequent noise function added is called an octave.  The reason for this is that each noise function has a frequency twice as large as the previous one.  In music, the octave also has this property. <br>  How many octaves you will add is entirely up to you.  You can add as many or as few as you want.  However, let me give you some tips.  If you use the Perlin noise function to render an image to the screen, a moment will come when the octave may have a frequency too high to be displayed.  There simply may not be enough pixels on the screen to reproduce all the fine details at a very high noise function.  Some Perlin noise implementations are automatically added up from noise functions until the screen resolution limits (or other environment) are reached. <br>  In addition, it is reasonable to stop when adding a noise function, when their amplitude becomes too small to influence the result.  When this happens will depend on the level of endurance, the overall amplitude of the Perlin function and a bit of the screen resolution (or something else). <br><br><h4>  Creating a noise function </h4><br>  What are we looking for in the noise function?  Essentially - a random number generator.  However, unlike other random number generators that you encounter in programs that give you different random numbers each time you call them, these noise functions produce a random number calculated from one or more parameters.  That is, each time you enter the same number, the noise function will respond with the same number as before for that number.  But by entering another number, it will return another number. <br>  Well, I don't know much about random number generators, so I started searching, and here is one I found.  He looked pretty good.  It returns floating-point numbers from -1.0 to 1.0. <br><pre> <code class="tex hljs"> function IntNoise(32-bit integer: x) x = (x&lt;&lt;13) ^ x; return ( 1.0 - ( (x * (x * x * 15731 + 789221) + 1376312589) &amp; 7fffffff) / 1073741824.0); end IntNoise function</code> </pre><br>  Now, you probably want several different random number generators, so I suggest making a few copies of the code above, but using slightly different numbers.  These big creepy-looking numbers are all prime numbers, so you could just use some other prime numbers of the same size.  So in order to make it easy for you to find random numbers, I wrote a small program to the list of prime numbers for you.  You can give her a starting and ending number, and she will find all the prime numbers between them.  Source code is also included, so you can easily include it in your programs to create a random prime number ( <a href="">program and code</a> ). <br>  (in <b>order not to strain the resource I spread the code, here it is completely, because there is not a lot of it</b> ) <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;iostream.h&gt; #include &lt;math.h&gt; inline long sqrt(long i) { long r,rnew=1,rold=r; do { rold=r; r=rnew; rnew = (r+(i/r)); rnew &gt;&gt;= 1; } while(rold != rnew); return rnew; } inline int isprime(long i) { long si,j; si = sqrt(i); for (j=2; (j&lt;=si); j++) { if (i%j == 0) return 0; } return 1; } void main(int argc, char *argv[]) { long i,i1,i2,f=0; if (argc &lt; 2) { cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; "Prime number finder: Hugo Elias 1998" &lt;&lt; endl &lt;&lt; "http://freespace.virgin.net/hugo.elias" &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; "Usage:" &lt;&lt; endl &lt;&lt; " primes ab &gt; primes.txt" &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; "will find all primes between a and b" &lt;&lt; endl &lt;&lt; "and will write the results to the file PRIMES.TXT" &lt;&lt; endl; return; } i1 = atol(argv[1]); i2 = atol(argv[2]); for (i=i1; i&lt;i2; i++) if (isprime(i)) { f++; if (f==16) { cout &lt;&lt; endl; f=0; } cout &lt;&lt; i &lt;&lt; " "; } }</span></span></span></span></code> </pre><br><br><h4>  Interpolation </h4><br>  After creating your noise function, you need to smooth out the values ‚Äã‚Äãit returns.  Again, you can choose any method you like, but some look better than others.  The standard interpolation functions have three inputs, a, b, the values ‚Äã‚Äãfor interpolation between them, and x, which takes values ‚Äã‚Äãfrom 0 to 1. The interpolation function returns a value between a and b depending on the value of x.  If x is 0, then a is returned, and when x = 1, then b is returned.  If x is between 0 and 1, then it returns a value between a and b. <br><br><h5>  Linear interpolation </h5><br>  It looks awful, like cheap "plasma" that many use to create landscapes.  This is a simple algorithm, though, and I suppose it would be excusable if you tried to make Perlin noise in real time. <br><pre> <code class="tex hljs">function Linear_Interpolate(a, b, x) return a*(1-x) + b*x end of function</code> </pre> <br><img src="http://freespace.virgin.net/hugo.elias/models/m_inter1.gif" alt="image"><br><br><h5>  Cosine interpolation </h5><br>  This method gives a smoother curve than linear interpolation.  This is clearly the best result and is well worth the effort if you can afford a very small loss in speed. <br><pre> <code class="tex hljs">function Cosine_Interpolate(a, b, x) ft = x * 3.1415927 f = (1 - cos(ft)) * .5 return a*(1-f) + b*f end of function</code> </pre> <br><img src="http://freespace.virgin.net/hugo.elias/models/m_inter2.gif" alt="image"><br><br><h5>  Cubic interpolation </h5><br>  This method gives very smooth results, but you pay for it in speed.  To be honest, I'm not sure that this will give much better results than the cosine interpolation, but here it is in any case at your discretion.  This is a little more complicated, so be careful.  If earlier, for the interpolation function there were three inputs, the cubic interpolation takes five.  Instead of a and b, now you need v0, v1, v2 and v3, along with x, as before. <br><img src="http://freespace.virgin.net/hugo.elias/models/m_inter4b.gif" alt="image"><br>  v0 = point to a <br>  v1 = point a <br>  v2 = point b <br>  v3 = point after b <br><pre> <code class="tex hljs"> function Cubic_Interpolate(v0, v1, v2, v3,x) P = (v3 - v2) - (v0 - v1) Q = (v0 - v1) - P R = v2 - v0 S = v1 return Px3 + Qx2 + Rx + S end of function</code> </pre> <br><img src="http://freespace.virgin.net/hugo.elias/models/m_inter4.gif" alt="image"><br><br><h4>  Smoothed noise </h4><br>  In addition to interpolation, you can also smooth out the output of the noise function to make it less random looking, as well as less area in the 2D and 3D versions.  Smoothing will do more than you expect, and everyone who has written a smoothing filter or a fire algorithm should already be familiar with this process.  Instead of just taking the values ‚Äã‚Äãof the noise function in one of the coordinates, you can take the average of this value and the value in the next coordinates.  If this is not clear, take a look at the pseudocode below. <br>  In the small diagram, the differences between the smoothed noise function and the same noise function without smoothing are illustrated. <br>  You can see that the smooth noise function is smoothed, never reaches the extremes of a smooth noise function and the frequency is about two times less.  There is little point in smoothing out the 1-dimensional noise, as this is really the only effect.  Smoothing becomes more useful in 2 or three dimensions, where the effect is to reduce the squareness of the noise. <br>  Unfortunately, it also reduces the contrast.  The smoother you make it, obviously, the noise will be flatter. <br><img src="http://freespace.virgin.net/hugo.elias/models/m_inter6.gif" alt="image"><img src="http://freespace.virgin.net/hugo.elias/models/smooth_n.gif" alt="image"><img src="http://freespace.virgin.net/hugo.elias/models/smooth_y.gif" alt="image"><br><br><h5>  1-dimensional smoothed noise </h5><br><pre> <code class="tex hljs"> function Noise(x) . . end function function SmoothNoise_1D(x) return Noise(x)/2 + Noise(x-1)/4 + Noise(x+1)/4 end function</code> </pre> <br><h5>  2-dimensional smoothed noise </h5><br><pre> <code class="tex hljs"> function Noise(x, y) . . end function function SmoothNoise_2D(x&gt;, y) corners = ( Noise(x-1, y-1)+Noise(x+1, y-1)+Noise(x-1, y+1)+Noise(x+1, y+1) ) / 16 sides = ( Noise(x-1, y) +Noise(x+1, y) +Noise(x, y-1) +Noise(x, y+1) ) / 8 center = Noise(x, y) / 4 return corners + sides + center end function</code> </pre> <br><br><h4>  Putting it all together </h4><br>  Now you know everything, so it's time to put together everything you learned and create the Perlin noise function.  Remember that these are just a few additions of the interpolations of the noise function.  Thus, Perlin noise is just a function.  You pass one or more parameters, and it responds with a number. <br>  So, here is a simple 1-dimensional function of Perlin.  The main part of the function of the Pearl is a cycle.  Each iteration of the loop adds another double octave.  Each iteration causes different noise functions, denoted Noise <sub>i</sub> .  Now you don‚Äôt actually need to write a lot of noise functions, one for each octave, as you would expect in pseudocode.  Since all the noise functions are almost the same, except for the values ‚Äã‚Äãof these three large primes, you can save the same code, but simply use a different set of prime numbers for each. <br><br><h5>  1-dimensional Perlin noise (pseudocode) </h5><br><pre> <code class="tex hljs"> function Noise1(integer x) x = (x&lt;&lt;13) ^ x; return ( 1.0 - ( (x * (x * x * 15731 + 789221) + 1376312589) &amp; 7fffffff) / 1073741824.0); end function function SmoothedNoise_1(float x) return Noise(x)/2 + Noise(x-1)/4 + Noise(x+1)/4 end function function InterpolatedNoise_1(float x) integer_X = int(x) fractional_X = x - integer_X v1 = SmoothedNoise1(integer_X) v2 = SmoothedNoise1(integer_X + 1) return Interpolate(v1 , v2 , fractional_X) end function function PerlinNoise_1D(float x) total = 0 p = persistence n = Number_Of_Octaves - 1 loop i from 0 to n frequency = 2i amplitude = pi total = total + InterpolatedNoisei(x * frequency) * amplitude end of i loop return total end function</code> </pre> <br><br>  Now you can easily apply the same code to create 2 or more dimensional Perlin noise functions. <br><h5>  2-dimensional Perlin noise (pseudocode) </h5><br><pre> <code class="tex hljs">function Noise1(integer x, integer y) n = x + y * 57 n = (n&lt;&lt;13) ^ n; return ( 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) &amp; 7fffffff) / 1073741824.0); end function function SmoothNoise_1(float x, float y) corners = ( Noise(x-1, y-1)+Noise(x+1, y-1)+Noise(x-1, y+1)+Noise(x+1, y+1) ) / 16 sides = ( Noise(x-1, y) +Noise(x+1, y) +Noise(x, y-1) +Noise(x, y+1) ) / 8 center = Noise(x, y) / 4 return corners + sides + center end function function InterpolatedNoise_1(float x, float y) integer_X = int(x) fractional_X = x - integer_X integer_Y = int(y) fractional_Y = y - integer_Y v1 = SmoothedNoise1(integer_X, integer_Y) v2 = SmoothedNoise1(integer_X + 1, integer_Y) v3 = SmoothedNoise1(integer_X, integer_Y + 1) v4 = SmoothedNoise1(integer_X + 1, integer_Y + 1) i1 = Interpolate(v1 , v2 , fractional_X) i2 = Interpolate(v3 , v4 , fractional_X) return Interpolate(i1 , i2 , fractional_Y) end function function PerlinNoise_2D(float x, float y) total = 0 p = persistence n = Number_Of_Octaves - 1 loop i from 0 to n frequency = 2i amplitude = pi total = total + InterpolatedNoisei(x * frequency, y * frequency) * amplitude end of i loop return total end function</code> </pre> <br><br>  At the end of the original article there are additional materials, who will be interested, I think it will not be difficult to proceed. <br><br>  References: <br>  <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">Actually the article itself</a> . <br>  <a href="http://mrl.nyu.edu/~perlin/">Ken Perlin website</a> <br><br>  ps: Dear minus, but to motivate the minus is not accepted? </div><p>Source: <a href="https://habr.com/ru/post/142592/">https://habr.com/ru/post/142592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142586/index.html">The problem of the popularity of Ruby and Ruby on Rails - bad documentation</a></li>
<li><a href="../142587/index.html">13 tools for community-based crowdfunding</a></li>
<li><a href="../142588/index.html">How to make a good promotional video for a startup. Part 2. Right off the bat</a></li>
<li><a href="../142589/index.html">Polynomial hashes and their applications</a></li>
<li><a href="../142590/index.html">7 reasons why AngularJS is cool</a></li>
<li><a href="../142593/index.html">When you connect the IPTV service you</a></li>
<li><a href="../142594/index.html">Erlang. Recommendations for code design</a></li>
<li><a href="../142595/index.html">So, you decided to prohibit copying class objects in C ++.</a></li>
<li><a href="../142596/index.html">Simulator for software testing</a></li>
<li><a href="../142597/index.html">We learn MS SQL Server Reporting Services 2008 R2 to show HTML in reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>