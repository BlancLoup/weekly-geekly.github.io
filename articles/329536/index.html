<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The path to transducers in pure javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have heard about the so-called ‚Äútransducers‚Äù, but you still do not use them in JavaScript development, today you have a chance to find answers ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The path to transducers in pure javascript</h1><div class="post__text post__text-html js-mediator-article">  If you have heard about the so-called ‚Äútransducers‚Äù, but you still do not use them in JavaScript development, today you have a chance to find answers to the questions: ‚ÄúWhat are transducers?‚Äù And ‚ÄúHow to use them?‚Äù.  This will allow you to understand whether they are needed in your projects, and, if needed, will help to start using them. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/329536/"><img src="https://habrastorage.org/web/27b/61c/641/27b61c64175343ce9c86c4e1267cad4b.jpg"></a> <br><br>  It will be about how to write code that is designed to build data conversions that are well suited for building pipelines and does not consume too much memory.  In order to properly understand the concept of transducers, we start with simpler mechanisms, reducers, or functions for convolving data. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Reductors</font> </h2><br>  A reducer is a function that accepts a drive object and an object object at the input, and then puts this element into the drive.  For example, here is the reducer: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <code>(acc, val) =&gt; acc.concat([val])</code> .  If the drive passed to it is an array <code>[1, 2, 3]</code> , and the element is the number <code>4</code> , it will return the array <code>[1, 2, 3, 4]</code> . <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> acc = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducer = (acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) =&gt; acc.concat([<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>]); reducer(acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) <span class="hljs-comment"><span class="hljs-comment">///=&gt; 1, 2, 3, 4</span></span></code> </pre> <br>  In our case, the reducer returns the result of the concatenation of the list of elements and the single element passed to it. <br><br>  Here is another similar reducer: <code>(acc, val) =&gt; acc.add(val)</code> .  It is suitable for any object that has a <code>.add()</code> method that, among other things, returns this object (like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add">Set.prototype.add ()</a> ).  Our reducer adds the element transferred to it to the drive using the method.  <code>add()</code> drive. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> acc = new Set([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducer = (acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) =&gt; acc.add(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); reducer(acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) <span class="hljs-comment"><span class="hljs-comment">///=&gt; Set{1, 2, 3, 4}</span></span></code> </pre> <br>  Here is a function that creates an array from any iterated object using our concatenated reducer. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toArray = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">iterable</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> acc.concat([val]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> seed = []; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accumulation = seed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterable) {   accumulation = reducer(accumulation, value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulation; } toArray([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [1, 2, 3]</span></span></code> </pre> <br>  You can make the variables <code>reducer</code> and <code>seed</code> parameters of the new function (the host, by analogy with the just considered, and the argument <code>iterable</code> ), getting a universal reducing function. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduce = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">iterable, reducer, seed</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accumulation = seed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterable) {   accumulation = reducer(accumulation, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulation; } reduce([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], (acc, val) =&gt; acc.concat([val]), []) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [1, 2, 3]</span></span></code> </pre> <br>  JavaScript evolves towards a convention of writing functions, such as our <code>reduce</code> , the first parameter of which is the reducer.  If you rewrite this function in <a href="https://leanpub.com/javascriptallongesix">JavaScript Allong√©</a> style, you get the following. <br><br><pre> <code class="hljs coffeescript">const reduceWith = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reducer, seed, iterable)</span></span></span><span class="hljs-function"> =&gt;</span></span> { let accumulation = seed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterable) {   accumulation = reducer(accumulation, value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulation; } reduce([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, val)</span></span></span><span class="hljs-function"> =&gt;</span></span> acc.concat([val]), []) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>=&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    : reduceWith(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, val)</span></span></span><span class="hljs-function"> =&gt;</span></span> acc.concat([val]), [], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>=&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br>  Arrays in JavaScript have a built-in <code>.reduce</code> method.  This method behaves in the same way as the above functions <code>reduce</code> and <code>reduceWith</code> . <br><br><pre> <code class="hljs scala">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].reduce((acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) =&gt; acc.concat([<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>]), []) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [1, 2, 3]</span></span></code> </pre> <br>  Now the function <code>(acc, val) =&gt; acc.concat([val])</code> creates an unnecessary load on the memory, so we can replace it with such a reducer: <code>(acc, val) =&gt; { acc.push(val); return acc; }</code> <code>(acc, val) =&gt; { acc.push(val); return acc; }</code>  <code>(acc, val) =&gt; { acc.push(val); return acc; }</code> . <br><br>  It should be noted here that the record of the form <code>(acc, val) =&gt; (acc.push(val), acc)</code> looks better from a semantic point of view, but the comma operator can confuse those who are not familiar with the peculiarities of its use.  Usually in production code this is best avoided. <br><br>  In any case, we will have a reducer that collects the elements into an array.  Give it a name and try to pass it to the <code>reduceWith</code> function. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayOf = (acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) =&gt; { acc.push(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; }; reduceWith(arrayOf, [], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [1, 2, 3]</span></span></code> </pre> <br>  Here is another reducer. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumOf = (acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) =&gt; acc + <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; reduceWith(sumOf, <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//=&gt; 6</span></span></code> </pre> <br>  You can write reducers that collapse an iterable object of one type (say, an array) into an object of another type (for example, into a number). <br><br><h2>  <font color="#3AC1EF">Dressing up of reducer</font> </h2><br>  In JavaScript, it is easy to write functions that return other functions.  Here, for example, a function that allows you to create reysery. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joinedWith = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">separator</span></span></span><span class="hljs-function"> =&gt;</span></span>   (acc, val) =&gt;     acc == <span class="hljs-string"><span class="hljs-string">''</span></span> ? val : <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${acc}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${separator}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${val}</span></span></span><span class="hljs-string">`</span></span>; reduceWith(joinedWith(<span class="hljs-string"><span class="hljs-string">', '</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//=&gt; "1, 2, 3" reduceWith(joinedWith('.'), '', [1, 2, 3]) //=&gt; "1.2.3"</span></span></code> </pre> <br>  In addition, in JS it is completely natural to create functions that take other functions as arguments. <br><br>  Decorators are functions that, taking a certain function as an argument, return another function that is semantically related to the argument.  For example, this function takes a function with two arguments, a binary one, if we speak in the language of functional programming, and decorates it by adding one to its second argument. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> incrementSecondArgument = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">binaryFn</span></span></span><span class="hljs-function"> =&gt;</span></span>   (x, y) =&gt; binaryFn(x, y + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> power = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">base, exponent</span></span></span><span class="hljs-function">) =&gt;</span></span> base ** exponent; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> higherPower = incrementSecondArgument(power); power(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//=&gt; 8 higherPower(2, 3) //=&gt; 16</span></span></code> </pre> <br>  In this example, the <code>higherPower</code> function is a <code>power</code> function, decorated by adding a unit to its <code>exponent</code> argument.  Thus, calling <code>higherPower(2,3)</code> gives the same result as <code>power(2,4)</code> .  We have already worked with similar functions, our reducers are also binary functions.  They can be decorated. <br><br><pre> <code class="hljs objectivec">reduceWith(incrementSecondArgument(arrayOf), [], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [2, 3, 4] const incremented = iterable =&gt;   reduceWith(incrementSecondArgument(arrayOf), [], iterable); incremented([1, 2, 3]) //=&gt; [2, 3, 4]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Mapping functions</font> </h2><br>  We have just created a function for mapping, which, taking an iterated object, returns the result of processing its values ‚Äã‚Äãby increasing each of them by one.  When developing programs on JS, we constantly resort to mapping, but, of course, the functions implementing this mechanism are usually expected to be somewhat larger than the production of copies of numerical arrays, the elements of which are increased by one.  Take another look at the <code>incrementSecondArgument</code> function. <br><br><pre> <code class="hljs lisp">const incrementSecondArgument = binaryFn =&gt;   (<span class="hljs-name"><span class="hljs-name">x</span></span>, y) =&gt; binaryFn(<span class="hljs-name"><span class="hljs-name">x</span></span>, y + <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Since we use it for decorating reduser, we give it a more appropriate name. <br><br><pre> <code class="hljs lisp">const incrementValue = reducer =&gt; (<span class="hljs-name"><span class="hljs-name">acc</span></span>, val) =&gt; reducer(<span class="hljs-name"><span class="hljs-name">acc</span></span>, val + <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Now, when reading the code, it is immediately obvious that <code>incrementValue</code> takes a reducer as an argument and returns another reducer, which, before processing the element passed to it, adds one to it.  The logic of "incrementing" can be made in the parameter. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span>   reducer =&gt;     <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> reducer(acc, fn(val)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> incrementValue = map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>); reduceWith(incrementValue(arrayOf), [], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [2, 3, 4]</span></span></code> </pre> <br>  Although all this may look unusual for those who are not used to functions that accept functions as arguments and return other functions that, again, accept functions as arguments, we can put the <code>map(x =&gt; x + 1)</code> construction <code>map(x =&gt; x + 1)</code> everywhere, where you can use <code>incrementValue</code> .  Thus, we can write the following. <br><br><pre> <code class="hljs javascript">reduceWith(map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>)(arrayOf), [], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [2, 3, 4]</span></span></code> </pre> <br>  And, since our <code>map</code> decorator can decorate any reducer, it is permissible to combine the results of incrementing numbers, forming a string, or summarize them. <br><br><pre> <code class="hljs lisp">reduceWith(<span class="hljs-name"><span class="hljs-name">map</span></span>(<span class="hljs-name"><span class="hljs-name">x</span></span> =&gt; x + <span class="hljs-number"><span class="hljs-number">1</span></span>)(<span class="hljs-name"><span class="hljs-name">joinedWith</span></span>('.')), '', [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) //=&gt; <span class="hljs-string"><span class="hljs-string">"2.3.4"</span></span> reduceWith(<span class="hljs-name"><span class="hljs-name">map</span></span>(<span class="hljs-name"><span class="hljs-name">x</span></span> =&gt; x + <span class="hljs-number"><span class="hljs-number">1</span></span>)(<span class="hljs-name"><span class="hljs-name">sumOf</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) //=&gt; <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre> <br>  Armed with the techniques described above, we will try to find the sum of squares of numbers from one to ten. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> squares = map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> power(x, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one2ten = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; reduceWith(squares(sumOf), <span class="hljs-number"><span class="hljs-number">0</span></span>, one2ten) <span class="hljs-comment"><span class="hljs-comment">//=&gt; 385</span></span></code> </pre> <br>  As you can see, we succeeded.  Now we go further - let's talk about filters. <br><br><h2>  <font color="#3AC1EF">Filters</font> </h2><br>  Let's return to our first reducer. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayOf = (acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) =&gt; { acc.push(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; }; reduceWith(arrayOf, <span class="hljs-number"><span class="hljs-number">0</span></span>, one2ten) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span></code> </pre> <br>  What if you want the output to get only numbers that are more than five?  Make it easy. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bigUns = (acc, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) {   acc.push(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; }; reduceWith(bigUns, [], one2ten) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [6, 7, 8, 9, 10]</span></span></code> </pre> <br>  Naturally, we can combine everything that has already been sorted out in order to get an array of numbers that are more than five squared. <br><br><pre> <code class="hljs objectivec">reduceWith(squares(bigUns), [], one2ten) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [9, 16, 25, 36, 49, 64, 81, 100]</span></span></code> </pre> <br>  However, it turned out here is not what is needed.  The output - the numbers, the squares of which are more than five, and not numbers that are more than five, squared.  The numbers must be selected before squareing them, not after.  To achieve this behavior of the system is not so difficult.  The point here is that the decorator, who is responsible for filtering numbers, will help us; we can use it to decorate the reducser. <br><br><pre> <code class="hljs objectivec">reduceWith(squares(arrayOf), [], one2ten) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] const bigUnsOf = reducer =&gt;   (acc, val) =&gt;     (val &gt; 5) ? reducer(acc, val) : acc; reduceWith(bigUnsOf(squares(arrayOf)), [], one2ten) //=&gt; [36, 49, 64, 81, 100]</span></span></code> </pre> <br>  The <code>bigUnsOf</code> function <code>bigUnsOf</code> quite specific.  We will do the same here as with the <code>map</code> , namely, we extract the predicate function and make it an argument. <br><br><pre> <code class="hljs pgsql">reduceWith(squares(arrayOf), [], one2ten) //=&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>] const <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> = fn =&gt;   reducer =&gt;     (acc, val) =&gt;       fn(val) ? reducer(acc, val) : acc; reduceWith(<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(x =&gt; x &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>)(squares(arrayOf)), [], one2ten) //=&gt; [<span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>]</code> </pre> <br>  Filters, of course, can be any.  They can be given names and used multiple times, and anonymous functions can be dispensed with. <br><br><pre> <code class="hljs javascript">reduceWith(filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">1</span></span>)(arrayOf), [], one2ten) <span class="hljs-comment"><span class="hljs-comment">//=&gt; [1, 3, 5, 7, 9]</span></span></code> </pre> <br>  Use the filter to find the sum of squares of odd numbers from one to ten. <br><br><pre> <code class="hljs lisp">reduceWith(<span class="hljs-name"><span class="hljs-name">filter</span></span>(<span class="hljs-name"><span class="hljs-name">x</span></span> =&gt; x % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">1</span></span>)(<span class="hljs-name"><span class="hljs-name">squares</span></span>(<span class="hljs-name"><span class="hljs-name">sumOf</span></span>)), <span class="hljs-number"><span class="hljs-number">0</span></span>, one2ten) //=&gt; <span class="hljs-number"><span class="hljs-number">165</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Transformers and composition</font> </h2><br>  The term "transformer" came in JavaScript from other programming languages.  This is the name of the function that takes a certain argument and transforms it into something else.  What we called above the "decorator" is a special case of the transformer.  Thus, if you meet somewhere a story about a transformer function that makes another one from one reducer, it will be clear to you that we are talking about the same function that ‚Äúdecorates‚Äù a reducer, adding additional functionality to it, such as mapping or filtering. . <br><br>  The mapping functions and filters we talked about are also transformers.  In the context of this programming pattern, the most important characteristic of transformers is that they use composition to create new transformers.  So, to make it clearer, the function that produces the composition of any two input functions to it. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> plusFive = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> divideByTwo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x / <span class="hljs-number"><span class="hljs-number">2</span></span>; plusFive(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//=&gt; 8 divideByTow(8) //=&gt; 4 const compose2 = (a, b) =&gt;   (...c) =&gt;     a(b(...c)); const plusFiveDividedByTwo = compose2(divideByTwo, plusFive); plusFiveDividedByTwo(3) //=&gt; 4</span></span></code> </pre> <br>  Transformers use the composition to create new transformers.  What does this mean for <code>compose2</code> ?  This means that by giving it two any transformers, we will get a new transformer that transforms the reducer.  Thus, we obtain the following. <br><br><pre> <code class="hljs lisp">const squaresOfTheOddNumbers = compose2( <span class="hljs-name"><span class="hljs-name">filter</span></span>(<span class="hljs-name"><span class="hljs-name">x</span></span> =&gt; x % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">1</span></span>), squares )<span class="hljs-comment"><span class="hljs-comment">; reduceWith(squaresOfTheOddNumbers(sumOf), 0, one2ten) //=&gt; 165</span></span></code> </pre> <br>  What is hidden under the name <code>squaresOfTheOddNumbers</code> is a transformer that we created by applying the <code>compose2</code> function to the filter and mapping functions. <br><br>  Now that we have the ability to compose the decorators, we will break apart a complex code, characterized by a high degree of connectivity, into small, highly specialized blocks. <br><br><h2>  <font color="#3AC1EF">Composition using transformers</font> </h2><br>  Knowing how the <code>compose2</code> function <code>compose2</code> , which allows you to get a composition of two functions, we will think about what to do if we need the composition of an arbitrary number of functions.  The answer lies in the convolution. <br><br>  <code>compose2</code> , making it a <code>compositionOf</code> transformer. <br><br><pre> <code class="hljs lisp">const compositionOf = (<span class="hljs-name"><span class="hljs-name">acc</span></span>, val) =&gt; (...args) =&gt; val(<span class="hljs-name"><span class="hljs-name">acc</span></span>(...args))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Now you can write the <code>compose</code> function to get the composition of an arbitrary number of functions as a reduction of its arguments: <br><br><pre> <code class="hljs lisp">const compose = (...fns) =&gt; reduceWith(<span class="hljs-name"><span class="hljs-name">compositionOf</span></span>, x =&gt; x, fns)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  So, we come to the most interesting. <br><br><h2>  <font color="#3AC1EF">Transducers</font> </h2><br>  Consider the following entry: <br><br><pre> <code class="hljs lisp">reduceWith(<span class="hljs-name"><span class="hljs-name">squaresOfTheOddNumbers</span></span>(<span class="hljs-name"><span class="hljs-name">sumOf</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, one2ten)</code> </pre> <br>  Here you can select four elements.  Transformer for a reducer (which can be a composition of transformers), the initial value (drive) and the object to be iterated.  If we take the transformer, reducer, drive and the object being iterated into separate parameters, we get the following. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> transduce = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transformer, reducer, seed, iterable</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> transformedReducer = transformer(reducer); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accumulation = seed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterable) {   accumulation = transformedReducer(accumulation, value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulation; } transduce(squaresOfTheOddNumbers, sumOf, <span class="hljs-number"><span class="hljs-number">0</span></span>, one2ten) <span class="hljs-comment"><span class="hljs-comment">//=&gt; 165</span></span></code> </pre> <br>  It should be noted that in some programming languages ‚Äã‚Äãthere is a strong desire to reduce the long names of variables or parameters.  As a result, the rather long name <code>transformer</code> abbreviated to <code>xform</code> or even to <code>xf</code> .  Do not be surprised if you see a similar construct, whose entry looks like (xf, reduce, seed, coll), or <code>xf((val, acc) =&gt; acc) -&gt; (val, acc) =&gt; acc</code> .  Here we can do without abbreviations, but in the production code names like <code>xf</code> or <code>xform</code> quite acceptable. <br><br>  And now, actually, for the sake of what it was all written.  A reducer is a function that is passed to methods like <code>.reduce ‚Äî</code> it takes a drive object and input data, and returns a drive into which new data is placed.  A transformer is a function that transforms a reducer into another reducer.  A transducer (this name is the result of combining the terms "transformer" and "reducer", here it is the answer to the question: "What are redusers?"), Is a function that accepts a transformer, reducer, drive and an iterated object, and then collapses the iterated object in a certain meaning. <br><br>  The elegance of the template "transducer" is that the composition of transformers naturally leads to the creation of new transformers.  As a result, you can chain as many transformers as you need.  This is very important, because as a result you will get one transformed reducer and you will have to walk only once on the iterated collection.  No need to create intermediate copies of the data or perform multiple passes on them. <br><br>  Transducers came to JavaScript from Clojure, but, as you can see, they fit perfectly into JavaScript, for their implementation are quite standard language features. <br><br>  So, if someone asks us what a transducer is, we can answer this: <br><br>  Note: this fragment should be highlighted. <br><br>  <b>Transducers are transformers that are suitable for composition, applied to reducers for convolving iterated objects.</b> <b><br><br></b> <h2>  <b><font color="#3AC1EF">Transducer in action</font></b> </h2> <b><br></b>  Above, we looked at code fragments leading to the construction of a transducer.  Quite possibly, you have already reproduced them in your JS-editor and have experienced, however, here, for convenience and clarity, all of our code is collected in one place. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrayOf = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { acc.push(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumOf = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> acc + val; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setOf = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> acc.add(val); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span>   reducer =&gt;     <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> reducer(acc, fn(val)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span>   reducer =&gt;     <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span>       fn(val) ? reducer(acc, val) : acc; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> (...args) =&gt; val(acc(...args)), x =&gt; x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> transduce = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transformer, reducer, seed, iterable</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> transformedReducer = transformer(reducer); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accumulation = seed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterable) {   accumulation = transformedReducer(accumulation, value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulation; }</code> </pre> <br>  This example demonstrates everything that is usually used when working with arrays, namely, these are <code>.map</code> , <code>.filter</code> , <code>.reduce</code> , and there are transducers suitable for composition that are not involved in creating multiple copies of the data set being processed.  In fact, transducers written for real projects provide much more use <code>.find</code> , for example, reproducing the functionality of the <code>.find</code> method. <br><br>  It should be noted that our <code>transduse</code> function <code>transduse</code> designed for the fact that an <code>transduse</code> collection will be passed to it, in addition, we must provide it with an initial value (drive) and a reducer.  In most cases, both the initial value and the reducer are the same functions for all collections of the same type.  This is also characteristic of the corresponding libraries. <br><br>  In object-oriented programming, of course, this problem is solved through polymorphism.  Collections have methods, therefore, calling the appropriate method, we get what we need at the output.  Libraries that can be used to create production code provide interfaces for collections of various types, making it convenient to use transducers. <br><br>  We believe that the foregoing is sufficient to understand the pattern underlying the transducer and evaluate the useful and convenient features provided by the presence of first-class functions in the language. <br><br><h2>  <font color="#3AC1EF">Transducers: processing a list of users</font> </h2><br>  <a href="http://raganwald.com/2017/04/19/incremental.html">This material</a> shows solutions for the following problem: there is a set of users and places they have visited, both of which are presented as a list of hash codes.  The first code in each line is the user, the second is the place he visited, say, a restaurant, or a shop.  The order of the data in the list is important.  The challenge is to find out which transitions between places are most popular. <br><br>  Namely, there is such a list: <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">1</span></span>a2ddc2, <span class="hljs-number"><span class="hljs-number">5f</span></span>2b932 f1a543f, <span class="hljs-number"><span class="hljs-number">5890595</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>abe124, bd11537 f1a543f, <span class="hljs-number"><span class="hljs-number">5f</span></span>2b932 f1a543f, bd11537 f1a543f, <span class="hljs-number"><span class="hljs-number">5890595</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>a2ddc2, bd11537 <span class="hljs-number"><span class="hljs-number">1</span></span>a2ddc2, <span class="hljs-number"><span class="hljs-number">5890595</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>abe124, <span class="hljs-number"><span class="hljs-number">5f</span></span>2b932 f1a543f, <span class="hljs-number"><span class="hljs-number">5f</span></span>2b932 f1a543f, bd11537 f1a543f, <span class="hljs-number"><span class="hljs-number">5890595</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>a2ddc2, <span class="hljs-number"><span class="hljs-number">5f</span></span>2b932 <span class="hljs-number"><span class="hljs-number">1</span></span>a2ddc2, bd11537 <span class="hljs-number"><span class="hljs-number">1</span></span>a2ddc2, <span class="hljs-number"><span class="hljs-number">5890595</span></span> ...</code> </pre> <br>  Carefully reviewing this list, we may find that user <code>1a2ddc2</code> visited places with codes <code>5f2b932</code> , <code>bd11537</code> , <code>5890595</code> , <code>5f2b932</code> , <code>bd11537</code> , and <code>5890595</code> .  At the same time, user <code>f1a543f</code> visited places <code>5890595</code> , <code>5f2b932</code> , <code>bd11537</code> , <code>5890595</code> , <code>5f2b932</code> , <code>bd11537</code> , and <code>5890595</code> .  And so on. <br><br>  Suppose you need to find out where people usually go, you need to find the most popular transitions from ‚Äúplace A‚Äù to ‚Äúplace B‚Äù.  We know that the user's travel history <code>1a2ddc2</code> as follows: <code>5f2b932</code> , <code>bd11537</code> , <code>5890595</code> , <code>5f2b932</code> , <code>bd11537</code> , <code>5890595</code> .  This means that for him it is possible to build such a scheme of transitions from place to place: <br><br><pre> <code class="hljs erlang-repl"><span class="hljs-number"><span class="hljs-number">5</span></span>f2b932 -&gt; bd11537 bd11537 -&gt; <span class="hljs-number"><span class="hljs-number">5890595</span></span> <span class="hljs-number"><span class="hljs-number">5890595</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>f2b932 <span class="hljs-number"><span class="hljs-number">5</span></span>f2b932 -&gt; bd11537 bd11537 -&gt; <span class="hljs-number"><span class="hljs-number">5890595</span></span></code> </pre> <br>  Please note that we need to build a similar list for each user.  When this is done, you need to find the most popular transitions.  Here is what a similar calculation might look like: <br><br>  The transition <code>5f2b932 -&gt; bd11537</code> appears in the list twice. <br>  The transition <code>bd11537 -&gt; 5890595</code> also occurs twice. <br>  The transition <code>5890595 -&gt; 5f2b932</code> met only once. <br><br>  Now all you have to do is count the number of clicks on all users and find the most popular ones.  Here is a solution to this problem using transducers. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logContents = <span class="hljs-string"><span class="hljs-string">`1a2ddc2, 5f2b932 f1a543f, 5890595 3abe124, bd11537 f1a543f, 5f2b932 f1a543f, bd11537 f1a543f, 5890595 1a2ddc2, bd11537 1a2ddc2, 5890595 3abe124, 5f2b932 f1a543f, 5f2b932 f1a543f, bd11537 f1a543f, 5890595 1a2ddc2, 5f2b932 1a2ddc2, bd11537 1a2ddc2, 5890595`</span></span>;</code> </pre> <br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asStream = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> * (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">iterable</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> * iterable; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lines = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> streamOfLines = asStream(lines(logContents)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datums = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.split(<span class="hljs-string"><span class="hljs-string">', '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datumize = map(datums); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userKey = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[user, _]</span></span></span><span class="hljs-function">) =&gt;</span></span> user; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pairMaker = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wip = []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reducer</span></span></span><span class="hljs-function"> =&gt;</span></span>   (acc, val) =&gt; {     wip.push(val);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wip.length === <span class="hljs-number"><span class="hljs-number">2</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pair = wip;       wip = wip.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>);       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reducer(acc, pair);     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc;     } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sortedTransformation = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xfMaker, keyFn</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> decoratedReducersByKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reducer</span></span></span><span class="hljs-function"> =&gt;</span></span>     (acc, val) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = keyFn(val);       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoratedReducer;       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decoratedReducersByKey.has(key)) {         decoratedReducer = decoratedReducersByKey.get(key);       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         decoratedReducer = xfMaker()(reducer);         decoratedReducersByKey.set(key, decoratedReducer);       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decoratedReducer(acc, val);     } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userTransitions = sortedTransformation(pairMaker, userKey); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> justLocations = map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[[u1, l1], [u2, l2]]</span></span></span><span class="hljs-function">) =&gt;</span></span> [l1, l2]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stringify = map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transition</span></span></span><span class="hljs-function"> =&gt;</span></span> transition.join(<span class="hljs-string"><span class="hljs-string">' -&gt; '</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> transitionKeys = compose( stringify, justLocations, userTransitions, datumize ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countsOf = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acc.has(val)) {     acc.set(val, <span class="hljs-number"><span class="hljs-number">1</span></span> + acc.get(val));   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     acc.set(val, <span class="hljs-number"><span class="hljs-number">1</span></span>);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greatestValue = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inMap</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(inMap.entries()).reduce(   <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[wasKeys, wasCount], [transitionKey, count]</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt; wasCount) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [wasKeys, wasCount];     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; wasCount) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>([transitionKey]), count];     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       wasKeys.add(transitionKey);       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [wasKeys, wasCount];     }   }   , [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(), <span class="hljs-number"><span class="hljs-number">0</span></span>] ); greatestValue( transduce(transitionKeys, countsOf, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(), streamOfLines) ) <span class="hljs-comment"><span class="hljs-comment">//=&gt;   [     "5f2b932 -&gt; bd11537",     "bd11537 -&gt; 5890595"   ],   4</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  We hope this material will help everyone to make transducers their permanent tool.  If you want to delve into their study, here is a good <a href="https://medium.com/%40roman01la/understanding-transducers-in-javascript-3500d3bd9624">material</a> about transducers, and here is the <a href="https://github.com/cognitect-labs/transducers-js">transdusers-js</a> library on GitHub. <br><br>  Dear readers!  Do you use transducers in your JavaScript projects? </div><p>Source: <a href="https://habr.com/ru/post/329536/">https://habr.com/ru/post/329536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329522/index.html">What is the difference between Bitcoin and other cryptocurrencies?</a></li>
<li><a href="../329524/index.html">Friday discussion: Russian vs foreign IT - company. Why everyone wants to work at Google</a></li>
<li><a href="../329528/index.html">Development of a chess program</a></li>
<li><a href="../329530/index.html">What did you encounter when translating the project to Android Studio 3.0 Preview and Gradle 4.0-milestone-1</a></li>
<li><a href="../329532/index.html">Understanding the Conductor</a></li>
<li><a href="../329538/index.html">Do-it-yourself phishing. Experience of the company "Aktiv", part two</a></li>
<li><a href="../329540/index.html">Open days before launching a new Java course</a></li>
<li><a href="../329542/index.html">Using statistics in PostgreSQL to optimize performance - Alexey Ermakov</a></li>
<li><a href="../329544/index.html">Start of big data project: 6 important issues</a></li>
<li><a href="../329546/index.html">To the question of constants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>