<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making lines of multiple parts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Roberto Iurusimshi explains how to effectively combine non-modifiable strings. 
 Despite the fact that the code is written in Lua, the algorithm is su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making lines of multiple parts</h1><div class="post__text post__text-html js-mediator-article">  Roberto Iurusimshi explains how to effectively combine non-modifiable strings. <br>  Despite the fact that the code is written in Lua, the algorithm is suitable for other languages ‚Äã‚Äãin which the strings cannot be changed. <br><a name="habracut"></a><br><h4>  Prologue </h4><br>  In Lua, the ‚Äúaccumulation‚Äù of the resultant string (i.e., a cycle with a body of the form s = s..x) can be extremely resource-intensive.  This note describes an efficient way to create a string piece by piece in Lua. <br><br><h4>  Problem </h4><br>  Suppose that you make a string in parts, for example, reading from a file line by line.  A typical code might look like this: <br><pre><code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- WARNING: bad code ahead!! local buff = "" while 1 do local line = read() if line == nil then break end buff = buff..line.."\n" end</span></span></code> </pre> <br><br>  Despite its innocent appearance, such Lua code can cause significant performance loss for large files: for example, it takes almost a minute to read a 350K file. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Often this is not a problem.  For small lines, a similar cycle is normal.  To read the entire file, you can use the "* all" option, which allows you to read the entire file.  But sometimes there is no such simple solution.  In this case, the only solution is a more efficient algorithm for this problem.  Here we show it (algorithm, not the problem). <br><br><h4>  Decision </h4><br>  The heart of the algorithm is the stack, which stores large lines at the bottom, and small lines come from above.  The main invariant of such a stack is similar to the popular (among programmers) ‚ÄúHanoi Tower‚Äù: a line in the stack cannot be on top of a shorter one.  When a new line is placed on top of a shorter one, then (and only then) the algorithm merges them together.  Combining lines creates a large line that may be larger than its neighbor from the bottom floor.  If this happens, the resulting string and the neighbor from the bottom are also merged.  These joins go down the stack until the loop reaches a larger line or bottom of the stack. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newBuffer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {n=<span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-comment"><span class="hljs-comment">-- 'n' counts number of elements in the stack end function addString (stack, s) tinsert(stack, s) -- push 's' into the top of the stack for i=stack.n-1, 1, -1 do if strlen(stack[i]) &gt; strlen(stack[i+1]) then break end stack[i] = stack[i]..tremove(stack) end end</span></span></code> </pre><br><br>  To get the final result, we just need to combine all the lines from top to bottom: <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stack)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=stack.n<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> stack[i] = stack[i]..tremove(stack) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stack[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Using our new data structure, we can rewrite the program as follows: <br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> s = newBuffer() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> line = <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> addString(s, line..<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> s = toString(s)</code> </pre><br><br>  This program reduced the time to read a 350K file from 40 seconds to 0.5 seconds.  The read call "* all" is still faster, doing the same in 0.02 seconds). <br><br><h4>  Explanation </h4><br><br>  To understand what happens when we use the naive approach, suppose that we are in the middle of the reading process;  buff already contains a 50KB string and each 20 byte row.  After concatenation operation <br><pre> <code class="lua hljs">buff = buff..line..<span class="hljs-string"><span class="hljs-string">"\n"</span></span></code> </pre><br>  The buff variable already contains 50020 bytes, and the old line has become garbage.  After two iterations of the loop, the buff already contains 50040 bytes, and already two lines form more than 100Kb of garbage.  Thus, Lua decides, quite correctly, that it is time to start the garbage collector, and frees these 100Kb.  The problem is that this happens every two iterations, and Lua will start the garbage collector two thousand times before the loop ends.  And even with all these actions, memory consumption will be three times larger than the file size.  And even worse, each concatenation must copy the contents of the entire line (50Kb and more) into a new line. <br><br>  This problem is not only Lua: other languages ‚Äã‚Äãwith a real garbage collector, and where the lines of non-modifiable objects behave also (the most famous of which is Java). <br><br>  Our initial cycle used a ‚Äúlinear‚Äù approach to the problem, combining small lines one after another into a variable ‚Äì accumulator.  A new algorithm avoids this using a binary approach.  It combines many small lines with each other, and sometimes combines the resulting large line with other large lines. <br><br><h4>  PS </h4><br>  Examples are given on a fairly old version of Lua, and I (Xitsa) did not change them, since the meaning of the algorithm is clear enough. </div><p>Source: <a href="https://habr.com/ru/post/99373/">https://habr.com/ru/post/99373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99366/index.html">Compilation. 3: bison</a></li>
<li><a href="../99367/index.html">Using Intel AVX: writing the program of tomorrow</a></li>
<li><a href="../99368/index.html">On Monday, Valve released a new free (!) Game Alien Swarm</a></li>
<li><a href="../99369/index.html">Overview of the Chinese UMPC Gome FlyTouch</a></li>
<li><a href="../99371/index.html">We create PivotViewer site content in 10 minutes using the example of Habrahabr</a></li>
<li><a href="../99375/index.html">Facts and Errors of Professional Programming</a></li>
<li><a href="../99376/index.html">RSA, is it really that simple?</a></li>
<li><a href="../99377/index.html">SSH access organization by one-time passwords</a></li>
<li><a href="../99380/index.html">The first 100 GB Blu-ray discs coming soon</a></li>
<li><a href="../99385/index.html">Two stories about bank cards</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>