<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Our view: Meteor vs Derby</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator : I didn‚Äôt see any materials on the Derbyjs framework, which is often referred to as the main competitor of Meteor, in Habr√©. Unde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Our view: Meteor vs Derby</h1><div class="post__text post__text-html js-mediator-article">  <b>From the translator</b> : I didn‚Äôt see any materials on the Derbyjs framework, which is often referred to as the main competitor of Meteor, in Habr√©.  Under the cut, a comparison of these two frameworks made by the authors of Derby.  Comparison is already more than a year old, but I think it will be interesting for those who have not read. <br><a name="habracut"></a><br>  We are often asked to compare these two products.  I would like to thank Nick Retallack, who did a great job comparing them in our group: <a href="http://groups.google.com/group/derbyjs">Google Group</a> .  Part of his conclusions will be used in this article. <br><br><h4>  How it all began </h4><br>  First of all, I would like to note that for the first time Brian and I met with the Meteor team in November, during a demonstration of an early version of Derby at the <a href="http://krtconf.com/">Keeping it Realtime</a> conference, organized by <a href="http://andyet.net/">&amp; yet</a> .  When we met, the <a href="http://meteor.com/">Meteor</a> team had already begun developing its own framework, and the similarities could be seen with the naked eye.  A little earlier, I also met with David Greenspan (who recently joined Meteor), it was interesting to talk and discuss his experience of creating an <a href="http://en.wikipedia.org/wiki/Etherpad">Etherpad</a> .  Our teams are friends, communicate and learn a lot from each other. <br><br>  We are united by a common vision of the world, where all applications work ‚Äúin real time‚Äù and ‚Äúin collaboration mode‚Äù.  We, like many other developers, a year and a half ago, suddenly became acutely aware that using modern approaches to web development, it is extremely difficult to create a positive user experience, especially where data is dynamically updated. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Brian and I discussed this a year ago.  At that time, I was a product manager on the Google Search team, and he was involved in several open source Node.js projects, including <a href="http://mongoosejs.com/">Mongoose</a> and <a href="http://everyauth.com/">everyauth</a> .  I was interested in developing this framework, since I thought it was best to create applications with the performance I needed, and Brian felt that Node.js community needed an easy-to-use framework for developers who prefer Rails or PHP. <br><br><h4>  Holy Grail: servile and client code </h4><br>  Working in Google Search, I realized that in order for the application to be responsive, it is critical to generate web pages, both on the server and on the client.  Google is able to do this - there are a lot of developers, and speed is paramount when searching.  To achieve fast downloads and fast updates, in Google Search all the code for generating pages is half written in C ++ and only half in JavaScript.  Over the past couple of years, they have launched several projects to simplify this task, but it‚Äôs not worth saying that such a development process is too expensive and useless for startups or complex applications. <br><br>  Gmail, Twitter, and other sites that are rendered only on the client are loading too slowly.  Twitter went through a full circle - they started with a <a href="http://engineering.twitter.com/2010/09/tech-behind-new-twittercom.html">full server generation</a> on Rails, then transferred the entire generation to the client, receiving as a result that reading the 140 character message began to take 4 seconds for the user.  Now Twitter forms half of the page on Scala on the server, and then the other half on JavaScript on the client.  All this together makes the code support more complex and means that less important parts of the page appear only a few seconds after the page is fully loaded.  People are very sensitive to change, and newly emerging elements divert attention from more important ones. <br><br>  Due to the rebirth of JavaScript performance in V8 and the ease of creating JavaScript servers with Node.js, many developers were inspired by the idea of ‚Äã‚Äãusing JavaScript on both the client and the server.  But despite this amazing opportunity, only some applications use shared code.  Even with one language, there are still a lot of problems, including: differences in delays and connection stability, differences in the way the URLs work on the server and in the browser, the DOM existence in the browser and its absence on the client, and finally, direct access to the file system only on the server. <br><br><h4>  So, to the point! </h4><br>  Considering all this, our teams decided to move along similar paths in some issues, and completely different in others.  Derby's goal is to give any developer the opportunity to write applications that load as fast as the search engine, just as interactive as a text editor and working offline.  <a href="https://groups.google.com/forum/%3Ffromgroups">Quoting Jeff</a> (Geoff), Meteor's goal is to create a ‚Äúplatform for a wide market‚Äù used in 90% of websites on the Internet, and for these 90% to make web development as fast as possible. ‚Äù <br><br><h4>  GPL vs MIT </h4><br>  Currently, Meteor is available only under the GPL license.  This means that if you do not want to publish your source code under a GPL or compatible license, you will need to contact them and agree on a commercial license. <br>  Derby, Racer and all other components of our framework are published under the free MIT license.  You can do whatever you want with your application, and we will not be able to stop you now or in the future. <br><br>  I am not a lawyer, so you should not take everything that I just said quite literally.  I did not see the future in a crystal ball or something like that.  (Yes, our lawyer once asked me to mention this.) <br><br><h4>  System packages Meteor vs npm </h4><br>  Meteor has created its own packet system and package distribution tool. <br><br>  Node.js modules follow the well-described CommonJS standard and have a built-in modular API.  However, initially the package distribution system was missing.  At the very beginning, Node.js had several package managers, but most developers have now stopped using <a href="http://npmjs.org/">npm</a> .  It is so versatile that it is even included in the distribution with Node.js. <br><br>  Frankly, this is the main thing that worries me in Meteor.  It‚Äôs as if people trying Meteor have never used Node.js and are not aware of the benefits of distributing packages through <a href="http://npmjs.org/">npm</a> .  I, and many other developers, see the key force of Node.js in npm, and it will be very sad to see its weakening by an incompatible package system. <br><br>  As in many other Node.js projects, we distribute Derby, Racer and their plugins as npm modules.  And we will continue to break our project into small modules, so that it is easier for them to use others.  You may not be using Derby, but you need to parse the HTML.  We needed to write a simple and fast HTML parser for the operation of our template system, and you can use it in your Node.js projects.  <a href="http://www.senchalabs.org/connect/">Connect</a> is an excellent example of a project with a rich ecosystem of modules based on it and distributed through npm, and we also hope to follow this path. <br><br><h4>  Compatible with other libraries </h4><br>  Meteor allows you to replace parts of your modules with other libraries.  The flexibility of this approach is particularly noticeable in the case of client libraries, although they must first be wrapped like Meteor modules. <br><br>  Meteor usually manages the creation of the server in its own way.  This makes the process of creating and deploying Meteor applications to their server extraordinarily simple, but at the same time makes it very difficult to use Meteor as a module on a regular Node.js server. <br><br>  In contrast, Derby is a regular npm module that can be added to any Node.js server.  If you want to use one of the 8900 npm modules (now 39 thousand - approx. Lane), just add them to your package.json file and run <code>npm install</code> . <br><br>  Derby does not provide any hosting solution, as there are already many excellent hosting services on the market.  In the future, we will provide instructions on how to quickly install and run Derby on any public server. <br><br>  <a href="http://derbyjs.com/">Racer</a> (the real-time engine that drives models in Derby) is a separate module, and can be used independently of Derby.  You can infiltrate into any Racer UI level and control the methods invoked when the model is updated.  Racer is based on the popular module, <a href="http://socket.io/">Socket.IO</a> , which can be accessed directly if necessary. <br><br>  The Derby core also uses several popular libraries, especially <a href="http://expressjs.com/">Express</a> for routing and <a href="https://github.com/substack/node-browserify">Browserify</a> , which automatically packs most Node.js modules for the browser. <br><br><h4>  MongoDB API vs Racer Methods </h4><br>  Meteor uses the MongoDB API directly in the browser.  MongoDB API is powerful and easy to use from JavaScript.  It is already used to it, certain development patterns have emerged, and, in general, it is sufficient for solving most of the tasks that may arise during the development of an application.  It seems that many people find this approach quite convenient for creating applications, since it removes the need to understand the layers of abstraction.  Some people talk about security problems, but I think you shouldn‚Äôt judge them strictly until the Meteor team brings to light its approach to authentication and authorization. <br><br>  Racer has its own API, built around ‚Äúdata modification methods‚Äù and ‚Äúpaths‚Äù.  This API allows 1: 1 to connect to any document-oriented storage, including MongoDb.  This of course has its pros and cons, but we believe that this is better for several reasons: <br><br><h5>  Conflict resolution </h5><br>  ‚ÄúWays‚Äù and ‚Äúmethods‚Äù are great for conflict resolution techniques, which, we expect, will be one of the biggest advantages of Racer.  Now, by default, we use the ‚Äúlast write changes wins‚Äù technique, which is equivalent to how Meteor saves data.  However, we have a preliminary implementation of the conflict resolution system through Software Transactional Memory and Operational Transformation methods.  These techniques allow you to use Derby applications offline, and then synchronize correctly.  It also becomes possible to implement things in the style of Google Docs - simultaneous simultaneous editing of content in one text field. <br><br><h5>  Data Store Interchangeability </h5><br>  Our ‚Äúpaths‚Äù and ‚Äúmethods‚Äù are flexible enough to take advantage of most data warehouses, switch from one to another, and even use several of them at the same time.  Switching between Riak, Postgres, CouchDb or any other service occurs without the need to modify the source code. <br><br><h5>  PubSub Efficiency (Publish / Subscribe to Data Changes) </h5><br>  Our ‚Äúpaths‚Äù are perfectly combined with the PubSub mechanism, this is how we synchronize data changes in real time.  In the implementation of LiveMongo in Meteor, the data is simply recorded in the database, then the database is periodically polled for changes, and for each client.  The advantages of their query pool are that any Mongo request can be applied to the database, we have implemented a wrapper for most PubSub requests without having to access the database.  We do not have obvious evidence so far, but we expect that PubSub scales much better than the pool of requests to the database. <br><br><h5>  Extension API </h5><br>  It will be possible to make extensions that act as data warehouses, even if they interact with other servers or using third-party APIs.  Database adapters are built at a fairly high level of abstraction, so they can be used very differently ... <br><br><h4>  Server page generation and general routing </h4><br>  Derby is one of a small number of frameworks designed so that the same page generation code and routing work simultaneously on both the server and the browser.  You can even use Derby to generate static pages that use the same templates as dynamic applications. <br><br>  This means that you get very fast loading pages right out of the box.  Even simple applications that generate a page on the client load and render pages take 1 to 2 seconds.  In simple Derby applications, the ‚Äúonload‚Äù event is triggered after 200 ms.  The more complex the application becomes, the greater the increase in speed due to server pregeneration. <br><br>  Many large companies, such as Google, Amazon and Facebook, allocate enormous resources to optimize page load times, as this directly affects conversion and revenue.  I almost died that day when Gmail added a progress bar with a load indication.  Never do that. <br><br>  In addition, the generation of pages on the server is crucial for SEO, and provides access to browsers and readers that do not support JavaScript. <br><br>  The routing module ( <a href="http://derbyjs.com/">routes</a> ) in Derby on the server is a middleware module Express, so you can use it in conjunction with other Express server routes, for example, to download files, and you can even write many applications that use different sets of routes on the same Express server.  For example, you can write a separate admin or mobile application that will not download all the code of the desktop version. <br><br>  While Derby provides you with all the benefits of speed and availability of a regular multi-page application, it also gives you the opportunity to create a fully optimized single-page application that can generate any template and route directly in the browser.  Client routing allows you to simply draw a link by reference without reloading the page, you do not need to use any specific API for routing.  Just set up a regular link on the client, and Derby will do everything for you. <br><br>  Meteor does not have this feature, although they have recently rewritten their template engine and <a href="http://meteor.com/faq/can-meteor-serve-static-html">can add it</a> . <br><br><h4>  Data Binding Models and Views </h4><br>  Meteor uses a reactive programming approach to update templates, which gives you the potential to work with any template engine.  When generating from a template, all data used for generation is tied to the resulting part of the page.  After changing the data, the template is re-generated and the result is compared with the existing part of the DOM.  And after that, Meteor replaces only obsolete pieces of DOM with minimal intervention.  The big advantage of this approach is the simplicity and ability to use any template language. <br><br>  In contrast, Derby uses its template based on Handlebars.  Bindings are explicitly defined, and the HTML template requires parsing to calculate the parts of the DOM that need to be updated.  Unlike Meteor, in Derby the bindings work in two ways - when the elements are attached, the model automatically changes if the user enters something in the edit field, marks the check box, or selects an element from the drop-down list.  You can also either bind all the data, or to optimize manually set the bindings of only the necessary data.  The output of unrelated data may be preferable if the developer plans to manually update the view by manipulating the elements of the DOM. <br><br><h4>  DOM event handlers </h4><br>  Here, the differences are quite small - Meteor uses CSS selectors in templates, and Derby HTML attributes to bind event handlers.  <a href="http://api.jquery.com/category/events/">jQuery</a> and <a href="http://documentcloud.github.com/backbone/">Backbone</a> made CSS selectors popular; <a href="http://knockoutjs.com/documentation/event-binding.html">Knockout</a> and <a href="http://docs.angularjs.org/">Angular</a> use HTML attributes. <br><br>  We prefer <a href="http://derbyjs.com/">HTML markup</a> , since it is more difficult to understand which CSS selector is responsible for the necessary elements, and it often happens that the HTML structure changes, imperceptibly destroying CSS selectors.  With markup, it is less likely that function names will be accidentally changed and an exception will be thrown that the required function was not found. <br><br>  Derby uses an innovative approach to bubbling events, which is more intuitive and understandable in comparison with the traditional approach.  Instead of floating up events up through the DOM nodes to the very root, Derby stops the ascent when the first tied handler finds it, and, as with the routes, you can continue the ascent of events by calling next (). <br><br><h4>  Fibers </h4><br>  Meteor uses <a href="https://github.com/laverdet/node-fibers">Fibers</a> , a Node.js extension that makes it possible to write code that looks synchronously, instead of the code traditional for most Node projects, based on a chain of callbacks.  Someone likes this way of writing asynchronous code, someone is totally against it.  There are many arguments, both for and against. <br><br>  The question is controversial, at the moment we prefer to stand aside from it.  A very <a href="http://www.mikealrogers.com/posts/a-vocal-minority.html">small percentage of npm modules are</a> written in this style, and we follow a more traditional approach to Node.js with callbacks. <br><br><h4>  Let's sum up </h4><br>  You can achieve almost the same result with both frameworks.  Both are powerful tools for developing programs that would be difficult to do using traditional web frameworks such as Rails or PHP. <br><br>  Derby focuses more on support for technologies such as conflict detection, support for offline clients and extremely fast page generation.  We are also more focused on compatibility with other modules that exist in the Node.js ecosystem, and are licensed to open. <br><br>  Ultimately, we all try to create the best tools for developers and the competitive spirit will only generate more innovation.  We are pleased to see other approaches in products such as <a href="http://meteor.com/">Meteor</a> , <a href="http://spacemagic.io/">SpaceMagic</a> or <a href="http://www.firebase.com/">Firebase</a> , since we all learn from each other.  In the end, this will lead to better tools, a better web and more convenience for our users. <br><br>  <b>From the translator</b> : In the time since the writing of the review, the products have grown, in a nutshell, what has changed in Meteor: <br>  1. Meteor is now also released under the MIT license. <br>  2. It became possible to use npm-modules, though not directly in the application - first they need to be wrapped in a wrapper from Meteor-packages <br>  3. Meteor has normal authorization, authentication. <br>  4. As for the server-side page generation, this possibility is incorporated in Spark (an intermediate DOM generation module, located under the handlebars in Meteor), but not yet implemented.  Indexing of pages is possible by connecting the spiderable module - it works with both Google and Yandex. <br><br>  If someone can tell what else has changed in Meteor or Derby - please comment. <br><br>  PS When translating used: <a href="http://goosly.com/89/myisli-o-derby-vs-meteor/">Thoughts on DERBY VS METEOR</a> </div><p>Source: <a href="https://habr.com/ru/post/191664/">https://habr.com/ru/post/191664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191652/index.html">Wireless Arduino with a range of more than a kilometer</a></li>
<li><a href="../191654/index.html">DoS exploit for WebKit engine</a></li>
<li><a href="../191656/index.html">JUG.ru: about the Petersburg Java User Group in a few minutes</a></li>
<li><a href="../191660/index.html">A way to extract data from 1C database</a></li>
<li><a href="../191662/index.html">Reverse engineering client Dropbox</a></li>
<li><a href="../191666/index.html">Shared VHDX in Windows Server 2012 R2</a></li>
<li><a href="../191670/index.html">Syrian hackers tweaked Twitter and The New York Times DNS records</a></li>
<li><a href="../191674/index.html">The evolution of the school program in computer science</a></li>
<li><a href="../191676/index.html">Overview of the network platform Lanner FW-7582</a></li>
<li><a href="../191678/index.html">Parallels Access: working with Windows and OS X applications on an iPad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>