<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the verge of madness</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Renju - the lot of commoners 
 heroes play chess 
 Go - the game of gods 

 Japanese proverb. 

 Against stupidity, the gods themselves fight powerles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the verge of madness</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/b37/d17/0db/b37d170dbd1d4407af20af86eb6d8203.PNG">  <b><i>Renju - the lot of commoners</i></b> <b><i><br></i></b>  <b><i>heroes play chess</i></b> <b><i><br></i></b>  <b><i>Go - the game of gods</i></b> <b><i><br><br></i></b>  <b><i>Japanese proverb.</i></b> <b><i><br><br></i></b>  <b><i>Against stupidity, the gods themselves fight powerless.</i></b> <b><i>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </i></b>  <b><i>Isaac Asimov.</i></b> <b><br></b> <br><br>  With the arrival of autumn, I want a strange one.  I thought about what should be the game, which is the most difficult to play?  I am interested in a kind of analogue of <a href="https://ru.wikipedia.org/wiki/Brainfuck">Brainfuck</a> from the world of board games.  I would like the rules of the game to be as simple as possible ( <a href="http://habrahabr.ru/post/234587/">rhythmology</a> for this definition is clearly not appropriate).  <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE">Go</a> is a good candidate for this role, but people play it quite massively (although it is not easy).  If Go is a game of gods, then you want to see a game that would be difficult for the gods themselves to play.  I decided to oppose the relics of the gods.  In a good way ... <br><a name="habracut"></a><br>  Certainly, I will not be the first to publish a post dedicated to the game " <a href="https://ru.wikipedia.org/wiki/%25D0%2596%25D0%25B8%25D0%25B7%25D0%25BD%25D1%258C_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Life</a> " on Habr√©.  This topic has been discussed repeatedly.  There were traditional posts " <a href="http://habrahabr.ru/post/202766/">... in 30 lines</a> ", there were also <a href="http://habrahabr.ru/post/218229/">funny posts</a> .  Considered <a href="http://habrahabr.ru/post/168421/">other</a> <a href="http://habrahabr.ru/post/154753/">spaces</a> and the possibility of <a href="http://habrahabr.ru/post/228203/">changing the</a> <a href="http://habrahabr.ru/post/111686/">rules</a> .  Dear <a href="http://habrahabr.ru/users/x0m9k/" class="user_link">x0m9k</a> showed how to implement <a href="http://habrahabr.ru/post/225473/">"Life" on Haskell</a> , and <a href="http://habrahabr.ru/users/barsmonster/" class="user_link">BarsMonster</a> connected it with <a href="http://habrahabr.ru/post/180135/">the Fourier transform</a> .  I, on the basis of "Life", decided to implement a board game (and in this I am again <a href="http://habrahabr.ru/post/49713/">not original</a> ). <br><br>  Why did I base the game "Life"?  For two reasons: <br><br><ol><li>  The rules of this game are easy to articulate. </li><li>  It is very difficult to predict what the initial configuration will become in just a few turns. </li></ol><br>  This is a good start for a truly challenging game, but two important points are missing: interactivity and the ability of the game to be played by several players.  The game "Life" is completely interactive.  You can build very complex initial configurations (for example, entire production lines for the production of "gliders" or even <a href="http://rendell-attic.org/gol/utm/index.htm">a Turing machine</a> ), but once the process has begun, the "player" plays the role of an observer.  You can not change anything.  Also, the initial concept does not provide for the participation in the game of two (or more) competing principles (this topic, although in a slightly different plane, was considered in the <a href="http://habrahabr.ru/post/154015/">posts of</a> <a href="http://habrahabr.ru/users/psibg/" class="user_link">PsiBG</a> ). <br><br><h4>  <b>rules</b> </h4><br>  The problem of adding interactivity can be solved in different ways.  So <a href="http://habrahabr.ru/users/abarmot/" class="user_link">abarmot</a> , in his <a href="http://habrahabr.ru/post/49713/">post</a> , offered to give players the opportunity to "throw" ready-made forms or even "bombs" on the enemy's field, for clearing the territory (there were also proposals to "shoot" enemy territories with moving forms, for example, "gliders").  I think it is too difficult.  The change introducing interactivity into the game should be minimal. <br><br>  Let us give players the opportunity to add exactly one stone of their color onto the field per turn.  In any place of the board, the main thing is that it is empty.  All the rules of the game will be applied to stones added this way.  For example, if he has less than two neighbors, he will die before the next player is transferred (of course, he can take with him those stones that would live in his absence). <br><br>  According to the rules of the game "Life", new stones will be created on empty fields with exactly three neighbors.  The color of the new stone will be determined by the predominance of one or another color in this neighborhood.  It is clear that when playing two players, the color of the new stone will always be determined unequivocally.  The stones that are already on the board can also be repainted, depending on the prevalence of one or another color in the neighborhood (if the colors are equal, no changes occur).  The current color of the stone itself is not taken into account, only the color of its neighbors is important. <br><br>  Now, you can formulate the rules of the game: <br><br><ul><li>  The game is played on a square board, initially containing some stable configuration (the game cannot start from an empty board, because, in this case, all stones added by players will die immediately after the turn has been completed) </li><li>  The game involves two players making turns in turn. </li><li>  When making a move, each player must place exactly one stone of his own color on any free board field, after which all board fields are processed in accordance with the rules listed below. </li><li>  If exactly three stones are adjacent to an empty field (at a distance of one field orthogonal or diagonal), a new stone will appear on the next turn, the color of which is determined by the prevailing color among neighboring stones </li><li>  If less than two or more than three stones are adjacent to a stone, it dies before the next turn. </li><li>  A stone having two or three neighbors, on the next move, acquires a color that prevails among the neighbors (if the colors are equal, the color does not change) </li><li>  The game ends when all the stones of one of the colors die (the player whose stones died - lost) </li><li>  If all the stones on the board have died, a draw is declared. </li></ul><br>  I will not ‚Äúglue‚Äù the board into a torus, so the boundary effects will appear.  All fields outside the board will always remain empty.  I think this will make the game more interesting and unpredictable. <br><br><h4>  <b>Implementation</b> </h4><br>  This game can serve as a good illustration of the possibilities of ForthScript.  It is not so complicated that you can get confused in the details of implementation and, at the same time, not too trivial.  The basis is the code of placing stones on the board: <br><br><div class="spoiler">  <b class="spoiler_title">The stub game</b> <div class="spoiler_text"><pre><code class="hljs rust"><span class="hljs-number"><span class="hljs-number">19</span></span> CONSTANT R <span class="hljs-number"><span class="hljs-number">19</span></span> CONSTANT C {board RC {grid} board} {directions -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> {direction} North <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> {direction} South <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> {direction} East <span class="hljs-number"><span class="hljs-number">0</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> {direction} West -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> {direction} Northeast <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> {direction} Southeast -<span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> {direction} Northwest <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> {direction} Southwest directions} {players {player} B {player} W players} {turn-order {turn} B {turn} W turn-order} : <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>-stone ( -- ) empty? IF <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span> add-<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> ENDIF ; {moves <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>-moves {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>-stone moves} {pieces {piece} S {drops} <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>-moves pieces}</code> </pre> <br></div></div><br>  This code allows players to alternately place their stones on the free board fields.  It remains to implement the rules of "Life."  The main difficulty lies in the fact that the changes can not be made directly on the board, so that they do not affect the subsequent calculations.  Create an array that will be filled in the process of calculating the course: <br><br><div class="spoiler">  <b class="spoiler_title">Stroke calculation</b> <div class="spoiler_text"><pre> <code class="hljs php">RC * CONSTANT SIZE VARIABLE <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt SIZE [] <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-pos[] SIZE [] <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-player[] {players {neutral} ?E {player} B {player} W players} : gen-move ( pos player -- ) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt @ SIZE &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt @ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-player[] ! <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt @ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-pos[] ! <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt ++ <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : life-tick ( -- ) here SIZE BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP calc-neighbors w-neighbors @ b-neighbors @ + my-<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here w-neighbors @ b-neighbors @ &gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> W <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> gen-move <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DUP <span class="hljs-number"><span class="hljs-number">2</span></span> &lt; OVER <span class="hljs-number"><span class="hljs-number">3</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here ?E gen-move <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> w-neighbors @ b-neighbors @ &gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> my-player W &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here W gen-move <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> b-neighbors @ w-neighbors @ &gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> my-player B &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here B gen-move <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> DROP DUP <span class="hljs-number"><span class="hljs-number">0</span></span>= UNTIL DROP to ;</code> </pre><br></div></div><br>  Here the rules of the game "Life" are formulated.  The basis of the code is a loop that iterates through all the board fields (as a result of the fact that the board in Axiom is mapped to a one-dimensional array, the location of each field is determined by a simple numeric index).  Based on the counting result of the <b>calc-neighbors neighbors</b> , a decision is made to change the state of the field.  The index of the field to be changed is saved to the array <b>new-pos []</b> , and the color of the created figure will be saved in <b>new-player []</b> .  To allow the removal of pieces, a dummy player <b>? E has been created</b> .  I want to note that the names of players and figures are not accidentally so concise (why is this important, I will say later). <br><br><div class="spoiler">  <b class="spoiler_title">Counting neighbors</b> <div class="spoiler_text"><pre> <code class="hljs cmake">VARIABLE w-neighbors VARIABLE b-neighbors VARIABLE curr-pos : my-empty? ( -- ? ) here curr-pos @ = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> empty? <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : my-player ( -- player ) here curr-pos @ = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> current-player <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : calc-direction ( 'dir -- ) EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> my-empty? <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> my-player B = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> b-neighbors ++ <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> my-player W = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> w-neighbors ++ <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : calc-neighbors ( pos -- ) <span class="hljs-number"><span class="hljs-number">0</span></span> w-neighbors ! <span class="hljs-number"><span class="hljs-number">0</span></span> b-neighbors ! DUP to ['] North calc-direction DUP to ['] South calc-direction DUP to ['] West calc-direction DUP to ['] East calc-direction DUP to ['] Northeast calc-direction DUP to ['] Southeast calc-direction DUP to ['] Northwest calc-direction DUP to ['] Southwest calc-direction to ;</code> </pre><br></div></div><br>  Everything is simple here.  We move from the current position in eight different directions, counting the number of black and white neighbors in <b>b-neighbors</b> and <b>w-neighbors,</b> respectively.  There is only one subtle point - at the time of calculating the move, the state of the board does not take into account the result of the move just made by the player.  To solve this problem, override the <b>empty?</b>  and <b>player</b> (to <b>my-empty?</b> and <b>my-player</b> ), checking the field for emptiness and getting the color of the figure located on the field, so as to take into account the move just made (the position of the added stone will be stored in the variable <b>curr-pos</b> ). <br><br>  The vector of changes in the state of the board is received, it remains to apply it: <br><br><div class="spoiler">  <b class="spoiler_title">Position change</b> <div class="spoiler_text"><pre> <code class="hljs php">: exec-moves ( -- ) BEGIN <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt -- <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt @ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-player[] @ DUP ?E = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt @ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-pos[] @ capture-at <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> STONE <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt @ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-pos[] @ create-player-piece-type-at <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt @ <span class="hljs-number"><span class="hljs-number">0</span></span>= UNTIL ; : drop-stone ( -- ) <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> SIZE curr-pos ! here calc-neighbors w-neighbors @ b-neighbors @ + <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt ! here curr-pos ! drop life-tick <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-cnt @ <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> exec-moves <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> add-move <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ;</code> </pre><br></div></div><br>  Here you can see that <b>exec-moves</b> "scroll" the previously filled array, forming the commands necessary to change the position.  The <b>drop-stone</b> call is supplemented by the calculation of changes, as well as their application (in the event that there is something to apply).  Entirely source code is available on <a href="">GitHub</a> . <br><br><h4>  <b>results</b> </h4><br>  Just want to say that this game gave <a href="http://www.zillions-of-games.com/">ZoG a</a> real test of strength.  And ZoG failed this test.  Since each move can change the state of a large number of fields (up to all board fields), the size of the move record in ZSG notation can reach 500 or more bytes (if I had not taken care of the laconic naming of players and figures, the size of the record of moves would be much more ).  The ZoG shell for processing moves of this size is clearly not designed and sometimes falls.  Fortunately, the implementation intended for Axiom programs, which was provided to me by Greg Schmidt, copes with moves of this size.  This is how the game of two random players looks like: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Kz2yVO-S8NY%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700190,15700253&amp;usg=ALkJrhheh3erifYtx4n1hCRRUViZjeOXvQ" frameborder="0" allowfullscreen=""></iframe><br>  The party ends very quickly.  AutoPlay also shows nothing unexpected: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Final</span></span> results: Player <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"Random"</span></span>, wins = <span class="hljs-number"><span class="hljs-number">54</span></span>. Player <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">"Random"</span></span>, wins = <span class="hljs-number"><span class="hljs-number">46</span></span>. Draws = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> game(s) played</code> </pre><br>  There are almost equal victories, no draws.  Behavior becomes more interesting when setting the simplest evaluation function (similar to the one used in Ritmomachia): <br><br><div class="spoiler">  <b class="spoiler_title">Evaluation function</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">: OnEvaluate ( <span class="hljs-comment"><span class="hljs-comment">-- score ) current-player material-balance ;</span></span></code> </pre><br></div></div><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/-FzRqRjjXU0%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700190,15700253&amp;usg=ALkJrhgxO_YlbvW915rgkkuu71SIosxJXw" frameborder="0" allowfullscreen=""></iframe><br>  Each turn began to be calculated much longer, but the players began to play ‚Äúsmarter‚Äù (as a result, the game between two such players was delayed for almost unlimited time).  AutoPlay allows you to check how much such a player plays better than randomly: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Final</span></span> results: Player <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"Random"</span></span>, wins = <span class="hljs-number"><span class="hljs-number">0</span></span>. Player <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">"Eval"</span></span>, wins = <span class="hljs-number"><span class="hljs-number">100</span></span>. Draws = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> game(s) played</code> </pre><br>  You can see that the ‚Äúsmart‚Äù player confidently wins in 100 cases out of 100. This means that our game can be played purposefully.  True for people, it is still not intended. <br></div><p>Source: <a href="https://habr.com/ru/post/235483/">https://habr.com/ru/post/235483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../235465/index.html">Oracle vs Teradata vs Hadoop</a></li>
<li><a href="../235467/index.html">The Skip. How the ‚ÄúSkip Track‚Äù button influenced music consumption patterns</a></li>
<li><a href="../235473/index.html">Cach√© Native Access - working with native libraries in Cach√©</a></li>
<li><a href="../235477/index.html">Firefox 32 release</a></li>
<li><a href="../235479/index.html">Another "smart" outlet with your own hands. Part 1</a></li>
<li><a href="../235485/index.html">Yii2 RBAC setup</a></li>
<li><a href="../235487/index.html">How we (almost) defeated DirCrypt</a></li>
<li><a href="../235489/index.html">Apple Update Review Guideline, Redget Statistics and All Reports from the Unity Event - Main Mobile News for the Week</a></li>
<li><a href="../235491/index.html">Do you really need the source code?</a></li>
<li><a href="../235493/index.html">Structure attachments to list items in Sharepoint 2010</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>