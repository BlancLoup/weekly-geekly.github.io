<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to the implementation of auto-renewable subscriptions in iOS-applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Denis, I am developing Apphud - a service for analyzing auto-renewable subscriptions in iOS applications. 


 In this article, I wil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to the implementation of auto-renewable subscriptions in iOS-applications</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/qy/ut/ez/qyutezbsfdccsr1yrml6revzsbm.png" alt="image"></p><br><p>  Hello!  My name is Denis, I am developing Apphud - a service for analyzing auto-renewable subscriptions in iOS applications. </p><br><p>  In this article, I will tell you how to configure, implement and validate auto-renewable subscriptions in iOS 12 and iOS 13. I will talk about fine points and pitfalls with a bonus, which not all developers take into account. <a name="habracut"></a></p><br><h2 id="nastroyka-podpisok-v-app-store-connect">  Setting App Store Connect Subscriptions </h2><br><p>  If you already have a Bundle ID and the application you created, then you can skip these steps.  If you are creating an application for the first time, do the following: </p><br><p>  On <a href="https://developer.apple.com/account/ios/profile/">the Apple Developer Portal,</a> you must create <em>an explicit Bundle ID (App ID)</em> .  After opening the page called <em>Certificates, Identifiers &amp; Profiles</em> , go to the <em>Identifiers</em> tab.  In June 2019, Apple finally updated the portal layout in accordance with ASC (short for App Store Connect). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fad/ba4/609/fadba4609e2e25bf48f1f9149cf81332.png" alt="New design for the Apple Developer Portal in 2019"><br>  <em>New design for the Apple Developer Portal in 2019</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cbb/84c/1ea/cbb84c1eac492c0c10e18aa373272c49.png"></p><br><p> Explicit Bundle ID can be specified in the domain style ( <code>com.apphud.subscriptionstest</code> ).  In the <em>Capabilities</em> section, you will notice that the check mark next to <em>In App Purchases is</em> already standing.  After creating the <em>Bundle ID</em> ( <em>App ID</em> ), go to App Store Connect. </p><br><h3 id="testovye-polzovateli-sandbox-users">  Test Users (Sandbox users) </h3><br><p>  To test future purchases, you will need to create a test user.  To do this, go to ASC in the <em>Users and Access</em> tab, then in <em>Sandbox testers.</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b9/15b/25d/6b915b25d4b0ee1374756d84c04d64a4.png" alt="Sandbox user creation form"><br>  <em>Sandbox user creation form</em> </p><br><blockquote>  When creating a tester, you can specify any non-existent data, the main thing is not to forget the email and password later! </blockquote><p>  About how to test purchases with test credentials, I will tell you closer to the end of the article. </p><br><p>  Another important step is to set up contracts and banking data in the ‚Äú <em>Agreements, Taxes and Banking Transactions</em> ‚Äù section.  If you do not set up an agreement for paid applications, you will not be able to test auto-renewable subscriptions! </p><br><p>  You can then create a new application in the App Store Connect.  Specify a unique name and select your <em>Bundle ID</em> as the package <em>ID</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b9/15d/251/2b915d25116265c73951ebe326ca672f.png" alt="Package ID is your Bundle ID"><br>  <em>Package ID is your Bundle ID</em> </p><br><p>  Immediately after creating the application, go to the <em>Features</em> tab <em>.</em> </p><br><blockquote>  If you have already created an application, you can continue to read from here. </blockquote><p>  The process of creating an auto-renewable subscription consists of several steps: </p><br><p>  <strong>1. Create a subscription ID and create a <em>group of subscriptions</em> .</strong>  A group of subscriptions is a collection of subscriptions with different periods and prices, but which open the same functionality in the application.  Also, in a group of subscriptions, you can activate a free trial period only once, and only one of the subscriptions can be active.  If you want your application to have two different subscriptions at the same time, then you will need to create two groups of subscriptions. </p><br><p>  <strong>2. Filling in the subscription data: duration, display name in the App Store (not to be confused with just the name) and description.</strong>  If you add the first subscription to a group, you will need to specify the display name of the subscription group.  Remember to save changes often, ASC may hang at any time and stop responding. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/62b/639/230/62b6392305ee8cd98000ba60aa408eb8.png" alt="Subscription page"><br>  <em>Subscription screen</em> </p><br><p>  <strong>3. Filling in the subscription price.</strong>  There are two stages: the creation of prices and special offers.  Specify the real price in any currency, it is automatically recalculated for all other countries.  Introductory offers: here you can offer users a free trial period or prepayment discounts.  Promotions appeared in the App Store just recently in 2019: they allow you to offer special discounts to users who have canceled a subscription and which you want to return. </p><br><h3 id="generaciya-sekretnogo-obschego-klyucha-shared-secret-key">  Generating a secret shared key (shared secret key) </h3><br><p>  On the page with a list of all your created subscriptions, you will see the <em>Shared Key</em> button <em>for the application</em> .  This is a special string that is needed to validate a check in an iOS application.  We will need to validate the check to determine subscription status. </p><br><p>  Shared key can be of two types: a unique key for your application or a single key for your account.  Important: in no case do not recreate the key if you already have an application in the App Store, otherwise users will not be able to validate the check and your application will stop working as expected. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/644/ce1/5d1/644ce15d1961d54f5f6cc1cf15b7dda0.png" alt="In this example, three subscription groups and 3 annual subscriptions are created."><br>  <em>In this example, three subscription groups and 3 annual subscriptions are created.</em> </p><br><p>  Copy the ID of all your subscriptions and the shared key, this will come in handy later in the code. </p><br><h2 id="programmnaya-chast">  Software part </h2><br><p>  We proceed to the practical part.  What you need to make a full-fledged shopping manager?  At least the following should be implemented: </p><br><ol><li><p>  Checkout </p><br></li><li><p>  Check Subscription Status </p><br></li><li><p>  Check Update </p><br></li><li><p>  Transaction recovery (not to be confused with updating the check!) </p><br></li></ol><br><h3 id="oformlenie-pokupok">  Checkout </h3><br><p>  The entire checkout process can be divided into 2 stages: the receipt of products (class <code>SKProduct</code> ) and the initialization of the purchase process (class <code>SKPayment</code> ).  First of all, we must specify the delegate of the <code>SKPaymentTransactionObserver</code> protocol. </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Starts products loading and sets transaction observer delegate @objc func startWith(arrayOfIds : Set&lt;String&gt;!, sharedSecret : String){ SKPaymentQueue.default().add(self) self.sharedSecret = sharedSecret self.productIds = arrayOfIds loadProducts() } private func loadProducts(){ let request = SKProductsRequest.init(productIdentifiers: productIds) request.delegate = self request.start() } public func productsRequest(_ request: SKProductsRequest, didReceive response: SKProductsResponse) { products = response.products DispatchQueue.main.async { NotificationCenter.default.post(name: IAP_PRODUCTS_DID_LOAD_NOTIFICATION, object: nil) } } func request(_ request: SKRequest, didFailWithError error: Error){ print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  The <code>IAP_PRODUCTS_DID_LOAD_NOTIFICATION</code> notification <code>IAP_PRODUCTS_DID_LOAD_NOTIFICATION</code> used to update the UI in the application. </p><br><p>  Next, write a method to initialize the purchase: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(product : SKProduct, success: @escaping SuccessBlock, failure: @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.canMakePayments() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().transactions.last?.transactionState != .purchasing <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock = success <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock = failure <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payment = <span class="hljs-type"><span class="hljs-type">SKPayment</span></span>(product: product) <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().add(payment) }</code> </pre> <br><p>  The <code>SKPaymentTransactionObserver</code> delegate looks like this: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAPManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SKPaymentTransactionObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paymentQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> transaction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> transactions { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (transaction.transactionState) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .purchased: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failed: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"purchase error : \(transaction.error?.localizedDescription ?? "</span></span><span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.failureBlock?(transaction.error) cleanUp() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .restored: <span class="hljs-type"><span class="hljs-type">SKPaymentQueue</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>().finishTransaction(transaction) notifyIsPurchased(transaction: transaction) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .deferred, .purchasing: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyIsPurchased</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transaction: SKPaymentTransaction)</span></span></span></span> { refreshSubscriptionsStatus(callback: { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.successBlock?() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cleanUp() }) { (error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// couldn't verify receipt self.failureBlock?(error) self.cleanUp() } } func cleanUp(){ self.successBlock = nil self.failureBlock = nil } }</span></span></code> </pre> <br><p>  When the subscription is successful, the delegate method is called, in which the transaction has a status of <code>purchased</code> . </p><br><p>  But how to determine the expiration date of the subscription?  To do this, make a separate request to Apple. </p><br><h3 id="proverka-statusa-podpiski">  Check Subscription Status </h3><br><p>  The check is validated with the help of the POST-request <code>verifyReceipt</code> to Apple, as a parameter we send the encrypted check as a base64-encoded string, and in the answer we receive the same receipt in JSON format.  The array with the key <code>latest_receipt_info</code> will list all transactions from each period of each subscription, including trial periods.  We can only parse the answer and get the current expiration date for each product. </p><br><blockquote>  WWDC 2017 added the ability to receive only current checks for each subscription using the <code>exclude-old-transactions</code> key in the <code>verifyReceipt</code> request. </blockquote><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshSubscriptionsStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback : @escaping SuccessBlock, failure : @escaping FailureBlock)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// save blocks for further use self.refreshSubscriptionSuccessBlock = callback self.refreshSubscriptionFailureBlock = failure guard let receiptUrl = Bundle.main.appStoreReceiptURL else { refreshReceipt() // do not call block yet return } #if DEBUG let urlString = "https://sandbox.itunes.apple.com/verifyReceipt" #else let urlString = "https://buy.itunes.apple.com/verifyReceipt" #endif let receiptData = try? Data(contentsOf: receiptUrl).base64EncodedString() let requestData = ["receipt-data" : receiptData ?? "", "password" : self.sharedSecret, "exclude-old-transactions" : true] as [String : Any] var request = URLRequest(url: URL(string: urlString)!) request.httpMethod = "POST" request.setValue("Application/json", forHTTPHeaderField: "Content-Type") let httpBody = try? JSONSerialization.data(withJSONObject: requestData, options: []) request.httpBody = httpBody URLSession.shared.dataTask(with: request) { (data, response, error) in DispatchQueue.main.async { if data != nil { if let json = try? JSONSerialization.jsonObject(with: data!, options: .allowFragments){ self.parseReceipt(json as! Dictionary&lt;String, Any&gt;) return } } else { print("error validating receipt: \(error?.localizedDescription ?? "")") } self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } }.resume() }</span></span></code> </pre> <br><p>  At the beginning of the method, you can see that there is a check for the existence of a local copy of the check.  A local check may not exist, for example, if the application was installed via iTunes.  In the absence of a check, we cannot execute the <code>verifyReceipt</code> request.  We need to first get the actual local check, and then try to validate it again.  Updating a check is done using the <code>SKReceiptRefreshRequest</code> class: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refreshReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">SKReceiptRefreshRequest</span></span>(receiptProperties: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) request.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> request.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestDidFinish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: SKRequest)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// call refresh subscriptions method again with same blocks if request is SKReceiptRefreshRequest { refreshSubscriptionsStatus(callback: self.successBlock ?? {}, failure: self.failureBlock ?? {_ in}) } } func request(_ request: SKRequest, didFailWithError error: Error){ if request is SKReceiptRefreshRequest { self.refreshSubscriptionFailureBlock?(error) self.cleanUpRefeshReceiptBlocks() } print("error: \(error.localizedDescription)") }</span></span></code> </pre> <br><p>  <strong>Update check</strong> implemented in the function <code>refreshReceipt()</code> .  If the check has been successfully updated, the requestDidFinish delegate <code>requestDidFinish(_ request : SKRequest)</code> is called, which re-calls the <code>refreshSubscriptionsStatus</code> method. </p><br><p>  How is shopping information parsing implemented?  A JSON object is returned to us, in which there is a nested array of transactions (using the key <code>latest_receipt_info</code> ).  We go through the array, get the expiration date by the key <code>expires_date</code> and save it if this date has not yet arrived. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> json : Dictionary&lt;String, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// It's the most simple way to get latest expiration date. Consider this code as for learning purposes. Do not use current code in production apps. guard let receipts_array = json["latest_receipt_info"] as? [Dictionary&lt;String, Any&gt;] else { self.refreshSubscriptionFailureBlock?(nil) self.cleanUpRefeshReceiptBlocks() return } for receipt in receipts_array { let productID = receipt["product_id"] as! String let formatter = DateFormatter() formatter.dateFormat = "yyyy-MM-dd HH:mm:ss VV" if let date = formatter.date(from: receipt["expires_date"] as! String) { if date &gt; Date() { // do not save expired date to user defaults to avoid overwriting with expired date UserDefaults.standard.set(date, forKey: productID) } } } self.refreshSubscriptionSuccessBlock?() self.cleanUpRefeshReceiptBlocks() }</span></span></code> </pre> <br><p>  I gave the simplest example of how to retrieve the current expiration date of the subscription.  There is no error handling and, for example, there is no check for the return of the purchase ( <em>cancellation date is</em> added). </p><br><p>  To determine whether a subscription is active or not, it is enough to compare the current date with the date from <em>User Defaults</em> by product key.  If it is missing or less than the current date, the subscription is considered inactive. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expirationDateFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> identifier : String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Date?</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>.standard.object(forKey: identifier) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subscriptionDate = <span class="hljs-type"><span class="hljs-type">IAPManager</span></span>.shared.expirationDateFor(<span class="hljs-string"><span class="hljs-string">"YOUR_PRODUCT_ID"</span></span>) ?? <span class="hljs-type"><span class="hljs-type">Date</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isActive = subscriptionDate &gt; <span class="hljs-type"><span class="hljs-type">Date</span></span>()</code> </pre> <br><p>  Transaction recovery is performed in a single line, <code>SKPaymentQueue.default().restoreCompletedTransactions()</code> .  This function restores all completed transactions by calling the delegate method of the <code>func paymentQueue(**_** queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</code> . </p><br><h3 id="chem-otlichaetsya-obnovlenie-cheka-ot-vosstanovleniya-tranzakciy">  What is different about updating a check from transaction recovery? </h3><br><p>  Both methods help recover purchase data.  But what are their differences?  There is a wonderful table with <a href="https://developer.apple.com/videos/play/wwdc2017/305/">wwdc video</a> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c21/520/f53/c21520f531f3df7a185296f33bfa8f2b.png" alt="Table of differences between two ways to restore purchases from WWDC"><br>  <em>Table of differences between two ways to restore purchases from WWDC</em> </p><br><p>  In most cases, you only need to use <code>SKReceiptRefreshRequest()</code> , because we are only interested in receiving a receipt for the subsequent calculation of the expiration date. </p><br><p>  In the case of auto-renewable subscriptions, the transactions themselves do not interest us, so it suffices to use only the update of the check.  However, there are cases when you need to use the transaction recovery method: if your application downloads content with the purchase (Apple hosted content) or if you still support versions below iOS 7. </p><br><h3 id="testirovanie-pokupok-sandbox-testing">  Shopping Testing (Sandbox Testing) </h3><br><p>  Previously, to test purchases it was necessary to log out from the App Store in the settings of your iPhone.  This was a big inconvenience (for example, the entire Apple Music library was erased).  But now it is not necessary to do this: the sandbox account now exists separately from the main account. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/846/b0d/1d5/846b0d1d5a265e9a3f38ebeaa1bd61ef.jpg"></p><br><p>  The purchase process occurs in a similar way compared to the actual purchases in the App Store, but there are some points: </p><br><ul><li><p>  You will always need to enter the login-password through the system window.  Shopping using Touch ID / Face ID is still not supported. </p><br></li><li><p>  If the system again and again asks for the login and password when entering the login and password correctly, <em>click ‚ÄúCancel‚Äù</em> , minimize the application, then try again.  It looks like nonsense, but for many it works.  But sometimes after the second password is entered, the process still goes on. </p><br></li><li><p>  You can‚Äôt test the cancellation process. </p><br></li><li><p>  Duration of subscription periods is significantly lower than real ones.  And they are updated no more than 6 times a day. </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Actual duration </th><th>  Test duration </th></tr></thead><tbody><tr><td>  Week 1 </td><td>  3 minutes </td></tr><tr><td>  1 month </td><td>  5 minutes </td></tr><tr><td>  2 months </td><td>  10 minutes </td></tr><tr><td>  3 months </td><td>  15 minutes </td></tr><tr><td>  6 months </td><td>  30 minutes </td></tr><tr><td>  1 year </td><td>  1 hour </td></tr></tbody></table></div><br><h3 id="chto-novogo-v-storekit-v-ios-13">  What's new in StoreKit in iOS 13? </h3><br><p>  From the new - only the <code>SKStorefront</code> class, which gives information about exactly which country this user is registered in the App Store.  This can be useful to those developers who use different subscriptions for different countries.  Previously, everyone checked by geolocation or by device region, but this did not give an accurate result.  Now it's very easy to find out the country in the App Store: <code>SKPaymentQueue.default().storefront?.countryCode</code> .  The delegate of the method was also added if during the buying process the country was changed in the App Store.  In this case, you can continue or cancel the purchase process. </p><br><h2 id="podvodnye-kamni-pri-rabote-s-podpiskami">  Pitfalls when working with subscriptions </h2><br><ul><li>  Checking a check straight from the device is not recommended by Apple.  They talked about <a href="https://developer.apple.com/videos/play/wwdc2017/305/">this</a> several times <a href="https://developer.apple.com/videos/play/wwdc2017/305/">at WWDC</a> (from 5:50) and this is indicated in the <a href="https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html">documentation</a> .  This is insecure because an attacker can intercept data using a man-in-the-middle attack.  The correct way to check checks is local validation or using your own server. </li><li>  There is a problem with checking the expiration date.  If you do not use your server, then the system time on the device can be changed to an older one and then our code will give the wrong result - the subscription will be considered active.  If this does not suit you, then you can use any service that issues accurate world time. </li><li>  Not for all users a free trial period may be available.  The user could reinstall the application after some time, and the application will show that the trial is available as usual.  It will be correct to update the check, validate it and check the availability of trial for this user in JSON.  Many do not. </li><li>  If the user has requested a refund, then <code>cancellation_date</code> will be added to the subscription JSON, but <code>expires_date</code> will remain unchanged.  Therefore, it is important to always check for the presence of the <code>cancellation_date</code> field, which is preferential to <code>expires_date</code> . </li><li>  You should not update the check every time you start the application, because, firstly, it is meaningless, and secondly, the user will most likely see the Apple ID password window.  Update the check is, for example, when the user himself pressed the button to restore purchases. </li><li>  How to determine when it is worth validating a check to get the current subscription expiration date?  You can validate a check every time you start it or only when the subscription expires.  However, if you check the check only when the subscription expires, the user who has made a refund will be able to use your application for free until the end of the period. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I hope this article will be useful to you.  I tried to add not only the code, but also to explain the subtle points in the development.  Full class code can be downloaded <a href="https://gist.github.com/ren6/2e04b222c736df18cc7919c5e6116c26">here</a> .  This class will be very useful for familiarizing novice developers and those who want to learn more about how things work.  For live applications, it is recommended to use more serious solutions, for example, <a href="https://github.com/bizz84/SwiftyStoreKit">SwiftyStoreKit</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/456602/">https://habr.com/ru/post/456602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456594/index.html">2 minutes with Webpack tree-shaking and re-export</a></li>
<li><a href="../456596/index.html">Microbiota How testing works</a></li>
<li><a href="../4566/index.html">The military stood in the way of 3G</a></li>
<li><a href="../45660/index.html">"The BlackBerry Storm is not monstrously convenient," - complains the reviewer of the NY Times</a></li>
<li><a href="../456600/index.html">Nginx recipes: LDAP authorization with captcha</a></li>
<li><a href="../456604/index.html">As we automated a large online store and began to match products automatically</a></li>
<li><a href="../456606/index.html">News from the world of OpenStreetMap ‚Ññ 464 (04.06.2019-10.06.2019)</a></li>
<li><a href="../45661/index.html">New search engine Keyboardr does not like mice</a></li>
<li><a href="../456610/index.html">Do not press and do not approve</a></li>
<li><a href="../456612/index.html">One of the hundreds of ways to publish multiple production projects on one server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>