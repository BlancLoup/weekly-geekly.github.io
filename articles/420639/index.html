<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Akka antipatterns: too many actors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By akka few materials on Habr√©. I decided to translate some antipatterns described by Manuel in his blog. They really may not be obvious to people who...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Akka antipatterns: too many actors</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/qx/zr/fg/qxzrfgwmebe3dou1nddp-sx5hou.jpeg" alt="image"><br><br>  By akka few materials on Habr√©.  I decided to translate some antipatterns described by Manuel in his blog.  They really may not be obvious to people who first encountered the framework. <br><a name="habracut"></a><br>  It occurred to me that I had not yet written about this very frequent anti-pattern.  It can often be found in the code of developers who are just starting to work with the actor model. <br><br>  There are two ways to get too many actors: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - having developed a system with too many different types of actors, many of which are not needed <br>  - creating a very large number of actors in runtime, when it is not necessary and inefficient <br><br>  Let's look at these options in detail. <br><br><h3>  Too many types of actors. </h3><br>  The general idea is something like this: ‚Äúwe have actors, so everything must be an actor‚Äù. <br><br>  The actor model makes it easy to write asynchronous applications.  It does this by providing the illusion of synchronous execution of the code inside the actor - there is no need to worry about parallel access to the state of one actor, because only the actor can access its state, and the messages are processed one at a time, one by one. <br><br>  But in fact, not everything needs to be done asynchronously.  Calls to methods that are associated exclusively with the CPU (and are not ‚Äúblocked‚Äù in the sense that they do not completely overload the CPU, for example, calculating the value of Pi) should not be performed asynchronously. <br><br>  I often see code with a large number of different actors interacting with each other and not doing anything that has a great advantage in asynchronous or simultaneous execution.  In these projects, the same state should be stored by each of these actors or transferred to them in each message. <br><br>  This approach has two drawbacks: <br><br>  - You get nothing in terms of performance.  On the contrary, there are overhead costs associated with the creation of messages and their transmission. <br>  - With each type of actor and its associated messages, the system becomes more complex to understand and maintain. <br><br>  Therefore, when designing actor systems, you need to think about what should actually be asynchronous, mainly: <br><br>  - calls to external systems (outside of your jvm) <br>  - calls to blocking operations (obsolete APIs, heavy computations, ...) <br><br><h3>  Too many actors in runtime </h3><br>  The general idea is something like this: "the more actors we have, the faster everything will go." <br><br>  And indeed, the actors are easy, and <a href="https://doc.akka.io/docs/akka/2.5/general/actor-systems.html">you can run millions of them in one virtual machine</a> .  Yes, you can.  But is it necessary? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vj/e3/lt/vje3ltv7mdcav3hptghw2zchn4m.png" alt="image"></div><br>  If you can, it does not mean that you should <br><br>  The short answer is: not always - it depends on what you do with the actors. <br><br>  If there are many long-lived actors in your system, each of which contains a few states and interact with each other from time to time, you may well end up with a million actors - and this is a legitimate use case, very well supported by Akka.  For example, you can create a system with a large number of users, where each user is represented by an actor.  The pure Akka actor takes only 300 bytes of memory, so it is quite possible to create millions on one machine and leave them to work without worrying about anything.  And if, ultimately, you create many actors or actors with a large state, that they no longer fit into the memory of one machine, cluster sharding simplifies the distribution of actors across several machines. <br><br>  However, if you have several types of actors that are involved in calculating something ‚Äî for example, parsing an XML document ‚Äî it‚Äôs doubtful to create millions of such actors (whether directly or through a router). <br><br>  The processor has a fixed number of cores (hardware threads) at its disposal, and the processing of messages by Akka actors is performed in the ExecutionContext based on the thread pool.  By default, this is fork-join-executor, based on ForkJoinPool, added in Java 7. <br><br>  But, despite its technical advantage, forkjoinpool is not a magic that repeals the laws of physics.  If you have one million actors, each of which analyzes an XML document (already loaded into memory) and 4 hardware streams, the system will not work much better than if you only had 4 actors analyzing these XML documents (with condition of uniform load).  In fact, your system will work much better with 4 actors, because there will be only minimal overhead in terms of memory planning and management.  By the way, if there are only a few actors on your system, check your thread pool, which is probably trying to reuse the same thread for the same actor. <br><br>  In general, the system will not work faster if you create a lot of actors. <br><br><h3>  Actors without state </h3><br>  Actors are object-oriented correctly (unlike, say, from objects in Java): their state is not visible from the outside, and they communicate through messages.  It is impossible to break the encapsulation, because it is impossible to look into the state of the actor during its operation.  This is the whole point of the actors: they give you the illusion of a safe space in which messages are executed sequentially, one after another, allowing you to use a variable state inside your actor without worrying about the race condition (well, almost without worrying: the main thing is not to allow the state to leak). <br><br>  That is why the use of actors who do not have a state is somewhat strange, to say the least.  With the exception of the actors who control the monitoring of large parts of the hierarchy of the system of actors (for example, setting up backup supervisors), the actors are really designed to work with long calculations that have a state.  Speaking long, I mean that the actor will process several messages throughout its life, producing different results depending on its state, as opposed to one-time calculations.  For them, futures are an excellent abstraction: they allow asynchronous code execution, are ideal for networking or disk-related computing (or really processor-intensive tasks), can be composited, and have a failure handling mechanism.  They also integrate well with Akka actors (using the pipe pattern). <br><br>  In general: do not use actors, if you do not have a state - they are not intended for this. </div><p>Source: <a href="https://habr.com/ru/post/420639/">https://habr.com/ru/post/420639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420629/index.html">PHP Digest No. 137 (August 6 - 20, 2018)</a></li>
<li><a href="../420631/index.html">We are not afraid of "clouds"</a></li>
<li><a href="../420633/index.html">We write GeoIP exporter for Prometheus with visualizations in Grafana in 15 minutes</a></li>
<li><a href="../420635/index.html">AI, practical course. The basic model of recognition of emotions in images</a></li>
<li><a href="../420637/index.html">WANHAO D9 / 300 3D Printer Review: Video</a></li>
<li><a href="../420641/index.html">Technical support 3CX responds: backup and restore 3CX from the command line</a></li>
<li><a href="../420643/index.html">Almost everything is the same, only 10 times cheaper</a></li>
<li><a href="../420645/index.html">Realistic hiring practice for engineers</a></li>
<li><a href="../420647/index.html">Why video game characters almost never undress</a></li>
<li><a href="../420651/index.html">Scientists have unearthed information about the unpleasant precedent associated with climate change</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>