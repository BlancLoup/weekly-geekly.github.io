<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Balancing write and read in the database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, I described the concept and implementation of a database, built on the basis of functions, rather than tables and fields as i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Balancing write and read in the database</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0w/wi/gl/0wwiglioocbaxcpjodrzg5x1ocs.jpeg" alt="image"></div><br>  In the previous <a href="https://habr.com/ru/company/lsfusion/blog/458774/">article,</a> I described the concept and implementation of a database, built on the basis of functions, rather than tables and fields as in relational databases.  It contained many examples showing the advantages of this approach over the classical one.  Many found them not convincing enough. <br><br>  In this article, I will show how this concept allows you to quickly and conveniently balance writing and reading to the database without any change in the operation logic.  They tried to implement similar functionality in modern commercial DBMS (in particular, Oracle and Microsoft SQL Server).  At the end of the article I will show what happened to them, to put it mildly, not very. <br><a name="habracut"></a><br><h3>  Description </h3><br>  As before, for a better understanding, I will begin the description with examples.  Suppose we need to implement a logic that will return a list of departments with the number of employees in them and their total salary. <br><br>  In a functional database, it will look like this: <br><div class="scrollable-table"><table><tbody><tr><td><code><font color="#a626a4">CLASS</font> Department ''; <br> name '' = <font color="#a626a4">DATA</font> <font color="#a626a4">STRING</font> [ <font color="#986801">100</font> ] (Department); <br> <br> <font color="#a626a4">CLASS</font> Employee ''; <br> department '' = <font color="#a626a4">DATA</font> Department (Employee); <br> salary '' = <font color="#a626a4">DATA</font> <font color="#a626a4">NUMERIC</font> [ <font color="#986801">10</font> , <font color="#986801">2</font> ] (Employee); <br> <br> countEmployees '- ' (Department d) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">IF</font> department(Employee e) = d; <br> salarySum ' ' (Department d) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> salary(Employee e) <font color="#a626a4">IF</font> department(e) = d; <br> <br> SELECT name(Department d), countEmployees(d), salarySum(d); <br></code> </td></tr></tbody></table></div>  The complexity of executing this query in any DBMS will be equivalent to <i>O (number of employees)</i> , since for this calculation it is necessary to scan the entire table of employees, and then group them by department.  There will also be some small (we believe that employees are much more than departments), depending on the chosen plan <i>O (log number of employees)</i> or <i>O (number of departments)</i> for grouping and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is clear that the overhead of execution may be different in different DBMS, but the complexity will not change in any way. <br><br>  In the proposed implementation, the functional DBMS will form one subquery, which will calculate the necessary values ‚Äã‚Äãby department, and then make a JOIN with a table of departments to get the name.  However, for each function during the announcement there is an opportunity to set a special MATERIALIZED marker.  The system will automatically create the appropriate field for each such function.  When the function value changes, the field value will also change in the same transaction.  When accessing this function, the call will already be addressed to the readable field. <br><br>  In particular, if you put MATERIALIZED for the functions <i>countEmployees</i> and <i>salarySum</i> , then the table with the list of departments will add two fields in which the number of employees and their total salary will be stored.  When any change of employees, their salaries or belonging to departments, the system will automatically change the values ‚Äã‚Äãof these fields.  The above request will be directly addressed to these fields and will be executed for <i>O (number of departments)</i> . <br><br>  What are the limitations?  Only one thing: such a function must have a finite number of input values ‚Äã‚Äãfor which its value is defined.  Otherwise it will be impossible to build a table storing all its values, since there can be no table with an infinite number of rows. <br><br>  Example: <br><div class="scrollable-table"><table><tbody><tr><td> <code>employeesCount '    &gt; N' (Department d, <font color="#a626a4">NUMERIC</font> [ <font color="#986801">10</font> , <font color="#986801">2</font> ] N) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> salary(Employee e) <font color="#a626a4">IF</font> department(e) = d <font color="#a626a4">AND</font> salary(e) &gt; N; <br></code> </td></tr></tbody></table></div>  This function is defined for an infinite number of values ‚Äã‚Äãof the number N (for example, any negative value is appropriate).  Therefore, it can not put MATERIALIZED.  Thus, this is a logical and not a technical limitation (that is, not because we could not implement it).  The rest - no restrictions.  You can use grouping, sorting, AND and OR, PARTITION, recursion, etc. <br><br>  For example, in task 2.2 of the previous article you can put MATERIALIZED on both functions: <br><div class="scrollable-table"><table><tbody><tr><td> <code>bought <font color="#50a14f">''</font> (Customer c, Product p, <font color="#a626a4">INTEGER</font> y) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> sum(Detail d) <font color="#a626a4">IF</font> <br> customer(order(d)) = c <font color="#a626a4">AND</font> <br> product(d) = p <font color="#a626a4">AND</font> <br> extractYear(date(order(d))) = y <font color="#a626a4">MATERIALIZED</font> ; <br> rating <font color="#50a14f">''</font> (Customer c, Product p, <font color="#a626a4">INTEGER</font> y) = <br> <font color="#a626a4">PARTITION</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">ORDER</font> <font color="#a626a4">DESC</font> bought(c, p, y), p <font color="#a626a4">BY</font> c, y <font color="#a626a4">MATERIALIZED</font> ; <br> SELECT contactName(Customer c), name(Product p) <font color="#a626a4">WHERE</font> rating(c, p, <font color="#986801">1997</font> ) &lt; <font color="#986801">3</font> ; <br></code> </td></tr></tbody></table></div>  The system itself will create one table with keys of the <i>Customer</i> , <i>Product</i> and <i>INTEGER types</i> , add two fields to it and update the field values ‚Äã‚Äãin them with any changes.  Further calls to these functions will not calculate them, but will read the values ‚Äã‚Äãfrom the corresponding fields. <br><br>  With this mechanism, for example, you can get rid of in recursions (CTE) in queries.  In particular, consider the groups that form a tree using the child / parent relationship (each group has a link to its parent): <br><div class="scrollable-table"><table><tbody><tr><td> <code>parent = <font color="#a626a4">DATA</font> Group (Group); <br></code> </td></tr></tbody></table></div>  In the functional database, the logic of recursions can be defined as follows: <br><div class="scrollable-table"><table><tbody><tr><td> <code>level (Group child, Group parent) = <font color="#a626a4">RECURSION</font> <font color="#986801">1l</font> <font color="#a626a4">IF</font> child <font color="#a626a4">IS</font> Group <font color="#a626a4">AND</font> parent == child <br> <font color="#a626a4">STEP</font> <font color="#986801">2l</font> <font color="#a626a4">IF</font> parent == parent($parent); <br> isParent (Group child, Group parent) = <font color="#a626a4">TRUE</font> <font color="#a626a4">IF</font> level(child, parent) <font color="#a626a4">MATERIALIZED</font> ; <br></code> </td></tr></tbody></table></div>  Since MATERIALIZED is affixed to the <i>isParent</i> function, a table with two keys (groups) will be created under it, in which the <i>isParent</i> field will be true only if the first key is a descendant of the second.  The number of entries in this table will be equal to the number of groups multiplied by the average depth of the tree.  If it is necessary, for example, to count the number of descendants of a certain group, then you can refer to this function: <br><div class="scrollable-table"><table><tbody><tr><td> <code>childrenCount (Group g) = <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">IF</font> isParent(Group child, g); <br></code> </td></tr></tbody></table></div>  There will be no CTE in the SQL query.  Instead, there will be a simple GROUP BY. <br><br>  Using this mechanism, you can also easily denormalize the database if necessary: <br><div class="scrollable-table"><table><tbody><tr><td> <code><font color="#a626a4">CLASS</font> Order <font color="#50a14f">''</font> ; <br> date <font color="#50a14f">''</font> = <font color="#a626a4">DATA</font> <font color="#a626a4">DATE</font> (Order); <br> <br> <font color="#a626a4">CLASS</font> OrderDetail <font color="#50a14f">' '</font> ; <br> order <font color="#50a14f">''</font> = <font color="#a626a4">DATA</font> Order (OrderDetail); <br> date <font color="#50a14f">''</font> (OrderDetail d) = date(order(d)) <font color="#a626a4">MATERIALIZED</font> <font color="#a626a4">INDEXED</font> ; <br></code> </td></tr></tbody></table></div>  When accessing the <i>date</i> function for the order line, there will be a reading from the table with the order lines of the field that has an index.  When you change the date of the order, the system will automatically automatically recalculate the denormalized date in the row. <br><br><h3>  Benefits </h3><br>  What is this mechanism for?  In classical DBMS, without rewriting queries, the developer or DBA can only change indices, define statistics and prompt the query planner how to execute them (and HINTs are only in commercial DBMS).  No matter how hard they try, they will not be able to execute the first request in the article for <i>O (number of departments)</i> without changing requests and adding triggers.  In the proposed scheme, at the development stage, you can not think about the structure of data storage and which aggregations to use.  All this can be easily changed on the fly already directly in operation. <br><br>  In practice, it looks like this.  Some people develop logic directly based on the task.  They do not understand the algorithms and their complexity, or the implementation plans, or the types of joines, nor any other technical component.  These people are more business intelligence than developers.  Then, it all goes into testing or operation.  Logging of long queries is enabled.  When a long query is discovered, then by other people (more technical - in fact, DBA) a decision is made to enable MATERIALIZED on some intermediate function.  Thus, the recording slows down a bit (since an additional field in the transaction needs to be updated).  However, not only this request is significantly accelerated, but also all others that use this function.  In this case, the decision on which function to materialize is relatively easy to take.  Two main parameters: the number of possible input values ‚Äã‚Äã(exactly how many records will be in the corresponding table), and how often it is used in other functions. <br><br><h3>  Analogs </h3><br>  Modern commercial databases have similar mechanisms: MATERIALIZED VIEW with FAST REFRESH (Oracle) and INDEXED VIEW (Microsoft SQL Server).  In PostgreSQL, MATERIALIZED VIEW is not able to be updated in a transaction, but only upon request (and even with very strict restrictions), so it is not considered.  But they have several problems, which significantly limits their use. <br><br>  First, you can enable materialization only if you have already created a normal VIEW.  Otherwise, you will have to rewrite the remaining requests for accessing the newly created view in order to use this materialization.  Or leave everything as it is, but it will be at least inefficient if there is some data already defined, but many queries do not always use them, but calculate it anew. <br><br>  Secondly, they have a huge number of restrictions: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle</b> <div class="spoiler_text"><blockquote><h5>  5.3.8.4 General Restrictions on Fast Refresh </h5><br>  The defining query is restricted as follows: <br><ul><li>  The materialized view must not contain references to non-repeating expressions like <code>SYSDATE</code> and <code>ROWNUM</code> . </li><li>  The materialized view must not be referenced to <code>RAW</code> or <code>LONG</code> <code>RAW</code> data types. </li><li>  It cannot contain a <code>SELECT</code> list subquery. </li><li>  It cannot contain analytic functions (for example, <code>RANK</code> ) in the <code>SELECT</code> clause. </li><li>  It can not <code>XMLIndex</code> indexed. </li><li>  It cannot contain a <code>MODEL</code> clause. </li><li>  It cannot contain a <code>HAVING</code> clause with a subquery. </li><li>  It cannot contain nested queries that have <code>ANY</code> , <code>ALL</code> , or <code>NOT</code> <code>EXISTS</code> . </li><li>  It cannot contain a <code>[START WITH ‚Ä¶] CONNECT BY</code> clause. </li><li>  It cannot contain multiple detail tables at different sites. </li><li>  <code>ON</code> <code>COMMIT</code> materialized views cannot have remote detail tables. </li><li>  Nested materialized views must be a join or aggregate. </li><li>  GROUPED clause cannot be selected from an index-organized table. </li></ul><br><h5>  5.3.8.5 Restrictions </h5><br>  The following restrictions on fast refreshing: <br><ul><li>  All restrictions from " <a href="http://basic-materialized-views.html/">General Restrictions on Fast Refresh</a> ". </li><li>  They cannot have <code>GROUP</code> <code>BY</code> clauses or aggregates. </li><li>  Rowids of all tables in the <code>FROM</code> list must appear in the <code>SELECT</code> list of the query. </li><li>  Materialized view logs must be listed in the <code>FROM</code> list of the query. </li><li>  It‚Äôs not a problem to make a statement. </li></ul><br>  Also, you should not be optimally efficient if: <br><ul><li>  The defining query uses the outer join.  If the defining query contains such a join, consider rewriting the defining query to contain an inner join. </li><li>  The <code>SELECT</code> list of materialized view contains several tables. </li></ul><br><h5>  5.3.8.6 Restrictions on Fast Foods with Aggregates </h5><br>  Fast refreshing queries: <br><ul><li>  All restrictions from " <a href="http://basic-materialized-views.html/">General Restrictions on Fast Refresh</a> ". </li></ul><br>  Fast refresh is supported for both the following restrictions apply: <br><ul><li>  All tables in the materialized logs must be: <br><ul><li>  Contain all columns from the table referenced in the materialized view. </li><li>  Specify with <code>ROWID</code> and <code>INCLUDING</code> <code>NEW</code> <code>VALUES</code> . </li><li>  Specify your <code>SEQUENCE</code> clause if you need a mix of directs, directs, deletes, and updates. </li></ul><br></li><li>  Only <code>SUM</code> , <code>COUNT</code> , <code>AVG</code> , <code>VARIANCE</code> , <code>VARIANCE</code> , <code>MIN</code> and <code>MAX</code> are supported for fast refresh. </li><li>  <code>COUNT(*)</code> must be specified. </li><li>  Aggregate functions must occur only in the outermost part of the expression.  That is, aggregates such as <code>AVG(AVG(x))</code> or <code>AVG(x)</code> + <code>AVG(x)</code> are not allowed. </li><li>  For each aggregate such as <code>AVG(expr)</code> , the corresponding <code>COUNT(expr)</code> must be present.  Oracle recommends that <code>SUM(expr)</code> be specified. </li><li>  If <code>VARIANCE(expr)</code> or <code>STDDEV(expr</code> ) is specified, <code>COUNT(expr)</code> and <code>SUM(expr)</code> must be specified.  Oracle recommends that <code>SUM(expr *expr)</code> be specified. </li><li>  The <code>SELECT</code> column in the defining query cant be a complex expression with multiple base tables.  A possible workaround is a materialized view. </li><li>  The <code>SELECT</code> list must contain all <code>GROUP</code> <code>BY</code> columns. </li><li>  Materialized view. </li><li>  If you‚Äôre using a must must must must must must must must </li><li>  If it is a materialized view, it is supported only on conventional DML inserts and direct loads. <br><ul><li>  Materialized views with <code>MIN</code> or <code>MAX</code> aggregates </li><li>  Materialized views which have <code>SUM(expr)</code> but no <code>COUNT(expr)</code> </li><li>  Materialized views without <code>COUNT(*)</code> </li></ul><br>  This is a materialized view. </li><li>  If you don‚Äôt have what it is, it doesn‚Äôt have a <code>WHERE</code> clause. <br>  DML doesn‚Äôt have the same behavior as the insert-only case.  It deletes and recomputes the max / min values ‚Äã‚Äãfor the affected groups.  You need to be aware of its performance impact. </li><li>  It can be completely refined and can be completely refreshed.  For information on which views will merge, see <a href="https://www.oracle.com/pls/topic/lookup%3Fctx%3Den/database/oracle/oracle-database/19/dwhsg%26amp%3Bid%3DTGSQL591">Oracle Database SQL Language Reference</a> . </li><li>  If there are no arbitrary selections and joins in the <code>WHERE</code> clause. </li><li>  There has been a change in the aggregate.  The join join table.  If there are outer joins, it must be the equality ( <code>=</code> ) operator. </li><li>  For materialized views with <code>CUBE</code> , <code>ROLLUP</code> , grouping sets, or <br><ul><li>  The <code>SELECT</code> list should contain a <code>GROUPING_ID</code> function.  For example, if it is a <code>CUBE(a, b)</code> , then it should be either " <code>GROUPING_ID(a, b)</code> " or " <code>GROUPING(a)</code> <code>AND</code> <code>GROUPING(b)</code> "for the materialized view to be fast refreshable. </li><li>  <code>GROUP</code> <code>BY</code> should not result in any duplicate groupings.  For example, " <code>GROUP BY a, ROLLUP(a, b)</code> " is not fast refreshable because it results in duplicate groupings " <code>(a), (a, b), AND (a)</code> ". </li></ul></li></ul><br><h5>  5.3.8.7 Restrictions on UNION ALL </h5><br>  If you are satisfied with the following conditions: <br><ul><li>  <code>ALL</code> operator at the top level. <br><br>  It can be used as a rule for the submission of the segregation. example: <br><pre>  CREATE VIEW view_with_unionall AS
 (SELECT c.rowid crid, c.cust_id, 2 umarker
  FROM customers with WHERE c.cust_last_name = 'Smith'
  UNION ALL
  SELECT c.rowid crid, c.cust_id, 3 umarker
  FROM customers with WHERE c.cust_last_name = 'Jones');<font></font>
<font></font>
 CREATE MATERIALIZED VIEW unionall_inside_view_mv
 REFRESH FAST ON DEMAND AS
 SELECT * FROM view_with_unionall;
</pre>  Note that the view <code>view_with_unionall</code> satisfies the requirements for a fast refresh. </li><li>  It is a fast refreshing materialized view. <br><br>  There is no need for any type of fast refreshing materialized view. <br>  It is also possible to note that the Oracle database will be included.  This is shown in the defining query of the view <code>view_with_unionall</code> . </li><li>  <code>SELECT</code> list of each query, you must include a <code>UNION</code> <code>ALL</code> branch.  The list of each query block should be followed.  See " <a href="http://advanced-query-rewrite-materialized-views.html/">UNION ALL Marker and Query Rewrite</a> " for more information regarding <code>UNION</code> <code>ALL</code> markers. </li><li>  Aggregate materialized aggregate material aggregate material aggregate material aggregate material views.  Note, however, that it can be fast refreshed when it‚Äôs used. </li><li>  A quick refreshable materialized view with <code>UNION</code> <code>ALL</code> . </li></ul></blockquote></div></div><br>  I do not want to offend Oracle fans, but judging by their list of restrictions, it seems that this mechanism was not written in the general case, using some kind of model, but thousands of Hindus, where everyone was given to write their own branch, and each of them could, then and did.  Using this mechanism for real logic is like walking a minefield.  At any time you can get a mine, hitting one of the not obvious restrictions.  How it works is also a separate issue, but it is outside the scope of this article. <br><br><div class="spoiler">  <b class="spoiler_title">Microsoft SQL Server</b> <div class="spoiler_text"><blockquote><h3>  Additional Requirements </h3><br>  In addition to the SET options, you must met: <br><ul><li>  <code>CREATE INDEX</code> must be the owner of the view. </li><li>  <code>IGNORE_DUP_KEY</code> option must be set to OFF (the default setting). </li><li>  Tables must be referenced by two-part names, <em>schema</em> <strong>.</strong>  <em>tablename</em> in the view definition. </li><li>  User-defined functions referenced in the view must be created by using the <code>WITH SCHEMABINDING</code> option. </li><li>  Any user defined functions should be referenced by two-part names, <em>&lt;schema&gt;</em> <strong>.</strong>  <em>&lt;function&gt;</em> . </li><li>  There is <code>NO SQL</code> , and it must be <code>NO</code> . </li><li>  It can be used to make a list of the indexed keys.  CLR functions can not be seen in the view. </li><li>  It is shown in the following table. <br><div class="scrollable-table"><table><thead><tr><th>  Property </th><th>  Note </th></tr></thead><tbody><tr><td>  DETERMINISTIC = TRUE </td><td>  The Microsoft .NET Framework method. </td></tr><tr><td>  PRECISE = TRUE </td><td>  Must be declared attribute of the .NET Framework method. </td></tr><tr><td>  DATA ACCESS = NO SQL </td><td>  Determined by setting DataAccess attribute to DataAccessKind.None and SystemDataAccess attribute to SystemDataAccessKind.None. </td></tr><tr><td>  EXTERNAL ACCESS = NO </td><td>  This property defaults to NO for CLR routines. </td></tr><tr><td></td><td></td></tr></tbody></table></div></li><li>  The view must be created by using the <code>WITH SCHEMABINDING</code> option. </li><li>  This is the same database as the view.  Reference view views. </li><li>  The following Transact-SQL elements include: <br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td> <code>COUNT</code> </td> <td>  ROWSET functions ( <code>OPENDATASOURCE</code> , <code>OPENQUERY</code> , <code>OPENROWSET</code> , AND <code>OPENXML</code> ) </td><td>  <code>OUTER</code> joins ( <code>LEFT</code> , <code>RIGHT</code> , or <code>FULL</code> ) </td></tr><tr><td>  Derived table (defined by clause) </td><td>  Self-joins </td><td>  Specifying columns by using <code>SELECT *</code> or <code>SELECT &lt;table_name&gt;.*</code> </td></tr><tr><td> <code>DISTINCT</code> </td> <td>  <code>STDEV</code> , <code>STDEVP</code> , <code>VAR</code> , <code>VARP</code> , or <code>AVG</code> </td><td>  Common table expression (CTE) </td></tr><tr><td>  <strong>float</strong> <sup>1</sup> , <strong>text</strong> , <strong>ntext</strong> , <strong>image</strong> , <strong>XML</strong> , or <strong>filestream</strong> columns </td><td>  Subquery </td><td>  <code>OVER</code> clause, which includes ranking or aggregate window functions </td></tr><tr><td>  Full-text predicates ( <code>CONTAINS</code> , <code>FREETEXT</code> ) </td><td>  <code>SUM</code> function that references a nullable expression </td><td> <code>ORDER BY</code> </td> </tr><tr><td>  CLR user-defined aggregate function </td><td> <code>TOP</code> </td> <td>  <code>CUBE</code> , <code>ROLLUP</code> , or <code>GROUPING SETS</code> operators </td></tr><tr><td>  <code>MIN</code> , <code>MAX</code> </td><td>  <code>UNION</code> , <code>EXCEPT</code> , or <code>INTERSECT</code> operators </td><td> <code>TABLESAMPLE</code> </td> </tr><tr><td>  Table variables </td><td>  <code>OUTER APPLY</code> or <code>CROSS APPLY</code> </td><td>  <code>PIVOT</code> , <code>UNPIVOT</code> </td></tr><tr><td>  Sparse column sets </td><td>  Inline (TVF) or multi-statement table-valued functions (MSTVF) </td><td> <code>OFFSET</code> </td> </tr><tr><td> <code>CHECKSUM_AGG</code> </td> <td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><br>  <sup>1</sup> The indexed view can contain <strong>float</strong> columns;  however, such columns cannot be included in the clustered index key. </li><li>  If <code>GROUP BY</code> is present, the VIEW definition must contain <code>COUNT_BIG(*)</code> and must not contain <code>HAVING</code> .  <code>GROUP BY</code> restrictions are applicable only to the indexed view definition.  It doesn‚Äôt matter if there is a group of restrictions. </li><li>  If you have a <code>GROUP BY</code> clusters, it will be possible to use the group of clauses. </li></ul></blockquote></div></div><br>  Here it can be seen that the Indians did not attract, as they decided to do according to the scheme ‚Äúwe will do little, but well‚Äù.  That is, they have more mines on the field, but their location is more transparent.  What is most upsetting is this restriction: <br><blockquote>  This is the same database as the view.  Reference view views. </blockquote><br>  In our terminology, this means that a function cannot refer to another materialized function.  It cuts the whole ideology on the vine. <br>  Also, this restriction (and further in the text) greatly reduces the use cases: <br><blockquote>  The following Transact-SQL elements include: <br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td> <code>COUNT</code> </td> <td>  ROWSET functions ( <code>OPENDATASOURCE</code> , <code>OPENQUERY</code> , <code>OPENROWSET</code> , AND <code>OPENXML</code> ) </td><td>  <code>OUTER</code> joins ( <code>LEFT</code> , <code>RIGHT</code> , or <code>FULL</code> ) </td></tr><tr><td>  Derived table (defined by clause) </td><td>  Self-joins </td><td>  Specifying columns by using <code>SELECT *</code> or <code>SELECT &lt;table_name&gt;.*</code> </td></tr><tr><td> <code>DISTINCT</code> </td> <td>  <code>STDEV</code> , <code>STDEVP</code> , <code>VAR</code> , <code>VARP</code> , or <code>AVG</code> </td><td>  Common table expression (CTE) </td></tr><tr><td>  <strong>float</strong> <sup>1</sup> , <strong>text</strong> , <strong>ntext</strong> , <strong>image</strong> , <strong>XML</strong> , or <strong>filestream</strong> columns </td><td>  Subquery </td><td>  <code>OVER</code> clause, which includes ranking or aggregate window functions </td></tr><tr><td>  Full-text predicates ( <code>CONTAINS</code> , <code>FREETEXT</code> ) </td><td>  <code>SUM</code> function that references a nullable expression </td><td> <code>ORDER BY</code> </td> </tr><tr><td>  CLR user-defined aggregate function </td><td> <code>TOP</code> </td> <td>  <code>CUBE</code> , <code>ROLLUP</code> , or <code>GROUPING SETS</code> operators </td></tr><tr><td>  <code>MIN</code> , <code>MAX</code> </td><td>  <code>UNION</code> , <code>EXCEPT</code> , or <code>INTERSECT</code> operators </td><td> <code>TABLESAMPLE</code> </td> </tr><tr><td>  Table variables </td><td>  <code>OUTER APPLY</code> or <code>CROSS APPLY</code> </td><td>  <code>PIVOT</code> , <code>UNPIVOT</code> </td></tr><tr><td>  Sparse column sets </td><td>  Inline (TVF) or multi-statement table-valued functions (MSTVF) </td><td> <code>OFFSET</code> </td> </tr><tr><td> <code>CHECKSUM_AGG</code> </td> <td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div></blockquote><br>  OUTER JOINS, UNION, ORDER BY and others are prohibited.  Perhaps it was easier to point out what can be used than what is impossible.  The list would probably be much smaller. <br><br>  Summing up: a huge set of restrictions in each (I note commercial) DBMS vs no (except for one logical, but not technical) in the LGPL technology.  However, it should be noted that to implement this mechanism in relational logic is somewhat more complicated than in the described functional. <br><br><h3>  Implementation </h3><br>  How it works?  PostgreSQL is used as a ‚Äúvirtual machine‚Äù.  Inside there is a complex algorithm that deals with the construction of queries.  Here is the <a href="https://github.com/lsfusion/platform">source code</a> .  And there is not just a big set of heuristics with a bunch of ifs.  So, if you have a couple of months to study, you can try to understand the architecture. <br><br>  Does it work efficiently?  Efficiently enough.  Unfortunately, it is hard to prove.  I can only say that if you consider the thousands of requests that exist in large applications, then on average they are more efficient than a good developer.  An excellent SQL programmer can write any query more efficiently, but on a thousand queries it simply will have neither motivation nor time to do it.  The only thing that I can now give as evidence of efficiency is that based on the platform built on this database, there are several <a href="https://github.com/lsfusion-solutions/erp">ERP system</a> projects in which there are thousands of different MATERIALIZED functions, with thousands of users and terrabite databases with hundreds of millions of records running on a regular two-processor server.  However, anyone can test / disprove efficiency by downloading the <a href="https://lsfusion.org/">platform</a> and PostgreSQL, <a href="https://tableplus.io/blog/2018/10/how-to-show-queries-log-in-postgresql.html">enabling</a> SQL query logging and trying to change the logic and data there. <br><br>  In the following articles, I will also talk about how you can hang restrictions on functions, work with change sessions, and more. </div><p>Source: <a href="https://habr.com/ru/post/459066/">https://habr.com/ru/post/459066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459046/index.html">How to independently implement (Proof of Existence) in 2 steps</a></li>
<li><a href="../459050/index.html">Powerful module for typing Vuex</a></li>
<li><a href="../459052/index.html">How to compare: ‚Äúamazing cars‚Äù and ‚Äúugly barracks‚Äù, in a marketing survey and in big data</a></li>
<li><a href="../459054/index.html">Heat map of clicks - how users behave on the site</a></li>
<li><a href="../459062/index.html">The digest of interesting materials for the mobile # 305 developer (July 1 - 7)</a></li>
<li><a href="../459068/index.html">Windows Server 2008 R2 - The King Is Dead, Long Live The King</a></li>
<li><a href="../45907/index.html">Whom ‚ÄúOdnoklassniki‚Äù scared ‚ÄúGoogle‚Äù?</a></li>
<li><a href="../459070/index.html">Creating a Tower Defense game in Unity: turrets and shooting at enemies</a></li>
<li><a href="../459074/index.html">Small python joy # 7: three things for the price of one - console animation, algorithms and debugging</a></li>
<li><a href="../459078/index.html">CERN switches to open source software - why?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>