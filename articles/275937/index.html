<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fuzzy search in the dictionary with the universal Levenshtein automaton. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fuzzy string searching is a very costly task in terms of computing resources, especially if you need high accuracy of the results. The article describ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fuzzy search in the dictionary with the universal Levenshtein automaton. Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/543/5b4/0f0/5435b40f0ed04ef2971984189149ce95.png"><br><br>  Fuzzy string searching is a very costly task in terms of computing resources, especially if you need high accuracy of the results.  The article describes the fuzzy search algorithm in the dictionary, which provides high search speed while maintaining 100% accuracy and relatively low memory consumption.  It is the Levenshtein machine gun that allowed Lucene developers to increase the speed of fuzzy search <a href="http://blog.mikemccandless.com/2011/03/lucenes-fuzzyquery-is-100-times-faster.html">by two orders of magnitude.</a> <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  Fuzzy search of lines in the dictionary is the basis for the construction of modern spell checking systems that are used in text editors, optical character recognition systems and search engines.  In addition, fuzzy search is used in solving a number of computational problems of bioinformatics. <br><br><img src="https://habrastorage.org/files/23a/8cd/606/23a8cd606b094945a9797e7009e34c21.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The formal definition of the fuzzy search task in the dictionary can be formulated as follows.  For a given search query <b>W,</b> it is necessary to select from the dictionary <b>D a</b> subset <b>P of</b> all words, the measure of difference between which <b>p</b> and search query does not exceed a certain threshold value <b>N</b> : <br><br><img src="https://habrastorage.org/files/88a/6bc/22e/88a6bc22edd44246b49a937b38294f6b.png"><br><br>  The degree of difference between two words can be measured, for example, using the <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">Levenshtein</a> or <a href="http://en.wikipedia.org/wiki/Damerau%25E2%2580%2593Levenshtein_distance">Damerau-Levenshtein distance</a> . <br><br>  The Levenshtein distance is a measure of the difference between two lines, defined as the minimum number of inserts, deletes, and replacements of characters required to translate one line to another. <br><br>  When calculating the Damerau-Levenshtein distance, transpositions (permutations of two adjacent symbols) are also allowed. <br><br><img src="https://habrastorage.org/files/e5b/eb0/908/e5beb0908e464ce8a85f0b00b6e90ac6.png"><br><br>  A few years ago on Habr√© there was already a <a href="http://habrahabr.ru/post/114997/">post</a> from <a href="https://habr.com/users/ntz/" class="user_link">ntz</a> devoted to fuzzy searching in the dictionary and text - in more detail about the distances of Levenshteyn and Damerau-Levenshteyn can be read there.  I only remind you that the time complexity of checking the conditions <br>  <b>p (Pi, W) &lt;= N</b> using dynamic programming methods is estimated as <br><br><img src="https://habrastorage.org/files/e56/07d/9b0/e5607d9b0fe54730a99575fb783f2f7c.png">  , <br><br>  where <b>| P <sub>i</sub> |, | W |</b>  - the length of the string and the request, respectively.  Therefore, in solving practical problems, a complete enumeration of the dictionary values ‚Äã‚Äãwith the verification of each word is, as a rule, unacceptable. <br><br>  It should be noted that not every fuzzy search algorithm ensures that all the words from the dictionary <b>D</b> that satisfy the condition <b>p (P <sub>i</sub> , W) &lt;= N are</b> found at the request of <b>W.</b>  Therefore, it makes sense to talk about the accuracy of the search as the ratio of the number of results found to the actual number of words in the dictionary that satisfy the given condition.  For example, the author of the <a href="http://habrahabr.ru/post/114997/">post</a> already mentioned by me estimated the accuracy of the search by the n-gram method at 65%. <br><br><h3>  Nondeterministic Lowenstein automaton </h3><br>  The author assumes that the reader is familiar with the basics of the theory of automata and formal languages ‚Äã‚Äãand will refrain from presenting the terminology of this subject area.  Instead, I'll get right to the point. <br><br>  To solve practical problems, a deterministic Levenshtein finite automaton is used (if to be completely accurate, then its imitation).  However, in order to understand the principles of operation of the deterministic Levenshtein finite state machine, it is better to first consider the operation of the non-deterministic version. <br><br>  <b>For a Levenshtein automaton for a word W,</b> we call the finite automaton <b>A <sub>N</sub> (W)</b> , which accepts the word <b>S</b> if and only if the Levenshtein (Damerau-Levenshtein) distance between the words <b>W</b> and <b>S</b> does not exceed the specified value <b>N.</b> <br><br>  The Levenshtein finite-state machine for the word <b>W</b> and the admissible number of modifications <b>N</b> can be given in the form of an ordered five of elements <b>A <sub>N</sub> (W) = &lt;E, Q, q <sub>0</sub> , F, V&gt;</b> , where: <br><br>  <b>E</b> is the automaton alphabet; <br>  <b>Q</b> is the set of internal states; <br>  <b>q <sub>0</sub></b> is the initial state, belongs to the set Q; <br>  <b>F</b> - a set of final, or final states <br>  <b>V</b> is a transition function that determines which (which) states it is possible to switch from the current state when the automaton arrives at the input of the next character. <br><br>  The states of the non-deterministic Levenshtein automaton <b>A <sub>N</sub> (W) are</b> usually denoted as <b>i <sup>#e</sup></b> , where <b>i = 0 .. | W |</b>  , <b>e = 0 ..N</b> .  If the automaton is in the <b>i <sup>#e state</sup></b> , it means that <b>i</b> ‚Äúcorrect‚Äù characters have been entered into the automaton and <b>e</b> modifications have been detected.  Since we consider an automaton that supports transpositions (that is <b>, the</b> Damerau-Levenshtein distance is used as <b>p (S, W)</b> ), the set of states must be supplemented with the states <b>{i <sub>T</sub> <sup>#e</sup> }</b> , where <b>i = 0 .. | W | -1</b> , <b>e = 1..N</b> . <br><br>  The initial state of the automaton is the state <b>0 <sup># 0</sup></b> . <br><br>  The set of final states includes such states <b>i <sup>#e</sup></b> for which the condition <b>| W |</b>  <b>- i &lt;= N - e</b> . <br><br>  Based on the physical meaning of the states of the automaton, it is not difficult to determine the composition of admissible transitions.  The transition function of the Levenshtein automaton is specified as a table. <br><br>  If you are interested in a rigorous mathematical substantiation of the composition of the states of the automaton and other theses presented above, you can find it in the <a href="http://link.springer.com/article/10.1007%252Fs10032-002-0082-8">article by Schultz and Mihov (2002)</a> . <br><br>  <b>The characteristic vector Z (x, W <sub>i</sub> )</b> for the symbol <b>x</b> is the bit vector of length <b>min (N + 1, | W | - i)</b> , the <b>kth</b> element of which is equal to <b>1</b> if <b>(i + k)</b> ith character of the string <b>W</b> is equal to <b>x</b> , and <b>0</b> otherwise.  For example, for <b>W</b> = ‚ÄùPISK‚Äù <br>  <b>Z ('P', W <sub>0</sub> )</b> = &lt;1, 0&gt;, and <b>Z ('P', W <sub>1</sub> )</b> = &lt;0, 0&gt;. <br><br><img src="https://habrastorage.org/files/1c1/a97/f21/1c1a97f21c1f4412887cd8d8ced041f7.png"><br><br>  A graphic representation of the Levenshtein automaton for <b>W</b> = ‚ÄùPISK‚Äù and <b>N</b> = 1 is shown in the figure.  Transitions of the automaton are signed by their corresponding characteristic vectors. <br><br><img src="https://habrastorage.org/files/dd0/2ac/08c/dd02ac08c6ba43f39f19ee892fe6e932.png"><br><br>  The end states of the automaton are highlighted in green.  Light blue - the current (active) state of the machine. <br><br>  The transition along horizontal arrows is carried out when a ‚Äúcorrect‚Äù symbol is entered into the machine. <br><br>  The transition along the vertical arrows corresponds to the assumption that the next symbol entered into the automaton is inserted into the original word <b>W</b> before the <b>(i + 1)</b> -th symbol.  When moving along vertical arrows, the automaton ‚Äúdetects‚Äù a modification of the word <b>W</b> - the value of <b>e</b> increases by <b>1</b> . <br><br>  The transition from the state <b>i <sup>#e</sup></b> to the state <b>(i + 1) <sup># e + 1</sup></b> corresponds to the assumption that the next character replaces the <b>(i +1)</b> -th symbol in the word <b>W.</b> <br><br>  The transition from the state <b>i <sup>#e</sup></b> to the state <b>(i + 2) <sup># e + 1</sup></b> corresponds to the assumption that the next character corresponds to the <b>(i + 2)</b> th character in the word <b>W</b> , and the <b>(i + 1)</b> th character of the word <b>W is</b> omitted in the word <b>s</b> . <br><br>  Probably, you have already guessed that the transition to the state <b>i <sub>T</sub> <sup>#e</sup></b> implies that the transposition of the <b>(i + 1)</b> -th and <b>(i + 2)</b> -th characters of the word <b>W is</b> detected. <br><br>  Now let's see how it works.  Entering a new symbol into the automaton will be indicated by a curved red arrow, and to the right of the arrow you will indicate the value of the characteristic vector.  This is how the automaton <b>A <sub>1</sub> (‚ÄúPISK‚Äù)</b> will work when you type the word ‚ÄúSEARCH‚Äù into it. <br><br><img src="https://habrastorage.org/files/9f0/c08/50a/9f0c0850aef04b11aedbae37845d5c46.gif"><br><br>  Note, in fact, the sequence of changes in the states of the automaton is not determined by the specific word supplied to the input of the automaton, but only by the sequence of characteristic vectors.  This sequence may be the same for two different words.  For example, if the automaton is set to the word ‚Äúmother‚Äù, then the sequence of characteristic vectors will be the same for the words ‚ÄúLama‚Äù, ‚Äúframe‚Äù, ‚Äúlady‚Äù, etc. <br><br>  Another interesting fact is that the structure of admissible transitions of the automaton does not change for <b>i = 0 .. | W |</b>  <b>- (N + 1)</b> . <br><br>  These two circumstances make it possible, when using a software implementation of fuzzy search algorithms, to use a machine that is not calculated for each specific word, but its universal imitation.  That is why the title of the post deals with the ‚Äúuniversal‚Äù Lowenstein automaton. <br><br>  The calculation of the automaton for a particular word <b>S</b> is reduced in this case to a simple calculation of the characteristic vectors for each character <b>x of the</b> word <b>S.</b>  The change of states is programmatically implemented as a simple increase in the two variables <b>e</b> , <b>i</b> by a value determined from universal tables.  <a href="http://link.springer.com/article/10.1007%252Fs10032-002-0082-8">Schulz and Mihov (2002)</a> showed that the calculation of all characteristic vectors for the word <b>S</b> can be made in time <b>O (| S |)</b> .  This is the temporary complexity of the machine. <br><br>  Symbols of the word <b>S are</b> sequentially fed to the input of the machine.  If, after submitting a symbol, it becomes clear that the distance between lines <b>S</b> and <b>W</b> exceeds the threshold value <b>N</b> , then the machine is in the ‚Äúempty‚Äù state ‚Äî there are no active states in the machine.  In this case, the need to calculate the characteristic vectors for the remaining characters of the word <b>S is</b> eliminated. <br><br>  This is how the automaton ‚Äúfulfills‚Äù the word <b>S</b> = ‚ÄùIKS‚Äù with <b>W</b> = ‚ÄùPISK‚Äù: <br><br><img src="https://habrastorage.org/files/4e0/bd1/855/4e0bd1855e6b440097d7d54d9d4129a4.gif"><br><br>  After entering the ‚ÄúAND‚Äù symbol in the machine, four active states appeared at once, however, after entering the ‚ÄúK‚Äù symbol, there were no active states left - the machine turned out to be in an error state and did not accept the word ‚ÄúX‚Äù.  In this case, the calculation of the characteristic vectors for the symbol ‚ÄúC‚Äù was not carried out. <br><br><h3>  Deterministic Lowenstein automaton </h3><br>  In accordance with the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">theorem on determinism,</a> for any non-deterministic finite-state machine, an equivalent deterministic finite-state machine can be constructed.  Why do we need a deterministic automaton?  Just when the software implementation, it will work faster.  Mainly due to the fact that it can have only one current state and, as a result, when entering the next character, it will be necessary to calculate only one characteristic vector and define only one transition using the transition table. <br><br>  If, for the nondeterministic Lowenstein automaton <b> <sub>1</sub> (W)</b> considered above, iterate through all possible values ‚Äã‚Äãof the characteristic vectors, then it can be verified that the states constituting one of the following sets can be active at the same time: <br><br><img src="https://habrastorage.org/files/9f9/59b/0d1/9f959b0d15654c1bbb26a45422ce06bd.png"><br><br>  The six sets listed above will be the states of the deterministic Lowenstein automaton for <b>N</b> = 1.  More precisely, the automaton will have six states for <b>i = 0 .. | W | -2</b> , three states for <b>i = | W | -1</b> and two more states for <b>i = | W |</b>  . <br><br>  The dimension of the characteristic vector for a deterministic automaton can be calculated as <b>2N + 1</b> .  Then the automaton transition table for a word from <b>| W |</b>  letters with <b>N</b> = 1 should have <b>2 <sup>2x1 + 1</sup></b> lines and <b>6x (| W | -1) + 3 + 2</b> columns (for example, 8x35 for a word of 6 letters).  In addition, such a table will have to be calculated for each value of <b>| W |</b>  separately.  This is not very convenient and requires additional time to calculate or additional memory for storage. <br><br>  However, as I already wrote above, the composition of admissible transitions of the automaton does not change for <b>i = 0 .. | W |</b>  <b>- (2N + 1)</b> .  Therefore, with a software implementation, it is much more convenient to simulate a deterministic automaton instead of calculating the real one.  To do this, it is enough to store the offset value <b>i</b> and use a universal jump table with eight rows and six columns.  Such a table can be calculated in advance. <br><br><img src="https://habrastorage.org/files/d35/670/1ea/d356701eabe14f68848c658e605c4fb0.png"><br><br>  As <b>i</b> increases, some states of the automaton become unreachable, therefore for <b>i = | W | -2 .. | W |</b>  separate smaller tables should be provided. <br><br>  Further, speaking of the Levenshtein deterministic automaton, I will imply the universal imitation described above. <br><br>  With increasing <b>N, the</b> number of states increases exponentially.  So, for <b>N</b> = 2, a deterministic automaton can have 42 states, for <b>N</b> = 3, already several hundred.  This means that the memory consumption will be proportional to <b>O (N <sup>2</sup> )</b> . <br><br>  The initial state of the Levenshtein deterministic automaton will be the state <b>A <sub>0</sub></b> . <br><br>  Which states will be final?  Those that correspond to the final states of a non-deterministic automaton.  For <b>N</b> = 1, these will be the states <b>A <sub>| W |</sub></b>  , <b>B <sub>| W |</sub></b>  , <b>A <sub>| W | -1</sub></b> , <b>C <sub>| W | -1</sub></b> , <b>D <sub>| W | -2</sub></b> , <b>E <sub>| W | -2</sub></b> , <b>F <sub>| W | -2</sub></b> . <br><br>  Since the number of transitions between the six states is very large, and the physical meaning of the states of the deterministic Lowenstein automaton is not obvious, I will not give here a graphical representation.  I think that the picture is not quite clear.  If you still want to see her, you can find in the article by <a href="http://www.cis.uni-muenchen.de/people/Schulz/Pub/aspaperCISreport.pdf">Mihov and Schultz (2004)</a> .  I will give one more example of the work of a non-deterministic automaton, but this time I will indicate in what state its deterministic equivalent is at each moment. <br><br><img src="https://habrastorage.org/files/f84/765/e14/f84765e14b314cd395b3db6461cf85c1.gif"><br><br><h3>  Software implementation of the Levenshtein deterministic automaton </h3><br>  I wrote the software implementation of the Lowenstein automaton in C # - this language is most familiar to me.  Sources can be found <a href="http://github.com/ibendrup/LevenshteinAutomaton">here</a> .  Universal conversion tables are implemented as fields of the static class ParametricDescription.  The class contains universal conversion tables for <b>N</b> = 1.2. <br><br>  In addition to transition tables, the ParametricDescription class also contains offset increment tables.  The offset increment is the amount by which the value of <b>i</b> must be increased when entering the next state. <br><br>  The Levenshtein automaton itself is implemented in the LevTAutomataImitation class.  All class methods are quite simple and I will not describe them in detail.  When performing a fuzzy search in the dictionary, it is enough to create one instance of the class per request. <br><br>  Please note - the creation of an instance of the LevTAutomataImitation class is performed in a small constant time for any values ‚Äã‚Äãof <b>W</b> , <b>S</b> , <b>N.</b>  An instance of the class stores only the value of <b>W</b> and auxiliary variables of small size. <br><br>  To select only those lines from the array of lines that are not more than 2 from the Damerau-Levenshtein distance, you can use the following code: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Misspelled word string wordToSearch = "fulzy"; //Your dictionary string[] dictionaryAsArray = new string[] { "fuzzy", "fully", "funny", "fast"}; //Maximum Damerau-Levenstein distance const int editDistance = 2; //Constructing automaton LevTAutomataImitation automaton = new LevTAutomataImitation (wordToSearch, editDistance); //List of possible corrections IEnumerable&lt;string&gt; corrections = dictionaryAsArray.Where(str =&gt; automaton.AcceptWord(str));</span></span></code> </pre> <br>  The code above implements the simplest fuzzy search algorithm in the dictionary using the Levenshtein automaton ‚Äî an exhaustive search algorithm.  Of course, this is not the most efficient algorithm.  I will talk about more efficient search algorithms using the Levenshtein automaton in the <a href="http://habrahabr.ru/post/276019">second part of the article</a> . <br><br><h3>  Links </h3><br><ol><li>  Source codes for an article in <a href="http://github.com/ibendrup/LevenshteinAutomaton">C #</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">Levenshtein distance</a> </li><li>  Distance <a href="http://en.wikipedia.org/wiki/Damerau%25E2%2580%2593Levenshtein_distance">Damerau-Levenshteyn</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">State machine</a> </li><li>  <a href="http://habrahabr.ru/post/114997">Good post about a fuzzy search in the dictionary and text</a> </li><li>  Brief description of the <a href="http://en.wikipedia.org/wiki/Levenshtein_automaton">Levenshtein</a> automaton </li><li>  A detailed mathematical description of the Levenshtein automaton in the article by <a href="http://link.springer.com/article/10.1007%252Fs10032-002-0082-8">Schultz and Mikhov (2002)</a> </li><li>  Another article by <a href="http://www.cis.uni-muenchen.de/people/Schulz/Pub/aspaperCISreport.pdf">Mihov and Schulz (2004)</a> on the same topic. </li><li>  The history of the introduction of Levenshtein's automaton into the fuzzy search for <a href="http://blog.mikemccandless.com/2011/03/lucenes-fuzzyquery-is-100-times-faster.html">Lucene</a> </li><li>  Implementations in java: <a href="http://github.com/universal-automata/liblevenshtein-java">one</a> and <a href="http://github.com/itdraft/levenshtein-automaton">two</a> </li><li>  <a href="http://habrahabr.ru/post/276019">The second part of my publication</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/275937/">https://habr.com/ru/post/275937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275921/index.html">Data centers without people as a new trend</a></li>
<li><a href="../275923/index.html">Welcome to the meeting Moscow.pm February 4</a></li>
<li><a href="../275927/index.html">Optimization of Android-games created on Unity for the Intel platform: an example from life</a></li>
<li><a href="../275929/index.html">Setting color tabs in the new assembly Vivaldi 1.0.380.2</a></li>
<li><a href="../275933/index.html">Grandstream First Conference Background Review - GAC2500</a></li>
<li><a href="../275939/index.html">Dry anti-pattern</a></li>
<li><a href="../275943/index.html">Building Android applications step by step, part one</a></li>
<li><a href="../275947/index.html">Customer support, Amazon backdoor</a></li>
<li><a href="../275949/index.html">Course for beginners. The Basics of IP Telephony on Cisco Packet Tracer</a></li>
<li><a href="../275951/index.html">A few things to remember about the age programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>