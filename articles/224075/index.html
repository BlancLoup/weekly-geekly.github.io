<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell. We test the multithreaded application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article was compiled by Valery Isaev, a lecturer at the Academic University, based on the practice materials for the functional programming cours...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell. We test the multithreaded application</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9d6/357/ad6/9d6357ad6b9892aaf039385af1e8dea7.png" width="400" align="left">  This article was compiled by Valery Isaev, a lecturer at the <a href="http://mit.spbau.ru/">Academic University,</a> based on the practice materials for the functional programming course. <br><br>  I suppose it is not a secret to anyone that writing multi-threaded applications is associated with a number of problems that are missing in the development of single-threaded programs. <br>  One of the problems is testing the application. <br>  We can not control the order in which operations are performed, therefore, it is not amenable to control and the result of the program.  Even if we get an error, stepping on the same rake a second time will not be so easy. <br>  I want to offer a small recipe on how to test a multi-threaded application. <br>  From the ingredients we need: <code>haskell</code> , <code>QuickCheck</code> , some monads, salt / pepper to taste. <br><a name="habracut"></a><br><h4>  Working example </h4><br>  As a working example, take the task of the dining philosophers. <br><br>  <code>MVar a</code> is a link that either contains a value of type a or is empty. <br>  <code>putMVar ref x</code> puts the reference ref value x. <br>  <code>takeMVar ref</code> reads the contents of the link, leaving it empty after that. <br>  If it was already empty, then the stream falls asleep until it records something else in it. <br>  <code>()</code> Is a type having a single value, which is denoted in the same way as the type itself - <code>()</code> . <br>  We model forks with links like <code>MVar ()</code> . <br>  Thus, a fork can have two states: if the fork is occupied by a philosopher, it is empty;  if the plug is free, it contains the value <code>()</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Cont <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.IORef <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Test.QuickCheck <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Test.QuickCheck.Gen <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Test.QuickCheck.Monadic <span class="hljs-comment"><span class="hljs-comment">-- sleep       ( 0  0.3) sleep :: IO () sleep = randomRIO (0, 300000) &gt;&gt;= threadDelay phil :: Int --  . -&gt; MVar () --    . -&gt; MVar () --    . -&gt; IO () phil n leftFork rightFork = forever $ do putStrLn $ show n ++ " is awaiting" sleep takeMVar leftFork putStrLn $ show n ++ " took left fork" -- sleep takeMVar rightFork putStrLn $ show n ++ " took right fork" sleep putMVar leftFork () putMVar rightFork () putStrLn $ show n ++ " put forks" sleep runPhil :: Int -&gt; IO () runPhil n = do --  ,   . forks &lt;- replicateM n $ newMVar () --  5 ,     phil. forM_ [1..n] $ \i -&gt; forkIO $ phil i (forks !! (i - 1)) (forks !! (i `mod` n)) main = do runPhil 5 --    ,  ,     . forever (threadDelay 1000000000)</span></span></code> </pre><br>  In this program can happen deadlock. <br>  To admire it, you can uncomment the line - <code>sleep</code> and wait a bit. <br>  Our goal is to write tests that would detect this error. <br>  But before we can do this, it‚Äôs worth understanding how we will manage the order of operations.  For this, instead of IO, use another monad. <br><br>  <code>runPhil</code> definition of the functions <code>sleep</code> , <code>phil</code> and <code>runPhil</code> , so that they work for other monads. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sleep</span></span> :: <span class="hljs-type"><span class="hljs-type">MonadIO</span></span> m =&gt; m () sleep = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> r &lt;- liftIO $ randomRIO (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) r `times` liftIO (threadDelay <span class="hljs-number"><span class="hljs-number">300</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> times :: <span class="hljs-type"><span class="hljs-type">Monad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; m () -&gt; m () times ra = mapM_ (\_ -&gt; a) [<span class="hljs-number"><span class="hljs-number">1.</span></span>.r]</code> </pre><br>  Now the <code>sleep</code> function can work with any monad that supports IO operations.  In the <code>MonadIO</code> class, only one <code>liftIO</code> function is <code>liftIO</code> that allows this. <br>  Note that instead of once falling asleep for a random number of seconds, we fall asleep a random number of times by 0.3 milliseconds.  The reason is that in our monad, actions inside <code>liftIO</code> are performed atomically.  Accordingly, the time at which we fall asleep does not affect anything, it only matters how many times we do it. <br><br>  Since our monad will work in the same thread, <code>MVar</code> is useless for us, and we will later define our type of links, assuming that the <code>phil</code> function can work with <code>MVar</code> and other types of links. <br>  To do this, we define the monad class <code>MonadConcurrent</code> , in which there will be operations for creating, reading and writing by reference, as well as for creating threads. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span><span class="hljs-class"> m =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MonadConcurrent</span></span></span><span class="hljs-class"> m </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CVar</span></span></span><span class="hljs-class"> m :: * -&gt; * newCVar :: a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CVar</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ma</span></span></span><span class="hljs-class">) takeCVar :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CVar</span></span></span><span class="hljs-class"> ma -&gt; ma putCVar :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CVar</span></span></span><span class="hljs-class"> ma -&gt; a -&gt; m () fork :: m () -&gt; m ()</span></span></code> </pre><br><br>  Here we used families of types that are extensions of the language. <br>  In this case, we need this extension so that we can define different types of links for different monads. <br>  To use an extension, you need to add the following line to the beginning of the file (and at the same time connect extensions that will be needed later): <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TypeFamilies, ExistentialQuantification, GeneralizedNewtypeDeriving #-}</span></span></code> </pre><br>  Define an <code>instance</code> this class for the monad IO. <br>  Everything is easy here: we simply use the appropriate operations for <code>MVar</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MonadConcurrent</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CVar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVar</span></span></span><span class="hljs-class"> newCVar = newMVar takeCVar = takeMVar putCVar = putMVar fork m = forkIO m &gt;&gt; return ()</span></span></code> </pre><br>  <code>runPhil</code> functions <code>phil</code> and <code>runPhil</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">phil</span></span> :: (<span class="hljs-type"><span class="hljs-type">MonadIO</span></span> m, <span class="hljs-type"><span class="hljs-type">MonadConcurrent</span></span> m) =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CVar</span></span> m () -&gt; <span class="hljs-type"><span class="hljs-type">CVar</span></span> m () -&gt; m () phil n leftFork rightFork = forever $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> liftIO $ putStrLn $ show n ++ <span class="hljs-string"><span class="hljs-string">" is awaiting"</span></span> sleep takeCVar leftFork liftIO $ putStrLn $ show n ++ <span class="hljs-string"><span class="hljs-string">" took left fork"</span></span> takeCVar rightFork liftIO $ putStrLn $ show n ++ <span class="hljs-string"><span class="hljs-string">" took right fork"</span></span> sleep putCVar leftFork () putCVar rightFork () liftIO $ putStrLn $ show n ++ <span class="hljs-string"><span class="hljs-string">" put forks"</span></span> sleep runPhil :: (<span class="hljs-type"><span class="hljs-type">MonadIO</span></span> m, <span class="hljs-type"><span class="hljs-type">MonadConcurrent</span></span> m) =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; m () runPhil n = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> forks &lt;- replicateM n $ newCVar () forM_ [<span class="hljs-number"><span class="hljs-number">1.</span></span>.n] $ \i -&gt; fork $ phil i (forks !! (i - <span class="hljs-number"><span class="hljs-number">1</span></span>)) (forks !! (i `mod` n))</code> </pre><br>  Run the program and make sure that it works as before. <br><br><h4>  Monad Concurrent </h4><br>  And now the fun begins. <br><br>  We define the monad in which we will work (looking ahead, I will say that it is called <code>Cont</code> ).  Also I would venture to suggest that <code>Cont</code> is one of the most complex and most powerful monads at the same time. <br>  Using this monad, you can do anything with the control flow: for example, instead of performing actions, you can save them in a structure (for this purpose we will declare an <code>Action</code> type) and perform them later, perhaps in a different order. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Action</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Atom</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Action</span></span></span><span class="hljs-class">) | forall a. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReadRef</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeRef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Action</span></span></span><span class="hljs-class">) | forall a. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WriteRef</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeRef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Action</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fork</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Action</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Action</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span></span></code> </pre><br>  Let's understand separately with each designer. <br>  A <code>Stop</code> action means that the calculation is complete. <br>  The <code>Fork</code> action means that the calculations are branching, that is, now we have two threads that can be executed simultaneously. <br>  The <code>Atom</code> action performs an atomically IO operation, which returns us a new <code>Action</code> , which contains the action, which should be performed in the next step. <br><br>  For example: <br>  The <code>getSum</code> function sets an action that reads two numbers from the keyboard, prints their sum and ends. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">getSum</span></span> :: <span class="hljs-type"><span class="hljs-type">Action</span></span> getSum = <span class="hljs-type"><span class="hljs-type">Atom</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- readLn <span class="hljs-comment"><span class="hljs-comment">--    return $ Atom $ do --   y &lt;- readLn --    return $ Atom $ do --   print (x + y) --   return Stop --  </span></span></code> </pre><br>  Further: <br>  Action <code>WriteRef ref val act</code> writes the value <code>val</code> by reference <code>ref</code> , in <code>act</code> is the continuation. <br>  The <code>ReadRef ref act</code> reads the value by reference <code>ref</code> , <code>act</code> takes this value and returns a continuation. <br>  To make it possible to save arbitrary types of references in <code>Action</code> , we use another extension of the language - existential quantification. <br><br>  The <code>MaybeRef</code> type represents the type of links that we will use instead of <code>MVar</code> , and it is defined as a link to <code>Maybe</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeRef</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeRef</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IORef</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">))</span></span></code> </pre><br>  Now we can define our monad. <br>  As I promised, we just wrap the monad <code>Cont</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cont</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Action</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monad</span></span></span></span></code> </pre><br>  Monad <code>Cont Action</code> organized as follows. <br>  Instead of returning a value of type <code>a</code> , it takes an extension of the type <code>(a -&gt; Action)</code> , passes the value to this function, and returns the result. <br>  That is, we can assume that <code>Cont Action a = (a -&gt; Action) -&gt; Action</code> . <br>  More specifically, we have the following pair of functions that translate <code>(a -&gt; Action) -&gt; Action</code> to <code>Cont Action a</code> and back. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cont</span></span> :: ((a -&gt; <span class="hljs-type"><span class="hljs-type">Action</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Action</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Cont</span></span> <span class="hljs-type"><span class="hljs-type">Action</span></span> a. runCont :: <span class="hljs-type"><span class="hljs-type">Cont</span></span> <span class="hljs-type"><span class="hljs-type">Action</span></span> a -&gt; (a -&gt; <span class="hljs-type"><span class="hljs-type">Action</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Action</span></span></code> </pre><br>  Now we can define instances of the <code>MonadIO</code> and <code>MonadConcurrent</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MonadIO</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> liftIO m = <span class="hljs-type"><span class="hljs-type">Concurrent</span></span> $ cont $ \c -&gt; <span class="hljs-type"><span class="hljs-type">Atom</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- m return (ca)</code> </pre><br>  Let's see what happens here. <br>  <code>liftIO</code> takes an IO operation and wraps it into an atomic action.  Namely: we in <code>cont</code> transfer to a function that accepts continuation (that is, c is of type <code>a -&gt; Action</code> ) and returns an atomic action that performs an IO operation <code>m</code> . <br>  We have defined <code>Atom</code> so that an atomic operation must return an <code>Action</code> that is a continuation. <br>  Actually, this is what we are doing: after we have executed <code>m</code> , we call <code>c</code> , which returns the necessary continuation. <br><br>  Now define the <code>instance MonadConcurrent</code> . <br>  Create a link in <code>newCVar</code> using the <code>liftIO</code> function <code>liftIO</code> just defined. <br>  In <code>takeCVar</code> and <code>putCVar</code> return the corresponding action, and we continue the continuation inside this structure. <br>  In fork, we return an action in which both threads are stored: one is passed to the arguments of the <code>fork</code> function, the other comes from a continuation. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MonadConcurrent</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CVar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeRef</span></span></span><span class="hljs-class"> newCVar a = liftIO $ liftM </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeRef</span></span></span><span class="hljs-class"> $ newIORef (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) takeCVar v = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> $ cont (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReadRef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">) putCVar va = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> $ cont $ \c -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WriteRef</span></span></span><span class="hljs-class"> va $ c () fork (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Concurrent</span></span></span><span class="hljs-class"> $ cont $ \c -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fork</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runCont</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> $ \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stop</span></span></span><span class="hljs-class">) $ c ()</span></span></code> </pre><br>  Our monad is almost ready, it remains only to learn how to run it. <br>  To begin with we will write the function launch <code>Action</code> .  It takes a list of actions, each element in which is a separate thread. <br>  Strategies for launching actions may be different.  We define two points: in what order to execute the threads, and what to do if we try to read the value from a variable that is empty.  Let me remind you that nothing can lie in a variable, and then we need to wait until something else is put into it by another thread. <br>  Let's first write a simple version, where we will execute the threads in turn;  and the stream trying to read from an empty variable will be moved to the end of the queue. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAction</span></span> :: [<span class="hljs-type"><span class="hljs-type">Action</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () <span class="hljs-comment"><span class="hljs-comment">--    , . runAction [] = return () --   ,  ,   ,    . runAction (Atom m : as) = do a' &lt;- m runAction $ as ++ [a'] --       . runAction (Fork a1 a2 : as) = runAction $ as ++ [a1,a2] --    . runAction (Stop : as) = runAction as runAction (ReadRef (MaybeRef ref) c : as) = do --   . ma &lt;- readIORef ref case ma of --    -,  Just a -&gt; do --   . writeIORef ref Nothing --     . runAction (as ++ [ca]) --     ,       ,         . Nothing -&gt; runAction (as ++ [ReadRef (MaybeRef ref) c]) --    ,     . runAction (WriteRef (MaybeRef ref) val a : as) = do writeIORef ref (Just val) runAction (as ++ [a])</span></span></code> </pre><br>  Notice that <code>putMVar</code> works slightly differently than our implementation of <code>WriteRef</code> . <br>  If the link already had some value, then <code>putMVar</code> freeze the stream until the variable is released.  In this case, overwrite the value. <br>  You should not create a version working as <code>putMVar</code> in this situation, so as not to over-complicate the code. <br><br>  Next, write the function that starts the <code>Concurrent</code> , and override the <code>main</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runConcurrent</span></span> :: <span class="hljs-type"><span class="hljs-type">Concurrent</span></span> () -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () runConcurrent (<span class="hljs-type"><span class="hljs-type">Concurrent</span></span> c) = runAction [runCont c $ \_ -&gt; <span class="hljs-type"><span class="hljs-type">Stop</span></span>] main = runConcurrent (runPhil <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre><br>  Since we are now working in one thread, and <code>threadDelay</code> stops all work, the speed has slowed down a bit. <br><br><h4>  We write tests </h4><br>  It is time to ‚Äúadd seasoning to the dish‚Äù - write tests for our example. <br>  To do this, use the <code>QuickCheck</code> library, which generates random input data for tests.  Since we want to run our threads in different orders, the input to our tests is the order in which we select the next thread from the list. <br>  It is possible to encode the input data with a list of numbers, but the problem is that we do not know in advance which range these numbers should be chosen for, since the number of streams can vary. <br>  Therefore, we will encode the input data as a list of functions of the type <code>Int -&gt; Int</code> , which take the number <code>n</code> and return a number from the interval <code>[0,n-1]</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Route</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Route</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">]</span></span></code> </pre><br>  The <code>Arbitrary</code> class provided by the <code>QuickCheck</code> library is designed to describe types that allow you to generate elements at random. <br>  In this class, two functions are declared - <code>shrink</code> and <code>arbitrary</code> . <br>  <code>shrink</code> has a default implementation, so we will not override it. <br>  In the <code>arbitrary</code> function, we will generate a list of random functions, where each function returns a number from the interval <code>[0,n-1]</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Arbitrary</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Route</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> arbitrary = fmap <span class="hljs-type"><span class="hljs-type">Route</span></span> (listOf arbitraryFun) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> arbitraryFun = <span class="hljs-type"><span class="hljs-type">MkGen</span></span> $ \qsn -&gt; unGen (choose (<span class="hljs-number"><span class="hljs-number">0</span></span>, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)) qs</code> </pre><br>  We also define an <code>instance Show</code> for <code>Route</code> , as this is required by <code>QuickCheck</code> . <br>  Unfortunately, we cannot write a too useful <code>show</code> .  Moreover, this function will not be used, so we leave it undefined. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Route</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> show = undefined</code> </pre><br>  Now you can start writing a smarter version of <code>runAction</code> . <br>  The first difference is that we will separate the execution of atomic actions and work with links. <br>  To begin <code>skipAtoms</code> , <code>skipAtoms</code> write an auxiliary function, <code>skipAtoms</code> , which performs atomic actions: the function accepts the list of actions, executes <code>Atom</code> , <code>Fork</code> and <code>Stop</code> , the rest returns as a result. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipAtoms</span></span> :: [<span class="hljs-type"><span class="hljs-type">Action</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> [<span class="hljs-type"><span class="hljs-type">Action</span></span>] skipAtoms [] = return [] skipAtoms (<span class="hljs-type"><span class="hljs-type">Atom</span></span> m : <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- m skipAtoms (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ++ [a]) skipAtoms (<span class="hljs-type"><span class="hljs-type">Fork</span></span> a1 a2 : <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = skipAtoms (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ++ [a1,a2]) skipAtoms (<span class="hljs-type"><span class="hljs-type">Stop</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = skipAtoms <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> skipAtoms (a : <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = fmap (a:) (skipAtoms <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>)</code> </pre><br>  The second difference of the new version of <code>runAction</code> from the previous one is that we track the receipt of deadlock. <br>  To do this, we have two lists of actions.  The first one stores active (executed by us) threads.  In the second, there are threads waiting for any link to be updated. <br>  If the list of active threads is empty, but there is no waiting list, then we have received deadlock, and in this case we throw an exception. <br><br>  The third innovation is the <code>Route</code> type argument used to select the stream number to be executed in the current step. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAction</span></span> :: <span class="hljs-type"><span class="hljs-type">Route</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Action</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Action</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () runAction _ [] [] = return () runAction _ [] _ = fail <span class="hljs-string"><span class="hljs-string">"Deadlock"</span></span> runAction (<span class="hljs-type"><span class="hljs-type">Route</span></span> []) _ _ = return () runAction (<span class="hljs-type"><span class="hljs-type">Route</span></span> (r:rs)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bs = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &lt;- skipAtoms <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = length <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> splitAt (rn) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> (as1, <span class="hljs-type"><span class="hljs-type">ReadRef</span></span> (<span class="hljs-type"><span class="hljs-type">MaybeRef</span></span> ref) c : as2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ma &lt;- readIORef ref <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ma <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> a -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> writeIORef ref <span class="hljs-type"><span class="hljs-type">Nothing</span></span> runAction (<span class="hljs-type"><span class="hljs-type">Route</span></span> rs) (as1 ++ [ca] ++ as2) bs <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; runAction (<span class="hljs-type"><span class="hljs-type">Route</span></span> rs) (as1 ++ as2) (bs ++ [<span class="hljs-type"><span class="hljs-type">ReadRef</span></span> (<span class="hljs-type"><span class="hljs-type">MaybeRef</span></span> ref) c]) (as1, <span class="hljs-type"><span class="hljs-type">WriteRef</span></span> (<span class="hljs-type"><span class="hljs-type">MaybeRef</span></span> ref) xc : as2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> writeIORef ref (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) runAction (<span class="hljs-type"><span class="hljs-type">Route</span></span> rs) (as1 ++ [c] ++ as2 ++ bs) []</code> </pre><br>  The <code>runConcurrent</code> function <code>runConcurrent</code> hardly changed. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runConcurrent</span></span> :: <span class="hljs-type"><span class="hljs-type">Route</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Concurrent</span></span> () -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () runConcurrent r (<span class="hljs-type"><span class="hljs-type">Concurrent</span></span> c) = runAction r [runCont c $ \_ -&gt; <span class="hljs-type"><span class="hljs-type">Stop</span></span>] []</code> </pre><br>  You can check how the new version works by passing <code>round_robin</code> as the first argument.  This is a simple execution strategy, similar to how the <code>runAction</code> function worked before.  Here we simply generate an infinite list and for each element we take the remainder modulo the number of threads. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">round_robin</span></span> :: <span class="hljs-type"><span class="hljs-type">Route</span></span> round_robin = <span class="hljs-type"><span class="hljs-type">Route</span></span> $ map rem [<span class="hljs-number"><span class="hljs-number">0.</span></span>.]</code> </pre><br>  By running the calculations on these inputs, we will most likely quickly get deadlock - due to the fact that the work of our example is based on a random number generator - therefore, despite the fact that the input data are always the same, the execution order is random. <br>  If our example were more deterministic, we would have to vary the input data randomly, which we now do. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = quickCheck $ monadicIO $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> r &lt;- pick arbitrary run $ runConcurrent r (runPhil <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre><br>  We choose an arbitrary element of the <code>Route</code> type using the <code>arbitrary</code> function that we implemented earlier.  Then we run our calculation on this input. <br>  <code>QuickCheck</code> will take care of the <code>QuickCheck</code> , namely: run our test 100 times, each time increasing the size of the input data. <br><br>  Running the program, we will see the following: <br><br><pre> <code class="hljs swift">... <span class="hljs-number"><span class="hljs-number">3</span></span> took <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> fork <span class="hljs-number"><span class="hljs-number">4</span></span> put forks <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> awaiting <span class="hljs-number"><span class="hljs-number">5</span></span> took <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> fork <span class="hljs-number"><span class="hljs-number">4</span></span> took <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> fork <span class="hljs-number"><span class="hljs-number">1</span></span> took <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> fork <span class="hljs-number"><span class="hljs-number">1</span></span> put forks <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> awaiting <span class="hljs-number"><span class="hljs-number">1</span></span> took <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> fork <span class="hljs-number"><span class="hljs-number">2</span></span> took <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> fork *** <span class="hljs-type"><span class="hljs-type">Failed!</span></span> <span class="hljs-type"><span class="hljs-type">Exception</span></span>: 'user error (<span class="hljs-type"><span class="hljs-type">Deadlock</span></span>)' (after <span class="hljs-number"><span class="hljs-number">36</span></span> tests):</code> </pre><br>  What was required to get! <br><br><h4>  Conclusion </h4><br>  We have learned how to write tests that can detect the state of the deadlock in a multi-threaded application. <br>  In the process, we have seen examples of using the <code>Cont</code> monad, type families, existential quantification, and the <code>QuickCheck</code> library. <br>  In addition, we learned how to build a model of multi-threaded program execution from scrap materials. </div><p>Source: <a href="https://habr.com/ru/post/224075/">https://habr.com/ru/post/224075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224065/index.html">Python-digest # 28. News, interesting projects, articles and interviews [May 19, 2014 - May 25, 2014]</a></li>
<li><a href="../224067/index.html">Profishop - solution for receiving orders from wholesale customers</a></li>
<li><a href="../224069/index.html">Splitting algorithms and van der Waerden numbers</a></li>
<li><a href="../224071/index.html">Popularizing 3D printing in an adult way ... in schools</a></li>
<li><a href="../224073/index.html">Node.js: Overview of General Library Development Technologies</a></li>
<li><a href="../224077/index.html">Testing through abstract classes in TestNG</a></li>
<li><a href="../224079/index.html">Amazon hides books from Hachette</a></li>
<li><a href="../224081/index.html">How to write parsers on javascript</a></li>
<li><a href="../224083/index.html">Lenovo ThinkServer RD540 Server New Corporate Standard</a></li>
<li><a href="../224089/index.html">DevConf 2014: Piracy and other threats for Android applications. How to defend?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>