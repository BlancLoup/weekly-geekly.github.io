<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The seven deadly sins of a T-SQL programmer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is not enough to write code well readable: it must also be quickly executed. 

 There are three basic rules for writing such T-SQL code that will w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The seven deadly sins of a T-SQL programmer</h1><div class="post__text post__text-html js-mediator-article">  It is not enough to write code well readable: it must also be quickly executed. <br><br>  There are three basic rules for writing such T-SQL code that will work well.  They are cumulative - the implementation of all these rules will have a positive impact on the code.  Skipping or changing any of them will most likely lead to a negative impact on the performance of your code. <br><br><ul><li>  Write on the basis of the data storage structure: if you are storing datetime data, use datetime, not varchar or anything else. </li><li>  Write based on the presence of indices: if there are indexes on the table, and they should be there, write the code so that it can use all the advantages provided by these indices.  Make sure that the clustered index, and for each table it can be only one, is used in the most efficient way. </li><li>  Write to help the query optimizer: the query optimizer is a delightful part of the DBMS.  Unfortunately, you can make it very difficult for him to write a request that will be ‚Äúhard‚Äù for him to parse, for example, containing nested views ‚Äî when one view receives data from another, and then from the third ‚Äî and so on.  Spend your time to understand how the optimizer works and write queries so that it can help you, and not harm. </li></ul><br>  There are some common mistakes that people make in their T-SQL code ‚Äî do not commit them. <br><a name="habracut"></a><br><h4>  Using wrong data types </h4><br>  In theory, to avoid this error is very simple, but in practice it is quite common.  For example, you use some type of data in your database.  Use it in your own parameters and variables!  Yes, I know that SQL Server can implicitly convert one data type to another.  But, when an implicit type conversion occurs, or you yourself cast the data type of a column to a different type, you perform the conversion for the entire column.  When you do this conversion for a column in a WHERE clause or in a join condition, you will always see a table scan.  An excellent index can be built on this column, but since you make a CAST for the values ‚Äã‚Äãstored in this column to compare, for example, the date stored in this column, with the type of char you used in the condition, the index will not be used. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Do not believe?  Let's look at this query: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> e.BusinessEntityID, e.NationalIDNumber <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> HumanResources.Employee <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> e.NationalIDNumber = <span class="hljs-number"><span class="hljs-number">112457891</span></span>;</code> </pre> <br>  Well written and very simple.  It should be covered by the index created on this table.  But here is the execution plan: <br><br><img src="https://habrastorage.org/storage2/300/4c2/8a2/3004c28a2986a97500ab71c2917e7605.png"><br><br>  This query is executed fairly quickly and the table is small, so only four reads are required to scan the index.  Notice the small exclamation point on the SELECT statement.  If we refer to its properties, we will see: <br><br><img src="https://habrastorage.org/storage2/95c/7d4/a2e/95c7d4a2e9af96f14ceefc19285ec029.png"><br><br>  Right.  This is a warning (new in SQL Server 2012) that type conversion occurs that affects the execution plan.  In short, this is because the query uses the wrong data type: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> e.BusinessEntityID, e.NationalIDNumber <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> HumanResources.Employee <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> e.NationalIDNumber = <span class="hljs-string"><span class="hljs-string">'112457891'</span></span>;</code> </pre><br>  And we get the following query execution plan: <br><br><img src="https://habrastorage.org/storage2/10b/e15/d5e/10be15d5ee63956b8ee4d04ea17ec54d.png"><br><br>  And here only two read operations are used, instead of four.  And yes, I understand that I made a query that was running so fast a little bit faster.  But what would happen if millions of rows were stored in the table?  Yeah, then I would be a hero. <br><br>  Use the correct data types. <br><br><h4>  Using Functions in Compounding Conditions and in WHERE Clauses </h4><br>  Speaking of functions, most of the functions used in join conditions or WHERE clauses, to which you, as an argument, pass a column, interfere with the proper use of indexes.  You will see how much slower queries are executed, in which functions are used that take columns as arguments.  For example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> a.AddressLine1, a.AddressLine2, a.City, a.StateProvinceID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person.Address <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-string"><span class="hljs-string">'4444'</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span>(a.AddressLine1, <span class="hljs-number"><span class="hljs-number">4</span></span>) ;</code> </pre><br>  This function, LEFT, takes a column as an argument, which translates into this execution plan: <br><br><img src="https://habrastorage.org/storage2/930/982/b7e/930982b7e0c5914cc0f39585535c0bbc.png"><br><br>  As a result, 316 read operations are performed to find the necessary data, and it takes 9 milliseconds (I have very fast disks).  All because '4444' should match every line returned by this function.  SQL Server cannot even simply scan the table, it needs to perform a LEFT for each row.  However, you can do something like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> a.AddressLine1, a.AddressLine2, a.City, a.StateProvinceID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person.Address <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.AddressLine1 <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'4444%'</span></span> ;</code> </pre><br>  And here we see a completely different implementation plan: <br><br><img src="https://habrastorage.org/storage2/251/566/8f6/2515668f6c61ba2c320b4f2b5429ccba.png"><br><br>  To perform the request requires 3 reads and 0 milliseconds.  Well, or let it be 1 millisecond, for objectivity.  This is a huge performance boost.  And all because I used such a function that can be used to search by index (previously it was called sargeable - the word <i>untranslatable, in general, the word: SARG - Search Arguments ‚Äìable if the SARGeable function - you can pass a column into it argument and it will still be used Index Seek, if not SARGeable - alas, Index Scan will always be used - translator‚Äôs comment</i> ).  In any case, do not use functions in WHERE expressions or search conditions, or use only those that can be used in search conditions by index. <br><br><h4>  Using Multi-statement UDF </h4><br>  <i>The multi-statement UDF in the Russian edition of msdn translates roughly as ‚ÄúUser-defined functions consisting of several instructions, but this sounds, in my opinion, somehow strange, so I tried to avoid translating this term further into the heading - text .</i>  <i>translator</i> <br><br>  In fact, they are driving you into a trap.  At first glance, this wonderful mechanism allows us to use T-SQL as a real programming language.  You can create these functions and call them one from another and the code can be reused, not like these old stored procedures.  This is amazing.  Until you try to run this code on a large amount of data. <br><br>  The problem with these functions is that they are built on table variables.  Table variables are a very cool thing if you use them for their intended purpose.  They have one obvious difference from temporary tables - no statistics are built on them.  This difference can be very useful, and maybe ... kill you.  If you do not have statistics, the optimizer assumes that any query running on a table variable or UDF will return just one row.  One (1) line.  This is good if they do return multiple rows.  But one day they will return hundreds or thousands of lines and you decide to connect one UDF to another ... Productivity will fall very, very quickly and very, very much. <br><br>  An example is quite large.  Here are a few UDFs: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> dbo.SalesInfo () <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> @return_variable <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ( SalesOrderID <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, OrderDate DATETIME, SalesPersonID <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, PurchaseOrderNumber dbo.OrderNumber, AccountNumber dbo.AccountNumber, ShippingCity <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> @return_variable (SalesOrderID, OrderDate, SalesPersonID, PurchaseOrderNumber, AccountNumber, ShippingCity ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> soh.SalesOrderID, soh.OrderDate, soh.SalesPersonID, soh.PurchaseOrderNumber, soh.AccountNumber, a.City <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Sales.SalesOrderHeader <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> soh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Person.Address <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> soh.ShipToAddressID = a.AddressID ; RETURN ; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ; GO <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> dbo.SalesDetails () <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> @return_variable <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ( SalesOrderID <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, SalesOrderDetailID <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, OrderQty <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>, UnitPrice MONEY ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> @return_variable (SalesOrderID, SalesOrderDetailId, OrderQty, UnitPrice ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sod.SalesOrderID, sod.SalesOrderDetailID, sod.OrderQty, sod.UnitPrice <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Sales.SalesOrderDetail <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sod ; RETURN ; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ; GO <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> dbo.CombinedSalesInfo () <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> @return_variable <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ( SalesPersonID <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, ShippingCity <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), OrderDate DATETIME, PurchaseOrderNumber dbo.OrderNumber, AccountNumber dbo.AccountNumber, OrderQty <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>, UnitPrice MONEY ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> @return_variable (SalesPersonId, ShippingCity, OrderDate, PurchaseOrderNumber, AccountNumber, OrderQty, UnitPrice ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> si.SalesPersonID, si.ShippingCity, si.OrderDate, si.PurchaseOrderNumber, si.AccountNumber, sd.OrderQty, sd.UnitPrice <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.SalesInfo() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> si <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dbo.SalesDetails() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sd <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> si.SalesOrderID = sd.SalesOrderID ; RETURN ; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ; GO</code> </pre><br>  Excellent structure.  It allows you to make very simple requests.  Well, for example, here: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> csi.OrderDate, csi.PurchaseOrderNumber, csi.AccountNumber, csi.OrderQty, csi.UnitPrice <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.CombinedSalesInfo() <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> csi <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> csi.SalesPersonID = <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> csi.ShippingCity = <span class="hljs-string"><span class="hljs-string">'Odessa'</span></span> ;</code> </pre><br>  One very simple request.  Here is his execution plan, also very simple: <br><br><img src="https://habrastorage.org/storage2/a07/0fd/f3a/a070fdf3a5979a99f3e54c065a3ada7a.png"><br><br>  Here it is only executed 2.17 seconds, returns 148 lines and uses 1456 read operations.  Please note that our function has a zero cost and only scanning a table, a table variable, affects the cost of the query.  Hmm, is that right?  Let's try to see what lies behind the zero-cost UDF execution operator.  This query will get the execution plan for the function from the cache: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> deqp.query_plan, dest.text, <span class="hljs-keyword"><span class="hljs-keyword">SUBSTRING</span></span>(dest.text, (deqs.statement_start_offset / <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>, (deqs.statement_end_offset - deqs.statement_start_offset) / <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> actualstatement <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_exec_query_stats <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> deqs <span class="hljs-keyword"><span class="hljs-keyword">CROSS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">APPLY</span></span> sys.dm_exec_query_plan(deqs.plan_handle) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> deqp <span class="hljs-keyword"><span class="hljs-keyword">CROSS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">APPLY</span></span> sys.dm_exec_sql_text(deqs.sql_handle) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> dest <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> deqp.objectid = OBJECT_ID(<span class="hljs-string"><span class="hljs-string">'dbo.CombinedSalesInfo'</span></span>);</code> </pre><br>  And that's what's really going on there: <br><br><img src="https://habrastorage.org/storage2/6a6/e78/0ed/6a6e780ed0aa9f8b33b6e4f275b4dc21.png"><br><br>  Wow, it looks like there are a few more of these small functions and scans of tables that almost, but still not quite, cost nothing.  Plus, the Hash Match connection operator, which writes to tempdb and is quite expensive when executed.  Let's see another UDF execution plan: <br><br><img src="https://habrastorage.org/storage2/682/642/1bd/6826421bd386cefb005d70ac02c1e999.png"><br><br>  Here!  And now we see a Clustered Index Scan, which scans a large number of rows.  This is not great.  In general, in this whole situation, UDFs seem less and less attractive.  What if we, well, I don‚Äôt directly know, just try to directly access the tables.  So, for example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> soh.OrderDate, soh.PurchaseOrderNumber, soh.AccountNumber, sod.OrderQty, sod.UnitPrice <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Sales.SalesOrderHeader <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> soh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Sales.SalesOrderDetail <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sod <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> soh.SalesOrderID = sod.SalesOrderID <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Person.Address <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ba <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> soh.BillToAddressID = ba.AddressID <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Person.Address <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sa <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> soh.ShipToAddressID = sa.AddressID <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> soh.SalesPersonID = <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> sa.City = <span class="hljs-string"><span class="hljs-string">'Odessa'</span></span> ;</code> </pre><br>  Now, by running this query, we get exactly the same data, but in just 310 milliseconds, not 2170. Plus, SQL Server will perform only 911 read operations, not 1456. To be honest, it‚Äôs very easy to get performance problems using UDF <br><br><h4>  Turning on the ‚ÄúWork faster!‚Äù Setting: using ‚ÄúDirty reads‚Äù </h4><br>  Returning to the past, to old computers with 286 processors on board, we can recall that for a number of reasons, they had a Turbo button on the front panel.  If you accidentally "squeezed" it, then the computer immediately began to slow down insanely.  Thus, you realized that some things should always be included to ensure maximum throughput.  In the same way, many people look at the READ_UNCOMMITTED isolation level and the NO_LOCK hint as a turbo button for SQL Server.  When using them, be sure that virtually any request and the entire system will become faster.  This is due to the fact that during the reading no locks will be imposed and checked.  Less locks - faster result.  But‚Ä¶ <br><br>  When you use READ_UNCOMMITTED or NO_LOCK in your queries, you encounter dirty reads.  Everyone understands that this means that you can read the "dog" and not the "cat" if at this moment the update operation is completed but not yet completed.  But, besides this, you can get more or less rows than you actually have, as well as duplicate rows, since data pages can be moved during the execution of your query, and you do not impose any locks to avoid this.  I do not know about you, but in most of the companies in which I worked, we expected that the majority of requests on most systems would return complete data.  The same query with the same parameters, performed on the same data set, should give the same result.  Only not if you use NO_LOCK.  In order to verify this, I advise you to read <a href="http://www.jasonstrate.com/2012/06/the-side-effect-of-nolock/">this post</a> . <br><br><h4>  Unreasonable use of hints in queries </h4><br>  People too quickly decide to use hints.  The most common situation is when hint helps to solve one very rare problem on one of the queries.  But when people see significant performance gains on this request ... they immediately start poking it generally everywhere. <br><br>  For example, a lot of people think that a LOOP JOIN is the best way to join tables.  They come to this conclusion because it is most often found in small and fast queries.  Therefore, they decide to force SQL Server to use LOOP JOIN.  It is not difficult at all: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s.[<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> StoreName, p.LastName + <span class="hljs-string"><span class="hljs-string">', '</span></span> + p.FirstName <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Sales.Store <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sales.SalesPerson <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> s.SalesPersonID = sp.BusinessEntityID <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> HumanResources.Employee <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> sp.BusinessEntityID = e.BusinessEntityID <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Person.Person <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> e.BusinessEntityID = p.BusinessEntityID <span class="hljs-keyword"><span class="hljs-keyword">OPTION</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span>);</code> </pre><br>  This request takes 101 milliseconds and performs 4115 read operations.  Not bad in general, but if we remove this hint, the same query will execute in 90 milliseconds and produce only 2370 readings.  The more loaded the system is, the more obvious will be the effectiveness of the query without using hint. <br><br>  Here is another example.  People often create an index on a table, expecting it to solve the problem.  So, we have a request: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Purchasing.PurchaseOrderHeader <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> poh <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> poh.PurchaseOrderID * <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">3400</span></span>;</code> </pre><br>  The problem again is that when you perform a column transformation, no index will be adequately used.  Performance drops as a clustered index scan is performed.  And so, when people see that their index is not used, they do this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Purchasing.PurchaseOrderHeader <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> poh <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> (PK_PurchaseOrderHeader_PurchaseOrderID)) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> poh.PurchaseOrderID * <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">3400</span></span>;</code> </pre><br>  And now they get a scan of their chosen index, not a clustered index, so the index is ‚Äúused‚Äù, right?  But the query performance changes - now, instead of 11 read operations, 44 are executed (the execution time for both is about 0 milliseconds, since I have really fast disks).  ‚ÄúUsed‚Äù is used, but not at all as intended.  The solution to this problem is to rewrite the query in this way: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Purchasing.PurchaseOrderHeader poh <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> PurchaseOrderID = <span class="hljs-number"><span class="hljs-number">3400</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Now the number of read operations has fallen to two, since an index search is used - the index is used correctly. <br><br>  Hints in requests should always be applied last, after all other possible options have been tested and have not given a positive result. <br><br><h4>  Using line-by-line processing of the query result ('Row by Agonizing Row' processing) </h4><br>  Line by line processing is performed using cursors or operations in the WHILE loop, instead of operations on sets.  When using them, the performance is very, very low.  Cursors are usually used for two reasons.  The first is the developers who are used to using line-by-line processing in their code, and the second is the developers who came from Oracle, who think that cursors are a good thing.  Whatever the reason, cursors - kill the performance on the vine. <br><br>  Here is a typical example of unsuccessful use of the cursor.  We need to update the color of products selected by a specific criterion.  It is not invented - it is based on a code that I once had to optimize. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>) , @Color <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>) , @Weight <span class="hljs-built_in"><span class="hljs-built_in">DECIMAL</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> BigUpdate <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.[<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>] ,p.Color ,p.[Weight] <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Production.Product <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p ; OPEN BigUpdate ; FETCH NEXT FROM BigUpdate INTO @Name, @Color, @Weight ; WHILE @@FETCH_STATUS = 0 <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @Weight &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> Production.Product <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Color = <span class="hljs-string"><span class="hljs-string">'Blue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> BigUpdate <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NEXT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> BigUpdate <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>, @Color, @Weight ; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLOSE</span></span> BigUpdate ; <span class="hljs-keyword"><span class="hljs-keyword">DEALLOCATE</span></span> BigUpdate ; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Production.Product <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Color = <span class="hljs-string"><span class="hljs-string">'Blue'</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span></code> </pre><br>  In each iteration, we perform two read operations, and the number of products that meet our criteria is in the hundreds.  On my machine, without load, the execution time is more than a second.  This is completely unacceptable, especially since rewriting this query is very simple: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> Production.Product <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Color = <span class="hljs-string"><span class="hljs-string">'BLUE'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> [Weight] &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span></code> </pre><br>  Now, only 15 read operations are performed and the execution time is only 1 millisecond.  Do not laugh.  People often write such code and even worse.  Cursors are such a thing that should be avoided and used only where you cannot do without them - for example, in maintenance tasks where you need to run through different tables or databases. <br><br><h4>  Unreasonable use of nested views </h4><br>  Views that refer to views, connect to views, link to other views, connect to views ... A view is just a query.  But since they can be treated as tables, people can start thinking of them as tables.  And in vain.  What happens when you connect one view to another, referring to a third view, and so on?  You just create a damn complicated query execution plan.  The optimizer will try to simplify it.  He will try plans that do not use all the tables, but the time to work on the choice of the plan is limited and the more complex the plan he gets, the less likely he is to have a fairly simple execution plan.  And performance problems will be almost inevitable. <br><br>  Here, for example, is a sequence of simple queries defining views: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> dbo.SalesInfoView <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> soh.SalesOrderID, soh.OrderDate, soh.SalesPersonID, soh.PurchaseOrderNumber, soh.AccountNumber, a.City <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ShippingCity <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Sales.SalesOrderHeader <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> soh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Person.Address <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> soh.ShipToAddressID = a.AddressID ; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> dbo.SalesDetailsView <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sod.SalesOrderID, sod.SalesOrderDetailID, sod.OrderQty, sod.UnitPrice <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Sales.SalesOrderDetail <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sod ; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> dbo.CombinedSalesInfoView <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> si.SalesPersonID, si.ShippingCity, si.OrderDate, si.PurchaseOrderNumber, si.AccountNumber, sd.OrderQty, sd.UnitPrice <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.SalesInfoView <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> si <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dbo.SalesDetailsView <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sd <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> si.SalesOrderID = sd.SalesOrderID ;</code> </pre><br>  <i>And here the author of the text forgot to specify the request, but he quotes it in the comments (approx. Translator):</i> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> csi.OrderDate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo. CominedSalesInfoView csi <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> csi.SalesPersonID = <span class="hljs-number"><span class="hljs-number">277</span></span></code> </pre><br>  As a result, our request executes 155 milliseconds and uses 965 read operations.  Here is his execution plan: <br><br><img src="http://habrastorage.org/storage2/1d2/e31/df2/1d2e31df2e98412675e36bbdc9851fe2.png"><br><br>  It looks good, especially since we get 7,000 lines, so everything seems to be in order.  But what if we try to execute the following query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> soh.OrderDate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Sales.SalesOrderHeader <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> soh <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> soh.SalesPersonID = <span class="hljs-number"><span class="hljs-number">277</span></span> ;</code> </pre><br>  And now the request is executed in 3 milliseconds and uses 685 read operations - quite different.  And here is his execution plan: <br><br><img src="http://habrastorage.org/storage2/9ad/2b4/279/9ad2b4279272f639cc7fa892c69cec12.png"><br><br>  As you can see, the optimizer cannot throw out all unnecessary tables as part of the query simplification process.  Therefore, in the first execution plan there are two unnecessary operations - Index Scan and Hash Match, which collects data together.  You could save SQL Server from unnecessary work by writing this query without using views.  And remember - this example is very simple, most requests in real life are much more complicated and lead to much bigger performance problems. <br><br>  <i>In the comments to this article there is a small dispute, the essence of which is that Grant (the author of the article) did seem to fulfill his requests not on the standard AdventureWorks database, but on a similar database, but with a slightly different structure, which is why the execution plan is ‚Äúnot optimal‚Äù ‚ÄúThe query in the last section is different from what you can see by conducting the experiment yourself.</i>  <i>Note</i>  <i>translator.</i> <br>  <i>If somewhere I was too stupid (and I can) and the text is difficult to understand, or you can offer me the best wording for anything, I‚Äôll be happy to hear all the comments.</i> </div><p>Source: <a href="https://habr.com/ru/post/149235/">https://habr.com/ru/post/149235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149228/index.html">Scalaxy saves you money</a></li>
<li><a href="../149229/index.html">483,000 kilometers without a single accident</a></li>
<li><a href="../149230/index.html">The Bricks - UI framework</a></li>
<li><a href="../149232/index.html">ASUS Zenbook Prime UX31A - review of the second attempt to create the perfect ultrabook</a></li>
<li><a href="../149234/index.html">Apple has published Open Source components Mac OS X 10.8</a></li>
<li><a href="../149237/index.html">Javascript and jQuery bikes</a></li>
<li><a href="../149238/index.html">PostgreSQL vs Oracle</a></li>
<li><a href="../149239/index.html">Automatic code check for PHP</a></li>
<li><a href="../149241/index.html">1C server 8.2 + MsSql 2008 + BackUp</a></li>
<li><a href="../149242/index.html">Google Play tightens requirements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>