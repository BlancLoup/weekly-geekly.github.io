<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lambda: from C ++ 11 to C ++ 20. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, habrovchane. In connection with the start of recruitment to a new group in the course ‚ÄúDeveloper C ++‚Äù , we are sharing with you the translation o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lambda: from C ++ 11 to C ++ 20. Part 2</h1><div class="post__text post__text-html js-mediator-article">  Hi, habrovchane.  In connection with the start of recruitment to a new group in the course <a href="https://otus.pw/EiLZ/">‚ÄúDeveloper C ++‚Äù</a> , we are sharing with you the translation of the second part of the article ‚ÄúLambdas: from C ++ 11 to C ++ 20‚Äù.  The first part can be read <a href="https://habr.com/ru/company/otus/blog/444524/">here</a> . <br><br><img src="https://habrastorage.org/webt/1v/wn/ec/1vwnecq2qaxmin6vtdxqcuv77ja.png"><br><br>  In the <a href="https://habr.com/ru/company/otus/blog/444524/">first part of the series</a> we looked at lambda from the point of view of C ++ 03, C ++ 11 and C ++ 14.  In this article, I described the motivations behind this powerful C ++ feature, basic usage, syntax and improvements in each of the locales.  I also mentioned several borderline cases. <br>  Now it's time to switch to C ++ 17 and look a bit into the future (very close!): C ++ 20. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Introduction</b> <br><br>  A small reminder: the idea of ‚Äã‚Äãthis series came after one of our recent C ++ User Group meetings in Krakow. <br><br>  We had a live programming session about the ‚Äúhistory‚Äù of lambda expressions.  The conversation was conducted by a C ++ expert, Thomas Kaminsky ( <a href="https://www.linkedin.com/in/tomasz-kami%25C5%2584ski-208572b1/">see Thomas's LinkedIn profile</a> ).  Here is the event: <br>  <a href="https://www.meetup.com/pl-PL/C-User-Group-Cracow/events/258795519/">Lambdas: From C ++ 11 to C ++ 20 - C ++ User Group Krakow</a> . <br><br>  I decided to take the code from Thomas (with his permission!) And write articles based on it. In the first part of the series I told the following about lambda expressions: <br><br><ul><li>  Basic syntax </li><li>  Lambda type </li><li>  Call operator </li><li>  Capture variables (mutable, global, static variables, class members and this pointer, move-able-only objects, save constants): <br><br><ul><li>  Return type </li><li>  IIFE - Immediately Invoked Function Expression </li><li>  Conversion to a function pointer </li><li>  Return type </li><li>  IIFE - Immediately Called Expressions </li><li>  Conversion to function pointer </li></ul></li><li>  Improvements in C ++ 14 <br><br><ul><li>  Return Type Output </li><li>  Capture with initializer </li><li>  Member variable capture </li><li>  Generalized lambda expressions </li></ul></li></ul><br>  The above list is only part of the history of lambda expressions! <br><br>  Now let's see what has changed in C ++ 17 and what we get in C ++ 20! <br><br>  <b>Improvements in C ++ 17</b> <br><br>  Standard (draft before publication) <a href="https://timsong-cpp.github.io/cppwp/n4659/">N659</a> section on lambda: <a href="https://timsong-cpp.github.io/cppwp/n4659/expr.prim.lambda">[expr.prim.lambda]</a> .  C ++ 17 introduced two significant improvements to lambda expressions: <br><br><ul><li>  constexpr lambda </li><li>  Capture * this </li></ul><br>  What do these innovations mean to us?  Let's see. <br><br>  <i><b>constexpr lambda expressions</b></i> <br><br>  Starting with C ++ 17, the standard implicitly defines <code>operator()</code> for a lambda type as <code>constexpr</code> , if possible: <br><blockquote>  From <a href="https://timsong-cpp.github.io/cppwp/n4659/expr.prim.lambda">expr.prim.lambda # 4</a> : <br>  The function call operator is a function of constexpr if the declaration of the condition parameter of the corresponding lambda expression is followed by constexpr, or it satisfies the requirements for the function constexpr. </blockquote><br>  For example: <br><br><pre> <code class="bash hljs">constexpr auto Square = [] (int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n*n; }; // implicitly constexpr static_assert(Square(2) == 4);</code> </pre> <br>  Recall that in C ++ 17 a <code>constexpr</code> function must follow these rules: <br><br><ul><li>  it should not be virtual (virtual); <br><br><ul><li>  its return type must be a literal type; </li><li>  each of its parameter types must be a literal type; </li><li>  her body must be = delete, = default, or a compound statement that does not contain <br><ul><li>  asm-definitions </li><li>  goto expressions </li><li>  tags, </li><li>  try block or </li><li>  definition of a variable of non-literal type, static variable or variable of stream memory for which initialization is not performed. </li></ul></li></ul></li></ul><br>  How about a more practical example? <br><br><pre> <code class="bash hljs">template&lt;typename Range, typename Func, typename T&gt; constexpr T SimpleAccumulate(const Range&amp; range, Func func, T init) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp;&amp;elem: range) { init += func(elem); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> init; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr std::array arr{ 1, 2, 3 }; static_assert(SimpleAccumulate(arr, [](int i) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> i * i; }, 0) == 14); }</code> </pre><br>  Play with the code here: <a href="https://wandbox.org/permlink/5fr5NCQAvvEKsWKq">@Wandbox</a> <br><br>  The code uses <code>constexpr</code> lambda, and then it is passed to a simple algorithm <code>SimpleAccumulate</code> .  The algorithm uses several C ++ 17 elements: the <code>constexpr</code> add- <code>constexpr</code> to <code>std::array</code> , <code>std::begin</code> and <code>std::end</code> (used in the <code>for</code> loop with a range) are now also <code>constexpr</code> , so this means that all code can be executed at compile time. <br><br>  Of course, this is not all. <br><br>  You can capture variables (assuming that they are also <code>constexpr</code> ): <br><br><pre> <code class="bash hljs">constexpr int add(int const&amp; t, int const&amp; u) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> t + u; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> add(x, n); }; static_assert(lam(10) == 10); }</code> </pre><br>  But there is an interesting case when you do not pass the captured variable further, for example: <br><br><pre> <code class="bash hljs">constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n + x };</code> </pre> <br>  In this case, in Clang we can get the following warning: <br><br> <code>warning: lambda capture 'x' is not required to be captured for this use</code> <br> <br>  This is probably due to the fact that x can be changed on the spot with each use (if you do not pass it on or you do not take the address of that name). <br><br>  But please let me know if you know the official rules for this behavior.  I found only (from the <a href="https://en.cppreference.com/w/cpp/language/lambda">cppreference</a> ) (but I can't find it in the draft ...) <br><br>  <i><b>(Translator's note: as our readers write, probably, we mean the substitution of the value 'x' in each place where it is used. It‚Äôs impossible to change it for sure.)</b></i> <br><br>  <i>A lambda expression can read the value of a variable without grabbing it if the variable</i> <i><br></i>  <i>* has a constant <code>non-volatile</code> integer or enum type and was initialized with <code>constexpr</code> or</i> <i><br></i>  <i>* is <code>constexpr</code> and has no changeable members.</i> <br><br>  Be prepared for the future: <br><br>  In C ++ 20, we will have <code>constexpr</code> standard algorithms and perhaps even some containers, so <code>constexpr</code> lambdas will be very useful in this context.  Your code will look the same for the runtime version, as well as for the <code>constexpr</code> version (compile time version)! <br><br>  In a nutshell: <br><br>  <code>constexpr</code> lambda allows you to <code>constexpr</code> with template programming and possibly have a shorter code. <br><br>  Now let's move on to the second important feature available in C ++ 17: <br><br>  <b>Capture of * this</b> <br>  <i><b>Capture * this</b></i> <br><br>  Do you remember our problem when we wanted to capture a member of the class?  By default, we capture this (as a pointer!), And therefore we may have problems when temporary objects go out of scope ... This can be fixed by using the capture method with an initializer (see the first part of the series).  But now, in C ++ 17, we have another way.  We can wrap a copy of * this: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;iostream&gt; struct Baz { auto foo() { return [*this] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></code> </pre> <br>  Play with the code here: <a href="https://wandbox.org/permlink/i8m9UeAHa2YsqkgL">@Wandbox</a> <br><br>  Capturing a desired member variable with an initializer capture protects you from possible errors with temporary values, but we cannot do the same when we want to call a method like: <br><br>  For example: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; } void <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() const { std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } std::string s; };</code> </pre> <br>  In C ++ 14, the only way to make the code more secure is to capture <code>this</code> with an initializer: <br><br><pre> <code class="bash hljs">auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [self=*this] { self.print(); }; }   C ++ 17    : auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [*this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; }</code> </pre> <br>  Something else: <br><br>  Please note that if you write <code>[=]</code> in a member function, <code>this</code> captured implicitly!  This can lead to errors in the future ... and it will become obsolete in C ++ 20. <br><br>  Here we come to the next section: the future. <br><br>  <b>Future with C ++ 20</b> <br><br>  In C ++ 20 we get the following functions: <br><br><ul><li>  Allow <code>[=, this]</code> as lambda capture - <a href="https://wg21.link/p0409r2">P0409R2</a> and cancel the implicit capture of this via <code>[=]</code> - <a href="https://wg21.link/P0806">P0806</a> </li><li>  Package extension in <code>lambda init-capture: ... args = std::move (args)] () {}</code> - <a href="https://wg21.link/P0780">P0780</a> </li><li>  static, <code>thread_local</code> and lambda capture for structured bindings - <a href="https://wg21.link/P1091">P1091</a> </li><li>  lambda template (also with concepts) - <a href="https://wg21.link/P0428R2">P0428R2</a> </li><li>  Simplify implicit lambda capture - <a href="https://wg21.link/P0588R1">P0588R1</a> </li><li>  Constructive and <a href="https://wg21.link/P0624R2">assignable</a> lambda stateless by default - <a href="https://wg21.link/P0624R2">P0624R2</a> </li><li>  Lambda in a non- <a href="https://wg21.link/P0315R4">calculated</a> context - <a href="https://wg21.link/P0315R4">P0315R4</a> </li></ul><br>  In most cases, the newly introduced functions ‚Äúclear‚Äù lambda usage, and they allow for some advanced use cases. <br><br>  For example, with <a href="https://wg21.link/P1091">P1091,</a> you can capture a structured binding. <br><br>  We also have explanations related to the seizure of this.  In C ++ 20, you will get a warning if you grab <code>[=]</code> in the method: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; GCC 9: warning: implicit capture of <span class="hljs-string"><span class="hljs-string">'this'</span></span> via <span class="hljs-string"><span class="hljs-string">'[=]'</span></span> is deprecated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> C++20</code> </pre> <br>  If you really need to capture it, you should write <code>[=, this]</code> . <br><br>  There are also changes associated with advanced use cases, such as unresolved contexts and stateless lambdas, which can be constructed by default. <br><br>  With both changes you can write: <br><br><pre> <code class="bash hljs">std::map&lt;int, int, decltype([](int x, int y) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x &gt; y; })&gt; map;</code> </pre> <br>  Read the motives of these functions in the first version of the sentences: <a href="https://wg21.link/P0315R0">P0315R0</a> and <a href="https://wg21.link/P0624R0">P0624R0</a> . <br><br>  But let's look at one interesting feature: lambda templates. <br><br>  <b>Lambda template</b> <br><br>  In C ++ 14, we obtained generalized lambdas, which means that the parameters declared as auto are template parameters. <br><br>  For lambda: <br><br><pre> <code class="bash hljs">[](auto x) { x; }</code> </pre> <br>  The compiler generates a call statement that corresponds to the following generic method: <br><br><pre> <code class="bash hljs">template&lt;typename T&gt; void operator(T x) { x; }</code> </pre> <br>  But there was no way to change this template parameter and use the actual template arguments.  In C ++ 20 this will be possible. <br><br>  For example, how can we limit our lambda to work only with vectors of some type? <br><br>  We can write a common lambda: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(const auto&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  But if you call it with the int parameter (for example, <code>foo(10);</code> ), you can get some kind of hard-to-read error: <br><br><pre> <code class="bash hljs">prog.cc: In instantiation of <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda(const auto:1&amp;)&gt; [with auto:1 = int]'</span></span>: prog.cc:16:11: required from here prog.cc:11:30: error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to <span class="hljs-string"><span class="hljs-string">'size(const int&amp;)'</span></span> 11 | std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre><br>  In C ++ 20 we can write: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(std::vector&lt;T&gt; const&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  The aforementioned lambda allows the template call operator: <br><br><pre> <code class="bash hljs">&lt;typename T&gt; void operator(std::vector&lt;T&gt; const&amp; s) { ... }</code> </pre> <br>  The template parameter follows the capture clause <code>[]</code> . <br><br>  If you call it with <code>int (foo(10);)</code> , you will get a more pleasant message: <br><br><pre> <code class="bash hljs">note: mismatched types <span class="hljs-string"><span class="hljs-string">'const std::vector&lt;T&gt;'</span></span> and <span class="hljs-string"><span class="hljs-string">'int'</span></span></code> </pre> <br><br>  Play with the code here: <a href="https://wandbox.org/permlink/gupbJfUfHHQ2y48q">@Wandbox</a> <br><br>  In the above example, the compiler can warn us about inconsistencies in the lambda interface, rather than in the code inside the body. <br><br>  Another important aspect is that in a universal lambda you only have a variable, not its type of pattern.  Therefore, if you want to access it, you must use decltype (x) (for lambda expressions with an argument (auto x)).  This makes some code more verbose and complex. <br><br>  For example (using the code from P0428): <br><br><pre> <code class="bash hljs">auto f = [](auto const&amp; x) { using T = std::decay_t&lt;decltype(x)&gt;; T copy = x; T::static_function(); using Iterator = typename T::iterator; }</code> </pre> <br>  Now you can write as: <br><br><pre> <code class="bash hljs">auto f = []&lt;typename T&gt;(T const&amp; x) { T::static_function(); T copy = x; using Iterator = typename T::iterator; }</code> </pre> <br>  In the section above, we had a brief overview of C ++ 20, but I have another additional usage example for you.  This technique is possible even in C ++ 14.  So read on. <br><br>  <b>Bonus - LIFTING LIFTING</b> <br><br>  Currently, we have a problem when you have function overloads, and you want to transfer them to standard algorithms (or anything that requires some callable object): <br><br><pre> <code class="bash hljs">// two overloads: void foo(int) {} void foo(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) {} int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { std::vector&lt;int&gt; vi; std::for_each(vi.begin(), vi.end(), foo); }</code> </pre> <br>  We get the following error from GCC 9 (trunk): <br><br><pre> <code class="bash hljs">error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to for_each(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;::iterator, &lt;unresolved overloaded <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>&gt;) std::for_each(vi.begin(), vi.end(), foo); ^^^^^</code> </pre> <br>  However, there is a trick in which we can use lambda, and then call the desired overload function. <br><br>  In the basic form, for simple value types, for our two functions, we can write the following code: <br><br><pre> <code class="bash hljs">std::for_each(vi.begin(), vi.end(), [](auto x) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> foo(x); });</code> </pre> <br>  And in the most general form, we need to recruit a little more: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#define LIFT(foo) \ [](auto&amp;&amp;... x) \ noexcept(noexcept(foo(std::forward&lt;decltype(x)&gt;(x)...))) \ -&gt; decltype(foo(std::forward&lt;decltype(x)&gt;(x)...)) \ { return foo(std::forward&lt;decltype(x)&gt;(x)...); }</span></span></code> </pre> <br>  Pretty complicated code ... right?  :) <br><br>  Let's try to decipher it: <br><br>  We create a generic lambda and then pass all the arguments we get.  To define it correctly, we need to specify noexcept and the type of the return value.  That's why we need to duplicate the calling code ‚Äî to get the right types. <br>  Such a LIFT macro works in any compiler that supports C ++ 14. <br><br>  Play with the code here: <a href="https://wandbox.org/permlink/r81jASiPPmYXTOmx">@Wandbox</a> <br><br>  <b>Conclusion</b> <br><br>  In this post, we looked at significant changes in C ++ 17, and made a review of new features in C ++ 20. <br><br>  You may notice that with each iteration of the language lambda expressions are mixed with other elements of C ++.  For example, before C ++ 17, we could not use them in the context of constexpr, but now it is possible.  Similarly with generalized lambdas starting from C ++ 14 and their evolution in C ++ 20 in the form of template lambdas.  Did I miss something?  Maybe you have some exciting example?  Please let me know in the comments! <br><br>  <b>Links</b> <br><br>  C ++ 11 - <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">[expr.prim.lambda]</a> <br>  C ++ 14 - <a href="https://timsong-cpp.github.io/cppwp/n4140/expr.prim.lambda">[expr.prim.lambda]</a> <br>  C ++ 17 - <a href="https://timsong-cpp.github.io/cppwp/n4659/expr.prim.lambda">[expr.prim.lambda]</a> <br>  <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp%3Fview%3Dvs-2017">Lambda Expressions in C ++ |</a>  <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp%3Fview%3Dvs-2017">Microsoft docs</a> <br>  Simon Brand - <a href="https://blog.tartanllama.xyz/passing-overload-sets/">Passing overload sets to functions</a> <br>  Jason Turner - <a href="https://www.youtube.com/watch%3Fv%3DixGiE4-1GA8%26">C ++ Weekly - Ep 128 - C ++ 20's Template Syntax For Lambdas</a> <br>  Jason Turner - <a href="https://www.youtube.com/watch%3Fv%3Dkmza9U_niq4">C ++ Weekly - Ep 41 - C ++ 17's constexpr Lambda Support</a> <br><br>  We invite everyone to the traditional <a href="https://otus.pw/3fvB/">free webinar</a> at the rate that will take place tomorrow, June 14th. </div><p>Source: <a href="https://habr.com/ru/post/455978/">https://habr.com/ru/post/455978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455968/index.html">I make a big half-bed on solar panels for 250,000 rubles (1 part)</a></li>
<li><a href="../45597/index.html">The beginning of sales of WiMAX modems in Moscow</a></li>
<li><a href="../455970/index.html">Everything you wanted to know about SwiftUI, but were afraid to ask</a></li>
<li><a href="../455972/index.html">Slurm: the caterpillar turned into a butterfly</a></li>
<li><a href="../455976/index.html">Cabinets, modules or units - what to choose for power management in the data center?</a></li>
<li><a href="../455980/index.html">iOS Digest number 7 (May 31 - June 13)</a></li>
<li><a href="../455982/index.html">It's time to replace GIF with AV1 video</a></li>
<li><a href="../455986/index.html">Why should an IT person take out the brain?</a></li>
<li><a href="../455990/index.html">KTT in server solutions - what does it look like?</a></li>
<li><a href="../455994/index.html">The evolution of the most popular tool of any developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>