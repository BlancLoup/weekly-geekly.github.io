<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Autonomous cross-platform monolithic Java program</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I love desktop apps. Admitting to this now seems more embarrassing than in relations with foreign intelligence, but it is. No, this does not mean that...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Autonomous cross-platform monolithic Java program</h1><div class="post__text post__text-html js-mediator-article">  I love desktop apps.  Admitting to this now seems more embarrassing than in relations with foreign intelligence, but it is.  No, this does not mean that I do not like Internet technology.  Moreover, I not only respect some, but even more or less know.  But, nevertheless, I miss the time when the program was written on one computer, then compiled and run on other, different computers.  Then everywhere (almost) there was one system - Windows with the same API, there were almost no compatibility issues at the application level, no one was motivated by browser developers - everybody took care of WinAPI developers, who managed to create conflicts even inside it.  But this is, of course, ironic, but seriously - sometimes even now I just want to write a desktop application, so much so that it works on all popular systems.  Difficult?  If you think and dig, it is not very. <br><br>  I also like high-level languages ‚Äã‚Äãwith neat architecture and strong typing.  My favorites are Java and C #.  Both of them provide the developer with many advantages compared to C ++, both relieve from a number of concerns.  What have to pay?  By dragging along a heavy deck called the Oracle JVM, .NET or mono.  All three decks weigh hundreds of megabytes and have a license such that each user has to download this thing himself, without confusing the bitness of his computer, and most importantly, the Java program cannot be compatible with all versions of JVM at once, is it?  And so - we come to the fact that just throwing the program to a friend (or a million friends) and not worrying that it does not start for him does not come out.  We have to make clever setups, drive crutches, and I have not mentioned it yet. NET - once I saw a friend with 3 installed versions at once, and all three were needed by different applications ... <br><br>  Stop!  <em>And let's write a Java program, but in such a way that it does not require installation of any JVM on the machine, with one touch going under Windows, Linux and OS X and at the same time taking up quite a bit;</em>  <em>so that no one even understood that it was written, say, not in C.</em> Impossible?  Quite the contrary!  (And no, I mean not gcj, which deprives Java of all its charms. Reflection will work and even third-party jar you can run). <br><img src="https://habrastorage.org/storage2/66d/2bb/544/66d2bb5444529a735c5fbfe774ca41a5.png"><br><a name="habracut"></a><br>  Of course, I'm not a magician.  I just found one magic artifact.  It is called Avian, lies at <a href="http://oss.readytalk.com/avian/">oss.readytalk.com/avian</a> and is a lightweight, but full-fledged third-party JVM implementation, which Oracle may not have even heard of.  He supports a bunch of platforms and architectures, has a ‚Äútake and do what you want‚Äù license, and - no, I have no relation to this project, I am not even a contributor, I just learned how to use it and want to share this powerful knowledge with respected inhabitants of Habr.  It is also worth noting that it is a JIT compiler, that is, it has a competitive high performance (although I haven‚Äôt measured it yet). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Avian can be embedded in your application along with its very standardized class library, which is tolerant in functionality, and the program is only a megabyte heavy with hooks.  Let's put together such a program. <br><br><h4>  0. Wednesday </h4><br>  To build, we first need the command line utilities of a unix developer, in particular, the g ++ compiler.  It is most difficult for Windows users.  I used to use MinGW32 for Windows with its excellent MSYS environment, which emulates a unix terminal.  The compilers included in MinGW32 are 32-bit, which in some way limits the resulting program.  In the comments I was told that there is a convenient mingw-w64 for a long time, which is regularly updated and in which there is not only MSYS, but even git. <br><br>  Here and further, I hid platform-specific instructions under spoilers for convenience. <br><br><div class="spoiler">  <b class="spoiler_title">Windows</b> <div class="spoiler_text"> To download MinGW, go to <a href="http://sourceforge.net/projects/mingwbuilds/">sourceforge.net/projects/mingwbuilds</a> and download two archives there: x64- <em>XXX</em> -release-posix-seh-rev <em>X</em> .7z and external-binary-packages / msys + 7za + wget + svn + git + mercurial + cvs-rev <em>X</em> .7z <br><br>  After they are downloaded, unpack both of them in convenient directories.  Next, you need to tell the MSYS environment where MinGW is located.  To do this, go to <code>msys/etc</code> and write the path to <code>/mingw</code> in the <code>fstab</code> file as shown in the <code>fstab.sample</code> file <code>fstab.sample</code> I did it like this: <br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">c</span></span>:/mingw64 /mingw</code> </pre><br><br>  After installing all of the above, you open the MSYS terminal.  To do this, run the file <code>msys\msys.bat</code> (next to it are two icons).  All further actions we will do from this terminal, since, firstly, it supports the format of unix-commands and unix-ways, and, secondly, it contains all the necessary environmental parameters. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">OS X</b> <div class="spoiler_text">  Under OS X you have to download Xcode 4 and in its settings, in the Downloads section, install the Command Line Tools.  Then you simply open a terminal window through the Launcher. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Linux</b> <div class="spoiler_text">  In linian based on debian, simply open the terminal and write: <br><br><pre> <code class="hljs swift">&gt; sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install build-essential</code> </pre><br>  After that, you need to close the terminal window and open it again to load the new environment settings. <br></div></div><br><br>  The bottom line in each operating system should be what you type on the command line. <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; g++</span></span></code> </pre><br>  and in response you see something like <br><br><pre> <code class="hljs pgsql">g++: fatal error: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> files</code> </pre><br>  Such a message means that the compiler is ready for battle and is eager to receive the source files. <br><br><h4>  1. Avian </h4><br>  For a start, let's offer our g ++ to build Avian. <br>  Open: <a href="http://oss.readytalk.com/avian/">oss.readytalk.com/avian</a> .  Select the <b>status</b> link.  On the page that opens, download <b>Avian 0.6</b> .  Despite the modest version number, the program is absolutely stable (in any case, I have never managed to drop it, and in their bugtracker there are quite intricate bugs, meaning high stability of what is). <br><br>  Unpack the Avian source file we downloaded into some folder (let it be ~ / Projects). <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; cd ~/Projects</span></span></code> </pre><br>  Under Windows, the "~" folder in the MSYS environment is not attached to the user's home folder, but to the C: \ MinGW64 \ msys \ home \ username folder.  In our case, since we want to maximally distance ourselves from the platform, this is even an advantage. <br><br>  Suppose the downloaded archive is called avian-0.6.tar.bz2 and is in ~ / Downloads, then unpack it into the current folder by typing <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; tar -xjf ~/Downloads/avian-0.6.tar.bz2</span></span></code> </pre><br>  On Windows, the path must be specified in the mingw format with straight slashes in the form of /c/Users/username/Downloads/avian-0.6.tar.bz2.  Of course, you can use one of a hundred alternative ways to unpack the archive - the main thing is to get it into the current folder.  As a result, the avian subfolder unpacked from the archive will appear in it.  Go to her: <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; cd avian</span></span></code> </pre><br>  Now you can try to run the make command, but if you run the build right now, most likely we will get a message that zlib was not found.  Something like zlib.h: No such file or directory. <br><br><div class="spoiler">  <b class="spoiler_title">Windows</b> <div class="spoiler_text">  Under Windows, you will have to sweat a little and use the method proposed by the Avian authors, namely, slip the zlib library from their special auxiliary win64 repository.  To do this, you will need git installed on your system.  Fortunately, git is included in the msys build that we installed.  Unfortunately, at the time of this writing, the build is crooked - it lacks the msys-crypto-0.9.8.dll file, which will have to be found on Google and put next to its useless brother, msys-crypto-1.0.0.dll, which This assembly is complete. <br><br>  Next, you need to run the command from the avian folder <br><br><pre> <code class="hljs php">&gt; git <span class="hljs-keyword"><span class="hljs-keyword">clone</span></span> git:<span class="hljs-comment"><span class="hljs-comment">//oss.readytalk.com/win64.git ../win64</span></span></code> </pre><br>  which will put the win64 folder next to the avian folder with all the libraries that avian may need, in particular, with zlib. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">OS X</b> <div class="spoiler_text">  Under OS X, as I recall, this library is installed automatically (possibly with the developer‚Äôs toolkit, which we have already installed). <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Linux</b> <div class="spoiler_text">  Under linux, this problem is solved by a simple <br><br><pre> <code class="hljs swift">&gt; sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install zlib1g-dev</code> </pre><br></div></div><br>  However, by installing zlib and typing <code>make</code> again, we will get another error - the Avian collector does not find the / bin / javac program.  Java developers are likely to recognize this program - this is a Java compiler.  Since Avian is only a virtual machine, we still use the official compiler from Oracle.  When building the VM itself, it is needed in order to build the Avian classes of the small standard Avian library from the source java files, such as <code>System</code> , <code>ArrayList</code> or <code>HashMap</code> .  Accordingly, the developer‚Äôs machine should still have the JDK - both when building Avian, and when building applications that will use it.  And it is desirable to put JDK7, which is compatible with Avian 0.6.  The user of your applications, like the JRE, will no longer need it (actually, for the sake of it we are trying). <br><br><div class="spoiler">  <b class="spoiler_title">Windows</b> <div class="spoiler_text">  On Windows, go to the Oracle site and download the desired distribution, and then install it. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">OS X</b> <div class="spoiler_text">  In OS X, as in Windows, go to the Oracle website and download the desired distribution, and then install it. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Linux</b> <div class="spoiler_text">  In Linux, we manage the usual mantra <br><br><pre> <code class="hljs swift">&gt; sudo apt-<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> install openjdk-<span class="hljs-number"><span class="hljs-number">7</span></span>-jdk</code> </pre><br>  (Perhaps your distribution will not have OpenJDK or the package will be called something else. But Linux is Linux - look for it and find it.) <br></div></div><br>  In order to see where you just put your java-environment for developers, make reads the JAVA_HOME environment variable, which we now need to set correctly.  We need the same variable with the same value later on in order to build our own project. <br><br><div class="spoiler">  <b class="spoiler_title">Windows</b> <div class="spoiler_text">  Your path to MinGW for Windows is likely to be something like / c / Program \ Files / Java / jdk1.7.0_07 / (you specified it when installing JDK7). <br></div></div><br><div class="spoiler">  <b class="spoiler_title">OS X</b> <div class="spoiler_text">  Under OS X, your JDK7 will install in /Library/Java/JavaVirtualMachines/jdk1.7.0_17.jdk/Contents/Home <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Linux</b> <div class="spoiler_text">  On Linux, it looks like this: <br><br><pre> <code class="hljs haskell">&gt; update-java-alternatives -l java<span class="hljs-number"><span class="hljs-number">-1.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>-openjdk-amd64 <span class="hljs-number"><span class="hljs-number">1071</span></span> /usr/lib/<span class="hljs-keyword"><span class="hljs-keyword">jvm</span></span>/java<span class="hljs-number"><span class="hljs-number">-1.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>-openjdk-amd64 &gt; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-type"><span class="hljs-type">JAVA_HOME</span></span>=/usr/lib/<span class="hljs-keyword"><span class="hljs-keyword">jvm</span></span>/java<span class="hljs-number"><span class="hljs-number">-1.7</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>-openjdk-amd64</code> </pre><br></div></div><br>  And now, finally, the hour of triumph - we collect Avian: <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; make</span></span></code> </pre><br>  If you did everything correctly, you will see a sequence of lines like compiling build / &lt;your platform_name&gt; / &lt;some file&gt;, and then linking build / &lt;your_ platform_name&gt; / &lt;some file&gt;.  At the end of the build process, we will get a lot of files in the build / &lt;your platform_name&gt; folder, but we‚Äôll be interested only in this: <br><br><ul><li>  <b>classpath.jar</b> is the smallest base class library that you will use in your programs.  It is possible to build Avian using the OpenJDK library, but, first, as I understand it, it has a less kind license, and second, it is significantly heavier. <br></li><li>  <b>binaryToObject (.exe)</b> is a utility necessary for embedding Avian into your applications, the purpose of which will be revealed later. <br></li><li>  <b>libavian.a</b> is the most important file.  This is, in fact, embedded virtual machine.  He takes up 23 megabytes from me, but don't be afraid.  It will noticeably lose weight after some simple and, what is important, completely harmless and automatic manipulations, the essence of which will also be revealed later. <br></li></ul><br><br><h4>  2. Cross-platform independent monolithic hello in Java </h4><br>  We compiled all the necessary third-party code.  Now let's create our own. <br><br>  The task is to make a program that will be written in Java, which at the same time will contain as few platform-specific bookmarks as possible and which will be assembled into one exe-file that does not require special installation by itself and runs on any "clean" system without install any dependencies. <br><br><h5>  2.1.  A little about JNI </h5><br>  Let's start with the theory.  Discuss how the JVM interacts with the system.  Any virtual machine is created, first of all, in order to abstract from the external environment.  Therefore, it is not surprising that the call of system functions is the bottleneck in the VM implementation.  A modern program cannot even "sneeze" without the OS.  Read / write to disk - system function.  Text output to the console is a system function.  Draw a window on the screen - what do you think? <br><br>  In fact, the only thing that an application can do ‚Äúinside itself‚Äù is calculations and decision making.  These actions ‚Äî arithmetic and logic ‚Äî are VM functions.  As soon as something else needs to be done, she calls for the external environment.  But how?  In the case of Java, there is a JNI (Java Native Interface) for this.  Its essence is very simple.  A program written in Java contains a function header marked with the native modifier.  For example, <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> packagename; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassName</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } }</code> </pre><br>  Such a function is understood by the Java compiler as a function that is called from loaded libraries of ordinary (non-virtual) code.  In one of these libraries there must be something like <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-function">JNIEXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_packagename_ClassName_foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JNIEnv * env, jobject caller</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre><br>  When we call the <code>foo()</code> function in Java code, we actually call a function from the native library, passing it a pointer to the <code>JNIEnv</code> environment ‚Äî an object that allows to ‚Äúcommunicate‚Äù with data and code inside the VM, and a pointer to the object from which the function was called, <code>jobject caller</code> (if the function were static, instead of the object descriptor, there would be a <code>jclass caller_class</code> class descriptor).  People who are familiar with Java, but have not studied JNI, can explain this principle of interaction as follows: JNI allows external native-code to perform reflection on a Java program.  If you want to study this technology in more detail, you are welcome <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">in a special section on the official Oracle website</a> . <br><br><h5>  2.2.  JNI "set" </h5><br>  Why was all this educational program?  Then, that at the moment we face a very interesting, almost inverse, task.  We need to run a native-executable file, which, being statically linked to the libavian.a library, will contain the JVM right inside it.  In addition, it will contain all the necessary java-classes, including the ‚Äúentry point‚Äù - a class like <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre><br>  It all sounds pretty scary, but the task is quite simple.  You need to write a fairly simple C code that will pull out the Avian class library (with our <code>Application</code> class added to it) from within its own binary file and feed it to the JVM along with command line parameters using the same JNI.  Then we link this C-file in a special way so that everything is in its place, and enjoy the result. <br><br><h5>  2.3.  New project and libraries </h5><br>  Now we will drag and lay down all the components we need for further work.  What I will describe here is my own approach.  Of course, you are free to do everything differently, as you please.  But if you want to end up with exactly what I posted on GitHub (the link will be at the end), try to do everything exactly. <br><br>  Create a crossbase folder where we want (I created it in Projects, next to avian and win32) <br><br><pre> <code class="hljs dos">&gt; <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> crossbase &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> crossbase</code> </pre><br>  Inside we create a subfolder libs <br><br><pre> <code class="hljs dos">&gt; <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> lib &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> lib</code> </pre><br>  Inside we create a subfolder with the name of your current OS.  It should be ‚Äúlinux‚Äù, ‚Äúwin32‚Äù or ‚Äúosx‚Äù. <br><br><pre> <code class="hljs dos">&gt; <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> win-x86_64 &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> win-x86_64</code> </pre><br>  In this folder you need to copy the libavian.a, which we collected earlier.  It looks like this to me: <br><br><pre> <code class="hljs coffeescript">&gt; cp ..<span class="hljs-regexp"><span class="hljs-regexp">/../</span></span>..<span class="hljs-regexp"><span class="hljs-regexp">/avian/build/windows-i386/libavian.a ./</span></span></code> </pre><br>  In addition, in a Windows system where there is no zlib, libz.a will also need to be copied to the same folder: <br><br><pre> <code class="hljs coffeescript">&gt; cp ..<span class="hljs-regexp"><span class="hljs-regexp">/../</span></span>..<span class="hljs-regexp"><span class="hljs-regexp">/win-x86_64/lib/libz.a ./</span></span></code> </pre><br>  Thus, we have collected the minimum required libraries.  That's enough for the simplest program. <br><br>  In addition to libraries, we will need classpath.jar, which was also compiled with avian. <br><br><pre> <code class="hljs dos">&gt; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. &gt; <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> java &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> java &gt; cp ../../../avian/build/windows-i386/classpath.jar ./</code> </pre><br>  And now it's time to reveal the purpose of the mysterious binaryToObject.  We need it to convert our jar file to a special object file, which will then be transferred to the linker and added to our program by it.  Since this procedure must be carried out with each assembly, it must also be dragged into our new project. <br><br><pre> <code class="hljs markdown"><span class="hljs-quote"><span class="hljs-quote">&gt; cd ../..</span></span></code> </pre><br>  (we are again in the crossbase folder where we created the lib) <br><br><pre> <code class="hljs dos">&gt; <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> -p tools/win-x86_64 &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> tools/win-x86_64</code> </pre><br>  The name win-x86_64 is assigned to the internal folder on the same principle as last time.  We throw here binaryToObject.  (in Windows, of course, it has an exe extension) <br><br><pre> <code class="hljs coffeescript">&gt; cp ..<span class="hljs-regexp"><span class="hljs-regexp">/../</span></span>..<span class="hljs-regexp"><span class="hljs-regexp">/avian/build/windows-i386/binaryToObject/binaryToObject.exe ./</span></span></code> </pre><br>  You can run it and see usage: <br><br><pre> <code class="hljs tex">usage: c:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Users</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">imizus</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Projects</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">crossbase</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">crossbase</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tools</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">win</span></span></span></span>32<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">binaryToObject</span></span></span></span>.exe &lt;input file&gt; &lt;output file&gt; &lt;start name&gt; &lt;end name&gt; &lt;platform&gt; &lt;architecture&gt; [&lt;alignment&gt; [{writable|executable}...]]</code> </pre><br><br><h5>  2.4.  Program code </h5><br>  Now let's start writing the code.  Create a new C ++ source file (you can use any text editor you like, I use eclipse, where you can edit both C ++ and Java in one project, although this will have to be slightly customized). <br><br><pre> <code class="hljs dos">&gt; <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> -p src/cpp &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> src/cpp</code> </pre><br>  Inside we create the main.cpp file with the following content (I will give it in its entirety, and then I will explain what is there for what): <br><br><pre> <code class="hljs lua">#include &lt;stdint.h&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.h&gt; #ifdef __MINGW32__ #include &lt;windows.h&gt; #endif #include &lt;jni.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defined __MINGW32__) # define EXPORT __declspec(dllexport) #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # define EXPORT __attribute__ ((visibility(<span class="hljs-string"><span class="hljs-string">"default"</span></span>))) \ __attribute__ ((used)) #endif #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! defined __x86_64__) &amp;&amp; (defined __MINGW32__) # define SYMBOL(x) binary_boot_jar_##x #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # define SYMBOL(x) _binary_boot_jar_##x #endif extern <span class="hljs-string"><span class="hljs-string">"C"</span></span> { extern const uint8_t SYMBOL(start)[]; extern const uint8_t SYMBOL(<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)[]; EXPORT const uint8_t* bootJar(unsigned* size) { *size = SYMBOL(<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) - SYMBOL(start); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SYMBOL(start); } } // extern <span class="hljs-string"><span class="hljs-string">"C"</span></span> int main(int argc, const <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>** argv) { #ifdef __MINGW32__ // For Windows: Getting command line as a wide <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> int wac = <span class="hljs-number"><span class="hljs-number">0</span></span>; wchar_t** wav; wav = CommandLineToArgvW(GetCommandLineW(), &amp;wac); #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // For other OS: Getting command line as a plain <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> (encoded <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> UTF8) int wac = argc; const <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>** wav = argv; #endif JavaVMInitArgs vmArgs; vmArgs.version = JNI_VERSION_1_2; vmArgs.nOptions = <span class="hljs-number"><span class="hljs-number">1</span></span>; vmArgs.ignoreUnrecognized = JNI_TRUE; JavaVMOption options[vmArgs.nOptions]; vmArgs.options = options; options[<span class="hljs-number"><span class="hljs-number">0</span></span>].optionString = const_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*&gt;(<span class="hljs-string"><span class="hljs-string">"-Xbootclasspath:[bootJar]"</span></span>); JavaVM* vm; void* env; JNI_CreateJavaVM(&amp;vm, &amp;env, &amp;vmArgs); JNIEnv* e = static_cast&lt;JNIEnv*&gt;(env); jclass c = e-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"crossbase/Application"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> e-&gt;ExceptionCheck()) { jmethodID m = e-&gt;GetStaticMethodID(c, <span class="hljs-string"><span class="hljs-string">"main"</span></span>, <span class="hljs-string"><span class="hljs-string">"([Ljava/lang/String;)V"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> e-&gt;ExceptionCheck()) { jclass stringClass = e-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/String"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> e-&gt;ExceptionCheck()) { jobjectArray a = e-&gt;NewObjectArray(wac - <span class="hljs-number"><span class="hljs-number">1</span></span>, stringClass, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> e-&gt;ExceptionCheck()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; wac; ++i) { #ifdef __MINGW32__ // For Windows: Sending wide <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> to Java int arglen = wcslen(wav[i]); jstring <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> = e-&gt;NewString((jchar*) (wav[i]), arglen); #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // For other OS: Sending UTF8-encoded <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> to Java int arglen = strlen(wav[i]); jstring <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> = e-&gt;NewStringUTF((<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*) (wav[i])); #endif e-&gt;SetObjectArrayElement(a, i - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>); } e-&gt;CallStaticVoidMethod(c, m, a); } } } } int exitCode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e-&gt;ExceptionCheck()) { exitCode = <span class="hljs-number"><span class="hljs-number">-1</span></span>; e-&gt;ExceptionDescribe(); } vm-&gt;DestroyJavaVM(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exitCode; }</code> </pre><br><br>  <code>__MINGW32__</code> is the preprocessor symbol, which (as unexpectedly!) Is automatically set inside the MinGW32 environment.  It allows us to distinguish between Windows, which, as you, I think, have already noticed, is very different from all other systems.  In particular, only under Windows we need a special system API, which we connect with the line <code>#include &lt;windows.h&gt;</code> .  On the other platforms, we manage the standard POSIX and ANSI C ++ libraries.  Why do you need?  It will become clear a little later.  We will view the code in order. <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (defined __MINGW32__) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EXPORT __declspec(dllexport) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EXPORT __attribute__ ((visibility(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"default"</span></span></span><span class="hljs-meta">))) \ __attribute__ ((used)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  This code is familiar and understandable to anyone who wrote cross-platform dynamic libraries using gcc.  Its essence is that in different operating systems functions that should be exported from a library are described differently.  ‚ÄúAnd here is a dynamic library, because we are collecting the executable file?‚Äù - you ask.  In response, I remind you that Avian interacts with the platform-specific code through the JNI mechanism, which implies a function call from the library.  In other words, for your Java code, an executable file is not only a launch program, but also a dynamic library of functions. <br><br>  The next part is weird magic: <br><pre> <code class="hljs rust">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! defined __x86_64__) &amp;&amp; (defined __MINGW32__) # define SYMBOL(x) binary_boot_jar_##x #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # define SYMBOL(x) _binary_boot_jar_##x #endif <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8_t SYMBOL(start)[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8_t SYMBOL(end)[]; EXPORT <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8_t* bootJar(unsigned* size) { *size = SYMBOL(end) - SYMBOL(start); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SYMBOL(start); } } <span class="hljs-comment"><span class="hljs-comment">// extern "C"</span></span></code> </pre><br>  Let's see.  We declare an export function (look at <code>extern "C"</code> and <code>EXPORT</code> directive that we just introduced. The function name is <code>bootJar</code> . <code>bootJar</code> this name and see what it does. If we mentally parse the preprocessor directives, we see that it calculates the distance between some _binary_boot_jar_start and _binary_boot_jar_end (In MinGW32, they will not have an underscore at the beginning.) These characters themselves are declared as <code>extern</code> , that is, they must be substituted by the linker. Mysterious activity, isn't it? <br><br>  In fact, as we will see below, it's pretty simple, if you know what to do.  Since Avian was designed to be embedded in applications, the authors provided the ability to add a class library directly to the executable file and then download it from there.  To do this, you just need to convert the library into an object file.  Yes, yes, I was surprised at first, but this is a very elegant idea.  In the object file containing our jar, when we create it, 2 symbols will be declared, indicating the beginning ( <code>_binary_boot_jar_start</code> ) and the end ( <code>_binary_boot_jar_end</code> ) of this jar-file.  And the <code>bootJar</code> function will be used by Avian to find out where it starts and how long it has.  Looking ahead, I‚Äôll say that the name of this function is passed as a string. <br><br><pre> <code class="hljs cpp">options[<span class="hljs-number"><span class="hljs-number">0</span></span>].optionString = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(<span class="hljs-string"><span class="hljs-string">"-Xbootclasspath:[bootJar]"</span></span>);</code> </pre><br>  Finally we got to the entry point - the <code>main</code> function.  Her task includes: <br><ul><li>  Read parameter string </li><li>  Download Avian by passing it a class library. </li><li>  Call the main function from the crossbase.Application class, passing in the command line parameters </li><li>  It is beautiful to fly with an error if any of the above fails. </li></ul><br><br>  Let's go from the beginning of the function: <br><br><pre> <code class="hljs vhdl">#ifdef __MINGW32__ // <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> Windows: Getting command <span class="hljs-literal"><span class="hljs-literal">line</span></span> as a wide <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> int wac = <span class="hljs-number"><span class="hljs-number">0</span></span>; wchar_t** wav; wav = CommandLineToArgvW(GetCommandLineW(), &amp;wac); #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> other OS: Getting command <span class="hljs-literal"><span class="hljs-literal">line</span></span> as a plain <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> (encoded <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> UTF8) int wac = argc; const char** wav = argv; #endif</code> </pre><br>  Here, as always, Windows distinguished itself.  When it was universally decided to switch from old uncomfortable single-byte encodings to more complex ones, all OS switched to convenient UTF-8, and Microsoft‚Äôs favorite brainchild switched to fixed two-byte one.  At the same time, they didn‚Äôt take care of the encoding used, for example, in file names.  But the coding doesn‚Äôt bother us now either.  We need to pass a string of parameters to Java (in which the two-byte <code>char</code> is also passed).  Therefore, for Windows, we call the API function (for which we dragged windows.h), which will give us the parameter string in the correct two-byte encoding.  So we will get the opportunity, for example, to open Cyrillic files in the title.  In all other systems, we simply read the parameters from the arguments of the <code>main</code> function. <br><br>  The following is the creation of a Java virtual machine: <br><br><pre> <code class="hljs cpp">JavaVMInitArgs vmArgs; vmArgs.version = JNI_VERSION_1_2; vmArgs.nOptions = <span class="hljs-number"><span class="hljs-number">1</span></span>; vmArgs.ignoreUnrecognized = JNI_TRUE; JavaVMOption options[vmArgs.nOptions]; vmArgs.options = options; options[<span class="hljs-number"><span class="hljs-number">0</span></span>].optionString = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(<span class="hljs-string"><span class="hljs-string">"-Xbootclasspath:[bootJar]"</span></span>); JavaVM* vm; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* env; JNI_CreateJavaVM(&amp;vm, &amp;env, &amp;vmArgs); JNIEnv* e = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;JNIEnv*&gt;(env);</code> </pre><br>  We also pull out a pointer to a <code>JNIEnv</code> object, which we will use to command the newly created Java machine. <br><br>  The following code reads Mayakovsky's verse, if you only know a little JNI. <br><br><pre> <code class="hljs pgsql">jclass c = e-&gt;FindClass("crossbase/Application"); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> e-&gt;ExceptionCheck()) { jmethodID m = e-&gt;GetStaticMethodID(c, "main", "([Ljava/lang/String;)V"); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> e-&gt;ExceptionCheck()) { jclass stringClass = e-&gt;FindClass("java/lang/String"); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> e-&gt;ExceptionCheck()) { jobjectArray a = e-&gt;NewObjectArray(wac - <span class="hljs-number"><span class="hljs-number">1</span></span>, stringClass, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> e-&gt;ExceptionCheck()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; wac; ++i) { #ifdef __MINGW32__ // <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> Windows: Sending wide string <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Java <span class="hljs-type"><span class="hljs-type">int</span></span> arglen = wcslen(wav[i]); jstring arg = e-&gt;NewString((jchar*) (wav[i]), arglen); #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> other OS: Sending UTF8-encoded string <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Java <span class="hljs-type"><span class="hljs-type">int</span></span> arglen = strlen(wav[i]); jstring arg = e-&gt;NewStringUTF((<span class="hljs-type"><span class="hljs-type">char</span></span>*) (wav[i])); #endif e-&gt;SetObjectArrayElement(a, i - <span class="hljs-number"><span class="hljs-number">1</span></span>, arg); } e-&gt;CallStaticVoidMethod(c, m, a); } } } } <span class="hljs-type"><span class="hljs-type">int</span></span> exitCode = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e-&gt;ExceptionCheck()) { exitCode = <span class="hljs-number"><span class="hljs-number">-1</span></span>; e-&gt;ExceptionDescribe(); }</code> </pre><br>  Take the <code>crossbase/Application</code> class.  If we could, we will find in it the static method <code>main</code> with the signature <code>([Ljava/lang/String;)V</code>  If we could, we will get the class <code>java/lang/String</code> from the standard library.  If we could, we will create an array of objects of this class (they will be parameters).  ,       java-   ,    <code>UTF-8</code> ,   Windows  ,   . <br><br>   -  ,   . <br><br> , ,   ¬´ ¬ª.        Java. ,  ,    <code>crossbase.Application</code>   <code>public static void main(String... args)</code> . <br><br>     crossbase/src  java,   ‚Äî  crossbase ( ‚Äî  ),     Application.java  : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> crossbase; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"This is a crossplatform monolith application with Java code inside. Freedom to Java apps!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; args.length; i++) { System.out.println(<span class="hljs-string"><span class="hljs-string">"args["</span></span> + i + <span class="hljs-string"><span class="hljs-string">"] = "</span></span> + args[i]); } } }</code> </pre><br>      Java, , ,   .  ,      Avian     (     ,  ,  OpenJDK). <br><br><h5>  2.5.  Assembly </h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the task of assembling our project. </font><font style="vertical-align: inherit;">I use make because it is always and wherever there is gcc. </font><font style="vertical-align: inherit;">It is also powerful enough to write almost any automated build system on it.</font></font> No, really.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It‚Äôs possible to list on fingers what I couldn‚Äôt do on make and these were hardly vital things. </font><font style="vertical-align: inherit;">Our Makefile will be located directly in the crossbase folder and it will look like this:</font></font><br><br><pre> <code class="hljs mel">UNAME := $(shell uname) ARCH := $(shell uname -m) SRC = src BIN = bin OBJ = obj JAVA_SOURCE_PATH = $(SRC)/java JAVA_CLASSPATH = $(BIN)/java CPP_SOURCE_PATH = $(SRC)/cpp OBJECTS = $(OBJ) DEBUG_OPTIMIZE = -O3 #-O0 -g ifeq ($(UNAME), Darwin) # OS X PLATFORM_ARCH = darwin x86_64 PLATFORM_LIBS = osx-x86_64 PLATFORM_GENERAL_INCLUDES = -I<span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/include"</span></span> -I<span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/include/darwin"</span></span> PLATFORM_GENERAL_LINKER_OPTIONS = -framework Carbon PLATFORM_CONSOLE_OPTION = EXE_EXT= STRIP_OPTIONS=-S -x RDYNAMIC=-rdynamic <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ifeq ($(UNAME) $(ARCH), Linux x86_64) # linux on PC PLATFORM_ARCH = linux x86_64 PLATFORM_LIBS = linux-x86_64 PLATFORM_GENERAL_INCLUDES = -I<span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/include"</span></span> -I<span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/include/linux"</span></span> PLATFORM_GENERAL_LINKER_OPTIONS = -lpthread -ldl PLATFORM_CONSOLE_OPTION = EXE_EXT= STRIP_OPTIONS=--<span class="hljs-keyword"><span class="hljs-keyword">strip</span></span>-all RDYNAMIC=-rdynamic <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ifeq ($(OS), Windows_NT) # Windows PLATFORM_ARCH = windows x86_64 PLATFORM_LIBS = win-x86_64 PLATFORM_GENERAL_INCLUDES = -I<span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/include"</span></span> -I<span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/include/win32"</span></span> PLATFORM_GENERAL_LINKER_OPTIONS = -static -lmingw32 -lmingwthrd -lws2_32 -mwindows -static-libgcc -static-libstdc++ PLATFORM_CONSOLE_OPTION = -mconsole EXE_EXT=.exe STRIP_OPTIONS=--<span class="hljs-keyword"><span class="hljs-keyword">strip</span></span>-all RDYNAMIC= endif JAVA_FILES = $(shell cd $(JAVA_SOURCE_PATH); find . -name \*.java | awk <span class="hljs-string"><span class="hljs-string">'{ sub(/.\//,"") }; 1'</span></span>) JAVA_CLASSES := $(addprefix $(JAVA_CLASSPATH)/,$(addsuffix .class,$(<span class="hljs-keyword"><span class="hljs-keyword">basename</span></span> $(JAVA_FILES)))) CPP_FILES = $(shell cd $(CPP_SOURCE_PATH); find . -name \*.cpp | awk <span class="hljs-string"><span class="hljs-string">'{ sub(/.\//,"") }; 1'</span></span>) CPP_OBJECTS := $(addprefix $(OBJECTS)/,$(addsuffix .o,$(<span class="hljs-keyword"><span class="hljs-keyword">basename</span></span> $(CPP_FILES)))) all: $(BIN)/crossbase $(JAVA_CLASSPATH)/%.class: $(JAVA_SOURCE_PATH)/%.java @echo $(PLATFORM_GENERAL_INCLUDES) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ ! -d <span class="hljs-string"><span class="hljs-string">"$(dir $@)"</span></span> ]; then mkdir -p <span class="hljs-string"><span class="hljs-string">"$(dir $@)"</span></span>; fi <span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/bin/javac"</span></span> -sourcepath <span class="hljs-string"><span class="hljs-string">"$(JAVA_SOURCE_PATH)"</span></span> -classpath <span class="hljs-string"><span class="hljs-string">"$(JAVA_CLASSPATH)"</span></span> -d <span class="hljs-string"><span class="hljs-string">"$(JAVA_CLASSPATH)"</span></span> $&lt; $(OBJ)/%.o: $(SRC)/cpp/%.cpp @echo $(PLATFORM_GENERAL_INCLUDES) mkdir -p $(OBJ) g++ $(DEBUG_OPTIMIZE) -D_JNI_IMPLEMENTATION_ -c $(PLATFORM_GENERAL_INCLUDES) $&lt; -o $@ $(BIN)/crossbase: $(JAVA_CLASSES) $(CPP_OBJECTS) mkdir -p $(BIN); @echo $(PLATFORM_GENERAL_INCLUDES) # Extracting libavian objects ( \ cd $(OBJ); \ mkdir -p libavian; \ cd libavian; \ ar x ../../lib/$(PLATFORM_LIBS)/libavian.a; \ ) # Making the java class library cp lib/java/classpath.jar $(BIN)/boot.jar; \ ( \ cd $(BIN); \ <span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/bin/jar"</span></span> u0f boot.jar -C java .; \ ) # Making an object <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> from the java class library tools/$(PLATFORM_LIBS)/binaryToObject $(BIN)/boot.jar $(OBJ)/boot.jar.o _binary_boot_jar_start _binary_boot_jar_end $(PLATFORM_ARCH); \ g++ $(RDYNAMIC) $(DEBUG_OPTIMIZE) -Llib/$(PLATFORM_LIBS) $(OBJ)/boot.jar.o $(CPP_OBJECTS) $(OBJ)/libavian<span class="hljs-comment"><span class="hljs-comment">/*.o $(PLATFORM_GENERAL_LINKER_OPTIONS) $(PLATFORM_CONSOLE_OPTION) -lm -lz -o $@ strip $(STRIP_OPTIONS) $@$(EXE_EXT) clean: rm -rf $(OBJ) rm -rf $(BIN) .PHONY: all</span></span></code> </pre><br>  Be careful!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not confuse tabs with spaces, in make tabs are allocated commands inside the build rule, and the space is not a syntax element. </font><font style="vertical-align: inherit;">Let's take a closer look at how it works. </font><font style="vertical-align: inherit;">The only more or less cerebral construct is the purpose of these variables:</font></font><br><br><pre> <code class="hljs mel">JAVA_FILES = $(shell cd $(JAVA_SOURCE_PATH); find . -name \*.java | awk <span class="hljs-string"><span class="hljs-string">'{ sub(/.\//,"") }; 1'</span></span>) JAVA_CLASSES := $(addprefix $(JAVA_CLASSPATH)/,$(addsuffix .class,$(<span class="hljs-keyword"><span class="hljs-keyword">basename</span></span> $(JAVA_FILES)))) CPP_FILES = $(shell cd $(CPP_SOURCE_PATH); find . -name \*.cpp | awk <span class="hljs-string"><span class="hljs-string">'{ sub(/.\//,"") }; 1'</span></span>) CPP_OBJECTS := $(addprefix $(OBJECTS)/,$(addsuffix .o,$(<span class="hljs-keyword"><span class="hljs-keyword">basename</span></span> $(CPP_FILES))))</code> </pre><br>     unix- find    <code>.java</code>   <code>$(JAVA_SOURCE_PATH)</code> .     .           <code>.class</code> ,     <code>$(JAVA_CLASSPATH)</code> ,      ,   , ..  .      <code>.cpp</code>  <code>.o</code> .   makefile     : <br><br><pre> <code class="hljs mel">$(JAVA_CLASSPATH)/%.class: $(JAVA_SOURCE_PATH)/%.java @echo $(PLATFORM_GENERAL_INCLUDES) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ ! -d <span class="hljs-string"><span class="hljs-string">"$(dir $@)"</span></span> ]; then mkdir -p <span class="hljs-string"><span class="hljs-string">"$(dir $@)"</span></span>; fi <span class="hljs-string"><span class="hljs-string">"$(JAVA_HOME)/bin/javac"</span></span> -sourcepath <span class="hljs-string"><span class="hljs-string">"$(JAVA_SOURCE_PATH)"</span></span> -classpath <span class="hljs-string"><span class="hljs-string">"$(JAVA_CLASSPATH)"</span></span> -d <span class="hljs-string"><span class="hljs-string">"$(JAVA_CLASSPATH)"</span></span> $&lt; $(OBJ)/%.o: $(SRC)/cpp/%.cpp @echo $(PLATFORM_GENERAL_INCLUDES) mkdir -p $(OBJ) g++ $(DEBUG_OPTIMIZE) -D_JNI_IMPLEMENTATION_ -c $(PLATFORM_GENERAL_INCLUDES) $&lt; -o $@</code> </pre><br>   ,      . , ,    <br><br><pre> <code class="hljs mel">$(BIN)/crossbase: $(JAVA_CLASSES) $(CPP_OBJECTS) ...</code> </pre><br>        .   makefile   ,    java  cpp ,     . <br><br>   : <br><br><ul><li> <code>-static-libgcc</code>  <code>-static-libstdc++</code>   mingw,         C  C++.                DLL. </li><li> <code>-mconsole</code>    Windows,      -  .    GUI-  . </li><li>  <code>-rdynamic</code>   gcc  Windows    . </li></ul><br><br>       ‚Äî <code>$(BIN)/crossbase: $(JAVA_CLASSES) $(CPP_OBJECTS)</code> .        libavian.a,      .  ,   .  Windows   -     (    ).     classpath.jar,        bin/java      bin/boot.jar.    binaryToObject,     boot.jar   obj/boot.jar.o   _binary_boot_jar_start  _binary_boot_jar_end (    main.o). , ,      . , ,    strip,   ,   ,  OS X,    ,   MinGW   Linux.   ‚Äî       .    crossbase   9 ,  ‚Äî  . <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. The moment of triumph </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Going into the crossbase / bin folder, we launch our crossbase from the console, passing parameters to it. </font></font><br><br><pre> <code class="hljs pgsql">&gt; ./crossbase  ! This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a crossplatform monolith application <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Java code inside. Freedom <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Java apps! args[<span class="hljs-number"><span class="hljs-number">0</span></span>] =  args[<span class="hljs-number"><span class="hljs-number">1</span></span>] = !</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project we got is </font></font><a href="http://github.com/bigfatbrowncat/crossbase"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on my GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Results and meaning </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's hard for me to appreciate the benefits of this article. If I at least get an invite for it, it will mean that she, at least, is not uninteresting. I can only say that with seeming complexity, this method pays off well compared to writing a program, say, in pure C ++. Java becomes very convenient when a project grows to at least a couple of dozen classes. Even if to be extremely careful when writing code in C ++, there are still loopholes for monstrously difficult to find errors. Therefore, I would advise everyone to write control code (not requiring super-performance) in Java. The code that requires maximum speed can be written in C ++, and then very easily and carefully wrapped the C ++ class with Java. Maybe I'll write how to make it beautiful and not run into a rake.</font></font><br><br>       ,     ¬´¬ª    SWT (,    Eclipse),   ,        .    ,    .  Thank you for attention! <br><br>  <em>PS</em> <br>     ,     .      . </div><p>Source: <a href="https://habr.com/ru/post/176237/">https://habr.com/ru/post/176237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176223/index.html">Job seeker vs employer: a fresh look at HR approaches</a></li>
<li><a href="../176227/index.html">NASA builds thermonuclear space engine</a></li>
<li><a href="../176229/index.html">D59 - the first Perm conference of software developers</a></li>
<li><a href="../176233/index.html">Lists from lambda functions</a></li>
<li><a href="../176235/index.html">Nokia Lumia 920 - Reverse</a></li>
<li><a href="../176239/index.html">Hyperlapse: Google Street View Review Service</a></li>
<li><a href="../176243/index.html">"National" programming languages</a></li>
<li><a href="../176245/index.html">COMAN: a very steady humanoid robot</a></li>
<li><a href="../176247/index.html">The world's smallest "laboratory" for DNA analysis</a></li>
<li><a href="../176249/index.html">Abstractness and open systems interaction model</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>