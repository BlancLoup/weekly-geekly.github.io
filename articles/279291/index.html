<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web applications offline. ServiceWorker and CacheStorage</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What are we talking about? 
 Increasingly, the task arises to teach the frontend application to work offline. This means giving a web application the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web applications offline. ServiceWorker and CacheStorage</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e8c/4df/605/e8c4df605ccd442e91ef667cf17cb64d.png" align="left"><h2>  What are we talking about? </h2><br>  Increasingly, the task arises to teach the frontend application to work offline.  This means giving a web application the property of a mobile or desktop program ‚Äî to function in the absence of an Internet connection, as well as in the event of server failure. <br><br>  The goal is to protect the user from connection problems on his device.  It would be a shame not to save the tables created in google docs due to the loss of wi-fi in the nearest fast food! <br><br>  To do this, you need to initialize the application in the browser and then cache the resources minimum necessary for operation.  After that, the application can be run from the cache in case of server unavailability. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The solution to the problem is as follows: <a name="habracut"></a><br><br><ol><li>  the first time you visit a web page, get ‚Äústatic‚Äù resources from the server in the form of html, css, js files, sprites, etc .; </li><li>  caching resources on the client side using browser tools; </li><li>  in the future, when requesting the same files, to issue them from the cache if there is no connection to the server; </li><li>  update modified cached resources. </li></ol><br>  There is already a wonderful <a href="https://habrahabr.ru/post/117123/">article</a> about this, but since then something has changed.  Earlier, ApplicationCache technology was popular, which you can read about <a href="https://habrahabr.ru/post/151815/">here</a> .  There were a number of problems with ApplicationCache, this technology lacked flexibility and is currently outdated and not recommended for use. <br><br>  Now CacheStorage is entering the arena, with which you can work in the ServiceWorker. <br><br><h2>  ServiceWorker </h2><br>  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers">ServiceWorker</a> is a new technology that allows you to run javascript code in the browser in the background - an analogue of services (services) in operating systems.  ServiceWorker runs from a web resource and continues to work in the browser, regardless of the application that initialized it. <br><br>  Often, the purpose of using ServiceWorker is to receive push notifications in the browser and control cached resources, the last is our case. <br><br><h2>  CacheStorage </h2><br>  <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage">CacheStorage</a> is a container for storing network resource caches.  The global CacheStorage object is available by the name of caches.  Its components are objects of type <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache</a> . <br><br>  Cache is a named store of pairs: the Request object is the Response object.  For each cached resource, the Cache instance will store the request and response created by the <a href="https://learn.javascript.ru/fetch">fetch</a> function. <br><br><h2>  How does it look in practice? </h2><br>  Now let's sort it all out on a small test application.  Assume that the files are located on the local server at <font color="#a33"><a href="http://localhost/test_serviceworker/">localhost / test_serviceworker</a></font> .  We set the tasks.  To manage caching, you must: <br><br><ol><li>  create a serviceWorker that will work in the browser, regardless of the presence / absence of access to the network; </li><li>  put in caches the resources to be cached; </li><li>  in the serviceWorker code, hang up the handler for the fetch event - an event that occurs when a network resource is requested; </li><li>  build in the handler logic for issuing and updating the cache. </li></ol><br>  To start ServiceWorker, you first need to register it.  In our application, you need to add the code as follows: <br><br>  <font color="#a33">workerLoader.js</font> <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     js-   serviceWorker' //  Promise  navigator.serviceWorker.register( '/test_serviceworker/appCache.js' ).then(function(registration) { //       ServiceWorkerRegistration console.log('ServiceWorker registration', registration); //      serviceWorker' //registration.unregister(); }).catch(function(err) { throw new Error('ServiceWorker error: ' + err); });</span></span></code> </pre> <br>  The next step is to write a simple ServiceWorker code. <br><br>  <font color="#a33">appCache.js</font> <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'install'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  console.log('install', event); }); self.addEventListener('activate', function(event) { //  console.log('activate', event); });</span></span></code> </pre><br>  It is important to keep in mind that serviceWorker is in no way associated with the global scope of the application in which it was registered, and does not have a window object at all.  In self, it has an object of type ServiceWorkerGlobalScope, on which event handlers are installed. <br><br>  After taking actions and updating the page in chrome at <font color="#a33">chrome: // inspect / # service-workers,</font> you can see something like this: <br><br><img src="https://habrastorage.org/files/00f/748/89b/00f74889bb6d43d0ab7c408f72511e5d.png"><br><br>  In this screenshot, three js files are running in the browser in the background, the first of which is the caching service of this example. <br><br>  Next, in the serviceWorker code, at the installation stage, we create the initial cache from the required resources. <br><br>  <font color="#a33">appCache.js</font> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      var CACHE_NAME = 'app_serviceworker_v_1', //     cacheUrls = [ '/test_serviceworker/', '/test_serviceworker/index.html', '/test_serviceworker/css/custom.css', '/test_serviceworker/images/icon.png', '/test_serviceworker/js/main.js' ]; self.addEventListener('install', function(event) { //    //   , serviceWorker   event.waitUntil( //     Cache-    //    ,     caches.open(CACHE_NAME).then(function(cache) { //    cache   return cache.addAll(cacheUrls); }) ); });</span></span></code> </pre><br>  Please note all links are relative to the root.  Also among the cached resources there is no file workerLoader.js, which registers the serviceWorker.  It is not desirable to cache it, since  in offline mode the application will work without it.  But if you urgently need to disable serviceWorker, problems may arise.  Users will have to wait until the serviceWorker updates itself (by comparing the content). <br><br>  Next, add the fetch event handler to the serviceWorker code.  And on the request of the resource we give it from the cache. <br><br>  <font color="#a33">appCache.js</font> <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( <span class="hljs-comment"><span class="hljs-comment">//       caches.match(event.request).then(function(cachedResponse) { //  ,    if (cachedResponse) { return cachedResponse; } //       return fetch(event.request); }) ); });</span></span></code> </pre><br><br>  But it's not always that simple.  Let's say our static files have changed on the server.  Let's complicate our code.  Check the date of the last resource update by pulling the last-modified parameter from the HTTP headers.  And if necessary, upload the latest version of the file and update the cache. <br><br>  <font color="#a33">appCache.js</font> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    -   var MAX_AGE = 86400000; self.addEventListener('fetch', function(event) { event.respondWith( //      caches.match(event.request).then(function(cachedResponse) { var lastModified, fetchRequest; //      if (cachedResponse) { //     lastModified = new Date(cachedResponse.headers.get('last-modified')); //       if (lastModified &amp;&amp; (Date.now() - lastModified.getTime()) &gt; MAX_AGE) { fetchRequest = event.request.clone(); //    return fetch(fetchRequest).then(function(response) { //         if (!response || response.status !== 200) { return cachedResponse; } //   caches.open(CACHE_NAME).then(function(cache) { cache.put(event.request, response.clone()); }); //    return response; }).catch(function() { return cachedResponse; }); } return cachedResponse; } //      return fetch(event.request); }) ); });</span></span></code> </pre><br>  Note, the request and response clones are used to re-request.  Only once it is possible to send a request and only once can it read the response.  Because of this limitation, we create copies of these objects. <br><br>  Similarly, the caching process can be controlled.  Now there is a clear advantage over appcache manifest in its declarative style.  The developer has the opportunity to operate HTTP headers, status codes, content and implement any logic for individual resources. <br><br><h2>  findings </h2><br><ul><li>  A significant plus is a flexible caching system.  What and when to cache is all in our hands (say goodbye to ApplicationCache!). </li><li>  You should not use this technique for ‚Äúnon-static‚Äù resources, i.e.  for data received from the server.  It is better to do this not in the service, but inside the front-application at the model level and use, for example, localStorage. </li><li>  There is such a nuance: serviceWorker is allowed to download only via HTTPS or from a local server.  An unpleasant restriction, but at the same time it is correct.  HTTPS is becoming the standard for popular services. </li><li>  The main drawback.  ServiceWorker and CacheStorage are both experimental technologies for the current time.  And there is support for modern Mozilla, Opera and Google browsers.  However, <a href="http://caniuse.com/">this is not enough</a> . </li></ul><br>  The theme of web applications offline has been around for a long time.  Perhaps ServiceWorker and CacheStorage is only a temporary solution.  However, it already makes sense to use.  Even if these technologies become obsolete, browser manufacturers will create something as a replacement.  One has only to follow the progress in this direction! <br><br>  The best materials for writing this article were: <br><br>  <a href="http://www.html5rocks.com/en/tutorials/service-worker/introduction/">http://www.html5rocks.com/en/tutorials/service-worker/introduction/</a> , <br>  <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers">https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers</a> .  Despite their presence, I decided to share information in Russian. </div><p>Source: <a href="https://habr.com/ru/post/279291/">https://habr.com/ru/post/279291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279281/index.html">Containerization mechanisms: namespaces</a></li>
<li><a href="../279283/index.html">What is Cisco ONE?</a></li>
<li><a href="../279285/index.html">Color Image Transfer using the Intel RealSense SDK</a></li>
<li><a href="../279287/index.html">How David Heinemeyer H√∂nsson organizes controllers</a></li>
<li><a href="../279289/index.html">The book "Android. Programming for professionals "</a></li>
<li><a href="../279293/index.html">Number written in Laravel 5</a></li>
<li><a href="../279295/index.html">How we wrote the code Netflix</a></li>
<li><a href="../279299/index.html">Dedicated servers and reviews about hosts</a></li>
<li><a href="../279307/index.html">Molecula - a new way to conduct group correspondence in Outlook</a></li>
<li><a href="../279309/index.html">Banking Android Trojan disguises as a Flash player and bypasses 2FA authentication</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>