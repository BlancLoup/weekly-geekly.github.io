<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architectural approaches in iOS applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about architectural approaches in iOS development, about some nuances and developments of the implementation of individual things. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Architectural approaches in iOS applications</h1><div class="post__text post__text-html js-mediator-article"><p>  Today we will talk about architectural approaches in iOS development, about some nuances and developments of the implementation of individual things.  I'll tell you what approaches we stick to and a little bit more detail. </p><a name="habracut"></a><br><p>  Immediately reveal all the cards.  We use MVVM-R (MVVM + Router). </p><br><p>  In fact, this is the usual MVVM, in which the navigation between the screens is placed in a separate layer - Router, and the logic of receiving data is in services.  Next, we consider our achievements in the implementation of each layer. </p><br><h2 id="pochemu-mvvm-a-ne-viper-ili-mvc">  Why MVVM, not VIPER or MVC? </h2><br><p>  Unlike MVC in MVVM, responsibility between the layers is quite divided.  It does not have as many "serving" code as in VIPER, although the ViewModel for screens is also closed by protocols.  This architecture is somewhat similar to VIPER, only Presenter and Interactor are combined into a ViewModel, and the connections between layers are simplified by the use of reactive programming and bindings (we use ReactiveSwift). </p><br><h2 id="entity">  Entity </h2><br><p>  We use two layers of data models: the first is tied to the database (hereinafter, <strong>managed objects</strong> ), the second is the so-called <strong>plain objects</strong> , which have nothing to do with the database. </p><br><p> Each plain entity implements the Translatable protocol, which can be initialized from a managed object, and from which you can create a managed object.  We use Realm as a database, in our case <code>ManagedObject</code> is <code>RealmSwift.Object</code> .  Mapping occurs through <code>Codable</code> : mapped as plain-objects and saved as managed-objects.  Further services and ViewModel work only with plain-objects. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Translatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">ManagedObject</span></span>: <span class="hljs-type"><span class="hljs-type">Object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(object: <span class="hljs-type"><span class="hljs-type">ManagedObject</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toManagedObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ManagedObject</span></span> }</code> </pre> <br><p>  To save, retrieve and delete objects from the database, a separate entity is used - Storage.  Since Storage is closed by protocol, we are independent of the implementation of a specific database and, if necessary, we can replace Realm with CoreData. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StorageProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedObjects</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byPrimaryKey key: AnyHashable)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objects: [T])</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object: T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objects: [T])</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object: T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAll</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ofType type: T.</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Type</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> }</code> </pre> <br><h3 id="kakie-plyusy-i-minusy-u-takogo-podhoda">  What are the pros and cons of this approach? </h3><br><p>  Each database has its own characteristics.  For example, a Realm object already saved to the database can only be used within the framework of the thread in which it was created.  This is a nuisance. </p><br><p>  Also, the object can be deleted from the database, while it lies in the RAM, and when it is accessed, it will crash.  Core Data has the same features.  Therefore, we retrieve objects from the database, convert them to plain objects and then work with them. </p><br><p>  With this approach, the code gets bigger and needs to be maintained.  Without dependence on database features, we lose the possibility of using steep chips.  In the case of CoreData, this is a FetchedResultsController, where we can control all inserts, deletions, changes within an array of entities.  About the same mechanism for Realm. </p><br><h2 id="core-components">  Core Components </h2><br><p>  Core components are entities that perform one of their tasks.  For example, mapping, interaction with the database, sending and processing network requests.  Storage from the previous item is just one of the core components. </p><br><h3 id="protocols">  Protocols </h3><br><p>  We actively use protocols.  All core components are closed by protocols, and there is an opportunity to make a mock or test implementation for unit tests.  Thus, we get a certain flexibility of implementation.  All dependencies are passed to init.  When initializing each object, we understand what dependencies are there, what it uses inside of itself. </p><br><h3 id="http-client">  HTTP Client </h3><br><p>  The network request is described by the <code>NetworkRequestParams</code> protocol. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkRequestParams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method: <span class="hljs-type"><span class="hljs-type">HTTPMethod</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameters: <span class="hljs-type"><span class="hljs-type">Parameters</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> encoding: <span class="hljs-type"><span class="hljs-type">ParameterEncoding</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headers: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultHeaders: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><p>  We use <code>enum</code> to describe network requests.  It looks like this: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserNetworkRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequestConvertible</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> update(userJson:[<span class="hljs-type"><span class="hljs-type">String</span></span> : <span class="hljs-type"><span class="hljs-type">Any</span></span>]) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserNetworkRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkRequestParams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .info: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/users/profile"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .update: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/users/update_profile"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method: <span class="hljs-type"><span class="hljs-type">HTTPMethod</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .info: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .update: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .post } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> encoding: <span class="hljs-type"><span class="hljs-type">ParameterEncoding</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .info: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">URLEncoding</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .update: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">JSONEncoding</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameters: <span class="hljs-type"><span class="hljs-type">Parameters</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .info: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [:] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .update(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userJson): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userJson } } }</code> </pre> <br><p>  Each <code>NetworkRouter</code> implements the <code>URLRequestConvertible</code> protocol.  We give it to the network client, which converts it to <code>URLRequest</code> and uses it for its intended purpose. </p><br><p>  The network client looks like this: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTTPClientProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: NetworkRequestParams &amp; URLRequestConvertible)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SignalProducer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Data</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt; }</code> </pre> <br><h3 id="mapper">  Mapper </h3><br><p>  We use <code>Codable</code> for data mapping. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapperProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">&lt;MappingResult: Codable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data, dateDecodingStrategy: JSONDecoder.DateDecodingStrategy)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SignalProducer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">MappingResult</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt; }</code> </pre> <br><h3 id="push---uvedomleniya">  Push Notifications </h3><br><p>  Each push-notification has a type and each type has its own handler.  The handler receives a dictionary with information from the notification.  Handlers are held by the aggregating entity, it is she who will receive the push and route it to the required handler.  This is a fairly scalable approach that is convenient to work with if you need to handle several types of push notifications in different ways. </p><br><h2 id="servisy">  Services </h2><br><p>  Roughly speaking, one service is responsible for one entity.  Consider this on the example of a social network application.  There is a server of the user who receives the user - himself, and gives the changed entities, if we edited it.  There is a post service that receives a list of posts, a detailed post, a payment service, etc.  etc. </p><br><p>  All services contain core components.  When we call a method on a service, it starts pulling various methods of core components and eventually gives the result out. </p><br><p>  The service, as a rule, performs work for a specific screen, or rather, for the view model of the screen (more on this below).  If, when leaving the screen, the service is not destroyed, but will continue to perform an already unnecessary network request and will slow down other requests.  This can be controlled manually, but it will be more difficult to maintain such a system.  However, this approach has a minus: if the result of the service is needed even after we left the screen, you will have to look for other solutions, perhaps making some services a singleton. </p><br><p>  Services do not contain a state.  Since services are not singletons, we may have several instances of the same service, in which the states may differ from each other.  This may lead to incorrect behavior. </p><br><p>  An example of the method of one of the services: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currentUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SignalProducer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">User</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">UserNetworkRouter</span></span>.info <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> httpClient.load(request: request) .flatMap(.latest, mapUser) .flatMap(.latest, save) }</code> </pre> <br><h2 id="viewmodel">  Viewmodel </h2><br><p>  We will divide the ViewModel into 2 types: </p><br><ul><li>  ViewModel for the screen (ViewController) </li><li>  ViewModel for UIView (including for table cells or UICollectionView) </li></ul><br><p>  ViewModel for ViewController is responsible for the logic of the screen.  As a rule, it is sending network requests, preparing data, responding to UI events. </p><br><p>  ViewModel prepares all the data for the view that came from the service.  If the list of entities has arrived, the ViewModel transforms it into a ViewModel list and binds it to the view.  If there are states (there is a check mark / no check mark), this is also controlled and transmitted to the ViewModel. </p><br><p>  Also ViewModel controls the navigation logic.  There is a separate Router layer for navigation, but the ViewModel gives the commands. </p><br><p>  Typical functions of the view-model: get the user, contact the user service, make the ViewModel from the obtained value.  When everything loads, View takes the ViewModel and draws the view cell. </p><br><p>  ViewModel for the screen is closed by the protocol for the same reasons as services.  However, there is another interesting case: for example, a banking application, where every action (transfer of funds, opening an account, blocking an account) is confirmed by SMS.  On the confirmation screen there is a code entry field and a ‚Äúsend again‚Äù button. </p><br><p>  ViewModel is closed by this protocol: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodeInputViewModelProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">///    func send(code: String) -&gt; SignalProducer&lt;Void, Error&gt; ///    func resendCode() -&gt; SignalProducer&lt;Void, Error&gt; }</span></span></code> </pre> <br><p>  In ViewController, it is stored in this form: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewModel: <span class="hljs-type"><span class="hljs-type">CodeInputViewModelProtocol?</span></span></code> </pre> <br><p>  Depending on what exactly we are trying to confirm by SMS, sending the code and re-sending SMS can be represented by completely different requests, and after confirmation, transitions to different screens are needed, etc.  Since the ViewController doesn‚Äôt matter what kind of ViewModel actually has, we can have several ViewModel implementations for different cases, and the UI will be common. </p><br><p>  ViewModel for View and cells, as a rule, is engaged in formatting data and processing user input.  For example, the storage state is "selected / not selected." </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedCellViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url: <span class="hljs-type"><span class="hljs-type">URL?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subtitle: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(feed: <span class="hljs-type"><span class="hljs-type">FeedItem</span></span>) { url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: feed.imageUrl) title = feed.title subtitle = <span class="hljs-type"><span class="hljs-type">DateFormatter</span></span>.feed.string(from feed.publishDate) } }</code> </pre> <br><h2 id="navigaciya">  Navigation </h2><br><p>  Transitions between screens are performed by the Router. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(sourceViewController: <span class="hljs-type"><span class="hljs-type">UIViewController</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.sourceViewController = sourceViewController } <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourceViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> }</code> </pre> <br><p>  Each screen has its own router, which is inherited from the base.  It has methods for navigating to specific screens. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedRouter</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: FeedDetailViewModelProtocol)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">FeedDetailViewController</span></span>() vc.viewModel = viewModel sourceViewController?.navigationController?.pushViewController(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } }</code> </pre> <br><p>  As can be seen from the example above, the assembly of the ‚Äúmodule‚Äù takes place in a router.  This is formally contrary to the letter S of SOLID, but in practice it is rather convenient and does not cause problems. </p><br><p>  There are cases when the same method is needed in different routers.  In order not to write it several times, we create a protocol in which there will be general methods, and implement an <code>extension</code> to it.  Now it is enough to sign the necessary router for this protocol, and it will have the necessary methods. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedRouterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: FeedDetailViewModelProtocol)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedRouterProtocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: FeedDetailViewModelProtocol)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">FeedDetailViewController</span></span>() vc.viewModel = viewModel sourceViewController?.navigationController?.pushViewController(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } }</code> </pre> <br><h2 id="view">  View </h2><br><p>  View is traditionally responsible for displaying information for the user and processing user actions.  In MVVM, we consider the ViewController to be a View.  It is important that there is no complicated logic, which is the place in the ViewModel.  In any case, even in MVC, you shouldn‚Äôt load ViewController too much, although it‚Äôs hard to do. </p><br><p>  View commands a ViewModel.  If ViewController is loaded, we give the ViewModel command: load data from the network or from the cache.  View also accepts signals from ViewModel.  If the ViewModel says that something has changed (for example, the same data was loaded), then View responds to it and redraws. </p><br><p>  We do not use storyboards.  Navigation is strongly tied to the ViewController, and it is hard to fit into the architecture.  In storyboards, conflicts often arise, which is a separate ‚Äúpleasure‚Äù to rule. </p><br><h2 id="chto-delat-dalshe">  What to do next? </h2><br><p>  You can use code generation for models (Translatable), since all initialization from a database object to a plane object and vice versa is now written manually. </p><br><p>  You can also use a more universal query scheme, since many methods of services look like this: go online, apply mapping, save to database.  This, too, can be universalized, set a common skeleton. </p><br><p>  We have examined the architectural approaches, but do not forget that a quality application is not only architecture, but also a smooth, responsive, user-friendly interface.  Love your users and write quality applications. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/458590/">https://habr.com/ru/post/458590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458576/index.html">Text management and localization in a web application</a></li>
<li><a href="../45858/index.html">Drawbacks i.mail</a></li>
<li><a href="../458582/index.html">Amazon engineer created an interlocking device with AI, which does not allow a cat with street loot into the house</a></li>
<li><a href="../458584/index.html">Group-IB Webinar July 11, Malware Analysis for Beginners: Basic Approaches</a></li>
<li><a href="../45859/index.html">Mobius transformations - a visual explanation (video)</a></li>
<li><a href="../458594/index.html">Do not forget to increase the chance of response to the client, using a second request in L7 balancing</a></li>
<li><a href="../4586/index.html">"Soup" explains its policy</a></li>
<li><a href="../45860/index.html">Website creation in Veliky Novgorod and other provincial cities</a></li>
<li><a href="../458604/index.html">Why the two largest electronics manufacturers joined forces in a new GPU project</a></li>
<li><a href="../458606/index.html">Run OpenVPN in Docker in 2 seconds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>