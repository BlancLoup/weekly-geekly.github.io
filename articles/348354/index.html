<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How ZFS Stores Data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zfs is a fairly popular file system for long-term data storage. In addition, it ensures the integrity of the recorded data, keeping together with the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How ZFS Stores Data</h1><div class="post__text post__text-html js-mediator-article">  Zfs is a fairly popular file system for long-term data storage.  In addition, it ensures the integrity of the recorded data, keeping together with the data and their checksums.  The mechanism of checksums allows you to identify, and in the presence of redundancy to recover, damaged data. <br><br>  In this article, a practical example analyzes how and where zfs saves data. <br><br>  Directly for data access, we will not use the zdb utility, but try using radare2 to look directly at the bytes that are written on the disk. <br><a name="habracut"></a><br><h2>  About zfs </h2><br>  Zfs (Zettabyte File System) is a COW (copy on write) file system created by Sun for the Solaris operating system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the main advantages of this file system is the use of checksums not only for metadata but also for user data. <br><br><h2>  Zfs disk structure </h2><br>  For a more detailed analysis of zfs components, it is recommended to refer to the official ZFS On-Disk Specification documentation from Sun. <br><br><h3>  Virtual devices </h3><br>  The zfs pool consists of virtual devices (hereinafter referred to as vdev).  We do not need more detailed information now, so we go further.  We don‚Äôt need more detailed information right now, so we‚Äôre going to go further; we‚Äôll just note that vdev has two types of logical and physical virtual devices. <br><br><h4>  Tag </h4><br>  Four physical labels are stored on each physical virtual device (in Figure L0, L1, L2, and L3). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d4/44c/2dd/3d444c2ddb79501fac9353fe7e1c5739.jpg" alt="Tag"><br><br><h4>  Boot block </h4><br>  Immediately after the L0 and L1 tags, 3.5 MB of space is allocated for future use. <br><br><h2>  Uberblock reference point </h2><br>  Unlike other zfs objects, the position of the labels is strictly fixed and updated in two steps; first, the labels L0 and L2 are updated, then L1 and L3.  For this article, of the data recorded in the label, we will be interested only in uberblock, consider it in more detail. <br><br><h3>  Uberblock </h3><br>  Uberblock is represented by the following structure: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uberblock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ub_magic; <span class="hljs-comment"><span class="hljs-comment">/* UBERBLOCK_MAGIC */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ub_version; <span class="hljs-comment"><span class="hljs-comment">/* SPA_VERSION */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ub_txg; <span class="hljs-comment"><span class="hljs-comment">/* txg of last sync */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ub_guid_sum; <span class="hljs-comment"><span class="hljs-comment">/* sum of all vdev guids */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ub_timestamp; <span class="hljs-comment"><span class="hljs-comment">/* UTC time of last sync */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span> ub_rootbp; <span class="hljs-comment"><span class="hljs-comment">/* MOS objset_phys_t */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* highest SPA_VERSION supported by software that wrote this txg */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ub_software_version; };</code> </pre> <br>  We describe some fields: <br><br>  <b>ub_txg</b> <br>  Transaction number <br>  <b>ub_timestamp</b> <br>  Contains uberblock write time (in UTC format) <br>  <b>ub_rootbp</b> <br>  The link to the Meta Object Set (In zfs, the links to the blocks are represented by the blkptr_t structure, which will be described below). <br><br><h3>  Links to blocks (blkptr_t) </h3><br>  References to blocks represent the following structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blkptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dva_t</span></span> blk_dva[SPA_DVAS_PER_BP]; <span class="hljs-comment"><span class="hljs-comment">/* Data Virtual Addresses */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> blk_prop; <span class="hljs-comment"><span class="hljs-comment">/* size, compression, type, etc */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> blk_pad[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* Extra space for the future */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> blk_phys_birth; <span class="hljs-comment"><span class="hljs-comment">/* txg when block was allocated */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> blk_birth; <span class="hljs-comment"><span class="hljs-comment">/* transaction group at birth */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> blk_fill; <span class="hljs-comment"><span class="hljs-comment">/* fill count */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">zio_cksum_t</span></span> blk_cksum; <span class="hljs-comment"><span class="hljs-comment">/* 256-bit checksum */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* * All SPA data is represented by 128-bit data virtual addresses (DVAs). * The members of the dva_t should be considered opaque outside the SPA. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dva</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> dva_word[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">dva_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* * Each block has a 256-bit checksum -- strong enough for cryptographic hashes. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zio_cksum</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> zc_word[<span class="hljs-number"><span class="hljs-number">4</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">zio_cksum_t</span></span>;</code> </pre><br>  If we represent in the form of an array of bytes, then we get the following image <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d37/d41/221/d37d412216c99235b6564a5f7db7c747.jpg" alt="image"><br><br>  The most important fields <br>  <b>dva_t</b> <br>  Virtual address data.  The offset field stores the sector offset (512 bytes). <br>  In the image above, these are lines 0 ~ 5. <br>  <b>blk_prop</b> <br>  Type, size, level of indirection of the block, etc. <br>  type converts to dmu_object_type.  And the cksum and comp fields in zio_checksum and zio_compress respectively. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> dmu_object_type { DMU_OT_NONE, <span class="hljs-comment"><span class="hljs-comment">/* general: */</span></span> DMU_OT_OBJECT_DIRECTORY, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_OBJECT_ARRAY, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> DMU_OT_PACKED_NVLIST, <span class="hljs-comment"><span class="hljs-comment">/* UINT8 (XDR by nvlist_pack/unpack) */</span></span> DMU_OT_PACKED_NVLIST_SIZE, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> DMU_OT_BPOBJ, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> DMU_OT_BPOBJ_HDR, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* spa: */</span></span> DMU_OT_SPACE_MAP_HEADER, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> DMU_OT_SPACE_MAP, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* zil: */</span></span> DMU_OT_INTENT_LOG, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* dmu: */</span></span> DMU_OT_DNODE, <span class="hljs-comment"><span class="hljs-comment">/* DNODE */</span></span> DMU_OT_OBJSET, <span class="hljs-comment"><span class="hljs-comment">/* OBJSET */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* dsl: */</span></span> DMU_OT_DSL_DIR, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> DMU_OT_DSL_DIR_CHILD_MAP, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_DSL_DS_SNAP_MAP, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_DSL_PROPS, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_DSL_DATASET, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* zpl: */</span></span> DMU_OT_ZNODE, <span class="hljs-comment"><span class="hljs-comment">/* ZNODE */</span></span> DMU_OT_OLDACL, <span class="hljs-comment"><span class="hljs-comment">/* Old ACL */</span></span> DMU_OT_PLAIN_FILE_CONTENTS, <span class="hljs-comment"><span class="hljs-comment">/* UINT8 */</span></span> DMU_OT_DIRECTORY_CONTENTS, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_MASTER_NODE, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_UNLINKED_SET, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* zvol: */</span></span> DMU_OT_ZVOL, <span class="hljs-comment"><span class="hljs-comment">/* UINT8 */</span></span> DMU_OT_ZVOL_PROP, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* other; for testing only! */</span></span> DMU_OT_PLAIN_OTHER, <span class="hljs-comment"><span class="hljs-comment">/* UINT8 */</span></span> DMU_OT_UINT64_OTHER, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> DMU_OT_ZAP_OTHER, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* new object types: */</span></span> DMU_OT_ERROR_LOG, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_SPA_HISTORY, <span class="hljs-comment"><span class="hljs-comment">/* UINT8 */</span></span> DMU_OT_SPA_HISTORY_OFFSETS, <span class="hljs-comment"><span class="hljs-comment">/* spa_his_phys_t */</span></span> DMU_OT_POOL_PROPS, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_DSL_PERMS, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_ACL, <span class="hljs-comment"><span class="hljs-comment">/* ACL */</span></span> DMU_OT_SYSACL, <span class="hljs-comment"><span class="hljs-comment">/* SYSACL */</span></span> DMU_OT_FUID, <span class="hljs-comment"><span class="hljs-comment">/* FUID table (Packed NVLIST UINT8) */</span></span> DMU_OT_FUID_SIZE, <span class="hljs-comment"><span class="hljs-comment">/* FUID table size UINT64 */</span></span> DMU_OT_NEXT_CLONES, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_SCAN_QUEUE, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_USERGROUP_USED, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_USERGROUP_QUOTA, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_USERREFS, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_DDT_ZAP, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_DDT_STATS, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_SA, <span class="hljs-comment"><span class="hljs-comment">/* System attr */</span></span> DMU_OT_SA_MASTER_NODE, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_SA_ATTR_REGISTRATION, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_SA_ATTR_LAYOUTS, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_SCAN_XLATE, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_DEDUP, <span class="hljs-comment"><span class="hljs-comment">/* fake dedup BP from ddt_bp_create() */</span></span> DMU_OT_DEADLIST, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_DEADLIST_HDR, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> DMU_OT_DSL_CLONES, <span class="hljs-comment"><span class="hljs-comment">/* ZAP */</span></span> DMU_OT_BPOBJ_SUBOBJ, <span class="hljs-comment"><span class="hljs-comment">/* UINT64 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* * Do not allocate new object types here. Doing so makes the on-disk * format incompatible with any other format that uses the same object * type number. * * When creating an object which does not have one of the above types * use the DMU_OTN_* type with the correct byteswap and metadata * values. * * The DMU_OTN_* types do not have entries in the dmu_ot table, * use the DMU_OT_IS_METDATA() and DMU_OT_BYTESWAP() macros instead * of indexing into dmu_ot directly (this works for both DMU_OT_* types * and DMU_OTN_* types). */</span></span> DMU_OT_NUMTYPES, <span class="hljs-comment"><span class="hljs-comment">/* * Names for valid types declared with DMU_OT(). */</span></span> DMU_OTN_UINT8_DATA = DMU_OT(DMU_BSWAP_UINT8, B_FALSE), DMU_OTN_UINT8_METADATA = DMU_OT(DMU_BSWAP_UINT8, B_TRUE), DMU_OTN_UINT16_DATA = DMU_OT(DMU_BSWAP_UINT16, B_FALSE), DMU_OTN_UINT16_METADATA = DMU_OT(DMU_BSWAP_UINT16, B_TRUE), DMU_OTN_UINT32_DATA = DMU_OT(DMU_BSWAP_UINT32, B_FALSE), DMU_OTN_UINT32_METADATA = DMU_OT(DMU_BSWAP_UINT32, B_TRUE), DMU_OTN_UINT64_DATA = DMU_OT(DMU_BSWAP_UINT64, B_FALSE), DMU_OTN_UINT64_METADATA = DMU_OT(DMU_BSWAP_UINT64, B_TRUE), DMU_OTN_ZAP_DATA = DMU_OT(DMU_BSWAP_ZAP, B_FALSE), DMU_OTN_ZAP_METADATA = DMU_OT(DMU_BSWAP_ZAP, B_TRUE), } <span class="hljs-keyword"><span class="hljs-keyword">dmu_object_type_t</span></span>;</code> </pre><br>  The zio_checksum and zio_compress listings are shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> zio_checksum { ZIO_CHECKSUM_INHERIT = <span class="hljs-number"><span class="hljs-number">0</span></span>, ZIO_CHECKSUM_ON, ZIO_CHECKSUM_OFF, ZIO_CHECKSUM_LABEL, ZIO_CHECKSUM_GANG_HEADER, ZIO_CHECKSUM_ZILOG, ZIO_CHECKSUM_FLETCHER_2, ZIO_CHECKSUM_FLETCHER_4, ZIO_CHECKSUM_SHA256, ZIO_CHECKSUM_ZILOG2, ZIO_CHECKSUM_FUNCTIONS };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> zio_compress { ZIO_COMPRESS_INHERIT = <span class="hljs-number"><span class="hljs-number">0</span></span>, ZIO_COMPRESS_ON, ZIO_COMPRESS_OFF, ZIO_COMPRESS_LZJB, ZIO_COMPRESS_EMPTY, ZIO_COMPRESS_GZIP_1, ZIO_COMPRESS_GZIP_2, ZIO_COMPRESS_GZIP_3, ZIO_COMPRESS_GZIP_4, ZIO_COMPRESS_GZIP_5, ZIO_COMPRESS_GZIP_6, ZIO_COMPRESS_GZIP_7, ZIO_COMPRESS_GZIP_8, ZIO_COMPRESS_GZIP_9, ZIO_COMPRESS_ZLE, ZIO_COMPRESS_LZ4, ZIO_COMPRESS_FUNCTIONS };</code> </pre><br><h3>  Object (dnode) </h3><br>  Excluding uberblock, all other entities (metadata and user data) are represented as objects.  The dmu_object_type enumeration lists the possible types of objects. <br><br>  The object is described by the dnode_phys structure presented below: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dnode_phys</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_type; <span class="hljs-comment"><span class="hljs-comment">/* dmu_object_type_t */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_indblkshift; <span class="hljs-comment"><span class="hljs-comment">/* ln2(indirect block size) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_nlevels; <span class="hljs-comment"><span class="hljs-comment">/* 1=dn_blkptr-&gt;data blocks */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_nblkptr; <span class="hljs-comment"><span class="hljs-comment">/* length of dn_blkptr */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_bonustype; <span class="hljs-comment"><span class="hljs-comment">/* type of data in bonus buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_checksum; <span class="hljs-comment"><span class="hljs-comment">/* ZIO_CHECKSUM type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_compress; <span class="hljs-comment"><span class="hljs-comment">/* ZIO_COMPRESS type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_flags; <span class="hljs-comment"><span class="hljs-comment">/* DNODE_FLAG_* */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> dn_datablkszsec; <span class="hljs-comment"><span class="hljs-comment">/* data block size in 512b sectors */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> dn_bonuslen; <span class="hljs-comment"><span class="hljs-comment">/* length of dn_bonus */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_pad2[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* accounting is protected by dn_dirty_mtx */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> dn_maxblkid; <span class="hljs-comment"><span class="hljs-comment">/* largest allocated block ID */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> dn_used; <span class="hljs-comment"><span class="hljs-comment">/* bytes (or sectors) of disk space */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> dn_pad3[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span> dn_blkptr[<span class="hljs-number"><span class="hljs-number">1</span></span>+DN_MAX_BONUSLEN/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span>)]; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span> __dn_ignore1; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dn_bonus[DN_MAX_BONUSLEN]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span> __dn_ignore2; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> __dn_ignore3[DN_MAX_BONUSLEN-<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span>)]; <span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span> dn_spill; }; }; } <span class="hljs-keyword"><span class="hljs-keyword">dnode_phys_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zil_header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> zh_claim_txg; <span class="hljs-comment"><span class="hljs-comment">/* txg in which log blocks were claimed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> zh_replay_seq; <span class="hljs-comment"><span class="hljs-comment">/* highest replayed sequence number */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span> zh_log; <span class="hljs-comment"><span class="hljs-comment">/* log chain */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> zh_claim_blk_seq; <span class="hljs-comment"><span class="hljs-comment">/* highest claimed block sequence number */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> zh_flags; <span class="hljs-comment"><span class="hljs-comment">/* header flags */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> zh_claim_lr_seq; <span class="hljs-comment"><span class="hljs-comment">/* highest claimed lr sequence number */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> zh_pad[<span class="hljs-number"><span class="hljs-number">3</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">zil_header_t</span></span>;</code> </pre><br><h3>  Set of objects </h3><br>  Zfs objects can be grouped into so-called object sets (objset), and are represented by the following types: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> dmu_objset_type { DMU_OST_NONE, DMU_OST_META, <span class="hljs-comment"><span class="hljs-comment">/* MOS */</span></span> DMU_OST_ZFS, <span class="hljs-comment"><span class="hljs-comment">/* Dataset DMU_OST_ZVOL, /*   zfs (vol) DMU_OST_OTHER, /* For testing only! */</span></span> DMU_OST_ANY, <span class="hljs-comment"><span class="hljs-comment">/* Be careful! */</span></span> DMU_OST_NUMTYPES } <span class="hljs-keyword"><span class="hljs-keyword">dmu_objset_type_t</span></span>;</code> </pre><br>  The set of objects itself is represented by such a 2-kilobyte structure: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">objset_phys</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dnode_phys_t</span></span> os_meta_dnode; <span class="hljs-keyword"><span class="hljs-keyword">zil_header_t</span></span> os_zil_header; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> os_type; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> os_flags; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> os_pad[OBJSET_PHYS_SIZE - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">dnode_phys_t</span></span>)*<span class="hljs-number"><span class="hljs-number">3</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">zil_header_t</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>)*<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">dnode_phys_t</span></span> os_userused_dnode; <span class="hljs-keyword"><span class="hljs-keyword">dnode_phys_t</span></span> os_groupused_dnode; } <span class="hljs-keyword"><span class="hljs-keyword">objset_phys_t</span></span>;</code> </pre><br><h2>  We look at bytes </h2><br>  In this article we will use a test pool based on a 101-megabyte file. <br>  Why just 101 MB?  The fact is that zfs breaks up free space (minus 4x 256KB tags and 3.5 megabyte boot-block) into fixed blocks (see <a href="https://habrahabr.ru/post/160943/">How ZFS works - part 1: vdev</a> ).  For a 100MB disk, the block size is 16MB and for a 100MB disk such blocks fit only 5 and the available capacity will be 80Mb.  But for 101MB of such blocks 6 are already accommodated and the available volume increases to 96MB.  Although this article is not so important.  But for example, for a 4Tb disk, if you completely give it to zfs, then we get a ‚Äúlost‚Äù space larger than 13GB. <br><br>  The 3725 ‚Äúbinary‚Äù GBs are divided into blocks of 16GB each, and the remainder of 13GB is not used. <br><br><h3>  Create a test pool </h3><br> <code># dd if=/dev/zero of=/tmp/test_disk bs=1M count=101 <br> 101+0   <br> 101+0   <br> 105906176  (106 MB, 101 MiB) , 0,0847695 s, 1,2 GB/s <br> <br> #zpool create test -o ashift=9 /tmp/test_disk <br></code> <br>  Set recordsize to 512 bytes and add a couple of files. <br><br> <code># zfs set recordsize=512 test <br> <br> # dd if=/dev/urandom of=/test/0B bs=1 count=0 <br> 0+0   <br> 0+0   <br> 0  , 0,000171206 s, 0,0 kB/s <br> # dd if=/dev/urandom of=/test/512B bs=512 count=1 <br> 1+0   <br> 1+0   <br> 512  , 0,000215428 s, 2,4 MB/s <br> # dd if=/dev/urandom of=/test/513B bs=513 count=1 <br> 1+0   <br> 1+0   <br> 513  , 0,00022484 s, 2,3 MB/s <br></code> <br><br>  Let's see how much space files occupy on disk. <br><br> <code># du -a --block-size=1 <br> 1024 ./512B <br> 512 ./0B <br> 2560 ./513B <br></code> <br>  From the interesting thing, it is striking that a zero-size file is 512 bytes (compare with ext3 where it has a size of zero bytes).  A file of 513 bytes in size does not occupy 1,536 bytes but as much as 2,560 bytes, although it would seem that the recordsize plus the service information would have taken the place equal to twice the size.  Let's see why this happens. <br><br><h4>  Find the active uberblock </h4><br>  To access the raw data, we will use the radare2 utility. <br>  Sort by transaction number. <br><br> <code># r2 /tmp/test_disk <br> [0x00000000]&gt; pf q @@s:0x20010 0x40000 0x400|sort -k2 <br> 0x00020010 = (qword)0x0000000000000000 <br> ‚Ä¶ <br> 0x00028010 = (qword)0x0000000000000020 <br> 0x00028810 = (qword)0x0000000000000022 <br> 0x00028c10 = (qword)0x0000000000000023 <br> 0x0002e010 = (qword)0x0000000000000038 <br></code> <br>  The active uberblock is located at 0x0002e000 (we subtract 16 bytes from the found offset 0x0002e010). <br><br>  <b>Read uberblock completely</b> <br> <code>[0x0003fc10]&gt; 0x0002e000 <br> [0x0002e000]&gt; pf qqqqt:[128].q ub_magic ub_version ub_txg ub_guid_sum ub_timestamp ub_software_version <br> ub_magic : 0x0002e000 = (qword)0x0000000000bab10c <br> ub_version : 0x0002e008 = (qword)0x0000000000001388 <br> ub_txg : 0x0002e010 = (qword)0x0000000000000038 <br> ub_guid_sum : 0x0002e018 = (qword)0x667c11fc34e97151 <br> ub_timestamp : 0x0002e020 = Wed Jan 31 07:29:56 2018 <br> ub_software_version : 0x0002e0a8 = (qword)0x0000000000001388 <br></code> <br><br>  <b>We get ub_rootbp</b> <br> <code>[0x0002e000]&gt; s+0x28 <br> [0x0002e028]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x0002e028 = (qword)[ 0x0000000000000001, 0x00000000000000ab ] <br> blk_dva_1 : 0x0002e038 = (qword)[ 0x0000000000000001, 0x00000000000000bc ] <br> blk_dva_2 : 0x0002e048 = (qword)[ 0x0000000000000001, 0x00000000000000bd ] <br> blk_prop : 0x0002e058 = (qword)0x800b070f00000003 <br> blk_pad[2] : 0x0002e060 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x0002e070 = (qword)0x0000000000000000 <br> blk_birth : 0x0002e078 = (qword)0x0000000000000038 <br> blk_fill : 0x0002e080 = (qword)0x0000000000000023 <br> blk_cksum : 0x0002e088 = (qword)[ 0x0000000d43174e30, 0x00000513bae6359f, 0x0000ff222817dfe3, 0x00223eedae162ece ] <br></code> <br>  To parse blkptr parameters (blk_prop) I use MS Excell <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99f/993/0bf/99f9930bf4dcd20e6bb3ccbcb1f2d370.jpg" alt="image"><br><br>  Judging by the comp (= 15) value, the block is compressed by lz4 and occupies 512 bytes on the disk (PSIZE indicates the number of sectors) and after unpacking it should become 2048 bytes (LSIZE). <br><br>  <b>Save block to file</b> <br>  Calculate the offset from the beginning of the disc.  To do this, the value of the blk_dva [0] .dva_word [1] field (= 0x00000000000000ab) from the blkptr structure is multiplied by 512 (sector size) and add 0x400000 (4MB - L0, L1 tags and the boot block).  The result is divided into 512 (we work in blocks of 512 bytes). <br><br> <code>[0x0002e028]&gt; ?v 0x00000000000000ab&lt;9+0x400000 <br> 0x415600 <br> [0x0002e028]&gt; ? 0x415600/512 <br> 8363 0x20ab 020253 8.2K 0000:00ab 8363 "\xab " 0b0010000010101011 8363.0 8363.000000f 8363.000000 0t102110202 <br> <br> # dd if=/tmp/test_disk bs=512 skip=8363 count=1 of=/tmp/mos.objset.bin.lz4 <br></code> <br><br>  For unpacking use a small program (source at the end of the article). <br><br> <code># zdec mos.objset.bin.lz4 mos.objset.bin 2048 <br> Input: mos.objset.bin.lz4 <br> Output: mos.objset.bin <br> Out size: 2048 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 187 <br> Decompress result: 0 <br></code> <br><br>  Let's see what is stored in the MOS object. <br><br> <code># r2 mos.objset.bin <br> [0x00000000]&gt; pf [512].[192].qq[304].[512].[512]. os_type os_flags <br> os_type : 0x000002c0 = (qword)0x0000000000000001 <br> os_flags : 0x000002c8 = (qword)0x0000000000000000 <br> [0x00000000]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000000 = 0x0a <br> dn_indblkshift : 0x00000001 = 0x0e <br> dn_nlevels : 0x00000002 = 0x01 <br> dn_nblkptr : 0x00000003 = 0x03 <br> dn_bonustype : 0x00000004 = 0x00 <br> dn_checksum : 0x00000005 = 0x00 <br> dn_compress : 0x00000006 = 0x00 <br> dn_flags : 0x00000007 = 0x01 <br> dn_datablkszsec : 0x00000008 = 0x0020 <br> dn_bonuslen : 0x0000000a = 0x0000 <br> dn_pad2[4] : 0x0000000c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000010 = (qword)0x0000000000000001 <br> dn_used : 0x00000018 = (qword)0x0000000000001e00 <br> dn_pad3[4] : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br>  Read the blkptr array (the beginning of the array with offset + 0x40).  Blkptr structure size 128 bytes (offset + 0x80) <br><br> <code>[0x00000000]&gt; s+0x40 <br> [0x00000040]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000040 = (qword)[ 0x0000000000000004, 0x00000000000000fd ] <br> blk_dva_1 : 0x00000050 = (qword)[ 0x0000000000000004, 0x0000000000000014 ] <br> blk_dva_2 : 0x00000060 = (qword)[ 0x0000000000000004, 0x0000000000000018 ] <br> blk_prop : 0x00000070 = (qword)0x800a070f0003001f <br> blk_pad[2] : 0x00000078 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000088 = (qword)0x0000000000000000 <br> blk_birth : 0x00000090 = (qword)0x0000000000000038 <br> blk_fill : 0x00000098 = (qword)0x000000000000001f <br> blk_cksum : 0x000000a0 = (qword)[ 0x0000005b728c5143, 0x00006add456a9057, 0x0046f84e9ebc9fc1, 0x227baf4ccb8d8253 ] <br> [0x00000040]&gt; s+0x80 <br> [0x000000c0]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x000000c0 = (qword)[ 0x0000000000000001, 0x00000000000000c7 ] <br> blk_dva_1 : 0x000000d0 = (qword)[ 0x0000000000000001, 0x00000000000000c8 ] <br> blk_dva_2 : 0x000000e0 = (qword)[ 0x0000000000000001, 0x00000000000000f9 ] <br> blk_prop : 0x000000f0 = (qword)0x800a070f0000001f <br> blk_pad[2] : 0x000000f8 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000108 = (qword)0x0000000000000000 <br> blk_birth : 0x00000110 = (qword)0x0000000000000038 <br> blk_fill : 0x00000118 = (qword)0x0000000000000004 <br> blk_cksum : 0x00000120 = (qword)[ 0x000000212e3f6320, 0x000007421d158d58, 0x00012cb9dd4a54c3, 0x0026ea30b4caddc5 ] <br> [0x000000c0]&gt; s+0x80 <br> [0x00000140]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000140 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_1 : 0x00000150 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_2 : 0x00000160 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000170 = (qword)0x0000000000000000 <br> blk_pad[2] : 0x00000178 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000188 = (qword)0x0000000000000000 <br> blk_birth : 0x00000190 = (qword)0x0000000000000000 <br> blk_fill : 0x00000198 = (qword)0x0000000000000000 <br> blk_cksum : 0x000001a0 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/c2e/3d2/d2f/c2e3d2d2ffcbf6aa3068bc6d1271bc16.jpg" alt="image"><br><br>  The blocks are compressed with the lz4 algorithm and are 2048 bytes in size and 512 bytes, respectively (and the actual size is 16384 bytes). <br><br>  <b>Save to file and unpack</b> <br> <code># dd if=/tmp/test_disk bs=512 skip=8445 count=4 of=/tmp/dsl.dnode.0.bin.lz4 <br> # dd if=/tmp/test_disk bs=512 skip=8391 count=1 of=/tmp/dsl.dnode.1.bin.lz4 <br> # zdec dsl.dnode.0.bin.lz4 dsl.dnode.0.bin 16384 <br> Input: dsl.dnode.0.bin.lz4 <br> Output: dsl.dnode.0.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 2048 <br> Real input size: 1589 <br> Decompress result: 0 <br> # zdec dsl.dnode.1.bin.lz4 dsl.dnode.1.bin 16384 <br> Input: dsl.dnode.1.bin.lz4 <br> Output: dsl.dnode.1.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 464 <br> Decompress result: 0 <br></code> <br>  Make a list of objects <br><br><div class="spoiler">  <b class="spoiler_title">31 objects</b> <div class="spoiler_text"> <code># r2 dsl.dnode.0.bin <br> [0x00000000]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000000 = 0x00 <br> dn_indblkshift : 0x00000001 = 0x00 <br> dn_nlevels : 0x00000002 = 0x00 <br> dn_nblkptr : 0x00000003 = 0x00 <br> dn_bonustype : 0x00000004 = 0x00 <br> dn_checksum : 0x00000005 = 0x00 <br> dn_compress : 0x00000006 = 0x00 <br> dn_flags : 0x00000007 = 0x00 <br> dn_datablkszsec : 0x00000008 = 0x0000 <br> dn_bonuslen : 0x0000000a = 0x0000 <br> dn_pad2[4] : 0x0000000c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000010 = (qword)0x0000000000000000 <br> dn_used : 0x00000018 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000000]&gt; s+0x200 <br> [0x00000200]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000200 = 0x01 <br> dn_indblkshift : 0x00000201 = 0x0e <br> dn_nlevels : 0x00000202 = 0x01 <br> dn_nblkptr : 0x00000203 = 0x03 <br> dn_bonustype : 0x00000204 = 0x00 <br> dn_checksum : 0x00000205 = 0x00 <br> dn_compress : 0x00000206 = 0x00 <br> dn_flags : 0x00000207 = 0x01 <br> dn_datablkszsec : 0x00000208 = 0x0002 <br> dn_bonuslen : 0x0000020a = 0x0000 <br> dn_pad2[4] : 0x0000020c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000210 = (qword)0x0000000000000000 <br> dn_used : 0x00000218 = (qword)0x0000000000000600 <br> dn_pad3[4] : 0x00000220 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000200]&gt; s+0x200 <br> [0x00000400]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000400 = 0x0c <br> dn_indblkshift : 0x00000401 = 0x0e <br> dn_nlevels : 0x00000402 = 0x01 <br> dn_nblkptr : 0x00000403 = 0x01 <br> dn_bonustype : 0x00000404 = 0x0c <br> dn_checksum : 0x00000405 = 0x00 <br> dn_compress : 0x00000406 = 0x00 <br> dn_flags : 0x00000407 = 0x00 <br> dn_datablkszsec : 0x00000408 = 0x0001 <br> dn_bonuslen : 0x0000040a = 0x0100 <br> dn_pad2[4] : 0x0000040c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000410 = (qword)0x0000000000000000 <br> dn_used : 0x00000418 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000420 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000400]&gt; s+0x200 <br> [0x00000600]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000600 = 0x0f <br> dn_indblkshift : 0x00000601 = 0x0e <br> dn_nlevels : 0x00000602 = 0x01 <br> dn_nblkptr : 0x00000603 = 0x03 <br> dn_bonustype : 0x00000604 = 0x00 <br> dn_checksum : 0x00000605 = 0x00 <br> dn_compress : 0x00000606 = 0x00 <br> dn_flags : 0x00000607 = 0x01 <br> dn_datablkszsec : 0x00000608 = 0x0001 <br> dn_bonuslen : 0x0000060a = 0x0000 <br> dn_pad2[4] : 0x0000060c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000610 = (qword)0x0000000000000000 <br> dn_used : 0x00000618 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000620 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000600]&gt; s+0x200 <br> [0x00000800]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000800 = 0x0d <br> dn_indblkshift : 0x00000801 = 0x0e <br> dn_nlevels : 0x00000802 = 0x01 <br> dn_nblkptr : 0x00000803 = 0x03 <br> dn_bonustype : 0x00000804 = 0x00 <br> dn_checksum : 0x00000805 = 0x00 <br> dn_compress : 0x00000806 = 0x00 <br> dn_flags : 0x00000807 = 0x01 <br> dn_datablkszsec : 0x00000808 = 0x0001 <br> dn_bonuslen : 0x0000080a = 0x0000 <br> dn_pad2[4] : 0x0000080c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000810 = (qword)0x0000000000000000 <br> dn_used : 0x00000818 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000820 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000800]&gt; s+0x200 <br> [0x00000a00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000a00 = 0x0c <br> dn_indblkshift : 0x00000a01 = 0x0e <br> dn_nlevels : 0x00000a02 = 0x01 <br> dn_nblkptr : 0x00000a03 = 0x01 <br> dn_bonustype : 0x00000a04 = 0x0c <br> dn_checksum : 0x00000a05 = 0x00 <br> dn_compress : 0x00000a06 = 0x00 <br> dn_flags : 0x00000a07 = 0x00 <br> dn_datablkszsec : 0x00000a08 = 0x0001 <br> dn_bonuslen : 0x00000a0a = 0x0100 <br> dn_pad2[4] : 0x00000a0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000a10 = (qword)0x0000000000000000 <br> dn_used : 0x00000a18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000a20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000a00]&gt; s+0x200 <br> [0x00000c00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000c00 = 0x0f <br> dn_indblkshift : 0x00000c01 = 0x0e <br> dn_nlevels : 0x00000c02 = 0x01 <br> dn_nblkptr : 0x00000c03 = 0x03 <br> dn_bonustype : 0x00000c04 = 0x00 <br> dn_checksum : 0x00000c05 = 0x00 <br> dn_compress : 0x00000c06 = 0x00 <br> dn_flags : 0x00000c07 = 0x01 <br> dn_datablkszsec : 0x00000c08 = 0x0001 <br> dn_bonuslen : 0x00000c0a = 0x0000 <br> dn_pad2[4] : 0x00000c0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000c10 = (qword)0x0000000000000000 <br> dn_used : 0x00000c18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000c20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000c00]&gt; s+0x200 <br> [0x00000e00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000e00 = 0x0d <br> dn_indblkshift : 0x00000e01 = 0x0e <br> dn_nlevels : 0x00000e02 = 0x01 <br> dn_nblkptr : 0x00000e03 = 0x03 <br> dn_bonustype : 0x00000e04 = 0x00 <br> dn_checksum : 0x00000e05 = 0x00 <br> dn_compress : 0x00000e06 = 0x00 <br> dn_flags : 0x00000e07 = 0x01 <br> dn_datablkszsec : 0x00000e08 = 0x0001 <br> dn_bonuslen : 0x00000e0a = 0x0000 <br> dn_pad2[4] : 0x00000e0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000e10 = (qword)0x0000000000000000 <br> dn_used : 0x00000e18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000e20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000e00]&gt; s+0x200 <br> [0x00001000]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001000 = 0x0c <br> dn_indblkshift : 0x00001001 = 0x0e <br> dn_nlevels : 0x00001002 = 0x01 <br> dn_nblkptr : 0x00001003 = 0x01 <br> dn_bonustype : 0x00001004 = 0x0c <br> dn_checksum : 0x00001005 = 0x00 <br> dn_compress : 0x00001006 = 0x00 <br> dn_flags : 0x00001007 = 0x00 <br> dn_datablkszsec : 0x00001008 = 0x0001 <br> dn_bonuslen : 0x0000100a = 0x0100 <br> dn_pad2[4] : 0x0000100c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001010 = (qword)0x0000000000000000 <br> dn_used : 0x00001018 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00001020 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001000]&gt; s+0x200 <br> [0x00001200]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001200 = 0x0f <br> dn_indblkshift : 0x00001201 = 0x0e <br> dn_nlevels : 0x00001202 = 0x01 <br> dn_nblkptr : 0x00001203 = 0x03 <br> dn_bonustype : 0x00001204 = 0x00 <br> dn_checksum : 0x00001205 = 0x00 <br> dn_compress : 0x00001206 = 0x00 <br> dn_flags : 0x00001207 = 0x01 <br> dn_datablkszsec : 0x00001208 = 0x0001 <br> dn_bonuslen : 0x0000120a = 0x0000 <br> dn_pad2[4] : 0x0000120c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001210 = (qword)0x0000000000000000 <br> dn_used : 0x00001218 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00001220 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001200]&gt; s+0x200 <br> [0x00001400]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001400 = 0x0d <br> dn_indblkshift : 0x00001401 = 0x0e <br> dn_nlevels : 0x00001402 = 0x01 <br> dn_nblkptr : 0x00001403 = 0x03 <br> dn_bonustype : 0x00001404 = 0x00 <br> dn_checksum : 0x00001405 = 0x00 <br> dn_compress : 0x00001406 = 0x00 <br> dn_flags : 0x00001407 = 0x01 <br> dn_datablkszsec : 0x00001408 = 0x0001 <br> dn_bonuslen : 0x0000140a = 0x0000 <br> dn_pad2[4] : 0x0000140c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001410 = (qword)0x0000000000000000 <br> dn_used : 0x00001418 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00001420 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001400]&gt; s+0x200 <br> [0x00001600]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001600 = 0x05 <br> dn_indblkshift : 0x00001601 = 0x0e <br> dn_nlevels : 0x00001602 = 0x01 <br> dn_nblkptr : 0x00001603 = 0x03 <br> dn_bonustype : 0x00001604 = 0x06 <br> dn_checksum : 0x00001605 = 0x00 <br> dn_compress : 0x00001606 = 0x00 <br> dn_flags : 0x00001607 = 0x00 <br> dn_datablkszsec : 0x00001608 = 0x0100 <br> dn_bonuslen : 0x0000160a = 0x0030 <br> dn_pad2[4] : 0x0000160c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001610 = (qword)0x0000000000000000 <br> dn_used : 0x00001618 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00001620 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001600]&gt; s+0x200 <br> [0x00001800]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001800 = 0x0c <br> dn_indblkshift : 0x00001801 = 0x0e <br> dn_nlevels : 0x00001802 = 0x01 <br> dn_nblkptr : 0x00001803 = 0x01 <br> dn_bonustype : 0x00001804 = 0x0c <br> dn_checksum : 0x00001805 = 0x00 <br> dn_compress : 0x00001806 = 0x00 <br> dn_flags : 0x00001807 = 0x00 <br> dn_datablkszsec : 0x00001808 = 0x0001 <br> dn_bonuslen : 0x0000180a = 0x0100 <br> dn_pad2[4] : 0x0000180c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001810 = (qword)0x0000000000000000 <br> dn_used : 0x00001818 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00001820 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001800]&gt; s+0x200 <br> [0x00001a00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001a00 = 0x0f <br> dn_indblkshift : 0x00001a01 = 0x0e <br> dn_nlevels : 0x00001a02 = 0x01 <br> dn_nblkptr : 0x00001a03 = 0x03 <br> dn_bonustype : 0x00001a04 = 0x00 <br> dn_checksum : 0x00001a05 = 0x00 <br> dn_compress : 0x00001a06 = 0x00 <br> dn_flags : 0x00001a07 = 0x01 <br> dn_datablkszsec : 0x00001a08 = 0x0001 <br> dn_bonuslen : 0x00001a0a = 0x0000 <br> dn_pad2[4] : 0x00001a0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001a10 = (qword)0x0000000000000000 <br> dn_used : 0x00001a18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00001a20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001a00]&gt; s+0x200 <br> [0x00001c00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001c00 = 0x0d <br> dn_indblkshift : 0x00001c01 = 0x0e <br> dn_nlevels : 0x00001c02 = 0x01 <br> dn_nblkptr : 0x00001c03 = 0x03 <br> dn_bonustype : 0x00001c04 = 0x00 <br> dn_checksum : 0x00001c05 = 0x00 <br> dn_compress : 0x00001c06 = 0x00 <br> dn_flags : 0x00001c07 = 0x01 <br> dn_datablkszsec : 0x00001c08 = 0x0001 <br> dn_bonuslen : 0x00001c0a = 0x0000 <br> dn_pad2[4] : 0x00001c0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001c10 = (qword)0x0000000000000000 <br> dn_used : 0x00001c18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00001c20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001c00]&gt; s+0x200 <br> [0x00001e00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001e00 = 0x10 <br> dn_indblkshift : 0x00001e01 = 0x0e <br> dn_nlevels : 0x00001e02 = 0x01 <br> dn_nblkptr : 0x00001e03 = 0x01 <br> dn_bonustype : 0x00001e04 = 0x10 <br> dn_checksum : 0x00001e05 = 0x00 <br> dn_compress : 0x00001e06 = 0x00 <br> dn_flags : 0x00001e07 = 0x00 <br> dn_datablkszsec : 0x00001e08 = 0x0001 <br> dn_bonuslen : 0x00001e0a = 0x0140 <br> dn_pad2[4] : 0x00001e0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001e10 = (qword)0x0000000000000000 <br> dn_used : 0x00001e18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00001e20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001e00]&gt; s+0x200 <br> [0x00002000]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00002000 = 0x0e <br> dn_indblkshift : 0x00002001 = 0x0e <br> dn_nlevels : 0x00002002 = 0x01 <br> dn_nblkptr : 0x00002003 = 0x03 <br> dn_bonustype : 0x00002004 = 0x00 <br> dn_checksum : 0x00002005 = 0x00 <br> dn_compress : 0x00002006 = 0x00 <br> dn_flags : 0x00002007 = 0x01 <br> dn_datablkszsec : 0x00002008 = 0x0001 <br> dn_bonuslen : 0x0000200a = 0x0000 <br> dn_pad2[4] : 0x0000200c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00002010 = (qword)0x0000000000000000 <br> dn_used : 0x00002018 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00002020 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00002000]&gt; s+0x200 <br> [0x00002200]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00002200 = 0x32 <br> dn_indblkshift : 0x00002201 = 0x0e <br> dn_nlevels : 0x00002202 = 0x01 <br> dn_nblkptr : 0x00002203 = 0x01 <br> dn_bonustype : 0x00002204 = 0x33 <br> dn_checksum : 0x00002205 = 0x00 <br> dn_compress : 0x00002206 = 0x00 <br> dn_flags : 0x00002207 = 0x01 <br> dn_datablkszsec : 0x00002208 = 0x0001 <br> dn_bonuslen : 0x0000220a = 0x0140 <br> dn_pad2[4] : 0x0000220c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00002210 = (qword)0x0000000000000000 <br> dn_used : 0x00002218 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00002220 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00002200]&gt; s+0x200 <br> [0x00002400]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00002400 = 0x10 <br> dn_indblkshift : 0x00002401 = 0x0e <br> dn_nlevels : 0x00002402 = 0x01 <br> dn_nblkptr : 0x00002403 = 0x01 <br> dn_bonustype : 0x00002404 = 0x10 <br> dn_checksum : 0x00002405 = 0x00 <br> dn_compress : 0x00002406 = 0x00 <br> dn_flags : 0x00002407 = 0x00 <br> dn_datablkszsec : 0x00002408 = 0x0001 <br> dn_bonuslen : 0x0000240a = 0x0140 <br> dn_pad2[4] : 0x0000240c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00002410 = (qword)0x0000000000000000 <br> dn_used : 0x00002418 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00002420 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00002400]&gt; s+0x200 <br> [0x00002600]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00002600 = 0x32 <br> dn_indblkshift : 0x00002601 = 0x0e <br> dn_nlevels : 0x00002602 = 0x01 <br> dn_nblkptr : 0x00002603 = 0x01 <br> dn_bonustype : 0x00002604 = 0x33 <br> dn_checksum : 0x00002605 = 0x00 <br> dn_compress : 0x00002606 = 0x00 <br> dn_flags : 0x00002607 = 0x01 <br> dn_datablkszsec : 0x00002608 = 0x0001 <br> dn_bonuslen : 0x0000260a = 0x0140 <br> dn_pad2[4] : 0x0000260c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00002610 = (qword)0x0000000000000000 <br> dn_used : 0x00002618 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00002620 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00002600]&gt; s+0x200 <br> [0x00002800]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00002800 = 0x05 <br> dn_indblkshift : 0x00002801 = 0x0e <br> dn_nlevels : 0x00002802 = 0x01 <br> dn_nblkptr : 0x00002803 = 0x03 <br> dn_bonustype : 0x00002804 = 0x06 <br> dn_checksum : 0x00002805 = 0x00 <br> dn_compress : 0x00002806 = 0x00 <br> dn_flags : 0x00002807 = 0x00 <br> dn_datablkszsec : 0x00002808 = 0x0100 <br> dn_bonuslen : 0x0000280a = 0x0030 <br> dn_pad2[4] : 0x0000280c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00002810 = (qword)0x0000000000000000 <br> dn_used : 0x00002818 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00002820 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00002800]&gt; s+0x200 <br> [0x00002a00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00002a00 = 0x10 <br> dn_indblkshift : 0x00002a01 = 0x0e <br> dn_nlevels : 0x00002a02 = 0x01 <br> dn_nblkptr : 0x00002a03 = 0x01 <br> dn_bonustype : 0x00002a04 = 0x10 <br> dn_checksum : 0x00002a05 = 0x00 <br> dn_compress : 0x00002a06 = 0x00 <br> dn_flags : 0x00002a07 = 0x00 <br> dn_datablkszsec : 0x00002a08 = 0x0001 <br> dn_bonuslen : 0x00002a0a = 0x0140 <br> dn_pad2[4] : 0x00002a0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00002a10 = (qword)0x0000000000000000 <br> dn_used : 0x00002a18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00002a20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00002a00]&gt; s+0x200 <br> [0x00002c00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00002c00 = 0x0e <br> dn_indblkshift : 0x00002c01 = 0x0e <br> dn_nlevels : 0x00002c02 = 0x01 <br> dn_nblkptr : 0x00002c03 = 0x03 <br> dn_bonustype : 0x00002c04 = 0x00 <br> dn_checksum : 0x00002c05 = 0x00 <br> dn_compress : 0x00002c06 = 0x00 <br> dn_flags : 0x00002c07 = 0x01 <br> dn_datablkszsec : 0x00002c08 = 0x0001 <br> dn_bonuslen : 0x00002c0a = 0x0000 <br> dn_pad2[4] : 0x00002c0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00002c10 = (qword)0x0000000000000000 <br> dn_used : 0x00002c18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00002c20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00002c00]&gt; s+0x200 <br> [0x00002e00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00002e00 = 0x32 <br> dn_indblkshift : 0x00002e01 = 0x0e <br> dn_nlevels : 0x00002e02 = 0x01 <br> dn_nblkptr : 0x00002e03 = 0x01 <br> dn_bonustype : 0x00002e04 = 0x33 <br> dn_checksum : 0x00002e05 = 0x00 <br> dn_compress : 0x00002e06 = 0x00 <br> dn_flags : 0x00002e07 = 0x01 <br> dn_datablkszsec : 0x00002e08 = 0x0001 <br> dn_bonuslen : 0x00002e0a = 0x0140 <br> dn_pad2[4] : 0x00002e0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00002e10 = (qword)0x0000000000000000 <br> dn_used : 0x00002e18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00002e20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00002e00]&gt; s+0x200 <br> [0x00003000]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00003000 = 0x05 <br> dn_indblkshift : 0x00003001 = 0x0e <br> dn_nlevels : 0x00003002 = 0x01 <br> dn_nblkptr : 0x00003003 = 0x03 <br> dn_bonustype : 0x00003004 = 0x06 <br> dn_checksum : 0x00003005 = 0x00 <br> dn_compress : 0x00003006 = 0x00 <br> dn_flags : 0x00003007 = 0x00 <br> dn_datablkszsec : 0x00003008 = 0x0100 <br> dn_bonuslen : 0x0000300a = 0x0030 <br> dn_pad2[4] : 0x0000300c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00003010 = (qword)0x0000000000000000 <br> dn_used : 0x00003018 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00003020 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00003000]&gt; s+0x200 <br> [0x00003200]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00003200 = 0x25 <br> dn_indblkshift : 0x00003201 = 0x0e <br> dn_nlevels : 0x00003202 = 0x01 <br> dn_nblkptr : 0x00003203 = 0x03 <br> dn_bonustype : 0x00003204 = 0x00 <br> dn_checksum : 0x00003205 = 0x00 <br> dn_compress : 0x00003206 = 0x00 <br> dn_flags : 0x00003207 = 0x01 <br> dn_datablkszsec : 0x00003208 = 0x0001 <br> dn_bonuslen : 0x0000320a = 0x0000 <br> dn_pad2[4] : 0x0000320c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00003210 = (qword)0x0000000000000000 <br> dn_used : 0x00003218 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00003220 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00003200]&gt; s+0x200 <br> [0x00003400]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00003400 = 0x34 <br> dn_indblkshift : 0x00003401 = 0x0e <br> dn_nlevels : 0x00003402 = 0x01 <br> dn_nblkptr : 0x00003403 = 0x03 <br> dn_bonustype : 0x00003404 = 0x00 <br> dn_checksum : 0x00003405 = 0x00 <br> dn_compress : 0x00003406 = 0x00 <br> dn_flags : 0x00003407 = 0x01 <br> dn_datablkszsec : 0x00003408 = 0x0001 <br> dn_bonuslen : 0x0000340a = 0x0000 <br> dn_pad2[4] : 0x0000340c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00003410 = (qword)0x0000000000000000 <br> dn_used : 0x00003418 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00003420 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00003400]&gt; s+0x200 <br> [0x00003600]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00003600 = 0x03 <br> dn_indblkshift : 0x00003601 = 0x0e <br> dn_nlevels : 0x00003602 = 0x01 <br> dn_nblkptr : 0x00003603 = 0x03 <br> dn_bonustype : 0x00003604 = 0x04 <br> dn_checksum : 0x00003605 = 0x00 <br> dn_compress : 0x00003606 = 0x00 <br> dn_flags : 0x00003607 = 0x01 <br> dn_datablkszsec : 0x00003608 = 0x0020 <br> dn_bonuslen : 0x0000360a = 0x0008 <br> dn_pad2[4] : 0x0000360c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00003610 = (qword)0x0000000000000000 <br> dn_used : 0x00003618 = (qword)0x0000000000000c00 <br> dn_pad3[4] : 0x00003620 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00003600]&gt; s+0x200 <br> [0x00003800]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00003800 = 0xc4 <br> dn_indblkshift : 0x00003801 = 0x0e <br> dn_nlevels : 0x00003802 = 0x01 <br> dn_nblkptr : 0x00003803 = 0x03 <br> dn_bonustype : 0x00003804 = 0x00 <br> dn_checksum : 0x00003805 = 0x00 <br> dn_compress : 0x00003806 = 0x00 <br> dn_flags : 0x00003807 = 0x01 <br> dn_datablkszsec : 0x00003808 = 0x0001 <br> dn_bonuslen : 0x0000380a = 0x0000 <br> dn_pad2[4] : 0x0000380c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00003810 = (qword)0x0000000000000000 <br> dn_used : 0x00003818 = (qword)0x0000000000000600 <br> dn_pad3[4] : 0x00003820 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00003800]&gt; s+0x200 <br> [0x00003a00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00003a00 = 0xc4 <br> dn_indblkshift : 0x00003a01 = 0x0e <br> dn_nlevels : 0x00003a02 = 0x01 <br> dn_nblkptr : 0x00003a03 = 0x03 <br> dn_bonustype : 0x00003a04 = 0x00 <br> dn_checksum : 0x00003a05 = 0x00 <br> dn_compress : 0x00003a06 = 0x00 <br> dn_flags : 0x00003a07 = 0x01 <br> dn_datablkszsec : 0x00003a08 = 0x0001 <br> dn_bonuslen : 0x00003a0a = 0x0000 <br> dn_pad2[4] : 0x00003a0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00003a10 = (qword)0x0000000000000000 <br> dn_used : 0x00003a18 = (qword)0x0000000000000600 <br> dn_pad3[4] : 0x00003a20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00003a00]&gt; s+0x200 <br> [0x00003c00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00003c00 = 0xc4 <br> dn_indblkshift : 0x00003c01 = 0x0e <br> dn_nlevels : 0x00003c02 = 0x01 <br> dn_nblkptr : 0x00003c03 = 0x03 <br> dn_bonustype : 0x00003c04 = 0x00 <br> dn_checksum : 0x00003c05 = 0x00 <br> dn_compress : 0x00003c06 = 0x00 <br> dn_flags : 0x00003c07 = 0x01 <br> dn_datablkszsec : 0x00003c08 = 0x0020 <br> dn_bonuslen : 0x00003c0a = 0x0000 <br> dn_pad2[4] : 0x00003c0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00003c10 = (qword)0x0000000000000001 <br> dn_used : 0x00003c18 = (qword)0x0000000000003600 <br> dn_pad3[4] : 0x00003c20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00003c00]&gt; s+0x200 <br> [0x00003e00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00003e00 = 0x05 <br> dn_indblkshift : 0x00003e01 = 0x0e <br> dn_nlevels : 0x00003e02 = 0x01 <br> dn_nblkptr : 0x00003e03 = 0x03 <br> dn_bonustype : 0x00003e04 = 0x06 <br> dn_checksum : 0x00003e05 = 0x00 <br> dn_compress : 0x00003e06 = 0x02 <br> dn_flags : 0x00003e07 = 0x01 <br> dn_datablkszsec : 0x00003e08 = 0x0020 <br> dn_bonuslen : 0x00003e0a = 0x0030 <br> dn_pad2[4] : 0x00003e0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00003e10 = (qword)0x0000000000000000 <br> dn_used : 0x00003e18 = (qword)0x0000000000000600 <br> dn_pad3[4] : 0x00003e20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">4 objects</b> <div class="spoiler_text"> <code># r2 dsl.dnode.1.bin <br> [0x00000000]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000000 = 0x1d <br> dn_indblkshift : 0x00000001 = 0x0e <br> dn_nlevels : 0x00000002 = 0x01 <br> dn_nblkptr : 0x00000003 = 0x03 <br> dn_bonustype : 0x00000004 = 0x1e <br> dn_checksum : 0x00000005 = 0x00 <br> dn_compress : 0x00000006 = 0x00 <br> dn_flags : 0x00000007 = 0x01 <br> dn_datablkszsec : 0x00000008 = 0x0100 <br> dn_bonuslen : 0x0000000a = 0x0028 <br> dn_pad2[4] : 0x0000000c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000010 = (qword)0x0000000000000000 <br> dn_used : 0x00000018 = (qword)0x0000000000001200 <br> dn_pad3[4] : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000000]&gt; s+0x200 <br> [0x00000200]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000200 = 0xc4 <br> dn_indblkshift : 0x00000201 = 0x0e <br> dn_nlevels : 0x00000202 = 0x01 <br> dn_nblkptr : 0x00000203 = 0x03 <br> dn_bonustype : 0x00000204 = 0x00 <br> dn_checksum : 0x00000205 = 0x00 <br> dn_compress : 0x00000206 = 0x00 <br> dn_flags : 0x00000207 = 0x01 <br> dn_datablkszsec : 0x00000208 = 0x0001 <br> dn_bonuslen : 0x0000020a = 0x0000 <br> dn_pad2[4] : 0x0000020c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000210 = (qword)0x0000000000000000 <br> dn_used : 0x00000218 = (qword)0x0000000000000600 <br> dn_pad3[4] : 0x00000220 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000200]&gt; s+0x200 <br> [0x00000400]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000400 = 0x02 <br> dn_indblkshift : 0x00000401 = 0x0e <br> dn_nlevels : 0x00000402 = 0x01 <br> dn_nblkptr : 0x00000403 = 0x03 <br> dn_bonustype : 0x00000404 = 0x00 <br> dn_checksum : 0x00000405 = 0x00 <br> dn_compress : 0x00000406 = 0x00 <br> dn_flags : 0x00000407 = 0x01 <br> dn_datablkszsec : 0x00000408 = 0x0001 <br> dn_bonuslen : 0x0000040a = 0x0000 <br> dn_pad2[4] : 0x0000040c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000410 = (qword)0x0000000000000000 <br> dn_used : 0x00000418 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000420 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000400]&gt; s+0x200 <br> [0x00000600]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000600 = 0x08 <br> dn_indblkshift : 0x00000601 = 0x0e <br> dn_nlevels : 0x00000602 = 0x01 <br> dn_nblkptr : 0x00000603 = 0x01 <br> dn_bonustype : 0x00000604 = 0x07 <br> dn_checksum : 0x00000605 = 0x00 <br> dn_compress : 0x00000606 = 0x00 <br> dn_flags : 0x00000607 = 0x01 <br> dn_datablkszsec : 0x00000608 = 0x0008 <br> dn_bonuslen : 0x0000060a = 0x0140 <br> dn_pad2[4] : 0x0000060c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000610 = (qword)0x0000000000000000 <br> dn_used : 0x00000618 = (qword)0x0000000000000c00 <br> dn_pad3[4] : 0x00000620 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br></div></div><br>  At the moment we are interested in objects 15, 18, 21. <br><table><tbody><tr><td>  index </td><td>  dn_type </td><td></td><td>  dn_bonustype </td><td></td><td>  dn_bonuslen </td></tr><tr><td>  15 </td><td>  0x10 </td><td>  DMU_OT_DSL_DATASET </td><td>  0x10 </td><td>  DMU_OT_DSL_DATASET </td><td>  0x0140 </td></tr><tr><td>  18 </td><td>  0x10 </td><td>  DMU_OT_DSL_DATASET </td><td>  0x10 </td><td>  DMU_OT_DSL_DATASET </td><td>  0x0140 </td></tr><tr><td>  21 </td><td>  0x10 </td><td>  DMU_OT_DSL_DATASET </td><td>  0x10 </td><td>  DMU_OT_DSL_DATASET </td><td>  0x0140 </td></tr></tbody></table><br><br>  For objects of type DMU_OT_DSL_DATASET, the dsl_dataset_phys structure is stored in the bonus buffer of the dnode structure. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dsl_dataset_phys</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_dir_obj; <span class="hljs-comment"><span class="hljs-comment">/* DMU_OT_DSL_DIR */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_prev_snap_obj; <span class="hljs-comment"><span class="hljs-comment">/* DMU_OT_DSL_DATASET */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_prev_snap_txg; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_next_snap_obj; <span class="hljs-comment"><span class="hljs-comment">/* DMU_OT_DSL_DATASET */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_snapnames_zapobj; <span class="hljs-comment"><span class="hljs-comment">/* DMU_OT_DSL_DS_SNAP_MAP 0 for snaps */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_num_children; <span class="hljs-comment"><span class="hljs-comment">/* clone/snap children; ==0 for head */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_creation_time; <span class="hljs-comment"><span class="hljs-comment">/* seconds since 1970 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_creation_txg; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_deadlist_obj; <span class="hljs-comment"><span class="hljs-comment">/* DMU_OT_DEADLIST */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* * ds_referenced_bytes, ds_compressed_bytes, and ds_uncompressed_bytes * include all blocks referenced by this dataset, including those * shared with any other datasets. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_referenced_bytes; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_compressed_bytes; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_uncompressed_bytes; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_unique_bytes; <span class="hljs-comment"><span class="hljs-comment">/* only relevant to snapshots */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* * The ds_fsid_guid is a 56-bit ID that can change to avoid * collisions. The ds_guid is a 64-bit ID that will never * change, so there is a small probability that it will collide. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_fsid_guid; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_guid; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_flags; <span class="hljs-comment"><span class="hljs-comment">/* DS_FLAG_* */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">blkptr_t</span></span> ds_bp; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_next_clones_obj; <span class="hljs-comment"><span class="hljs-comment">/* DMU_OT_DSL_CLONES */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_props_obj; <span class="hljs-comment"><span class="hljs-comment">/* DMU_OT_DSL_PROPS for snaps */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_userrefs_obj; <span class="hljs-comment"><span class="hljs-comment">/* DMU_OT_USERREFS */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ds_pad[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* pad out to 320 bytes for good measure */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">dsl_dataset_phys_t</span></span>;</code> </pre><br><br>  Read object 15 <br><br> <code># r2 dsl.dnode.0.bin <br> -- Change the size of the file with the 'r' (resize) command <br> [0x00000000]&gt; 0x00001e00 <br> [0x00001e00]&gt; s+0x40 <br> [0x00001e40]&gt; s+0x80 <br> [0x00001ec0]&gt; pf qqqqqqt:qqqqqqqqqb[127].qqq[5]q ds_dir_obj ds_prev_snap_obj ds_prev_snap_txg ds_next_snap_obj ds_snapnames_zapobj ds_num_children ds_creation_time ds_creation_txg ds_deadlist_obj ds_referenced_bytes ds_compressed_bytes ds_uncompressed_bytes ds_unique_bytes ds_fsid_guid ds_guid ds_flags ds_bp ds_next_clones_obj ds_props_obj ds_userrefs_obj ds_pad[5] <br> ds_dir_obj : 0x00001ec0 = (qword)0x000000000000000c <br> ds_prev_snap_obj : 0x00001ec8 = (qword)0x0000000000000012 <br> ds_prev_snap_txg : 0x00001ed0 = (qword)0x0000000000000001 <br> ds_next_snap_obj : 0x00001ed8 = (qword)0x0000000000000000 <br> ds_snapnames_zapobj : 0x00001ee0 = (qword)0x0000000000000010 <br> ds_num_children : 0x00001ee8 = (qword)0x0000000000000000 <br> ds_creation_time : 0x00001ef0 = Wed Jan 31 07:25:31 2018 <br> ds_creation_txg : 0x00001ef8 = (qword)0x0000000000000001 <br> ds_deadlist_obj : 0x00001f00 = (qword)0x0000000000000013 <br> ds_referenced_bytes : 0x00001f08 = (qword)0x0000000000000000 <br> ds_compressed_bytes : 0x00001f10 = (qword)0x0000000000000000 <br> ds_uncompressed_bytes : 0x00001f18 = (qword)0x0000000000000000 <br> ds_unique_bytes : 0x00001f20 = (qword)0x0000000000000000 <br> ds_fsid_guid : 0x00001f28 = (qword)0x0072595fd26fec77 <br> ds_guid : 0x00001f30 = (qword)0x3723b59bcad0d186 <br> ds_flags : 0x00001f38 = (qword)0x0000000000000004 <br> ds_bp : 0x00001f40 = 0x00 <br> ds_next_clones_obj : 0x00001fc0 = (qword)0x0000000000000000 <br> ds_props_obj : 0x00001fc8 = (qword)0x0000000000000000 <br> ds_userrefs_obj : 0x00001fd0 = (qword)0x0000000000000000 <br> ds_pad[5] : 0x00001fd8 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> 0x00001f40 <br> [0x00001f40]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00001f40 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_1 : 0x00001f50 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_2 : 0x00001f60 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00001f70 = (qword)0x0000000000000000 <br> blk_pad[2] : 0x00001f78 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00001f88 = (qword)0x0000000000000000 <br> blk_birth : 0x00001f90 = (qword)0x0000000000000000 <br> blk_fill : 0x00001f98 = (qword)0x0000000000000000 <br> blk_cksum : 0x00001fa0 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br>  Read object 18 <br><br> <code>0x00002400 <br> [0x00002400]&gt; s+0x40 <br> [0x00002440]&gt; s+0x80 <br> [0x000024c0]&gt; pf qqqqqqt:qqqqqqqqqb[127].qqq[5]q ds_dir_obj ds_prev_snap_obj ds_prev_snap_txg ds_next_snap_obj ds_snapnames_zapobj ds_num_children ds_creation_time ds_creation_txg ds_deadlist_obj ds_referenced_bytes ds_compressed_bytes ds_uncompressed_bytes ds_unique_bytes ds_fsid_guid ds_guid ds_flags ds_bp ds_next_clones_obj ds_props_obj ds_userrefs_obj ds_pad[5] <br> ds_dir_obj : 0x000024c0 = (qword)0x000000000000000c <br> ds_prev_snap_obj : 0x000024c8 = (qword)0x0000000000000000 <br> ds_prev_snap_txg : 0x000024d0 = (qword)0x0000000000000000 <br> ds_next_snap_obj : 0x000024d8 = (qword)0x000000000000000f <br> ds_snapnames_zapobj : 0x000024e0 = (qword)0x0000000000000000 <br> ds_num_children : 0x000024e8 = (qword)0x0000000000000002 <br> ds_creation_time : 0x000024f0 = Wed Jan 31 07:25:31 2018 <br> ds_creation_txg : 0x000024f8 = (qword)0x0000000000000001 <br> ds_deadlist_obj : 0x00002500 = (qword)0x0000000000000011 <br> ds_referenced_bytes : 0x00002508 = (qword)0x0000000000000000 <br> ds_compressed_bytes : 0x00002510 = (qword)0x0000000000000000 <br> ds_uncompressed_bytes : 0x00002518 = (qword)0x0000000000000000 <br> ds_unique_bytes : 0x00002520 = (qword)0x0000000000000000 <br> ds_fsid_guid : 0x00002528 = (qword)0x007551fa166ccbaf <br> ds_guid : 0x00002530 = (qword)0x107a852b04f9f01f <br> ds_flags : 0x00002538 = (qword)0x0000000000000004 <br> ds_bp : 0x00002540 = 0x00 <br> ds_next_clones_obj : 0x000025c0 = (qword)0x0000000000000019 <br> ds_props_obj : 0x000025c8 = (qword)0x0000000000000000 <br> ds_userrefs_obj : 0x000025d0 = (qword)0x0000000000000000 <br> ds_pad[5] : 0x000025d8 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> 0x00002540 <br> [0x00002540]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00002540 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_1 : 0x00002550 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_2 : 0x00002560 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00002570 = (qword)0x0000000000000000 <br> blk_pad[2] : 0x00002578 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00002588 = (qword)0x0000000000000000 <br> blk_birth : 0x00002590 = (qword)0x0000000000000000 <br> blk_fill : 0x00002598 = (qword)0x0000000000000000 <br> blk_cksum : 0x000025a0 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br>  Read object 21 <br><br> <code>0x00002a00 <br> [0x00002a00]&gt; s+0x40 <br> [0x00002a40]&gt; s+0x80 <br> [0x00002ac0]&gt; pf qqqqqqt:qqqqqqqqqb[127].qqq[5]q ds_dir_obj ds_prev_snap_obj ds_prev_snap_txg ds_next_snap_obj ds_snapnames_zapobj ds_num_children ds_creation_time ds_creation_txg ds_deadlist_obj ds_referenced_bytes ds_compressed_bytes ds_uncompressed_bytes ds_unique_bytes ds_fsid_guid ds_guid ds_flags ds_bp ds_next_clones_obj ds_props_obj ds_userrefs_obj ds_pad[5] <br> ds_dir_obj : 0x00002ac0 = (qword)0x0000000000000002 <br> ds_prev_snap_obj : 0x00002ac8 = (qword)0x0000000000000012 <br> ds_prev_snap_txg : 0x00002ad0 = (qword)0x0000000000000001 <br> ds_next_snap_obj : 0x00002ad8 = (qword)0x0000000000000000 <br> ds_snapnames_zapobj : 0x00002ae0 = (qword)0x0000000000000016 <br> ds_num_children : 0x00002ae8 = (qword)0x0000000000000000 <br> ds_creation_time : 0x00002af0 = Wed Jan 31 07:25:31 2018 <br> ds_creation_txg : 0x00002af8 = (qword)0x0000000000000001 <br> ds_deadlist_obj : 0x00002b00 = (qword)0x0000000000000017 <br> ds_referenced_bytes : 0x00002b08 = (qword)0x0000000000005600 <br> ds_compressed_bytes : 0x00002b10 = (qword)0x0000000000002e00 <br> ds_uncompressed_bytes : 0x00002b18 = (qword)0x0000000000002e00 <br> ds_unique_bytes : 0x00002b20 = (qword)0x0000000000005600 <br> ds_fsid_guid : 0x00002b28 = (qword)0x00aca2eec566a5b9 <br> ds_guid : 0x00002b30 = (qword)0x6994c8e8b2452f06 <br> ds_flags : 0x00002b38 = (qword)0x0000000000000004 <br> ds_bp : 0x00002b40 = 0x01 <br> ds_next_clones_obj : 0x00002bc0 = (qword)0x0000000000000000 <br> ds_props_obj : 0x00002bc8 = (qword)0x0000000000000000 <br> ds_userrefs_obj : 0x00002bd0 = (qword)0x0000000000000000 <br> ds_pad[5] : 0x00002bd8 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> 0x00002b40 <br> [0x00002b40]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00002b40 = (qword)[ 0x0000000000000001, 0x0000000000000057 ] <br> blk_dva_1 : 0x00002b50 = (qword)[ 0x0000000000000001, 0x0000000000000058 ] <br> blk_dva_2 : 0x00002b60 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00002b70 = (qword)0x800b070f00000003 <br> blk_pad[2] : 0x00002b78 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00002b88 = (qword)0x0000000000000000 <br> blk_birth : 0x00002b90 = (qword)0x0000000000000038 <br> blk_fill : 0x00002b98 = (qword)0x0000000000000009 <br> blk_cksum : 0x00002ba0 = (qword)[ 0x0000000efd4a0466, 0x000005ded369f382, 0x00012e169b3aebd5, 0x00298598c4f3c9d9 ] <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/f1c/ae5/12a/f1cae512af35639a920d3dd445f56c4f.jpg" alt="image"><br>  Only this object stores data, then we will work with it. <br><br>  Save to file and unpack <br><br> <code># dd if=/tmp/test_disk bs=512 skip=8279 count=1 of=/tmp/os.dataset.bin.lz4 <br> # zdec os.dataset.bin.lz4 os.dataset.bin 2048 <br> Input: os.dataset.bin.lz4 <br> Output: os.dataset.bin <br> Out size: 2048 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 201 <br> Decompress result: 0 <br></code> <br>  Look at the contents of objset <br><br> <code># r2 os.dataset.bin <br> [0x00000000]&gt; pf [512].[192].qq[304].[512].[512]. os_type os_flags <br> os_type : 0x000002c0 = (qword)0x0000000000000002 <br> os_flags : 0x000002c8 = (qword)0x0000000000000001 <br> [0x00000000]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000000 = 0x0a <br> dn_indblkshift : 0x00000001 = 0x0e <br> dn_nlevels : 0x00000002 = 0x07 <br> dn_nblkptr : 0x00000003 = 0x03 <br> dn_bonustype : 0x00000004 = 0x00 <br> dn_checksum : 0x00000005 = 0x00 <br> dn_compress : 0x00000006 = 0x00 <br> dn_flags : 0x00000007 = 0x01 <br> dn_datablkszsec : 0x00000008 = 0x0020 <br> dn_bonuslen : 0x0000000a = 0x0000 <br> dn_pad2[4] : 0x0000000c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000010 = (qword)0x0000000000000000 <br> dn_used : 0x00000018 = (qword)0x0000000000002000 <br> dn_pad3[4] : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000000]&gt; s+0x40 <br> [0x00000040]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000040 = (qword)[ 0x0000000000000001, 0x000000000000010c ] <br> blk_dva_1 : 0x00000050 = (qword)[ 0x0000000000000001, 0x000000000000010d ] <br> blk_dva_2 : 0x00000060 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000070 = (qword)0x860a070f0000001f <br> blk_pad[2] : 0x00000078 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000088 = (qword)0x0000000000000000 <br> blk_birth : 0x00000090 = (qword)0x0000000000000038 <br> blk_fill : 0x00000098 = (qword)0x0000000000000009 <br> blk_cksum : 0x000000a0 = (qword)[ 0x0000001353eb3bd1, 0x000007c5fce654db, 0x000196a4bd5ee712, 0x00384d0db7501d91 ] <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/477/c53/661/477c53661ddf6657bded706b182f73a2.jpg" alt="image"><br><br>  This is a link to an indirect block of level 6; we will consistently dig to the zero level. <br><br>  <b>L6</b> <br> <code># dd if=/tmp/test_disk bs=512 skip=8460 count=1 of=/tmp/os.dataset.dnode.l6.bin.lz4 <br> # zdec os.dataset.dnode.l6.bin.lz4 os.dataset.dnode.l6.bin 16384 <br> Input: os.dataset.dnode.l6.bin.lz4 <br> Output: os.dataset.dnode.l6.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 150 <br> Decompress result: 0 <br> # r2 os.dataset.dnode.l6.bin <br> [0x00000000]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000000 = (qword)[ 0x0000000000000001, 0x00000000000000b6 ] <br> blk_dva_1 : 0x00000010 = (qword)[ 0x0000000000000001, 0x000000000000010b ] <br> blk_dva_2 : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000030 = (qword)0x850a070f0000001f <br> blk_pad[2] : 0x00000038 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000048 = (qword)0x0000000000000000 <br> blk_birth : 0x00000050 = (qword)0x0000000000000038 <br> blk_fill : 0x00000058 = (qword)0x0000000000000009 <br> blk_cksum : 0x00000060 = (qword)[ 0x00000012eaa1fd11, 0x000007989478980e, 0x00018c88e386c191, 0x0036c2a7102bf2c2 ] <br></code> <br><br>  <b>L5</b> <br> <code>[0x00000000]&gt; "? 0x400000/512 + 0x00000000000000b6" <br> 8374 0x20b6 020266 8.2K 0000:00b6 8374 "\xb6 " 0b0010000010110110 8374.0 8374.000000f 8374.000000 0t102111011 <br> # dd if=/tmp/test_disk bs=512 skip=8374 count=1 of=/tmp/os.dataset.dnode.l5.bin.lz4 <br> # zdec os.dataset.dnode.l5.bin.lz4 os.dataset.dnode.l5.bin 16384 <br> Input: os.dataset.dnode.l5.bin.lz4 <br> Output: os.dataset.dnode.l5.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 149 <br> Decompress result: 0 <br> # r2 os.dataset.dnode.l5.bin <br> [0x00000000]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000000 = (qword)[ 0x0000000000000001, 0x00000000000000b4 ] <br> blk_dva_1 : 0x00000010 = (qword)[ 0x0000000000000001, 0x00000000000000b5 ] <br> blk_dva_2 : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000030 = (qword)0x840a070f0000001f <br> blk_pad[2] : 0x00000038 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000048 = (qword)0x0000000000000000 <br> blk_birth : 0x00000050 = (qword)0x0000000000000038 <br> blk_fill : 0x00000058 = (qword)0x0000000000000009 <br> blk_cksum : 0x00000060 = (qword)[ 0x000000135bd403fd, 0x000007c79b2ed6a0, 0x0001969b589bf00e, 0x00383d2f2da4c77e ] <br></code> <br><br>  <b>L4</b> <br> <code>[0x00000000]&gt; "? 0x400000/512 + 0x00000000000000b4" <br> 8372 0x20b4 020264 8.2K 0000:00b4 8372 "\xb4 " 0b0010000010110100 8372.0 8372.000000f 8372.000000 0t102111002 <br> # dd if=/tmp/test_disk bs=512 skip=8372 count=1 of=/tmp/os.dataset.dnode.l4.bin.lz4 <br> # zdec os.dataset.dnode.l4.bin.lz4 os.dataset.dnode.l4.bin 16384 <br> Input: os.dataset.dnode.l4.bin.lz4 <br> Output: os.dataset.dnode.l4.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 150 <br> Decompress result: 0 <br> # r2 os.dataset.dnode.l4.bin <br> -- Execute a command every time a breakpoint is hit with 'e cmd.bp = !my-program' <br> [0x00000000]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000000 = (qword)[ 0x0000000000000001, 0x0000000000000081 ] <br> blk_dva_1 : 0x00000010 = (qword)[ 0x0000000000000001, 0x0000000000000082 ] <br> blk_dva_2 : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000030 = (qword)0x830a070f0000001f <br> blk_pad[2] : 0x00000038 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000048 = (qword)0x0000000000000000 <br> blk_birth : 0x00000050 = (qword)0x0000000000000038 <br> blk_fill : 0x00000058 = (qword)0x0000000000000009 <br> blk_cksum : 0x00000060 = (qword)[ 0x00000012cee6bcc2, 0x0000078b79b1c147, 0x000189aa5ace3a0a, 0x00365db1d10dc06e ] <br></code> <br><br>  <b>L3</b> <br> <code>[0x00000000]&gt; "? 0x400000/512 + 0x0000000000000081" <br> 8321 0x2081 020201 8.1K 0000:0081 8321 "\x81 " 0b0010000010000001 8321.0 8321.000000f 8321.000000 0t102102012 <br> # dd if=/tmp/test_disk bs=512 skip=8321 count=1 of=/tmp/os.dataset.dnode.l3.bin.lz4 <br> # zdec os.dataset.dnode.l3.bin.lz4 os.dataset.dnode.l3.bin 16384 <br> Input: os.dataset.dnode.l3.bin.lz4 <br> Output: os.dataset.dnode.l3.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 150 <br> Decompress result: 0 <br> # r2 os.dataset.dnode.l3.bin <br> -- Use the '[' and ']' keys in visual mode to adjust the screen width <br> [0x00000000]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000000 = (qword)[ 0x0000000000000001, 0x00000000000000ea ] <br> blk_dva_1 : 0x00000010 = (qword)[ 0x0000000000000001, 0x0000000000000080 ] <br> blk_dva_2 : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000030 = (qword)0x820a070f0000001f <br> blk_pad[2] : 0x00000038 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000048 = (qword)0x0000000000000000 <br> blk_birth : 0x00000050 = (qword)0x0000000000000038 <br> blk_fill : 0x00000058 = (qword)0x0000000000000009 <br> blk_cksum : 0x00000060 = (qword)[ 0x00000013d660f06c, 0x000007fd7a9a913f, 0x0001a28c7591888d, 0x003a04c5208f66a6 ] <br></code> <br><br>  <b>L2</b> <br> <code>[0x00000000]&gt; "? 0x400000/512 + 0x00000000000000ea" <br> 8426 0x20ea 020352 8.2K 0000:00ea 8426 "\xea " 0b0010000011101010 8426.0 8426.000000f 8426.000000 0t102120002 <br> # dd if=/tmp/test_disk bs=512 skip=8426 count=1 of=/tmp/os.dataset.dnode.l2.bin.lz4 <br> # zdec os.dataset.dnode.l2.bin.lz4 os.dataset.dnode.l2.bin 16384 <br> Input: os.dataset.dnode.l2.bin.lz4 <br> Output: os.dataset.dnode.l2.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 150 <br> Decompress result: 0 <br> # r2 os.dataset.dnode.l2.bin <br> [0x00000000]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000000 = (qword)[ 0x0000000000000001, 0x000000000000007e ] <br> blk_dva_1 : 0x00000010 = (qword)[ 0x0000000000000001, 0x00000000000000d8 ] <br> blk_dva_2 : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000030 = (qword)0x810a070f0000001f <br> blk_pad[2] : 0x00000038 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000048 = (qword)0x0000000000000000 <br> blk_birth : 0x00000050 = (qword)0x0000000000000038 <br> blk_fill : 0x00000058 = (qword)0x0000000000000009 <br> blk_cksum : 0x00000060 = (qword)[ 0x000000119de2c7aa, 0x00000700d12632b0, 0x000169e2d81be607, 0x00317850a78e8a46 ] <br></code> <br><br>  <b>L1</b> <br> <code>[0x00000000]&gt; "? 0x400000/512 + 0x000000000000007e" <br> 8318 0x207e 020176 8.1K 0000:007e 8318 "~ " 0b0010000001111110 8318.0 8318.000000f 8318.000000 0t102102002 <br> # dd if=/tmp/test_disk bs=512 skip=8318 count=1 of=/tmp/os.dataset.dnode.l1.bin.lz4 <br> # zdec os.dataset.dnode.l1.bin.lz4 os.dataset.dnode.l1.bin 16384 <br> Input: os.dataset.dnode.l1.bin.lz4 <br> Output: os.dataset.dnode.l1.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 512 <br> Real input size: 150 <br> Decompress result: 0 <br> # r2 os.dataset.dnode.l1.bin <br> [0x00000000]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000000 = (qword)[ 0x0000000000000002, 0x0000000000000105 ] <br> blk_dva_1 : 0x00000010 = (qword)[ 0x0000000000000002, 0x000000000000007c ] <br> blk_dva_2 : 0x00000020 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000030 = (qword)0x800a070f0001001f <br> blk_pad[2] : 0x00000038 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000048 = (qword)0x0000000000000000 <br> blk_birth : 0x00000050 = (qword)0x0000000000000038 <br> blk_fill : 0x00000058 = (qword)0x0000000000000009 <br> blk_cksum : 0x00000060 = (qword)[ 0x0000003e07b9461b, 0x00001c6526d2728c, 0x00097c6c15624af0, 0x0268557731d83b04 ] <br></code> <br><br>  <b>L0</b> <br> <code>[0x00000000]&gt; "? 0x400000/512 + 0x0000000000000105" <br> 8453 0x2105 020405 8.3K 0000:0105 8453 "\x05!" 0b0010000100000101 8453.0 8453.000000f 8453.000000 0t102121002 <br> # dd if=/tmp/test_disk bs=512 skip=8453 count=2 of=/tmp/os.dataset.dnode.l0.bin.lz4 <br> # zdec os.dataset.dnode.l0.bin.lz4 os.dataset.dnode.l0.bin 16384 <br> Input: os.dataset.dnode.l0.bin.lz4 <br> Output: os.dataset.dnode.l0.bin <br> Out size: 16384 <br> ----------------------------- <br> Input size: 1024 <br> Real input size: 1007 <br> Decompress result: 0 <br></code> <br>  Zero level is directly objset. <br><br>  Make a list of objects <br><br><div class="spoiler">  <b class="spoiler_title">9 objects</b> <div class="spoiler_text"> <code># r2 os.dataset.dnode.l0.bin <br> [0x00000000]&gt; s+0x200 <br> [0x00000200]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000200 = 0x15 <br> dn_indblkshift : 0x00000201 = 0x0e <br> dn_nlevels : 0x00000202 = 0x01 <br> dn_nblkptr : 0x00000203 = 0x03 <br> dn_bonustype : 0x00000204 = 0x00 <br> dn_checksum : 0x00000205 = 0x00 <br> dn_compress : 0x00000206 = 0x00 <br> dn_flags : 0x00000207 = 0x03 <br> dn_datablkszsec : 0x00000208 = 0x0001 <br> dn_bonuslen : 0x0000020a = 0x0000 <br> dn_pad2[4] : 0x0000020c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000210 = (qword)0x0000000000000000 <br> dn_used : 0x00000218 = (qword)0x0000000000000400 <br> dn_pad3[4] : 0x00000220 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000200]&gt; s+0x200 <br> [0x00000400]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000400 = 0x2d <br> dn_indblkshift : 0x00000401 = 0x0e <br> dn_nlevels : 0x00000402 = 0x01 <br> dn_nblkptr : 0x00000403 = 0x03 <br> dn_bonustype : 0x00000404 = 0x00 <br> dn_checksum : 0x00000405 = 0x00 <br> dn_compress : 0x00000406 = 0x00 <br> dn_flags : 0x00000407 = 0x03 <br> dn_datablkszsec : 0x00000408 = 0x0001 <br> dn_bonuslen : 0x0000040a = 0x0000 <br> dn_pad2[4] : 0x0000040c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000410 = (qword)0x0000000000000000 <br> dn_used : 0x00000418 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000420 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000400]&gt; s+0x200 <br> [0x00000600]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000600 = 0x16 <br> dn_indblkshift : 0x00000601 = 0x0e <br> dn_nlevels : 0x00000602 = 0x01 <br> dn_nblkptr : 0x00000603 = 0x03 <br> dn_bonustype : 0x00000604 = 0x00 <br> dn_checksum : 0x00000605 = 0x00 <br> dn_compress : 0x00000606 = 0x00 <br> dn_flags : 0x00000607 = 0x03 <br> dn_datablkszsec : 0x00000608 = 0x0001 <br> dn_bonuslen : 0x0000060a = 0x0000 <br> dn_pad2[4] : 0x0000060c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000610 = (qword)0x0000000000000000 <br> dn_used : 0x00000618 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000620 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000600]&gt; s+0x200 <br> [0x00000800]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000800 = 0x14 <br> dn_indblkshift : 0x00000801 = 0x0e <br> dn_nlevels : 0x00000802 = 0x01 <br> dn_nblkptr : 0x00000803 = 0x01 <br> dn_bonustype : 0x00000804 = 0x2c <br> dn_checksum : 0x00000805 = 0x00 <br> dn_compress : 0x00000806 = 0x00 <br> dn_flags : 0x00000807 = 0x03 <br> dn_datablkszsec : 0x00000808 = 0x0001 <br> dn_bonuslen : 0x0000080a = 0x00a8 <br> dn_pad2[4] : 0x0000080c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000810 = (qword)0x0000000000000000 <br> dn_used : 0x00000818 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000820 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000800]&gt; s+0x200 <br> [0x00000a00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000a00 = 0x2e <br> dn_indblkshift : 0x00000a01 = 0x0e <br> dn_nlevels : 0x00000a02 = 0x01 <br> dn_nblkptr : 0x00000a03 = 0x03 <br> dn_bonustype : 0x00000a04 = 0x00 <br> dn_checksum : 0x00000a05 = 0x00 <br> dn_compress : 0x00000a06 = 0x00 <br> dn_flags : 0x00000a07 = 0x03 <br> dn_datablkszsec : 0x00000a08 = 0x0003 <br> dn_bonuslen : 0x00000a0a = 0x0000 <br> dn_pad2[4] : 0x00000a0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000a10 = (qword)0x0000000000000000 <br> dn_used : 0x00000a18 = (qword)0x0000000000000400 <br> dn_pad3[4] : 0x00000a20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000a00]&gt; s+0x200 <br> [0x00000c00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000c00 = 0x2f <br> dn_indblkshift : 0x00000c01 = 0x0e <br> dn_nlevels : 0x00000c02 = 0x01 <br> dn_nblkptr : 0x00000c03 = 0x03 <br> dn_bonustype : 0x00000c04 = 0x00 <br> dn_checksum : 0x00000c05 = 0x00 <br> dn_compress : 0x00000c06 = 0x00 <br> dn_flags : 0x00000c07 = 0x03 <br> dn_datablkszsec : 0x00000c08 = 0x0020 <br> dn_bonuslen : 0x00000c0a = 0x0000 <br> dn_pad2[4] : 0x00000c0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000c10 = (qword)0x0000000000000001 <br> dn_used : 0x00000c18 = (qword)0x0000000000002000 <br> dn_pad3[4] : 0x00000c20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000c00]&gt; s+0x200 <br> [0x00000e00]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00000e00 = 0x13 <br> dn_indblkshift : 0x00000e01 = 0x0e <br> dn_nlevels : 0x00000e02 = 0x01 <br> dn_nblkptr : 0x00000e03 = 0x01 <br> dn_bonustype : 0x00000e04 = 0x2c <br> dn_checksum : 0x00000e05 = 0x00 <br> dn_compress : 0x00000e06 = 0x00 <br> dn_flags : 0x00000e07 = 0x02 <br> dn_datablkszsec : 0x00000e08 = 0x0001 <br> dn_bonuslen : 0x00000e0a = 0x00a8 <br> dn_pad2[4] : 0x00000e0c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00000e10 = (qword)0x0000000000000000 <br> dn_used : 0x00000e18 = (qword)0x0000000000000000 <br> dn_pad3[4] : 0x00000e20 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00000e00]&gt; s+0x200 <br> [0x00001000]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001000 = 0x13 <br> dn_indblkshift : 0x00001001 = 0x0e <br> dn_nlevels : 0x00001002 = 0x01 <br> dn_nblkptr : 0x00001003 = 0x01 <br> dn_bonustype : 0x00001004 = 0x2c <br> dn_checksum : 0x00001005 = 0x00 <br> dn_compress : 0x00001006 = 0x00 <br> dn_flags : 0x00001007 = 0x03 <br> dn_datablkszsec : 0x00001008 = 0x0001 <br> dn_bonuslen : 0x0000100a = 0x00a8 <br> dn_pad2[4] : 0x0000100c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001010 = (qword)0x0000000000000000 <br> dn_used : 0x00001018 = (qword)0x0000000000000200 <br> dn_pad3[4] : 0x00001020 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> [0x00001000]&gt; s+0x200 <br> [0x00001200]&gt; pf bbbbbbbbww[4]bqq[4]q dn_type dn_indblkshift dn_nlevels dn_nblkptr dn_bonustype dn_checksum dn_compress dn_flags dn_datablkszsec dn_bonuslen dn_pad2[4] dn_maxblkid dn_used dn_pad3[4] <br> dn_type : 0x00001200 = 0x13 <br> dn_indblkshift : 0x00001201 = 0x0e <br> dn_nlevels : 0x00001202 = 0x02 <br> dn_nblkptr : 0x00001203 = 0x01 <br> dn_bonustype : 0x00001204 = 0x2c <br> dn_checksum : 0x00001205 = 0x00 <br> dn_compress : 0x00001206 = 0x00 <br> dn_flags : 0x00001207 = 0x03 <br> dn_datablkszsec : 0x00001208 = 0x0001 <br> dn_bonuslen : 0x0000120a = 0x00a8 <br> dn_pad2[4] : 0x0000120c = [ 0x00, 0x00, 0x00, 0x00 ] <br> dn_maxblkid : 0x00001210 = (qword)0x0000000000000001 <br> dn_used : 0x00001218 = (qword)0x0000000000000800 <br> dn_pad3[4] : 0x00001220 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br></div></div><br><table width="600"><tbody><tr><td>  index </td><td>  dn_type </td><td></td><td>  dn_bonustype </td><td></td><td>  dn_bonuslen </td></tr><tr><td>  four </td><td>  0x14 </td><td>  DMU_OT_DIRECTORY_CONTENTS </td><td>  0x2c </td><td>  DMU_OT_SA </td><td>  0x00a8 </td></tr><tr><td>  7 </td><td>  0x13 </td><td>  DMU_OT_PLAIN_FILE_CONTENTS </td><td>  0x2c </td><td>  DMU_OT_SA </td><td>  0x00a8 </td></tr><tr><td>  eight </td><td>  0x13 </td><td>  DMU_OT_PLAIN_FILE_CONTENTS </td><td>  0x2c </td><td>  DMU_OT_SA </td><td>  0x00a8 </td></tr><tr><td>  9 </td><td>  0x13 </td><td>  DMU_OT_PLAIN_FILE_CONTENTS </td><td>  0x2c </td><td>  DMU_OT_SA </td><td>  0x00a8 </td></tr></tbody></table><br><br>  Objects 7, 8, 9 are our 0B, 512B, 513B files.  The number and file correspondence can be obtained from object 4 (DMU_OT_DIRECTORY_CONTENTS). <br><br>  <b>Consider object 4</b> <br> <code># r2 os.dataset.dnode.l0.bin <br> [0x00001400]&gt; 0x00000800 <br> [0x00000800]&gt; s+0x40 <br> [0x00000840]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000840 = (qword)[ 0x0100032143000000, 0x0cfd073129805300 ] <br> blk_dva_1 : 0x00000850 = (qword)[ 0x2e07121a00020f00, 0x4230220007801200 ] <br> blk_dva_2 : 0x00000860 = (qword)[ 0x08121700020f0008, 0x31353f004003002b ] <br> blk_prop : 0x00000870 = (qword)0x8014008f8c0001ff <br> blk_pad[2] : 0x00000878 = (qword)[ 0x0040091b1c004232, 0x00020f1c0040331f ] <br> blk_phys_birth : 0x00000888 = (qword)0x00000000000050e8 <br> blk_birth : 0x00000890 = (qword)0x0000000000000022 <br> blk_fill : 0x00000898 = (qword)0x0000000000000000 <br> blk_cksum : 0x000008a0 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br>  This is an embedded blkptr (bit E), the structure is different from the usual blkptr. <br><img src="https://habrastorage.org/getpro/habr/post_images/25f/420/abe/25f420abe4a8f180a7eb179c397b57cd.jpg" alt="image"><br><br>  Data is stored directly in the structure. <br><br> <code>[0x00000840]&gt; pf [48]bq[24]bq[40]b data_1 blk_prob data_2 txg data_3 <br> data_1 : 0x00000840 = [ 0x00, 0x00, 0x00, 0x43, 0x21, 0x03, 0x00, 0x01, 0x00, 0x53, 0x80, 0x29, 0x31, 0x07, 0xfd, 0x0c, 0x00, 0x0f, 0x02, 0x00, 0x1a, 0x12, 0x07, 0x2e, 0x00, 0x12, 0x80, 0x07, 0x00, 0x22, 0x30, 0x42, 0x08, 0x00, 0x0f, 0x02, 0x00, 0x17, 0x12, 0x08, 0x2b, 0x00, 0x03, 0x40, 0x00, 0x3f, 0x35, 0x31 ] <br> blk_prob : 0x00000870 = (qword)0x8014008f8c0001ff <br> data_2 : 0x00000878 = [ 0x32, 0x42, 0x00, 0x1c, 0x1b, 0x09, 0x40, 0x00, 0x1f, 0x33, 0x40, 0x00, 0x1c, 0x0f, 0x02, 0x00, 0xe8, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ] <br> txg : 0x00000890 = (qword)0x0000000000000022 <br> data_3 : 0x00000898 = [ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ] <br></code> <br><br>  <b>We consider this data in the file</b> <br>  Consistently copy 48 bytes and skip blk_prob (8 bytes) the remaining 23 bytes (the full size is taken from the PSIZE field). <br> <code># dd if=os.dataset.dnode.l0.bin of=/tmp/emb.bin.lz4 bs=1 count=48 skip=2112 <br> # dd if=os.dataset.dnode.l0.bin of=/tmp/emb.bin.lz4 bs=1 seek=48 count=23 skip=2168 <br> # zdec emb.bin.lz4 emb.bin 512 <br> Input: emb.bin.lz4 <br> Output: emb.bin <br> Out size: 512 <br> ----------------------------- <br> Input size: 71 <br> Real input size: 67 <br> Decompress result: 0 <br></code> <br> <code># r2 emb.bin <br> [0x00000000]&gt; pf qqq[5]qqxwz mz_block_type mz_salt mz_normflags mz_pad[5] mz_chunk[1]_mze_value mz_chunk[1]_mze_cd mz_chunk[1]_mze_pad mz_chunk[1]_mze_name <br> mz_block_type : 0x00000000 = (qword)0x8000000000000003 <br> mz_salt : 0x00000008 = (qword)0x00000003fd073129 <br> mz_normflags : 0x00000010 = (qword)0x0000000000000000 <br> mz_pad[5] : 0x00000018 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br> mz_chunk[1]_mze_value : 0x00000040 = (qword)0x8000000000000007 <br> mz_chunk[1]_mze_cd : 0x00000048 = 0x00000000 <br> mz_chunk[1]_mze_pad : 0x0000004c = 0x0000 <br> mz_chunk[1]_mze_name : 0x0000004e = 0B <br> [0x00000000]&gt; s+0x80 <br> [0x00000080]&gt; pf qxwz mze_value mze_cd mze_pad mze_name <br> mze_value : 0x00000080 = (qword)0x8000000000000008 <br> mze_cd : 0x00000088 = 0x00000000 <br> mze_pad : 0x0000008c = 0x0000 <br> mze_name : 0x0000008e = 512B <br> [0x00000080]&gt; s+0x40 <br> [0x000000c0]&gt; pf qxwz mze_value mze_cd mze_pad mze_name <br> mze_value : 0x000000c0 = (qword)0x8000000000000009 <br> mze_cd : 0x000000c8 = 0x00000000 <br> mze_pad : 0x000000cc = 0x0000 <br> mze_name : 0x000000ce = 513B <br></code> <br> <code>mze_value : 0x8000000000000007 <br> ZFS_DIRENT_TYPE : 8 // "? (0x8000000000000007&gt;60)&amp;((1&lt;4)-1)" // /* 8 */ "Regular File", <br> ZFS_DIRENT_OBJ : 7 // "? (0x8000000000000007&gt;0)&amp;((1&lt;48)-1)" // Object id <br></code> <br>  0B file is number 7 <br>  512B file is number 8 <br>  513B file is number 9 <br><br>  <b>Consider object 7</b> <br> <code># r2 os.dataset.dnode.l0.bin <br> [0x00000000]&gt; 0x00000e00 <br> [0x00000e00]&gt; s+0x40 <br> [0x00000e40]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00000e40 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_1 : 0x00000e50 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_2 : 0x00000e60 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00000e70 = (qword)0x0000000000000000 <br> blk_pad[2] : 0x00000e78 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00000e88 = (qword)0x0000000000000000 <br> blk_birth : 0x00000e90 = (qword)0x0000000000000000 <br> blk_fill : 0x00000e98 = (qword)0x0000000000000000 <br> blk_cksum : 0x00000ea0 = (qword)[ 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 ] <br></code> <br>  The file contains no data - blkptr is empty. <br><br>  <b>Consider object 8</b> <br> <code>[0x00000e40]&gt; 0x00001000 <br> [0x00001000]&gt; s+0x40 <br> [0x00001040]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00001040 = (qword)[ 0x0000000000000001, 0x00000000000000e9 ] <br> blk_dva_1 : 0x00001050 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_dva_2 : 0x00001060 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00001070 = (qword)0x8013070200000000 <br> blk_pad[2] : 0x00001078 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00001088 = (qword)0x0000000000000000 <br> blk_birth : 0x00001090 = (qword)0x0000000000000020 <br> blk_fill : 0x00001098 = (qword)0x0000000000000001 <br> blk_cksum : 0x000010a0 = (qword)[ 0x0000003c34e2ea5c, 0x00000f3db2d3ec9f, 0x00029bdcc6458734, 0x005654ddd2b56e82 ] <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/b07/180/b3d/b07180b3d527f2807617ae02c0680850.jpg" alt="image"><br><br>  The file occupies one sector on the disk, i.e.  512 bytes <br><br>  <b>Consider object 9</b> <br> <code>[0x00001040]&gt; 0x1200 <br> [0x00001200]&gt; s+0x40 <br> [0x00001240]&gt; pf [2]q[2]q[2]qq[2]qqqq[4]q blk_dva_0 blk_dva_1 blk_dva_2 blk_prop blk_pad[2] blk_phys_birth blk_birth blk_fill blk_cksum <br> blk_dva_0 : 0x00001240 = (qword)[ 0x0000000000000001, 0x000000000000009d ] <br> blk_dva_1 : 0x00001250 = (qword)[ 0x0000000000000001, 0x0000000000000059 ] <br> blk_dva_2 : 0x00001260 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_prop : 0x00001270 = (qword)0x8113070f0000001f <br> blk_pad[2] : 0x00001278 = (qword)[ 0x0000000000000000, 0x0000000000000000 ] <br> blk_phys_birth : 0x00001288 = (qword)0x0000000000000000 <br> blk_birth : 0x00001290 = (qword)0x0000000000000022 <br> blk_fill : 0x00001298 = (qword)0x0000000000000002 <br> blk_cksum : 0x000012a0 = (qword)[ 0x0000001427d4c96a, 0x000007e5038b685d, 0x000194254db44203, 0x0037093ef743abcc ] <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/f49/d81/8c0/f49d818c064392187a4b809c6fe8b6c0.jpg" alt="image"><br><br>  A file of 513 bytes in size does not fit completely into recordsize equal to 512 bytes and an indirect block is used to store it. <br>  The indirect block is stored in duplicate (blk_dva_0 and blk_dva_1). <br>  From here the sizes of files on a disk: <br>  0B: dnode (512B) = 512 bytes <br>  512B: dnode (512B) + file data (512B) = 1024 bytes <br>  513B: dnode (512B) + 2 * indirect blocks (512B) + 2 * file data (512B) = 2560 bytes <br><br><div class="spoiler">  <b class="spoiler_title">Program for unpacking the block compressed by the lz4 algorithm</b> <div class="spoiler_text">  It is a copy of the LZ4_uncompress_unknownOutputSize function from the <a href="">lz4.c</a> file <a href="">.</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;fstream&gt; #include &lt;cstdint&gt; #include &lt;cstring&gt; using namespace std; static int LZ4_uncompress_unknownOutputSize(const char *source, char *dest, int isize, int maxOutputSize); #define BE_IN8(xa) \ *((uint8_t *)(xa)) #define BE_IN16(xa) \ (((uint16_t)BE_IN8(xa) &lt;&lt; 8) | BE_IN8((uint8_t *)(xa)+1)) #define BE_IN32(xa) \ (((uint32_t)BE_IN16(xa) &lt;&lt; 16) | BE_IN16((uint8_t *)(xa)+2)) #define COMPRESSIONLEVEL 12 #define NOTCOMPRESSIBLE_CONFIRMATION 6 /* * * CPU Feature Detection */ /* 32 or 64 bits ? */ #if defined(_LP64) #define LZ4_ARCH64 1 #else #define LZ4_ARCH64 0 #endif /* * Little Endian or Big Endian? * Note: overwrite the below #define if you know your architecture endianess. */ #if defined(_BIG_ENDIAN) #define LZ4_BIG_ENDIAN 1 #else /* * Little Endian assumed. PDP Endian and other very rare endian format * are unsupported. */ #undef LZ4_BIG_ENDIAN #endif /* * Unaligned memory access is automatically enabled for "common" CPU, * such as x86. For others CPU, the compiler will be more cautious, and * insert extra code to ensure aligned access is respected. If you know * your target CPU supports unaligned memory access, you may want to * force this option manually to improve performance */ #if defined(__ARM_FEATURE_UNALIGNED) #define LZ4_FORCE_UNALIGNED_ACCESS 1 #endif /* * Illumos : we can't use GCC's __builtin_ctz family of builtins in the * kernel * Linux : we can use GCC's __builtin_ctz family of builtins in the * kernel */ #undef LZ4_FORCE_SW_BITCOUNT #if defined(__sparc) #define LZ4_FORCE_SW_BITCOUNT #endif /* * Compiler Options */ /* Disable restrict */ #define restrict /* * Linux : GCC_VERSION is defined as of 3.9-rc1, so undefine it. * torvalds/linux@3f3f8d2f48acfd8ed3b8e6b7377935da57b27b16 */ #ifdef GCC_VERSION #undef GCC_VERSION #endif #define GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__) #if (GCC_VERSION &gt;= 302) || (__INTEL_COMPILER &gt;= 800) || defined(__clang__) #define expect(expr, value) (__builtin_expect((expr), (value))) #else #define expect(expr, value) (expr) #endif #ifndef likely #define likely(expr) expect((expr) != 0, 1) #endif #ifndef unlikely #define unlikely(expr) expect((expr) != 0, 0) #endif #define lz4_bswap16(x) ((unsigned short int) ((((x) &gt;&gt; 8) &amp; 0xffu) | \ (((x) &amp; 0xffu) &lt;&lt; 8))) /* Basic types */ #define BYTE uint8_t #define U16 uint16_t #define U32 uint32_t #define S32 int32_t #define U64 uint64_t #ifndef LZ4_FORCE_UNALIGNED_ACCESS #pragma pack(1) #endif typedef struct _U16_S { U16 v; } U16_S; typedef struct _U32_S { U32 v; } U32_S; typedef struct _U64_S { U64 v; } U64_S; #ifndef LZ4_FORCE_UNALIGNED_ACCESS #pragma pack() #endif #define A64(x) (((U64_S *)(x))-&gt;v) #define A32(x) (((U32_S *)(x))-&gt;v) #define A16(x) (((U16_S *)(x))-&gt;v) /* * Constants */ #define MINMATCH 4 #define HASH_LOG COMPRESSIONLEVEL #define HASHTABLESIZE (1 &lt;&lt; HASH_LOG) #define HASH_MASK (HASHTABLESIZE - 1) #define SKIPSTRENGTH (NOTCOMPRESSIBLE_CONFIRMATION &gt; 2 ? \ NOTCOMPRESSIBLE_CONFIRMATION : 2) #define COPYLENGTH 8 #define LASTLITERALS 5 #define MFLIMIT (COPYLENGTH + MINMATCH) #define MINLENGTH (MFLIMIT + 1) #define MAXD_LOG 16 #define MAX_DISTANCE ((1 &lt;&lt; MAXD_LOG) - 1) #define ML_BITS 4 #define ML_MASK ((1U&lt;&lt;ML_BITS)-1) #define RUN_BITS (8-ML_BITS) #define RUN_MASK ((1U&lt;&lt;RUN_BITS)-1) /* * Architecture-specific macros */ #if LZ4_ARCH64 #define STEPSIZE 8 #define UARCH U64 #define AARCH A64 #define LZ4_COPYSTEP(s, d) A64(d) = A64(s); d += 8; s += 8; #define LZ4_COPYPACKET(s, d) LZ4_COPYSTEP(s, d) #define LZ4_SECURECOPY(s, d, e) if (d &lt; e) LZ4_WILDCOPY(s, d, e) #define HTYPE U32 #define INITBASE(base) const BYTE* const base = ip #else /* !LZ4_ARCH64 */ #define STEPSIZE 4 #define UARCH U32 #define AARCH A32 #define LZ4_COPYSTEP(s, d) A32(d) = A32(s); d += 4; s += 4; #define LZ4_COPYPACKET(s, d) LZ4_COPYSTEP(s, d); LZ4_COPYSTEP(s, d); #define LZ4_SECURECOPY LZ4_WILDCOPY #define HTYPE const BYTE * #define INITBASE(base) const int base = 0 #endif /* !LZ4_ARCH64 */ #if (defined(LZ4_BIG_ENDIAN) &amp;&amp; !defined(BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE)) #define LZ4_READ_LITTLEENDIAN_16(d, s, p) \ { U16 v = A16(p); v = lz4_bswap16(v); d = (s) - v; } #define LZ4_WRITE_LITTLEENDIAN_16(p, i) \ { U16 v = (U16)(i); v = lz4_bswap16(v); A16(p) = v; p += 2; } #else #define LZ4_READ_LITTLEENDIAN_16(d, s, p) { d = (s) - A16(p); } #define LZ4_WRITE_LITTLEENDIAN_16(p, v) { A16(p) = v; p += 2; } #endif /* Local structures */ struct refTables { HTYPE hashTable[HASHTABLESIZE]; }; /* Macros */ #define LZ4_HASH_FUNCTION(i) (((i) * 2654435761U) &gt;&gt; ((MINMATCH * 8) - \ HASH_LOG)) #define LZ4_HASH_VALUE(p) LZ4_HASH_FUNCTION(A32(p)) #define LZ4_WILDCOPY(s, d, e) do { LZ4_COPYPACKET(s, d) } while (d &lt; e); #define LZ4_BLINDCOPY(s, d, l) { BYTE* e = (d) + l; LZ4_WILDCOPY(s, d, e); \ d = e; } static int LZ4_uncompress_unknownOutputSize(const char *source, char *dest, int isize, int maxOutputSize) { /* Local Variables */ const BYTE *restrict ip = (const BYTE *) source; const BYTE *const iend = ip + isize; const BYTE *ref; BYTE *op = (BYTE *) dest; BYTE *const oend = op + maxOutputSize; BYTE *cpy; size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0}; #if LZ4_ARCH64 size_t dec64table[] = {0, 0, 0, (size_t)-1, 0, 1, 2, 3}; #endif /* Main Loop */ while (ip &lt; iend) { unsigned token; size_t length; /* get runlength */ token = *ip++; if ((length = (token &gt;&gt; ML_BITS)) == RUN_MASK) { int s = 255; while ((ip &lt; iend) &amp;&amp; (s == 255)) { s = *ip++; length += s; } } /* copy literals */ cpy = op + length; /* CORNER-CASE: cpy might overflow. */ if (cpy &lt; op) goto _output_error; /* cpy was overflowed, bail! */ if ((cpy &gt; oend - COPYLENGTH) || (ip + length &gt; iend - COPYLENGTH)) { if (cpy &gt; oend) /* Error: writes beyond output buffer */ goto _output_error; if (ip + length != iend) /* * Error: LZ4 format requires to consume all * input at this stage */ goto _output_error; (void) memcpy(op, ip, length); op += length; /* Necessarily EOF, due to parsing restrictions */ break; } LZ4_WILDCOPY(ip, op, cpy); ip -= (op - cpy); op = cpy; /* get offset */ LZ4_READ_LITTLEENDIAN_16(ref, cpy, ip); ip += 2; if (ref &lt; (BYTE * const) dest) /* * Error: offset creates reference outside of * destination buffer */ goto _output_error; /* get matchlength */ if ((length = (token &amp; ML_MASK)) == ML_MASK) { while (ip &lt; iend) { int s = *ip++; length += s; if (s == 255) continue; break; } } /* copy repeated sequence */ if (unlikely(op - ref &lt; STEPSIZE)) { #if LZ4_ARCH64 size_t dec64 = dec64table[op-ref]; #else const int dec64 = 0; #endif op[0] = ref[0]; op[1] = ref[1]; op[2] = ref[2]; op[3] = ref[3]; op += 4; ref += 4; ref -= dec32table[op-ref]; A32(op) = A32(ref); op += STEPSIZE - 4; ref -= dec64; } else { LZ4_COPYSTEP(ref, op); } cpy = op + length - (STEPSIZE - 4); if (cpy &gt; oend - COPYLENGTH) { if (cpy &gt; oend) /* * Error: request to write outside of * destination buffer */ goto _output_error; LZ4_SECURECOPY(ref, op, (oend - COPYLENGTH)); while (op &lt; cpy) *op++ = *ref++; op = cpy; if (op == oend) /* * Check EOF (should never happen, since * last 5 bytes are supposed to be literals) */ goto _output_error; continue; } LZ4_SECURECOPY(ref, op, cpy); op = cpy; /* correction */ } /* end of decoding */ return (int)(((char *)op) - dest); /* write overflow error detected */ _output_error: return (int)(-(((char *)ip) - source)); } /*ARGSUSED*/ int lz4_decompress_zfs(void *s_start, void *d_start, size_t s_len, size_t d_len, int n) { const char *src = (const char*) s_start; uint32_t bufsiz = BE_IN32(src); /* invalid compressed buffer size encoded at start */ if (bufsiz + sizeof (bufsiz) &gt; s_len) return (1); std::cout &lt;&lt; "Real input size: " &lt;&lt; bufsiz &lt;&lt; std::endl; /* * Returns 0 on success (decompression function returned non-negative) * and non-zero on failure (decompression function returned negative. */ return (LZ4_uncompress_unknownOutputSize(&amp;src[sizeof (bufsiz)], (char*)d_start, bufsiz, d_len) &lt; 0); } int main( int argc, char **argv ) { if (argc &lt; 4) { std::cout &lt;&lt; argv[0] &lt;&lt; " &lt;in&gt; &lt;out&gt; &lt;out_size&gt;" &lt;&lt; std::endl; return 1; } char* szInput = argv[1]; char* szOutput = argv[2]; int nOutSize = atoi(argv[3]); std::cout &lt;&lt; "Input: \t\t" &lt;&lt; szInput &lt;&lt; std::endl; std::cout &lt;&lt; "Output: \t" &lt;&lt; szOutput &lt;&lt; std::endl; std::cout &lt;&lt; "Out size: \t" &lt;&lt; nOutSize &lt;&lt; std::endl; std::cout &lt;&lt; "-----------------------------" &lt;&lt; std::endl; // READ INPUT fstream fs(szInput, fstream::in); if (!fs.is_open()) { std::cout &lt;&lt; "Open error"; return 1; } fs.seekg(0, ios::end); int fileSize = fs.tellg(); std::cout &lt;&lt; "Input size: \t" &lt;&lt; fileSize &lt;&lt; std::endl; char* src = new char[fileSize]; fs.seekg(0, ios::beg); fs.read(src, fileSize); if (!fs) { std::cout &lt;&lt; "error: only " &lt;&lt; fs.gcount() &lt;&lt; " could be read"; fs.close(); return 1; } fs.close(); // END READ INPUT // DECOMPRESS char* dst = new char[nOutSize]; std::memset(dst, 0, nOutSize); int nRes = lz4_decompress_zfs(src, dst, fileSize, nOutSize, 0); std::cout &lt;&lt; "Decompress result: " &lt;&lt; nRes &lt;&lt; std::endl; if (nRes) { std::cout &lt;&lt; "Decompress error" &lt;&lt; std::endl; // return 1; } // END DECOMPRESS // OUTPUT fstream out(szOutput, fstream::out); if (!out.is_open()) { std::cout &lt;&lt; "Open error"; return 1; } out.write(dst, nOutSize); if (!out) { std::cout &lt;&lt; "error: only " &lt;&lt; out.gcount() &lt;&lt; " could be write"; out.close(); return 1; } out.close(); // END OUTPUT delete[] src; delete[] dst; return 0; }</span></span></span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/348354/">https://habr.com/ru/post/348354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348344/index.html">Leakpocalypse: Rust can surprise unpleasantly</a></li>
<li><a href="../348346/index.html">New industry requirements: Certification Centers stop issuing 3-year SSL certificates from March 1, 2018</a></li>
<li><a href="../348348/index.html">It is dangerous to use EDS in Kazakhstan</a></li>
<li><a href="../348350/index.html">Updating strings on the fly in mobile apps: part 2</a></li>
<li><a href="../348352/index.html">How to work with Jira plugin from ScriptRunner or how to avoid code duplication</a></li>
<li><a href="../348356/index.html">Transition from AngularJS to Angular: goals, plans and rules for transferring elements (1/3)</a></li>
<li><a href="../348358/index.html">10 Gigabit Ethernet: Newbie Tips</a></li>
<li><a href="../348360/index.html">OpenVPN OSPF between two servers, multiple tunnels</a></li>
<li><a href="../348362/index.html">Where in Siberia to talk about IT</a></li>
<li><a href="../348364/index.html">BitPaymer (FriedEx) coder created by Dridex banker trojan authors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>