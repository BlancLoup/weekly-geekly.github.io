<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Amazon Cloud Services and Investment Portfolio Analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, there has been high volatility in stock markets, when, for example, a stable paper of a well-known company can lose several percent at once ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Amazon Cloud Services and Investment Portfolio Analysis</h1><div class="post__text post__text-html js-mediator-article">  Recently, there has been high volatility in stock markets, when, for example, a stable paper of a well-known company can lose several percent at once on the news of sanctions against its leadership or, on the contrary, fly to the skies on a positive report and investors' expectations about super-profit dividends. <br><br>  How to determine whether the ownership of this security brought in income or only loss and disappointment? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q3/2q/zs/q32qzs8fmzzpilpnbmfcek6l57a.png"></div>  <a href="https://www.vecteezy.com/">(A source)</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I will tell you how to determine and visualize the adjusted financial result for securities. <br><br>  Using the example of Client Reporting Opening Broker, we consider parsing and consolidating brokerage reports for the stock market, building a cloud reporting system architecture followed by simple and convenient analysis in AWS Quicksight. <br><a name="habracut"></a><br><h2>  Task Description </h2><br>  Many trainings and training lessons tell us about the need to maintain a trading journal, which records all the parameters of the transaction for further analysis and summarizing the work of the trading strategy.  I agree that such an approach to work on the Exchange allows you to discipline a trader, to increase his awareness, but it can also be great to tire out the tedious process. <br><br>  I admit, at first I tried carefully to follow the advice of keeping a journal, meticulously wrote down every transaction with its parameters in an Excel spreadsheet, built some reports, summary diagrams, planned future deals, but ... I quickly got tired of it all. <br><br><div class="spoiler">  <b class="spoiler_title">Why keeping a trader's manual journal is inconvenient?</b> <div class="spoiler_text"><ul><li>  manual filling of the journal (even using partial automation, in the form of unloading transactions from the trading terminal for the day) quickly tires; </li><li>  there is a high risk of errors or typographical errors during manual input; </li><li>  it may happen that the active trader becomes a passive investor and he returns to this magazine less and less, and then forgets about him at all (my case);  well finally </li><li>  we can program, why not take advantage of this and not automate the whole process?  So, drove! </li></ul></div></div><br>  Often, brokerage companies are high-tech organizations that provide their clients with fairly high-quality analytics on virtually all issues of interest.  It is fair to say that with each update this reporting gets better and better, but even the most advanced of them may not have the customization and consolidation that demanding and inquisitive customers want to see. <br><br>  For example, Opening Broker allows you to receive brokerage reports in XML format in your account, but if you have an IIS and a normal brokerage account on the Moscow Stock Exchange (MOEX), these will be two different reports, and if you still have an account on St. Petersburg Petersburg Stock Exchange (SPB), then one more will be added to the first two. <br><br>  So, to get a consolidated investor log, you will need to process three files in XML format. <br><br>  The above reports on MOEX and SPB differ slightly in their formats, which will need to be taken into account in the implementation of the data mapping. <br><br><h2>  The architecture of the developed system </h2><br>  The diagram below shows the architecture model of the system being developed: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/uq/ed/vvuqedfvl-l8tnghx3v6vtujabc.jpeg"></div><br><h2>  Parser implementation </h2><br>  We will receive reports on all three accounts in the My Account for the maximum possible period (can be divided into several reports for each year), save them in XML format and put them in one folder.  As a test data for the study, we will use a fictional client portfolio, but with the most approximate parameters to market realities. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/og/ig/xw/ogigxw4yganahuuzbdqecsbqmry.png"></div><br>  Suppose that the investor Mr. X we are considering has a small portfolio of five securities: <br><br><ol><li>  The report on the stock exchange SPB will be two papers: Apple and Microsoft; </li><li>  In the report on the stock exchange MOEX (brokerage) one paper: FGC UES; </li><li>  The report on the stock exchange MOEX (IIS) two papers: MMK and OFZ 24019; </li></ol><br>  According to our five papers, there may be buy / sell transactions, dividend and coupon payments, prices may change, etc.  We want to see the current situation, namely: the financial result, taking into account all payments, transactions and current market value. <br><br>  And here comes Python, we read information from all reports into one array: <br><br><pre><code class="python hljs">my_files_list = [join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listdir(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isfile(join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f))] my_xml_data = [] <span class="hljs-comment"><span class="hljs-comment">#     for f in my_files_list: tree = ET.parse(f) root = tree.getroot() my_xml_data.append(root)</span></span></code> </pre> <br><blockquote>  For analytics, we need several entities from the reports, namely: <br><br><ul><li>  Positions of securities in the portfolio; </li><li>  Concluded transactions; </li><li>  Non-trading operations and other movements on the account; </li><li>  Average prices of open positions </li></ul></blockquote>  In order to prepare the sample, we will use four dictionaries to describe the above sets. <br><br><pre> <code class="python hljs">dict_stocks = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost_rub'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'saldo'</span></span> : []} dict_deals = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'quantity'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'price'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'brokerage'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: []} dict_flows = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: []} dict_avg_price = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'avg_open_price'</span></span> : []}</code> </pre> <br>  A few words about what these dictionaries are. <br><br><div class="spoiler">  <b class="spoiler_title">Dictionary dict_stocks</b> <div class="spoiler_text">  The dict_stocks dictionary is needed to store general information on a portfolio: <br><br><ul><li>  Paper name (stock_name); </li><li>  Account name (SPB, MOEX BROK, MOEX IIS) (account); </li><li>  The currency used to settle this paper (currency); </li><li>  Current value (at the time of the report in the Personal Account Opening Broker) (current_cost).  Here I want to note that for demanding customers, in the future, you can make additional refinement and use dynamic receipt of a security quotation from the trading terminal or from the website of the corresponding stock exchange; </li><li>  The current value of the position of the security at the time of reporting (current_cost_rub) <br>  Similar to the above item, here you can also receive the current rate of the Central Bank or the exchange rate, as you like. </li><li>  Current balance of securities (saldo) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dictionary dict_deals</b> <div class="spoiler_text">  The dict_deals dictionary is needed to store the following information on completed transactions: <br><br><ul><li>  Paper name (stock_name); </li><li>  Account name (SPB, MOEX BROK, MOEX IIS) (account); </li><li>  The date of the transaction, i.e.  T0 (date_oper); </li><li>  Type of operation (type_oper); </li><li>  The volume of securities involved in the transaction (quantity); </li><li>  The price at which the transaction was executed (price); </li><li>  The currency in which the operation was performed (currency); </li><li>  Brokerage commission for the transaction (brokerage); </li><li>  Financial result of the transaction (result) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dict_flows dictionary</b> <div class="spoiler_text">  The dict_flows dictionary reflects the movement of funds in a client account and is used to store the following information: <br><br><ul><li>  Paper name (stock_name); </li><li>  Account name (SPB, MOEX BROK, MOEX IIS) (account); </li><li>  The date of the transaction, i.e.  T0 (date_oper); </li><li>  Type of operation (type_oper).  It can take several values: div, NKD, tax; </li><li>  The currency in which the operation was performed (currency); </li><li>  Financial result of the operation (result) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dictionary dict_avg_price</b> <div class="spoiler_text">  The dict_avg_price dictionary is required to account for information on the average purchase price for each paper: <br><br><ul><li>  Paper name (stock_name); </li><li>  Account name (SPB, MOEX BROK, MOEX IIS) (account); </li><li>  Average open position price (avg_open_price) </li></ul></div></div><br>  We process an array of XML documents and fill these dictionaries with the appropriate data: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       for XMLdata in my_xml_data: #      exchange_name = 'SPB' if XMLdata.get('board_list') == ' ' else 'MOEX' client_code = XMLdata.get('client_code') account_name = get_account_name(exchange_name, client_code) #   current_position, deals, flows, stock_name, \ saldo, ticketdate, price, brokerage, \ operationdate, currency, \ current_cost, current_cost_rub, \ stock_name_deal, payment_currency, currency_flows = get_allias(exchange_name) #      get_briefcase(XMLdata) df_stocks = pd.DataFrame(dict_stocks) df_stocks.set_index("stock_name", drop = False, inplace = True) #    get_deals(XMLdata) df_deals = pd.DataFrame(dict_deals) df_avg = pd.DataFrame(dict_avg_price) #       get_nontrade_operation(XMLdata) df_flows = pd.DataFrame(dict_flows)</span></span></code> </pre> <br>  All processing is looped through all the XML data from the reports.  Information about the trading platform, client code is the same in all reports, so you can safely extract it from the same tags without using mapping. <br><br>  But then you have to apply a special construction that will provide the necessary alias for the tag based on the report (SPB or MOEX), since  the same data in these reports are called differently. <br><br><div class="spoiler">  <b class="spoiler_title">Discrepancies in tags</b> <div class="spoiler_text"><ul><li>  The broker's transaction commission in the SBP report is in the <b>brokerage</b> tag, and in the MOEX report - <b>broker_commission</b> ; </li><li>  The date of the non-trading account transaction in the SPB report is the <b>operationdate</b> , and in MOEX the <b>operation_date</b> , etc. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Sample Tag Mapping</b> <div class="spoiler_text"><pre> <code class="python hljs">tags_mapping = { <span class="hljs-string"><span class="hljs-string">'SPB'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'briefcase_position'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'closed_deal'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'nontrade_money_operation'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'issuername'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currencycode'</span></span> }, <span class="hljs-string"><span class="hljs-string">'MOEX'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_assets'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_main_deals_conclusion'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_non_trade_money_operations'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'security_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'price_currency_code'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currency_code'</span></span> } }</code> </pre></div></div><br>  The get_allias function returns the name of the required tag for processing, taking as input the name of the trading platform: <br><br><div class="spoiler">  <b class="spoiler_title">Get_allias function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_allias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'current_position'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'deals'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'flows'</span></span>], ... tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>] )</code> </pre></div></div><br>  The function get_briefcase is responsible for processing information about the state of the client portfolio: <br><br><div class="spoiler">  <b class="spoiler_title">Get_briefcase function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#         briefcase_position briefcase_position = XMLdata.find(current_position) if not briefcase_position: return try: for child in briefcase_position: stock_name_reduce = child.get(stock_name).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_stocks['stock_name'].append(stock_name_reduce) dict_stocks['account'].append(account_name) dict_stocks['currency'].append(child.get(currency)) dict_stocks['current_cost'].append(float(child.get(current_cost))) dict_stocks['current_cost_rub'].append(float(child.get(current_cost_rub))) dict_stocks['saldo'].append(float(child.get(saldo))) except Exception as e: print('get_briefcase --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Further, using the get_deals function, information about transactions is extracted: <br><br><div class="spoiler">  <b class="spoiler_title">Get_deals function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_deals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> stock_name_proc = <span class="hljs-string"><span class="hljs-string">''</span></span> closed_deal = XMLdata.find(deals) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> closed_deal: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">#   SPB    -    , #    MOEX:  ,      #    : if exchange_name == 'SPB': sortchildrenby(closed_deal, stock_name_deal) for child in closed_deal: sortchildrenby(child, stock_name_deal) try: for child in closed_deal: stock_name_reduce = child.get(stock_name_deal).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_deals['stock_name'].append(stock_name_reduce) dict_deals['account'].append(account_name) dict_deals['date_oper'].append(to_dt(child.get(ticketdate)).strftime('%Y-%m-%d')) current_cost = get_current_cost(stock_name_reduce) #    SPB     - quantity, #   MOEX  : buy_qnty  sell_qnty if exchange_name == 'MOEX': if child.get('buy_qnty'): quantity = float(child.get('buy_qnty')) else: quantity = - float(child.get('sell_qnty')) else: quantity = float(child.get('quantity')) dict_deals['quantity'].append(quantity) dict_deals['price'].append(float(child.get('price'))) dict_deals['type_oper'].append('deal') dict_deals['currency'].append(child.get(payment_currency)) brok_comm = child.get(brokerage) if brok_comm is None: brok_comm = 0 else: brok_comm = float(brok_comm) dict_deals['brokerage'].append(float(brok_comm)) #         if stock_name_proc != stock_name_reduce: if stock_name_proc != '': put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] stock_name_proc = stock_name_reduce pnl = PnlSnapshot(stock_name_proc, float(child.get('price')), quantity) dict_deals['result'].append(-1 * brok_comm) else: pnl.update_by_tradefeed(float(child.get('price')), quantity) #  ,   if quantity &lt; 0: if pnl.m_realized_pnl &gt; 0 and exchange_name != 'SPB': pnl_sum = pnl.m_realized_pnl * 0.87 - brok_comm else: pnl_sum = pnl.m_realized_pnl - brok_comm dict_deals['result'].append(float(pnl_sum)) else: pnl.update_by_marketdata(current_cost) dict_deals['result'].append(-1 * brok_comm) put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] except Exception as e: print('get_deals --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  In addition to processing an array with information about the parameters of the transaction, it also calculates the average price of an open position and the PNL realized by the FIFO method.  Responsible for this calculation is the PnlSnapshot class, for the creation of which, with minor modifications, the code presented here is taken as the basis: <a href="https://lichgo.github.io/2015/10/29/40-lines-pnl-calculation.html">P &amp; L calculation</a> <br><br>  And finally, the most difficult to implement - the function of obtaining information about non-trading operations - <b>get_nontrade_operation</b> .  Its complexity lies in the fact that in the report block used for non-trading operations, there is no clear information about the type of operation and the security to which this operation is linked. <br><br><div class="spoiler">  <b class="spoiler_title">Example of payment purposes for non-trading operations</b> <div class="spoiler_text">  Payment of dividends or accrued coupon income may be indicated as follows: <br><br><ol><li>  Payment of client income &lt;777777&gt; <font color="#cc0000">dividends</font> &lt; <font color="#cc0000">APPLE</font> INC-ao&gt; -&gt; payment of dividends from the SPB report; </li><li>  Payment of client income &lt;777777&gt; <font color="#cc0000">dividends</font> &lt; <font color="#cc0000">MICROSOFT</font> COM-ao&gt; </li><li>  Payment of client income 777777i (NKD 2 <font color="#cc0000">OFZ 24019</font> ) withholding tax 0.00 rubles -&gt; coupon payment from the MOEX report; </li><li>  Payment of client income 777777 <font color="#cc0000">dividends of FGC UES -</font> ao tax to withholding XX.XX rubles -&gt; payment of dividends from the MOEX report.  etc. </li></ol></div></div><br>  Accordingly, it will be difficult to do without regular expressions, therefore we will use them to the full.  The other side of the question is that the name of the company does not always coincide with the name in the portfolio or in the transactions.  Therefore, the received name of the issuer from the purpose of payment should be additionally correlated with the dictionary.  As a dictionary, we will use an array of transactions, since  There is the most comprehensive list of companies. <br><br>  The function <b>get_company_from_str</b> extracts the name of the issuer from the comment: <br><br><div class="spoiler">  <b class="spoiler_title">Get_company_from_str function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comment)</span></span></span><span class="hljs-function">:</span></span> company_name = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-comment"><span class="hljs-comment">#    / flows_pattern = [ '^.+\s&lt;(\w+)?.+-&gt;$', '^.+\s(.+)-.+$', '^.+\(\s\d?\s(.+)\).+$', '^.+\s(.+)-.+$' ] for pattern in flows_pattern: match = re.search(pattern, comment) if match: return match.group(1).upper() return company_name</span></span></code> </pre> </div></div><br>  The function <b>get_company_from_briefcase</b> brings the name of the company to the dictionary, if it finds a match among the companies that participated in the transactions: <br><br><div class="spoiler">  <b class="spoiler_title">Get_company_from_briefcase function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(company_name)</span></span></span><span class="hljs-function">:</span></span> company_name_full = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> value_from_dic = df_deals[df_deals[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].str.contains(company_name)] company_arr = value_from_dic[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].unique() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(company_arr) == <span class="hljs-number"><span class="hljs-number">1</span></span>: company_name_full = company_arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> company_name_full</code> </pre> <br></div></div><br>  And finally, the final data collection function for non-trading operations is <b>get_nontrade_operation</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Get_nontrade_operation function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nontrade_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> nontrade_money_operation = XMLdata.find(flows) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> nontrade_money_operation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nontrade_money_operation: comment = child.get(<span class="hljs-string"><span class="hljs-string">'comment'</span></span>) type_oper_match = re.search(<span class="hljs-string"><span class="hljs-string">'||^.+.+.+$'</span></span>, comment) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type_oper_match: company_name = get_company_from_str(comment) type_oper = get_type_oper(comment) dict_flows[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].append(company_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'account'</span></span>].append(account_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>].append(to_dt(child.get(operationdate)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>)) dict_flows[<span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>].append(type_oper) dict_flows[<span class="hljs-string"><span class="hljs-string">'result'</span></span>].append(float(child.get(<span class="hljs-string"><span class="hljs-string">'amount'</span></span>))) dict_flows[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>].append(child.get(currency_flows)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'get_nontrade_operation --&gt; Oops! It seems we have a BUG!'</span></span>, e)</code> </pre> </div></div><br>  The result of collecting data from reports will be three DataFrame, which are approximately the following: <br><br><ol><li>  DataFrame with information on average prices of open positions: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1o/c-/qs/1oc-qs_akl5cvraaq7sg7pvfwfu.png"></div></li><li>  Transaction Information DataFrame: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/lp/xb/gqlpxby2utfl0ahr-fm8l_fqywc.png"></div></li><li>  DataFrame with information about non-trading operations: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/-7/su/hx-7suk1zgheyiyr6ov6o0z5yd0.png"></div><br></li></ol><br>  So, all we have to do is perform the external merging of the table of transactions with the table of information about the portfolio: <br><br><pre> <code class="python hljs">df_result = pd.merge(df_deals, df_stocks_avg, how=<span class="hljs-string"><span class="hljs-string">'outer'</span></span>, on=[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency'</span></span>]).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/wj/nz/jowjnzmldhgscs30ynz5lrdcueu.png"></div><br>  And, finally, the final part of the data array processing is the merging of the data array obtained at the previous step with the DataFrame for non-trade transactions. <br>  The result of the work done is one large flat table with all the necessary information for the analysis: <br><br><pre> <code class="python hljs">df_result_full = df_result.append(df_flows, ignore_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result_full.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>).head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jc/rh/ccjcrh4dq5auyrg3jba6csb_s0g.png"></div><br>  The resulting data set (Final Report) from the DataFrame is easily downloaded to CSV and can then be used for detailed analysis in any BI system. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exists(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>): makedirs(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>) report_name = <span class="hljs-string"><span class="hljs-string">'OUTPUT\my_trader_diary.csv'</span></span> df_result_full.to_csv(report_name, index = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8-sig'</span></span>)</code> </pre> <br><br><h2>  Loading and processing data in AWS </h2><br>  Progress does not stand still, and now cloud services and serverless computing models are gaining great popularity in processing and storing data.  This is largely due to the simplicity and cheapness of this approach, when building an architecture for complex computing or processing big data does not require buying expensive equipment, and you only rent power for the cloud you need and deploy the necessary resources quickly enough for a relatively small fee. . <br><br>  One of the largest and most well-known cloud technology providers on the market is Amazon.  Consider the example of the Amazon Web Services (AWS) environment, building an analytical system for processing data on our investment portfolio. <br><br>  AWS has an extensive selection of tools, but we will use the following: <br><br><ul><li>  <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/Welcome.html">Amazon S3</a> - object storage, which allows you to store almost unlimited amounts of information; </li><li>  <a href="https://docs.aws.amazon.com/glue/latest/dg/what-is-glue.html">AWS Glue</a> is the most powerful ETL cloud service that can itself determine the structure and generate the ETL code from the given source data; </li><li>  <a href="https://docs.aws.amazon.com/athena/latest/ug/what-is.html">Amazon Athena</a> is a serverless online SQL query service that allows you to quickly analyze data from S3 without much preparation.  He also has access to the metadata that AWS Glue prepares, which makes it possible to access the data immediately after passing the ETL; </li><li>  <a href="https://docs.aws.amazon.com/quicksight/latest/user/welcome.html">Amazon QuickSight</a> is a serverless BI service, you can build any visualization, analytical reports on the fly, etc. </li></ul><br>  With Amazon's documentation, everything is in order, in particular, there is a good article <a href="https://docs.aws.amazon.com/athena/latest/ug/glue-best-practices.html">Best Practices When Using Athens with AWS Glue</a> , which describes how to create and use tables and data using AWS Glue.  Let us and we will use the main ideas of this article and apply them to create our own architecture of the analytical reporting system. <br><br>  CSV files prepared by our report parser will be added to the S3 bucket.  It is planned that the corresponding folder on S3 will be replenished every Saturday - at the end of the trading week, so we can not do without data partitioning by the date of the formation and processing of the report. <br>  In addition to optimizing the work of SQL queries to such data, this approach will allow us to conduct additional analysis, for example, to obtain the dynamics of changes in the financial result for each paper, etc. <br><br><div class="spoiler">  <b class="spoiler_title">Work with Amazon S3</b> <div class="spoiler_text"><ul><li>  Create a bake on S3, let's call it ‚Äúreport-parser‚Äù; </li><li>  In this report-parser batch we will create a folder called my_trader_diary; </li><li>  In the ‚Äúmy_trader_diary‚Äù directory, create a directory with the current report date, for example, ‚Äúdate_report = 2018-10-01‚Äù and place a CSV file in it; </li><li>  Just for the sake of experiment and a better understanding of sectioning, we will create two more directories: "date_report = 2018-09-27" and "date_report = 2018-10-08".  In them we put the same CSV file; </li><li>  The final S3 bakery ‚Äúreport-parser‚Äù should look like the one shown in the pictures below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n1/4z/c9/n14zc9odchiv6l-_dpc_qbs3s_o.png"></div></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Work with AWS Glue</b> <div class="spoiler_text">  By and large, you can get by just Amazon Athena to create an external table from the data lying on S3, but AWS Glue is a more flexible and convenient tool for this. <br><br><ul><li>  We go to AWS Glue and create a new Crawler, which will be from a separate CSV files for the reporting dates to collect one table: <br><ul><li>  Set the name of the new Crawler; </li><li>  Specify the repository where to get the data from (s3: // report-parser / my_trader_diary /) </li><li>  Choose or create a new IAM role that will have access to launch the Crawler and access to the specified resource on S3; </li><li>  Next, you need to set the start frequency.  For now, we put on demand, but in the future, I think this will change and the launch will be weekly; </li><li>  Save and wait for the Crawler to be created. </li></ul></li><li>  When the Crawler enters the Ready state, launch it! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/xx/z9/edxxz9kurfrebky5-fuaqwzt-0e.png"></div></li><li>  Once it‚Äôs done, a new my_trader_diary table will appear in the AWS Glue: Database -&gt; Tables tab: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u6/2n/rt/u62nrttephj6m-hxxguky4il6os.png"></div></li></ul></div></div><br>  Consider the generated table in more detail. <br>  If you click on the name of the created table, we will go to the page with the description of the metadata.  At the bottom there is a table diagram and the most recent is a column that was not in the original CSV file - date_report.  Glue creates this AWS column automatically based on the definition of the source data sections (in the S3 batch, we specifically named folders - date_report = YYYY-MM-DD, which made it possible to use them as partitions divided by date). <br><br><div class="spoiler">  <b class="spoiler_title">Table partitioning</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/30/2v/5o302vb08y_zmylnfyaiign5us0.png"></div><br>  On the same page in the upper right corner there is a button View partitions, by clicking on which we can see which sections our formed table consists of: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/82/0l/kk/820lkk4mytj34kzh0tt__ieb6me.png"></div></div></div><br><h2>  Data analysis </h2><br>  Having at our disposal downloaded processed data, we can easily proceed to their analysis.  First, let's look at the features of Amazon Athena as the easiest and fastest way to perform analytical queries.  To do this, go to the Amazon Athena service, select the database we need (financial) and write the following SQL code: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d.date_report, d.account, d.stock_name, d.currency, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.quantity) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> quantity, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.result), <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_trader_diary d <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.date_report, d.account, d.stock_name, d.currency <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.account, d.stock_name, d.date_report;</code> </pre> <br>  This query will give us the net financial result for each paper for all reporting dates.  Since  we have downloaded the same report three times for different dates, and the result will not change, which, of course, in the real market conditions will be different: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9o/fg/dl/9ofgdloafbrxbvctdyprolilvna.png"></div><br>  But what if we want to visualize the data in the form of flexible tables or charts?  This is where Amazon QuickSight comes to the rescue, with which you can set up flexible analytics almost as quickly as writing a SQL query.  Let's go to Amazon QuickSight (if you haven't registered there yet, then registration is required). <br><br>  Click on the button New analyses -&gt; New dataset and in the appeared source selection window for dataset, click on Athena: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kr/bv/yqkrbv144qas16af4jolsj3rnci.png"></div><br><br>  We will invent a name for our data source, for example, ‚ÄúPNL_analysis‚Äù and click on the ‚ÄúCreate data source‚Äù button. <br><br>  Next, the Choose your table window will open, where you need to select a database and a data source table.  Choose a database - financial, and a table in it: my_traider_diary.  By default, the entire table is used, but when ‚ÄúUse custom SQL‚Äù is selected, you can customize and fine-tune the data selection you need.  For example, let's use the entire table and click on the Edit / Preview Data button. <br><br>  A new page will open where you can make additional settings and process the available data. <br><br>  Now it is necessary to add additional calculated fields to our dataset: quarter and year of the operation.  An attentive reader may notice that such manipulations were easier to do on the side of the parser before saving the Final Report to CSV.  Undoubtedly, my goal now is to demonstrate the capabilities and flexibility of setting up a BI system on the fly.  Continue the creation of calculated fields by clicking on the "New field" button. <br><br><div class="spoiler">  <b class="spoiler_title">Creating a new field</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ax/1z/ag/ax1zagyy7nnryd62t5najdntcio.png"></div></div></div><br>  To select the year of the operation and the quarter, simple formulas are used: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/yc/bi/pmycbiybxqtus62nkaa_5v2fu4s.png"></div><br><div class="spoiler">  <b class="spoiler_title">Filling the formulas for the new field</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uo/e1/u1/uoe1u1uco3ygn7cljsr6qcnhwbk.png"></div></div></div><br>  When the calculated fields are successfully created and added to the sample, we give the name to our dataset, for example, ‚Äúmy_pnl_analyze‚Äù and click on the ‚ÄúSave and visualize‚Äù button. <br><br>  After that, we transfer to the main Amazon QuickSight board and the first thing we need to do is set up a filter for the report date (taking into account that the same data was collected from three sections).  Select the key date 2018-10-01 and click on the Apply button and go to the Visualize tab. <br><br><div class="spoiler">  <b class="spoiler_title">Filter installation</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/jo/et/anjoet5xt_divhygnebb5v9ys8k.png"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can visualize the result for a portfolio in any plane, for example, for each security within a trading account, and divided in turn by currency (since the result is not comparable in different currencies) and types of transactions. </font><font style="vertical-align: inherit;">Let's start with the most powerful tool of any BI - pivot tables. </font><font style="vertical-align: inherit;">To save space and display flexibility, I rendered currencies into a separate control (analogue of the slice in MS Excel)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/90/3e/it/903eitay8v9j1psyz05d8qaqh_k.png"></div><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The table above shows that if an investor decides to sell all shares of FGC UES now, he will thereby fix the loss, since </font><font style="vertical-align: inherit;">dividends paid in the amount of 1 509.91 p. </font><font style="vertical-align: inherit;">do not cover its costs (1 763.36 p. - negative exchange difference and 174 p. - NDFL for dividends). </font><font style="vertical-align: inherit;">It makes sense to wait and wait for the best times on the Exchange.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The following graph is a bar graph: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/a7/qj/upa7qjdqjiqyo-j6tx0bnrth67m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now we will create a table that will show us how much we have invested in each paper, how many days it is in our portfolio and what is the yield for the entire period of ownership. </font><font style="vertical-align: inherit;">To do this, add two new calculated fields: sum_investment and count_days.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Field sum_investment</font></font></b> <div class="spoiler_text">   sum_investment ( )   : <br><br> ifelse({stock_name} = ' 24019',{avg_open_price} * quantity * 10,{avg_open_price} * quantity) <br><br>           ,       ‚Äì     (    ‚Äì 1000). <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Count_days field</font></font></b> <div class="spoiler_text">   count_day (   )                : <br><br> dateDiff(parseDate({date_oper}),parseDate({date_report})) <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The final table is shown in the screenshot below: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ws/dk/utwsdkbzhksrjh3wunw_w6stqr0.png"></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusions and summary </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have reviewed with you the implementation of the report parser and how to analyze the data prepared by it ‚Äúon the fly‚Äù using Amazon services. They also touched upon some business and fundamental aspects of the analysis of the investment portfolio, since this topic is almost immense and it is quite difficult to fit it in one article, I think it makes sense to put it in a separate publication or even a cycle of publications. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As regards the use of the broker's report processing tool and the approaches and algorithms involved in it, they can be used (with a corresponding modification) for processing reports of other Brokers. In any case, if you are thinking of adapting the code to your needs, I am ready to give some tips, so do not hesitate to ask questions - I will definitely try to answer them.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am sure that this system will find its application and will have further development. For example, it is planned to add to the calculation of the full PNL portfolio for accounting for depository and other commissions (for example, withdrawal of funds), as well as redemption of bonds, etc ... The calculated fields on the Quicksight side were used for the demonstration purpose, all these additional columns will be transferred to Python and will be calculated on the side of the parser.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an architect and main business customer of this solution, I see further modernization as follows: well, I don‚Äôt want to manually manually request these XML reports every time! </font><font style="vertical-align: inherit;">Of course, there is no other possibility so far, but the Broker's API with the transfer of a token and a sampling range would be ideal for weekly receiving raw reports. </font><font style="vertical-align: inherit;">The subsequent complete automatic processing on the Amazon side: from triggering an ETL-job on AWS Glue to getting finished results in the form of graphs and tables in Amazon QuickSight will allow you to fully automate the process. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The full source code can be found in my </font></font><a href="https://github.com/igorgorbenko/report_parser"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub repository.</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/426027/">https://habr.com/ru/post/426027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426017/index.html">How to reduce the number of experiments on animals</a></li>
<li><a href="../426019/index.html">Weather Station on Arduino from A to Z. Part 5</a></li>
<li><a href="../426021/index.html">libGDX and feelings</a></li>
<li><a href="../426023/index.html">Open lesson "Virtual Lab on Vagrant"</a></li>
<li><a href="../426025/index.html">Use offensive techniques to enrich Threat Intelligence</a></li>
<li><a href="../426029/index.html">Hands down and want to quit the task? This is effective developer training.</a></li>
<li><a href="../426031/index.html">Anxiety about the capture of the world by artificial intelligence, perhaps based on unscientific assumptions</a></li>
<li><a href="../426033/index.html">Titans from mathematics have clashed over the epic evidence of the abc hypothesis</a></li>
<li><a href="../426039/index.html">Emergency launch of Soyuz MS-10 (crew rescued, broadcast over)</a></li>
<li><a href="../426041/index.html">Symbolic solution of linear differential equations and systems by the Laplace transform method using SymPy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>