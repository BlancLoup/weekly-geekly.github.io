<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to cryptography and encryption, part one. Lecture in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To understand the materials about the infrastructure of public keys, network security and HTTPS, you need to know the basics of cryptographic theory. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to cryptography and encryption, part one. Lecture in Yandex</h1><div class="post__text post__text-html js-mediator-article">  To understand the materials about the infrastructure of public keys, network security and HTTPS, you need to know the basics of cryptographic theory.  One of the fastest ways to study them is to watch or give a lecture by Vladimir <a href="https://habrahabr.ru/users/ivlad/" class="user_link">ivlad</a> Ivanov.  Vladimir is a well-known specialist in networks and their protection systems.  He worked for a long time in Yandex, was one of the leaders of our operating department. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mE_s-R5wvpw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  We publish this lecture for the first time along with the transcript.  Let's start with the first part.  Under the cut you will find the text and part of the slides. <br><br><a name="habracut"></a><hr><br>  I once read lectures on a crypt at MSU, and they took me half a year.  I will try to tell you everything in two and a half hours.  Never did it.  Here we try. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Who understands what is DES?  AES?  Tls?  Binominal mapping? <br><br>  We will try to speak in general terms, because it is difficult and deep to disassemble will not work: there is little time and basic training must be quite large.  We will operate with general concepts, rather superficially. <br><br>  We will talk about what cryptographic primitives are, simple things from which you can later build more complex things, protocols. <br><br>  We will talk about three primitives: symmetric encryption, message authentication, and asymmetric encryption.  From them grows a lot of protocols. <br><br>  Today we will try to talk a little bit about how keys are made.  In general, let's talk about how to send a secure message using the crypto primitives that we have from one user to another. <br><br>  When people talk about crypt in general, there are several fundamental principles.  One of them is the Kirkoffs principle, which says that open source is very important in cryptography.  More specifically, it gives a general knowledge of the protocol structure.  The meaning is very simple: cryptographic algorithms that are used in a particular system should not be a secret to ensure its stability.  Ideally, it is necessary to build systems so that their cryptographic side is completely known to the attacker and the only secret is the cryptographic key that is used in this system. <br><br>  Modern and commercially available encryption systems ‚Äî all or nearly all or the best of them ‚Äî are built from components whose design and operation are well known.  The only secret thing about them is the encryption key.  There is only one significant exception known to me - a set of secret cryptographic protocols for all sorts of government organizations.  In the USA, this is called the NSA suite B, and in Russia it is all sorts of strange, secret encryption algorithms that are used to a certain extent by military and government agencies. <br><br>  I would not say that such algorithms are of great benefit to them, except that it is approximately like atomic physics.  You can try on understanding the design of the protocol to understand the direction of thought of the people who developed it, and somehow overtake the other side.  I don‚Äôt know how relevant such a principle is by today's standards, but people who know more about it than me do just that. <br><br>  In every commercial protocol you come across, the situation is different.  They use an open system everywhere, everyone adheres to this principle. <br><br>  The first cryptographic primitive is symmetric ciphers. <br><img src="https://habrastorage.org/files/7a7/309/454/7a7309454bfd4186b17414f42bdcc455.jpg"><br>  They are very simple.  We have some kind of algorithm, at the input of which the plaintext goes and something called the key, some value.  The output is an encrypted message.  When we want to decrypt it, it is important that we take the same encryption key.  And, applying it to another algorithm, the decryption algorithm, we get our plaintext back from the ciphertext. <br><img src="https://habrastorage.org/files/755/8f7/2db/7558f72db31e493894211e82dfddecfe.jpg"><br>  What are the important nuances here?  In most common symmetric encryption algorithms that can be encountered, the size of the ciphertext is always equal to the size of the plaintext.  Modern encryption algorithms operate on key sizes.  The size of the keys is measured in bits.  Modern size - from 128 to 256 bits for symmetric encryption algorithms.  The rest, including the size of the block, we'll talk later. <br><img src="https://habrastorage.org/files/a2b/bb6/694/a2bbb66941e84bef9a462876b7bf0448.jpg"><br>  Historically, in the conditional 4th century BC, there were two methods for the design of ciphers: substitution and permutation ciphers.  Substitution ciphers are an algorithm, where in those days they replaced one letter of a message with another one according to some principle.  A simple substitution cipher is according to the table: we take a table where it is written that we change A to I, B to U, etc. Then we encrypt this table, decipher it from it. <br><br>  How do you think, in terms of key size, how complex is the algorithm?  How many key options are there?  The order factorial of the length of the alphabet.  We take the table.  How do we build it?  Suppose there is a table of 26 characters.  We can replace the letter A with any of them, the letter B with any of the remaining 25, C with any of the remaining 24 ... We get 26 * 25 * 24 * ... - that is, the factorial from 26. The factorial of the dimension of the alphabet. <br><br>  If you take log <sub>2</sub> 26 !, it will be a lot.  I think you will definitely get around 100 bits of the key length, or even more.  It turned out that from the point of view of the formal presentation of strength, the indicated encryption algorithm is quite good.  100 bits is acceptable.  In this case, everyone, probably, in childhood or adolescence, when faced with encodings, saw that such algorithms are decrypted trivially.  There are no problems with decoding. <br><br>  For a long time there were all sorts of substitution algorithms in different constructions.  One of them, even more primitive, is Caesar's cipher, where the table is formed not by random permutation of characters, but by a shift of three characters: A changes to D, B to E, etc. very easy: unlike tabular substitution, in the key of Caesar there are only 25 variants with 26 letters in the alphabet - not counting the trivial encryption of itself.  And it is just possible to sort it out.  There is some complexity here. <br><br>  Why is the table substitution cipher so simple?  Where does the problem arise from which we can easily, without even knowing anything about cryptography, decipher the table substitution?  The point is frequency analysis.  There are the most common letters - some kind of AND or E. Their prevalence is high, vowels are found much more often than consonants, and there are negative pairs that are never found in natural languages ‚Äã‚Äã- something like b.  I even gave students the task to make an automatic substitution cipher decoder, and, in principle, many coped. <br><br>  What is the problem?  It is necessary to distort the statistics of the distribution of letters, so that the common letters are not so shone in the encrypted text.  The obvious way: let's encrypt the most common letters not in one character, but in five different, for example.  If the letter is found on average five times more often, then let's take turns - first we will encrypt the first character, then the second, the third, and so on. Next, we will have a mapping of letters not 1 to 1, but, conditionally, 26 to 50. Statistics, therefore, will be violated.  Before us is the first example of a polyalphabet cipher that somehow worked.  However, there are quite a few problems with it, and most importantly, it is very inconvenient to work with the table. <br><br>  We came up with the following: let's not encrypt with such tables, but try to take Caesar's cipher and change the shift for each next letter.  The result is a Vigenere cipher. <br><br>  Take as a key the word Vasya.  Take the message MASHA.  We engage Caesar's cipher, but counting from these letters.  For example, B is the third letter in the alphabet.  We must move the corresponding letter in the plaintext into three letters.  M moves in P. A in A. Sh - by 16, by skipping the letter A, we obtain, conditionally, D. I will move A to I. FALL. <br><br>  What is convenient in the resulting cipher?  There were two identical letters, but as a result they were encrypted into different ones.  This is great because it blurs statistics.  The method worked well, until somewhere in the XIX century, literally recently against the background of the history of cryptography, they did not figure out how to break it.  If you look at a message of several dozen words, and the key is rather short, the whole construction looks like several Caesar ciphers.  We say: OK, let's look at every fourth letter ‚Äî first, fifth, ninth ‚Äî as Caesar's cipher.  And we will look for statistical laws among them.  We will find them.  Then take the second, sixth, tenth, and so on.  Find again.  This will restore the key.  The only problem is to understand how long it is.  It is not very difficult, well, how long can it be?  Well, 4, well, 10 characters.  Going through 6 options from 4 to 10 is not very difficult.  A simple attack - it was available without computers, just at the expense of a pen and a sheet of paper. <br><br>  How to make an unbreakable cipher out of this thing?  Take the key text size.  A character named Claude Shannon in the twentieth century, in 1946, wrote the classic first work on cryptography as a section of mathematics, where he formulated a theorem.  The key length is equal to the length of the message ‚Äî it used XOR instead of adding modulo the length of the alphabet, but in this situation it is not very important.  The key is generated randomly, is a sequence of random bits, and the output will also result in a random sequence of bits.  Theorem: if we have such a key, then such a construction is absolutely stable.  The proof is not very complicated, but now I will not talk about him. <br><br>  It is important that you can create an unbreakable cipher, but it has flaws.  First, the key must be completely random.  Secondly, it should never be reused.  Third, the key length must be equal to the message length.  Why can not I use the same key to encrypt different messages?  Because, having intercepted this key next time, it will be possible to decrypt all messages?  Not.  Will Caesar's cipher appear in the first characters?  Not really understood.  It seems not. <br><br>  Take two messages: MASHA, encrypted with the VASYA key, and another word that also had the VASY key, FAITH.  We get something like this: ZEZHYA.  Fold the two received messages, and so that the two keys are mutually deleted.  As a result, we obtain only the difference between a meaningful ciphertext and a meaningful ciphertext.  On the XOR, this is done more conveniently than on addition along the length of the alphabet, but there is practically no difference. <br><br>  If we get the difference between two meaningful ciphertexts, then further, as a rule, it becomes much easier, since natural language texts have high redundancy.  Often we can guess what is happening, making different assumptions, hypotheses.  And most importantly, each correct hypothesis will reveal to us a piece of the key, and therefore pieces of two ciphertexts.  Something like this.  Therefore bad. <br><br>  In addition to the substitution ciphers, there were also permutation ciphers.  With them, too, everything is quite simple.  We take the message of VASIAI, write it into a block of some length, for example, a BID, and read the result in the same way. <br><br>  God knows what a thing.  How to break it is also understandable - let's look through all possible permutations.  There are not many of them here.  We take the length of the block, select and restore. <br><br>  As the next iteration, the following method was chosen: let's take the same thing, and from the top we will write some key - SIMON.  Rearrange the columns so that the letters are in alphabetical order.  As a result, we obtain a new permutation by key.  It is already much better than the old one, since the number of permutations is much larger and it is not always easy to pick it up. <br><br>  Each modern cipher in one way or another is based on these two principles - substitution and permutation.  Now their use is much more complicated, but the basic principles themselves remain the same. <br><img src="https://habrastorage.org/files/cf1/961/778/cf19617788074743b6f8f5868317f254.jpg"><br>  If we talk about modern ciphers, they are divided into two categories: flow and block.  The stream cipher is designed in such a way that it actually represents a random number generator, the output of which we add modulo 2, ‚ÄúXori,‚Äù with our ciphertext, as I can see on the slide.  I said earlier: if the length of the resulting keystream ‚Äî the key itself ‚Äî is absolutely random, never reused, and its length is equal to the length of the message, then we have an absolutely strong cipher that cannot be broken. <br><br>  The question arises: how to generate a random, long and eternal Key for such a cipher?  How do stream ciphers work at all?  In fact, they are a random number generator based on some initial value.  The initial value is the cipher key, the answer. <br><br>  There is one amusing exception to this story - the cipher block.  This is a real spy story about real espionage.  Some people who need absolutely stable communication generate random numbers ‚Äî for example, by literally throwing a die or literally pulling the balls out of the drum, like in a lotto.  Create two sheets where these random numbers are printed.  One sheet is given to the recipient, and the second is left at the sender.  If they want to chat, they use this stream of random numbers as a key stream.  No, the story is not taken from the very distant past.  I have a real radio interception from October 15, 2014: 7 2 6, 7 2 6, 7 2 6. This is a call sign.  4 8 3, 4 8 3, 4 8 3. This is a cipher block number.  5 0, 5 0, 5 0. This is the number of words.  8 4 4 7 9 8 4 4 7 9 2 0 5 1 4 2 0 5 1 4, etc. 50 such numerical groups.  I don‚Äôt know where, somewhere in Russia, there was a man with a pen and a pencil at an ordinary radio receiver and wrote down these numbers.  Writing them down, he took out a similar thing, folded them modulo 10, and received his message.  In other words, it really works, and such a message cannot be cracked.  If really random random numbers were actually generated and he subsequently burned a piece of paper with a key, then there is no way to hack it, absolutely. <br><br>  But there are quite a few problems.  The first is how to generate really good random numbers.  The world around us is deterministic, and if we are talking about computers, they are fully determined. <br><br>  Secondly, delivering keys of this size ... if we are talking about the transfer of messages from 55 digital groups, then it is not very difficult to do this, but transferring several gigabytes of text is already a serious problem.  Therefore, we need some algorithms that, in essence, generate pseudo-random numbers based on some small initial value and which could be used as such streaming algorithms. <br><img src="https://habrastorage.org/files/638/a94/d2a/638a94d2a34341feaaef3929c88200ad.jpg"><br>  The most historically common algorithm of this kind is called RC4.  It was developed by Ron Rivest about 25 years ago and was actively used for a very long time, it was the most common algorithm for TLS, all its various options, including HTTPS.  But lately RC4 has begun to show its age.  For him, there are a number of attacks.  It is actively used in WEP.  There was <a href="https://events.yandex.ru/lib/talks/523/">one good lecture by Anton</a> , a story that shows: the poor use of a decent encryption algorithm even by today's standards leads to compromising the whole system. <br><br>  RC4 is made easy.  The slide describes his work entirely.  There is an internal byte state of 256 bytes.  At each step of this state there are two numbers, two pointers to different bytes in the state.  And at each step there is an addition between these numbers - they are placed in some place of the state.  The byte received from there is the next byte in the numerical sequence.  Rotating this knob in this way, performing a similar action at each step, we get every next byte.  We can get the next byte of a numeric sequence forever, in a stream. <br><br>  The big advantage of RC4 is that it is entirely intrabyte, which means that its software implementation runs fairly quickly - much faster, at times, if not tens of times faster than the DES code that was comparable to it at about the same time as it.  Therefore, RC4 and received such a distribution.  For a long time he was a commercial secret of RSA, but then, somewhere around the 90s, some people anonymously published the sources of his device on the cypherpunks mailing list.  As a result, a lot of drama arose, there were cries, they say, how is it that some indecent people stole the intellectual property of RSA and published it.  RSA began to threaten all patents, all sorts of legal prosecutions.  To avoid them, all implementations of the algorithm that are in the open source are called not RC4, but ARC4 or ARCFOUR.  And - alleged.  This is a cipher, which on all test cases coincides with RC4, but technically it is not like them. <br><br>  If you are configuring some SSH or OpenSSL, you will not find any mention of RC4 in it, but you will find ARC4 or something like that.  A simple construction, it is already old, there are attacks on it now, and it is not highly recommended for use. <br><img src="https://habrastorage.org/files/e23/88d/a62/e2388da622d24baf817334e07f686eb5.jpg"><br>  There have been several attempts to replace him.  Probably, in my biased opinion, the Salsa20 cipher and several of its followers from Dan Bershtein, a character well-known in narrow circles, became the most successful.  The linuxoid is commonly known as the author of qmail. <br><br>  Salsa20 is more complex than DES.  His block diagram is complicated, but he has several interesting and cool features.  For a start, it is always executed in a finite time, each round, which is important for protection against timing attacks.  These are such attacks, where the attacker observes the behavior of the encryption system, feeding it different ciphertexts or different keys behind this black box.  And, understanding the changes in response time or in the power consumption of the system, he can draw conclusions about exactly what processes took place inside.  If you think that the attack is highly contrived, it is not.  Attacks of this kind on smart cards are very widespread - very convenient, since the attacker has full access to the box.  The only thing that he, as a rule, cannot do in it is to read the key itself.  It is difficult, and he can do everything else - to send different messages there and try to decipher them. <br><br>  Salsa20 is designed so that it is always performed in constant constant time.       :     ,      2    32, 32- .  Salsa20  ,   RC4.            ‚Äî    cipher suite  TLS,  Salsa20, ‚Äî      .        eSTREAM     .    ,  Salsa ‚Äî   .       -. ,  ‚Äî ,    ‚Äî   cipher suite  TLS  Salsa20.    . <br><br>      ,   .     ,        , 2 <sup>64</sup> .      .    ,     ,     . <br><br>     ?      ,   ,     .    ,     .   ‚Äî     .  , ,    . . <br><br>  ,    ,     ,     10 ,          1 ,       10 .  . <br><br>  Salsa   ,            ,   .     20   . 20  ‚Äî    512   . <br><br>    ‚Äî  8 .   256-,     8  ‚Äî 250  251 . ,    , .     .         ,  ,        . <br><br>     .       ,    .   ,     . <br><br>   ? :    ,   Salsa,      ,  ,       .       .  . <br><br>         ,     ‚Äî  . <br><br>     ,     .       .       ,      -  . <br><br>        .    -.      ,      ,    ‚Äî   .     ,        ,  . <br><br>      ‚Äî  , 128 .   ,   ,    128  256 ,     .   ‚Äî   ,    : 128  256    ,   . <br><br>           ‚Äî DES  AES. DES   ,  RC4.  DES    ‚Äî 64 ,    ‚Äî 56 .      IBM   .   IBM     ,    128     .     ,  124  192 . <br><br>  DES   ,          .       64       56   . <br><img src="https://habrastorage.org/files/24a/340/9c7/24a3409c72de46fd96e71d1bbf6c9605.jpg"><br> 20        .   ‚Äî     , ,    ,    .    DES  ,    ,         . <br><br>        .     .          ,      . ,    56         . <br><br>   DES?    ,    .   .  ,   ,    :   .      .        ,        .       . <br><img src="https://habrastorage.org/files/cb7/d53/487/cb7d534878e046ceb8aca7033100b001.jpg"><br>      .   :  F   .      ,        .     . <br><br>    :    ,  .     ,                . <br><br>   ? 30      ,                 .       ,         . <br><br>      ‚Äî    ,        16    .   16      16  ,          F. <br><br>      ‚Äî     - .  :      32 ,    ,    32 .          32 ,    48:     ,  . <br><br>       ,   ‚Äî  48 ,   48- . <br>      ,   S-         . ,     48    32 . <br><br>  ,   P.    32   .   ,    . <br><br>        S-:     6   4.     , ,     XOR   .   S-  ,  DES        .       ,       ,  .     DES   :     . <br><br>     S-,   .     ,    .  ,   10   ,  DES    ,      ‚Äî  .    :        ‚Äî ,  ,     0  1 ‚Äî  ,    . ,         0  1        . ,  DES,       ,    ,      .         : ,    10         ,    ,     . <br><br>   S-     .   ,    :        S-.     ,              . <br><br> 56            ‚Äî ,   .   .   ? <br><br>     :      . Triple DES.    :        ,    .      . <br><br> ,      .    ,    k1  k2           k3,       .     ,  DES   .   ,     . <br><br> , 56 .    ‚Äî k1  k2. 56 + 56 = 112 . 112      ‚Äî    .    ,   100 .      , 112 ? <br><br>   DES   16 .   16 .     16 .   ‚Äî  .   ,      k3,      ,      k1  k2. <br><br>  .       - ,          .  ,    2 <sup>56</sup> .  -  .       2 <sup>56</sup>  ‚Äî       ‚Äî     k1  k2,     . <br><br>    ‚Äî  112 ,  57,     .    ,    .   ‚Äî   ,     : k1, k2, k3.   Triple DES.      -.   DES    ‚Äî    ,     : ,     ‚Äî        . <br><br>    Triple DES     DES.            . <br><br>   DES?  .         TLS,  cipher suite  TLS,  Triple DES  DES.     ,     .   . <br><br>        ,    ,   .  ,      ,      .  , ,    PIN, ‚Äî    .    ,      PIN,   PIN-.   ‚Äî ,  DES.    ,            ,       Triple DES,   DES. <br><br>  DES    ,    ,      .    ,   NIST, :        .   AES. <br><br> DES   digital encrypted standard. AES ‚Äî advanced encrypted standard.    AES ‚Äî 128 ,   64.      .    AES ‚Äî 128, 192  256 .  AES    ,    ,         .  128   10 ,  256 ‚Äî 14. <br><br>  ,    .          ‚Äî   . <br><br>    DES,    AES    .        .    AES   ,  DES.  128- ,    10   10 .  ,    DES,     . <br><br>        .   ‚Äî    . <br><br>  AES      4  4.    ‚Äî .   16   128 .     AES . <br><br>   ‚Äî  . <br><br>   , .    4  4.     ,     1  ,  ‚Äî  2 ,  ‚Äî  3, . <br><br>      .     .       ,    .       . <br><br> ,     ‚Äî XOR         .  . <br><br>      ,      .        : <br><br>   ,               .      . <br><br>   4   10 ,     128-    128- . <br><br>    AES?   ,   ,  DES. AES     .     AES  DES   , AES    ,         . <br><br>   , Intel  AMD,       AES  ,     .   ‚Äî AES  .   DES      , , 1-2 ,  10- AES-       . <br><br>      .     128  64        128  64 . <br><br>     ,   ,  16 ? <br><br> ,    , ‚Äî      ,  ,   ,  ,     . <br><br> , ,      16   .    ECB ‚Äî electronic code boot,      16    AES   8    DES  . <br><img src="https://habrastorage.org/files/ab2/e98/3d4/ab2e983d441f465bb3b2571120ebf31b.jpg"><br>   ,  ,      . <br><img src="https://habrastorage.org/files/f5e/e97/c28/f5ee97c28db14fdeb64f86173fcdf2b2.jpg"><br>    ,    ECB.     ,    , ,     .  What is the problem?  ,    .       ,   ‚Äî        . <br><br>   -    ,        ,      ‚Äî   ,       .      CBC. <br><img src="https://habrastorage.org/files/3c8/869/fdb/3c8869fdb5064faa97ba4e3b89dc1e02.jpg"><br>        ,     ,    .    .    . <br><br>        ,     2     .   ‚Äî .       2     .   ‚Äî   .     2       .      .   :       . <br><br>    ,  ,    ,  ,         .     .   . <br><br>   CBC   . <br><br>   . :    , ,   DES.   DES    ,  DES         64 .  ,          64       ? 1/(2 <sup>64</sup> ).      ?   . </div><p>Source: <a href="https://habr.com/ru/post/324866/">https://habr.com/ru/post/324866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324854/index.html">How to escape from the plane: a review of the book "Presentation of Information" by Edward Tufti (1990)</a></li>
<li><a href="../324856/index.html">The Pitch Canvas - template for short presentations.</a></li>
<li><a href="../324858/index.html">Alignment in Bootstrap</a></li>
<li><a href="../324862/index.html">An example of creating a single chrome extension</a></li>
<li><a href="../324864/index.html">The fastest way to take 35 billboards in Moscow</a></li>
<li><a href="../324868/index.html">Read configuration files without problems</a></li>
<li><a href="../324870/index.html">The digest of interesting materials for the mobile # 196 developer (March 20-26)</a></li>
<li><a href="../324872/index.html">Roads that change us</a></li>
<li><a href="../324874/index.html">The proximity theory: the main rule of design, which helps to move from subjective feelings to specifics</a></li>
<li><a href="../324876/index.html">How do I make SQLAlchemy handy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>