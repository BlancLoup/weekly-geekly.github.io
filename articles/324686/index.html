<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Technological stack for classifying natural language texts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post we will look at modern approaches used to classify natural language texts according to their topics. The chosen methods of working with d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Technological stack for classifying natural language texts</h1><div class="post__text post__text-html js-mediator-article">  In this post we will look at modern approaches used to classify natural language texts according to their topics.  The chosen methods of working with documents are determined by the general complex specificity of the task - noisy training samples, samples of insufficient size or no samples at all, a strong distortion of class sizes, and so on.  In general - real practical problems.  I ask under the cat. <br><a name="habracut"></a><br><h3>  Solvable tasks </h3><br>  There are two main tasks: binary classification and multiclass classification.  Binary classification gives us the answer, this document is interesting in general, or it is not at all in the subject and should not be read.  Here we have a skewed class size of about 1 to 20, that is - for one good document, there are twenty worthless.  But the training sample itself is also problematic - it contains noise both in its completeness and in its accuracy.  Noise in terms of completeness is when not all is good, suitable documents are marked as good (FalseNegative), and noise in accuracy - when not all documents marked up as good are actually good (FalsePositive). <br><br>  The multiclass classification sets us the task of determining the subject of the document and attributing it to one of the hundreds of thematic classes.  The training sample for this problem is very noisy in its completeness, but rather pure in accuracy - all the same, the markup is only done manually, not in the first case - on heuristics.  But then, thanks to a large number of classes, we begin to enjoy strong distortions in the number of documents per class.  The maximum recorded bias is more than 6 thousand.  That is, when there is more documents in one class than in the other, 6 thousand times.  Just because in the second grade there is one document.  Only.  But this is not the largest distortion available, since there are classes in which there are zero documents.  Well, the assessors did not find the right documents - turn around as you know. <br><br>  That is, our problems are: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Noisy training samples; </li><li>  Severe distortions in class sizes; </li><li>  Classes represented by a small number of documents; </li><li>  Classes in which there are no documents at all (but you need to work with them). </li></ul><br>  We will consistently solve these problems by developing one classifier - the signature one, then the other - covering the weak points of the first one - a template, and then we polish it all with machine learning in the form of xgboost and regression.  And on top of this ensemble of models we roll a method that covers the shortcomings of all the listed ones - namely, the method of work without training samples in general. <br><br><h3>  Distributive semantics (Word2Vec) </h3><br>  Google and Yandex know which <a href="https://habrahabr.ru/post/249215/">post to</a> show first when people ask about Word2Vec.  Therefore, we will give a brief squeeze from that post and pay attention to what is not written there.  Of course, there are other good methods in the distribution semantics section - GloVe, AdaGram, Text2Vec, Seq2Vec, and others.  But I didn‚Äôt see any strong advantages over W2V in them.  If you learn how to work with W2V vectors, you can get amazing results. <br><br><h4>  Word2Vec: </h4><br><ul><li>  It is taught without a teacher on any texts; </li><li>  Each token corresponds to a vector of real numbers, such that: </li><li>  For any two tokens, you can define the metric * of the distance between them (cosine measure); </li><li>  For semantically related tokens, the distance is positive and tends to 1: </li><li>  Interchangeable words (Skipgram model); </li><li>  Associated words (BagofWords model). </li></ul><br>  * Not really <br><br><h4>  Interchangeable words </h4><br>  Enter word or sentence (EXIT to break): coffee <br><br>  coffe 0.734483 <br>  tea 0.690234 <br>  tea 0.688656 <br>  cappuccino 0.666638 <br>  code 0.636362 <br>  cocoa 0.619801 <br>  espresso 0.599390 <br><br><h4>  Associated words </h4><br>  Enter word or sentence (EXIT to break): coffee <br><br>  0.757635 grains <br>  soluble 0.709936 <br>  tea 0.709579 <br>  coffe 0.704036 <br>  mellanrost 0.694822 <br>  sublimated 0.694553 <br>  ground 0.690066 <br>  coffee 0.680409 <br><br><h4>  Summarizing a few words (A + B) </h4><br>  Enter word or sentence (EXIT to break): mobile phone <br><br>  cell 0.811114 <br>  phone 0.776416 <br>  smartphone 0.730191 <br>  telfon 0.719766 <br>  mobile 0.717972 <br>  mobile phone 0.706131 <br><br><h4>  Projection of Relations (A-B + C) </h4><br>  Find a word that refers to Ukraine as the dollar refers to the United States (that is, what is the currency of Ukraine?): <br><br>  Enter three words (EXIT to break): us dollar ukraine <br><br>  UAH 0.622719 <br>  Dolar 0.607078 <br>  hryvnia 0.597969 <br>  Ruble 0.596636 <br><br>  Find such a word that refers to germany as France refers to france (that is, the translation of the word germany): <br><br>  Enter three words (EXIT to break): france france germany <br><br>  Germany 0.748171 <br>  England 0.692712 <br>  Netherlands 0.665715 <br>  Great Britain 0.651329 <br><br><h4>  Advantages and disadvantages: </h4><br>  Learning quickly on unprepared texts: <br><br><ul><li>  1.5 months per 100 GB training file, BagOfWords and Skipgram models, on 24 cores; </li><li>  Reduces the dimension: </li><li>  2.5 million tokens dictionary is compressed to 256 elements of the real numbers; </li><li>  Vector operations quickly degrade: </li><li>  The result of adding 3-5 words is practically useless =&gt; not applicable for word processing; </li></ul><br>  Elements of a vector have no meaning, only the distances between the vectors are meaningful =&gt; the metric between the tokens is one-dimensional.  This disadvantage is the most offensive.  It seems that we already have 256 real numbers, we occupy a whole kilobyte of memory, and in fact the only available operation for us is to compare this vector with another one and get a cosine measure as an estimate of the proximity of these vectors.  Process two kilobytes of data, get 4-byte result.  And nothing more. <br><br><h4>  Semantic vector </h4><br><ul><li>  The coffee example shows that tokens are grouped by meaning (drinks); </li><li>  It is necessary to form a sufficient number of clusters; </li><li>  There is no need to mark up the clusters. </li></ul><br>  Then, we get a set of clusters in which the tokens are grouped by meaning, and, if necessary, each cluster can be assigned the label =&gt; each cluster has a meaning independent from the others. <br>  In more detail about the construction of the semantic vector is described in this <a href="https://habrahabr.ru/post/277563/">post</a> . <br><br><h3>  Text signature </h3><br>  The text consists of tokens, each of which is tied to its cluster; <br>  You can count the number of occurrences of the token in the text and translate into the number of occurrences of the cluster in the text (the sum of all tokens included in the cluster); <br>  Unlike the size of the dictionary (2.5 million tokens), the number of clusters is much less (2048) =&gt; the effect of reducing the dimensionality works; <br><br>  Let's move from the total number of tokens calculated in the text to their relative number (share).  Then: <br><br><ul><li>  The share does not depend on the length of the text, but depends only on the frequency of appearance of tokens in the text =&gt; it becomes possible to compare texts of different lengths; </li><li>  The share characterizes the subject of the text =&gt; the subject of the text is determined by the words that are used; </li></ul><br>  We normalize the proportion of specific texts mat.  by expectation and variance calculated over the entire base: <br><br>  This will increase the importance of rare clusters (not found in all texts - for example, names) as compared with frequent clusters (for example, pronouns, verbs, and other connecting words); <br><br>  The text is determined by its signature - the vector of 2048 real numbers, meaningful as the normalized shares of the tokens of thematic clusters from which the text is composed. <br><br><h3>  Signature Classifier </h3><br>  Each text document is assigned a signature; <br>  The tagged training sample of texts turns into the tagged base of signatures; <br>  For the text under study, its signature is formed, which is sequentially compared with the signatures of each file from the training set; <br>  The classification decision is made on the basis of kNN (k nearest neighbors), where k = 3. <br><br><h4>  Advantages and disadvantages </h4><br>  Benefits: <br><br>  There is no loss of information from the generalization (comparison is made with each original file from the training sample).  The essence of machine learning is to find some patterns, select them and work only with them - drastically reducing the size of the model compared to the size of the training set.  True, these are regularities or false ones that have arisen as artifacts of the learning process or because of a lack of training data ‚Äî it does not matter.  The main thing is that the original training information is no longer available - you have to operate only with the model.  In the case of a signature-based classifier, we can afford to keep in our memory the entire training sample (not quite so, more on that later - when we talk about classifier tuning).  The main thing is that we can determine which particular example from the training set our document looks like the most and connect if necessary an additional analysis of the situation.  The lack of generalization is the essence of the absence of loss of information; <br><br>  Acceptable performance is about 0.3 seconds to run the signature database of 1.7 million documents in 24 streams.  And this is without SIMD instructions, but taking into account maximization of cache hits.  And in general - <a href="https://www.youtube.com/watch%3Fv%3DcdX8r3ZSzN4">dad can in si</a> ; <br><br>  The ability to highlight fuzzy duplicates: <br><br><ul><li>  Free (comparison of signatures and so happens at the stage of classification); </li><li>  High selectivity (only potential duplicates are analyzed, made up mainly of the same tokens, that is, signatures with a high measure of proximity); </li><li>  Customizability (you can underestimate the trigger threshold and get not just duplicates, but thematically and stylistically close texts); </li></ul><br>  Normalization of estimates (0; 1]; <br><br>  The ease of replenishing the training set with new documents (and the ease of excluding documents from it).  New training images are connected on the fly - accordingly, the quality of the classifier's performance grows as it works.  He is studying.  And deleting documents from the database is good for experimenting, building training samples, and so on ‚Äî just exclude the signature of this particular document from the signature database and run its classification ‚Äî get a correct assessment of the quality of the classifier's work; <br><br><h4>  Disadvantages: </h4><br>  The mutual arrangement of tokens (phrases) is not taken into account.  It is clear that word combinations are the strongest classifying attribute; <br>  Large minimum requirements for RAM (35+ GB); <br><br>  Poorly (in no way) does not work when there are a small number of samples per unit.  Imagine a 256-dimensional surface of a sphere ... No, it‚Äôs better not to.  Simply, there is an area in which the documents of our interest should be located.  If there are quite a few points in this area ‚Äî document signatures from the training set ‚Äî the chances of a new document being close to three of these points are higher (kNN ‚Äî the same) than if there are proudly 1-2 points in the entire area.  Therefore, there are chances to work even with a single positive example per class, but these chances are, of course, not realized as often as we would like. <br><br><h3>  Accuracy and completeness (binary classification) </h3><br><img src="https://habrastorage.org/files/175/f6f/59c/175f6f59cb4f433698f5b42bb239cd19.png"><br><br>  How to calculate the score for the binary classification?  Very simple - we take the average distance to the 3 best signatures from each class (positive and negative) and evaluate it as: <br>  Positive / (positive + negative). <br><br>  Therefore, most of the estimates are in a very narrow range, and people, as usual, want to see the numbers interpreted as percentages.  That 0.54 is very good, and 0.46 is very bad to explain for a long time and not productively.  Still, the graphics look good, classic cross. <br><br><h3>  Fine-tuning signature classifier </h3><br>  As can be seen from the graph ‚Äúaccuracy and completeness‚Äù, the classifier's working area is quite narrow.  The solution is to mark up the original text training file that Word2Vec learns from.  For this purpose, the labels defining the class of the document are embedded in the document text: <br><br>  As a result, the clusters are located in the vector space not in a random way, but are divorced so that the clusters of one class will be to each other and stand at a maximum distance from the clusters of the opposite class.  Clusters characteristic of both classes are located in the middle. <br><br>  Memory requirements are reduced by reducing the size of the signature database: <br><br>  The training sample signatures containing an excessive number of samples (over a million) are sequentially clustered into a large number of clusters, and one signature is used from each cluster.  Thereby: <br><br><ul><li>  A relatively uniform coverage of the vector space with sample signatures is preserved; </li><li>  Signatures of samples that are too close to each other and, accordingly, are of little use for classification are removed. </li></ul><br><h3>  Signature classifier, summary </h3><br><ul><li>  Fast; </li><li>  Easily complemented; </li><li>  Allows you to also detect duplicates; </li><li>  Does not take into account the mutual arrangement of tokens; </li><li>  It does not work when there are few examples in the training set. </li></ul><br><h3>  Template Classifier </h3><br>  To correct the shortcomings of the signature classifier is designed a classifier on the templates.  On ngramma, simply put.  If the signature classifier matches the text with the signature and stumbles when there are few such signatures, the template classifier reads the contents of the text more thoughtfully and, if the text is large enough, even a single text is enough to highlight a large number of classifying features. <br><br><h4>  Template Classifier: </h4><br>  Based on grams up to 16 elements long: <br><br>  Some target texts are framed according to standards (ISO).  There are many typical elements: <br><br><ul><li>  Headers; </li><li>  Signatures; </li><li>  Coordination sheets and archive tags; </li></ul><br>  Some of the target documents contain information on registration: <br><br><ul><li>  Xml (including all modern office standards); </li><li>  Html; </li></ul><br>  Almost all contain stable phrases, for example: <br><br><ul><li>  ‚ÄúStrictly confidential, burn before reading‚Äù; </li></ul><br>  Is a simplified implementation of the Naive Baess classifier (without normalization); <br>  Generate up to 60 mln grading grams; <br>  Runs fast (state machine). <br><br><h4>  Building a classifier </h4><br>  Grams are distinguished from texts; <br>  Calculates the relative frequency of grams per class; <br>  If for different classes the relative frequency is very different (at times), the gram is a classification feature; <br>  Rare grams, met 1 time, are discarded; <br><br>  The training set is classified, and according to the documents for which the classification was erroneous, additional grams are formed and added to the common gram base. <br><br><h4>  Classifier use </h4><br>  Grams are distinguished from the text; <br>  Weights of all grams for each class to which they belong are summed; <br>  The class with the highest weights is the winner; <br>  Wherein: <br><br><ul><li>  The class in which there were more teaching texts usually forms more grading grams; </li><li>  A rare class (few teaching texts) generates few grams, but their average weight is higher (due to the prevalence of long unique grams for this class); </li><li>  The text in which there is no obvious predominance of rare long grams will be assigned to a class with a large number of teaching examples (the posterior distribution tends to a priori).  This is how the original naive Baess works and, in general, all universal classifiers; </li><li>  A text that has long unique grams of a rare class will be referred rather to this rare class (deliberately introduced distortion in the a posteriori distribution in order to increase selectivity in rare classes).  Money pays for the result, and the harder it is to get a result, the more money.  It's clear.  The most difficult result is just rare thematic classes.  Therefore, it makes sense to distort your classifier in such a way that it would be better to look for rare classes, albeit sagging as in large, pop classes.  In the end, with the pop classes perfectly handles the signature classifier. </li></ul><br><h4>  Advantages and disadvantages </h4><br>  Benefits: <br><br><ul><li>  Relatively fast and compact; </li><li>  Not bad parallels; </li><li>  Able to learn from a single document in a training sample per class; </li></ul><br>  Disadvantages: <br><br><ul><li>  Estimates are not normalized and, in their original form, do not provide a pairwize criterion (it cannot be guaranteed that a higher weight score is more likely); </li><li>  A huge number of grams is generated with a near-zero probability of meeting them in real documents (not duplicates).  But then, having met such a rare gram in a document, you can immediately say a lot about this document.  And there is enough memory on the server - this is not a problem; </li><li>  Huge memory requirements at the training stage.  Yes, we need a cluster, but we have them (see poskriptum to this post). </li></ul><br><h4>  Nonnormalized ratings </h4><br>  Why: <br><br>  There is no need to do normalization - a strong simplification of the code; <br>  Non-normalized estimates contain more potentially available information for classification. <br><br>  How to use: <br><br>  Classifier ratings are good signs for use in universal classifiers (xgboost, SVM, ANN); <br>  At the same time, universal classifiers themselves determine the optimal value of the normalization. <br><br><h3>  Final generalized classifier (multiclass) </h3><br>  The answers of the signature and template classifiers are combined into a single feature vector, which is subjected to additional processing: <br><br><ul><li>  Normalizing grades to a unit, to get their relative share per class; </li><li>  Grouping rare classes to get enough teaching examples per group; </li><li>  Taking the difference of group estimates for a flatter surface for gradient descent. </li></ul><br>  According to the resulting feature vector, the xgboost model is constructed, giving an accuracy gain of up to 3% to the accuracy of the original classifiers. <br><br><h3>  Binary generalized classifier </h3><br>  Essence of regression from: <br><br><ul><li>  Signature Classifier: </li><li>  Template Classifier: </li><li>  XgBoost at the outputs of the signature and template classifier. </li></ul><br>  The optimization criterion is the maximum of the area under the product of completeness and accuracy on the [0; 1] segment; at the same time, issuing a classifier that does not fall into the segment is considered a false positive. <br><br>  What gives: <br><br>  Maximizes the classifier work area.  Humans see the usual estimate in the form of percentages, from zero to one hundred, at the same time, this estimate falls in such a way as to maximize both completeness and accuracy.  It is clear that the maximum of the work is in the area of ‚Äã‚Äãthe cross, where both the completeness and accuracy do not have too small values, but the areas on the right and left, where high completeness is multiplied by no accuracy and where high accuracy is multiplied by no completeness, are uninteresting.  No money is paid for them; <br><br>  Rejects some of the examples to the region below zero =&gt; is a signal that the classifier is not able to work out these examples =&gt; the classifier fails.  From an engineering point of view, this is generally an excellent ability - the classifier himself honestly warns that yes, there are 1-2% of good documents in the discarded stream, but the classifier itself does not know how to work with them - use other methods.  Or reconcile. <br><br><h3>  Binary generalized classifier, 1:20 </h3><br><img src="https://habrastorage.org/files/980/354/d49/980354d493f248a9a2f88d78b893a5ec.png"><br><br>  Chic schedule, especially happy blockage on the right.  I remind you that here we have a ratio of positive examples in the stream is twenty times less than negative ones.  Nevertheless, the graph of completeness looks quite canonical - convex-concave with a knee point in the middle, in the region of 0.3.  Why this is important, we show further. <br><br><h4>  Binary Generalized Classifier, 1:20, Analysis </h4><br>  Completeness begins with 73% =&gt; 27% of all positive examples cannot be effectively worked out by the classifier.  These 27% of positive examples were in the region below zero precisely because of the optimization of the regression.  It is better for business to report that we are not able to work with these documents than to give false negatives to them.  But the classifier‚Äôs workspace starts with almost 30% accuracy - and these are the numbers that businesses already like; <br>  There is a blockage of accuracy from 96% to 0% =&gt; in the sample there are about 4% of examples marked as negative, although in fact they are positive (the problem of completeness of markup); <br><br>  Five areas are clearly visible: <br><br><ul><li>  Classifier failure area (less than zero); </li><li>  two quasilinear regions; </li><li>  Saturation region (maximum efficiency); </li><li>  Dam area (problem of completeness of markup). </li></ul><br>  The division into regions makes it possible to develop additional means of classification for each of the regions, especially for the 1st and 5th. <br><br><h3>  Binary generalized classifier, 1: 182 </h3><br><img src="https://habrastorage.org/files/2c6/b50/a4c/2c6b50a4c65541728f271bf6fddf73ce.png"><br>  Here we solve the same problem of binary classification, but at the same time, 182 negative ones fall on one positive example. <br><br><h4>  Binary Generalized Classifier, 1: 182, Analysis </h4><br>  Completeness begins with 76% =&gt; 24% of all positive examples cannot be effectively worked out by the classifier; <br>  12% of all positive examples are clearly recognized by the classifier (100% accuracy); <br>  Four areas are clearly visible: <br><ul><li>  Classifier failure area (less than zero); </li><li>  two quasilinear regions; </li><li>  The area is 100% accurate. </li></ul><br>  The completeness graph is concave without inflection points =&gt; the classifier has a high selectivity (corresponds to the right side of the classical completeness graph with an inflection point in the middle). <br><br><h3>  Building a classifier for classes that do not have teaching examples </h3><br>  The reality is that there is a sufficiently large number of classes for which no documents have been marked up, and the only information available is the Customer‚Äôs message about which documents he wants to classify into this class. <br><br>  It is impossible to build a training sample manually, since for 1.7 million documents available in the database, only a few documents can be expected to fall under this class, and perhaps not just one. <br><br><h4>  Class ‚ÄúMarketing research cosmetics‚Äù </h4><br>  From the analysis of the class name, we see that the Customer is interested in documents relating to ‚ÄúMarketing Research‚Äù and ‚ÄúCosmetics‚Äù.  To detect such documents you need: <br><br>  To form a semantic core of texts on given topics, in this case, in all languages ‚Äã‚Äãof interest; <br>  Find those topics that are not related to a given class - use them as negative examples (for example, politics); <br>  Find in the database of documents several samples of documents that have a partial or exact relation to a given class; <br>  Mark the found documents by the Assessors of the Customer; <br>  Build a classifier. <br><br><h4>  Build semantic core texts. </h4><br>  Go to Wikipedia and find an article called, oddly enough, ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2580%25D0%25BA%25D0%25B5%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25B8%25D1%2581%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">marketing research</a> ‚Äù.  Below there is an inconspicuous reference " <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2582%25D0%25B5%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F:%25D0%259C%25D0%25B0%25D1%2580%25D0%25BA%25D0%25B5%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B5_%25D0%25B8%25D1%2581%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">category</a> ."  In the categories are given all the Wikipedia articles on this topic and nested categories with their articles.  In general - a rich source of thematic texts. <br><br>  But that's not all.  On the right in the menu are links to similar articles and categories in other languages.  Texts of the same subject, but in languages ‚Äã‚Äãthat interest us.  Or on everyone - the classifiers themselves will understand. <br><br><h4>  Using semantic kernels </h4><br>  We have three themes: <br><br><ul><li>  Marketing research; </li><li>  Cosmetics; </li><li>  Politics. </li></ul><br>  We use the template classifier for these three classes.  We will process all documents in the database of documents and get: <br><br><ul><li>  Marketing research 20%; </li><li>  Cosmetics 6%; </li><li>  Politics 74%. </li></ul><br>  These shares do not show the actual distribution of documents by subject, they show only the average weights of features of each class, highlighted by the template classifier. <br><br>  However, if a document is examined that has a distribution of 30%, 20%, 50% shares of such a document, it can be argued that it contains more features of a text with given topics against negative topics (politics), respectively - this text is potentially interesting: <br><br><img src="https://habrastorage.org/files/f66/4bd/8e0/f664bd8e0c2342489b0e795712f217d1.jpg"><br><br><h4>  Document Search Results </h4><br>  As a result of processing the entire database of documents, ~ 80 documents were allocated, of which: Two turned out to be fully compliant with the class: <br><br><ul><li>  were not previously found when processing documents manually; </li><li>  In different languages ‚Äã‚Äãother than the entry point into the semantic core (Russian); </li></ul><br>  ~ 36% of all documents found are partially related to the class; <br>  The rest are not related to the class at all. <br><br>  It is important that as a result of the assessment a marked selection of ~ 80 documents was received, containing both positive and negative examples. <br><br><h4>  Building a classifier </h4><br>  More than 60% of false positives signal that a single policy is not enough as a negative example. <br><br>  Decision: <br><br>  To automatically find other topics of texts that can be used as negative and, potentially, positive examples.  For this: <br><br>  To form automatically sets of texts on a large number of topics and select those that correlate (negatively or positively) with a marked selection of ~ 80 documents. <br><br><h4>  DBPedia ontology </h4><br>  If someone else does not know, all of Wikipedia is already kindly <a href="http://wiki.dbpedia.org/downloads-2016-04">parsed and laid out</a> in RDF files.  Take it and use it.  Of interest: <br><br><ul><li>  ShortAbstracts - a brief annotation of the article; </li><li>  LongAbstracts - long abstract article; </li><li>  Homepages - links to external resources, home pages; </li><li>  Article Categories - page category; </li><li>  Categorylabels - readable category names; </li><li>  Externallinks - links to external resources on the topic; </li><li>  Interlanguagelinks - The same article in other languages. </li></ul><br>  It is worth remembering that DBPedia does not replace Wikipedia as a source of texts for computer linguistics, since the size of the annotation is usually 1-2 paragraphs and cannot be compared with most articles in terms of volume.  But no one forbids pumping out your favorite articles and their categories from Wikipedia in the future, right? <br><br><h3>  [Expected] search results for correlated topics in DBPEdia </h3><br>  The result of the search for correlated topics will be: <br><br><ul><li>  Sets of texts in all languages ‚Äã‚Äãon specified topics; </li><li>  Evaluation of the degree of correlation of texts in relation to the class; </li><li>  Human readable (verbal) description of topics. </li></ul><br>  At the same time, the correlated subjects depend not only on the class ‚ÄúMarketing research of cosmetics‚Äù, but also on the topics of the documents contained in the database (for topics with negative correlation).  What allows to use the found subjects: <br><br><ul><li>  for manual construction of classifiers on other topics; </li><li>  as additional features for texts classified by the final generalized classifier; </li><li>  To create additional measurements of similarity metrics in the vector space of the signature classifier: here I refer to my article in the collection of the 2015 Dialogue on learning by analogy in mixed ontological networks.  And to the <a href="https://habrahabr.ru/post/229403/">corresponding post</a> . </li></ul><br><h3>  P.S </h3><br>  This post showed the technologies that we use at the moment and where we plan to move in the future (and these are ontologies).  Taking this opportunity, I want to say that in our group we recruit people who are beginning / continuing to study machine linguistics, we are especially glad to see students / graduates who you know which universities. </div><p>Source: <a href="https://habr.com/ru/post/324686/">https://habr.com/ru/post/324686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324670/index.html">TOP 10 mistakes in organizing blockchain projects from Gartner Inc</a></li>
<li><a href="../324674/index.html">Intel SGX Extensions Tutorial. Preface and full course content</a></li>
<li><a href="../324680/index.html">Features of the choice of data center for the cloud provider. Regional bias</a></li>
<li><a href="../324682/index.html">Go Web Application Profiling and Optimization</a></li>
<li><a href="../324684/index.html">How to part with the traditional telephony operator and not lose calls</a></li>
<li><a href="../324688/index.html">How does imperative programming differ from declarative</a></li>
<li><a href="../324692/index.html">Maintainer's notes: resurrection</a></li>
<li><a href="../324694/index.html">40+ Business Learning Technology Applications</a></li>
<li><a href="../324696/index.html">Report from Moscow.pm February 2</a></li>
<li><a href="../324700/index.html">Meet Buddy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>