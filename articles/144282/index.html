<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Secure authentication between client and server without entering username and password</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, when developing a distributed traffic analyzer, I had the task of designing an authentication system between the client and the server. More...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Secure authentication between client and server without entering username and password</h1><div class="post__text post__text-html js-mediator-article">  Recently, when developing a distributed traffic analyzer, I had the task of designing an authentication system between the client and the server.  Moreover, it was necessary to design the system for two different situations: <br><br><ul><li>  when the client and server communicate in a trusted (local) network; </li><li>  The client and server communicate through a global, unsecured network. </li></ul><br>  The differences lie in the fact that when a client and a server interact through a local network, when designing a system, threats of intrusion from outside were excluded (the threat of a hacker sitting next to you, who redirected your traffic to your computer, was minimized).  In addition, the interaction between the client and server in the local network means that the client and server have no access to the Internet or are not desired, that is, there is also no access to certificate authorities, and, as a result, it is impossible to fully use authentication using public keys. <br><br>  Unlike a local network, where an attacker somehow needs to connect to it (and if good system administrators manage such a network, this is quite problematic), when a client and server interact through an unprotected network, you cannot be sure that no one listens for traffic.  Therefore, an authentication algorithm is required here that is different from the algorithm for interaction in the local network. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  In addition, some additional restrictions were imposed on the authentication system. <br>  In general, the limitations can be described as follows: <br><ul><li>  strong encryption of traffic between the client and the server is required; </li><li>  The client should work immediately after installation on the computer, without requesting a password from the user.  That is, the employee does not need to know at all about the existence of such a client installed on his computer.  All settings for the client come from the server, and the client, in turn, should simply be able to verify his identity in order to send encrypted traffic; </li><li>  if curious employees have access to a client and its private key, then the maximum that they can do is to decrypt messages only for a certain period of time, for which this key was created.  That is, forward secrecy (security of future messages) and backward secrecy (secrecy of past messages) are partially provided; </li><li>  if employees start to install clients on local computers without need, it will not be critical, since  the client does not have the ability to disrupt the server, or to gain access to encrypted data.  In addition, the server can ban such clients. </li></ul><br>  Based on these limitations, the following protocols and algorithms were chosen: <br><br><ul><li>  Authentication protocol based on a shared secret key using HMAC is used for authentication in the local network, and Diffie-Hellman's algorithm is used to generate the shared secret key (I will not write about the algorithm itself here, since there are already many detailed articles on the Habr√© about him). </li><li>  for authentication between the client and the server in an unsecured network, it is supposed to use an authentication protocol using public key encryption using the RSA algorithm (you can see about RSA on Wikipedia). </li></ul><br><h4>  Shared Secret Authentication Using HMAC </h4><br>  This type of authentication implies that the client and the server have a certain secret key that only two of them know.  We generated such a key using the Diffie-Hellman algorithm. <br><br>  HMAC (short for English hash-based message authentication code, message identification hash code).  That is, it is a mechanism that uses cryptographic hash functions in combination with a secret key. <br><br>  The protocol authentication sequence is as follows: <br><br><img src="https://habrastorage.org/storage2/051/af6/85b/051af685b7bc0bd8036bbdfd5850c3ea.jpg"><br><br>  N, N - 128 bit number, randomly selected by the client and server separately; <br>  K, C - identifiers of the client and server (for example, IP address); <br>  HMAC - hash message identification code; <br>  Ks is a shared secret key. <br><br>  In the first step, the client sends a randomly selected number to the server so that it can encrypt it with a key common to them, and thereby confirm that it is in fact a server and not an attacker who pretends to be it (although as we will see later, in our example this number is not encrypted, but is converted with other data into a hash, which does not change the essence of the process). <br><br>  In the second step, the server sends the client a random number Nc, as well as an HMAC hash, formed by hashing the values ‚Äã‚ÄãNk, Nc, K, C, and Ks using the HMAC function.  Because  the client knows NC, NC, K, C, and Ks, then he can generate his HMAC hash, and compare it with what came from the server.  If the hashes match, then the server is what it claims to be.  At the same time, the attacker could not form a HMAC hash (NC, NC, K, C, Ks), because  at least he should not know the secret key Ks. <br><br>  In the third step, it was the client's turn to confirm his ‚Äúidentity‚Äù.  The process is carried out by analogy with the second step. <br><br><h4>  Authentication using public key encryption </h4><br>  This type of authentication is used when both the client and the server have certificates.  The sequence of steps of this type of authentication is shown below. <br><br><img src="https://habrastorage.org/storage2/4bf/cd2/ff6/4bfcd2ff66656adf33ac20981823bc7f.jpg"><br><br>  N, N - 128 bit number, randomly selected by the client and server separately; <br>  K, C - identifiers of the client and server (for example, IP address); <br>  Ks - shared secret key; <br>  Ec, Ec are the public keys of the server and the client, respectively, which are transmitted in the form of certificates. <br><br>  First, the client requests the public key of the server (EU) from the certification authority.  Then he encrypts with his help a randomly selected number and his identifier (step 3).  Only a real server can decrypt this message.  Therefore, the server, receiving this message, decrypts it, and encrypts the client‚Äôs public key (which it receives from the certification authority) with the client‚Äôs random number, its random number, and the shared secret key (step 6).  Further, if the client is the one who claims to be, decrypts the server message, finds out the shared secret key, and to confirm that he was able to decrypt the server message, he randomly sends the number Nc to the server by encrypting it with the shared secret key (step 7). <br><br>  When designing an authentication system, in contrast to the standard protocol, it is assumed that clients will not have their certificate, but will send their public key to the server, encrypting it with the server's previously public key obtained using the certificate.  This will avoid the need to obtain multiple certificates for each client, which would entail the need for the user of this client to be distracted by its configuration, which is contrary to the limitations of the system. <br><br><img src="https://habrastorage.org/storage2/d26/84c/8c1/d2684c8c142af8914f8ffa1ac1399742.jpg"><br><br>  Additional protection is provided by changing the shared secret key (Ks) at random intervals (Tk).  Read more about this in the section ‚ÄúAnalysis of the system for protection from attacks‚Äù. <br><br><h4>  Authentication System Algorithm </h4><br>  Further, all the stages of establishing a connection have been described using flowcharts. <br><br>  The client authentication system algorithm is as follows: <br><br><img src="https://habrastorage.org/storage2/f20/bbd/429/f20bbd429ab09ea766dc0a0b861bb778.jpg"><br><br>  From the server side: <br><br><img src="https://habrastorage.org/storage2/667/812/924/6678129248dc542c1dac9f846c109a91.jpg"><br><br>  After successful authentication, encrypted traffic can be transmitted.  It is assumed that traffic wakes up encrypted using the AES algorithm, using the secret key Ks.  Why AES?  Because it is the best symmetric encryption algorithm to date.  More information about him can be found on the Internet. <br><br><h4>  System analysis for protection from attacks </h4><br>  Next, I simulated various situations that may occur, and analyzed the resilience of the system to them. <br><br><h5>  Diffie-Hellman algorithm vulnerability to MITM attacks </h5><br>  This is perhaps the main drawback of this algorithm.  If we assume that the attacker impersonates the server to the client and the client to the server (for example, using ARP-spoofing), then all traffic will be routed through the attacker. <br><br><img src="https://habrastorage.org/storage2/844/425/991/844425991af8f78da02e3e6a2a6f80ed.jpg"><br><br>  One can only protect oneself from such attacks by properly thinking through the network architecture and the rules of the information security company.  For example, you can install software to detect ARP-spoofinga and similar attacks. <br><br><h5>  Connecting clients to the server without the need </h5><br>  What can happen if someone gets a client of our analyzer? <br>  On the one hand, because  the server does not transmit any important information to the client (only commands), and the client, in turn, cannot get access to important server data and only sends traffic, this will not cause any serious inconvenience. <br><br><img src="https://habrastorage.org/storage2/b62/8ff/a17/b628ffa1790f7791e28789170aed28d6.jpg"><br><br>  The only thing that can cause inconvenience is that the server database may increase indecently, but it is the server‚Äôs and administrator‚Äôs concern to disconnect unnecessary clients from the network (as it takes a long time to fill the database). <br><br>  On the other hand, the client can initiate a DOS attack by sending multiple requests to establish a shared key, then deleting the received key and sending a new request to obtain the secret key. <br><br><img src="https://habrastorage.org/storage2/40e/e18/0d4/40ee180d4d9f3061bb90beaf2045bc64.jpg"><br><br>  Here you can simply ban on the time of such customers.  Also, the client cannot initialize the update of the secret key.  The only one who knows the duration of the shared secret key is the server itself.  And only he can send a request to update the shared secret key. <br><br><h5>  The attacker gets the client's secret key and traffic from this client </h5><br>  In this situation, it is assumed that the attacker has acquired the secret key and client traffic. <br><br><img src="https://habrastorage.org/storage2/03c/e31/a92/03ce31a92847d86aa93aafc6bcd8d143.jpg"><br><br>  m - network packet (message) that is encrypted with a secret key. <br><br>  As mentioned earlier, the establishment of a shared secret key between the agent and the server in the trusted zone is performed using the Diffie-Hellman algorithm.  Unlike the standard Diffie-Hellman, in my case, it is assumed that the shared key (Ks) is changed at a random time interval that lies in the time interval (Tmin, Tmax), where Tmin and Tmax are set in the server-side settings of the application. <br><br>  This method allows to partially provide forward secrecy (secrecy of future messages) and backward secrecy (secrecy of past messages).  That is, if we assume that the attacker inside the enterprise has the previously recorded traffic, and he managed to get the current shared secret key Ks (i), he can only decrypt such traffic that was transmitted during the interval (Tmin (i), Tmax ( i)), where i is the current number of the generated shared secret key. <br><br><h4>  Conclusion </h4><br>  This article has described the design of an authentication system based on widely known authentication protocols.  A brief description of a shared secret key authentication protocol using HMAC and an authentication protocol using public key encryption was provided. <br>  At the end, a brief analysis was made of the susceptibility of the designed system to computer attacks. <br><br>  PS I would welcome comments, corrections and reasoned criticism. </div><p>Source: <a href="https://habr.com/ru/post/144282/">https://habr.com/ru/post/144282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144275/index.html">Organization of interaction architecture Activity and Service</a></li>
<li><a href="../144277/index.html">We write REST application on Sinatra and we fasten Redactor. Part 1</a></li>
<li><a href="../144278/index.html">Secret Room at Pixar Animation Studio</a></li>
<li><a href="../144280/index.html">Augmented Reality is Easy</a></li>
<li><a href="../144281/index.html">A look into the future</a></li>
<li><a href="../144284/index.html">Clodo Cloud Load Balancers</a></li>
<li><a href="../144285/index.html">Improvement suggestion: translations</a></li>
<li><a href="../144288/index.html">Noise reduction as a diffusion task</a></li>
<li><a href="../144289/index.html">Antitrust investigation against google</a></li>
<li><a href="../144290/index.html">Diskless iSCSI boot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>