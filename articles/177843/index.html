<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript MVC Framework: Comparing Marionette and Chaplin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Developing JavaScript applications is a hot topic and people are interested in which framework to choose. In this article I will compare two of them. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript MVC Framework: Comparing Marionette and Chaplin</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/4ac/11d/f88/4ac11df887c15566c6f13730e1045707.jpeg"><br><br>  Developing JavaScript applications is a hot topic and people are interested in which framework to choose.  In this article I will compare two of them. <br><br>  <a href="http://marionettejs.com/">Marionette</a> and <a href="http://chaplinjs.org/">Chaplin</a> are frameworks that run on top of the popular <a href="http://backbonejs.org/">Backbone.js</a> library.  Both want to facilitate the development of one-page JS applications.  In such applications, the frontend performs tasks that were performed on the server in the past (such as rendering HTML from data). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Backbon is designed as a minimalistic library, and not as a full-fledged framework.  My experience has shown that Beckbon is only good as the core of JS application architecture.  Both Puppet and Chaplin appeared because Beckbon provides little structuring for real-world applications.  They solve the same problems.  So there are quite a few similarities between them - perhaps even more than differences. <br><br><a name="habracut"></a><br><br>  First of all I want to declare that I am co-author of Chaplin.  But I also worked with the Puppet and follow its development.  There is another ambitious framework based on Beckbon - Toraks.  Since I did not work with him, I did not include it in this comparison. <br><br><h2>  Content </h2><br><br><ol><li>  Non-technical aspects </li><li>  General features that eliminate the disadvantages of Backbone </li><li>  Advantages of the Puppets </li><li>  Disadvantages of Puppets </li><li>  Advantages of Chaplin </li><li>  Disadvantages of Chaplin </li><li>  Conclusion </li></ol><br><br><h2>  Non-technical aspects </h2><br><br>  I‚Äôll talk about technical details later, but let's face it - the decision to choose a program is strongly influenced by their marketing, reputation, success stories and documentation. <br><br>  <a href="https://github.com/marionettejs/backbone.marionette">Puppet</a> and <a href="https://github.com/chaplinjs/chaplin">Chaplin</a> are open source projects released under the MIT license and actively developed on GitHub.  Their authors participated in the development of several large Backbon applications and transferred their experience of creating good architecture so that you would not have to step on the same rake. <br><br>  Well known companies use Puppet and Chaplin.  It is difficult to say for sure, but in general the number of users is about the same.  The Puppets Ecosystem is bigger, so many people use only parts of the Puppets instead of the whole. <br><br>  Chaplin was more popular in the beginning, and the Puppet became famous later.  The puppet is friendlier to beginners and is well documented, which is probably one of the reasons why she is chosen.  Another reason for the popularity is the contribution of Darius Bailey, the creator of Marionette, who wrote a <a href="http://lostechies.com/derickbailey">bunch of articles</a> on the development of Beckbon appliqu√©s.  He also speaks at conferences and records <a href="http://www.watchmecode.net/">video lessons</a> . <br><br><h2>  General features that eliminate the disadvantages of Backbone </h2><br><br><img src="https://habrastorage.org/storage2/b8b/7a6/314/b8b7a6314e593341cec1e928f27c189d.png"><br><br><h3>  Event-oriented architecture without the mess </h3><br><br>  A key feature of Backbone is the division of responsibility between views and models.  They interact through events ( <a href="http://en.wikipedia.org/wiki/Publish%25E2%2580%2593subscribe_pattern">Publish / Subscribe</a> ).  Using <code>Backbone.Events</code> , you can make an <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B1%25D1%258B%25D1%2582%25D0%25B8%25D0%25B9%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0">event-oriented architecture</a> .  This is a good way to separate parts of your application from each other. <br><br>  Both Puppet and Chaplin define application bottlenecks on Beckbon.  Cleaning event listeners is critical in an event-oriented architecture.  The life cycle is important: the component that created the other component is responsible for removing it.  Puppet and Chaplin solve these problems in different ways.  They not only promote the use of Publish / Subscribe, but also provide tools to avoid the common mistakes associated with the approach. <br><br><h3>  Structuring the application </h3><br><br>  Models and views are low-level patterns.  On top of this, Beckbon provides only <a href="http://backbonejs.org/">Routers</a> .  This is a very thin layer and is probably the most problematic part of the backbone.  With a pure Beckbon router, you cannot create a normal high-level architecture with memory management.  Both Puppet and Chaplin introduce <em>controllers</em> . <br><br><h3>  Powerful view conventions </h3><br><br>  Following the simplicity of Beckbon, his views and their rendering is an abstract thing.  The backbone view is responsible for one DOM element, but Beckbon does not provide tools from the box to drive data into the element and insert it into the page - the <code>View#render</code> method is empty by default. <br><br>  Puppet and Chaplin provide view classes with a robust rendering engine (see <a href="">Marionette.ItemView</a> and <a href="">Chaplin.View</a> ).  On top of this, you need to choose some template language, such as <a href="">Mustache / Hogan</a> , <a href="http://handlebarsjs.com/">Handlebars</a> or <a href="https://github.com/netzpirat/haml-coffee">HAML-coffee</a> . <br><br>  Both libraries have agreements on when to render views and how to insert them into the DOM.  You can transform the model data before it is sent to the template.  This is useful, for example, for computed properties. <br><br>  Views are probably the most difficult part of your application, so Puppet and Chaplin are additionally provided with helpers.  With them, you can create nested views and declare named <a href="">regions</a> .  You can also declaratively register model events (easier and more readable than <code>this.listenTo(this.model, ...);</code> ). <br><br>  Pure Backbon is also a minus view for working with collections (see <a href="">Marionette.CompositeView</a> and <a href="">Chaplin.CollectionView</a> ).  The bottom line is this: use a separate view for each collection model.  With this complex lists can be implemented through simple and structured code.  The views for collections are smart in themselves, they will not regenerate the entire list because of one model. <br><br><h2>  Advantages of the Puppets </h2><br><br><img src="https://habrastorage.org/storage2/a9d/8c6/0d5/a9d8c60d55828b3a36161cf426bf1599.png"><br><br>  The puppet is a storehouse of useful patterns.  It is modular, you are not required to use all parts of the Marionette.  You can start with several parts and start the rest later.  Some of the features of the Puppets come from individual plugins for Backbone, for example, <a href="https://github.com/marionettejs/backbone.babysitter">Backbone.BabySitter</a> and <a href="https://github.com/marionettejs/backbone.wreqr">Backbone.Wreqr</a> . <br><br>  In the Puppet there are also cool unique features.  In my opinion, the most powerful <em>are application modules</em> and smart <em>view management</em> . <br><br><h3>  Modules </h3><br><br>  Application modules are independent parts of the architecture, which may consist of routers, controllers, models, and views.  <a href="">The modules</a> can be started and stopped, you can still define ‚Äúhooks‚Äù that will be executed before the stop.  They can also be lazily loaded when the route matches the one set in the module. <br><br>  <a href="https://github.com/marionettejs/bbclonemail">BBCloneMail</a> is an example of an application that consists of two modules ( <a href="https://github.com/marionettejs/bbclonemail/tree/master/public/javascripts/bbclonemail/mail">mail</a> and <a href="https://github.com/marionettejs/bbclonemail/tree/master/public/javascripts/bbclonemail/contacts">contacts</a> ).  In this example, only one module is active at a time.  But in general, modules may not ‚Äúreplace‚Äù each other.  The modules have their own routers, which must be started from the very beginning ( <a href="">contact</a> <a href="">router, mail router</a> ). <br><br>  Modules can be nested.  Your main application, <a href="">Marionette.Application</a> is also a module.  Technically, there are some differences between Marionette.Application and Marionette.Module, but I hope that <a href="https://github.com/marionettejs/backbone.marionette/issues/452">in the future</a> they will become more uniform. <br><br>  You most likely will not need to use several modules from the very beginning, but this is a good feature that helps to divide the application into small, related units. <br><br><h3>  View Management </h3><br><br>  Another powerful part of the Puppets is smart view management.  Views can be easily nested with each other using the <a href="https://github.com/marionettejs/backbone.babysitter">BabySitter</a> .  In addition, Puppet adds several abstractions, like Layouts and Regions.  <a href="">Layout</a> is a view that contains named regions.  <a href="">Region</a> is the object that is responsible for the DOM element.  Examples of regions are header, navigation, main, sidebar and footer. <br><br>  Where do you need to render views and insert them into the DOM?  In the regions!  Instead of managing DOM elements directly, you can define a Region once and then just write <code>mainRegion.show(view)</code> , for example.  This will render the view and append it to the DOM element corresponding to the region.  A region holds only one view at a time, so the old view is ‚Äúclosed‚Äù (removed from the DOM and safely released from memory). <br><br>  With nested regions, you can build a complex interface simply through readable and supported code. <br><br><h2>  Disadvantages of Puppets </h2><br><br>  For the sake of brevity, I described a couple of unique Marionette features. <br><br>  I do not like weak abstractions and vague recommendations for effective use. <br><br><h3>  Routing and controllers </h3><br><br>  For example, Puppet provides very few add-ons on top of Backbone.Router.  In my opinion, this is important, since the Beckbon router does not provide any agreements on clearing the created objects from memory when the next route becomes active.  In principle, you can implement centralized cleaning using <code>route</code> events, but this is a crutch. <br><br>  There are modules in the Puppet that can be <a href="">stopped</a> and regions that can be <a href="">closed</a> .  But each time to start and stop modules or close regions is clearly not comme il faut. <br><br>  <a href="">Marionette.AppRouter</a> - step in the right direction.  His idea is to separate the configuration of the route from the code.  When the routes match, AppRouter refers to the <a href="">Controller</a> instance that responds to it. <br><br>  The controllers in the Puppet have no definite purpose, they only ‚Äúcontrol‚Äù something.  They can subscribe to events through <code>Backbone.Events</code> Events, they have methods <code>initialize</code> and <code>close</code> .  This is definitely useful, but you need to think for yourself how to use them and when.  Usually, models and views are created there. <br><br><h3>  Global and private objects </h3><br><br>  In the Puppet, modules and classes sit in a global variable, for example, <a href=""><code>window.BBCloneMail.MailApp.Controller</code></a> .  With a puppet, it becomes tempting to create globally accessible instances of classes, although it‚Äôs not at all cool to do so.  In the BBCloneMail example, some objects are passed and returned from functions, while others are available globally (for example, <a href="">BBCloneMail.MailApp.controller</a> ). <br><br>  When you read the code, it is not obvious which objects are globally accessible and which are globally used.  With the Puppet, I advise you to use the <a href="http://en.wikipedia.org/wiki/Object-capability_model">object-capability</a> pattern, with which you can associate objects without global namespaces. <br><br><h3>  Default Templates </h3><br><br>  By default, views read their templates from the DOM and compile them with the Anderskor template language ( <a href="http://underscorejs.org/">_.template</a> ).  It's simple, but embedding templates in HTML is not recommended (for example, with Chrome Web Store guidelines ‚Äî applications with templates that are compiled on the fly simply won't go there).  In the end, the templates must be in separate files, precompiled.  But, of course, you can easily add this to the Puppet - just work with <a href="">Renderer</a> . <br><br><h2>  Advantages of Chaplin </h2><br><br><img src="https://habrastorage.org/storage2/321/c29/694/321c296942639c283c24886177268088.png"><br><br>  In comparison with the Puppet, Chaplin looks more like a framework.  He is more stubborn and has stronger agreements in different areas.  He took the ideas of server-based MVC frameworks like Ruby on Rails, which follow the <a href="http://en.wikipedia.org/wiki/Convention_over_configuration">convention over configuration</a> principle.  Chaplin's goal is to provide proven practices and a convenient development environment. <br><br><h3>  Coffeefree and OOP </h3><br><br>  Chaplin is written in <a href="http://coffeescript.org/">CoffeeScript</a> , a meta-language that compiles into JavaScript.  However, applications on Chaplin may not use coffee, because Chaplin is just another JS library. <br><br>  The use of a cofescript is part of the Chaplin idea that development should be simple.  Coffeefree imposes Douglas Crockford's guideline from the book ‚ÄúJavaScript - The Good Parts‚Äù.  As a puppet, Chaplin promotes the use of <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode">ECMAScript 5 Strict Mode</a> . <br><br>  With coferscript, defining and inheriting classes is easier and cleaner than through <code>Backbone.extend</code> . <br><br>  Chaplin also actively promotes the redefinition of methods in child classes and the use of the <code>super</code> cofescript (or its equivalent in JavaScript) and tries to make class inheritance work clearly.  For example, if you declaratively define events for a class and its successor (via <code>View#events</code> ), both of them will be applied. <br><br><h3>  Modularity via AMD or CommonJS </h3><br><br>  Chaplin demands to use modules - <a href="">CommonJS</a> or <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD will do</a> .  Each module must define its own dependencies and export something (a constructor function or a single object).  Usually in Chaplin, there is one class and one module per file. <br><br>  <a href="http://www.sitepen.com/blog/2012/06/25/amd-the-definitive-source/">It's</a> not easy to <a href="http://www.sitepen.com/blog/2012/06/25/amd-the-definitive-source/">use AMD</a> , you need to know loaders a la <a href="http://requirejs.org/">require.js</a> and optimizers like <a href="https://github.com/jrburke/r.js/">r.js.</a>  Alternatively, you can use CommonJS modules and the <a href="http://brunch.io/">Brunch</a> collector, everything is much simpler. <br><br>  <a href="https://github.com/marionettejs/backbone.marionette/wiki/Using-marionette-with-requirejs">The puppet also supports AMD</a> , but does not force them to be used. <br><br><h3>  Fixed application structure </h3><br><br>  Chaplin gives a fixed structure.  It handles the bulk of all actions. <br><br><ul><li>  <code>Application</code> is the root class that runs these parts. </li><li>  <code>Router</code> replaces <code>Backbone.Router</code> </li><li>  <code>Dispatcher</code> starts and stops controllers when the route matches. </li><li>  <code>Layout</code> is the main view that monitors clicks on links. </li></ul><br><br>  In Chaplin, there is a central place to define all the routes.  Route indicates controller action.  For example, the <code>cars/:id</code> link template points to <code>cars#show</code> , that is, to the action (method) of the <code>CarsController</code> controller <code>CarsController</code> . <br><br>  <em>The controller</em> is the place where the models and views are initialized (for the main part of the screen, not the sidebars, headers).  In general, the controller action usually responds to one screen of your application. <br><br><h3>  Memory management </h3><br><br><img src="https://habrastorage.org/storage2/ce1/088/556/ce10885564e651e2490d1721fc40334b.jpeg"><br><br>  The main idea of ‚Äã‚ÄãChaplin is the controllers cleared from memory.  The main rule - the current controller and <em>all its properties</em> (models, collections, views) are deleted on the next controller.  Even if the route indicates a different action of the same controller, the old controller instance is deleted and a new one is created. <br><br>  Removing previous objects when the next route matches is a simple and effective way to clean up links.  But some objects would be better to keep in memory for several or all actions.  For this purpose, there is <a href="">Chaplin.Composer</a> , which allows you to share models and views.  If the stored object is not used by the next route, it is automatically cleared. <br><br>  In Chaplin's applications, each object is easily cleaned.  All Chaplin classes have a <code>dispose</code> method that will render the object unusable, remove all links and <a href="https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/Object/freeze">freeze</a> it. <br><br><h3>  Hidden instances of classes and Publish / Subscribe </h3><br><br>  A well-known JavaScript programming rule is to avoid global variables, and Chaplin tries to force them not to use them.  Classes in Chaplin are CommonJS / AMD modules that are not available in global namespace.  All copies, in turn, are hidden.  Two instances should not be linked to each other, unless they are closely related, like a view and its model. <br><br>  Objects can communicate with each other in an unbound form using the <a href="http://en.wikipedia.org/wiki/Publish%25E2%2580%2593subscribe_pattern">Publish / Subscribe</a> pattern.  For this purpose, there is <a href="">Chaplin.Mediator</a> .  The mediator can also be used to store some frequently used items, such as the current user's model file.  After creating the necessary properties, the mediator is <a href="https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/Object/seal">sealed</a> in order not to become a global garbage dump for your application. <br><br><h3>  Wise management </h3><br><br>  Chaplin is also strong at <a href="">managing views</a> .  It has named regions and nested views.  Chaplin uses a different approach to rendering views and inserting them into the DOM.  The viewers may have an <code>autoRender</code> flag and the <code>container</code> option.  If they are, views will be rendered immediately after creation and inserted into the DOM automatically.  Instead of the <code>container</code> option, you can specify a <code>region</code> , so that instead of a direct link to the DOM element, attach a view to a previously registered region. <br><br>  In addition to global regions, there are no abstractions in Chaplin. <code>Marionette.Layout</code> and <code>Marionette.Region</code> type puppets.  In an application with a Puppet, there are usually several nested regions and layouts.  In the application with Chaplin, you will have fewer main regions and more views embedded in them.  Of course, you can still create views for reuse with the behavior of <code>Marionette.Layout</code> , for example, <code>ThreePaneView</code> . <br><br><h2>  Disadvantages of Chaplin </h2><br><br>  As a co-author of Chaplin, I can be biased.  But I also see weaknesses and potential for improvement.  Obviously, the Puppet has found more suitable solutions to some problems. <br><br>  As I have already noted, Chaplin delineates the life cycle of each component and is therefore strong in memory management.  What is one of the main problems when creating web applications on Beckbon.  Chaplin found a solution that works well, but it is not perfect and <a href="https://github.com/chaplinjs/chaplin/issues/465">controversial</a> .  This feature has evolved and must develop further. <br><br>  Beginners difficult to understand the whole picture of Chaplin at once.  Memory management, modularity, and other Chaplin concepts are new to many JavaScript developers.  At the same time, if at the beginning these features seem to be ‚Äúin the grip‚Äù, the application will benefit from them in the long term. <br><br>  Publish / Subscribe is not a unique Chaplin opportunity when compared to the <a href="">app vent</a> Puppet.  In fact, app vent is more flexible, as each module comes with its own event aggregator. <br><br>  Chaplin uses Pub / Sub not only for broadcasting events, but also for launching commands that there is an abuse of the pubs.  <a href="https://github.com/marionettejs/backbone.wreqr">Backbone.Wreqr</a> implements the <a href="https://github.com/marionettejs/backbone.wreqr">Command / Request / Response</a> pattern for this case.  Chaplin <a href="https://github.com/chaplinjs/chaplin/issues/527">should take</a> this opportunity from the Marionette. <br><br><h2>  Conclusion </h2><br><br>  The puppet is more modular, you can only use parts that you like (I think you should use most of them, since they can improve the application).  Instead of a single central structure, you can create a <em>composite</em> architecture with independent modules.  This provides a greater separation of components, but you must understand how to use them properly. <br><br>  Chaplin is more like a framework, it is centralized and strict.  The authors of Chaplin believe that agreements increase convenience and productivity.  But, of course, your opinion on this matter may be different. <br><br>  Because of his goals, Chaplin covers more problems than other libraries.  For example, there are rich routing and dispatching systems that replace Backbone.Router, but use Backbone.History. <br><br>  In comparison with the Puppet, Chaplin is monolithic.  This does not mean that you can not do things differently.  You can still customize, modify or change the base classes and break all the rules. <br><br><h3>  Standing on the shoulders of giants </h3><br><br>  So which library to choose?  I do not think that the choice is clear.  Obviously, you should build architecture on the library that best suits your needs.  But you also need to understand and learn how to apply its best practices. <br><br>  Using Beckbon, you need to develop a scalable application architecture yourself.  <a href="https://speakerdeck.com/molily/application-frameworks-on-top-of-backbone-dot-js-talk-at-apps-dot-berlin-dot-js">Do not write applications on pure Backbone</a> , stepping on the same rake as others, learn from their experience.  Take a walk through Puppet, Toraks, <a href="https://github.com/aurajs/aura">Aura</a> , Chaplin and other architectures to explore them. <br><br>  To start using Chaplin, I recommend using one of our basic boilerplates: <a href="https://github.com/chaplinjs/chaplin-boilerplate">CoffeeScript boilerplate</a> with support for Handlebars templates, or its equivalent in <a href="https://github.com/chaplinjs/chaplin-boilerplate-plain">pure JavaScript</a> .  They include some conventions that we find quite useful: the folder structure and file naming conventions, the style of writing code, the template engines. <br><br>  If you are looking for a mature development environment for a quick start, try <br>  <a href="http://brunch.io/">Brunch with Chaplin</a> or <a href="https://github.com/chaplinjs/chaplin-rails">Chaplin + Rails boilerplate</a> . <br><br>  For a more practical introduction to the Puppet, read the article on Smashing Magazine ( <a href="http://coding.smashingmagazine.com/2013/02/11/introduction-backbone-marionette/">first</a> , <a href="http://coding.smashingmagazine.com/2013/04/02/thorough-introduction-backbone-marionette-part-2-modules/">second</a> parts).  There are a whole bunch of <a href="https://github.com/marionettejs/backbone.marionette/wiki/Books%252C-Articles%252C-Blog-Posts%252C-and-Presentations">articles, video tutorials and presentations</a> on the <a href="https://github.com/marionettejs/backbone.marionette/wiki">Puppets wiki</a> . <br><br><h3>  Thanks </h3><br><br>  Thanks to Darick Bailey, Sebastian Deutsch, Paul Miller and Paul Wittmann for reviewing this article and contributing to the development of Puppet and Chaplin. </div><p>Source: <a href="https://habr.com/ru/post/177843/">https://habr.com/ru/post/177843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../177827/index.html">Nokia showed a $ 72 QWERTY phone</a></li>
<li><a href="../177829/index.html">Defragmentation of the brain. Soft building from the inside</a></li>
<li><a href="../177831/index.html">3D printing will help repair intervertebral discs.</a></li>
<li><a href="../177837/index.html">Intel Summer School 0x7DD waiting for their students</a></li>
<li><a href="../177839/index.html">The creator of wFido opens FTN.SU reading without registration, introduces support for hypertext Fidonet</a></li>
<li><a href="../177849/index.html">Sites will start to block for "calls for violence"</a></li>
<li><a href="../177851/index.html">"CAPTCHA: Prototype" or another attempt to avoid deciphering captcha</a></li>
<li><a href="../177853/index.html">Runetology (195): Kirill Sermyagin, founder of Excursiopedia.com</a></li>
<li><a href="../177855/index.html">History modeling in centralized and distributed version control systems</a></li>
<li><a href="../177857/index.html">Swype keyboard release for Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>