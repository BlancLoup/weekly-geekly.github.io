<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding the event architecture of Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most Node objects ‚Äî such as HTTP requests, responses, and streams ‚Äî implement the EventEmitter module, through which they can generate and listen for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding the event architecture of Node.js</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/c29/4e4/7ab/c294e47abd5542f5823acd6e55d8359d.jpg"></p><br><p> Most Node objects ‚Äî such as HTTP requests, responses, and streams ‚Äî implement the <code>EventEmitter</code> module, through which they can generate and listen for events. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>)</code> </pre> <br><p>  The simplest form of event management is the callback style of some popular Node.js functions, for example <code>fs.readFile</code> .  By this analogy, an event is generated once (when the Node is ready to call a callback), and the callback acts as an event handler.  Let's first analyze this basic form of event-driven architecture. </p><a name="habracut"></a><br><h2 id="vyzovi-menya-kogda-budesh-gotov-node">  Call me when you're ready, Node! </h2><br><p>  Initially, Node handled asynchronous events using callbacks.  It was a long time ago, even before the native support of promis and async / await feature appeared in JavaScript.  Callbacks are simply functions that you pass to other functions.  This is possible in JavaScript, because functions are first-class objects. </p><br><p>  It is important to understand that callbacks are not indicators of an asynchronous call in the code.  The function can call a callback both synchronously and asynchronously.  For example, the host function <code>fileSize</code> accepts a callback function <code>cb</code> , and calls it synchronously or asynchronously, depending on the condition: </p><br><pre> <code class="hljs coffeescript">function fileSize (fileName, cb) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> fileName !== <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">'argument should be string'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Sync } fs.stat(fileName, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(err); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Async cb(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, stats.size); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Async }); }</code> </pre> <br><p>  This is a bad approach, leading to unexpected errors.  Create such host functions that accept callbacks either always synchronously or always asynchronously. </p><br><p>  Let's look at a simple example of a typical asynchronous Node function written in a callback style: </p><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readFileAsArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file, cb)</span></span></span><span class="hljs-function"> </span></span>{ fs.readFile(file, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(err); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lines = data.toString().trim().split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); cb(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, lines); }); };</code> </pre> <br><p>  <code>readFileAsArray</code> takes the file path and callback function.  It reads the contents of the file, splits it into an array of strings, and calls a callback function for this array.  Here's how to use it.  Suppose the <code>numbers.txt</code> file is in the same directory as this content: </p><br><pre> <code class="hljs">10 11 12 13 14 15</code> </pre> <br><p>  If we have a task to count the numbers in this file, then to simplify the code, you can use <code>readFileAsArray</code> : </p><br><pre> <code class="hljs javascript">readFileAsArray(<span class="hljs-string"><span class="hljs-string">'./numbers.txt'</span></span>, (err, lines) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = lines.map(<span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oddNumbers = numbers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n%<span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Odd numbers count:'</span></span>, oddNumbers.length); });</code> </pre> <br><p>  This code reads numeric content in an array of strings, parses it as a number, and performs a count. <br>  It works typical for Node callback style.  A callback has an <code>err</code> error-first argument, which can be null.  We pass this callback as the last argument to the host function.  Always do this in your functions, because users will probably count on it.  Let your host function get a callback as the last argument, and let the callback wait for an error object as its first argument. </p><br><h2 id="sovremennye-js-alternativy-kollbekam">  Modern JS alternatives to callbacks </h2><br><p>  In modern javascript there are such objects as promises.  They can be an alternative to callbacks in the case of asynchronous APIs.  Instead of passing a callback as an argument and handling errors at the same place, promis allows you to separately handle successful and erroneous situations, and also to connect several asynchronous calls into chains, rather than making them nested. </p><br><p>  If the <code>readFileAsArray</code> function supports promises, then we can use it as follows: </p><br><pre> <code class="hljs javascript">readFileAsArray(<span class="hljs-string"><span class="hljs-string">'./numbers.txt'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lines</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = lines.map(<span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oddNumbers = numbers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n%<span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Odd numbers count:'</span></span>, oddNumbers.length); }) .catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error);</code> </pre> <br><p>  Instead of passing a callback, we call the function <code>.then</code> for the return value of the host function.  Usually <code>.then</code> gives us access to the same array lines that we get in the callback version, so we can work as before.  To handle errors, we add a call to <code>.catch</code> as applied to the result, which will give us access to the error if it occurs. </p><br><p>  Thanks to the new Promise object in modern JavaScript, it has become easier to implement support for the promise interface by the host function.  Here is the <code>readFileAsArray</code> function, modified so that it supports the promis interface in addition to the already supported callback interface: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readFileAsArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file, cb = (</span></span></span><span class="hljs-function">) =&gt; </span></span>{}) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { fs.readFile(file, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { reject(err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(err); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lines = data.toString().trim().split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); resolve(lines); cb(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, lines); }); }); };</code> </pre> <br><p>  The function returns a Promise object, in which the asynchronous <code>fs.readFile</code> call is <code>fs.readFile</code> .  The promise has two arguments: the function <code>resolve</code> and <code>reject</code> .  If we need to call a callback with an error, then we use the promise function <code>reject</code> , and for the callback with data, we use the promise function <code>resolve</code> . </p><br><p>  The only difference is that we need to have a default value for the callback argument in case the code is used with a promise interface.  For example, a simple, default empty function <code>() =&gt; {}</code> can be used as an argument. </p><br><h2 id="primenenie-promisov-s-pomoschyu-asyncawait">  Using promises with async / await </h2><br><p>  Adding a promis interface makes it much easier to work with your code if you need to use an asynchronous function in a loop.  With callbacks, the situation becomes more complicated.  Promises improve things a bit, as does the function generator.  In other words, a more recent alternative for working with asynchronous code is the <code>async</code> function.  It allows you to treat asynchronous code as synchronous, which greatly improves the readability of the code. </p><br><p>  Here's how to use the <code>readFileAsArray</code> function using async / await: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countOdd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lines = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> readFileAsArray(<span class="hljs-string"><span class="hljs-string">'./numbers'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = lines.map(<span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oddCount = numbers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n%<span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">1</span></span>).length; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Odd numbers count:'</span></span>, oddCount); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err); } } countOdd();</code> </pre> <br><p>  First we create an asynchronous function - a normal function with the word <code>async</code> at the beginning.  Inside it, we call the function <code>readFileAsArray</code> , as if it returns the variable lines, and for this we use the keyword <code>await</code> .  If the <code>readFileAsArray</code> call was synchronous, then continue the code.  To do this, we execute the async function.  So it turns out simply and readable.  To work with errors, we need to wrap the async call into a <code>try/catch</code> expression. </p><br><p>  Thanks to the async / await feature, we didn't need a special API (like .then and .catch).  We only labeled functions differently and took pure javascript. </p><br><p>  We can use async / await with any function that supports the promis interface.  But we cannot - with asynchronous functions in a callback style (for example, setTimeout). </p><br><h2 id="modul-eventemitter">  EventEmitter module </h2><br><p>  An EventEmitter is a module that facilitates communication between objects in a Node.  It is the core of an asynchronous, event-driven architecture.  Many of the modules built into Node inherit from EventEmitter. </p><br><p>  His idea is simple: emitter objects generate named events that lead to invoking previously registered listeners.  So the emitter has two main functions: </p><br><ul><li>  Generating named events. </li><li>  Register and deregister listener functions. </li></ul><br><p>  To work with EventEmitter, you need to create a class that extends it. </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEmitter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Emitters are what we instantiate from EventEmitter based classes: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyEmitter();</code> </pre> <br><p>  At any time during the emitter life cycle, we can use the emit function and generate any named event. </p><br><pre> <code class="hljs mel">myEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'something-happened'</span></span>);</code> </pre> <br><p>  Generating an event is a signal that a condition is met.  Usually we are talking about changing the state of the generating object.  Using the <code>on</code> method, you can add listener functions that will be executed each time emitters generate their associated named events. </p><br><h2 id="sobytiya--asinhronnost">  Events! == asynchrony </h2><br><p>  Take a look at an example: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithLog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ execute(taskFunc) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before executing'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-string"><span class="hljs-string">'begin'</span></span>); taskFunc(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-string"><span class="hljs-string">'end'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After executing'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withLog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WithLog(); withLog.on(<span class="hljs-string"><span class="hljs-string">'begin'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'About to execute'</span></span>)); withLog.on(<span class="hljs-string"><span class="hljs-string">'end'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Done with execute'</span></span>)); withLog.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'*** Executing task ***'</span></span>));</code> </pre> <br><p>  The <code>WithLog</code> class is an emitter.  It defines one instance of the <code>execute</code> function.  It takes one argument ‚Äî the task function ‚Äî and wraps its execution in a log expression.  Events are generated before and after execution. </p><br><p>  To see the order in which everything works, we will register listeners for the named events and perform an example of the task of starting the entire chain. </p><br><p>  Result: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> executing About <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> *** Executing task *** Done <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> executing</code> </pre> <br><p>  What I want to note about the result of code execution: there is nothing asynchronous here. </p><br><ul><li>  First we get the string ‚ÄúBefore executing‚Äù. </li><li>  Then the event named <code>begin</code> causes the string ‚ÄúAbout to execute‚Äù to appear. </li><li>  Further, the actually executed string generates the string <code>¬´*** Executing task ***¬ª</code> . </li><li>  Then the <code>end</code> event named causes the string ‚ÄúDone with execute‚Äù to appear. </li><li>  At the end we get the string "After executing". </li></ul><br><p>  Just like the good old callbacks, not suggesting that events are characteristic of synchronous or asynchronous code.  This is important, because if we pass asynchronous taskFunc to <code>execute</code> , the generated events will no longer be accurate. </p><br><p>  You can emulate this situation by calling <code>setImmediate</code> : </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... withLog.execute(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'*** Executing task ***'</span></span>) }); });</code> </pre> <br><p>  Now the result will be: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> executing About <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> Done <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> executing *** Executing task ***</code> </pre> <br><p>  It is not right.  The strings after an asynchronous call, leading to the ‚ÄúDone with execute‚Äù and ‚ÄúAfter executing‚Äù calls, appear in the wrong order. </p><br><p>  To generate an event after the completion of the asynchronous function, we need to combine callbacks (or promises) with this event-driven communication.  This is demonstrated in the example below. </p><br><p>  One of the advantages of using events instead of ordinary callbacks is that we can react to the same signal many times thanks to the definition of multiple listeners.  To do the same with callbacks, you have to write more logic inside one available callback.  Events are a great way to implement numerous external plugins that add functionality to the application core.  You can consider them as "connectors" for customization of behavior when the state changes. </p><br><h2 id="asinhronnye-sobytiya">  Asynchronous events </h2><br><p>  Let's transform our synchronous example into something asynchronous and a little more useful. </p><br><pre> <code class="hljs scala">const fs = require(<span class="hljs-symbol"><span class="hljs-symbol">'f</span></span>s'); const <span class="hljs-type"><span class="hljs-type">EventEmitter</span></span> = require(<span class="hljs-symbol"><span class="hljs-symbol">'event</span></span>s'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithTime</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ execute(asyncFunc, ...args) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'begi</span></span>n'); console.time(<span class="hljs-symbol"><span class="hljs-symbol">'execut</span></span>e'); asyncFunc(...args, (err, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'erro</span></span>r', err); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'dat</span></span>a', data); console.timeEnd(<span class="hljs-symbol"><span class="hljs-symbol">'execut</span></span>e'); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'en</span></span>d'); }); } } const withTime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">WithTime</span></span>(); withTime.on(<span class="hljs-symbol"><span class="hljs-symbol">'begi</span></span>n', () =&gt; console.log(<span class="hljs-symbol"><span class="hljs-symbol">'About</span></span> to execute')); withTime.on(<span class="hljs-symbol"><span class="hljs-symbol">'en</span></span>d', () =&gt; console.log(<span class="hljs-symbol"><span class="hljs-symbol">'Done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> execute')); withTime.execute(fs.readFile, __filename);</code> </pre> <br><p>  The <code>WithTime</code> class executes <code>asyncFunc</code> and using the calls <code>console.time</code> and <code>console.timeEnd</code> reports the time spent by this <code>asyncFunc</code> .  It generates the correct sequence of events before and after execution.  It also generates error / data-events for working with ordinary asynchronous call signals. </p><br><p>  <code>withTime</code> emitter <code>withTime</code> , transferring to it a call to the asynchronous function <code>fs.readFile</code> .  Instead of processing data from a file using a callback, we can now listen to a data event. </p><br><p>  Having executed this code, we, as expected, receive the correct sequence of events, and also the report on execution time: </p><br><pre> <code class="hljs pgsql">About <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>: <span class="hljs-number"><span class="hljs-number">4.507</span></span>ms Done <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span></code> </pre> <br><p>  Please note that for this we had to combine the callback with the emitter.  If <code>asynFunc</code> also supported promises, then the same could be done with async / await: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithTime</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ async execute(asyncFunc, ...args) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'begi</span></span>n'); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { console.time(<span class="hljs-symbol"><span class="hljs-symbol">'execut</span></span>e'); const data = await asyncFunc(...args); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'dat</span></span>a', data); console.timeEnd(<span class="hljs-symbol"><span class="hljs-symbol">'execut</span></span>e'); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'en</span></span>d'); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'erro</span></span>r', err); } } }</code> </pre> <br><p>  I don‚Äôt know how for you, but for me it looks much more readable than code based on callbacks or strings with .then / .catch.  The async / await feature brings us as close as possible to JavaScript, which I consider to be a great achievement. </p><br><h2 id="argumenty-sobytiy-i-oshibki">  Event arguments and errors </h2><br><p>  In the previous example, there were two events generated with additional arguments.  Error event generated by error object. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, err);</code> </pre> <br><p>  Data event generated by the data object. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>);</code> </pre> <br><p>  After a named event, we can use as many arguments as needed, and all of them will be available inside the listener functions that we registered for these named events. </p><br><p>  For example, to work with a data event, a registered listener function will have access to the data argument that was passed to the generated event.  And this data object is exactly what the <code>asyncFunc</code> provides. </p><br><pre> <code class="hljs coffeescript">withTime.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something with data });</code> </pre> <br><p>  Usually the <code>error</code> event is special.  In the example with callbacks, if we don‚Äôt handle the error event with a listener, the Node process ends. </p><br><p>  To demonstrate this behavior, let's call the method execution again with a bad argument: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithTime</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ execute(asyncFunc, ...args) { console.time(<span class="hljs-symbol"><span class="hljs-symbol">'execut</span></span>e'); asyncFunc(...args, (err, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.emit(<span class="hljs-symbol"><span class="hljs-symbol">'erro</span></span>r', err); <span class="hljs-comment"><span class="hljs-comment">// Not Handled } console.timeEnd('execute'); }); } } const withTime = new WithTime(); withTime.execute(fs.readFile, ''); // BAD CALL withTime.execute(fs.readFile, __filename);</span></span></code> </pre> <br><p>  The first execution call (execute call) will result in an error.  Node process will crash or end: </p><br><pre> <code class="hljs pgsql">events.js:<span class="hljs-number"><span class="hljs-number">163</span></span> throw er; // Unhandled <span class="hljs-string"><span class="hljs-string">'error'</span></span> event ^ Error: ENOENT: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> such file <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> directory, <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br><p>  This crash will affect the second performance call, which may not be executed at all. </p><br><p>  If you register a listener for a special <code>error</code> event, the behavior of the Node process changes.  For example: </p><br><pre> <code class="hljs coffeescript">withTime.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something with err, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> example log it somewhere <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err) });</code> </pre> <br><p>  In this case, the error of the first execution call will be reported, but the Node process will not crash and end.  The second execution call will normally end: </p><br><pre> <code class="hljs pgsql">{ Error: ENOENT: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> such file <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> directory, <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> errno: <span class="hljs-number"><span class="hljs-number">-2</span></span>, code: <span class="hljs-string"><span class="hljs-string">'ENOENT'</span></span>, syscall: <span class="hljs-string"><span class="hljs-string">'open'</span></span>, <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>: <span class="hljs-number"><span class="hljs-number">4.276</span></span>ms</code> </pre> <br><p>  Note that now Node behaves differently with functions based on promises, it only gives a warning, but in the end it will change: </p><br><pre> <code class="hljs vhdl">UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: <span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-literal"><span class="hljs-literal">Error</span></span>: ENOENT: no such <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> directory, <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> '' DeprecationWarning: Unhandled promise rejections are deprecated. <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> the future, promise rejections that are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> handled will terminate the Node.js <span class="hljs-keyword"><span class="hljs-keyword">process</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a non-zero <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> code.</code> </pre> <br><p>  Another way to handle exceptions due to generated errors is to register a listener for a global event of the <code>uncaughtException</code> process.  However, the global catching of errors in such an event is a bad idea. </p><br><p>  Standard advice regarding <code>uncaughtException</code> : avoid using it.  But if you need it (for example, to report what happened or to clean it up), then let the process end anyway: </p><br><pre> <code class="hljs coffeescript">process.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'uncaughtException'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> something went unhandled. <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Do any cleanup <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> exit anyway! <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> don<span class="hljs-string"><span class="hljs-string">'t do just that. // FORCE exit the process too. process.exit(1); });</span></span></code> </pre> <br><p>  However, imagine that several error-events occurred simultaneously.  This means that the <code>uncaughtException</code> listener <code>uncaughtException</code> run several times, which can be a problem when cleaning up the code.  This happens, for example, when multiple calls lead to the termination of a database. </p><br><p>  The <code>EventEmitter</code> module provides a <code>once</code> method.  It signals that one call to the listener is enough.  The method is practical to use with <code>uncaughtException</code> , because at the first uncaught exception, we will start to perform the cleaning, knowing that in any case the process will end. </p><br><h2 id="poryadok-proslushivateley">  Order of listeners </h2><br><p>  If several listeners are registered for one event, they will be called up in some order.  The first registered will be the first called. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‡§™‡•ç‡§∞‡§•‡§Æ withTime.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">Length: ${data.length}</span></span>`); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‡§¶‡•Ç‡§∏‡§∞‡§æ withTime.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">Characters: ${data.toString().length}</span></span>`); }); withTime.execute(fs.readFile, __filename);</code> </pre> <br><p>  If you execute this code, then first the ‚ÄúLength‚Äù string will be entered into the log, and then ‚ÄúCharacters‚Äù, because it is in this order that we defined their listeners. </p><br><p>  If you need to define a new listener, but so that it is called first, you can use the <code>prependListener</code> method: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‡§™‡•ç‡§∞‡§•‡§Æ withTime.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">Length: ${data.length}</span></span>`); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ‡§¶‡•Ç‡§∏‡§∞‡§æ withTime.prependListener(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">Characters: ${data.toString().length}</span></span>`); }); withTime.execute(fs.readFile, __filename);</code> </pre> <br><p>  In this case, the line ‚ÄúCharacters‚Äù first appears in the log. </p><br><p>  Finally, if you need to remove the listener, use the <code>removeListener</code> method. </p><br><p>  That's all. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330048/">https://habr.com/ru/post/330048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330036/index.html">GitLab 9.2 released: Multiple task executors, pipelines on schedule, localization, disaster recovery alpha</a></li>
<li><a href="../330038/index.html">Cisco CSR 1000v: Reliability - the key to success. Part 2</a></li>
<li><a href="../330040/index.html">Flashcache - cheap and angry or alternative to HW RAID 10 SAS</a></li>
<li><a href="../330044/index.html">Chat with your own hands</a></li>
<li><a href="../330046/index.html">1 more non-recursive algorithm for generating all partitions of an integer</a></li>
<li><a href="../330052/index.html">Software Defined Radio by the hands of a sixteen year old</a></li>
<li><a href="../330056/index.html">The history of the creation of the Virtual File System Git (GVFS, Git Virtual File System)</a></li>
<li><a href="../330060/index.html">Kotlin, bytecode compilation and performance (part 1)</a></li>
<li><a href="../330062/index.html">Own scripting engine for games using C ++ and Lua (part 1)</a></li>
<li><a href="../330064/index.html">Kotlin, bytecode compilation and performance (part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>