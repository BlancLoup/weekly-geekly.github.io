<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Setting up PostgreSQL monitoring in Zabbix</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL is a modern, dynamically developing database with a very large set of features that allow you to solve the widest range of tasks. Using Pos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Setting up PostgreSQL monitoring in Zabbix</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/42c/22f/c3b/42c22fc3b4da4d44aa5d3161fda46858.jpg" alt="image"></div><br>  PostgreSQL is a modern, dynamically developing database with a very large set of features that allow you to solve the widest range of tasks.  Using PostgreSQL usually refers to a very critical segment of IT infrastructure that is associated with data processing and storage.  Considering the special place of the DBMS in the infrastructure and the degree of criticality of the tasks assigned to it, the question arises of monitoring and proper control over the work of the DBMS.  In this regard, PostgreSQL has extensive internal means of collecting and storing statistics.  Collected statistics allows you to get a pretty detailed picture of what is happening under the hood in the process of the DBMS functioning.  These statistics are stored in special system tables-views and are constantly updated.  By performing regular SQL queries in these tables, you can get a variety of data about databases, tables, indexes, and other DBMS subsystems. <br>  Below I describe the method and means for monitoring PostgreSQL in the Zabbix monitoring system.  I like this monitoring system because it provides ample opportunities for the implementation of the most custom monitoring of various systems and processes. <br><a name="habracut"></a><br>  Monitoring will be built on the basis of SQL queries to statistics tables.  The queries themselves are in the form of an additional configuration file for the zabbix agent, in which SQL queries are wrapped in a so-called.  <b>UserParameters</b> - user monitoring parameters.  Zabbix user parameter is a great way that allows you to customize monitoring for non-standard things, such things in our case will be PostgreSQL operation parameters.  Each user parameter consists of two elements: <i>Key name</i> and <i>Command</i> .  The key name is a unique name that does not overlap with other key names.  A command is the actual command-action that the zabbix agent must perform.  In the extended version, various parameters can be passed to this command.  In a zabbiks configuration, it looks like this: <br><pre><code class="bash hljs">UserParameter=custom.simple.key,/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/simple-script UserParameter=custom.ext.key[*],/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/ext-script <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span></code> </pre> <br>  Thus, all requests for PostgreSQL statistics are psql client requests wrapped in user parameters. <br><br>  Strengths: <br><ul><li>  minimum requirements for configuring the observed node - in the simplest case, we add the config and restart the zabbix agent (a complex case involves donning access rights to PostgreSQL); </li><li>  PostgreSQL connection settings, as well as thresholds for triggers, are performed via macro variables in the web interface - this way you do not need to climb into triggers and create a pattern in case of different threshold values ‚Äã‚Äãfor different hosts (macros can be assigned to a host); </li><li>  a wide range of data collected (connections, transaction time, statistics on databases and tables, streaming replication, etc.); </li><li>  low-level detection for databases, tables, and stand-by servers. </li></ul><br>  Weak sides: <br><ul><li>  a lot of observed parameters, maybe someone wants to disable something. </li><li>  depending on the PostgreSQL version, things will not work.  In particular, this concerns replication monitoring, since  Some functions are simply not available in older versions.  It was written with an eye on version 9.2 and higher. </li><li>  some things also require the presence of installed pg_stat_statements and pg_buffercache extensions - if the extensions are not installed, some of the parameters will not be available for monitoring. </li></ul><br>  Monitoring capabilities: <br><ul><li>  information on the volume of allocated and recorded buffers, checkpoints and recording time in the process of checkpoints - <a href="http://www.postgresql.org/docs/9.3/static/monitoring-stats.html">pg_stat_bgwriter</a> </li><li>  General information on shared buffers - <a href="http://www.postgresql.org/docs/9.3/static/pgbuffercache.html">pg_buffercache</a> extension is required here.  I also want to note that requests for these statistics are resource intensive, which is reflected in the documentation for the extension, so depending on the needs, you can either increase the polling interval or turn off the parameters altogether. </li><li>  general information on the service - uptime, response time, cache hit ratio, average request time. </li><li>  information on client connections and query / transaction execution time - <a href="http://www.postgresql.org/docs/9.3/static/monitoring-stats.html">pg_stat_activity</a> . </li><li>  database size and summary statistics for all databases (commits / rollbacks, read / write, temporary files) - <a href="http://www.postgresql.org/docs/9.3/static/monitoring-stats.html">pg_stat_database</a> </li><li>  table statistics (read / write, number of service tasks such as vacuum / analyze) - <a href="http://www.postgresql.org/docs/9.3/static/monitoring-stats.html">pg_stat_user_tables</a> , <a href="http://www.postgresql.org/docs/9.3/static/monitoring-stats.html">pg_statio_user_tables</a> . </li><li>  streaming replication information (server status, number of replicas, lag with them) - <a href="http://www.postgresql.org/docs/9.3/static/monitoring-stats.html">pg_stat_replication</a> </li><li>  other things (number of rows in the table, the existence of a trigger, configuration parameters, WAL logs) </li></ul><br>  Additionally, it is worth noting that to collect statistical data, it is necessary to include the following parameters in postgresql.conf: <br>  track_activities - includes command tracking (queries / statements) by all client processes; <br>  track_counts - includes collecting statistics on tables and indexes; <br><br>  Installation and configuration. <br>  Everything you need to configure is in the Github repository. <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># git clone https://github.com/lesovsky/zabbix-extensions/ # cp zabbix-extensions/files/postgresql/postgresql.conf /etc/zabbix/zabbix_agentd.d/</span></span></code> </pre><br>  Further, it should be noted that to execute requests from the agent, it is necessary that the appropriate <a href="http://www.postgresql.org/docs/9.3/static/auth-pg-hba-conf.html">access</a> is defined in the pg_hba configuration ‚Äî the agent must be able to establish connections with the postgres service to the target database and execute the requests.  In the simplest case, you need to add the following line to pg_hba.conf (for different distributions, the file location may be different) - we allow connections from the name of postgres to the mydb database from localhost. <br><pre> <code class="bash hljs">host mydb postgres 127.0.0.1/32 trust</code> </pre><br>  It‚Äôs unforgettable that after changing pg_hba.conf, the postgresql service needs to reload (pg_ctl reload).  However, this is the easiest option and not entirely secure, so if you want to use a password or a more complex access scheme, then once again carefully read <a href="http://www.postgresql.org/docs/9.3/static/auth-pg-hba-conf.html">pg_hba</a> and <a href="http://www.postgresql.org/docs/9.3/static/libpq-pgpass.html">.pgpass</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, the configuration file is copied, it remains to load it into the main configuration, make sure that there is an Include line in the main agent configuration file in the path specified where the additional configuration files are located.  Now we restart the agent, after which we can check the work by performing the simplest check - we use pgsql.ping and in square brackets we specify the connection options to postgres, which will be transferred to the psql client. <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># systemctl restart zabbix-agent.service # zabbix-get -s 127.0.0.1 -k pgsql.ping['-h 127.0.0.1 -p 5432 -U postgres -d mydb']</span></span></code> </pre><br>  If you have correctly registered the access, then the service response time in milliseconds will return to you.  If an empty string is returned, then there is a problem with accessing pg_hba.  If the ZBX_NOTSUPPORTED string is returned - the configuration did not load, check the agent configuration, paths to Include and rights set to the configuration. <br><br>  When the verification command returns the correct answer, it remains to download the template and upload it to the web interface and assign it to the target host.  You can also download the template from the repository (postgresql-extended-template.xml).  After importing, you need to go to the template macro settings tab and configure them. <br><img src="https://habrastorage.org/files/420/d39/456/420d394565dc4065a354593e0b914438.png" alt="image"><br>  Below is a list and brief description: <br><ul><li>  PG_CONNINFO are the connection parameters that will be transferred to the psql client when the request is executed.  This is the most important macro because  defines the parameters for connecting to the postgres service.  The default string is more or less universal for any cases, but if you have several servers and each server has different settings, then the hosts in the zabbiks can define a macro with the same name and set an individual value for it.  When performing a check, the host macro takes precedence over the template macro. </li><li>  PG_CONNINFO_STANDBY is the connection parameters that will be transferred to the psql utility when executing a request to the stanby server (definition of replication lag). </li><li>  PG_CACHE_HIT_RATIO is the trigger threshold for the percentage of successful cache hits;  the trigger will work if the percentage of hit is below this mark; </li><li>  PG_CHECKPOINTS_REQ_THRESHOLD - threshold for checkpoint on demand </li><li>  PG_CONFLICTS_THRESHOLD - threshold value for conflicts that occurred when executing queries on standby servers; </li><li>  PG_CONN_IDLE_IN_TRANSACTION - threshold value for connections that opened a transaction and do nothing at the same time (bad transactions); </li><li>  PG_CONN_TOTAL_PCT - threshold value for the percentage of open connections to the maximum possible number of connections (if 100%, then all connections terminated); </li><li>  PG_CONN_WAITING - the threshold for blocked requests that are waiting for the completion of other requests; </li><li>  PG_DATABASE_SIZE_THRESHOLD - threshold value for database size; </li><li>  PG_DEADLOCKS_THRESHOLD - threshold value for deadlocks (fortunately they are resolved automatically, but you should be aware of their presence, because this is direct evidence of poorly written code); </li><li>  PG_LONG_QUERY_THRESHOLD - threshold value for query execution time;  the trigger will be triggered if there are requests whose execution time is greater than this mark; </li><li>  PG_PING_THRESHOLD_MS - threshold value for service response time; </li><li>  PG_SR_LAG_BYTE - threshold for replication lag in bytes; </li><li>  PG_SR_LAG_SEC ‚Äî threshold value for replication lag in seconds; </li><li>  PG_UPTIME_THRESHOLD - uptime threshold value, if uptime is below the mark, the service has been restarted; </li></ul><br>  From the text of the triggers it should be clear why these threshold values ‚Äã‚Äãare needed: <br><ul><li>  PostgreSQL active transaction to long - a long transaction or request is fixed; </li><li>  PostgreSQL cache hit ratio too low - a very low cache hit rate; </li><li>  PostgreSQL deadlock occured - deadlock fixed; </li><li>  PostgreSQL idle in transaction connections to high - many connections in idle in transaction state; </li><li>  PostgreSQL idle transaction to long - a long transaction is fixed in the state idel in transaction; </li><li>  PostgreSQL number ‚Äî a request or transaction is pending; </li><li>  PostgreSQL recovery conflict occured - a conflict was detected during recovery on a replica; </li><li>  PostgreSQL required checkpoints occurs to frequently - checkpoints happen too often; </li><li>  PostgreSQL response to long - long response time; </li><li>  PostgreSQL service not running - the service is not running; </li><li>  PostgreSQL service was restarted - the service was restarted; </li><li>  PostgreSQL total number of connections to high - the total number of connections is too large and is approaching max_connections; </li><li>  PostgreSQL waiting transaction to long - the request or transaction is in a waiting state; </li><li>  PostgreSQL database {#DBNAME} to large - the size of the database is too large; </li><li>  PostgreSQL streaming lag between {HOSTNAME} and {#HOTSTANDBY} to high - the replication lag between servers is too high. </li></ul><br>  Low Level Discovery Rules <br><ul><li>  PostgreSQL databases discovery - detection of existing databases with the ability to filter by regular expressions.  At detection the schedule about the sizes is added; </li><li>  PostgreSQL database tables discovery - detection of existing tables in the observed database with the ability to filter by regular expressions.  Be careful with the filter and add only those tables that you are really interested in, because  this rule generates 21 parameters for each table found.  When detected, charts are added about sizes, scans, line changes, and reading statistics. </li><li>  PostgreSQL streaming stand-by discovery - detection of connected replicas.  At detection the schedule with a replication lag is added. </li></ul><br>  Available graphics, if we talk about graphics, I tried to group the observed parameters, while not overloading the graphics with an excessively large number of paramters.  So the information from pg_stat_user_tables is separated into 4 graphs. <br><ul><li>  PostgreSQL bgwriter - general information about what is happening with the buffers (how much is allocated, how much and how is recorded). </li><li>  PostgreSQL buffers - general information on the status of shared buffers (how many buffers, how many are used, how many "dirty" buffers). </li><li>  PostgreSQL checkpoints - information on ongoing checkpoints. </li><li>  PostgreSQL connections - information on client connections. </li><li>  PostgreSQL service responce - service response time and average query execution time. </li><li>  PostgreSQL summary db stats: block hit / read - read from cache and from disk. </li><li>  PostgreSQL summary db stats: events - events in the database (deadlocks, conflicts, commits, rollbacks). </li><li>  PostgreSQL summary db stats: temp files - information on temporary files. </li><li>  PostgreSQL summary db stats: tuples - general information on row changes. </li><li>  PostgreSQL transactions - query execution time. </li><li>  PostgreSQL uptime - uptime and cache hit percentage. </li><li>  PostgreSQL write-ahead log - information on the WAL log (recording volume and number of files). </li><li>  PostgreSQL: database {#DBNAME} size - information on changing the size of the database. </li><li>  PostgreSQL table {#TABLENAME} maintenance - table maintenance operations (autovacuum, autoanalyze, vacuum, analyze). </li><li>  PostgreSQL table {#TABLENAME} read stats - statistics for reading from the cache disk. </li><li>  PostgreSQL table {#TABLENAME} rows - change in rows. </li><li>  PostgreSQL table {#TABLENAME} scans - information on scanning (sequential / index scans). </li><li>  PostgreSQL table {#TABLENAME} size - information on the size of tables and their indexes. </li><li>  PostgreSQL streaming replication lag with {#HOTSTANDBY} - the size of the replication lag with replica servers. </li></ul><br>  Finally, a few sample graphics: <br>  Here, as we can see, temporary files are regularly created in the database, you should look for the culprit in the log and review work_mem. <br><img src="https://habrastorage.org/files/f8d/be8/9ca/f8dbe89caa2742009d7c826551b2505c.png" alt="image"><br><br>  Here, events taking place in the database - commits / rollbacks and conflicts / deadlocks - everything is alright here in general. <br><img src="https://habrastorage.org/files/ec3/ad6/aea/ec3ad6aea60f4afbb8262f67f41d093e.png" alt="image"><br><br>  Here the status of streaming replication with one of the servers is the lag time in seconds and bytes. <br><img src="https://habrastorage.org/files/7d5/6e6/722/7d56e67229344ae7ba085f023678cbbe.png" alt="image"><br><br>  And the final graph is the service response time and average request time. <br><img src="https://habrastorage.org/files/581/b1b/4dd/581b1b4ddd14436db1580c04c32a9de8.png" alt="image"><br><br>  That's all, thank you all for your attention! </div><p>Source: <a href="https://habr.com/ru/post/234481/">https://habr.com/ru/post/234481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234465/index.html">Technological singularity as an event inevitable</a></li>
<li><a href="../234467/index.html">Cuckoo - proprietary automated malware analysis lab</a></li>
<li><a href="../234469/index.html">LAN between houses using WiFI bridge</a></li>
<li><a href="../234471/index.html">Review WD My Cloud 2 Tb. NAS or cloud? Or maybe together?</a></li>
<li><a href="../234477/index.html">ATtiny13 firmware and programming with Arduino UPD 03/17/2016</a></li>
<li><a href="../234483/index.html">TestLink - pain and tears tester or a panacea? Implementation experience</a></li>
<li><a href="../234487/index.html">About viruses for palm trees, ecosystems and continuity</a></li>
<li><a href="../234489/index.html">Working with PostgreSQL: Adjustment and Scaling (4th Edition) and Cooking Infrastructure by Chef (1st Edition)</a></li>
<li><a href="../234491/index.html">Importation of encryption in Russia: exposing the myths</a></li>
<li><a href="../234493/index.html">Clean Mouse Day - Clean Mouse Day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>