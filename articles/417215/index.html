<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you need to know about the Python garbage collector</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a rule, you do not need to worry about the garbage collector and working with memory when you write code in Python. Once objects are no longer need...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you need to know about the Python garbage collector</h1><div class="post__text post__text-html js-mediator-article">  As a rule, you do not need to worry about the garbage collector and working with memory when you write code in Python.  Once objects are no longer needed, Python automatically frees memory from under them.  Despite this, understanding how GC works will help you write better code. <br><br><h4>  Memory manager </h4><br>  Unlike other popular languages, Python does not free all memory back to the operating system as soon as it deletes an object.  Instead, it uses an additional memory manager designed for small objects (the size of which is less than 512 bytes).  To work with such objects, it allocates large blocks of memory, in which many small objects will be stored in the future. <br><br>  As soon as one of the small objects is removed - the memory does not pass from under it to the operating system, Python leaves it for new objects with the same size.  If there are no objects left in one of the allocated memory blocks, then Python can release it to the operating system.  As a rule, the release of blocks happens when the script creates a lot of temporary objects. <br><a name="habracut"></a><br>  Thus, if a long-lived Python process begins to consume more memory over time, this does not mean at all that your code has a memory leak problem.  If you want to learn more about the memory manager in Python, you can read about it in <a href="https://rushter.com/blog/python-memory-managment/">my other article</a> (eng.). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Garbage collection algorithms </h4><br>  The standard python interpreter (CPython) uses two algorithms at once, reference counting and the generational garbage collector (hereinafter GC), better known as the standard <a href="https://docs.python.org/3.6/library/gc.html">gc module</a> from Python. <br><br>  The reference counting algorithm is very simple and efficient, but it has one major drawback.  He does not know how to define circular references.  It is because of this, in python, there is an additional collector, referred to as a generational GC, which tracks objects with potential circular references. <br><br>  In Python, the reference counting algorithm is fundamental and cannot be disabled, whereas GC is optional and can be disabled. <br><br><h4>  Link counting algorithm </h4><br>  The reference counting algorithm is one of the easiest techniques for garbage collection.  Objects are deleted as soon as they are no longer referenced. <br><br>  In Python, variables do not store values, but act as references to objects.  That is, when you assign a value to a new variable, an object is first created with this value, and only then the variable begins to refer to it.  A set of variables can refer to one object. <br><br>  Each object in Python contains an additional field (reference count) that stores the number of links to it.  As soon as someone refers to an object, this field is incremented by one.  If for some reason the link disappears, then this field is reduced by one. <br><br>  Examples when the number of links increases: <br><br><ul><li>  assignment operator </li><li>  passing arguments </li><li>  insert a new object into the list (the number of links for the object increases) </li><li>  construction of the form foo = bar (foo starts referring to the same object as bar) </li></ul><br>  As soon as the reference count for a particular object reaches zero, the interpreter starts the process of destroying the object.  If the deleted object contained references to other objects, these links are also deleted.  Thus, the deletion of one object may entail the removal of others. <br><br>  For example, if a list is deleted, the reference count in all its elements is reduced by one.  If all objects inside the list are not used anywhere else, they will also be deleted. <br><br>  Variables that are declared outside functions, classes, and blocks are called global.  Typically, the life cycle of such variables is equal to the life of the Python process.  Thus, the number of references to objects referenced by global variables never drops to zero. <br><br>  Variables that are declared inside a block (function, class) have local visibility (i.e., they are visible only inside the block).  As soon as the python interpreter leaves the block, it destroys all references created by local variables inside it. <br><br>  You can always check the number of links using the <code>sys.getrefcount</code> function. <br><br>  An example of the reference counter operation: <br><br><pre> <code class="python hljs">foo = [] <span class="hljs-comment"><span class="hljs-comment"># 2 ,    foo    getrefcount print(sys.getrefcount(foo)) def bar(a): # 4  #  foo,   (a), getrefcount       print(sys.getrefcount(a)) bar(foo) # 2 ,      print(sys.getrefcount(foo))</span></span></code> </pre><br>  The main reason why the standard interpreter (CPython) uses a reference count is historical.  There are currently many debates about this approach.  Some people believe that a garbage collector can be much more efficient without reference counting.  This algorithm has many problems, such as circular references, blocking threads, as well as additional overhead for memory and cpu. <br><br>  The main advantage of this algorithm is that objects are deleted as soon as they are not needed. <br><br><h4>  Optional garbage collector </h4><br>  Why do we need an additional algorithm when we already have a reference count? <br><br>  Unfortunately, the classic reference counting algorithm has one major drawback - it does not know how to find circular references.  Cyclic links occur when one or more objects link to each other. <br><br>  Two examples: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46f/9b6/6ae/46f9b66aed851bb88c4c430a892e5670.svg" alt="image"><br><br>  As you can see, the <code>lst</code> object refers to itself, while <code>object1</code> and <code>object2</code> refer to each other.  For such objects, the reference count will always be 1. <br><br>  Python demo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc <span class="hljs-comment"><span class="hljs-comment">#  ctypes        class PyObject(ctypes.Structure): _fields_ = [("refcnt", ctypes.c_long)] gc.disable() #   GC lst = [] lst.append(lst) #    lst lst_address = id(lst) #   lst del lst object_1 = {} object_2 = {} object_1['obj2'] = object_2 object_2['obj1'] = object_1 obj_address = id(object_1) #   del object_1, object_2 #          # gc.collect() #    print(PyObject.from_address(obj_address).refcnt) print(PyObject.from_address(lst_address).refcnt)</span></span></code> </pre><br>  In the example above, the del instruction removes references to our objects (not the objects themselves).  As soon as Python executes the del instruction, these objects become inaccessible from the Python code.  However, with the gc module turned off, they will still remain in memory, since  they had circular references and their counter is still equal to one.  You can visually explore such links using the <code>objgraph</code> library. <br><br>  In order to fix this problem, an additional algorithm was added in Python 1.5, known as the <a href="https://docs.python.org/3.6/library/gc.html">gc module</a> .  The only task of which is the removal of cyclic objects that are no longer accessible from the code. <br><br>  Cyclic links can occur only in ‚Äúcontainer‚Äù objects.  Those.  in objects that can store other objects, such as lists, dictionaries, classes, and tuples.  GC does not keep track of simple and immutable types, with the exception of tuples.  Some tuples and dictionaries are also excluded from the list of surveillance when certain conditions are met.  All other objects are guaranteed to handle reference counting. <br><br><h4>  When GC is triggered </h4><br>  Unlike the reference counting algorithm, cyclic GC does not work in real time and runs periodically.  Each launch of the collector creates micropauses in the code, so CPython (the standard interpreter) uses different heuristics to determine the frequency at which the garbage collector runs. <br><br>  The cyclic garbage collector divides all objects into 3 generations (generations).  New objects fall into the first generation.  If a new object survives the garbage collection process, then it moves to the next generation.  The higher the generation, the less often it is scanned for rubbish.  Since new facilities often have a very small lifespan (are temporary), it makes sense to interview them more often than those that have already gone through several stages of garbage collection. <br><br>  In each generation there is a special counter and a trigger threshold, upon reaching which the process of garbage collection is triggered.  Each counter stores the number of allocations minus the number of deallocations in this generation.  As soon as any container object is created in Python, it checks these counters.  If the conditions work, then the process of garbage collection begins. <br><br>  If several or more generations crossed the threshold at once, then the older generation is chosen.  This is due to the fact that older generations also scan all previous ones.  To reduce the number of garbage collection pauses for long-lived objects, the oldest generation has <a href="">an additional set of conditions</a> . <br><br>  The default thresholds for generations are set to <code>700, 10  10</code> respectively, but you can always change them using the <code>gc.get_threshold  gc.set_threshold</code> . <br><br><h4>  Cycle search algorithm </h4><br>  For a full description of the cycle search algorithm, a separate article is required.  In short, the GC iterates each object from the selected generations and temporarily removes all references from a single object (all references to which this object refers).  After a full pass, all objects whose reference count less than two is considered inaccessible from python and can be deleted. <br><br>  For a deeper understanding, I recommend reading (approx. Translator: English material) the <a href="http://arctrix.com/nas/python/gc/">original description of the algorithm from Neil Schemenauer</a> and the <code>collect</code> function from <a href="">CPython sources</a> .  A description from <a href="https://www.quora.com/How-does-garbage-collection-in-Python-work-What-are-the-pros-and-cons">Quora</a> and a <a href="https://pythoninternal.wordpress.com/2014/08/04/the-garbage-collector/">post about a garbage collector</a> can also be useful. <br><br>  It should be noted that the problem with destructors described in the original description of the algorithm has been fixed since Python 3.4 (more details in <a href="http://legacy.python.org/dev/peps/pep-0442/">PEP 442</a> ). <br><br><h4>  Optimization Tips </h4><br>  Loops often occur in real-world tasks, they can be found in problems with graphs, linked lists, or in data structures where you need to keep track of the relationships between objects.  If your program has a high load and is demanding for delays, then, if possible, cycles are best avoided. <br><br>  In places where you deliberately use circular links, you can use "weak" links.  Weak links are implemented in the <a href="https://docs.python.org/3/library/weakref.html">weakref</a> module and, unlike regular links, have no effect on the link count.  If an object with weak links is deleted, then <code>None</code> returned instead. <br><br>  In some cases, it is useful to disable the automatic assembly module gc and call it manually.  It is enough to call <code>gc.disable()</code> and then call <code>gc.collect()</code> manually. <br><br><h4>  How to find and debug circular references </h4><br>  Debugging loops can be painful, especially if your code uses a lot of third-party modules. <br><br>  The gc module provides helper functions that can help debug.  If the GC parameters are set to the <code>DEBUG_SAVEALL</code> flag, then all inaccessible objects will be added to the <code>gc.garbage</code> list. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc gc.set_debug(gc.DEBUG_SAVEALL) print(gc.get_count()) lst = [] lst.append(lst) list_id = id(lst) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> lst gc.collect() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gc.garbage: print(item) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> list_id == id(item)</code> </pre><br>  As soon as you identify the problem area, it can be visualized using <a href="https://mg.pov.lt/objgraph/">objgraph</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d8/355/be9/3d8355be99fea997cae6aff7fd7fb6b2.svg" alt="image"><br><br><h5>  Conclusion </h5><br>  The main garbage collection process is performed by a reference counting algorithm, which is very simple and has no settings.  An additional algorithm is used only for finding and deleting objects with circular references. <br><br>  You should not deal with premature code optimization for the garbage collector, in practice, serious problems with garbage collection are quite rare. <br><br>  PS: I am the author of this article, you can ask any questions. </div><p>Source: <a href="https://habr.com/ru/post/417215/">https://habr.com/ru/post/417215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417201/index.html">Alexey Zinoviev about BigData + ML on jug.msk.ru</a></li>
<li><a href="../417203/index.html">Break STM8 stack</a></li>
<li><a href="../417207/index.html">Reference: Hyperloop Superfast Trains</a></li>
<li><a href="../417209/index.html">Neural networks from scratch. Overview of courses and articles in Russian, free of charge and without registration</a></li>
<li><a href="../417211/index.html">Nastolka for learning the basics of electrical circuits. Why not?</a></li>
<li><a href="../417219/index.html">Forget burger king! There is a leak of documents is more dangerous</a></li>
<li><a href="../417221/index.html">3DTouch - Scales on the iPhone: Getting Started</a></li>
<li><a href="../417223/index.html">Capsule Neural Networks</a></li>
<li><a href="../417225/index.html">Boschernitsana theorem</a></li>
<li><a href="../417227/index.html">What happened to the Fermi paradox</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>