<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experiment with binary code in Glimmer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of an article about the experiment with a binary code in Glimmer , co-authors of the publication: Sarah Clutterbuck, Chad Hietala and Tom ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experiment with binary code in Glimmer</h1><div class="post__text post__text-html js-mediator-article">  Translation of an article about the <a href="https://engineering.linkedin.com/blog/2017/12/the-glimmer-binary-experience">experiment with a binary code in Glimmer</a> , co-authors of the publication: Sarah Clutterbuck, Chad Hietala and Tom Dale. <br><br>  Just over a year ago, <a href="https://engineering.linkedin.com/blog/2016/10/live-testing-with-play-framework-and-ember">Ember.js</a> underwent significant changes.  In close collaboration between the LinkedIn engineers and the Open Source community, we replaced Ember with the new engine for Randirang, Glimmer VM, which improved performance and significantly reduced the size of the compiled templates. <br><br>  Glimmer refers to Handlebars patterns as a functional programming language and compiles them into a sequence of instructions that can be executed in a browser.  These instructions, or opcodes (approx. Translator operation codes) are encoded into a compact data structure in the form of JSON. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When we migrated our web site linkedin.com to Glimmer, we saw significant improvements in load times.  In addition to reducing the size of files by 40%, we also reduced the time spent by the browser on the analysis of JavaScript, due to the compilation of templates in JSON.  Moreover, this change improved boot time in 90% of cases by more than 1 second. <br><br>  In this article, we will discuss a recent experiment to further improve loading times, completely eliminating the time required to parse compiled templates. <br><a name="habracut"></a><br><h3>  Expanding the experiment with Glimmer.js </h3><br>  About six months ago, the Ember.js team announced the release of Glimmer.js as a separate component library.  Separating the presentation layer allowed us to take the best from Ember and the Glimmer virtual machine, and pass it on to developers who create lightweight products, such as mobile apps for emerging markets, or SEO pages. <br><br>  Glimmer's breakthrough allowed our team to conduct many experiments in the coming months. <br>  Recently, for example, we presented a gibid render, in which html is generated on the server and then rehydrated happens (for example, see the translator <a href="https://www.emberjs.com/blog/2017/10/10/glimmer-progress-report.html">here</a> ) in the browser.  This is just the beginning of the performance benefits provided by the Glimmer virtual machine architecture. <br><br>  The Web‚Äôs holy grail of performance is the ability to quickly boot up, quickly update when the user performs actions (maintaining performance 60fps), and ensuring the default performance, which means that large teams with less experienced developers can create effective web applications without significant intervention. . <br><br>  Traditionally, there is a dilemma between delivering the minimum amount of JavaScript code to run instant downloads and the ability to have a complex responsive UI.  It seems that the fundamental compromise is that as the application grows, productivity and productivity decrease.  With Glimmer, our goal is to create light, fast and productive applications.  One of the keys to achieving this goal is to reduce the costs of each new component added to the application. <br><br><h3>  Instant Templates </h3><br>  When switching from JavaScript to JSON, the cost of parsing compiled templates is reduced, we combined Glimmer with advanced browser functions to completely eliminate the parsing step. <br><br>  When optimizing load times, most developers try to reduce file sizes in order to speed up downloads.  But in JavaScript-based applications, startup performance is also affected by the ability of the browser to analyze, compile, and evaluate your code.  What is significant, since the analysis and compilation of JavaScript code on mobile devices is 2-5 times slower than on desktop computers.  Only this single step can significantly affect the overall performance of the application. <br><br>  Today, most frameworks compile the view (view) in JavaScript functions.  The costs of parsing such JavaScript code are often hidden, and as new functions are added, the application runs slower and slower. <br><br>  As mentioned above, Glimmer compiles templates into a sequence of opcodes, which are transmitted to the browser as JSON.  Due to the fact that the JSON grammar is much simpler than the JavaScript grammar, the JSON parser can work 10 times faster than the JavaScript parser when parsing the same data. <br><br>  But it still means that the time of parsing will increase as the size of the template increases, the truth is already slower.  What if we could bypass the parsing step altogether? <br>  In recent years, browsers have learned to perfectly handle binary data.  Using a low-level API, such as <u>ArrayBuffer</u> , JavaScript programs can process binary data as quickly as their native counterparts.  We took advantage of this to compile templates into our own bytecode format, which the Glimmer virtual machine can perform directly.  Similar to the <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/">JVM</a> bytecode format, the Glimmer bytecode is a platform-independent binary format that encodes the instruction set of the Glimmer virtual machine into a stream of bytes consisting of opcodes and its operators.  Instead of running into the performance of parsing JSON or JavaScript, now we are only limited by the ability of the browser to copy raw bytes from the network. <br><br><h3>  Glimmer bytecode encoding </h3><br>  As with many virtual machines, the instructions in the Glimmer virtual machine are recognized by numbers.  a bytecode is just an encoded sequence of these numbers.  The uniqueness of Glimmer lies in the fact that its command set is intended for rendering DOM in a browser. <br><br>  For example, a pattern <br><br><pre> <code class="hljs xml"><code><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello World<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code></code> </pre> <br>  will be compiled into the following JSON format at build time: <br><br><pre> <code class="hljs json">[ [<span class="hljs-string"><span class="hljs-string">"open-element"</span></span>, <span class="hljs-string"><span class="hljs-string">"h1"</span></span>, []], [<span class="hljs-string"><span class="hljs-string">"text"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>], [<span class="hljs-string"><span class="hljs-string">"close-element"</span></span>] ]</code> </pre> <br>  In the browser at the last JSON compilation step, the format will be turned into an array of numbers, each number is an operation code or operand: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Program = [<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  Notice that the strings in our JSON were replaced by integers.  This is because we use the so-called ‚Äústring interning‚Äù technique, which eliminates duplication of identical strings, here the strings are replaced by a shift in the pool of string constants, which in practice significantly reduces the file size (just imagine how many times you repeat the string <u>div</u> in your templates). <br><br>  Initially, our bytecode encoded each operation as four 32-bit integers, where the first 32-bit number described the type of operation (opcode), and the remaining 96 bits described up to three instruction arguments (operands). <br><br>  Despite the fact that this approach is effective for executing code, there is a minus - the size of the files with byte-code is larger than necessary.  This is because we always reserve space for three operands, although most instructions do not need operands or accept only one operand.  Thus, the program is filled with empty bytes, which should not have been there.  In addition, the Glimmer instruction set contains only 80 opcodes, so we can reduce the reserved space for opcodes to 8 bits. <br><br>  Ultimately, we stopped at a more compact coding scheme, which was still 16-bit.  The first 8 bits are an opcode, the next 2 bits are used to encode the number of operands, and the last 6 bits are reserved for future use.  Each operand, if any, is encoded in an additional 16 bits. <br><br>  With this coding scheme, each instruction can take from two to six bytes, it looks like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/* Fixed Opcode */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Operand? */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Operand? */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Operand? */</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>bIIIIIIIILLRRRRRR, <span class="hljs-number"><span class="hljs-number">0</span></span>bAAAAAAAAAAAAAAAA, <span class="hljs-number"><span class="hljs-number">0</span></span>bAAAAAAAAAAAAAAAA, <span class="hljs-number"><span class="hljs-number">0</span></span>bAAAAAAAAAAAAAAAA] <span class="hljs-comment"><span class="hljs-comment">/* I = instruction (opcode) type L = operand length R = reserved A = operand value */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> raw</code> </pre> <br>  This new scheme reduces the size of the compiled program by 50%.  "Decoding" of this scheme has a slight overhead, since we simply mask and shift the bits to find out the length of the opcode and the length of the operand. <br><br><h3>  Eliminating the gap between bytecode and javascript </h3><br>  One of the problems we encountered was to move the entire compilation phase into the project builder.  Previously, we performed the last step of compiling templates in the browser as soon as the JavaScript code of the application was loaded.  This allowed us to combine compiled templates with JavaScript objects, such as component classes that processed user actions. <br><br>  The first step was to provide all levels of compilation on Node.js.  We created a new interface called ‚Äúbundle compiler‚Äù, which encapsulated all levels of compilation into one API, which allowed the build tools to turn the ‚Äúbundle‚Äù of templates into byte-code. <br><br>  Then we faced an additional problem: when compiling to bytecode, how would we ‚Äúconnect‚Äù this bytecode back to the right JavaScript objects at runtime?  To solve this problem, we introduced the concept of ‚Äúhandles‚Äù (handlers).  A handler is a unique numeric identifier that is associated with external objects in a template, such as components or helpers.  During compilation, we associate each external object with a handler, which is encoded into bytecode.  For example, if we see a call to the <u>&lt;UserProfile /&gt;</u> component, we can associate it with the handler with identifier <u>42</u> (assuming that 41 unique components have already been called before). <br><br>  A component call for this is compiled into several opcodes in the Glimmer command set.  One of these instructions is <u>0x003b PushComponentDefinition</u> , which pushes the component's JavaScript class <u>onto</u> the virtual machine (VM) stack.  When compiling to bytecode, this instruction will create four bytes: <u>0x00 0x3b 0x01 0x2A</u> .  The first two bytes encode the opcode <u>PushComponentDefinition</u> .  The second two bytes encode the operand, which in this case is a processor (the number 42). <br><br>  And so what happens when we run the bytecode in the browser?  How to turn the whole number 42 into a living, breathing JavaScript class?  We call this trick the ‚Äúexternal module table‚Äù.  This is a small fragment of the generated JavaScript code that unites the two worlds, defining a data structure that allows you to effectively map handlers with the corresponding JavaScript classes. <br><br>  In our example, we have associated <u>UserProfile</u> with handler 42, so our plug-in table is an array, where the class <u>UserProfile</u> is 42 elements in the array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserProfile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./src/ui/components/UserProfile/component'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ...other component imports */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> table = [ <span class="hljs-comment"><span class="hljs-comment">/* Component1 */</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Component2 */</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* Component41 */</span></span>, UserProfile, <span class="hljs-comment"><span class="hljs-comment">/* Component43 */</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> ];</code> </pre> <br>  During the execution of a bytecode, a helper object called a ‚Äúresolver‚Äù turns the handler into a corresponding JavaScript object.  Since each handler is also an offset in the array, this code is simple and fast: <br><br><pre> <code class="javascript hljs">resolve&lt;U&gt;(handle: number): U { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.table[handle]; }</code> </pre> <br><img src="https://habrastorage.org/webt/ym/jw/an/ymjwan3-db6ubwp9ks7takdadhw.png" alt="image"><br><br>  Build the project in .gbx format (Glimmer Binary Experience), transfer to the browser, and VM rendering the header in the browser. <br><br><h3>  What's next </h3><br>  We simply integrated the bytecode compiler into the internal application to prove the concept of Glimmer.js and look forward to collecting real results in the production application.  This will help us assess the impact of these changes in the real world with different participants on different hardware, operating systems, browsers, and bandwidth combinations. <br><br>  Since Glimmer's bytecode reduces file size and completely eliminates the cost of parsing and compiling the last step, we expect significant improvements in application launch time, especially on devices with weak hardware capabilities, where the CPU is a bottleneck.  Perhaps more importantly, the process of matching the file format and the internal elements of a virtual machine in the direction of a well-defined binary format opens up many interesting experiments in the future.  In particular, our chosen bytecode format means that we are in a good position to research and change some parts of the Glimmer virtual machine in the direction of WebAssembly technology, reducing the cost of parsing and further improving performance at runtime. <br><br>  We are all LinkedIn big fans of open source, and all the work described above was opened on GitHub.  If we are interested in the Glimmer project, we invite you to the <a href="https://github.com/glimmerjs/glimmer-vm">Glimmer VM</a> and <a href="">Glimmer.js repositories</a> on GitHub. <br><br><h3>  Thanks </h3><br>  Many thanks to <a href="https://www.linkedin.com/in/chadhietala/">Chad Hietale</a> and <a href="https://www.linkedin.com/in/tommothereffindale/">Tom Dale</a> , who set about compiling a bytecode on LinkedIn.  In addition, thanks to <a href="https://www.linkedin.com/in/yehudakatz/">Yehuda Katz</a> and <a href="https://www.linkedin.com/in/godfreykfc/">Godfrey Chen</a> for helping to realize this vision in the open source community. </div><p>Source: <a href="https://habr.com/ru/post/348586/">https://habr.com/ru/post/348586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348572/index.html">Security week 3: a thief from a bitcoin thief stole, your trojan could be here, ten days without computers</a></li>
<li><a href="../348574/index.html">From regular office to fully distant work: how we built an effective corporate culture</a></li>
<li><a href="../348578/index.html">Serverless application with AWS and Bitbucket Pipelines CI / CD implementation</a></li>
<li><a href="../348582/index.html">Some interesting data drawn from the ‚ÄúMy Circle‚Äù autocompletion</a></li>
<li><a href="../348584/index.html">How to avoid performance problems when creating React-applications</a></li>
<li><a href="../348588/index.html">Black Friday 2017 through the eyes of IT and developers. As we stood black Friday with a 10 times increase in traffic</a></li>
<li><a href="../348590/index.html">What is not written in the documentation, or the subtleties of refactoring on .Net Core</a></li>
<li><a href="../348592/index.html">Fintech Digest: eBay vs. PayPal, the international payment system on the blockchain</a></li>
<li><a href="../348594/index.html">Internet people and non-people</a></li>
<li><a href="../348596/index.html">Traffic Management with Fiddler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>