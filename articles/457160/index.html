<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My approach to implementing delegates in C ++: calling a function with unknown parameters at runtime</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prehistory 
 I like the C ++ language. I would even say that this is my favorite language. In addition, for my development I use .NET technologies, an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My approach to implementing delegates in C ++: calling a function with unknown parameters at runtime</h1><div class="post__text post__text-html js-mediator-article"><h2>  Prehistory </h2><br>  I like the C ++ language.  I would even say that this is my favorite language.  In addition, for my development I use .NET technologies, and many of the ideas in it, in my opinion, are simply amazing.  Once I had an idea - how to implement some means of reflection and dynamic function call in C ++?  I really wanted C ++ to have the advantage of the CLI, like calling a delegate with an unknown number of parameters and their types.  This can be useful, for example, when it is not known in advance what types of data are needed by the function to be called. <br><br>  Of course, a complete imitation of delegates is too complicated, so this article will demonstrate only the general architecture of the library and the solution of some important problems that arise when dealing with something that is not directly supported by the language. <br><a name="habracut"></a><br><h2>  Calling functions with an indefinite number of parameters and unknown types during compilation </h2><br>  Of course, this is the main problem with C ++, which is not so easy to solve.  Of course, in C ++ there is a tool inherited from C - <i>varargs</i> , and, most likely, this is the first thing that comes to mind ... However, they are not suitable, firstly, because of their type-safe nature (like many things from C), secondly, when using such arguments, it is necessary to know in advance exactly what types the arguments have.  However, almost certainly, this is not all the problems with <i>varargs</i> .  In general, this tool is not our assistant. <br><br>  And now I will list the funds that helped me solve this problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  std :: any </h3><br>  Beginning with C ++ 17, a wonderful storage container for anything appeared in the language - some distant similarity of <i>System.Object</i> in the CLI is <i>std :: any</i> .  This container can really store anything, and how to: efficiently!  - The standard recommends that small objects be stored directly in it, large ones can already be stored in dynamic memory (although this behavior is not mandatory, Microsoft has done just that in its C ++ implementation, which is good news).  And it can only be called a similarity because System.Object participates in the inheritance relationship (‚Äúis a‚Äù), and std :: any participates in the ownership relationship (‚Äúhas a‚Äù).  In addition to data, the container contains a pointer to an object <i>std :: type_info</i> - RTTI about a type whose object is ‚Äúlying‚Äù in the container. <br><br>  For the container, the whole <b>&lt;any&gt;</b> header file is highlighted. <br><br>  To ‚Äúpull out‚Äù an object from a container, you need to use the template function <i>std :: any_cast ()</i> , which returns a reference to the object. <br>  Example of use: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;any&gt; void any_test() { std::any obj = 5; int from_any = std::any_cast&lt;int&gt;(obj); }</span></span></span></span></code> </pre> <br>  If the requested type does not match the one that the object has inside the container, then the exception <i>std :: bad_any_cast is thrown</i> . <br><br>  In addition to the <i>std :: any</i> , <i>std :: bad_any_cast classes</i> and the <i>std :: any_cast functions</i> , the header file contains the template function <i>std :: make_any</i> , similar to <i>std :: make_shared</i> , <i>std :: make_pair,</i> and other functions of this kind. <br><br><h3>  RTTI </h3><br>  Of course, it would be practically impossible in C ++ to implement dynamic function calls without type information at runtime.  After all, it is necessary to somehow check whether the correct types are transferred or not. <br><br>  Primitive support for RTTI in C ++ has been around for quite some time.  That's just the fact of the matter is that the primitive - we can learn little about the type, except decorated and undecorated names.  In addition, we can compare types with each other. <br><br>  Typically, the term "RTTI" is used in connection with polymorphic types.  However, here we will use this term in a wider sense.  For example, we will take into account the fact that type information at runtime is on each type (although it can only be obtained statically, at compile time, unlike polymorphic types).  Therefore, it is possible (and necessary) to compare the types of even non-polymorphic types (sorry for tautology) at run time. <br>  Access to RTTI can be obtained using the class <i>std :: type_info</i> .  This class is in the <b>&lt;typeinfo&gt;</b> header file.  A link to an object of this class can be obtained (at least for now) only with the help of the <i>typeid ()</i> operator. <br><br><h3>  Templates </h3><br>  Another extremely important feature of the language that we need to implement our ideas is templates.  This tool is quite powerful and extremely difficult, in fact allows you to generate code at compile time. <br><br>  Templates are a very broad topic, and it will not be possible to reveal it within the framework of the article, and it is not necessary.  We assume that the reader understands what they mean.  Some obscure points will be revealed in the process. <br><br><h3>  Packing arguments with a subsequent call </h3><br>  So, we have a certain function that takes several parameters as input. <br><br>  I will demonstrate a sketch of the code that explains my intentions. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Variadic_args_binder.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;any&gt; int f(int a, std::string s) { std::cout &lt;&lt; "int: " &lt;&lt; a &lt;&lt; "\nstring: " &lt;&lt; s &lt;&lt; std::endl; return 1; } void demo() { std::vector&lt;std::any&gt; params; params.push_back(5); params.push_back(std::string{ "Hello, Delegates!" }); delegates::Variadic_args_binder&lt;int(*)(int, std::string), int, std::string&gt; binder{ f, params }; binder(); }</span></span></span></span></code> </pre> <br>  You may ask - how is this possible?  The class name <i>Variadic_args_binder</i> suggests that the object binds the function and the arguments that need to be passed to it when called.  Thus, it remains only to call this binder as a function without parameters! <br>  So it looks outside. <br><br>  If immediately, without thinking, to make an assumption how this can be implemented, then it may come to mind to write several <i>Variadic_args_binder</i> specializations for a different number of parameters.  However, this is not possible if it is necessary to support an unlimited number of parameters.  And the problem is: the arguments, unfortunately, need to be substituted statically into the function call, that is, in the end for the compiler, the calling code should be reduced to this: <br><br><pre> <code class="cpp hljs">fun_ptr(param1, param2, ‚Ä¶, paramN);</code> </pre> <br>  This is how C ++ works.  And this complicates things a lot. <br><br>  Only patterned magic can do this! <br><br>  The main idea is to create recursive types that store one of the arguments or a function at each nesting level. <br><br>  So, let's declare the <i>_Tagged_args_binder</i> class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> delegates::impl { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">;</span></span> }</code> </pre> <br>  To conveniently ‚Äútransfer‚Äù type packages, create an auxiliary type <i>Type_pack_tag</i> (why it was needed, it will become clear soon): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type_pack_tag</span></span></span><span class="hljs-class"> {</span></span> };</code> </pre> <br>  Now we create specializations of the <i>_Tagged_args_binder</i> class. <br><br><h4>  Initial specialization </h4><br>  As it is known, that the recursion was not infinite, it is necessary to define boundary cases. <br>  The following specializations are initial.  To simplify, I will give specializations only for non-reference types and right-side reference types (rvalue reference). <br>  Specialization for directly parameter-values: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types_to_construct&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, Type_pack_tag&lt;T1, Types_to_construct...&gt;, Type_pack_tag&lt;&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, T1&gt;, <span class="hljs-string"><span class="hljs-string">"Void argument is not allowed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Func_type, T1, Types_to_construct...&gt;; _Tagged_args_binder(Func_type func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&gt;&amp; args) : ap_arg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-number"><span class="hljs-number">0</span></span>))) }, ap_caller_part{ func, args } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg))); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg))); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: _Tagged_args_binder&lt;Func_type, Type_pack_tag&lt;Types_to_construct...&gt;, Type_pack_tag&lt;T1&gt;&gt; ap_caller_part; T1 ap_arg; };</code> </pre> <br>  The first argument of the <i>ap_arg</i> call and the rest of the recursive <i>ap_caller_part</i> object are <i>stored here</i> .  Note that the type <i>T1</i> ‚Äúmoved‚Äù from the first type package in this object to the second in the ‚Äútail‚Äù of the recursive object. <br><br>  Specialization for rvalue links: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types_to_construct&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, Type_pack_tag&lt;T1&amp;&amp;, Types_to_construct...&gt;, Type_pack_tag&lt;&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> move_ref_T1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_rvalue_reference_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T1&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Func_type, move_ref_T1, Types_to_construct&gt;; _Tagged_args_binder(Func_type func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&gt;&amp; args) : ap_arg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-number"><span class="hljs-number">0</span></span>))) }, ap_caller_part{ func, args } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg)))); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(ap_arg)))); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: _Tagged_args_binder&lt;Func_type, Type_pack_tag&lt;Types_to_construct...&gt;, Type_pack_tag&lt;move_ref_T1&gt;&gt; ap_caller_part; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any ap_arg; };</code> </pre> <br><br>  Template ‚Äúright-hand‚Äù links are not really right-hand values.  These are the so-called ‚Äúuniversal links‚Äù, which, depending on the type of <i>T1</i> , become either <i>T1 &amp;</i> then <i>T1 &amp;&amp;</i> .  Therefore, it is necessary to use workarounds: first, since the specializations for both types of links are defined (not quite correctly stated, for the reason already stated) and for non-reference parameters, when the template is instantiated, the necessary specialization will be chosen, even if it is a right-side link;  secondly, to transfer the type <i>T1</i> from the packet to the packet, use the corrected version of <i>move_ref_T1</i> , converted into a real rvalue-link. <br><br>  Specialization with the usual link is done similarly, with the necessary corrections. <br><br><h4>  Ultimate specialization </h4><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Param_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, Type_pack_tag&lt;&gt;, Type_pack_tag&lt;Param_type...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Func_type, Param_type...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> _Tagged_args_binder(Func_type func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&gt;&amp; args) : ap_func{ func } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Param_type... param)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">(ap_func(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;Param_type&gt;(param)...))&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_func(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_func(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)...)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Param_type... param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_func(param...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_func(param...)); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func_type ap_func; };</code> </pre> <br>  This specialization is responsible for storing the functional object and, in fact, is a wrapper over it.  It is the final recursive type. <br><br>  Notice how <i>Type_pack_tag is</i> used here.  All types of parameters are now collected in the left package.  This means that they are all processed and packaged. <br><br>  Now, I think it becomes clear why it was necessary to use <i>Type_pack_tag</i> .  The fact is, the language would not allow using two types of packages side by side, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types_to_construct, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Param_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, T1, Types_to_construct..., Param_type...&gt; {</span></span> };</code> </pre> <br>  therefore it is necessary to separate them into two separate packages within two types.  In addition, you must somehow separate the processed types from those that have not yet been processed. <br><br><h4>  Intermediate specializations </h4><br>  Of the intermediate specializations, finally, I will give a specialization, again, for value types, the rest by analogy: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types_to_construct, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Param_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tagged_args_binder</span></span></span><span class="hljs-class">&lt;Func_type, Type_pack_tag&lt;T1, Types_to_construct...&gt;, Type_pack_tag&lt;Param_type...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;Func_type, Param_type..., T1, Types_to_construct...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, T1&gt;, <span class="hljs-string"><span class="hljs-string">"Void argument is not allowed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> _Tagged_args_binder(Func_type func, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&gt;&amp; args) : ap_arg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(unihold::reference_any_cast&lt;T1&gt;(args.at(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Param_type)))) }, ap_caller_part{ func, args } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Param_type... param)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg))); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Param_type... param)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same_v&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Ret_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ret_type&gt;(ap_caller_part(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Param_type&gt;(param)..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ap_arg))); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: _Tagged_args_binder&lt;Func_type, Type_pack_tag&lt;Types_to_construct...&gt;, Type_pack_tag&lt;Param_type..., T1&gt;&gt; ap_caller_part; T1 ap_arg; };</code> </pre> <br>  This specialization is intended for the packaging of any argument except the first. <br><br><h4>  Class binder </h4><br>  The <i>_Tagged_args_binder</i> class <i>is</i> not intended to be used directly, which I wanted to emphasize with a single underscore at the beginning of its name.  Therefore, I will give the code of a small class, which is a kind of ‚Äúinterface‚Äù to this ugly and inconvenient to use type (which, however, uses rather unusual C ++ techniques, which gives it some charm, in my opinion): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> cutecpplib::delegates { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Functor_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Param_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variadic_args_binder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> binder_type = impl::_Tagged_args_binder&lt;Functor_type, Type_pack_tag&lt;Param_type...&gt;, Type_pack_tag&lt;&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ret_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">invoke_result_t</span></span>&lt;binder_type&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Variadic_args_binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Functor_type function, Param_type... param)</span></span></span><span class="hljs-function"> : ap_tagged_binder</span></span>{ function, param... } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Variadic_args_binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Functor_type function, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::any&gt;&amp; args)</span></span></span><span class="hljs-function"> : ap_tagged_binder</span></span>{ function, args } { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ap_tagged_binder(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ap_tagged_binder(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: binder_type ap_tagged_binder; }; }</code> </pre><br><h4>  Unihold agreement - passing links inside <i>std :: any</i> </h4><br>  The attentive reader probably noticed that the code uses the <i>unihold :: reference_any_cast ()</i> function.  This function, as well as its counterpart <i>unihold :: pointer_any_cast ()</i> , is designed to implement the library's agreement: the arguments that need to be passed by reference are passed by pointer to <i>std :: any</i> . <br><br>  The <i>reference_any_cast</i> function always returns a reference to an object, whether the object itself is stored in the container or only a pointer to it.  If <i>std :: any</i> contains an object, then a reference to this object is returned inside the container;  if it contains a pointer, then a reference is returned to the object the pointer points to. <br><br>  For each of the functions, there are variants of the constant <i>std :: any</i> and overloaded versions to determine whether the <i>std :: any</i> container owns the object or contains only a pointer. <br><br>  Functions need to be specialized explicitly with the type of the stored object, as well as C ++ type conversions and similar template functions. <br><br>  The code for these functions is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp; unihold::reference_any_cast(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&amp; wrapper) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_any_cast&lt;T&gt;(wrapper, result); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp; unihold::reference_any_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&amp; wrapper) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_any_cast&lt;T&gt;(wrapper, result); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp; unihold::reference_any_cast(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&amp; wrapper, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; is_owner) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = pointer_any_cast&lt;T&gt;(&amp;wrapper, is_owner); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_any_cast{ }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ptr; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;&amp; unihold::reference_any_cast(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any&amp; wrapper, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; is_owner) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = pointer_any_cast&lt;T&gt;(&amp;wrapper, is_owner); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_any_cast{ }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ptr; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;* unihold::pointer_any_cast(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::any* wrapper, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; is_owner) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NR_T = <span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;T&gt;; <span class="hljs-comment"><span class="hljs-comment">// No_reference_T //     wrapper NR_T** double_ptr_to_original = any_cast&lt;NR_T*&gt;(wrapper); //      wrapper NR_T* ptr_to_copy; if (double_ptr_to_original) { // Wrapper      is_owner = false; return *double_ptr_to_original; } else if (ptr_to_copy = any_cast&lt;NR_T&gt;(wrapper)) { // Wrapper    is_owner = true; return ptr_to_copy; } else { throw bad_any_cast{}; } } template &lt;typename T&gt; const std::remove_reference_t&lt;T&gt;* unihold::pointer_any_cast(const std::any* wrapper, bool&amp; is_owner) { using namespace std; using NR_T = remove_reference_t&lt;T&gt;; // No_reference_T //     wrapper NR_T*const * double_ptr_to_original = any_cast&lt;NR_T*&gt;(wrapper); //      wrapper const NR_T* ptr_to_copy; //remove_reference_t&lt;T&gt;* ptr2 = any_cast&lt;remove_reference_t&lt;T&gt;&gt;(&amp;wrapper); if (double_ptr_to_original) { // Wrapper      is_owner = false; return *double_ptr_to_original; } else if (ptr_to_copy = any_cast&lt;NR_T&gt;(wrapper)) { // Wrapper    is_owner = true; return ptr_to_copy; } else { throw bad_any_cast{}; } } template &lt;typename T&gt; std::remove_reference_t&lt;T&gt;* unihold::pointer_any_cast(std::any* wrapper) { bool result; return pointer_any_cast&lt;T&gt;(wrapper, result); } template &lt;typename T&gt; const std::remove_reference_t&lt;T&gt;* unihold::pointer_any_cast(const std::any* wrapper) { bool result; return pointer_any_cast&lt;T&gt;(wrapper, result); }</span></span></code> </pre><br><h2>  Conclusion </h2><br>  I tried to briefly describe one of the possible approaches to solving the problem of dynamic function call in C ++.  Subsequently, this will form the basis of the delegates library in C ++ (in fact, I have already written the main library functionality, namely, polymorphic delegates, but the library still needs to be rewritten as necessary so that you can demonstrate the code and add some unimplemented functionality).  In the near future I plan to finish the work on the library and tell you exactly how I implemented the rest of the delegates functionality in C ++. <br><br>  PS The use of RTTI will be demonstrated in the next section. </div><p>Source: <a href="https://habr.com/ru/post/457160/">https://habr.com/ru/post/457160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45715/index.html">CSS Project: Abstract Data Types and Algorithms</a></li>
<li><a href="../457150/index.html">New Windows Terminal is already available in Microsoft Store</a></li>
<li><a href="../457152/index.html">Conference DEFCON 25. Garry Kasparov. "The Last Battle of the Brain." Part 1</a></li>
<li><a href="../457154/index.html">Adaptive design of the application for each user</a></li>
<li><a href="../457156/index.html">What could be the computing systems of the future</a></li>
<li><a href="../457164/index.html">Navigation in a cross-platform .NET Core application with saving state to disk using ReactiveUI and Avalonia as an example</a></li>
<li><a href="../457172/index.html">ScreenLogger - smile, you are hidden camera</a></li>
<li><a href="../457178/index.html">How processors are developed and manufactured: design of the CPU</a></li>
<li><a href="../45718/index.html">Quake III Server on Nokia Phone</a></li>
<li><a href="../457180/index.html">The official site of Node.js is now in Russian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>