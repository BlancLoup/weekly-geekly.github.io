<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pumping C # Performance with Federico Luis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about performance in C #, about how to pump it beyond recognition. The goal of this article is to demonstrate ways to increase prod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pumping C # Performance with Federico Luis</h1><div class="post__text post__text-html js-mediator-article"><p>  Today we will talk about performance in C #, about how to pump it beyond recognition.  The goal of this article is to demonstrate ways to increase productivity, which, if necessary, you could use yourself.  However, these techniques are not universal - you can not use them as a general solution to any problem.  They are good in the presence of very specific use cases, which will be discussed below. </p><br><p>  The report of Federico Luiz, the founder of Corvalius (they are involved in R &amp; D) was chosen as a prototype of the article.  Working on a database engine for one of the clients, they devoted about four years to optimization problems.  This amount of time is required in order to apply all sorts of techniques and achieve good optimization indicators.  It is required to identify all the problems and bottlenecks, to trace the behavior of the software in accordance with all available metrics and so on.  The examples in this article are based on the work on RavenDB 4.0 (the well-known NoSQL base for .NET), which Federico Tyunil‚Äôs company is down to the nanosecond level in all sorts of complex cases. </p><br><p>  All the examples that you will encounter during the story (plus some additional ones) are available <a href="https://github.com/redknightlois/performance-course">in a special repository on GitHub</a> . </p><br><blockquote>  Caution traffic!  In this post there is a huge number of pictures - slides and screenshots from a video in 720p format.  On the slides there is an important code for understanding the article. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7GTpwgsmHgU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h1 id="nemnogo-matematiki">  A bit of math </h1><br><p>  Imagine that you came back from the next DotNext or Habra was reported during working hours, and your boss, believing that you were pumping high-quality in terms of performance, suggests developing a system that would perform 20 billion operations per day.  Think about this number!  Obviously, the idea is crazy - to realize unreal  However, let's try to dig deeper and understand one important thing: 20 billion operations must be performed within 24 hours of <em>continuous</em> node <em>operation</em> .  High or not, but our productivity will necessarily be sustainable.  This fact allows us to go to other numbers: 20000000000/24 ‚Äã‚Äã= 833333333 operations per hour.  Is it easier for us?  No, really.  But we can continue to break our indicator further.  We get that the required number of operations per minute: 833333333/60 = 13888888. Such a number is more or less amenable to counting.  In the next step, we get the number of operations per second - 13888888/60 = 231481. In practice, the further solution of the problem is usually very simple: we take, say, 40 servers, each of which would have a performance of 231481/40 = 5787 operations per second .  Better yet, if we take 1500 servers with a capacity of 231481/1500 = 154 operations per second.  With these figures you can already work.  It turns out that the number that initially seemed incredibly large to us no longer produces such horror.  A single node and as many as 5 milliseconds of its operation will be provided for performing one operation.  Moreover, in this case, we can confidently talk about the speed of our system.  For comparison, computer games are released to the market with a mark of 13 milliseconds. </p><br><h1 id="poryadok-chisel">  Order of numbers </h1><br><p>  Most high-performance systems sold are characterized by the ability of a single node to process about 600 requests per second in continuous mode.  How is this possible?  Of course, the indicator largely depends on the benchmark that is presented to the system: do we simply perform a series of repetitive operations that return the same thing each time, or do we send messages all over the world and generally know what?  But the fact is that if our goal is to ensure that the node executes 600 requests per second in continuous mode, then in the initial design of the system we must lay the indicator 10 times larger and focus on it.  And 6000 requests is a task that requires a different kind of effort from an engineering point of view.  6000 operations per second - an indicator that requires planning.  It is necessary that someone constantly monitors the new code, which is added to the code base, and does not miss anything that puts the figure in 6000 operations at risk.  And ultimately you will achieve this goal.  But in order to achieve a performance that would be higher not by one, but by two orders of magnitude, that is, 60,000 operations per second, the same techniques will no longer work.  Here we will need serious sophistication.  Today I would like to share with you the secrets that we use in our work. </p><br><h1 id="obsuzhdat-ne-budem-no-primem-za-aksiomy">  We will not discuss, but we take for axioms </h1><br><ul><li>  Interop is a constant source of resource overhead: <br><ul><li>  Performance kills high marshaling frequency; </li></ul></li><li>  Garbage collection is a major source of performance problems; </li><li>  You cannot use try-catch and LINQ: <br><ul><li>  <a href="https://docs.microsoft.com/en-us/cpp/build/prolog-and-epilog">Epilogue and prologue</a> for exceptions - not free; </li><li>  Calls to LINQ methods lead to memory allocation; </li><li>  With a high frequency of short operations, everything was gone; </li></ul></li><li>  Any access to values ‚Äã‚Äãvia interfaces leads to heap memory allocation (in other words, there will be boxing; </li><li>  Value types need to be optimized in a special way; </li><li> <code>unsafe</code> is called unsafe for a reason; </li><li>  GC pinning (explicitly blocking objects, prohibiting their movement in the memory by the garbage collector) is very expensive. </li></ul><br><h1 id="vsyo-chto-nuzhno-znat-ob-inlayninge">  Everything you need to know about inlining </h1><br><ul><li>  Compiler directives are nothing more than hints; </li><li>  By applying inline, we reduce: <br><ul><li>  the number of instruction cache misses; </li><li>  the number of Push / Pop operations and parameter processing; </li><li>  the number of context switches at the processor level; </li></ul></li><li>  By applying inline, we increase: <br><ul><li>  the size (in bytes) of the calling function; </li><li>  the locality of the link; </li></ul></li><li>  Related effects: <br><ul><li>  Dead Code Elimination; </li><li>  Constant propagation; </li><li>  The code can speed up or slow down (you need to measure everything!). </li></ul></li></ul><br><p>  Even knowing all this, you can still find optimizing solutions.  What comes next is completely based on our work experience.  No publications, reports about this you will not find.  Conclusions made by us rather empirically, based on our own observations. </p><br><h1 id="poryadkovaya-ocenka-i-pareto-klassifikaciya-uzkih-mest">  Ordinal evaluation and Pareto-classification of bottlenecks </h1><br><p>  The famous Pareto law tells us that 20% of the code uses 80% of the resources.  The assessment, we believe, is quite realistic.  Raise this proportion to the square and scale down the values ‚Äã‚Äã100 times.  We get the square of the Pareto law: 4.0% of the code uses 64% (about ‚Öî) of resources.  If we raise the proportion to a cube and scale down 10,000 times, we get the Pareto law cube: 0.8% of the code uses approximately 51% (about half) of the resources.  That is, having a code base of 1 million lines, we are forced to devote about half of the resources to the execution of only 5,000 lines.  Pareto's law of the first, second and third order - this is what will help us to classify optimization techniques.  We will conduct the favorite work of the programmer and decompose our technology into groups: </p><br><ol><li>  In the first group we will place the optimization techniques working according to the Pareto law of the first order.  These are techniques about the system architecture, network environment, ordinal complexity of the algorithms used (for the time being in terms of ‚Äúbig O‚Äù). </li><li>  The second group will go technology, for which the Pareto II order law is applicable.  They involve work on optimizing the execution time of the algorithms.  Is it possible, for example, to prevent the repeated execution of the algorithm that can be executed only once? </li><li>  The third group is Pareto's law of the third order, and here we are confronted with truly complex things that require real ingenuity.  These are the so-called micro-optimization techniques. </li></ol><br><p>  I must say that, as a rule, the initial performance of your system will require the use of techniques of the first group.  If the level of system optimization is below a certain threshold value, then it is too early for you to think about the techniques of the second and third groups. </p><br><h1 id="rabotaya-nad-ravendb">  Working on RavenDB </h1><br><p>  Now I will show you the problems that we dealt with when working on the RavenDB product a couple of versions ago.  RavenDB is a fully managed document-oriented database.  In the days of RavenDB 2.0, we used Microsoft ESE storage (also known as Esent).  The product is good.  But a problem soon emerged: each time a data was saved, the interop call was made, which, as we know, is quite resource-intensive.  Other performance problems arose, in part, due to the use of cryptographic hashing, due to JSON processing.  We also performed insufficient batching and lost productivity using Write Locks when writing data.  So, we decided to optimize the code base of RavenDB 2.0.  We created our own repository, which was designed to solve the problem with interopes.  And well, in return we got two new holes!  In the same way, we discovered new problems after we optimized JSON processing and began to perform more batching.  Removing existing bottlenecks, we received in exchange more and more new.  But by that time, the actions we took gave a tenfold increase in performance on the critical branches of the code, which in itself is quite significant. </p><br><p>  On the way from version 3.0 to version 4.0 of RavenDB, we decided to use a radically different approach - ‚ÄúPerformance first‚Äù.  We put customer requirements on the back burner, and put performance at the forefront.  We began to work with local memory allocation, created our own string type.  To avoid copying data and achieve full control over memory, we created our own binary serialization format.  We developed our own compression algorithms, sharpened specifically for the types of stored data.  We also made efforts to ensure full control of access to IO and memory (for example, it was necessary to be able to directly tell the kernel which pages to unload and load).  It was extremely important to try to clear the code from virtual calls.  It is impossible to judge the effectiveness of such methods beforehand, they are only evaluated in practice.  And each successful optimization is not just a quantity, it is a new multiplier in the formula.  Increased productivity is always its multiplication.  Of all the botlneks that were present in RavenDB 3.0, I would like to consider three with you: </p><br><ul><li>  JSON handling problem; </li><li>  memory management problems; </li><li>  a large number of virtual calls. </li></ul><br><h1 id="rabota-s-pamyatyu">  Work with memory </h1><br><p>  One way or another, we deal with requests all the time.  The request begins and ends in some way.  Memory allocation is also a request.  First, the memory must be provided, and after use it must be returned.  As our practice has shown, approximately 90% of cases memory allocation occurs for strings (such is the specificity of databases, because they mostly store strings).  Then, in descending order, there are collections, Gen0 generation objects that fall under garbage collection (the so-called ‚Äúfire &amp; forget‚Äù objects), asynchronous operations, Context objects of lambda functions.  If you are developing high-performance software, you will have to give up using the garbage collector.  This means that you will also release the memory manually.  We created such lines that we would manage not the environment, but we personally (literally referring to the disk).  For brevity, we will call such strings "unmanaged." </p><br><p>  Now we will deal with questions like: who owns this or that section of memory, how quickly can memory be allocated, is it possible to ensure high speed memory allocation, if it is a short line?  If during the work we need (within the framework of the same thread) to perform another memory request, then, since the free segment will be located next to the ones already used, it will most likely be already loaded into the cache.  But the presence of a botnek in your code may not give you the opportunity to conduct such jewelry work.  In order for you to successfully engage in this kind of optimization, your code must be tailored sufficiently sparingly.  However, this approach refers to the methods of the Pareto I order law, as it permeates the entire system architecture.  Deciding on such transformations is usually not easy.  You must be prepared to practically start from scratch.  Your versions will not have binary software compatibility, which is problematic. </p><br><h1 id="anatomiya-bytestring">  Anatomy of a ByteString </h1><br><p>  What is a <code>ByteString</code> ?  Its implementation looks like this: </p><br><img src="https://habrastorage.org/webt/i9/yw/nq/i9ywnqk6zfdzhe87dgvop75mqtk.png"><br><p>  Several flags, the length of a <code>ByteString</code> , a pointer to the memory segment in which it is stored, as well as the size of this segment (in case we decide to release it with the possibility of someone else reusing it).  Not much different from string type pluses, right?  This implementation of <code>ByteString</code> reminds us of something else - the Span of the CoreCLR library. </p><br><img src="https://habrastorage.org/webt/st/os/cs/stoscsy6eyfojgpjs7pfcftezn8.png"><br><p>  Span was first introduced in early 2016, and now entered the mainstream.  Inside itself, Span stores a reference to a type.  And what is the link?  This is nothing but a pointer, carefully hidden from us for its beautiful realization.  The second field Span stores the length.  Span itself will not do for us, because it does not support work with unmanaged memory.  So, <code>ByteString</code> is a Span-like structure, which is completely legitimate for C #.  It perfectly solves the problem of memory management.  However, <code>ByteString</code> has one big problem - it takes as many as 36 bytes.  The size of the data register allows us to store only 8 bytes, at best - 32 bytes.  Passing such a structure as a parameter or return value will be extremely problematic.  And all the performance that we won through the concept of <code>ByteString</code> , will be lost during its transfer.  But this kind of problem, as a rule, finds a solution in the community of any language.  Solve it the same way as any other problem in computer science: by adding another level of indirection. </p><br><img src="https://habrastorage.org/webt/07/4s/id/074sid1e9626zttnzpn5yi5kvam.png"><br><p>  Create a pointer to our <code>ByteString</code> . </p><br><img src="https://habrastorage.org/webt/kk/0q/vl/kk0qvlxirx8ivotozxioiob_cn0.png"><br><p>  And now our <code>ByteString</code> is 8 bytes.  Cool after all!  But I want to ask the question: and yet, how much does it cost us to actually transfer ByteString as a parameter?  The best way to find out is to conduct an experiment.  Experimenting performance specialist forced constantly. </p><br><img src="https://habrastorage.org/webt/o2/qk/9o/o2qk9ozm3mtvmkjjdqwhlochgx0.png"><br><p>  Let <code>ByteString</code> <code>"a"</code> specified inside the <code>UsingByteString</code> method.  We will not perform any operations, the method should simply return <code>""</code> .  The compiler needs to specify that the method is ‚Äúcold‚Äù.  The ‚Äúhot‚Äù method will always work faster - the purity of the experiment will be broken, the performance indicator will be distorted for the better.  I will remind that <code>ByteString</code> , according to our implementation, should occupy 8 bytes.  Below, we implement the <code>UsingLong</code> method, which performs the same actions (returning a value) on an 8-byte <code>long</code> variable.  If <code>ByteString</code> a <code>ByteString</code> through a pointer is no more complicated than controlling a variable of type long, then <code>UsingByteString</code> and <code>UsingLong</code> work in equal time.  As the implementation of <code>ByteString</code> we take the following: </p><br><img src="https://habrastorage.org/webt/tg/ma/s7/tgmas7vyq7mbsizkguxpdbl6xn4.png"><br><p>  The implementation is simplified to a minimum, but it is quite suitable for our experiment.  Creating an instance of the structure, we assign the value to the pointer.  So, first we test on the variable <code>long</code> .  The starting point of our program: </p><br><img src="https://habrastorage.org/webt/ga/xy/y1/gaxyy1insikrtousu242crgldz4.png"><br><p>  The value of the long variable is obtained from the static global variable.  Then run our method, and save the returned value to the variable <code>"a"</code> .  And, to prevent the compiler from intervening and optimizing anything here (and he does it only when all the actions of the code are strictly deterministic, in particular, there are no side effects), add an operation with a side effect - execute output <code>"a"</code> in console.  Run the program and get the following result: </p><br><img src="https://habrastorage.org/webt/_o/bj/u2/_obju25pbaajcnv-yhbeyll3xsq.png"><br><p>  So, the first mov operation moves the first parameter of the method to the register <code>RCX</code> .  Next comes the call operation ‚Äî a function call, after which the value is copied from the <code>RAX</code> register to the <code>RCX</code> register ‚Äî the value written by the function is returned to the variable <code>"a"</code> .  The next call is a call to the <code>WriteLine</code> method.  Now repeat the same thing, but with a <code>ByteString</code> .  Code to run: </p><br><img src="https://habrastorage.org/webt/ll/is/xq/llisxqbnnccli9pk1kqyz6ency4.png"><br><p>  We declare a static global pointer variable.  The <code>Main</code> code is similar: we initialize the new <code>ByteString</code> , call the <code>UsingByteString</code> method, <code>UsingByteString</code> returned value to the variable <code>"a"</code> and output its value to the console;  in order to avoid any problems with <code>Console.WriteLine</code> , we add here an explicit cast to the <code>long</code> type.  The results of the program: </p><br><img src="https://habrastorage.org/webt/fi/ti/gh/fitighch7lulf85xibfgrojayyg.png"><br><p>  In the same way, saving to the <code>RCX</code> register is performed, the method is <code>RAX</code> in the same way, the resulting value is copied from the <code>RAX</code> register to the <code>RCX</code> register in the same way, and the call to <code>WriteLine</code> occurs in the same way.  The results are the same! </p><br><img src="https://habrastorage.org/webt/fe/vd/tn/fevdtnwrs5lfidqj9gpqc8fam00.png"><br><p>  It turns out that, despite the obvious semantic difference, at the level of the JIT compiler, these two pieces of code are worked out identically.  Perhaps you guess something.  But be patient, the second part of the story is ahead. </p><br><h1 id="likvidaciya-vetvleniy">  Branch elimination </h1><br><p>  On the sly, the JIT compiler optimized something from us.  We illustrate with another example: </p><br><img src="https://habrastorage.org/webt/gg/me/bi/ggmebiexmi61lm6ukkowci3nof4.png"><br><p>  Suppose we have an empty <code>IMarker</code> interface and its two implementations, <code>MarkerI</code> and <code>MarkerJ</code> .  However, importantly, we declare <code>MarkerI</code> and <code>MarkerJ</code> structures, not classes, as usual.  Below we define the <code>Method</code> method, for which: - a type parameter belonging to the <code>IMarker</code> interface;  <code>i</code> and <code>j</code> are input parameters of type <code>int</code> .  Inside the method, we perform a simple operation: if <code>T</code> is equal to <code>MarkerI</code> , then we will return the value of <code>i</code> ;  if <code>T</code> is equal to <code>MarkerJ</code> - we return <code>j</code> .  Run the method with the <code>MarkerI</code> parameter. </p><br><img src="https://habrastorage.org/webt/2o/vr/et/2ovretd0g0i-j7aw5mtqitudlts.png"><br><p>  How exactly will the JIT compiler handle such a call?  He will see the Method method and the <code>MarkerI</code> parameter that is passed to him.  He then performs a check on the identity of <code>MarkerI</code> to the <code>MarkerI</code> interface, and, considering that the condition is fulfilled, will proceed to the execution of the method body.  And further, analyzing the condition of the if statement, the compiler will perform a rather interesting operation: it will check whether <code>MarkerI</code> type is equal to <code>MarkerI</code> type and, of course, will be <code>true</code> .  However, since <code>MarkerI</code> is a structure, not a class, the compiler considers that <code>true</code> in this case is constant and decides to remove the if statement from the code (along with what follows after it), leaving only the body commands if.  The code will look like this: </p><br><img src="https://habrastorage.org/webt/ky/cc/2_/kycc2_n1vgpc1zoclyfs0aexpyw.png"><br><p>  Now run the method with the <code>MarkerJ</code> parameter. </p><br><img src="https://habrastorage.org/webt/a9/s6/gf/a9s6gfyuy4fbhnb7am1bkt8iyac.png"><br><p>  This time, the analysis of the condition of the if statement will give a value of <code>false</code> (the transferred type <code>MarkerJ</code> not equal to the type <code>MarkerI</code> ).  In the same way, the compiler will consider that in this case <code>false</code> is a constant, which means you can remove the if construct as a whole along with its contents.  Thus, we observed the generation of code for two different branches by the JIT compiler. </p><br><h1 id="zachem-nam-nuzhno-obobschyonnoe-metaprogrammirovanie">  Why do we need generic metaprogramming? </h1><br><p>  For C ++ programmers, I‚Äôll say: for the same reasons as you.  For everyone else, it allows you to: </p><br><ul><li>  avoid frequent virtual calls; </li><li>  adapt the algorithms taking into account how we plan to use them (for example, how often); </li><li>  use the capabilities of the JIT compiler (definition of the values ‚Äã‚Äãof constants and simple expressions) - get improved, ‚Äúcompacted‚Äù code; </li><li>  avoid invariant conditions (we cannot predict a branch of execution, but we can minimize the number of branches). </li></ul><br><p>  For a more visual presentation, I will give you an example of applying generalized metaprogramming.  Let's talk about object pools. </p><br><h1 id="obektnye-puly">  Object Pools </h1><br><img src="https://habrastorage.org/webt/fg/fm/sz/fgfmszm4kilpy9zc7si_syftqdg.png"><br><p>  In essence, we have some type and we have a set of objects of this type - we get a pool.  But the object after all has a life cycle: once it is created, and sooner or later we will need to remove it from memory (having contacted uncontrollable memory, we are forced to do removal literally with our hands).  There is another nuance.  Perhaps we want to make the object specially sharpened for a particular processor.  If the last time some object was received by us from processor No. 1, then we would like further work with this object to occur as soon as possible and on the same processor No. 1.  A typical implementation of the allocator today looks like this: </p><br><img src="https://habrastorage.org/webt/nx/ws/ny/nxwsnywyw5wl3snbuzxy3tgq7um.png"><br><p>  We have an object pool with NonThreadAwareBehavior.  At the input to the constructor, we pass the function factory, which is able to create the object we need.  The trick is that we will adjust the data types. </p><br><img src="https://habrastorage.org/webt/pt/ri/na/ptrinafa075tqxg3yks61oqtu5a.png"><br><p>  Compare two implementations: </p><br><img src="https://habrastorage.org/webt/kf/xz/mq/kfxzmqy2rzi-xxqvs9m6c9ftqtm.png"><br><p>  The first uses the classic approach just introduced.  In the second, an explicit allocator is used, represented by an ordinary structure.  To create a new pool object, in this case, we just need to use the New operator.  Now we will test and compare these two implementations. </p><br><img src="https://habrastorage.org/webt/7-/oe/on/7-oeon_zgfble5viwbwd8ea4dqg.png"><br><p>  We can see that the implementation with the factory involved 84 assembler commands, and the implementation with New only 57. That is, the variant using New turns out to be more efficient by 1.7 times.  How important is this distinction to us?  Let's try something more interesting - let's implement an associative array (Dictionary). </p><br><img src="https://habrastorage.org/webt/v4/up/no/v4upnorcdqgpcs7lfamhgpbzavq.png"><br><p>  In addition to the usual two key and value arguments, let's declare the third one - a comparator.  A classic implementation that matches our wishes will look something like this: </p><br><img src="https://habrastorage.org/webt/zp/n8/bv/zpn8bvtp_rr656r26wdke2usyts.png"><br><p>  We specify the <code>IEqualityComparer</code> interface as a comparator.  The implementation of <code>NumericEqualityComparer</code> quite simple: </p><br><img src="https://habrastorage.org/webt/ax/l6/mq/axl6mq1r9hzi-kejltgmo4umsf8.png"><br><p>  In this case, the <code>NumericEqualityComparer</code> is a structure that implements the <code>IEqualityComparer</code> interface for the <code>long</code> type.  The <code>Equals</code> method simply returns the result of checking for the equality of the two <code>long</code> values ‚Äã‚Äãpassed to it.  Pay attention to a special instruction for the implementation of the method - <code>AgressiveInlining</code> , upon seeing which, the JIT compiler will, if possible, execute the method as embedded.  We will test three different implementations: </p><br><img src="https://habrastorage.org/webt/wo/cm/hk/wocmhkubqeyi9sjfjzfrv4px3wi.png"><br><p>  In the first case, we implement typical for .NET using an associative array using the interface.  In the second case, bypassing the use of the interface, we try to pass our <code>NumericEqualityComparer</code> directly as a type.  The third option we need to complete the picture.  Here we do the same thing using the CoreCLR associative array.  Test results give: </p><br><img src="https://habrastorage.org/webt/ln/2x/i5/ln2xi53ckry4p_-uupcg0z5dkoo.png"><br><img src="https://habrastorage.org/webt/pu/qx/pr/puqxprdqkcrdxnlrvhhodwa9f1w.png"><br><p>  Obviously, <code>FastDictionary</code> algorithms are faster.  But besides, we see that direct use of the <code>NumericEqualityComparer</code> type is <code>NumericEqualityComparer</code> efficient than using the interface more than twice.  I have presented you with a few examples.  Is it objective to use them as benchmarks?  The answer is no.  We need to conduct a real test. </p><br><img src="https://habrastorage.org/webt/o-/u8/ki/o-u8ki9oxfxaei4ho1m7qbub7rq.png"><br><p>  From here we see that in fact the comparators were not built in: they turned out to be too large.  And yet, the use of <code>FastDictionary</code> already increases our productivity by 3.25 times.  Not any use of <code>FastDictionary</code> will give us a similar result, so it is important to understand what caused it in this particular case.  The optimizations performed by JIT compilers are far from as simple as they seem. </p><br><h1 id="konstanty">  Constants </h1><br><p>  One more example: </p><br><img src="https://habrastorage.org/webt/mk/gq/hc/mkgqhcwn8zj0_46xmqoubln3jbc.png"><br><p>  The doDispose flag is assigned a calculated value.    JIT-   ,      (,      , , ,      ). ,   ,         .   .   ,    ,     ,         .   : </p><br><img src="https://habrastorage.org/webt/2_/br/lo/2_brloolamexc7ti4io97xgyiqy.png"><br><p> <em>(  :  <code>TEvictionStrategy</code>   <code>TEviction</code> )</em> </p><br><p>   <code>Clear</code> ,         .       ,   ?    :             (, 15   ).      . </p><br><img src="https://habrastorage.org/webt/tn/1u/vd/tn1uvdohsxtpws3bznmumzyptzo.png"><br><p>  <code>IEviction</code> ‚Äî  .    <code>AlwaysEvictStrategy</code>  <code>NeverEvictStrategy</code> ,     : ¬´ ¬ª  ¬´ ¬ª. ,  <code>AlwaysEvictStrategy</code> ,  <code>NeverEvictStrategy</code>     <code>CanEvict</code> ,    <code>true</code>  <code>false</code> .  <code>Clear</code>   : </p><br><img src="https://habrastorage.org/webt/fk/xg/nj/fkxgnjf3dq-t01fv8tro50vkmjw.png"><br><p>  bucket   .    ,     <code>CanEvict</code> ,  ,      .     .      (  ),      .    <code>AlwaysEvictStrategy</code> ,   : </p><br><img src="https://habrastorage.org/webt/n7/dv/xq/n7dvxqxjos4p5gq8ivyud_aaw9e.png"><br><p>    ,       ,           <code>AlwaysEvictStrategy</code> . </p><br><img src="https://habrastorage.org/webt/ac/il/ta/aciltaxnj4uhx-8xmodj4jvxwog.png"><br><p>  CanEvict   true     .  if    : </p><br><img src="https://habrastorage.org/webt/de/ic/jh/deicjhl1s8tod5dlx_mr2h3ng-c.png"><br><p>  ,    <code>NeverEvictStrategy</code> ,   : </p><br><img src="https://habrastorage.org/webt/q7/ui/kq/q7uikqh75deykywnxxuvmezsqk8.png"><br><p>    if   <code>false</code> ,  <code>CanEvict</code> . </p><br><img src="https://habrastorage.org/webt/fk/x2/_k/fkx2_k5fjnrqedgpwx9wqw8j4x8.png"><br><p>  ,       ,  , if-   : </p><br><img src="https://habrastorage.org/webt/ci/lr/vj/cilrvj_aouv_8ckcr6kniqg8shw.png"><br><p>        <code>inst</code> ?        : </p><br><img src="https://habrastorage.org/webt/pd/aq/n7/pdaqn7eo5o0zd1y5xpz6nt55ov0.png"><br><p>      ? </p><br><img src="https://habrastorage.org/webt/k6/cm/v7/k6cmv7hp_lpaizxn4rf1ldjc79c.png"><br><p>    <code>Clear</code>  .      : </p><br><img src="https://habrastorage.org/webt/z8/oj/f4/z8ojf4zdtpcdpy0ktp4snaw-pti.png"><br><p>     for,        . </p><br><h1 id="zero-cost-faade"> Zero Cost Fa√ßade </h1><br><p>        . ,     <code>ILimitedOutputDirective</code> ,   <code>NotLimited</code>  <code>LimitedOutput</code> .    <code>ITableTypeDirective</code>     <code>ByU32</code>  <code>ByU16</code> . </p><br><img src="https://habrastorage.org/webt/e_/8h/i4/e_8hi4mblg2tlozpkqna4foq3ri.png"><br><p>     : </p><br><img src="https://habrastorage.org/webt/yh/ep/4k/yhep4kdxkarse7dxkbpnd2t3q2w.png"><br><p>  : </p><br><img src="https://habrastorage.org/webt/e0/cu/6h/e0cu6hdkq5gkpjplr5mdklxv4f0.png"><br><p>        <code>ByU16</code> ,     if.    <code>ByU32</code> ‚Äî    if.        <code>ByU32</code> ,  <code>ByU16</code> ,   .       .    ,  ¬´Zero Cost Fa√ßade¬ª.   . </p><br><img src="https://habrastorage.org/webt/8p/h_/ss/8ph_sslglpxxclj_h_q8wwtrnjc.png"><br><p>    <code>IUnmanagedWriteBuffer</code>    :  <code>UnmanagedStreamBuffer</code> ( , ,  ,  ,       )   <code>UnmanagedWriteBuffer</code> (    ).  ,          .     . </p><br><img src="https://habrastorage.org/webt/qh/iq/ts/qhiqtshpewkqhpnanee2wbigl_m.png"><br><p>  , ,   <code>BlittableWriter</code> ‚Äî       ,      <code>TWriter</code> .    ,  ,  : </p><br><img src="https://habrastorage.org/webt/wx/4k/qj/wx4kqjh7uniawm0titrkfxwfmi4.png"><br><p>    <code>WriteNumber</code> ,    .      <code>AgressiveInlining</code> .  ,    ,          ‚Äî      . JIT- ,     ,   .   ?      ,  ,     . </p><br><img src="https://habrastorage.org/webt/n5/sy/5k/n5sy5kztg-i1s1hxqlvlgzd304c.png"><br><p>      ,     ,     :        . </p><br><h1 id="stoit-li-vlozhitsya-vo-vsyo-eto">      ? </h1><br><p>  6      JSON-,       - .             500  ( 8 ).           ,        3 .        2 ,          2- .  ,       ,         6,6 .   ,          ,  , , Raspberry Pi.       .     ,   ,        1000 .     ,        ‚Äî     . </p><br><h1 id="podvodya-itog">  Summarizing </h1><br><p>    ? -,   ,     .   ,     . </p><br><p>  ,   : </p><br><ul><li>      ; </li><li>   : <br><ul><li>     ; </li><li>      ; </li><li> ! </li><li> (   Rust,  ¬´  ¬ª ‚Äî  ,  ); </li><li> (  C#    <a href="http://github.com/dotnet/csharplang/issues/164">shapes and extensions</a> ); </li></ul></li><li>     (   ). </li></ul><br><p>  C#-    .  ,    -,   ¬´shapes &amp; extensions¬ª.   ,     ,          C#. </p><br><ul><li> C     : <br><ul><li>      ; </li><li>        : <br><ul><li>        ; </li><li>   ; </li><li>          ; </li></ul></li><li>          . </li></ul></li></ul><br><p>       .      ,        .  ,  ,     ,      (      Corvalius). </p><br><h1 id="zaklyuchitelnaya-mysl">   </h1><br><p>         :     ,    ,    .               .       6      64 ,     17%  .        ,   ,      ‚Äî     <em> </em> .      ?      I/O,   ,       ,    .  !  ,            . </p><br><h1 id="chto-dalshe">  What's next? </h1><br><p>     ,        ! </p><br><ul><li>  RavenDB 4.0: <a href="https://github.com/ravendb/ravendb/search%3Fo%3Ddesc%26amp%3Bq%3Dauthor%253Aredknightlois%26amp%3Bs%3Dauthor-date%26amp%3Btype%3DCommits">   , Federico Lois</a> ; </li><li> <a href="https://www.youtube.com/watch%3Fv%3Dd1DpVR0tw0U">Local (arena) Memory Allocators ‚Äî John Lakos [ACCU 2017]</a> ; </li><li> <a href="https://www.youtube.com/watch%3Fv%3DNH1Tta7purM">Carl Cook ¬´When a Microsecond Is an Eternity: High Performance Trading Systems in C++¬ª</a> ; </li><li> <a href="https://www.youtube.com/watch%3Fv%3DpEvm5NNc6ko">An Overview of Program Optimization Techniques ‚Äî Mathias Gaunard [ACCU 2017]</a> ; </li><li> <a href="https://www.youtube.com/watch%3Fv%3D9Rb85cOXTKU">MIT 6.172 Performance Engineering of Software Systems, Fall 2010 ‚Äî BTree Write Cliff</a> ; </li><li> <a href="https://flashdba.com/2014/11/24/understanding-flash-the-write-cliff/">Understanding Flash: The Write Cliff</a> (SSD); </li><li>  <a href="https://ayende.com/blog/">Oren Eini</a> ‚Äî      (Federico Lois    ); </li><li> <a href="https://github.com/dotnet/coreclr/issues%3Fq%3Dlabel%253Atenet-performance%2520%2520label%253Aoptimization%2520"> CoreCLR     </a> ; </li><li> <a href="https://github.com/dotnet/benchmarkdotnet">BenchmarkDotNet</a> . </li></ul><br><blockquote>  Minute advertising.  As you probably know, we do conferences.  The nearest .NET conference - <a href="https://dotnext-piter.ru/">DotNext 2018 Piter</a> .  It will be held April 22-23, 2018 in St. Petersburg.  What reports are there - you can see in <a href="https://www.youtube.com/watch%3Fv%3DMpFEkVPbgiU%26amp%3Blist%3DPLtWrKx3nUGBeYn-pSCjEgBPL90SvpylZL">our archive on YouTube</a> .  At the conference, it will be possible to chat live with the speakers and the best experts on .NET in special discussion zones after each report.  In short, come in, we are waiting for you. </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/352362/">https://habr.com/ru/post/352362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352348/index.html">The first year of my life as an indie developer</a></li>
<li><a href="../352350/index.html">Introducing the cloud: how static traffic distribution methods work</a></li>
<li><a href="../352352/index.html">Not by Dagger</a></li>
<li><a href="../352354/index.html">Fluttering bikes. What to do with state saving in Flutter?</a></li>
<li><a href="../352358/index.html">SecaaS as a type of cloud services and other standards of the GOST project ‚ÄúInformation protection when using cloud technologies‚Äù</a></li>
<li><a href="../352364/index.html">DotNext 2018 Piter program overview</a></li>
<li><a href="../352366/index.html">Smart face control: machine learning algorithms for efficient data caching on SSD</a></li>
<li><a href="../352368/index.html">MEPhI invites to the information security competition</a></li>
<li><a href="../352372/index.html">"Computer, how is my build doing?" And other magic spells</a></li>
<li><a href="../352374/index.html">Multithreading on ships</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>