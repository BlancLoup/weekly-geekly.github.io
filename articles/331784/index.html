<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Million WebSocket and Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all! My name is Sergey Kamardin, I am a programmer for the Mail.Ru Mail team. 


 This is an article about how we developed a high-loaded Web...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Million WebSocket and Go</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/799/40f/990/79940f9904554e249903f8df73166952.jpeg" alt="image"></p><br><p>  Hello to all!  My name is Sergey Kamardin, I am a programmer for the Mail.Ru Mail team. </p><br><p>  This is an article about how we developed a high-loaded WebSocket server on Go. </p><br><p>  If the topic of WebSocket is close to you, but Go is not quite, I hope the article will still seem interesting to you from the point of view of ideas and optimization techniques. </p><a name="habracut"></a><br><h2 id="1-predislovie">  1. Preface </h2><br><p>  To indicate the context of the story, it is worth saying a few words about why we needed such a server. </p><br><p>  Mail.Ru Mail has a lot of systems, the state of which is changing.  Obviously, such a system is the repository of user letters.  You can learn about state changes ‚Äî about events ‚Äî in several ways.  Basically, it is either a periodic polling of the system, or - in the opposite direction - notifications from the system about a change in its state. </p><br><p>  Both methods have their pros and cons, but if we talk about mail, then the sooner the user receives a new letter, the better.  Polling in the mail is about 50 thousand HTTP requests per second, 60% of which return the status 304, which means there is no change in the box. </p><br><p>  Therefore, in order to reduce server load and speed up the delivery of letters to users, it was decided <del>  invent a bicycle </del>  write a publisher-subscriber server (aka bus, message-broker or event-channel), which, on the one hand, receives status messages, and on the other hand, subscribes to such messages. </p><br><p>  It was: </p><br><pre><code class="tex hljs">+-----------+ +-----------+ +-----------+ | | ‚óÑ-------+ | | ‚óÑ-------+ | | | Storage | | API | HTTP | Browser | | | +-------‚ñ∫ | | +-------‚ñ∫ | | +-----------+ +-----------+ +-----------+</code> </pre> <br><p>  It became: </p><br><pre> <code class="tex hljs"> +-------------+ +---------+ WebSocket +-----------+ | Storage | | API * | +-----------‚ñ∫ | Browser | +-------------+ +---------+ (3) +-----------+ + (2) ‚ñ≤ | | (1) ‚ñº + +---------------------------------+ | Bus | +---------------------------------+</code> </pre> <br><p>  The first diagram shows how it was before.  The browser periodically went to the API and asked about changes to the Storage (store letters). </p><br><p>  On the second - a new version of the architecture.  The browser establishes a WebSocket connection to the API over which the Storage event is notified.  The API is a client to the Bus server and sends it the data of its subscribers (this server will not be discussed today; perhaps I will tell about it in the following publications).  At the time of receiving a new letter, Storage sends a notification about this to the Bus (1), Bus to its subscribers (2).  The API determines which connection to send the received notification to, and sends it to the browser to the user (3). </p><br><p>  As you might have guessed, today we‚Äôll talk about the API, or WebSocket server.  Looking ahead, I will say that there will be about 3 million live connections on the server.  This figure will emerge more than once in the subsequent story about optimizations. </p><br><h2 id="2-idiomatic-way">  2. Idiomatic way </h2><br><p>  Let's take a look at how we would implement some parts of our server, using Go capabilities, without using system calls in our own code. </p><br><p>  Before we consider working with <code>net/http</code> , let's talk about sending and receiving data.  The data that is <em>above</em> the WebSocket protocol (for example, json envelopes), hereinafter I will begin to call <em>packages</em> .  Let's start the implementation of the <code>Channel</code> structure, which will contain the logic for receiving and sending packets through a WebSocket connection. </p><br><h3 id="21-channel-struct">  2.1.  Channel struct </h3><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Packet represents application level data. type Packet struct { ... } // Channel wraps user connection. type Channel struct { conn net.Conn // WebSocket connection. send chan Packet // Outgoing packets queue. } func NewChannel(conn net.Conn) *Channel { c := &amp;Channel{ conn: conn, send: make(chan Packet, N), } go c.reader() go c.writer() return c }</span></span></code> </pre> <br><p>  I want to draw your attention to the launch of two gorutin reading and writing.  Each gorutina needs its own stack, which, <a href="">depending on the operating system</a> and the Go version, can have an initial size of 2 to 8 KB.  If we take into account the figure mentioned earlier (3 million live connections), then we will need <strong>24 GB of memory</strong> for all connections (with a stack of 4 KB).  And this is without taking into account the memory allocated to the <code>Channel</code> structure, the queue of outgoing <code>ch.send</code> packets <code>ch.send</code> and other internal fields. </p><br><h3 id="22-gorutiny-io">  2.2.  Gorutiny I / O </h3><br><p>  Let's look at the implementation of the "reader" from the connection: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Channel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// We make buffered read to reduce read syscalls. buf := bufio.NewReader(c.conn) for { pkt, _ := readPacket(buf) c.handle(pkt) } }</span></span></code> </pre> <br><p>  Simple enough, right?  We use a buffer to reduce the number of syscalls for reading and read as many <code>buf</code> as it allows us.  In an infinite loop, we expect new data to come into the connection and read the next packet.  I‚Äôll ask you to remember the words, <em>we</em> ‚Äôll <em>expect new data to arrive</em> : we'll return to them later. </p><br><p>  Parsing and processing incoming packets will be left aside, since it does not matter for those optimizations that will be discussed.  But <code>buf</code> is worth paying attention to now: by default it is 4 KB, which means it is another <strong>12 GB of</strong> memory.  A similar situation with the "writer": </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Channel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// We make buffered write to reduce write syscalls. buf := bufio.NewWriter(c.conn) for pkt := range c.send { _ := writePacket(buf, pkt) buf.Flush() } }</span></span></code> </pre> <br><p>  We iterate through the outgoing <code>c.send</code> packet <code>c.send</code> and write them to the buffer.  This, as an attentive reader could already guess, is another 4 KB and <strong>12 GB of</strong> memory for our 3 million connections. </p><br><h3 id="23-http">  2.3.  HTTP </h3><br><p>  We have a simple implementation of the <code>Channel</code> , now we need to get a WebSocket-connection with which we will work.  Since we are still under the heading <strong>Idiomatic way</strong> , we will do it in the appropriate key. </p><br><blockquote>  If you are not familiar with how WebSocket works, then you should say that the client switches to the WebSocket protocol using a special mechanism in HTTP called Upgrade.  After successful processing of the Upgrade request, the server and client use a TCP connection to exchange binary WebSocket frames. <br><br>  Here the frame structure inside the connection is described. </blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"some/websocket"</span></span> ) http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/v1/ws"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { conn, _ := websocket.Upgrade(r, w) ch := NewChannel(conn) <span class="hljs-comment"><span class="hljs-comment">//... })</span></span></code> </pre> <br><p>  Note that the <code>http.ResponseWriter</code> inside itself contains the <code>bufio.Writer</code> write buffer, and to initialize <code>*http.Request</code> , the <code>bufio.Reader</code> read <code>bufio.Reader</code> also allocated <code>bufio.Reader</code> . </p><br><p>  Regardless of the WebSocket library used, after a successful response to an Upgrade request, the <a href="https://github.com/golang/go/blob/143bdc27932451200f3c8f4b304fe92ee8bba9be/src/net/">server receives</a> I / O buffers along with a TCP connection when calling <code>responseWriter.Hijack()</code> . </p><br><blockquote>  Hint: in some cases, using <code>go:linkname</code> you can return buffers to the <code>net/http</code> pool by calling <code>net/http.putBufio{Reader,Writer}</code> . </blockquote><p>  Thus, we need another <strong>24 GB of</strong> memory for 3 million connections. </p><br><p>  Total already <strong>72 GB of</strong> memory for an application that still does nothing! </p><br><h2 id="3-optimizacii">  3. Optimization </h2><br><p>  It is worth refreshing what we have said in the preface, and remember how the user connection behaves.  After switching to WebSocket, the client sends a packet with events of interest to it ‚Äî that is, subscribes to events.  After that (apart from technical messages like <code>ping/pong</code> ), the client can send nothing more for the entire lifetime of the connection. </p><br><blockquote>  The lifetime of a connection can be from several seconds to several days. </blockquote><p>  It turns out that our <code>Channel.reader()</code> and <code>Channel.writer()</code> most of the time are waiting for data processing to receive or send.  And along with them, data is waiting for I / O buffers, each 4 KB. </p><br><p>  Now it‚Äôs obvious that you can do some things better, right? </p><br><h3 id="31-netpoll">  3.1.  netpoll </h3><br><p>  Remember the implementation of <code>Channel.reader()</code> , which <em>waited for new data</em> to <code>conn.Read()</code> in, blocking on the call to <code>conn.Read()</code> inside <code>bufio.Reader</code> ?  If there is data in the connection, the runtime go ‚Äúwoke up‚Äù our mountain and allowed us to read the next packet.  After that, the gorutin was again blocked while waiting for new data.  Let's see how runtime in go understands that it is necessary to ‚Äúwake up‚Äù Goretin. </p><br><p>  Looking at the <a href=""><code> conn.Read()</code></a> , we will see that the <a href=""><code>  net.netFD.Read()</code></a> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// net/fd_unix.go func (fd *netFD) Read(p []byte) (n int, err error) { //... for { n, err = syscall.Read(fd.sysfd, p) if err != nil { n = 0 if err == syscall.EAGAIN { if err = fd.pd.waitRead(); err == nil { continue } } } //... break } //... }</span></span></code> </pre> <br><blockquote>  Sockets go non-blocking.  EAGAIN says that there is no data in the socket, and in order not to block from reading from an empty socket, the OS returns us control. </blockquote><p>  We see that the <code>read()</code> system call from the file connection descriptor occurs.  In the event that reading returns an <a href="http://man7.org/linux/man-pages/man2/read.2.html"><code> EAGAIN</code></a> , the runtime makes <a href=""><code> pollDesc.waitRead()</code></a> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// net/fd_poll_runtime.go func (pd *pollDesc) waitRead() error { return pd.wait('r') } func (pd *pollDesc) wait(mode int) error { res := runtime_pollWait(pd.runtimeCtx, mode) //... }</span></span></code> </pre> <br><p>  If you <a href="">dig deeper</a> , we <a href="">will see</a> that in Linux <code>netpoll</code> implemented <a href="http://man7.org/linux/man-pages/man7/epoll.7.html"><code> epoll</code></a> .  Why don't we use the same approach for our connections?  We could allocate a buffer for reading and run gorutin only when it is really necessary: ‚Äã‚Äãwhen there is data in the socket for sure. </p><br><blockquote>  At github.com/golang/go, there is an <a href="https://github.com/golang/go/issues/15735">issue</a> on the export of netpoll features. </blockquote><br><h3 id="32-izbavlyaemsya-ot-gorutin">  3.2.  Getting rid of gorutin </h3><br><p>  Suppose we have <a href="https://godoc.org/github.com/mailru/easygo/netpoll">a netpoll implementation</a> for Go.  Now we can not run Channel.reader <code>Channel.reader()</code> with the buffer inside, but ‚Äúsubscribe‚Äù instead to the data availability event in the connection: </p><br><pre> <code class="go hljs">ch := NewChannel(conn) <span class="hljs-comment"><span class="hljs-comment">// Make conn to be observed by netpoll instance. // Note that EventRead is identical to EPOLLIN on Linux. poller.Start(conn, netpoll.EventRead, func() { // We spawn goroutine here to prevent poller wait loop // to become locked during receiving packet from ch. go Receive(ch) }) // Receive reads a packet from conn and handles it somehow. func (ch *Channel) Receive() { buf := bufio.NewReader(ch.conn) pkt := readPacket(buf) c.handle(pkt) }</span></span></code> </pre> <br><p>  With <code>Channel.writer()</code> the situation is simpler - we can run gorutina and allocate a buffer only when we are going to send a package: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch *Channel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p Packet)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.noWriterYet() { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> ch.writer() } ch.send &lt;- p }</code> </pre> <br><p>  After reading the outgoing packets from <code>ch.send</code> (one or more), the writer will complete its work and release the stack and buffer. </p><br><p>  Fine!  We saved <strong>48 GB</strong> ‚Äî we got rid of the stack and I / O buffers inside two constantly ‚Äúworking‚Äù Gorutin. </p><br><h3 id="33-kontrol-resursov">  3.3.  Resource control </h3><br><p>  A large number of connections is not only a large memory consumption.  During the development of the server, we had more than once race conditions and deadlocks, which were often accompanied by the so-called self-DDoS - a situation where application clients uncontrollably tried to connect to the server and even more <del>  broke down </del>  broke it. </p><br><p>  For example, if suddenly for some reason we could not process <code>ping/pong</code> messages, but the idle connection handler continued to disconnect such connections (assuming that the connections were closed incorrectly, so there is no data from them), it turned out that the client instead of to wait for events after connecting, lose connection every N seconds and try to connect again. </p><br><p>  It would be great if a blocked or overloaded server simply stopped accepting new connections, and the balancer before it (for example, nginx) would move on to the next server instance. </p><br><p>  Moreover, regardless of the server load, if suddenly all clients for any of the reasons want to send us a package, the previously saved <strong>48 GB</strong> will be back in business - in fact, we will return to the original state of the gorutina and buffer for each connection. </p><br><h4 id="331-goroutine-pool">  3.3.1 Goroutine pool </h4><br><p>  We can limit the number of simultaneously processed packets using a gorutin pool.  Here is the naive implementation of such a pool: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> gpool <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;Pool{ work: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">), </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sem</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, size)</span></span></span><span class="hljs-function">, } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Pool)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> p.work &lt;- task: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> p.sem &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{}: <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> p.worker(task) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Pool)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-p.sem } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { task() task = &lt;-p.work } }</code> </pre> <br><p>  And now our code with netpoll takes the following form: </p><br><pre> <code class="go hljs">pool := gpool.New(<span class="hljs-number"><span class="hljs-number">128</span></span>) poller.Start(conn, netpoll.EventRead, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// We will block poller wait loop when // all pool workers are busy. pool.Schedule(func() { Receive(ch) }) })</span></span></code> </pre> <br><p>  That is, now we are reading the packet not immediately when data is found in the socket, but at the first opportunity to take a free gorutin in the pool. </p><br><p>  Similarly, we will change the <code>Send()</code> : </p><br><pre> <code class="go hljs">pool := gpool.New(<span class="hljs-number"><span class="hljs-number">128</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch *Channel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p Packet)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.noWriterYet() { pool.Schedule(ch.writer) } ch.send &lt;- p }</code> </pre> <br><p>  Instead of <code>go ch.writer()</code> we want to make an entry in one of the reusable gorutin.  Thus, in the case of a pool of <code>N</code> gorutins, we guarantee that with N requests processed simultaneously and <code>N + 1</code> arriving, we will not allocate <code>N + 1</code> read buffer.  The gorutin pool also allows you to limit <code>Accept()</code> and <code>Upgrade()</code> new connections and avoid most situations with DDoS. </p><br><h3 id="34-zero-copy-upgrade">  3.4.  Zero-copy upgrade </h3><br><p>  Let's go a little bit towards the WebSocket protocol.  As mentioned above, the client switches to the WebSocket protocol using the HTTP Upgrade request.  Here's what it looks like: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /ws HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: mail.ru <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: Upgrade Sec-Websocket-Key: A3xNe7sEB9HixkmBhVrYaA== Sec-Websocket-<span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">13</span></span> Upgrade: websocket HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">101</span></span> Switching Protocols <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: Upgrade Sec-Websocket-Accept: ksu0wXWG+YmkVx+KQR2agP0cQn4= Upgrade: websocket</code> </pre> <br><p>  That is, the HTTP request and its headers in our case are needed only to switch to the WebSocket protocol.  This knowledge, as well as <a href="https://github.com/golang/go/blob/release-branch.go1.8/src/net/">what is stored</a> inside <code>http.Request</code> , suggests that, for optimization purposes, we could refuse unnecessary allocations and copyings when parsing an HTTP request and leave the standard <code>net/http</code> server. </p><br><blockquote>  <code>http.Request</code> contains, for example, a <a href="https://github.com/golang/go/blob/release-branch.go1.8/src/net/"><code>    Header</code></a> , which is unconditionally filled in with all request headers by copying data from the connection to the rows.  Imagine how much extra data you can keep inside this field, for example, if the size of the <code>Cookie</code> large. </blockquote><p>  But what to take in return? </p><br><h4 id="341-realizacii-websocket">  3.4.1.  WebSocket implementations </h4><br><p>  Unfortunately, all the libraries that existed at the time of our server optimization made it possible to do an upgrade only when using a standard <code>net/http</code> server.  Moreover, none (of the two) libraries allowed to apply all the read and write optimizations described above.  In order for these optimizations to work, we need to have a sufficiently low-level API for working with WebSocket.  To reuse buffers, we need the functions to work with the connection to look like this: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Frame, error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(io.Writer, Frame)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p>  Having a library with such an API, we could read the packets from the connection as follows (writing packets would look the same): </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// getReadBuf, putReadBuf are intended to // reuse *bufio.Reader (with sync.Pool for example). func getReadBuf(io.Reader) *bufio.Reader func putReadBuf(*bufio.Reader) // readPacket must be called when data could be read from conn. func readPacket(conn io.Reader) error { buf := getReadBuf() defer putReadBuf(buf) buf.Reset(conn) frame, _ := ReadFrame(buf) parsePacket(frame.Payload) //... }</span></span></code> </pre> <br><p>  In short, it is time to gash your lib. </p><br><h4 id="342-githubcomgobwasws">  3.4.2.  github.com/gobwas/ws </h4><br><p>  Ideologically, the <code>ws</code> library was written with the thought that it should not impose the logic of working with the protocol to the user.  All read and write methods accept the standard <code>io.Reader</code> and <code>io.Writer</code> , which allow or not to use buffering, as well as any other wrappers around I / O. </p><br><p>  In addition to the upgrade-requests from the standard <code>net/http</code> , <code>ws</code> supports <strong>zero-copy upgrade</strong> - processing upgrade-requests and switching to WebSocket without memory allocation and copying.  <code>ws.Upgrade()</code> takes <code>io.ReadWriter</code> ( <code>net.Conn</code> implements this interface) <code>net.Conn</code> is, we could use standard <code>net.Listen()</code> and send the resulting connection from <code>ln.Accept()</code> immediately to <code>ws.Upgrade()</code> .  At the same time, the library allows you to copy any request data for future use in the application (for example, a <code>Cookie</code> to check the session). </p><br><p>  Below is a <a href="">comparison</a> of the upgrade-request processing: standard <code>net/http</code> - <code>net.Listen()</code> against <code>net.Listen()</code> and zero-copy upgrade: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">BenchmarkUpgradeHTTP</span></span> <span class="hljs-number"><span class="hljs-number">5156</span></span> ns/op <span class="hljs-number"><span class="hljs-number">8576</span></span> B/op <span class="hljs-number"><span class="hljs-number">9</span></span> allocs/op BenchmarkUpgradeTCP <span class="hljs-number"><span class="hljs-number">973</span></span> ns/op <span class="hljs-number"><span class="hljs-number">0</span></span> B/op <span class="hljs-number"><span class="hljs-number">0</span></span> allocs/op</code> </pre> <br><p>  Switching to <code>ws</code> and <strong>zero-copy upgrade</strong> allowed us to save another <strong>24 GB</strong> - the ones that were allocated for I / O buffers when processing the request in the <code>net/http</code> handler. </p><br><h3 id="35-vsyo-vmeste">  3.5.  Together </h3><br><p>  Let's structure the optimization that I talked about. </p><br><ul><li>  Gorutina for reading with a buffer inside is expensive. <br>  <strong>Solution:</strong> netpoll (epoll, kqueue);  reuse buffers. </li><li>  Gorutin recording with a buffer inside is expensive. <br>  <strong>Solution:</strong> start gorutina when needed;  reuse buffers. </li><li>  When an avalanche of connections, netpoll will not work. <br>  <strong>Solution:</strong> reuse gorutiny with a limit on their number. </li><li>  <code>net/http</code> not the fastest way to handle Upgrade on WebSocket. <br>  <strong>Solution:</strong> use zero-copy upgrade on a bare TCP connection. </li></ul><br><p>  Something like this might look like the server code: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gobwas/ws"</span></span> ) ln, _ := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Try to accept incoming connection inside free pool worker. // If there no free workers for 1ms, do not accept anything and try later. // This will help us to prevent many self-ddos or out of resource limit cases. err := pool.ScheduleTimeout(time.Millisecond, func() { conn := ln.Accept() _ = ws.Upgrade(conn) // Wrap WebSocket connection with our Channel struct. // This will help us to handle/send our app's packets. ch := NewChannel(conn) // Wait for incoming bytes from connection. poller.Start(conn, netpoll.EventRead, func() { // Do not cross the resource limits. pool.Schedule(func() { // Read and handle incoming packet(s). ch.Recevie() }) }) }) if err != nil { time.Sleep(time.Millisecond) } }</span></span></code> </pre> <br><h2 id="4-zaklyuchenie">  4. Conclusion </h2><br><blockquote>  Premature optimization in programming.  Donald knuth </blockquote><p>  Of course, the optimization above is not relevant in all cases.  For example, if the ratio of free resources (memory, CPU) to the number of live connections is large enough, probably, there is no point in optimization.  However, knowing where and what can be improved, I hope, will be useful. </p><br><p>  Thanks for attention! </p><br><h2 id="5-ssylki">  5. References </h2><br><ul><li>  <a href="https://github.com/mailru/easygo">https://github.com/mailru/easygo</a> </li><li>  <a href="https://github.com/gobwas/ws">https://github.com/gobwas/ws</a> </li><li>  <a href="httphead">https://github.com/gobwas/httphead</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331784/">https://habr.com/ru/post/331784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331772/index.html">Cash registers go online: Russia's tax has opened a new market for application developers</a></li>
<li><a href="../331774/index.html">What is RQL</a></li>
<li><a href="../331776/index.html">SD-WAN "on the fingers": pros, cons, pitfalls</a></li>
<li><a href="../331778/index.html">As we wrote a strategic clicker on the hackathon ReactRiot</a></li>
<li><a href="../331780/index.html">It's time to throw! Migration Experience from Objective-C to Swift</a></li>
<li><a href="../331786/index.html">The problem of continuous protection of web applications. View from the side of researchers and operators</a></li>
<li><a href="../331788/index.html">Petya.A, Petya.C, PetrWrap or PetyaCry? New virus threat for companies in Russia and Ukraine</a></li>
<li><a href="../331790/index.html">Early bury java</a></li>
<li><a href="../331792/index.html">IT & City Android hackathon in Nizhny Novgorod</a></li>
<li><a href="../331794/index.html">"Now he counted you" or Data Science from Scratch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>