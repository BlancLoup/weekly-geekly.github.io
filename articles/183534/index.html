<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic lighting and an unlimited number of arbitrary sources in 2D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the theme of cycling, I want to share how I did the lighting in a pixel-art toy. 
 The peculiarity of this method is that these light sourc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic lighting and an unlimited number of arbitrary sources in 2D</h1><div class="post__text post__text-html js-mediator-article">  Continuing the theme of cycling, I want to share how I did the lighting in a pixel-art toy. <br>  The peculiarity of this method is that these <b>light sources are not limited to either the amount or the form</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/549/c23/af4/549c23af47771f8b71ba8567616145ae.gif"><br><a name="habracut"></a><br>  Conventionally, the algorithm can be divided into two components: the illumination of 2D objects and the shape of the light sources. <br><br><h4>  Lighting </h4><br>  Partly about the lighting written in <a href="http://habrahabr.ru/post/201572/">this</a> post. <br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text">  I was even surprised when I saw this post, because I use the same technique.  Of course, normal mapping has long been known, but as far as I know, in pixel art, it began to be used quite recently, I would even say that this is one of the first posts. </div></div><br>  In order to determine the intensity of illumination of each pixel, it is necessary to know the normal of this pixel and the direction vector to the light source.  Actually here is the division of my post into two parts: where to get the normal pixel (the current object) and how to calculate the direction vector of the light. <br>  As a rule, the normal pixel of the current object is taken from the <a href="http://www.gamedev.ru/terms/NormalMap">normal map</a> . <br>  You can get the map of normals in different ways (one of them is described in the above post), I create it like this: <br>  sprite is drawn: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/d90/7d4/c73/d907d4c73a10661d320c9fa9a37caba1.png"><br><br>  Next, a height map is drawn for it.  In my case, the sprite itself can be interpreted as a height map.  The fact that such a height map and in general about the bump mapping in general can be read <a href="http://www.gamedev.ru/code/articles/%3Fid%3D4202">here</a> . <br>  On the height map it is already possible to build a normal map.  There are several utilities that can do this.  I used the <a href="https://developer.valvesoftware.com/wiki/Normal_Map_Creation_in_The_GIMP">plugin</a> for GIMP (here are the <a href="http://code.google.com/p/gimp-normalmap/">examples</a> , but there seems to be ubuntas in the standard repositories). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43d/ef4/e66/43def4e66842f94a3e4237be2cd49881.png"><br><br>  So, we have both sprites to create the effect of a three-dimensional object.  Consider the shader, which using these two sprites and the direction of the light source determines the pixel intensity, at this stage it is exactly the same as in my <a href="http://habrahabr.ru/post/182346/">previous post</a> . <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="hljs pgsql">// <span class="hljs-type"><span class="hljs-type">varying</span></span> vec4 texCoord; <span class="hljs-type"><span class="hljs-type">void</span></span> main(){ gl_Position = gl_ModelViewProjectionMatrix*gl_Vertex; texCoord = gl_MultiTexCoord0; } // uniform sampler2D colorMap; uniform sampler2D normalMap; <span class="hljs-type"><span class="hljs-type">varying</span></span> vec4 texCoord; uniform vec2 light; uniform vec2 screen; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> dist; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { vec3 normal = texture2D(normalMap, texCoord.st).rgb; normal = <span class="hljs-number"><span class="hljs-number">2.0</span></span>*normal<span class="hljs-number"><span class="hljs-number">-1.0</span></span>; vec3 n = normalize(normal); vec3 l = normalize(vec3((gl_FragCoord.xy-light.xy)/screen, dist)); <span class="hljs-type"><span class="hljs-type">float</span></span> a = dot(n, l); gl_FragColor = a*texture2D(colorMap, texCoord.st); }</code> </pre> </div></div><br><h4>  Sources of light </h4><br>  This technology is vaguely reminiscent of Deferred Shading. <br>  The main idea is to create a separate buffer for lighting, where each pixel stores the value of the light intensity for the corresponding pixel in the frame.  In other words, this is a regular <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2580%25D1%2582%25D0%25B0_%25D0%25BE%25D1%2581%25D0%25B2%25D0%25B5%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">lightmap</a> for a 2D scene. <br>  In order to make a lightmap, you just need to render all the sources of light into it.  The advantages of this approach: <br><ul><li>  The number of light sources is limited only by iron.  For example, 1000 light sources are 1000 sprites.  Rendering 1000 sprites is not difficult even for a mobile GPU, and is there a need for 1000 sources in a 2D scene? </li><li>  light sources can be of different colors and different degrees of transparency - this is a common texture </li><li>  the shape of the light sources can be any </li></ul><br>  Here, for example, lightmap scene with lava: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0f/855/315/e0f8553158ef141e46a5dadd8b284c88.png"><br><br>  This is not a new lighting technique and it has a minus - the lack of a vector of light direction.  However, you can come up with an algorithm that would define this vector. <br>  To begin with, we will determine what the light source is and what properties it has.  I will not give complex formulas and quotes from a textbook on physics - all this is boring and not interesting.  I will try to explain as I would explain to my mother. <br>  So the farther the rays of light come, the weaker their intensity.  This observation can be used to determine the direction vector of the light rays.  That is, if we have two neighboring pixels and in the first of them the light value is 0.5, and in the second 0.25, then we can conclude that the vector of the light beam is directed from the first pixel to the second. <br>  In this case, a simple formula for calculating the luminance vector is: <br><br>  v [cx] [cy] .x = p [cx] [cy] .x - p [cx + 1] [cy] .x <br>  v [cx] [cy] .y = p [cx] [cy] .y - p [cx] [cy + 1] .y <br><br>  where cx, cy - coordinates of the considered pixel <br>  However, the difference between two adjacent pixels may be extremely small, respectively, the length of the vector may also be small and not accurate, so in this case the lighting may seem "flat."  I found two solutions to this problem: multiply the result by a certain factor or take pixels spaced 1 or more pixels apart.  In the second case, we sacrifice lighting detail.  As a result, I combined both of these methods and the final formula looks like this: <br><br>  v [cx] [cy] .x = (p [cx-d / 2] [cy] .x - p [cx + d / 2] [cy] .x) * k <br>  v [cx] [cy] .y = (p [cx] [cy-d / 2] .y - p [cx] [cy + d / 2] .y) * k <br><br>  where k is the gain vector of the direction of light, d is the distance between pixels on the basis of which the direction vector is considered. <br>  These new values ‚Äã‚Äãcan either be written to a separate light normal map or calculated on the fly during the rendering of the resulting frame simply by using a lightmap.  I chose the second option. <br><div class="spoiler">  <b class="spoiler_title">Shader</b> <div class="spoiler_text"><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ varying vec4 texCoord; varying vec4 nmTexCoord; varying vec2 lightMapTexCoord; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    varying vec2 lightMapTexCoordX1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    varying vec2 lightMapTexCoordX2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    varying vec2 lightMapTexCoordY1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    varying vec2 lightMapTexCoordY2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/,  ,     .    uniform vec2 fieldSize; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    const float spriteSize = 16.0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      void main() { gl_Position = gl_ModelViewProjectionMatrix*gl_Vertex; texCoord = gl_MultiTexCoord0; nmTexCoord = gl_MultiTexCoord1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . lightMapTexCoordX1 = vec2(gl_Vertex.x/</span></span>(fieldSize.x-<span class="hljs-number"><span class="hljs-number">1.0</span></span>/spriteSize), gl_Vertex.y/fieldSize.y); lightMapTexCoordX2 = vec2(gl_Vertex.x/(fieldSize.x+<span class="hljs-number"><span class="hljs-number">1.0</span></span>/spriteSize), gl_Vertex.y/fieldSize.y); lightMapTexCoordY1 = vec2(gl_Vertex.x/fieldSize.x, gl_Vertex.y/(fieldSize.y-<span class="hljs-number"><span class="hljs-number">1.0</span></span>/spriteSize)); lightMapTexCoordY2 = vec2(gl_Vertex.x/fieldSize.x, gl_Vertex.y/(fieldSize.y+<span class="hljs-number"><span class="hljs-number">1.0</span></span>/spriteSize)); lightMapTexCoord = vec2(gl_Vertex.x/fieldSize.x, gl_Vertex.y/fieldSize.y); } /<span class="hljs-regexp"><span class="hljs-regexp">/--------------------------------------------------------------------------------------------------------------- /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ varying vec4 texCoord; varying vec4 nmTexCoord; varying vec2 lightMapTexCoord; varying vec2 lightMapTexCoordX1; varying vec2 lightMapTexCoordX2; varying vec2 lightMapTexCoordY1; varying vec2 lightMapTexCoordY2; uniform sampler2D colorMap; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         uniform sampler2D lightMap; uniform float ambientIntensity; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  uniform float lightIntensity; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    const float shadowIntensity = 8.0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     const vec3 av = vec3(0.33333); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     void main() { vec4 lmc = texture2D(lightMap, lightMapTexCoord)*2,0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   .    ,          0.5,   1.0 ().         , ,    .    ,         . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ x  y -      float x = (dot(texture2D(lightMap, lightMapTexCoordX1).rgb, av)- dot(texture2D(lightMap, lightMapTexCoordX2).rgb, av))*shadowIntensity; float y = (dot(texture2D(lightMap, lightMapTexCoordY2).rgb, av)- dot(texture2D(lightMap, lightMapTexCoordY1).rgb, av))*shadowIntensity; float br = dot(lmc.rgb, av); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      -   vec3 l = vec3(x, y, br); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,  z    ,        ,    ,     l = normalize(l)*br; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       vec3 normal = 2.0*texture2D(colorMap, nmTexCoord.st).rgb-1.0; float a = dot(normal, l)*lightIntensity; a = max(a, 0.0); vec4 c = texture2D(colorMap, texCoord.st); c = a*min(c, lmc)+ambientIntensity*c; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         float m = 0.0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        ,    ,          (.    gif  ).    . m = max(m, cr); m = max(m, cg); m = max(m, cb); gl_FragColor = c+max(0.0, m-1.0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . }</span></span></code> </pre></div></div><br>  Video demonstrating the effect: the <a href="http://youtu.be/AjsxiHZa3Og">light source is a sprite of arbitrary shape</a> , <a href="http://youtu.be/CkNusPWYVvY">each lava particle is a light source</a> . </div><p>Source: <a href="https://habr.com/ru/post/183534/">https://habr.com/ru/post/183534/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../183518/index.html">Siklum announces Amazonization of .NET developers in Kharkov!</a></li>
<li><a href="../183520/index.html">Why Hong Kong is an Excellent Option for Snowden</a></li>
<li><a href="../183526/index.html">NSA drama continues: GCHQ overheard politicians talks at the G20 summit and built fake Internet cafes</a></li>
<li><a href="../183530/index.html">Upgrading HP Entry Storage Systems</a></li>
<li><a href="../183532/index.html">Summer School of System Programming (SSS'13)</a></li>
<li><a href="../183536/index.html">Qt Bitcoin Trader - program for trading Bitcoin under Windows, Mac and Linux</a></li>
<li><a href="../183540/index.html">In Switzerland, created a cheetah-sized robot the size of a cat</a></li>
<li><a href="../183542/index.html">Layout: two blocks of the same height</a></li>
<li><a href="../183546/index.html">Downloading music from vk.com</a></li>
<li><a href="../183548/index.html">Search for the most influential objects of the social network subset</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>