<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a fighting game in Unity: the implementation of Hitbox and Hurtbox</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Explanation 
 What is hitbox and hurtbox? Is it not the same thing? 

 The answer may depend on who you ask the question, but in the article we will t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a fighting game in Unity: the implementation of Hitbox and Hurtbox</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/cd2/1bd/495cd21bd92fe213cf16e0ff7a68c99b.png" alt="image"></div><br><h2>  Explanation </h2><br>  What is hitbox and hurtbox?  Is it not the same thing? <br><br>  The answer may depend on who you ask the question, but in the article we will take the view that hitbox and hurtbox are two different concepts with different uses, as is the case in any decent fighting game. <br><br>  <b>A hitbox</b> is an invisible rectangle (or sphere) that determines where the attack hits. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>The hurtbox</b> is also an invisible rectangle (or sphere), but it defines the place where a player or object can hit with the help of Hitbox. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb8/3cd/e14/eb83cde14adae01016f480359c06a465.jpg"></div><br>  <i>In this image from <b>Street Fighter IV, the</b></i> red box is the hitbox and the green is the hurtbox. <br><a name="habracut"></a><br>  It is worth noting that the size and position of hitboxes and hurtboxes depends on the animation frame being played: <br><br><div class="spoiler">  <b class="spoiler_title">Gif of Killer Instinct.</b>  <b class="spoiler_title">Note that hitboxes appear only in frames of impact and move along with the sword.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b5/916/106/4b59161068003d3daf4cf5b117e3ecd0.gif"></div></div></div><br>  In the example from Killer Instinct, we also see another type of rectangles, namely <b>Pushbox</b> (yellow rectangle; Hurtbox - these are empty green rectangles).  Pushbox is an area denoting a space that is physically occupied by a character and does not allow them to overlap each other. <br><br>  In most games of the genre of fighting and beat 'em up, there are two more types of areas that we will not consider for simplicity: <br><br>  <b>Grab or throw box</b> defines the area for which the character can be grabbed or thrown, and the <b>block box</b> determines the area in which the attacked player pressing the back button starts blocking the attack instead of moving backwards. <br><br>  From a design point of view, all these areas are very important.  Hitboxes and Hurtboxes of attacks determine not only the number of frames in which the attack deals damage, but also the blind zones of this attack, as well as player's vulnerabilities. <br><br>  A good explanation of this on the example of <b>Street Fighter</b> is presented in the <a href="https://www.youtube.com/watch%3Fv%3DcL3lI9cLfuE">video</a> . <br><br>  So, having understood the terminology, let's get down to work. <br><br><h2>  What we want </h2><br>  Let's look at each type of area we want to work with, and say what we want from them: <br><br>  <b>Pushbox:</b> we need two pushboxes to touch, but not overlap (that‚Äôs why they are called ‚Äúpushboxes‚Äù - they push another character).  Pushboxes should interact only with other pushboxes. <br><br>  <b>Hurtbox:</b> it can register a punch, but should not perform collisions in the physical sense.  Hurtboxes should only interact with Hitboxes. <br><br>  <b>Hitbox:</b> we need to be able to check its overlay on the Hurtbox in arbitrary frames.  It should only interact with Hurtboxes. <br><br><h2>  Using standard Unity components </h2><br>  First of all, we can try to bind different types of areas to standard Unity components.  An obvious choice is any <b>Collider</b> . <br><br>  Pushbox can be directly implemented as a Collider plus <b>Rigidbody</b> .  It will behave exactly as we need - to react to collisions with objects and not overlap with other Pushboxes. <br><br>  The only thing we need to worry about (except for the correct setting of the Rigidbody) is that the implementation of the property " <b>can have collisions only with other Pushboxes</b> ".  If you are familiar with the Unity physics system, you already know that the solution is to use the <a href="https://docs.unity3d.com/Manual/LayerBasedCollision.html">layers and the layer collision matrix</a> .  For clarity, we can create a layer called Pushbox, assign it to our object and configure the collision matrix so that <b>Pushbox performs collisions with Pushbox only</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c5/280/4e4/3c52804e43aaa0d3cedcadc02ac112d7.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/48b/359/b5c48b3593e6cecf4a6eadf71763b217.png"></div><br>  For Hurtboxes, we can take a Collider using <b>isTrigger</b> .  So we guarantee that he will not perform collisions in the physical sense and will only register other colliders that fall into his area.  To register the impact itself, we need to add a script to the same object that implements the <b>OnTriggerEnter</b> event, possibly checking the incoming collider tag to make sure that the collider that caused the event is necessary for us, and then perform the damage and health calculations necessary for the game.  You are probably familiar with this approach. <br><br>  We also need to create the Hurtbox and Hitbox layers, and we will use the Layer Collision Matrix again so that the Hurtbox will only collide with the Hitbox and vice versa. <br><br><ul><li>  Notice that we don't need a Rigidbody, but only because I believe that every trigger we add will be a child of the Pushbox object, which already has a Rigidbody.  This is important because Colliders without a Rigidbody inside themselves or some of their parent objects will be defined by the Unity engine as <b>Static</b> and <b>moving them will not lead to any actions</b> . </li><li>  In addition, we will probably need to distinguish the Hitbox player from the Hitbox of one of the enemies.  The same applies to Hurtbox-s.  Thanks to this, the player‚Äôs Hitbox will only be able to hit the Hurtbox of enemies, and the enemies' Hitboxes will only be able to beat the player‚Äôs Hurtbox.  If you want to allow damage to allies, but you should be careful here so that the player cannot hit his own Hurtbox. </li></ul><br>  Hitboxes are the hardest to implement.  To avoid physical collisions, we can use Collider with isTrigger, in fact, we do not have colliders that are "included" in Hitbox.  This problem can be solved in another way: Hitbox "enters" ( <b>or checks the overlay with</b> ) Hurtbox.  Be that as it may, we need a Collider, otherwise <b>Unity will never call OnTriggerEnter</b> in our Hurtbox. <br><br>  To damage the Hurtbox, we need to add the script to the same object so that our Hurtbox can use <b>GetComponent &lt;T&gt;</b> and get it to find out how much damage needs to be done.  We can do this in another way: called for OnTriggerEnter for both Colliders.  We also need to find a way to make our Hitbox active only when we want, and not in every frame and not when the character does not attack.  To do this, we can simply disable the script, since, according to the <a href="https://docs.unity3d.com/ScriptReference/Collider.OnTriggerEnter.html">documentation,</a> <i>Trigger events are sent by disabled MonoBehaviours to allow Behaviours to be enabled in response to collisions</i> . <br><br>  We can enable and disable the collider or add a boolean value to the script, telling whether it should hit or not. <br><br><h2>  Problems </h2><br><ul><li>  <b>Hierarchy:</b> we need to have a script in each object with a Collider to be able to respond to OnTriggerEnter.  If you prefer to keep all the scripts in one place for the sake of order, then you will need to create a script just to delegate the call to all other objects. </li><li>  <b>Excessiveness:</b> with this approach, our Hitboxes have a huge functionality that we will not need. </li><li>  <b>Events:</b> our functionality is based on OnTriggerEnter.  Using <a href="https://docs.unity3d.com/Manual/EventFunctions.html">Unity events</a> may not be a problem.  but there are <a href="https://blogs.unity3d.com/es/2015/12/23/1k-update-calls/">reasons</a> , at least in order to reflect on their necessity.  To know more, it is also worth exploring <a href="https://unity3d.com/es/learn/tutorials/topics/performance-optimization/optimizing-scripts-unity-games">this</a> (in the section <i>‚ÄúAvoiding expensive calls to the Unity API‚Äù</i> ). </li><li>  <b>Visual noise:</b> if for different attacks you want to use different Hitboxes, then not only the problems mentioned above appear again, but <b>visual noise</b> appears in the editor window. </li><li>  <b>Low flexibility:</b> when used as a Hitbox Collider, it means that when changing the shape of the collider, for example, from Box to Sphere, you will have to manually delete all BoxCollider and add SphereCollider (or write an editor script that does the work for you) </li></ul><br><h2>  Create everything yourself </h2><br>  As you probably understood from the above, Pushboxes and Hurtboxes are quite conveniently implemented with standard Unity components. <br><br>  Hurtboxes still have the aforementioned problems, and we will solve some of them, but the main entity that requires its own abstraction is Hitbox. <br><br>  If you create a fighting game with a variety of attacks and combos, then you probably want all the attacks to be well organized in the object and you can create several combinations of Hitboxes for each of them.  To do this, you will need a script that strictly delegates the OnTriggerEnter calls to an active attack or performs something similar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/373/82f/4ff37382fc219f6edd3c84dc6788014d.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/cd2/1bd/495cd21bd92fe213cf16e0ff7a68c99b.png" alt="image"></div><br>  <i>We do not want to create a separate <b>Hitbox</b> object for each of the attacks, and here we can use the same ones, changing their size!</i> <br><br><h2>  Hitboxes </h2><br>  We need a new component to solve the following tasks: <br><br><ol><li>  Possess Hitbox behavior: he must be able to check the overlay on the Hurtbox in arbitrary frames.  He must interact only with Hurtboxes. </li><li>  Have a visual representation in the Scene window. </li><li>  Be customizable and flexible. </li><li>  Ideally, do not depend on Unity API events. </li><li>  Be independent enough to be able to use the script for another object. </li><li>  Do not be tied to a specific attack.  Hitboxes should be applicable to several different attacks. </li></ol><br><h3>  Behavior </h3><br>  First, how do we check if an area overlaps a Collider?  The answer is to use <a href="https://docs.unity3d.com/ScriptReference/Physics.html">UnityEngine.Physics</a> . <br><br>  There are many methods in Physics that can accomplish this task.  We can specify the form we need (Box, Sphere, Capsule), and also if we want to receive Colliders, which we strike (if they have) as an array or pass an array to fill it with these Colliders.  For now we will not think about it, but in the first case a new array is allocated, and in the second we simply fill in the existing one. <br><br>  Let's start by checking if something hits a rectangular area.  For this we can use <b>OverlapBox</b> . <br><br>  We need to set the dimensions of the rectangle to be checked.  To do this, we need the center of the rectangle, its half value, the rotation and the layers that it should hit.  <b>Half value</b> is half the size in each direction, for example, if we have a rectangle with the size (2, 6, 8) then its half value will be equal to (1, 3, 4). <br><br>  As a center, we can use the transform position of the GameObject, and to rotate it, we can use the transform rotation of the GameObject, or add common variables to set specific values. <br><br>  The half value is just Vector3, so we will make it common and use it. <br><br>  For layers that can be hit, we will create a public property of type <b>LayerMask</b> .  This will allow us to select layers in the inspector. <br><br><pre><code class="cs hljs">Collider[] colliders = Physics.OverlapBox(position, boxSize, rotation, mask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colliders.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"We hit something"</span></span>); }</code> </pre> <br>  If the settings are correct and when the projected rectangle is superimposed on the Collider in the corresponding mask, we should see a message in the console. <br><br><h3>  Visual presentation </h3><br>  All this is great ... but not too functional.  Until we can see a rectangle defined somewhere, it will be very difficult to specify the appropriate size and location of the Hitboxes. <br><br>  So how do we draw a rectangle in the Scene window, but not in the game itself?  Using <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDrawGizmos.html">OnDrawGizmos</a> . <br><br>  As stated in the <a href="https://docs.unity3d.com/ScriptReference/Gizmos.html">documentation</a> , <i>Gizmos is intended for visual debugging or auxiliary constructions in the scene window</i> .  Exactly what we need! <br><br>  We will give our <b>Gizmo a</b> color and <a href="https://docs.unity3d.com/ScriptReference/Matrix4x4.html">transformation matrix</a> .  That is, we simply create a matrix with the position, rotation and scale of the transform. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.red; Gizmos.matrix = Matrix4x4.TRS(transform.position, transform.rotation, transform.localScale); Gizmos.DrawCube(Vector3.zero, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(boxSize.x * <span class="hljs-number"><span class="hljs-number">2</span></span>, boxSize.y * <span class="hljs-number"><span class="hljs-number">2</span></span>, boxSize.z * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//    -    }</span></span></code> </pre> <br>  If desired, you can use <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDrawGizmosSelected.html">OnDrawGizmosSelected</a> to draw a rectangle only when an object is selected. <br><br><h3>  Customizability and flexibility </h3><br>  Configurability is an extensive topic, it largely depends on the type of game being created and the required functionality. <br><br>  In our case, we will allow quick changes in the shape and color of the hitbox.  If you use <b>Anima2D</b> or some kind of skeletal animation, then you may need.  for Hitbox to scale to the scale of the bones. <br><br>  To change the form, all you need to do is add a boolean property and change OverlapBox to any other form, for example, <b>OverlapSphere</b> .  To configure a sphere, you will need to add a public radius property.  Do not forget that to draw a new form, you will need to change the OnDrawGizmos event (in our example, this will be <b>DrawSphere</b> ). <br><br>  It should be noted that we do not add a new component and do not delete anything, but simply created a boolean value that will choose the superimposed shape when checking for collisions.  It allows us to change the form of the hitbox depending on the attack (or even for the same attack). <br><br>  As for color, I want Hitbox to change color under the following conditions: it is inactive, it checks for collisions, or it detects a collision with something.  Later we will need these states for logic, so let's add them. <br><br>  We will create an <b>enum</b> for the state and three colors that we add as properties of our Hitbox. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ColliderState { Closed, Open, Colliding }</code> </pre> <br>  Your class might look something like this: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Hitbox</span></span>: <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LayerMask mask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useSphere = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 hitboxSize = Vector3.one; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color inactiveColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color collisionOpenColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color collidingColor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ColliderState _state; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }</code> </pre> <br>  Now we can update gizmos, replacing the line <code>Gizmos.color = Color.red;</code>  to call a new method: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkGizmoColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ColliderState.Closed: Gizmos.color = inactiveColor; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ColliderState.Open: Gizmos.color = collisionOpenColor; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ColliderState.Colliding: Gizmos.color = collidingColor; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  So where are we going to change the state?  We need three elements: <br><br><ol><li>  way to tell hitbox to start checking for collisions </li><li>  way to tell him to stop </li><li>  collision checking method </li></ol><br>  The first two are obvious: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startCheckingCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _state = ColliderState.Open; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopCheckingCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _state = ColliderState.Closed; }</code> </pre> <br>  Now that Hitbox is active, we want to check in each frame whether it has any collisions with anything while it is active.  In this case, we proceed to the next item. <br><br><h3>  Independence from the Unity Events API </h3><br>  As you probably know, we can use <b>Update</b> to check something in each frame (for the sake of simplicity, I don‚Äôt add a resize check): <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_state == ColliderState.Closed) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Collider[] colliders = Physics.OverlapBox(position, boxSize, rotation, mask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colliders.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { _state = ColliderState.Colliding; <span class="hljs-comment"><span class="hljs-comment">//     -   } else { _state = ColliderState.Open; } }</span></span></code> </pre> <br>  As you can see, we only return if the current state is ‚ÄúClosed‚Äù.  This means that we still check for collisions if Hitbox encounters something, which allows Hitbox to hit several objects at the same time, and not just the first hit.  In your game, you can process it differently. <br><br>  We use Update, but do not want to depend on the Unity Events API!  The solution may be to create your own public update method, which can be called <b>hitboxUpdate</b> (its contents will be the same as the Update method), and only be called in Hitboxes used in the current attack. <br><br>  Obviously, we will need to call Update () in some objects up the hierarchy, but we definitely don‚Äôt need to use them in every Hitbox all the time just because they exist. <br><br><h3>  Using Hitbox with a script in another object </h3><br>  Remember - the problem with using Collider was that to implement OnTriggerEnter we needed a script in the same GameObject?  Since we use our own script and can add it to anything, the solution is quite obvious. <br><br>  We will add an object as a property so that you can call some method for it when a Hitbox collides. <br><br>  To solve this problem, you can use different approaches: <br><br><ul><li>  We can add a public GameObject and use <a href="https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">SendMessage</a> (this method has very low speed). </li><li>  You can do the same with Monobehaviour, which uses the method that is called when a Hitbox collides.  This method has its drawback: if we want Hitboxes to use different scripts, then it will be necessary to add all these properties or inherit from the base script that contains the method being called </li><li>  You can create an <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface">interface</a> with the method you want to call and implement it in each class that Hitboxes should use. </li></ul><br>  In terms of structure, the obvious choice for me is interface.  The only problem with Unity is that the default editor does not display interfaces as public properties, so we cannot assign it to the editor.  In the next paragraph I will explain why this is not a serious problem. <br><br>  Let's create and apply the interface: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IHitboxResponder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collisionedWith</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider collider</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Add it as a property to our Hitbox ... <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Hitbox</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IHitboxResponder _responder = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }</code> </pre> <br>  Also, if you wish, you can use an array instead of a single respondent. <br><br>  Let's use the respondent: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hitboxUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_state == ColliderState.Closed) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Collider[] colliders = Physics.OverlapBox(position, boxSize, rotation, mask); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colliders.Length; i++) { Collider aCollider = colliders[i]; responder?.collisionedWith(aCollider); } _state = colliders.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? ColliderState.Colliding : ColliderState.Open; }</code> </pre> <br>  If you are unfamiliar with the operator "?", Then read <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-conditional-operators">this</a> . <br><br>  Fine!  But how do we set the <code>_responder</code> property <code>_responder</code>  Let's add a setter and look at it in the next paragraph. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useResponder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IHitboxResponder responder</span></span></span><span class="hljs-function">)</span></span> { _responder = responder; }</code> </pre> <br><h3>  Hitboxes should be applicable to several different attacks, and not tied to one </h3><br>  In this section, I will explain why it doesn‚Äôt matter that we cannot set <b>HitboxResponders</b> using an editor. <br><br>  First, let's talk about these "respondents."  In the approach we have chosen to implement Hitbox, the respondent is any class that has to do something when Hitbox is in collision with Collider, that is, it implements <b>IHitboxResponder</b> .  For example, you can take the attack script: we want it to inflict damage on what we hit. <br><br>  Since we want it not to be associated with a particular attack and could be used many times, the task of the respondents in the editor would not give us anything, because we want to be able to change respondents on the fly. <br><br>  Suppose we have two types of attacks - a direct hit and an uppercut with the same hand, and each of them has its own script, telling which animation frames it should hit, how much damage to do and the like.  Since both of these attacks are carried out with one limb, let's use one Hitbox. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Attack</span></span>: <span class="hljs-title"><span class="hljs-title">Monobehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IHitboxResponder</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> damage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Hitbox hitbox; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hitbox.setResponder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      } void collisionedWith(Collider collider) { Hurtbox hurtbox = collider.GetComponent&lt;Hurtbox&gt;(); hurtbox?.getHitBy(damage); } }</span></span></code> </pre> <br>  Fine!  We have created working hitboxes.  As you can see from the code above, we added the Hurtbox method <code>getHitBy(int damage)</code> .  Let's see if we can improve it. <br><br><h3>  Hurtbox enhancements </h3><br>  Ideally, for Hurtboxes, we want to implement more or less the same items as for Hitboxes.  This should be easier, because Collider has the functionality we need.  We also need to use Collider, otherwise Physics.Overlap ... will not report a bump. <br><br>  Notice that due to the way we structured the code, we do not need to use OnTriggerEnter for anything, we get the script using GetComponent. <br><br>  This gives us customizability and flexibility.  To provide the same flexibility as Hitboxes, we need to add and remove colliders on the fly, and for customizability we can draw color on the collider depending on its state. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Hurtbox</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Collider collider; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ColliderState _state = ColliderState.Open; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHitBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -     } private void OnDrawGizmos() { //       , //   ,      } }</span></span></code> </pre> <br>  Adding and removing Colliders on the fly is not as easy as Hitboxes.  I have not found a satisfactory way to accomplish this task.  We can add several different Colliders to the script and choose the one we need using a Boolean value, as we did in Hitbox.  The problem here is that it is necessary to add each required Collider as a component and as a result we will have a strong visual noise in the editor and on the object. <br><br>  Another approach would be to add and remove components through the code, but this solution will add a bunch of unnecessary garbage and probably will not be so accurate. <br><br>  It would be ideal for Hurtbox to inherit from Collider, and all of its form logic was internal and we could only draw the form we are using, but I could not get this system to work as I wanted. <br><br><h3>  What's next? </h3><br>  If you repeated closely followed and repeated the operations in the post, now you have implemented hitboxes, hurtboxes and pushboxes implemented in Unity.  But more importantly, now we know these abstractions, and this will greatly simplify the work if you build something on top of them. <br><br>  Probably now the Script Inspector looks awful, but don't worry, we will look at it in the next post: <b><br></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/533/ae8/85b/533ae885bb213cd723c84683cdc1d8e5.png"></div><br>  <i>We can turn it ...</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/7ba/f0e/1d47baf0e001e04ac8e204e08955fc98.png"></div><br>  <i>In something like this!</i> </div><p>Source: <a href="https://habr.com/ru/post/358548/">https://habr.com/ru/post/358548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358536/index.html">The Telegram v. Russia case will be considered by the European Court of Human Rights. Also sent a complaint to the Moscow City Court</a></li>
<li><a href="../358538/index.html">New orienteering: how to determine your location</a></li>
<li><a href="../358540/index.html">First Atlassian User Group in Minsk</a></li>
<li><a href="../358544/index.html">One day as a user support employee. What does it change?</a></li>
<li><a href="../358546/index.html">How to plan the capacity of the Apache Ignite cluster</a></li>
<li><a href="../358550/index.html">Monitoring Elasticsearch without pain and suffering</a></li>
<li><a href="../358552/index.html">Best practices for designing productive mobile APIs</a></li>
<li><a href="../358554/index.html">Confrontation: results</a></li>
<li><a href="../358558/index.html">The whole program Backend Conf: from microservices to endless data</a></li>
<li><a href="../358560/index.html">Digest news from the world of PostgreSQL. Issue number 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>