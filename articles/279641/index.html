<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagger 2. Part Two. Custom scopes, Component dependencies, Subcomponents</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 We continue our series of articles on Dagger 2. If you have not yet read the first part , do it immediately :) 
 Many thanks for the feedback...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagger 2. Part Two. Custom scopes, Component dependencies, Subcomponents</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello! <br>  We continue our series of articles on Dagger 2. If you have not yet read the <a href="https://habrahabr.ru/post/279125/">first part</a> , do it immediately :) <br>  Many thanks for the feedback and comments on the first part. <br>  In this article we will talk about custom scopes, about linking components through component dependencies and subcomponents.  And also we will touch upon such an important question as the architecture of the mobile application, and how Dagger 2 helps us build a more correct, module-independent architecture. <br>  I ask all those interested under the cat! </p><a name="habracut"></a><br><h2 id="arhitektura-i-custom-scopes">  Architecture and custom scopes </h2><br><p>  Let's start with architecture.  Recently, a lot of attention has been paid to this issue, many articles and speeches are devoted.  The question is certainly important, because from the way we call the boat, so it will float.  Therefore, I highly recommend to start reading these articles: </p><br><ol><li>  <a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture by Uncle Bob</a> </li><li>  <a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/">Clean Architecture in Android</a> </li><li>  <a href="https://habrahabr.ru/post/250659/">Translation into Russian</a> </li></ol><br><p>  I really like the Clean Architecture approach in building architecture.  It allows for a clear vertical and horizontal construction of all modules, where each class does only what it has to do.  For example, Fragment is responsible only for displaying the UI, and not implementing requests to the network, database, implementation of business logic and other things, which made Fragment just a huge piece of tangled code.  I think many people know this .. </p><br><p>  Consider an example.  There is an application.  There are several modules in the application, one of which is a chat module.  The chat module includes three screens: a single chat screen, a group chat and settings. <br>  Remembering Clean architecture, we distinguish three horizontal levels: </p><br><ol><li> The level of the entire application.  Here are the objects that are needed throughout the entire life cycle of the application, that is, "global singletons".  Let it be objects: <code>Context</code> (global context), <code>RxUtilsAbs</code> (utility class), <code>NetworkUtils</code> (utility class), and <code>IDataRepository</code> (class responsible for server requests). </li><li>  Chat level  Objects that are needed for all three Chat screens: <code>IChatInteractor</code> (a class that implements specific Chat business cases) and <code>IChatStateController</code> (a class that is responsible for Chat status). </li><li>  The level of each chat screen.  Each screen will have its own Presenter, resistant to reorientation, that is, whose life cycle will be different from the life cycle of the fragment / activation. </li></ol><br><p>  Schematically, life cycles will look like this: <br><img src="https://habrastorage.org/files/c9b/793/e44/c9b793e44fc74e30a05c4d5bb56eeb5f" alt="image"></p><br><p>  Remember, in the last article we mentioned the "local" singltons?  So, the objects of the chat levels and each chat screen are "local singletons", that is, objects whose life cycle is longer than the life cycle of the standard activation / fragment, but less than the life cycle of the entire application. <br>  But now Dagger 2 comes into play, which has a wonderful Scopes mechanism.  This mechanism assumes the creation and storage of a single instance of the required class as long as the corresponding scope exists.  I am sure that the phrase "while the existing scope exists" is somewhat confusing and raises questions.  Do not worry, everything will become clear below. <br>  In the last article, we tagged the "global singletons" scope <code>@Singleton</code> .  This scope has existed for the entire lifetime of the application.  But we can also create our own custom scope annotations.  For example: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ChatScope { }</code> </pre> <br><p>  And creating the <code>@Singleton</code> annotation in Dagger 2 looks like this: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Singleton { }</code> </pre> <br><p>  That is, <code>@Singleton</code> is no different from <code>@ChatScope</code> , just the <code>@Singleton</code> annotation <code>@Singleton</code> provided by the default library.  And the purpose of these annotations is one thing - specify Dagger, provide "scope" or "unscoped" objects.  But, again, I repeat, we are responsible for the life cycle of the "scope" of objects. <br>  We return to our example.  According to the current architecture, we get three groups of objects that have their own "length of life".  Thus, we need three scope annotations: </p><br><ol><li>  <code>@Singleton</code> - for global singltons. </li><li>  <code>@ChatScope</code> - for Chat objects. </li><li>  <code>@ChatScreenScope</code> - for objects of a particular Chat screen. </li></ol><br><p>  In this case, we note that <code>@ChatScope</code> objects must have access to <code>@Singleton</code> objects, and <code>@ChatScreenScope</code> - to <code>@Singleton</code> and <code>@ChatScope</code> objects. <br>  Schematically: <br><img src="https://habrastorage.org/files/5f1/2eb/1a3/5f12eb1a3fd84350bfc78a1c1e35127b" alt="image"><br>  Next comes the creation and the corresponding component of Dagger: </p><br><ol><li>  <code>AppComponent</code> that provides "global singletones". </li><li>  <code>ChatComponent</code> providing "local singltons" for all Chat screens. </li><li>  <code>SCComponent</code> , which provides "local singltons" for a specific Chat screen ( <code>SingleChatFragment</code> , i.e., Single Chat screen). </li></ol><br><p>  And again we visualize the above: <br><img src="https://habrastorage.org/files/b61/fa0/74c/b61fa074c8984c27befb1aa3ca2a30e1" alt="image"><br>  As a result, we obtain three components with three different scope-annotations that are connected to each other in a chain.  <code>ChatComponent</code> depends on <code>AppComponent</code> , and <code>SCComponent</code> on <code>ChatComponent</code> . </p><br><p>  But now the question arises, how do we properly link these components?  There are two ways. </p><br><h2 id="component-dependencies">  Component dependencies </h2><br><p>  This communication method was pumping from Dagger 1. <br>  We note immediately the features of Component dependencies: </p><br><ol><li>  Two dependent components cannot have the same scope.  Similar <a href="https://github.com/google/dagger/issues/107">here</a> . </li><li>  The parent component in its interface must explicitly specify objects that dependent components can use. </li><li>  A component may depend on several components. </li></ol><br><p>  As in our example, the dependency diagram will look like with component dependencies: <br><img src="https://habrastorage.org/web/844/396/29c/84439629c4434356bb2fbf0bec3d8d74.png" alt="image"><br>  Now we will consider each component with its modules separately. </p><br><p>  <strong>Appcomponent</strong> <br><img src="https://habrastorage.org/files/f1a/67d/266/f1a67d266adf4212b3f60f30a614b3ab.png" alt="image"><br>  Note that in the interface of the component we explicitly specify the objects that will be available for the child components ( <strong>but not for the subsidiaries of the child components</strong> , <strong>let's</strong> talk about this situation a bit later).  For example, if the child component wants <code>NetworkUtils</code> , then Dagger will give the corresponding error. <br>  In the interface, we can also still set injection targets.  That is, you should not be mistaken that if a component has child components, then it cannot inject its dependencies into the necessary classes (activations / fragments / other). </p><br><p>  <strong>Chatcomponent</strong> <br><img src="https://habrastorage.org/web/64c/1e6/31a/64c1e631ad8f4f4da4073990a2293988.png" alt="image"><br>  In the annotation for <code>ChatComponent</code> we explicitly prescribe what component <code>ChatComponent</code> should depend <code>ChatComponent</code> (depends on <code>AppComponent</code> ).  Yes, as it was noted earlier, the component component may have several parents (it is enough just to add new parent components to the annotation).  But the scope annotations of the components should be different.  And also in the interface we explicitly register those objects to which the child components can have access. <br>  Notice the green arrow?  As we have said, <code>ChatComponent</code> can use dependencies on <code>AppComponent</code> , which it explicitly indicated.  But the <code>ChatComponent</code> child components <code>ChatComponent</code> no longer use <code>AppComponent</code> , unless we explicitly register these dependencies in <code>ChatComponent</code> , which we actually did for <code>Context</code> . </p><br><p>  <strong>Sccomponent</strong> <br><img src="https://habrastorage.org/files/e67/72c/b59/e6772cb59c2a43d48555423fca53222a" alt="image"><br>  <code>SCComponent</code> is <code>SCComponent</code> dependent, and it <code>SingleChatFragment</code> dependencies into a <code>SingleChatFragment</code> .  In this case, in <code>SingleChatFragment</code> this component can inject both <code>SCPresenter</code> and other objects of the parent components, which are explicitly specified in the corresponding interfaces. </p><br><p>  Stayed last step.  This is to initialize the components: <br><img src="https://habrastorage.org/files/e41/926/9a7/e419269a70be4ee481306855cb81455c" alt="image"></p><br><p>  Compared to a regular component, when the dependent component is initialized in the DaggerChatComponent and <code>DaggerSCComponent</code> , another method appears - <code>appComponent(...)</code> (for <code>DaggerChatComponent</code> ) and <code>chatComponent(...)</code> (for <code>DaggerSCComponent</code> ), into which we specify initialized parent components. <br>  By the way, if a component has two parents, then two corresponding methods appear in the builder.  If there are three parents, then there are three methods, etc. <br>  Since all components have their own life cycle, different from the activation / fragment life cycle, we will initialize and store the component instances in the Application file.  An example of the Application class is considered at the end. </p><br><h2 id="subcomponents">  Subcomponents </h2><br><p>  The feature is already Dagger2. <br>  Features: </p><br><ol><li>  It is necessary to prescribe in the interface of the parent the method of obtaining the subcomponent (the simplified name Subcomponent) </li><li>  All parent objects are available for the Subcomponent. </li><li>  There can be only one parent </li></ol><br><p>  Yes, Subcomponents have some differences from Component dependencies.  Consider the schema and code to better understand the differences. </p><br><p><img src="https://habrastorage.org/files/877/2c1/4b1/8772c14b16c84399acd7d521341bbd5a" alt="image"></p><br><p>  According to the scheme, we see that all objects of the parent are available for the child component, and so on throughout the component dependency tree.  For example, <code>SCComponent</code> is available for <code>NetworkUtils</code> . </p><br><p>  <strong>Appcomponent</strong> </p><br><p><img src="https://habrastorage.org/files/fff/b0c/37e/fffb0c37e72a4af989b45ffc2880d9d7" alt="image"></p><br><p>  The next difference is Subcomponents.  In the <code>AppComponent</code> interface, <code>AppComponent</code> create a method for the subsequent initialization of <code>ChatComponent</code> .  Again, the main thing in this method is the return value ( <code>ChatComponent</code> ) and the arguments ( <code>ChatModule</code> ). <br>  I note that <code>ChatModule</code> don‚Äôt need to pass anything to the constructor of our <code>ChatModule</code> (the default constructor), so you can omit this argument in the <code>plusChatComponent</code> method.  However, for a clearer picture of dependencies and for educational purposes, for the time being we will leave everything as detailed as possible. </p><br><p>  <strong>Chatcomponent</strong> <br><img src="https://habrastorage.org/files/f4f/753/334/f4f7533346f94f6cb9ae640cdf7c8cf3" alt="image"><br>  <code>ChatComponent</code> - is both a child and a parent component.  <code>SCComponent</code> parent is indicated by the method of creating an <code>SCComponent</code> in the interface.  And the fact that a component is a child is indicated by the <code>@Subcomponent</code> annotation. </p><br><p>  <strong>Sccomponent</strong> <br><img src="https://habrastorage.org/files/d4a/8fb/f39/d4a8fbf397704ca49201d4f1a49297f2" alt="image"></p><br><p>  As we noted earlier, since all components have their own life cycle, which is different from the activation / fragment life cycle, we will initialize and store the instances of the components in the Application file: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApp</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MyApp instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MyApp </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-comment"><span class="hljs-comment">// Dagger 2 components private AppComponent appComponent; private ChatComponent chatComponent; private SCComponent scComponent; @Override public void onCreate() { super.onCreate(); instance = this; // init AppComponent on start of the Application appComponent = DaggerAppComponent.builder() .appModule(new AppModule(instance)) .build(); } public ChatComponent plusChatComponent() { // always get only one instance if (chatComponent == null) { // start lifecycle of chatComponent chatComponent = appComponent.plusChatComponent(new ChatModule()); } return chatComponent; } public void clearChatComponent() { // end lifecycle of chatComponent chatComponent = null; } public SCComponent plusSCComponent() { // always get only one instance if (scComponent == null) { // start lifecycle of scComponent scComponent = chatComponent.plusSComponent(new SCModule()); } return scComponent; } public void clearSCComponent() { // end lifecycle of scComponent scComponent = null; } }</span></span></code> </pre> <br><p>  And now we can finally see the life cycle of the components in the code.  Everything is clear about <code>AppComponent</code> , we initialized it when the application started and we don‚Äôt touch it anymore.  But we initialize <code>ChatComponent</code> and <code>SCComponent</code> as needed using the <code>plusChatComponent()</code> and <code>plusSCComponent</code> .  These methods are also responsible for returning single instances of the component. <br>  So when you call again, for example, <br> <code>scComponent = chatComponent.plusSComponent(new SCModule());</code> <br>  a new instance of <code>SCComponent</code> with its dependency graph. <br>  With the help of the <code>clearChatComponent()</code> and <code>clearSCComponent()</code> methods, we can end the life of the corresponding components with their graphs.  Yes, the usual reference links.  If <code>ChatComponent</code> and <code>SCComponent</code> needed again, then we simply call the <code>plusChatComponent()</code> and <code>plusSCComponent</code> that create new instances. <br>  Just in case, I‚Äôll clarify that in this example we cannot initialize <code>ChatComponent</code> when <code>SCComponent</code> is not initialized <code>ChatComponent</code> we will snatch a <code>NullPointerException</code> . <br>  Also note that if you have a lot of components and subcomponents, then it is better to put all this code from <code>MyApp</code> into a special singleton (for example, <code>Injector</code> ), which will be responsible for creating, destroying and providing the necessary Dugger components. </p><br><p>  That's all.  As you have seen, custom scopes, component dependencies and subcomponent are extremely important elements of Dagger 2, with which the developer can create a more structured and correct architecture. <br>  In addition to reading I recommend the following articles: </p><br><ol><li>  <a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-the-api/">Very good article about Dagger 2 in general</a> </li><li>  <a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-custom-scopes/">About custom scopes of the same author</a> </li><li>  <a href="http://jellybeanssir.blogspot.ru/2015/05/component-dependency-vs-submodules-in.html">Differences component dependencies from subcomponents</a> </li></ol><br><p>  I will be glad to your comments, comments, questions and likes :) <br>  In the next article we will consider the use of Dagger 2 in testing, as well as additional, but no less important and functional features of the library. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/279641/">https://habr.com/ru/post/279641/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279629/index.html">Security Week 11: Trojans on iOS without jailbreak, leaked on American Express, stealing uchetok Steam</a></li>
<li><a href="../279633/index.html">Search for changes in two collections</a></li>
<li><a href="../279635/index.html">Today starts the official part of <hackathon_weekend /> in Stavropol</a></li>
<li><a href="../279637/index.html">March Releases of Official Yii 2.0 Extensions</a></li>
<li><a href="../279639/index.html">What can flog whips in the digital age? How does GitHub comply with DMCA, RFC 7725 and what is HTTP 451?</a></li>
<li><a href="../279645/index.html">Weekly assembly Vivaldi 1.0.425.3 with a surprise</a></li>
<li><a href="../279647/index.html">Generation and visualization of multidimensional data with R</a></li>
<li><a href="../279651/index.html">Algorithms are just one of the variables in the equation.</a></li>
<li><a href="../279653/index.html">2.2 Streams</a></li>
<li><a href="../279655/index.html">The source code of the compact hypervisor is published on GitHub.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>