<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a Babel plugin</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modularity is firmly established in the javascript world. However, with all the advantages, writing the same imports in each file is tiring. And what ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a Babel plugin</h1><div class="post__text post__text-html js-mediator-article">  Modularity is firmly established in the javascript world.  However, with all the advantages, writing the same imports in each file is tiring.  And what if you remove the connection of frequently used modules to the collector, and in the code to use them as global variables?  Looks like a babel plugin task.  Well, let's write together such a plugin, incidentally figuring out how babel works. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/80f/d39/4e0/80fd394e0ed548258280f01d8be051a6.png"></div><a name="habracut"></a><br>  Let's start with the "skeleton".  A plugin is a function that returns an object with visitors (visitors).  An argument with it is passed an object with modules from the <i>babel-core</i> .  In the future, we need the <i>babel-types</i> module. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{types: t}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">visitor</span></span>: {} }; }</code> </pre> <br>  The visitor is a method of the <code>visitor</code> object whose name corresponds to the type of the abstract syntax tree (ASD) node, for example, <code>FunctionDeclaration</code> or <code>StringLiteral</code> ( <a href="http://babeljs.io/docs/core-packages/babel-types/">full list</a> ), to which the path (path) to the node is passed.  We are interested in nodes of type <code>Identifier</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{types: t}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">visitor</span></span>: { Identifier(path, {<span class="hljs-attr"><span class="hljs-attr">opts</span></span>: options}) { } } }; }</code> </pre><br>  Also, the visitor has access to the plugin settings in the <code>.opts</code> property of the second argument.  Through them we will pass the variable names and paths to the modules for which the import will be created.  It will look like this: <br><br>  <i>.babelrc</i> <br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">plugins</span></span>: [[ <span class="hljs-string"><span class="hljs-string">"babel-plugin-auto-import"</span></span>, { declarations: [{name: <span class="hljs-string"><span class="hljs-string">"React"</span></span>, path: <span class="hljs-string"><span class="hljs-string">"react"</span></span>}] } ]] }</code> </pre><br><h2>  <font color="#3AC1EF">Bypass ASD.</font>  <font color="#3AC1EF">Ways</font>  <font color="#3AC1EF">Knots</font> </h2><br>  Babel takes as input a code (as a string), which is broken up into tokens, from which the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">ASD</a> is built.  Then the plugins change the ASD, and a new code is generated from it, which is fed to the output.  For manipulations with ASD, plugins use paths.  You can also check through the paths what type of node this path represents.  For this there are methods of the format <code>.["is" +  ]()</code> .  For example, <code>path.isIdentifier()</code> .  The path can be searched among child paths using the <code>.find(callback)</code> method, and among parent paths using the <code>.findParent(callback)</code> method.  The <code>.parentPath</code> property stores a link to the parent path. <br><br>  Let's start writing the plugin itself.  First and foremost, you need to filter identifiers.  The <code>Identifier</code> type is widely used in various types of nodes.  We need only some of them.  Suppose we have this code: <br><br><pre> <code class="javascript hljs">React.Component</code> </pre><br>  ASD for this code looks like this: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"MemberExpression"</span></span>, <span class="hljs-attr"><span class="hljs-attr">object</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"React"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">property</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Component"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">computed</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  A node is an object with the <code>.type</code> property and some other properties specific to each type.  Consider the root node - <code>MemberExpression</code> .  He has three properties.  <code>Object</code> is the expression to the left of the point.  In this case, it is an identifier.  The <code>computed</code> property indicates whether there is an identifier or some expression on the right, for example, <code>x["a" + b]</code> .  <code>Property</code> - actually, that to the right of a point. <br><br>  If we start our plug-in framework now, the <code>Identifier</code> method will be called twice: for <code>React</code> and <code>Component</code> identifiers, respectively.  The plugin should handle the <code>React</code> ID, but skip the <code>Component</code> ID.  To do this, the identifier path must receive the parent path and, if it is a node of type <code>MemberExpression</code> , check whether the identifier is a <code>.object</code> property.  We put the check into a separate function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{types: t}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">visitor</span></span>: { Identifier(path, {<span class="hljs-attr"><span class="hljs-attr">opts</span></span>: options}) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isCorrectIdentifier(path)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCorrectIdentifier</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {parentPath} = path; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isMemberExpression() &amp;&amp; parentPath.get(<span class="hljs-string"><span class="hljs-string">"object"</span></span>) == path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre><br>  In the final version of such checks there will be many - for each case its own check.  But they all work on the same principle. <br><br><div class="spoiler">  <b class="spoiler_title">Full list</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCorrectIdentifier</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {parentPath} = path; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isArrayExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isArrowFunctionExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isAssignmentExpression() &amp;&amp; parentPath.get(<span class="hljs-string"><span class="hljs-string">"right"</span></span>) == path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isAwaitExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isBinaryExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.bindExpression &amp;&amp; parentPath.bindExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isCallExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isClassDeclaration() &amp;&amp; parentPath.get(<span class="hljs-string"><span class="hljs-string">"superClass"</span></span>) == path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isClassExpression() &amp;&amp; parentPath.get(<span class="hljs-string"><span class="hljs-string">"superClass"</span></span>) == path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isConditionalExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isDecorator()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isDoWhileStatement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isExpressionStatement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isExportDefaultDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isForInStatement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isForStatement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isIfStatement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isLogicalExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isMemberExpression() &amp;&amp; parentPath.get(<span class="hljs-string"><span class="hljs-string">"object"</span></span>) == path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isNewExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isObjectProperty() &amp;&amp; parentPath.get(<span class="hljs-string"><span class="hljs-string">"value"</span></span>) == path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !parentPath.node.shorthand; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isReturnStatement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isSpreadElement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isSwitchStatement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isTaggedTemplateExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isThrowStatement()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isUnaryExpression()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentPath.isVariableDeclarator() &amp;&amp; parentPath.get(<span class="hljs-string"><span class="hljs-string">"init"</span></span>) == path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br></div></div><br><h2>  <font color="#3AC1EF">Variable scope</font> </h2><br>  The next step is to check whether our identifier is declared as a local variable or is global.  For this, there is one useful property in the paths - <code>scope</code> .  With it, we will iterate all scopes, starting with the current.  The variables for the current scope are in the <code>.bindings</code> property.  The link to the parent scope is in the <code>.parent</code> property.  It remains to recursively go through all the variables of all scopes and check if our identifier is there. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{types: t}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">visitor</span></span>: { Identifier(path, {<span class="hljs-attr"><span class="hljs-attr">opts</span></span>: options}) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isCorrectIdentifier(path)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-attr"><span class="hljs-attr">node</span></span>: identifier, scope} = path; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDefined(identifier, scope)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }; <span class="hljs-comment"><span class="hljs-comment">// ... function isDefined(identifier, {bindings, parent}) { let variables = Object.keys(bindings); if (variables.some(has, identifier)) return true; return parent ? isDefined(identifier, parent) : false; } function has(identifier) { let {name} = this; return identifier == name; } }</span></span></code> </pre><br>  Fine!  Now we are sure that you can work with the identifier.  Take <code>options</code> from the declaration of ‚Äúglobal‚Äù variables and process them: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {declarations} = options; declarations.some(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">declaration</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (declaration.name == identifier.name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> program = path.findParent(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function"> =&gt;</span></span> path.isProgram()); insertImport(program, declaration); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } });</code> </pre><br><h2>  <font color="#3AC1EF">Modification of the ASD</font> </h2><br>  And here we have come to change the SDA.  But before we begin to insert new imports, we get all the existing ones.  To do this, we use the <code>.reduce</code> method to get an array with paths like <code>ImportDeclaration</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertImport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">program, { name, path }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> programBody = program.get(<span class="hljs-string"><span class="hljs-string">"body"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentImportDeclarations = programBody.reduce(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentPath</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPath.isImportDeclaration()) list.push(currentPath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }, []); }</code> </pre><br>  Now let's check if our identifier is already connected: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> importDidAppend = currentImportDeclarations.some(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{node: importDeclaration}</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (importDeclaration.source.value == path) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> importDeclaration.specifiers.some(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">specifier</span></span></span><span class="hljs-function"> =&gt;</span></span> specifier.local.name == name); } });</code> </pre><br>  If the module is not connected, create a new import node and insert it into the program. <br><br>  To create nodes, use the <i>babel-types</i> module.  The link to it is in the variable <code>t</code> .  For each of the nodes has its own method.  We need to create <code>importDeclaration</code> .  We look at the <a href="http://babeljs.io/docs/core-packages/babel-types/">documentation</a> and see that creating import requires specifiers (that is, the names of the variables being imported) and the path to the module. <br><br>  First create a qualifier.  Our plugin connects modules as exported by default ( <code>export default ...</code> ).  Then create a node with a path to the module.  This is a simple <code>StringLiteral</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> specifier = t.importDefaultSpecifier(t.identifier(name)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pathToModule = t.stringLiteral(path);</code> </pre><br>  Well, we have everything to create an import: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> importDeclaration = t.importDeclaration([specifier], pathToModule);</code> </pre><br>  It remains to insert the node in the ASD.  For this we need a way.  The path can be replaced by a node using the <code>.replaceWith(node)</code> method, or an array of nodes using the <code>.replaceWithMultiple([...nodes])</code> method <code>.replaceWithMultiple([...nodes])</code> .  Can be removed using the <code>.remove()</code> method.  For insertion, the <code>.insertBefore(node)</code> and <code>.insertAfter(node)</code> methods are used to insert a node before or after the path, respectively. <br><br>  In our case, the import must be inserted into the so-called container.  The <code>program</code> node has a property <code>.body</code> , which contains an array of expressions representing the program.  To insert nodes into such ‚Äúcontainer‚Äù arrays, paths have special methods <code>pushContainer</code> and <code>unshiftContainer</code> .  We use the latter: <br><br><pre> <code class="javascript hljs">program.unshiftContainer(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, importNode);</code> </pre><br>  Plugin ready.  We got acquainted with the main API Babel, considered the principles of the device and the plug-ins.  The plugin we made is a simplified version that does not work correctly.  But with the knowledge gained you can easily read the <a href="">full code of the plugin</a> .  I hope the article was interesting, and the experience gained was useful.  So tnank you! </div><p>Source: <a href="https://habr.com/ru/post/330018/">https://habr.com/ru/post/330018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330008/index.html">How not to give the algorithm to sell the bank</a></li>
<li><a href="../330010/index.html">HPE 3PAR StoreServ 9450</a></li>
<li><a href="../330012/index.html">Attack on AB test: recipe 'R' + t (101) + 'es46'</a></li>
<li><a href="../330014/index.html">NeoQUEST-2017: what awaits the guests at the jubilee "confrontation"?</a></li>
<li><a href="../330016/index.html">QEMU-KVM under LXC</a></li>
<li><a href="../330024/index.html">Oracle SystemTap</a></li>
<li><a href="../330026/index.html">Amazon Alexa Skill Smart Home with Open Source ioBroker Home Automation Platform</a></li>
<li><a href="../330028/index.html">Integration SaltStack and Telegram</a></li>
<li><a href="../330030/index.html">Dynamic Angular or manipulate correctly</a></li>
<li><a href="../330032/index.html">OpenTl.Server - server implementation of the messenger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>