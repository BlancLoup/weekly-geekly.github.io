<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the development of web-applications on PSGI / Plack. Part 3. Starman</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing a series of articles on PSGI / Plack. Reviewed in more detail preforking Starman PSGI server. 

 With the permission of the author of the a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the development of web-applications on PSGI / Plack. Part 3. Starman</h1><div class="post__text post__text-html js-mediator-article">  <i>Continuing a series of articles on PSGI / Plack.</i>  <i>Reviewed in more detail preforking Starman PSGI server.</i> <br><br>  With the permission of the author of the article and the chief editor of the magazine <a href="http://pragmaticperl.com/">PragmaticPerl.com</a> .  The original article is located <a href="http://pragmaticperl.com/issues/04/pragmaticperl-04-%25D0%25B2%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5-%25D0%25B2-%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D1%2583-web-%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9-%25D0%25BD%25D0%25B0-psgiplack.-%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D1%258C-3.-starman..html">here.</a> <br><br><h2>  Starman? </h2><br>  The author of this server (Tatsuhiko Miyagawa) says the following about him: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ‚ÄúStarman‚Äôs name comes from Star HA Otoko‚Äôs song from Japanese rock band Unicorn (Yes, Unicorn).  David Bowie also has a song of the same name, Starman is the name of the character of the cult Japanese game Earthbound, the name of the musical theme from the Super Mario Brothers. <br><br>  I'm tired of naming Perl modules like HTTP :: Server :: PSGI :: How :: Its :: Written :: With :: What :: Module, and as a result people call it HSPHIWWWM in IRC.  It is badly pronounced and creates problems for beginners.  Yes, maybe I am an uproar.  Time will tell." <br><br>  With the name sorted out.  Now we will deal with the server itself. <br><a name="habracut"></a><br><br><h2>  Preforking? </h2><br>  Starman's preforking model is similar to the most high-performance Unix servers.  It uses a model of pre-running processes  It also automatically restarts the pool of workers and removes its zombie processes. <br><br><h2>  Plack application </h2><br>  This time the Plack application will be quite elementary: <br><br><pre><code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'body'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body2</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;body(body()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $app }; };</code> </pre> <br>  When developing, Starman needs to understand one very important point of its work.  Consider, for example, a connection to a database.  Very often, in order to save time and lines of code, the connection initialization is brought to the very beginning of the script.  This applies to CGI and sometimes FastCGI.  In the case of PSGI, this is not possible.  And that's why.  When the server starts, this code will be executed exactly once for each worker.  And the danger of the situation lies in the fact that at first, until the connection takes off either by timeout or for some other reason, the application will work in normal mode.  In the case of asynchronous servers, you can initialize the connection pool at the beginning of the application code (connection! = Connection pool). <br><br>  In order to confirm or deny this, we will make changes to the application code.  Add to the beginning of the code, after imports, the following line: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'AFTER IMPORT'</span></span>;</code> </pre><br><br>  Now the application should look like: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'AFTER IMPORT'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'body'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body2</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;body(body()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $app }; };</code> </pre><br>  For the purity of the experiment, we will launch a starman with one worker at the following command: <br><br><pre> <code class="bash hljs">starman --port 8080 --workers 1 app.psgi</code> </pre><br><br>  Where app.psgi is an application. <br><br>  Immediately after the launch, we see the following picture in STDERR: <br><br><pre> <code class="bash hljs">noxx@noxx-inferno ~/perl/psgi $ starman --port 8080 app.psgi --workers 1 2013/06/02-15:05:31 Starman::Server (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Net::Server::PreFork) starting! pid(4204) Resolved [*]:8080 to [::]:8080, IPv6 Not including resolved host [0.0.0.0] IPv4 because it will be handled by [::] IPv6 Binding to TCP port 8080 on host :: with IPv6 Setting gid to <span class="hljs-string"><span class="hljs-string">"1000 1000 4 24 27 30 46 107 125 1000 1001"</span></span> AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7.</code> </pre><br>  If you send a request to localhost: 8080 /, you can make sure that nothing new in STDERR has appeared, and the server responds normally. <br>  In order to make sure that the worker is really alone, run the following command: <br><br><pre> <code class="bash hljs">ps uax | grep starman</code> </pre><br><br>  Result: <br><br><pre> <code class="bash hljs">noxx 4204 0.6 0.1 57836 11264 pts/3 S+ 15:05 0:00 starman master --port 8080 app.psgi --workers 1 noxx 4205 0.2 0.1 64708 13164 pts/3 S+ 15:05 0:00 starman worker --port 8080 app.psgi --workers 1 noxx 4213 0.0 0.0 13580 940 pts/4 S+ 15:05 0:00 grep --colour=auto starman</code> </pre><br>  There are two processes.  But actually worker from them only one.  Let's do another experiment.  Run the starman with three workers. <br><br><pre> <code class="bash hljs">starman --port 8080 --workers 3 app.psgi</code> </pre><br><br>  Result: <br><br><pre> <code class="bash hljs">2013/06/02-15:11:08 Starman::Server (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Net::Server::PreFork) starting! pid(4219) Resolved [*]:8080 to [::]:8080, IPv6 Not including resolved host [0.0.0.0] IPv4 because it will be handled by [::] IPv6 Binding to TCP port 8080 on host :: with IPv6 Setting gid to <span class="hljs-string"><span class="hljs-string">"1000 1000 4 24 27 30 46 107 125 1000 1001"</span></span> AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7.</code> </pre><br><br>  That's right.  Now look at the process list.  I have it looks like this: <br><br><pre> <code class="bash hljs">noxx 4219 0.1 0.1 57836 11264 pts/3 S+ 15:11 0:00 starman master --port 8080 app.psgi --workers 3 noxx 4220 0.0 0.1 64460 12756 pts/3 S+ 15:11 0:00 starman worker --port 8080 app.psgi --workers 3 noxx 4221 0.0 0.1 64460 12920 pts/3 S+ 15:11 0:00 starman worker --port 8080 app.psgi --workers 3 noxx 4222 0.0 0.1 64460 12756 pts/3 S+ 15:11 0:00 starman worker --port 8080 app.psgi --workers 3 noxx 4224 0.0 0.0 13580 936 pts/4 S+ 15:12 0:00 grep --colour=auto starman</code> </pre><br><br>  One master, three workers. <br><br>  Deal with the order of execution.  Now add another warning. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'IN BUILDER'</span></span></code> </pre><br><br>  The application is as follows: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'AFTER IMPORT'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'body'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body2</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;body(body()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'IN BUILDER'</span></span>; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $app }; };</code> </pre><br><br>  For one worker process, the output looks like this (startup command: starman --port 8080 --workers 1 app.psgi): <br><br><pre> <code class="bash hljs">2013/06/02-17:33:27 Starman::Server (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Net::Server::PreFork) starting! pid(4430) Resolved [*]:8080 to [::]:8080, IPv6 Not including resolved host [0.0.0.0] IPv4 because it will be handled by [::] IPv6 Binding to TCP port 8080 on host :: with IPv6 Setting gid to <span class="hljs-string"><span class="hljs-string">"1000 1000 4 24 27 30 46 107 125 1000 1001"</span></span> AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 23.</code> </pre><br><br>  If we run the application with three workers, we will see the following picture in STDERR: <br><br><pre> <code class="bash hljs">AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 23. AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 23. AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 23.</code> </pre><br><br>  By making a request to localhost: 8080 /, you can easily make sure that nothing new in STDERR has appeared. <br><br>  The following conclusions can be drawn: <br><br>  This action <b>will be</b> performed at the start of the application.  This is true both for the start of the script and for the builder section, if any. <br>  This action <b>will not be</b> performed when querying the server. <br>  Starman workflows start sequentially. <br>  This makes it possible to construct heavy objects both at the start of the script and in the builder part. <br><br>  Now add another warning to the code of the following form: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'REQUEST'</span></span>;</code> </pre><br><br>  And we bring the application to the following form: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'AFTER IMPORT'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'body'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body2</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'REQUEST'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;body(body()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'IN BUILDER'</span></span>; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $app }; };</code> </pre><br><br>  Now run the application with one workflow (starman --port 8080 --workers 1 app.psgi).  So far, nothing has changed: <br><br><pre> <code class="bash hljs">AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 24.</code> </pre><br><br>  But it is worth making a request, as in STDERR a new entry will appear. <br><br><pre> <code class="bash hljs">REQUEST at /home/noxx/perl/psgi/app.psgi line 16.</code> </pre><br><br>  Summarize.  With each request to the starman, only the code of the application itself will be executed (it is worth remembering return sub ...), but this code will not be executed at the start. <br><br>  And now, let's say, one process fell.  Add the following line to the return sub ...: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"DIED"</span></span>);</code> </pre><br><br>  As a result, you should get the following application: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'AFTER IMPORT'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'body'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body2</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'REQUEST'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;body(body()); <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"DIED"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'IN BUILDER'</span></span>; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $app }; };</code> </pre><br>  Run the application with one workflow, make a request.  The application naturally falls.  But the result is curious, although it is logical.  The application did not fall, only two notifications appeared in STDERR: <br><br><pre> <code class="bash hljs">REQUEST at /home/noxx/perl/psgi/app.psgi line 16. DIED at /home/noxx/perl/psgi/app.psgi line 21.</code> </pre><br><br>  Now replace die ('DIED');  at exit 1;  Run Starman, make a request to localhost: 8080 /.  Now the workflow has fallen.  This can be seen in STDERR, which will now look like this: <br><br><pre> <code class="bash hljs">REQUEST at /home/noxx/perl/psgi/app.psgi line 16, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 7. AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 8. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 26, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 8.</code> </pre><br><br>  After each request, the workflow will fall, but the master process will raise it. <br><br>  Let's leave Starman for a while.  Let's try to run this application, for example, under Twiggy.  If this server is not installed, then it's time to install it.  The package is called Twiggy. <br><br>  After installing Twiggy, launch our application with the following command: <br><pre> <code class="bash hljs">twiggy --port 8080 app.psgi</code> </pre><br><br>  And make a request.  Everything is like Starman, except for one feature.  The server has collapsed. <br><br><pre> <code class="bash hljs">noxx@noxx-inferno ~/perl/psgi $ twiggy --port 8080 app.psgi AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 26. REQUEST at /home/noxx/perl/psgi/app.psgi line 16, &lt;&gt; line 5. noxx@noxx-inferno ~/perl/psgi $</code> </pre><br><br>  Of course, this is because Twiggy lacks a master process and there is no one to lift the fallen worker.  And now it follows a very important point that must be taken into account.  Before restarting the server, you must make sure that its code is correct and does not contain syntax errors.  If you try to start an application that contains an error using Starman, several events will occur in the following order: <br><br><ul><li>  Starman will launch a master process, check if it can start workflows. </li><li>  Starman will launch workflows and submit the application code for execution. </li><li>  Workflows begin to fall, and the master will begin to raise them. </li><li>  The load increases incredibly and in a very short amount of time. </li></ul><br><br>  Execution errors are not so critical.  Remove falls from the application, bringing it almost to the initial form: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Builder; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Plack::Request; <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'AFTER IMPORT'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'body'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body2</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'REQUEST'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $env = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $req = Plack::Request-&gt;new($env); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $req-&gt;new_response(<span class="hljs-number"><span class="hljs-number">200</span></span>); $res-&gt;body(body()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $res-&gt;finalize(); }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $main_app = builder { <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> <span class="hljs-string"><span class="hljs-string">'IN BUILDER'</span></span>; mount <span class="hljs-string"><span class="hljs-string">"/"</span></span> =&gt; builder { $app }; };</code> </pre><br>  And we will try to do the following exactly in this order: <br><ul><li>  We give the application to the initial form. </li><li>  Run it with Starman. </li><li>  Make a request. </li><li>  Change the application code and save it. </li><li>  <b>Without restarting the application, we</b> will make a request for it again. </li></ul><br>  Result: <br><br><pre> <code class="bash hljs">curl localhost:8080/ body</code> </pre><br>  Save the application, change the body function.  Let now, for example, it returns nobody.  We make a request - the result, if we did not restart the server, the following: <br><pre> <code class="bash hljs">curl localhost:8080/ body</code> </pre><br>  But it is necessary to make a restart, how things change: <br><br><pre> <code class="bash hljs">curl localhost:8080/ nobody</code> </pre><br><br>  Another important conclusion.  In order for the application to be updated, changing the files is not enough.  You must restart the server.  Or send a special signal to the master process. <br><br><h2>  Starman and signals </h2><br>  Imagine that we have a large PSGI application, which cannot be stopped, because  we have quite heavy libraries that are loaded into memory for, say, ten seconds. <br><br>  Repeat the previous chain of actions, but with one change.  Add sending signals. <br><br>  The signal that tells Starman to reread is SIGHUP. <br><br>  The command to send this signal looks like this: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -s SIGHUP [pid]</code> </pre><br>  You can get the pid value with the following command: <br><br><pre> <code class="bash hljs">ps uax | grep starman | grep master</code> </pre><br><br>  Example command output: <br><br><pre> <code class="bash hljs">noxx 6214 0.8 0.1 54852 10288 pts/3 S+ 19:17 0:00 starman master --port 8080 --workers 1 app.psgi</code> </pre><br>  pid = 6214. <br><br>  We check the request-response.  Replace nobody back with body and run the application. <br><br>  Result: <br><pre> <code class="bash hljs">curl localhost:8080 body <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -s SIGHUP 6214 curl localhost:8080 nobody</code> </pre><br>  In the meantime, in STDERR Starman we can see the following: <br><br><pre> <code class="bash hljs">AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 24. REQUEST at /home/noxx/perl/psgi/app.psgi line 16. Sending children hup signal AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 2. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 24, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 2. REQUEST at /home/noxx/perl/psgi/app.psgi line 16, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 2.</code> </pre><br>  Thus, there are two ways to update a PSGI application.  Which one to choose depends on the task. <br><br>  Suppose you need another workflow.  It can be added in two ways.  Restart the server with the required parameter (--workers) or send a signal.  The signal for adding one workflow is TTIN, for deletion - TTOU.  If we want to stop the server completely safely, we can use the QUIT signal. <br><br>  So.  Run our application with one workflow: <br><pre> <code class="hljs pgsql">starman <span class="hljs-comment"><span class="hljs-comment">--port 8080 --workers 1</span></span></code> </pre><br><br>  Then add two processes by running the following command twice: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -s TTIN 6214</code> </pre><br><br>  Starman process list: <br><br><pre> <code class="bash hljs">noxx 6214 0.0 0.1 54852 10304 pts/3 S+ 19:17 0:00 starman master --port 8080 --workers 1 app.psgi noxx 6221 0.0 0.1 64724 13188 pts/3 S+ 19:19 0:00 starman worker --port 8080 --workers 1 app.psgi noxx 6233 0.0 0.1 64476 12872 pts/3 S+ 19:26 0:00 starman worker --port 8080 --workers 1 app.psgi noxx 6239 2.0 0.1 64480 12872 pts/3 S+ 19:29 0:00 starman worker --port 8080 --workers 1 app.psgi</code> </pre><br>  In STDERR already familiar: <br><br><pre> <code class="bash hljs">AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 4. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 24, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 4. AFTER IMPORT at /home/noxx/perl/psgi/app.psgi line 7, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 4. IN BUILDER at /home/noxx/perl/psgi/app.psgi line 24, &lt;<span class="hljs-variable"><span class="hljs-variable">$read</span></span>&gt; line 4.</code> </pre><br><br>  Then we remove one process: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -s TTOU 6214</code> </pre><br><br>  We can see that the team had an effect by looking at the process list: <br><pre> <code class="bash hljs">noxx 6214 0.0 0.1 54852 10304 pts/3 S+ 19:17 0:00 starman master --port 8080 --workers 1 app.psgi noxx 6221 0.0 0.1 64724 13188 pts/3 S+ 19:19 0:00 starman worker --port 8080 --workers 1 app.psgi noxx 6233 0.0 0.1 64476 12872 pts/3 S+ 19:26 0:00 starman worker --port 8080 --workers 1 app.psgi noxx 6238 0.0 0.0 13584 936 pts/4 S+ 19:29 0:00 grep --colour=auto starman</code> </pre><br>  But in STDERR it will not be displayed. <br><br>  And now we complete the work of our application by sending it a QUIT signal. <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -s QUIT 6214</code> </pre><br>  The server writes to STDERR: <br><br><pre> <code class="bash hljs">2013/06/02-19:32:15 Received QUIT. Running a graceful shutdown Sending children hup signal 2013/06/02-19:32:15 Worker processes cleaned up 2013/06/02-19:32:15 Server closing!</code> </pre><br><br>  And completes the job. <br><br>  That's all you need to know about Starman in order to start working with it. <br><br>  There is one more important detail.  When you start Starman, you can specify the required module for loading through the master process using the -M key.  But then the following restriction begins to work.  Modules loaded via -M (-MDBI -MDBIx :: Class) will not be re-read with SIGHUP. <br><br>  Another useful server option is -I.  It allows you to specify the path to Perl modules before starting the master process.  Starman also knows how to work with Unix sockets, but this opportunity will be discussed in more detail in future articles, starting with the article on deploying and administering Plack. <br><br>  And finally, the -E flag, which sets the environment variable (PLACK_ENV) to the passed state. <br><br>  The next article will be devoted to the asynchronous PSGI-server - Twiggy. <br><br>  <a href="http://pragmaticperl.com/authors/6">Dmitry Shamatrin</a> </div><p>Source: <a href="https://habr.com/ru/post/248283/">https://habr.com/ru/post/248283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248269/index.html">We build a backdoor in the RSA public key</a></li>
<li><a href="../248271/index.html">Electronic signature on Russian regulations: practical use in enterprises</a></li>
<li><a href="../248273/index.html">Unity UI in version 4.6</a></li>
<li><a href="../248279/index.html">Practice "Intel IoT". Galileo Gen2 - First dating</a></li>
<li><a href="../248281/index.html">Zoho CRM. Overview</a></li>
<li><a href="../248285/index.html">Free https certificate + integration into Apache ‚Äì TomCat</a></li>
<li><a href="../248287/index.html">Critical Vulnerability in PolarSSL</a></li>
<li><a href="../248289/index.html">Smart alarm clock for smart home</a></li>
<li><a href="../248291/index.html">Grape: no single rails, part 2</a></li>
<li><a href="../248293/index.html">The digest of interesting materials from the world of Drupal # 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>