<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Own implementation of https using crypto ++ for I2P bootstrapping</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Each new I2P node should first get an initial list of nodes from where it first starts. To do this, there are special servers (reseed), the addresses ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Own implementation of https using crypto ++ for I2P bootstrapping</h1><div class="post__text post__text-html js-mediator-article">  Each new I2P node should first get an initial list of nodes from where it first starts.  To do this, there are special servers (reseed), the addresses of which are strictly written in the code.  Previously, the download was carried out on http, but more recently, reseed-s began to move to https.  For successful work <a href="http://habrahabr.ru/post/240815/">"purple" I2P</a> also required to make the appropriate changes.  The <a href="http://www.cryptopp.com/">crypto ++</a> cryptographic library used there does not support ssl.  Instead of using an additional library like openssl, which actually duplicates cryptography, the option described below was chosen. <br>  Boot is the only place in I2P where https is used. <br>  On the other hand, the article will be interesting to those who are interested in understanding how ssl works and try it yourself. <br><br><a name="habracut"></a><br><br><h4>  Inventing a bicycle </h4><br>  Our goal is to get an i2pseeds.su3 file of about 100K in size from one of the I2P reseed nodes.  This file is signed by a separate certificate independent of the site certificate, so certificate verification can be excluded.  The relatively short length of the received data allows us not to implement the mechanisms of compression and restoration of broken connections. <br>  Only <a href="https://tools.ietf.org/html/rfc5246">TLS 1.2</a> and the TLS_RSA_WITH_AES_256_CBC_SHA256 cipher suite will be used.  In other words, AES256 in CBC mode is used to encrypt data, and RSA is used for key negotiation. <br>  This choice is due to the fact that AES256-CBC is the most used encryption in I2P, and RSA to simplify the implementation of the protocol by reducing the number of messages required for key negotiation.  In addition to RSA and AES, the following cryptographic functions from crypto ++ are also required: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  HMAC for computing checksums of encrypted messages and pseudo-random functions.  Please note that the standard implementation of HMAC is used, not from I2P </li><li>  SHA256 hash for use with HMAC and for calculating the checksum of all messages involved in setting up a connection </li><li>  Functions for working with descriptions in the ASN.1 language in DER encoding.  Required to extract a public key from an X.509 certificate </li></ul><br><br>  The RSA implementation is based on PKCS v1.5.  The key length can be any and is determined by the certificate. <br><img src="https://habrastorage.org/files/909/ff7/848/909ff78485a2460bbe250b73282f1bfa.jpg"><br><br><h4>  SSL messaging </h4><br>  Absolutely all transmitted messages begin with a 5-byte header, the first byte of which contains the message type, the next 2 bytes ‚Äî the protocol version number (0x03, 0x03 for TSL 1.2) and then the length of the rest (content) of the message ‚Äî 2 bytes in Big Endian, most defining message boundaries. <br>  Thus, when receiving new data, you should first read 5 bytes of the header, and then how many bytes are in the length field. <br>  There are 4 types of messages: <br><ol><li>  0x17 - data.  The content is encrypted HTTP messages, and in our case using AES256, the key of which is calculated during the connection setup process.  Data size must be a multiple of 16 bytes. </li><li>  0x16 - set the connection.  Multiple types defined by the corresponding field inside the content.  Unencrypted, with the exception of the message 'finished', sent last. </li><li>  0x15 is a warning.  The message that "something went wrong."  Close the connection.  Contains codes of what exactly went wrong, you can use for debugging. </li><li>  0x14 - change cipher.  It is sent immediately after the key is negotiated.  Content is 1 byte, always containing 0x01.  In fact, it is part of the connection setup process. </li></ol><br><br>  In our implementation, the encrypted data is as follows: <br>  16 bytes IV for CBC, in TSL 1.2 for each message own IV; <br>  data length up to 64K is the length of the headers; <br>  32 MAC bytes, calculated for a 13-byte header and data, the header consists of an 8-byte sequence number starting with zero, message type (0x17 or 0x16), version and data length.  All in BigEndian.  The key for HMAC is also calculated during the connection setup process; <br>  a placeholder, so that the length of the encrypted data is a multiple of 16 bytes, the last byte contains the number of bytes of the placeholder, not taking into account itself.  If the message length is a multiple of 16 bytes, then another 16 bytes will be added for this last byte with a length. <br><br><h4>  Connection setup </h4><br>  During the installation process, we must solve two problems: <br><ol><li>  Coordinate and calculate encryption keys and HMAC </li><li>  Send the correct sequence of messages so that the other side does not close the connection, but goes into the data exchange mode. </li></ol><br><br>  In our case, the sequence of messages is as follows: <br>  ClientHello -&gt; (0x01) <br>  &lt;- ServerHello (0x02) <br>  &lt;- Certificate (0x0B) <br>  &lt;- ServerHelloDone (0x0E) <br>  -&gt; ClientKeyExchange (0x10) <br>  -&gt; ChangeCipherSpec <br>  -&gt; Finished (0x14) <br>  &lt;- ChangeCipherSpec <br>  &lt;- Finished (0x14) <br>  where "-&gt;" means sending a message, and "&lt;-" means receiving. <br>  All messages, except for ChangeChiperSpec, are a message of the type 0x16 - connection establishment.  The content of this type of message begins with its own 4-byte header, the first byte of which is the type of the connection setup message, as indicated above, and 3 bytes of the length of the remaining message, the highest byte of which in our case is always zero. <br>  Consider these messages in detail. <br><br><h5>  Clienthello </h5><br>  The first message that we send to the server after a successful connection.  Since we use one particular set of ciphers, in our case it will be permanent.  Here it is: <br><pre><code class="hljs ruby">static uint8_t clientHello[] = { <span class="hljs-number"><span class="hljs-number">0x16</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> handshake <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> version (TLS <span class="hljs-number"><span class="hljs-number">1.2</span></span>) <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x2F</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> length of handshake /<span class="hljs-regexp"><span class="hljs-regexp">/ handshake 0x01, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ handshake type (client hello) 0x00, 0x00, 0x2B, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ length of handshake payload /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ client hello 0x03, 0x03, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ highest version supported (TLS 1.2) 0x45, 0xFA, 0x01, 0x19, 0x74, 0x55, 0x18, 0x36, 0x42, 0x05, 0xC1, 0xDD, 0x4A, 0x21, 0x80, 0x80, 0xEC, 0x37, 0x11, 0x93, 0x16, 0xF4, 0x66, 0x00, 0x12, 0x67, 0xAB, 0xBA, 0xFF, 0x29, 0x13, 0x9E, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 32 random bytes 0x00, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ session id length 0x00, 0x02, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ chiper suites length 0x00, 0x3D, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ RSA_WITH_AES_256_CBC_SHA256 0x01, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ compression methods length 0x00, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ no compression 0x00, 0x00 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ extensions length };</span></span></code> </pre> <br><br>  This message tells the server that we support TLS 1.2, this new connection (the length of the session identifier is zero) and support a single cipher suite - RSA with AES256.  We also send a set of 32 "random" bytes for key generation.  If these bytes are really random, then they should be remembered somewhere, because they will be needed later. <br><br><h5>  Serverhello </h5><br>  The ‚Äútwin brother‚Äù is ClientHello, except that the message type is 0x02 instead of 0x01, and a non-empty session identifier.  From this message, we need only 32 random bytes. <br><br><h5>  Certificate </h5><br>  It may contain several certificates, first comes the length of the entire group of certificates, then each certificate has its own length.  We are only interested in the first certificate and read the length should be 2 times.  The certificate itself is X.509 in DER encoding.  From it, we need the RSA public key. <br><br><h5>  ServerHelloDone </h5><br>  It does not contain anything useful, but is taken into account when calculating a hash for Finished. <br><br><h5>  ClientKeyExchange </h5><br>  At this point, we have enough information to generate and reconcile the keys that occur in 3 stages: the generation of a random secret key, the master key calculation, the master key extension to obtain the encryption keys and the checksum. <br>  The random secret key is 48 bytes, the first 2 of which are the version number (0x03, 0x03), and the remaining 46 are randomly generated.  Further, these 48 bytes are encrypted with the RSA public key, and together with the length of the encrypted block are sent to the server.  It should be noted that the length of the encrypted block will be equal to the key length, and not 48 bytes.  For example, for certificates with a 2048-bit key, this length will be 256, and the length of the transmitted data will be 258. <br><br><h5>  ChangeCipherSpec </h5><br>  Dispatched immediately after ClientKeyExchange.  Always the same: <br><pre> <code class="hljs ruby">static uint8_t changeCipherSpecs[] = { <span class="hljs-number"><span class="hljs-number">0x14</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> change cipher specs <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-number"><span class="hljs-number">0x03</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> version (TLS <span class="hljs-number"><span class="hljs-number">1.2</span></span>) <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> length <span class="hljs-number"><span class="hljs-number">0x01</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ type };</span></span></code> </pre><br>  This message is of type 0x14 and hash calculation for Finished is not involved. <br><br><h5>  Pseudo-random function (PRF) </h5><br>  To further calculate the keys, we need a pseudo-random function that accepts 4 parameters at the input: the secret key just sent to the server, a label in the form of a text string, a block of initial data and the desired length of the result. <br>  In TLS 1.2, it is defined as follows: <br>  PRF (secret, label, seed) = P_SHA256 (secret, label + seed); <br>  P_SHA256 (secret, seed) = HMAC_SHA256 (secret, A (1) + seed) + <br>  HMAC_SHA256 (secret, A (2) + seed) + <br>  HMAC_SH256 (secret, A (3) + seed) + ... <br>  where A is determined by induction <br>  A (0) = seed, <br>  A (i) = HMAC_SHA256 (secret, A (i -1)). <br>  That is, at each step we recalculate the checksum from the previous step, and then we calculate the checksum from combining the result with the text string and the original data, repeating this until the desired length is obtained. <br><br>  Now the master key is calculated by the formula <br>  PRF (secret, "master secret", clientRandom + serverRadom, 48); <br>  where clientRandom is 32 random bytes from ClientHello, and serverRandom is from ServerHello. <br>  Then it should be expanded to a 128-byte block, containing 4 32-byte keys in the following sequence: a MAC key for sending, a MAC key for receiving, an encryption key for sending, a decryption key for receiving. <br>  MAC key for receiving is not used. <br>  Key expansion is made according to the formula <br>  PRF (masterSecret, "key expansion", serverRandom + clientRadom, 128) <br>  clientRadom and serverRadom change places here. <br><br><h5>  Finished </h5><br>  At this point, we have everything we need to start the data exchange, but, unfortunately, we have to send a Finished message containing the correct data, otherwise the server will break the connection. <br>  If all the previous posts were rather trivial, then Finshed is more complicated.  Firstly, it is of type 0x16, but its contents are completely encrypted, while 0x16 also appears in the calculation of the checksum, and not 0x17 as for other encrypted messages. <br>  The message itself contains the first 12 bytes from <br>  PRT (masterSecret, "client finished", hash, 12) <br>  where hash is SHA256 from the following sequence of messages: <br>  ClientHello, ServerHello, Certficate, ServerHelloDone, ClientKeyExchange.  All messages are counted without a 5 byte header. <br>  If the message is generated correctly, the server will respond with ChangeCipherSpec and Finished, otherwise with an error message. <br>  After that, we server is ready for data exchange and we send our HTTP request and receive a response. <br><br><h4>  findings </h4><br>  The approach considered in the article allows you to work effectively with https for applications that do not require its full implementation.  Instead of third-party implementations of ssl, which pull their own cryptography, you can use those already present in the project, as shown in the example of crypto ++, which reduces the number of dependencies, improves support and portability. <br>  Implemented and used in almost <a href="https://github.com/PurpleI2P/i2pd">i2pd</a> - C ++ I2P implementation </div><p>Source: <a href="https://habr.com/ru/post/251143/">https://habr.com/ru/post/251143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251127/index.html">International exhibition "EuroCIS-2015". Live twitter feed</a></li>
<li><a href="../251131/index.html">Java EE, JCA and jNode 2.X announce</a></li>
<li><a href="../251133/index.html">CxxMock - principle of operation</a></li>
<li><a href="../251137/index.html">We write a bot for MMORPG with assembler and draenei. Part 0</a></li>
<li><a href="../251141/index.html">Another software UART on ATtiny13</a></li>
<li><a href="../251149/index.html">We write a bot for MMORPG with assembler and draenei. Part 1</a></li>
<li><a href="../251155/index.html">Creating MMC Management Console</a></li>
<li><a href="../251157/index.html">The most needed plugins for Grunt</a></li>
<li><a href="../251161/index.html">Introduction to the course "Image and video analysis". Lectures from Yandex</a></li>
<li><a href="../251163/index.html">About Intel Hyper-Threading and Virtual Machine Performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>