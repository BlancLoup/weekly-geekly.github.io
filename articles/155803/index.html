<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UDP hole punching for Symmetric NAT: a bit of theory and an almost honest experiment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, colleagues. 

 Some time ago I became interested in a subject. The search gave a lot of material, while studying which a number of questions...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UDP hole punching for Symmetric NAT: a bit of theory and an almost honest experiment</h1><div class="post__text post__text-html js-mediator-article"> Good day, colleagues. <br><br>  Some time ago I became interested in a subject.  The search gave a lot of material, while studying which a number of questions arose and I wanted to check some theoretical points in practice.  Who cares - please. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For those who are not in the subject briefly about what Symmetric NAT is. <br><br>  Consider a simple scheme in which <br><br>  host1, host2 - user hosts for NATs <br>  NAT1, NAT2 - border devices providing NAT <br><br>  When host1 initiates an outgoing connection (TCP or UDP) with a real_IP, the NAT1 device replaces the source IP in its outgoing packet with its own (not necessarily its own, but accept it for simplicity and clarity), and also generally replaces PORT_SRC with a random PORT_SRC1. <br><br>  <b>host1 ____ PORT_SRC, PORT_DST ---&gt; device NAT1 PORT_SRC1, PORT_DST ----&gt; real_IP</b> <br><br>  So, NAT will be symmetrical if the host_real_IP response packet is passed by the NAT1 device if and only if the source‚Äôs actual IP in such a reply packet is real_IP, the source port is PORT_DST, and the destination port is PORT_SRC1.  That is, real_IP will respond from its address, from the same port that it was connected to, and to the same port from which there was an outgoing connection from the NAT1 device.  It is not difficult to notice that the term ‚Äúsymmetry‚Äù was not in vain here. <br><br>  What do we have when the task is to ‚Äúbreak through‚Äù symmetric NAT and allow the hosts to communicate directly with it? <br><br>  In general, we have the following simple schema. <br><br>  <b>host1 ----&gt; NAT1</b> SRC1_ random, DST1_the wish ----&gt; <br><br>  &lt;- DST2_health, SRC2_ <b>random NAT2 &lt;- host2</b> <br><br>  SRC1_s chance - the source port after NAT substitution by the NAT1 device; <br>  DST1_by_ wish ‚Äî the destination port for an outgoing connection established from host1 through NAT1 can be chosen by us; <br>  DST2_to_ wish ‚Äî the destination port for a packet sent from host2 through NAT2 to NAT1 can be chosen by us; <br>  SRC2_incident - source port after NAT substitution by NAT2 device. <br><br>  If you look closely at this schema, the difficulties for the "breakdown" are obvious.  In order for traffic exchange to occur, the following must be done: SRC1_slip = DST2_glove and DST1_glove = SRC2_slip. <br>  The host1 and host2 devices cannot control the SRC1_cause and SRC2_cord ports.  In general, they will be really random, plus depending on the destination IP and the destination port.  The mass of materials found by the search on this topic ignored this simple fact, considering that a simple STUN server is enough to find out these unknowns. <br>  Like, yes.  If you take NAT, organized with, say, iptables, then constructions like <br><br>  -t nat -A POSTROUTING -j MASQUERADE <br>  or <br>  -t nat -A POSTROUTING -j SNAT --to-source <br><br>  will only replace the source IP, the outgoing port will remain the same as on the client.  Thus, the task is greatly simplified and the mass of articles describing the role of an intermediary for this NAT traversal technology begin to hit the mark. <br>  But this is a private and simple case. <br><br>  For the same iptables, these structures can be replaced by <br><br>  -t nat -A POSTROUTING -j MASQUERADE ... --random <br>  or <br>  -t nat -A POSTROUTING -j SNAT --to-source ... --random <br><br>  and the situation will be less fun.  The outgoing port will start to be selected when the NAT translation is random. <br><br>  Total, after a careful look at the schematic above, we have the following problems. <br><br>  Neither host1 nor host2 is aware of SRC1_cause and SRC2_cause, they can only influence them indirectly, for example, changing the source port for their outgoing packets or sufficient timeout between sending data so that NAT records on NAT-devices have time to become obsolete and reset. . <br>  Host2 should, among other things, find out DST1_the_willingness (in general, the port can be agreed upon in advance, but we will consider the worst option). <br><br>  Without going into long explanations of the need for an intermediary, I will set forth at once an approximate algorithm for the actions of all participants in the exchange. <br><br>  1. A mediator is strictly necessary with which host1 and host2 establish full-fledged control connections with free two-way traffic.  Initiators of such control sessions are hosts for NAT.  The mediator distributes among the end hosts information about their white IPs. <br><br>  2. Suppose that host1 is the initiator of the target connection / client, and for host2 the connection will be incoming, that is, it will act as a server. <br><br>  3. Host1 starts sending packets to the real NAT2 address, choosing DST1_ according to wish arbitrarily. <br><br>  4. Host1 on the control connection informs the broker about the selected DST1_ according to the wish and continues to send packets with the same parameters (source port, destination port) to maintain constant broadcast on NAT1 so that SRC1_ does not change.  The delay between shipments can be determined experimentally, due to the triviality of the task I do not schedule it and do not include it in this text. <br><br>  5. The broker scans NAT1, replacing the source IP address with the NAT2 address, providing the source port DST1_wheel and sorting out the destination port in the range from 1024 (or the entire range of 65535?) And above.  All this is necessary, because we decided earlier that NAT is not for nothing called symmetric. <br>  When, as a result of busting (if we are not banned by NAT1 by this time), we finally send a packet with the destination port SRC1_accidental, then such a packet, if any particularly tricky protection mechanisms that go beyond the NAT functionality, do not interfere with the host1 .  What he detects and further on the control channel will notify the intermediary, and he will remember the guessed value SRC1_ random. <br><br>  6. The intermediary reports on the control channel to the host2 SRC1_sluggish. <br><br>  7. Host2 starts sending packets to the external address NAT1, the destination port in these packets should be DST2_ wish = SRC1_ random.  It will be forced to do this until the SRC2_s chance, chosen by the NAT2 device, matches DST1_growth. <br>  When this long-awaited coincidence happens, two options are possible. <br>  The first.  This package will reach the host1, he will notify the intermediary, the intermediary will notify the host2 and the ‚Äúhappy‚Äù session will continue. <br>  Second.  Host2, not wanting to annoy NAT1 once again with ‚Äúswotting‚Äù, changed IP-ttl in its outgoing packets to such a value that they would pass through NAT2, but did not reach NAT1.  In this case, translations to NAT2 are created, packets do not reach NAT1, but when the cherished broadcast is created, the packet from host1 (and we did not forget that it supports its broadcast with the previously described, namely, ‚Äúdolbytsya‚Äù on NAT2 with constant parameters) will reach host2, and that one in turn will notify the intermediary and so on. <br><br>  As you can see, in the general case, the breakdown of symmetric NAT is not such an easy and quick task.  On those or other implementations (recalling iptables), it can be significantly simplified and turned into a procedure with guaranteed success, but, I repeat, not in the general case. <br>  What are the "bottlenecks" of the described algorithm? <br><br>  1. The need for spoofing in clause 5. The mediator should have a way to access the network that would allow it and not get problems from the provider. <br><br>  2. Scanning a large range of ports in step 5. Let me repeat again, in the case of a ‚Äúcorrect‚Äù NAT, you cannot host1 simply connect to an intermediary and assume that SRC1_specific in the case of a connection to NAT2 will be the same, all other things being equal.  Changing the destination address will result in a change of SRC1_ random.  Scan, of course, can be done fairly quickly and aggressively, you can be careful, but longer.  In any case, this is a weak point. <br><br>  3. The steps in clause 7 may be indefinitely long.  Just this moment caused my curiosity and desire to try. <br><br>  4. And of course, someone who is tired of reading so many letters can say: ‚ÄúI need it, drive all the target traffic through an intermediary and that's it!‚Äù.  It is certainly difficult to argue here, I apologize to those for the time taken by this text. <br><br>  Now to practice.  Perhaps I will disappoint those who are interested in the topic, but I did not write a mediator :) In his role tcpdump played in the right place at the right time, as well as the author‚Äôs eyes and hands :) But I did get some interesting results. <br><br>  So.  We have a screw workstation with 3G = host1.  On the modem connection, the gray address was 10.140.80.130.  This is the internal address of the host1 behind NAT. <br>  We have an AT AR-750s router with a white address xx.xx.xx.xx and host2 directly behind this router. <br>  Choose arbitrary DST1_ according to wish, in my case it was equal to 21393. <br>  We start at intervals of 10 seconds from host1 to send UDP packets to xx.xx.xx.xx: 21393. <br>  Passing the malicious scan stage, we convey ‚Äúsecretly‚Äù information about port 21393 to host2, as well as ‚Äúspied on‚Äù information that SRC1_ is random for the NAT of the cellular operator, we have 45499 (well, IP, from which we are NAT-i-world-wide too = yy.yy.yy.yy). <br>  Starting with host2, we start ‚Äúdolby‚Äù on yy.yy.yy.yy: 45499 and wait for us to get lucky and our outgoing packet will receive the source port for NAT that is 21393. .  The packet generation rate from host2 was ~ 5 packets per second.  At the same time, the NAT2 router was slightly loaded with outsiders (users would hear it) with traffic. <br>  The first "breakdown" happened about 8 hours after the start of the experiment.  Then a few more of them happened, since all this household was left to work at night.  Subsequent began to occur more quickly several times, here you can fantasize about the impact of "outsider" traffic. <br><br>  Here's what the "breakdown" looked like.  The output is selective, which includes only the "happy" packets with the necessary coincidence. <br><br>  The output of the sniffer in the ‚Äútricky‚Äù traffic pick-up point, where it (traffic) is visible already after the NAT on the external interface of the AR-750 router <br><br>  02: 19: 05.060809 IP xx.xx.xx.xx.21393&gt; yy.yy.yy.yy.45499: UDP, length 0 <br>  05: 07: 00.178149 IP xx.xx.xx.xx.21393&gt; yy.yy.yy.yy.45499: UDP, length 0 <br>  06: 28: 35.355623 IP xx.xx.xx.xx.21393&gt; yy.yy.yy.yy.45499: UDP, length 0 <br>  07: 16: 29.764069 IP xx.xx.xx.xx.21393&gt; yy.yy.yy.yy.45499: UDP, length 0 <br>  11: 28: 06.899109 IP xx.xx.xx.xx.21393&gt; yy.yy.yy.yy.45499: UDP, length 0 <br><br>  The output of a sniffer on host1, in which a breakdown is ‚Äúdetected‚Äù (time is not synchronized, hence some discrepancy between time stamps and printout from the traffic dump of host2). <br><br>  02: 18: 20.480468 IP xx.xx.xx.xx.21393&gt; 10.140.80.130.2429: UDP, length 0 <br>  05: 06: 15.496093 IP xx.xx.xx.xx.21393&gt; 10.140.80.130.2429: UDP, length 0 <br>  06: 27: 50.464843 IP xx.xx.xx.xx.21393&gt; 10.140.80.130.2429: UDP, length 0 <br>  07: 15: 44.839843 IP xx.xx.xx.xx.21393&gt; 10.140.80.130.2429: UDP, length 0 <br>  11: 27: 21.589843 IP xx.xx.xx.xx.21393&gt; 10.140.80.130.2429: UDP, length 0 <br><br>  There was another result of the dump directly on host2, in which it was clear that the packets from point 4 to host2, which support constant broadcast on NAT1, began to reach, but I sowed it. <br><br>  Here is a not entirely honest experiment.  But he showed that even with a relatively low frequency of enumeration in paragraph 7, the desired result can be achieved in a relatively reasonable time.  It can become even more sensible with a more aggressive search.  Of course, the "industrial" application does not pull, but ... But it is possible.  The described algorithm and experiment gives food for thought on the topic of acceleration-optimization-multi-thread approach and so on. <br><br>  UPD: I forgot to mention that from host2 the packets were sent with the change of the source port, so that the source port would also change over NAT2, it‚Äôs too expensive to wait for the broadcast to NAT2 to die. </div><p>Source: <a href="https://habr.com/ru/post/155803/">https://habr.com/ru/post/155803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155779/index.html">Great outcome of IT & Media-people in Chiang Mai</a></li>
<li><a href="../155781/index.html">Mono 3.0</a></li>
<li><a href="../155785/index.html">Officially released Wayland 1.0 (replacement for X11)</a></li>
<li><a href="../155791/index.html">Cognitive education: from mastering to cognition. From engineers to cognitaria</a></li>
<li><a href="../155801/index.html">ASUS PadFone 2</a></li>
<li><a href="../155807/index.html">Mobile Professional Days in Kharkov</a></li>
<li><a href="../155811/index.html">JRuby 1.7.0 release</a></li>
<li><a href="../155813/index.html">The developers of ‚ÄúMamba‚Äù at the HighLoad ++ 2012 conference</a></li>
<li><a href="../155815/index.html">Four function call patterns in javascript</a></li>
<li><a href="../155819/index.html">Oryol Prosecutor's Office does not leave the wiki alone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>