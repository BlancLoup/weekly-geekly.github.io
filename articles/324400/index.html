<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NSUserDefaults in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This text is a translation of the article NSUserDefaults In Practice . The original author is David Smith. The translation was made with the kind perm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>NSUserDefaults in practice</h1><div class="post__text post__text-html js-mediator-article">  This text is a translation of the article <a href="http://dscoder.com/defaults.html">NSUserDefaults In Practice</a> .  The original author is David Smith.  The translation was made with the kind permission of the author. <br><br><h2>  What is NSUserDefaults? </h2><br>  The comment that starts the header file ‚ÄúNSUserDefaults.h‚Äù describes the class quite well.  I will use this comment to start: <br><blockquote>  NSUserDefaults are: <br><br>  1) hierarchical <br>  2) permanent (persistent) <br>  3) interprocess <br>  4) and in some cases distributed <br>  repository type key value.  NSUserDefaults are optimized for storing user preferences. </blockquote><br><a name="habracut"></a><h3>  1) Hierarchical: </h3><br>  NSUserDefaults contain the list of data storage locations where they are looking for this data.  This list is called a ‚Äúsearch list‚Äù.  The ‚Äúsearch list‚Äù contains some arbitrary strings, called ‚Äúsuite identifiers‚Äù or ‚Äúdomain identifiers‚Äù.  When a request is received NSUserDefaults will check each item in its search list until they find the one that contains the key from the request, or until they have passed the entire list.  The list includes: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Managed ("forced") settings set by a configuration profile or network administrator via MCX (Managed Client for OS X - Managed Client OS X) </li><li>  Command line arguments </li><li>  Settings for the current domain in the cloud </li><li>  Settings for the current domain, current user, on the current host </li><li>  Settings for the current domain, current user, on any host </li><li>  Settings added by <i>-addSuiteNamed:</i> </li><li>  Global settings for all applications of the current user, on the current host </li><li>  Global settings for all applications of the current user, on any host </li><li>  Settings for the current domain, for all users, on the current host </li><li>  Global settings for all applications of all users on the current host </li><li>  Settings registered via <i>-registerDefaults:</i> </li></ul><br>  Note: ‚Äúcurrent host + current user‚Äù settings are not implemented on iOS, watchOS, and tvOS, and ‚Äúfor any user‚Äù settings basically do not give anything to applications on these operating systems. <br><br><h3>  2) Permanent (persistent): </h3><br>  Settings stored in NSUserDefaults are persistent between reloads and application restarts, unless otherwise specified. <br><br><h3>  3) Inter-Process: </h3><br>  Settings can be available for reading / writing from several processes simultaneously (for example, from an application and its extension). <br><br><h3>  4) In some cases distributed: </h3><br>  At the moment, there is support only in Shared iPad for students (Apple program <a href="http://www.apple.com/education/it/">www.apple.com/education/it</a> - approx. Transl.). <br><br>  The data stored in NSUserDefaults can be made distributed ("ubiqitous" - approx. Transl.), I.e.  synchronizing between devices via the cloud.  Distributed ‚Äúuser settings‚Äù are automatically transferred to all devices logged into one iCloud account.  When reading settings (via calling methods of the form <i>- * ForKey:),</i> distributed settings are checked before local ones.  All operations with distributed settings are asynchronous.  Thus, if the download from iCloud is not complete, then the registered settings can be returned, instead of distributed.  Distributed settings are set in the application's Confaults Configuration File. <br><br><h3>  Key-value storage: </h3><br>  NSUserDefaults store property list objects (plist files): NSString, NSData, NSNumber, NSDate, NSArray, and NSDictionary ‚Äî identified by keys of the NSString type.  This is similar to the work of NSMutableDictionary. <br><br><h3>  Optimized to store user settings: </h3><br>  NSUserDefaults are designed to store relatively small amounts of data that are often requested and rarely modified.  Other uses may result in slower work or more memory consumption than more suitable solutions. <br><br>  In CoreFoundation, the CFPreferences functions containing ‚ÄúApp‚Äù in their names work with the same search lists as NSUserDefaults.  Observing NSUserDefaults using the KVO (Key-Value Observing) mechanism is possible for any key stored in them.  When monitoring changes from other processes or devices, using the NSKeyValueObservingOptionPrior does not affect KVO behavior. <br><br><h2>  Basics NSUserDefaults: 99% </h2><br>  Under normal circumstances, NSUserDefaults are extremely simple. <br><br><h3>  Reading settings from NSUserDefaults: </h3><br>  If there is a setting that controls some of the code, you simply call the appropriate getter method ( <i>-objectForKey:</i> or one of the wrapping methods for a particular type). <br>  If you find that you need to do something else to get the setting, you should take a step back and weigh it all over again: <br><br><ol><li>  Caching values ‚Äã‚Äãfrom NSUserDefaults is usually not necessary, since reading is already extremely fast. </li><li>  Calling <i>-synchronize</i> before reading the value is not necessary in any situations. </li><li>  Actions in response to a change in value are almost never needed, since the purpose of any settings is to control what the program does, and not to force it to act. </li><li>  Writing code to handle the ‚Äúvalue not set‚Äù case is also not generally necessary, since you can register a default value (see <a href="https://habr.com/ru/post/324400/">Registering default values</a> below). </li></ol><br><h3>  Saving user settings in NSUserDefaults </h3><br>  Similarly, when a user changes a setting, you simply call <i>-setObject: forKey:</i> (or one of its type-specific wrappers). <br><br>  If it turns out that you need something else, then again, it probably is not necessary.  Almost never call <i>-synchronize</i> after setting a value (see below. <a href="https://habr.com/ru/post/324400/">Splitting settings between programs</a> ).  And users are usually not able to change settings so quickly that ‚Äúbundling‚Äù of any kind would be beneficial for performance.  Real disk writing is asynchronous, and NSUserDefaults merge changes into a single write operation automatically. <br><br><a name="register_default_value"></a><h3>  Default logging </h3><br>  It may seem tempting to write code like: <br><br><pre><code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) applicationDidFinishLaunching:(<span class="hljs-built_in"><span class="hljs-built_in">NSApplication</span></span> *)app { <span class="hljs-built_in"><span class="hljs-built_in">NSUserDefaults</span></span> *defaults = [<span class="hljs-built_in"><span class="hljs-built_in">NSUserDefaults</span></span> standardUserDefaults]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![defaults objectForKey:<span class="hljs-string"><span class="hljs-string">@"Something"</span></span>]) { [defaults setObject:initialValue forKey:<span class="hljs-string"><span class="hljs-string">@"Something"</span></span>]; } }</code> </pre> <br>  But in the long term, it has a hidden flaw: if you ever want to change the initial value, you will not have a way to distinguish the value set by the user (which he would like to keep) and the initial value set by you (which you would like to change).  Also, doing so is kind of slow.  The solution is to use the <nobr><i>-registerDefaults</i></nobr> method <nobr>:</nobr> <nobr><br><br></nobr> <pre> <nobr><code class="objectivec hljs">[[<span class="hljs-built_in"><span class="hljs-built_in">NSUserDefaults</span></span> standardUserDefaults] registerDefaults:@{ <span class="hljs-string"><span class="hljs-string">@"Something"</span></span> : initialValue }];</code></nobr> </pre> <nobr><br></nobr>  <nobr>What has many advantages:</nobr> <nobr><br><br></nobr> <ul><li>  <nobr>Nothing is saved to disk here, so there will never be confusion with the value that the user has set.</nobr> </li><li>  <nobr>The registered value is automatically overridden by any value set by the user.</nobr>  <nobr>So</nobr>  <nobr>no need to wrap an if-ohm value setting to check if it needs to be done</nobr> </li><li>  <nobr>No writing to disk: there is no slowdown in the process of launching the application, there is no wear on the disk.</nobr> </li></ul> <nobr><br></nobr>  <nobr>The</nobr> <nobr><i>-registerDefaults:</i></nobr> <nobr>method</nobr> can be called as many times as needed.  And all key-value pairs from all the dictionaries transferred to it will be registered.  This gives you the opportunity to keep the registration settings next to the code that works with them. <br><br><a name="share_defaults"></a><h2>  Splitting settings between programs </h2><br>  One tricky moment, which nevertheless often occurs, is the need to share settings between several running processes, for example, between an application and its extension or between two or more applications (on macOS) <br><br>  In the old (good / bad) times, even before applications were put in sandboxes, everything was very simple: use <nobr><i>[[NSUserDefaults alloc] initWithSuiteName:]</i></nobr> with the same name in both processes, and these processes will share the same settings.  Terminological note: "domain" and "set name" are used interchangeably.  Both terms simply mean an arbitrary string that identifies the configuration store. <br><br>  In the world of sandboxes, in the world of modern macOS and all iOS NSUserDefaults are initially limited to working in the sandbox of your application.  If you use <nobr><i>-initWithSuiteName:,</i></nobr> then you get only a new storage of settings, still indivisible.  To make it shared two things are needed: <br><br><ol><li>  Create a shared container to hold the settings. </li><li>  Use the identifier of this container as the set name, which is passed to NSUserDefaults when creating the set (using the <i>-initWithSuiteName:</i> method - comment <i>transl</i> .).  I will not go into details now, but <a href="https://developer.apple.com/library/content/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html">here</a> you can find relevant documentation.  As soon as you add an application or application extension to a group, the set with the name equal to the group identifier automatically becomes shared. </li></ol><br>  If one of the processes establishes a shared setting and then notifies the other process to read it, then you may be in one of those very rare situations where a call to the <nobr><i>-synchronize</i></nobr> method may be useful.  This is a blocking method.  It guarantees that after returning from it, reading the settings by any other process will return a new one, and not the old value.  For applications <nobr><i>running</i></nobr> on iOS 9.3 and later or on macOS Sierra and later, <nobr><i>-synchronize is</i></nobr> not needed (or recommended) even in the described situation.  Since KVO monitoring of settings now works between processes, the reading process can simply watch the value change directly. <br><br>  As a result, applications running on these operating systems generally should never invoke <nobr><i>-synchronize</i></nobr> . <br><br>  My main recommendation is to share as little of the settings as possible - simply because the code is easier to understand and maintain when the values ‚Äã‚Äãdo not change externally. <br><br>  Transactions in NSUserDefaults are not implemented, so there is no way to ensure that the results of several changes are readable all at once.  Another application may see the results of the first changes before the subsequent changes are completed. <br><br><h2>  Splitting settings between devices </h2><br>  Distributed (i.e., stored in iCloud) settings are now supported only in Shared iPad mode for training.  Therefore, they are outside the scope of this general discussion.  Currently, for distributed storage of data outside of training mode, you should not use NSUserDefaults, but NSUbiquitousKeyValueStore.  A few nontrivial moments of distributed settings are mentioned in the section <a href="https://habr.com/ru/post/324400/">Traps and Warnings</a> . <br><br><a name="caveeats"></a><h2>  Pitfalls and cautions: StackOverflow sends to this section. </h2><br>  Despite the simplicity that has been paramount, there are plenty of ways to create problems for yourself. <br><br>  NSUserDefaults have improved significantly over the years of their existence.  The list below is relevant for iOS 10 and macOS Sierra, but should be longer for older systems, and is likely to be shorter in future ones. <br><br><ul><li>  The collections returned by NSUserDefaults are always immutable, even if you saved the editable collection. </li><li>  Saving the editable collection to NSUserDefaults and then modifying it will not save the edited value. </li><li>  Settings are not plist-files, storage in plist-files is only a frequent case.  Direct intervention in plist files can have unpredictable consequences.  Instead, use NSUserDefaults, CFPreferences, the command line ‚Äúdefaults‚Äù utility.  You can use ‚Äúdefaults import‚Äù and ‚Äúdefaults export‚Äù to convert ‚Äúentirely‚Äù between the standard plist file and the settings </li><li>  Plist files are not settings.  Use ‚Äúplutil‚Äù or NSPropertyList API to work with arbitrary plist files, but not with settings or NSUserDefaults </li><li>  Only types that can be stored by plist can be stored in NSUserDefaults.  If you want to save an arbitrary object, then you need to apply NSKeyedArchiver or something similar in order to first get NSData.  Often this means that you are trying to save something that is not user preferences. </li><li>  Until iOS 9.3 / macOS Sierra, KVO only works with standardUserDefaults </li><li>  Until iOS 9.3 / macOS Sierra, KVO does not notify about changes made by other applications. </li><li>  NSUserDefaultsDidChangeNotification does not notify about changes made by other applications. </li><li>  The <i>-registerDefaults:</i> method works on each instance of NSUserDefaults, and not only on the one where you called it </li><li>  The <i>+ resetStandardUserDefaults</i> method does nothing particularly useful. </li><li>  "VolatileDomain" methods also do nothing particularly useful </li><li>  Using the <i>-setPersistentDomain: forName method:</i> it‚Äôs difficult to avoid problems if more than one thread sets preferences.  The reason in situations like this: <br><br><ol><li>  <b>Stream 1</b> calls <i>-persistentDomainForName:,</i> taking snapshots of current settings </li><li>  <b>Stream 2</b> calls <i>-setObject: forKey:</i> for the ‚ÄúA‚Äù key </li><li>  <b>Stream 1</b> creates a copy of the snapshot received and changes the value for the ‚ÄúB‚Äù key, then calls <i>-setPersistentDomain: forName:</i> </li></ol><br>  Changing the value for key ‚ÄúA‚Äù is lost, because <b>Stream 1</b> sets the entire dictionary at once, and there is no new value for key ‚ÄúA‚Äù in this dictionary. <br></li><li>  If you set a setting, and immediately call <i>exit ()</i> or <i>abort ()</i> (but not- <i>terminate</i> or the like), then the value you set may be lost.  You can use CFPreferencesAppSynchronize () to make the output secure. </li><li>  If you use settings in conjunction with KVO between processes or devices, then make sure you do not set the settings in response to their change.  Otherwise, a ‚Äúcycle‚Äù may occur in which two or more processes / devices constantly respond to changes made by each other, spending battery and traffic (in the case of distributed settings) </li><li>  Unlike the usual settings, the distributed ones are saved in the cloud, and there is no guarantee that they will be available.  Therefore, reading the distributed settings can return the registered value instead of the real one from the cloud, if the download is not yet complete (which in turn can take an unlimited amount of time).  Your application should be ready for this. </li></ul><br><h2>  Advanced NSUserDefaults: you probably don‚Äôt need it </h2><br>  A surprise gift bag full of the less-used features of NSUserDefaults.  May contain bees. <br><br><ul><li>  Methods of adding / deleting a set accept another instance of NSUserDefaults and effectively insert it into the instance on which they are called ( <a href="https://developer.apple.com/reference/foundation/nsuserdefaults/1410294-addsuitenamed%3Flanguage%3Dobjc">documentation on <i>-addSuiteNamed:</i></a> says: "inserts the specified domain name into the search list of the recipient" - approx. Translation).  Yes - this means that you can automatically access the settings that you share with another process.  No, you probably shouldn‚Äôt do that because invisible call to the interprocess-changeable state is scary </li><li>  Methods of the form "PersistentDomain" (permanent domain) were the only way to work with the settings of another application until <i>-initWithSuiteName:.</i>  The main application that remains in the modern world is the call <i>-removePersistentDomainForName:</i> to delete all settings in the domain </li><li>  The <i>-objectIsForcedForKey</i> method <i>:</i> allows you to check whether this setting was overridden by a configuration profile (iOS) or MCX (macOS) </li><li>  Method <i>-setURL: forKey:</i> does what is written on the box.  It is unique in that it is the only NSUserDefaults method that allows you to save a non-plist type.  If you want to save NSURLs, you should use <i>-setURL: forKey:</i> instead of <i>-setObject: forKey:</i> </li><li>  A variety of typed getters perform implicit conversions of readable values.  For example, ‚Äú1.0‚Äù will be read as ‚Äú1‚Äù if you use <i>-integerForKey:</i> or as ‚ÄúYES‚Äù if you use <i>-boolForKey:</i> </li><li>  The command line arguments of your program that have the form "-key value" (-key value) override the settings, which can be useful for testing.  By the way, you can configure these arguments in the project diagram in XCode </li><li>  To write global settings that all applications read, you can use the ‚Äúdefaults write -g‚Äù command </li></ul><br><h2>  NSUserDefaults Performance Compromises: Accelerating </h2><br>  In general, the performance of NSUserDefaults is good enough so you don‚Äôt have to worry about it.  However, there are several things to know about if a problem occurs (please use a profiler, like the Tools tool, to check!) <br><br>  When you first read any setting, the entire set is loaded into memory.  This can take considerable time on slow systems.  The implications of this are: <br><br><ol><li>  Do not store huge amounts of data in the settings, because they will be loaded all at once </li><li>  Do not pile mountains of presets, as each set will require its own initial boot. </li></ol><br>  Even if there are no settings in the domain, overhead is still incurred in detecting this fact.  For example, if you have the ‚ÄúEnable debug logs‚Äù setting, then it is usually faster and more economical to store it in the standard settings in memory than in a separate ‚ÄúLogging‚Äù set. <br><br>  Reading already loaded settings is extremely fast: about half a microsecond on a 2012 MacBook Pro.  Certain things can invalidate the cache and require reloading: if the set is shared with another process, then setting the settings in either process disables the cache in both.  In a more typical case of unshared settings, reading the settings after installation will create a small overhead, but not a complete rebuilding of the cache.  Conclusions from here: <br><br><ol><li>  When possible, avoid separation. </li><li>  When possible, minimize installations </li><li>  Always free to read. </li></ol><br>  Repeatedly installing one key, even at different values, can be much faster than installing many different keys.  This allows NSUserDefaults to be fast in cases like saving a resizable real-time window. <br><br>  Most of the work involved in setting up the setup is asynchronous.  But reading can be blocking while asynchronous writing is in progress.  The <nobr><i>-synchronize</i></nobr> call <nobr><i>is</i></nobr> also blocking.  Intermittent set-up and read operations of a large split set are the worst case for performance tuning. <br><br>  Setting the value in the collection inside the settings will cause the installation of the entire collection (apparently, an emphasis on ‚Äúthe unchanged part of the collection too‚Äù - approx. Transl.).  Partial write support works only for top-level keys. <br><br>  Setting the value (ultimately, it is asynchronous and happens later in another process) writes the entire plist to disk, no matter how small the change was.  Avoid storing large amounts of data, especially with frequent changes. <br><br>  <a href="">The awful horror of the tic-tac-toe program, leading to the sad end of NSUserDefaults</a> </div><p>Source: <a href="https://habr.com/ru/post/324400/">https://habr.com/ru/post/324400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324384/index.html">Intel SGX Extensions Tutorial. Part 7, revision of the enclave</a></li>
<li><a href="../324388/index.html">React + mobx path from scratch. Mobx + react, side view</a></li>
<li><a href="../324394/index.html">Are commodity aggregators good?</a></li>
<li><a href="../324396/index.html">Check Point Security CheckUP - Free network security audit. Part 1</a></li>
<li><a href="../324398/index.html">Biometrics: the art of recognition. Perspectives of biometric systems on the example of the Id-Me platform from the company RecFaces</a></li>
<li><a href="../324402/index.html">Open machine learning course. Theme 5. Compositions: bagging, random forest</a></li>
<li><a href="../324410/index.html">Smarting Cities</a></li>
<li><a href="../324412/index.html">How to choose the best server solution and not make a mistake</a></li>
<li><a href="../324414/index.html">Scapegoat or MVC in iOS</a></li>
<li><a href="../324416/index.html">Targeted attacks on Polish banks: technical analysis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>