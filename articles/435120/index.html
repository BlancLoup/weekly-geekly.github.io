<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lambda functions in SQL ... let me think</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What will be the article, and so it is clear from the title. 

 In addition, the author will explain why, from his point of view, it is necessary, and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lambda functions in SQL ... let me think</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ch/fp/slchfpm_a-deoh62fqiazjgdc5k.png" alt="image"></div><br>  What will be the article, and so it is clear from the title. <br><br>  In addition, the author will explain why, from his point of view, it is necessary, and also tell you that SUBJ is not just a fashionable technology, but also ‚Äúa doubly necessary thing - both pleasant and useful.‚Äù <br><a name="habracut"></a><br>  It is always interesting to see how several talented people do something (a programming language, why not), knowing exactly what problem they are solving and what tasks they set for themselves.  They also test their creation on themselves.  Do not compare with the monumental creations of giant committees, which are at the forefront of maintaining the harmony of the universe, as he understands it. <br><br>  Compare, for example, the fate of <a href="https://en.wikipedia.org/wiki/Fortran">FORTRAN</a> and <a href="https://en.wikipedia.org/wiki/PL/I">PL / 1</a> .  Who now generally remembers this PL / 1. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      From this point of view, the <a href="https://en.wikipedia.org/wiki/AWK">AWK</a> language, for example, is very successful.  It is worth saying that in its title A is <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2585%25D0%25BE,_%25D0%2590%25D0%25BB%25D1%258C%25D1%2584%25D1%2580%25D0%25B5%25D0%25B4">Alfred Aho</a> , one of the authors of the <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Dragon Book</a> , W is <a href="https://en.wikipedia.org/wiki/Peter_J._Weinberger">Peter Weinberger</a> , who also had a hand on Fortran-77, K is <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B5%25D1%2580%25D0%25BD%25D0%25B8%25D0%25B3%25D0%25B0%25D0%25BD,_%25D0%2591%25D1%2580%25D0%25B0%25D0%25B9%25D0%25B0%25D0%25BD">Brian Kernighan</a> , where without him.  A language is designed to process textual flow on the fly in the pipes between processes. <br><br>  The language is typeless ( <a href="http://project.net.ru/web-master/unix_shell/article5/awk_bal_str7_10.html">this is not quite so</a> ), the syntax is very similar to C, it has filtering capabilities, associative arrays, start / end events of a stream, a newline event ... <br><br>  The author has always been impressed with this language by the fact that his interpreter does not need to be installed, it is always available under UNIX-like systems, and under Windows it is enough just to copy the executable file and everything works.  However, this is irrelevant. <br><br>  In the process, the author often has to use a bunch of SQL + AWK and here's why.  SQL is still an inherently declarative language for managing data flows.  It provides very limited possibilities for working with the context of executing a query in the form of aggregate functions. <br><br>  How, for example, to build a two-dimensional histogram using SQL? <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   100 x 100 SELECT count(), round(x, -2) AS cx, round(y, -2) AS cy FROM samples GROUP BY cx, xy</span></span></code> </pre> <br>  But let me use GROUP BY to use sorting, which is not cheap, if you have hundreds of millions (or even more) rows. <br><div class="spoiler">  <b class="spoiler_title">UPD: in the comments I was corrected that this is not quite so (or not at all)</b> <div class="spoiler_text">  SQL-processor has the ability to perform aggregate functions in the process of constructing a hash according to the criterion of grouping.  For this, it is necessary that it has enough free memory to accommodate the hash map in memory. <br><br>  Then the contexts of the groups will be updated as the table is read, and at the end of this reading we will already have a calculated result. <br>  The same technique can be extended to window functions (below), just the context will be "thicker". <br><br>  In the case when the number of groups is not known in advance or is very large, the SQL processor is forced to build a temporary index and run through it with the second pass. <br><br>  In simple cases, for example, like here - a simple COUNT, a universal option is possible - a temporary index (cx, cy, count), then with a small number of groups it will be completely in memory on the cached pages.  In complex cases, window functions, the state of the group becomes non-trivial and constantly (de) serialize it is not at all what the doctor prescribed. <br></div></div>  In short: the SQL processor resorts to sorting when it cannot estimate the number of groups after a GROUP BY.  However, grouping by calculated values ‚Äã‚Äãis (often) just the case. <br><br>  So you have to do something like: <br><br><pre> <code class="bash hljs">psql -t -q -c <span class="hljs-string"><span class="hljs-string">'select x, y from samples'</span></span> | gawk -f mk_hist2d.awk</code> </pre> <br>  where mk_hist2d.awk accumulates statistics in an associative array and displays it upon completion <br><br><pre> <code class="cpp hljs"># mk_hist2d.awk { bucket[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>)]+=$<span class="hljs-number"><span class="hljs-number">1</span></span>; } END { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i, j) in bucket) print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>bucket[i, j]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" 0"</span></span>; } }</code> </pre><br>  There is one BUT - the full data stream should be sent from the server to the working machine, and this is not so cheap. <br><br>  Is it possible to somehow combine business with pleasure - to accumulate statistics during the execution of a SQL query, but without resorting to sorting?  Yes, for example, using custom aggregate functions. <br><br><h4>  Custom aggregate functions </h4><br>  Subj is present in different systems, everywhere done a little differently. <br><br><ol><li>  <b>PostgreSQL</b> .  Documentation is <a href="https://postgrespro.ru/docs/postgresql/9.6/sql-createaggregate">here</a> .  Read more <a href="https://habr.com/company/postgrespro/blog/351008/">here</a> . <br>  This is <a href="https://hashrocket.com/blog/posts/custom-aggregates-in-postgresql">where the</a> maximum account balance <a href="https://hashrocket.com/blog/posts/custom-aggregates-in-postgresql">is</a> calculated. <br>  And this is <a href="https://habr.com/post/177165/">an example</a> that calculates what is more in a boolean column - true or false. <br><br>  It looks like this - <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AGGREGATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mode</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span>) ( SFUNC = mode_bool_state, STYPE = <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>[], FINALFUNC = mode_bool_final, INITCOND = <span class="hljs-string"><span class="hljs-string">'{0,0}'</span></span> );</code> </pre><br>  Here, <b>SFUNC</b> is a function that is called for every line in the stream, <br>  The first argument in it is of type <b>STYPE</b> . <br><br>  <b>FINALFUNC finishes the</b> calculation and returns the value of the aggregate. <br>  <b>INITCOND</b> - initialization of the initial value of the internal state ( <b>STYPE</b> ), transmitted by the first argument. <br>  Taking into account that functions can be written in C (which means that you can use automatically released memory when closing a request for the internal state), this is a very powerful tool.  Beyond its use one must still be able to go. </li><li>  <b>MS SQL.</b> <br>  <a href="http://weblogs.sqlteam.com/jeffs/articles/1490.aspx">Before</a> (2000), before the request, it was necessary to create an ActiveX object, do aggregation using this object. <br>  <a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/user-defined-functions/create-user-defined-aggregates%3Fview%3Dsql-server-2017">Now</a> (2016+) this is done in the CLR environment.  You have to create a custom <a href="https://docs.microsoft.com/ru-ru/sql/relational-databases/clr-integration-database-objects-user-defined-functions/clr-user-defined-aggregates%3Fview%3Dsql-server-2017">function</a> , create and register an <a href="https://docs.microsoft.com/ru-ru/sql/t-sql/statements/create-assembly-transact-sql%3Fview%3Dsql-server-2017">assembly</a> .  Then you can create an <a href="https://docs.microsoft.com/ru-ru/sql/t-sql/statements/create-aggregate-transact-sql%3Fview%3Dsql-server-2017">aggregate</a> . <br>  <a href="https://www.codeproject.com/articles/170061/webcontrols/WebControls/">An example of</a> calculating a geometric average, as well as merging lines: with additional parameters and a user-defined type for storing an intermediate state. </li><li>  <b>Oracle</b> . <br>  In Oracle, this is done using the <a href="https://docs.oracle.com/cd/B10501_01/appdev.920/a96595/dci11agg.htm">ODCIAggregate</a> <a href="https://docs.oracle.com/cd/B10501_01/appdev.920/a96595/dci01wht.htm">Data Cartridge</a> (interface). <br>  To create your own aggregate, you must write a custom type that implements 4 methods. <br>  - initialization (ODCIAggregateInitialize), static, must create an instance of the desired type and return via the parameter <br>  - iteration (ODCIAggregateIterate), called on each data line <br>  - merge (ODCIAggregateMerge), used to merge concurrently executed units <br>  - finish (ODCIAggregateTerminate) - issue result <br>  Examples: <a href="https://habr.com/company/postgrespro/blog/351008/">1</a> , <a href="http://torofimofu.blogspot.com/2014/01/oracle.html">2</a> , <a href="https://docs.oracle.com/cd/B10501_01/appdev.920/a96595/dci11agg.htm">3</a> , <a href="https://www.experts-exchange.com/articles/9391/How-to-Create-User-Defined-Aggregates-in-Oracle.html">4</a> . </li><li>  <b>DB2.</b> <br>  There is no explicit way to use custom aggregates in DB2. <br>  But <a href="https://www.ibm.com/developerworks/data/library/techarticle/0309stolze/0309stolze.html">you can</a> slip the standard function (even, MAX) user defined type (in Java) and force the system to perform queries of the form <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> Complex <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span>, i <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span> ) ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> complexNumbers ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> Complex ) ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum..real, sum..i <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> GetAggrResult(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(BuildComplexSum(<span class="hljs-built_in"><span class="hljs-built_in">number</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> complexNumbers ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>)</code> </pre></li></ol><br>  What attracts attention in all these systems? <br><br><ul><li>  Anyway, you will need to create some objects in the database.  Whether AGGREGATE or TYPE.  At least the corresponding rights are required.  <i>And all I want to add a few numbers on the knee.</i> <br></li><li>  You may have to write something in another language, be it C, C # or Java. <br>  To integrate the written into the system, again, you need rights.  <i>And all you want ...</i> <br></li><li>  Difficulties with initialization.  Suppose you want to count histograms with different sizes of baskets.  It would seem, what is simpler - we indicate the desired INITCOND when declaring an aggregate (PostgreSQL) and the whole business.  But then for each size of the basket you need your own unit, and for this, rights are needed again. <br><br>  Here you can resort to a dirty trick and slip the processor union out of the initialization string (forward) and data, construct the context not in the constructor, but when you get the first string. <br></li><li>  Nevertheless, even with the described limitations, custom aggregates allow us to calculate anything. <br></li><li>  It is important that <u>aggregates can be parallelized</u> , at least PostgreSQL, and Oracle (Enterprise Edition) can do this.  To do this, the truth will have to learn how to serialize / deserialize intermediate states as well as to migrate them from different streams. </li></ul><br><h4>  Window functions </h4><br>  Window functions appeared in the <a href="https://en.wikipedia.org/wiki/SQL:2003">SQL: 2003</a> standard.  At the moment, they are supported by all the above systems.  In essence, window functions are an extension of working with aggregates.  And, of course, custom aggregate functions work in a windowed context. <br><br>  The extension is this.  And before SQL: 2003, the aggregate functions worked in a certain window, which either the entire resultset or its part corresponding to the combination of field values ‚Äã‚Äãfrom the GROUP BY clause performed.  Now the user has some freedom in manipulating this window. <br><br>  The difference is that the values ‚Äã‚Äãcalculated using windows are added to the output in a separate column, and do not require the entire flow to be closed using aggregate functions.  So in one request you can use several window units each in its own context (window).  There could be several aggregate functions before, but they all worked in one window. <br><br>  Large strokes, <br><br><ul><li>  <b>OVER ()</b> <br>  the window is the entire resultset.  Suppose the query ' <i>select count (1) from Samples</i> ' returns 169. In this case, by running ' <i>select count (1) over () from Samples</i> ', we get a column that is written 169 times 169 times. </li><li>  <b>OVER (PARTITION BY)</b> <br>  this is analogous to GROUP BY, for each combination of values ‚Äã‚Äãa window is created in which the aggregate functions are performed.  Suppose in the Samples table one integer column is val, data is numbers from 1 to 169. <br>  Then the query ' <i>select count (1) over (partition by (12 + val) / 13) from Samples</i> ' will return a column in which value 139 is written 16 times. <br></li><li>  <b>OVER (ORDER BY)</b> <br>  can be combined with PARTITION BY, allows you to dynamically change the size of the window in the process of moving the cursor, in this case, the window extends from the beginning of the group to the current position of the cursor.  As a result, the group does not produce the same value in the aggregate column, but its own.  Convenient for calculating the cumulative sum.  Query result <br>  <i>'select sum (val) over (order by val) from Samples</i> ' will be a column in which the nth element will contain the sum of positive integers from 1 to n. </li><li>  <b>OVER (ROWS)</b> <br>  allows you to define the window frame, starting from either the cursor position or the start / end of the ORDER BY range. <br><br>  For example, ' <i>... ROWS 1 PRECEDING ...</i> ' means that the window consists of the current line and 1 before it.  A ' <i>... ROWS BETWEEN 1 FOLLOWING AND 2 FOLLOWING ...</i> ' - the window consists of two lines immediately after the cursor. <br><br>  CURRENT ROW in this mode indicates the current position of the cursor.  For example, ' <i>ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</i> ' means starting at the current line and ending at the end of the range. </li><li>  <b>OVER (RANGE)</b> <br>  differs from ROWS in that CURRENT ROW here means as the start of the window - the beginning of the range from ORDER BY, and as the end of the window - the last line of the ORDER BY range. </li></ul><br>  The syntax for using window functions varies slightly across systems. <br><br>  To summarize the above, there remains a bit of a painful feeling that the developers, having analyzed the construction of various reports in SQL, identified the most frequent cases and tightly concreted them in the syntax. <br><br><h4>  Functions returning recordset </h4><br>  In the output of aggregate / window functions, each resultant line corresponds to a certain range of lines from the incoming data stream.  In life, such a correspondence does not always exist. <br><br>  For example, you need to build a 10X10 covariance matrix ( <a href="https://habr.com/company/2gis/blog/193116/">this</a> would require 672X672).  This <a href="https://habr.com/post/333426/">can be</a> done in a single pass; for this, we execute the aggregate function written by us with 10 numeric parameters.  The result of its work is a recordset of 10 rows of 10 values, each element of the matrix refers to all rows of the input stream (no matter how many). <br><br>  You can say - so what, in PostgreSQl, for example, <a href="https://postgrespro.ru/docs/postgrespro/9.6/arrays">you can</a> return a two-dimensional array from a function (Ex: 'ARRAY [[1,2], [3,4]').  Or just serialize the matrix into a row. <br><br>  It is good, but it is not always possible to keep the size of the result within the limits acceptable to this approach. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrical digression</b> <div class="spoiler_text">  For example, our task is to generalize geometry. <br><br>  The size of the geometries is unknown to us, it may be the coastline of Eurasia from tens of millions of points.  Or vice versa, there is a very rough geometry, it is required to smooth it with splines.  I would like to pass the parameters to the aggregate and get a data stream instead of a vector or string. <br><br>  You can, of course, say that the task is far-fetched, that no one does this, the geometries in the DBMS are stored in a special way, there are special programs for processing geometries, ... <br><br>  In fact, it is quite convenient to store geometry in point-by-point tables, if only because by moving one point, there is no need to rewrite the entire blob.  Before spatial data was universally leaked into the DBMS, it was, for example, in <a href="https://en.wikipedia.org/wiki/ArcSDE">ArcSDE</a> . <br><br>  As soon as the average size of a blob of a geometry exceeds the size of a page, it becomes more profitable to work directly with points.  If there was a physical opportunity to operate with streams of points, perhaps the history wheel would turn again. <br></div></div><br>  The covariance matrix is ‚Äã‚Äãstill not a very good example of dissynchronization between input and output streams, since the entire result is obtained simultaneously at the end.  Suppose you want to process / compress the source data stream.  Wherein <br><br><ul><li>  there is a lot of data, they are in a ‚Äúheap‚Äù without indexes, in fact they are simply 'quickly' written to disk </li><li>  required to put them in different categories, which are relatively few </li><li>  within categories, average over time intervals, store only average, number of measurements and variance </li><li>  all this needs to be done quickly </li></ul><br>  What are the options? <br><br><ol><li>  In the framework of SQL, a sorting by time interval / category is required, which contradicts the last item. </li><li>  If the data is already sorted by time (which, in general, is not guaranteed), and you will be able to convey this fact to the SQL processor, you can get by with window functions and a single pass. </li><li>  Write a separate application that will do all this.  On PL / SQL or, more likely, considering that there is a lot of data, on C / C ++. </li><li>  Functions returning a record set.  Perhaps they can help us. </li></ol><br>  More detail about P.4.  There are two mechanisms for this - temporary tables and pipeline functions. <br><br><ol><li>  Conveyor functions. <br>  This mechanism <a href="https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/tuning.htm">appeared</a> in Oracle (starting from 9i, 2001) and allows the function that returns the recordset not to accumulate data, but to calculate it as necessary (by analogy with the synchronization of stdout and stdin of two pipe-related processes). <br>  Those.  The results of pipelined functions can be processed before exiting this function.  For this, it suffices to say in the definition of the function <br><br><pre> <code class="sql hljs"> FUNCTION f_trans(p refcur_t) RETURN outrecset PIPELINED IS ‚Ä¶</code> </pre> <br>  and in the body register result lines <br><br><pre> <code class="sql hljs">LOOP ‚Ä¶ out_rec.var_char1 := in_rec.email; out_rec.var_char2 := in_rec.phone_number; PIPE ROW(out_rec); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>;</code> </pre> <br>  As a result, we have <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>( refcur_pkg.f_trans( <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">60</span></span>)));</code> </pre><br>  Custom units are simply not needed when there are pipeline functions. <br><br>  Bravo, Oracle! <br><br>  Not so long ago (2014) pipeline functions <a href="https://www.itjungle.com/2015/05/05/fhg050515-story01/">appeared</a> in DB2 (IBM i 7.1 TR9, i 7.2 TR1). </li><li>  Temporary tables. <br>  To begin with, neither <a href="https://decipherinfosys.wordpress.com/2007/05/24/simulating-a-pipeline-function-in-sql-server/">in</a> MS SQL nor <a href="https://www.postgresql.org/docs/10/static/xfunc-sql.html">in</a> PostgreSQL, it seems impossible to return the cursor from the aggregate function. <br><br>  Well, let's, by analogy with the conveyor functions, get the cursor by parameter, process it, add it to the temporary table and return the cursor to it. <br><br>  However, in MS SQL, <a href="https://books.google.ru/books%3Fid%3DkuBCF2bsW7YC%26pg%3DPA613%26lpg%3DPA613">it is impossible</a> to transfer the cursor by parameter to the stored procedure; you can only create a cursor in the procedure and return it via the output parameter.  The same can be <a href="https://postgrespro.ru/docs/postgrespro/10/plpgsql-cursors">said</a> about PostgreSQL. <br><br>  Well, okay, just open the cursor, subtract it, process the values, calculate the result, add to the temporary table and give the cursor. <br><br>  Or even easier, we add the results of the query into one temporary table, process it and return the results through the cursor to another temporary table. <br><br>  <a href="https://www.quotes.net/mquote/44338">What</a> can I say.  First, and most importantly, reading the data through the cursor is slower than processing in the stream.  Secondly, why do we need a SQL processor at all, let's read the tables with cursors, create temporary tables with our hands, write join-in logic in cycles ... This is like assembler inserts in C / C ++, sometimes you can be pampered, but it's better not to abuse it. </li></ol><br>  So, having considered the issue with functions that return a recordset, we arrive at the conclusions: <br><br><ul><li>  Custom units here will not help us much. </li><li>  In any case, you will need to create some objects in the database.  Whether functions or temporary tables.  At least the corresponding rights are required.  <i>And all I want to handle a few numbers.</i> <br></li><li>  However, albeit with the described limitations, sometimes not too elegantly, but this method can solve the problem. </li></ul><br><h4>  What else </h4><br>  In fact, if we already have the opportunity to solve problems, what else does the author need? <br>  In fact, the Turing machine can also calculate anything, it simply does not do it very quickly and is not very convenient. <br><br>  We formulate the requirements as follows: <br><br><ol><li>  it should be a relational operator that can be used along with the rest (sample, projection, ...) </li><li>  it must be a statement that turns one data stream into another </li><li>  there is no synchronization between input and output streams </li><li>  when declaring an operator, the output stream structure is determined </li><li>  the operator has the ability to dynamically initialize (as a function, more precisely, of its body, specified directly in the definition of the operator) </li><li>  as well as a destructor as a function (...) </li><li>  as well as a function (...) that is called every time a new line is received from the input stream. </li><li>  the operator has an execution context ‚Äî a user-defined set of variables and / or collections that are needed for operation </li><li>  To run this operator, you do not need to create database objects, you do not need additional rights </li><li>  all that is required for work is determined in one place, in one language </li></ol><br>  Once, a <a href="https://habr.com/post/204254/">long time ago, the</a> author made such an operator, extending a home-made processor of a implemented subset of <a href="https://books.google.ru/books%3Fid%3Dnpdn5wROkecC">TTM / Tutorial D.</a>  Now the same idea is proposed for SQL. <br><br>  It is worth warning, here the SQL ends and begins improvisation.  The syntax is left as it was in the original, in the end, syntactic sugar can be anything, it does not change the essence. <br><br>  So, the <b>chew</b> operator consists of <br><br><ol><li>  The header, which contains a list of output fields and their types. <br>  Each output (and input) field is a local variable. <br>  Ex: <i>‚Äúchew {‚Äú var1 "float," var2 "integer}"</i> means that there will be two columns in the output stream - a floating point and an integer </li><li>  Body - a list of callbacks for events, at the moment - the start of the stream, the end of the stream, a string.  Syntax functions are similar to PL / SQL.  The predefined function <i>__interrupt</i> () is analogous to PIPE; it takes values ‚Äã‚Äãfrom the variables corresponding to the output columns and places them in the output stream.  If the output buffer overflows, the handler stops working and the receiving side of the stream begins. <br>  Ex: ‚Äúhook‚Äú init ‚Äù{var1: = 0;  var2: = -1;  } " </li></ol><br>  The easiest way to show examples. <br><br><ul><li>  Analogue of the SUM aggregate function. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples' -- select * from samples chew {‚Äúsum(val)‚Äù float} --    hook ‚Äúinit‚Äù { ‚Äúsum(val)‚Äù := 0; --      } hook ‚Äúrow‚Äù { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; end if; } hook ‚Äúfinit‚Äù { call __interrupt(); --  PIPE }</span></span></code> </pre><br>  It looks cumbersome, but this is just an example, <br>  It is not necessary to write a C program to add a pair of numbers. </li><li>  SUM + AVG <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val), avg(val) from samples' -- select * from samples chew { ‚Äúsum(val)‚Äù float, ‚Äúavg(val)‚Äù float --       } hook ‚Äúinit‚Äù { ‚Äúsum(val)‚Äù := 0; ‚Äúavg(val)‚Äù := 0; var num integer; num := 0; --    ,       } hook ‚Äúrow‚Äù { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook ‚Äúfinit‚Äù { if (num &gt; 0) then ‚Äúavg(val)‚Äù := ‚Äúsum(val)‚Äù / num; end if; call __interrupt(); }</span></span></code> </pre><br>  Here we note that the summation occurs only once. </li><li>  SUM + GROUP BY <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples group by type' -- select * from --     ( samples val, type from samples order by type ) chew { ‚Äúsum(val)‚Äù float } hook ‚Äúinit‚Äù { ‚Äúsum(val)‚Äù := 0; var gtype integer; gtype := NULL; var num integer; --   num := 0; } hook ‚Äúrow‚Äù { if (gtype &lt;&gt; ‚Äútype‚Äù) then __interrupt(); ‚Äúgtype‚Äù := type; "sum(val)" := 0; num := 0; end if; if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook ‚Äúfinit‚Äù { if (num &gt; 0) then call __interrupt(); end if; }</span></span></code> </pre></li><li>  ROW_NUMBER () OVER () <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- select row_number() over() as num, * from samples -- select * from samples chew { ‚Äúnum‚Äù integer, * --        --   '* except val1, ...valX',   TTM } hook ‚Äúinit‚Äù { num := 0; } hook ‚Äúrow‚Äù { num := num + 1; call __interrupt(); }</span></span></code> </pre></li></ul><br>  Is it possible to offer an example in which this approach gives results that are fundamentally unattainable in the usual way?  We have them. <br><br>  Sometimes it happens that the data is almost sorted.  They may even be completely sorted, but it is not known for sure. <br><br>     (  )             .  Those.        T1            T2   T1 &lt; T2. <br><br>    ,    T1  T2     () ,    ( )  . <br><br> ,   ,             ,        ,         . <br><br>     . <br><br>   ,    . <br><br>      . <br><br>       ,       . <br>        ,   . <br><br>    SQL-           . <br><br>   lambda-     SQL-   ,     ,    . <br><br><h4>  Conclusion </h4><br>        . <br><br>       PL/SQL. <br><br>             . <br><br>   ,         , GROUP BY. <br><br> ,      ,    SQL-   . <br><br>   ,  ,                . <br><br> <b>PS:</b>        . </div><p>Source: <a href="https://habr.com/ru/post/435120/">https://habr.com/ru/post/435120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435106/index.html">Once again about passport.js</a></li>
<li><a href="../435108/index.html">Use Prolog</a></li>
<li><a href="../435112/index.html">Corporate Interview</a></li>
<li><a href="../435114/index.html">Spring Data JPA</a></li>
<li><a href="../435118/index.html">Save File Me - free client-side backup service</a></li>
<li><a href="../435122/index.html">How the flames were implemented in Doom on the Playstation</a></li>
<li><a href="../435124/index.html">Masterpieces of world column design: studio transformer with a variable number of lanes</a></li>
<li><a href="../435126/index.html">Experience in organizing and conducting corporate conferences for analysts</a></li>
<li><a href="../435128/index.html">Pi-Sonos: a hobby out of control</a></li>
<li><a href="../435132/index.html">Nomad: problems and solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>