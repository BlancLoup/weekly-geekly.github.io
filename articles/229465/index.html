<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automatic code alignment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. 

 Among the ways to improve the readability of the code associated with the visual perception of the text, the following can be highlighted...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automatic code alignment</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/40c/c2d/22a/40cc2d22abbebd97aec8c88183dcac76.png"><br><br>  Good day. <br><br>  Among the ways to improve the readability of the code associated with the visual perception of the text, the following can be highlighted: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Syntax highlighting </li><li>  Use indents </li><li>  Vertical alignment </li></ul><br>  The first 2 methods have proven themselves and are used in almost all modern IDE and advanced text editors.  The third method did not find such wide distribution.  This gap, both from a theoretical and from a practical point of view, I will try to fill in this article. <br><br><a name="habracut"></a><br><br>  It would be a mistake to say that this problem was never solved.  A quick search showed that there are many implementations, including for the Sublime Text editor I use. <br><br>  However, if you look more closely, it becomes clear that almost all of these plug-ins implement alignment only for one pre-selected symbol.  Among the most advanced versions builds highlight the following <a href="http://www.codealignment.com/">tool</a> .  But it also has a significant drawback: it uses a closed source DLL for its work, which makes it impossible to use it cross-platform, including under Linux. <br><br>  In this regard, I decided to look for my own method for solving the problem. <br><br>  It should be noted that initially I assumed that I would spend no more than a couple of evenings on the decision, but the task turned out to be much more difficult than it seemed to me at first glance. <br><br>  The first unsuccessful option was to simply find pairs of similar tokens in two adjacent lines, and then align it to them.  Moreover, it would be necessary to find such pairs that, firstly, would not overlap each other, and secondly, they would have the maximum weighted sum of similarity coefficients.  However, the following example illustrates the non-viability of this approach: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// from f(a, b + c) g(b + c, a) // to f(a, b + c ) g( b + c, a)</span></span></code> </pre> <br><br>  In this case, the second argument of the function <i>f</i> and the first argument of the function <i>g are</i> so similar that they outweigh the comma resemblance.  Such an alignment is unacceptable, it can knock down the table, since to determine the number of parameters of a function, it is necessary to recalculate the number of commas located in completely different places. <br><br>  Obviously, a simple increase in weight for a pair <i>(comma, comma)</i> does not solve the problem, since the parameters of the function themselves can be arbitrarily large and, therefore, have an arbitrarily large weight. <br><br>  Therefore, it is necessary to take into account not only the degree of similarity of tokens, but also the syntactic structure of the lines to be aligned. <br><br>  In this case, there is a problem related to the fact that different languages ‚Äã‚Äãhave their own, sometimes unique, syntax, and I would like to see the tool as universal as possible. <br><br>  Moreover, in the text of the program there can be places, which can not be aligned in any way.  These include string constants and comments.  Different languages ‚Äã‚Äãrecognize comments differently, for example, C / C ++ uses <i>//</i> , and Ruby and Python <i>#</i> .  Therefore, the only way to increase versatility is to use the method of quickly describing the syntax of a language. <br><br><h5>  Grammar </h5><br><br>  The basic idea of ‚Äã‚Äãusing grammars is to build an expression tree in such a way that each node of this tree would be aligned separately with the corresponding node of another tree and only with it. <br><br>  The structure obtained from the previous example: <br><br><pre> <code class="cpp hljs"> f ( a , b + c ) g ( b + c , a )</code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e6/038/3f5/3e60383f542acaab30322401da640032.png"><br><br>  Dotted lines show the nodes between which alignment will occur. <br><br>  Due to the fact that the task of the tool does not include the interpretation of the code, there is no need to keep a complete description of the syntax of each language in the program.  On the contrary, it suffices to describe only those rules that we want to use for alignment.  These may include the function arguments mentioned above, assignment operations, bracket constructions. <br><br>  Among the requirements for grammar, the following should also be singled out: any sequence of tokens, one way or another, must be adopted by the grammar.  This requirement will allow the use of a single grammar for similar languages. <br><br>  The grammar used to construct the structure shown above can be described in the Backus-Naur form as follows: <br><br><pre> <code class="cpp hljs"> main ::= expr expr ::= expr p | p | expr <span class="hljs-string"><span class="hljs-string">','</span></span> expr p ::= <span class="hljs-string"><span class="hljs-string">'('</span></span> expr <span class="hljs-string"><span class="hljs-string">')'</span></span> |<span class="hljs-string"><span class="hljs-string">'('</span></span> <span class="hljs-string"><span class="hljs-string">')'</span></span> | any_token_except(<span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">')'</span></span>, <span class="hljs-string"><span class="hljs-string">'('</span></span>)</code> </pre><br><br>  If the string cannot be accepted by the grammar (there is no closing bracket, for example), then the recognition output will be a linear structure. <br><br>  It can be noted that the selection of nodes in the tree does not correspond to every rule of grammar convolution; otherwise, each token would be in a separate node.  To achieve the desired structure, it is necessary to highlight in the grammar those rules, the application of which should form new nodes in the tree.  In our case, such rules should be: <br><br><pre> <code class="cpp hljs"> expr ::= expr <span class="hljs-string"><span class="hljs-string">','</span></span> expr p ::= <span class="hljs-string"><span class="hljs-string">'('</span></span> expr <span class="hljs-string"><span class="hljs-string">')'</span></span></code> </pre><br><br>  During the development, an LR-0 parser was implemented using a grammar description to build an expression tree.  A description of the parser construction algorithm is beyond the scope of this article; you can find more information on it in the book: Aho, Lam, Networks, Ulman - Compilers.  Principles, technologies, tools. <br><br><h5>  Comparison </h5><br><br>  After receiving the expression tree, it is necessary to align the tokens with regard to their similarity.  A similar problem arises in genetics when studying the genome.  Sequence alignment is a method based on placing two or more sequences of DNA, RNA or protein monomers under each other in such a way that it is easy to see similar areas in these sequences [ <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B5%25D0%25B9">wiki</a> ]. <br><br>  One of the ways to solve this problem in bioinformatics is the use of dynamic programming, which I took as the basis for the task of aligning tokens. <br><br>  As in all problems of dynamic programming, the original problem is divided into more accurate ones, the solution of which is sought recursively.  In this case, a smaller task for aligning strings is to align the suffixes of these strings.  As a result of the recursive passage, a matrix is ‚Äã‚Äãobtained that associates the indices i, j of the tokens of the rows X and Y with the maximum possible total weight of the similarity of the remaining suffixes of these strings. <br>  The restoration of similar pairs in this matrix is ‚Äã‚Äãnot difficult. <br><br><div class="spoiler">  <b class="spoiler_title">Description for getting pairs of tokens from 2 arrays in Ruby language</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y,i,j)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(@cache[[i,j]] != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @cache[[i,j]][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x.size == i <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> @cache[[i,j]] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y.size == j <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> @cache[[i,j]] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> value = []; value[<span class="hljs-number"><span class="hljs-number">0</span></span>] = x[i].cmp(y[j]) + match(x,y,i+<span class="hljs-number"><span class="hljs-number">1</span></span>,j+<span class="hljs-number"><span class="hljs-number">1</span></span>) value[<span class="hljs-number"><span class="hljs-number">1</span></span>] = match(x, y, i ,j+<span class="hljs-number"><span class="hljs-number">1</span></span>) value[<span class="hljs-number"><span class="hljs-number">2</span></span>] = match(x, y, i+<span class="hljs-number"><span class="hljs-number">1</span></span>,j ) max_value = <span class="hljs-number"><span class="hljs-number">0</span></span>; max_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; value.each{ <span class="hljs-params"><span class="hljs-params">|x|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt; max_value <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> max_value = x; max_index = index; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> index += <span class="hljs-number"><span class="hljs-number">1</span></span>; } @cache[[i,j]] = [max_value, max_index]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_pairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y, start = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> @cache = {}; match(x, y, start, start); pairs = []; i = j = start; curr = @cache[[i,j]][<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> curr != <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> curr <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> pairs += [[i,j]] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x[i].cmp(y[j]) &gt; Float::EPSILON i+=<span class="hljs-number"><span class="hljs-number">1</span></span>; j+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> j+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> i+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> curr = @cache[[i,j]][<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [@cache[[start, start]][<span class="hljs-number"><span class="hljs-number">0</span></span>], pairs]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br></div></div><br><br>  In order to ensure the possibility of alignment of more than two lines, among the many arrays of pairs are allocated chains, along which the alignment takes place. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ac/0f0/970/1ac0f097003d1591eb9ff93bb7105a1f.png"><br><br>  The figure shows a chain of commas, which will be aligned. <br><br><h5>  Token allocation </h5><br><br>  Tokens are extracted from the string using a sequence of attempts to apply a regular expression for the corresponding type of tokens.  This sequence should be arranged in such a way that more specific regular expressions are applied first, and then more general, highlighting, perhaps even individual characters.  After successful recognition, the token is assigned the type corresponding to the regular expression.  The project also implements a type hierarchy, which is designed to simplify the construction of grammars and improve alignment accuracy. <br><br>  Until now, the question of how to calculate the similarity of two separately taken tokens has not been raised.  Unfortunately, I did not manage to find a strict formal solution for this task, therefore the similarity of tokens in the current implementation is determined mainly by heuristic methods. <br><br>  In particular, the similarity of identifiers is defined as the ratio of the <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">Levenshtein distance</a> between identifiers to the length of the maximum of them. <br><br>  The default values ‚Äã‚Äãin this case are as follows: <br><br><pre> <code class="cpp hljs">     <span class="hljs-number"><span class="hljs-number">1</span></span>   max(Levenshtein_dist / max_length, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)    <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><br><h5>  Determining the minimum indent between tokens </h5><br><br>  Placing indentation in some language constructions is considered a good programming style. <br>  Such cases include setting spaces after a comma in the function arguments, spaces around comparison operators, etc ... <br><br>  However, the options for setting spaces are not only different for different languages, but also different programmers use different styles. <br><br><pre> <code class="cpp hljs"> f (a, b) <span class="hljs-comment"><span class="hljs-comment">//VS f(a, b)</span></span></code> </pre><br><br>  To simplify the setup of automatic indentation in this case, it was decided to add the possibility of learning. <br>  A number of properly formatted strings are used as source data.  For each successive pair of tokens: their type and number of spaces is remembered.  The resulting data is then summarized according to the type hierarchy. <br><br><h5>  Current implementation </h5><br><br>  At the time of this writing, the program is implemented as a plugin for the Sublime Text 3 editor. Among the features, the following should be noted: <br><br><ul><li>  Align selected lines using hotkeys; </li><li>  Protection against alignment of lines with different indentation.  (It is assumed that before aligning the lines, indents are set correctly.); </li><li>  Support for different grammar options, selection of tokens and type hierarchy depending on the language used; </li><li>  At the time of this writing, only specialization has been implemented for the C language of the 99th standard and java. </li><li>  Source code written in Ruby, open and available on <a href="https://github.com/generall/aligner">GitHub</a> </li></ul><br><br>  Among the plans for the future I would like to note the following: <br><br><ul><li>  Expansion of the list of specialized grammars; </li><li>  Determining the maximum number of gaps in alignment based on machine learning. </li><li>  The ability to add lines to the training set using hot keys. </li></ul><br><br><h6>  Examples of the results </h6><br><br><div class="spoiler">  <b class="spoiler_title">Examples</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> State.QLD: city = <span class="hljs-string"><span class="hljs-string">"Brisbane"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> State.WA: city = <span class="hljs-string"><span class="hljs-string">"Perth"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> State.NSW: city = <span class="hljs-string"><span class="hljs-string">"Sydney"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: city = <span class="hljs-string"><span class="hljs-string">"???"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// To switch (state) { case State.QLD:city = "Brisbane"; break; case State.WA :city = "Perth" ; break; case State.NSW:city = "Sydney" ; break; default :city = "???" ; break; }</span></span></code> </pre><br><br><pre> <code class="ruby hljs"> /<span class="hljs-regexp"><span class="hljs-regexp">/ From types[:space] = nil; types[:quote] = nil; types[:regexp] = nil; types[:id] = nil; types[:spchar] = nil; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ To types[:space ] = nil; types[:quote ] = nil; types[:regexp] = nil; types[:id ] = nil; types[:spchar] = nil;</span></span></code> </pre><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// From long int a = 2; long long double b = 1; const int doubl = 4; // To long int a = 2; long long double b = 1; const int doubl = 4;</span></span></code> </pre><br><br>  The last example uses the separation of the type description at the grammar level, so similar <code>double</code> and <code>doubl</code> were not aligned with each other. <br><br></div></div><br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/229465/">https://habr.com/ru/post/229465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229451/index.html">MSI GX70 laptop video review</a></li>
<li><a href="../229453/index.html">Nvidia + Nexus 7 + two magnifiers + box = VR helmet</a></li>
<li><a href="../229455/index.html">TinyBanker banking trojan source leaked to network</a></li>
<li><a href="../229459/index.html">Do-it-yourself visitor</a></li>
<li><a href="../229461/index.html">Check the validity of in-game purchases through the Google API</a></li>
<li><a href="../229467/index.html">Android last.fm scrobbler WAIL Beta is now open source</a></li>
<li><a href="../229469/index.html">We analyze the protocol of new sensors Noolite</a></li>
<li><a href="../229471/index.html">We charge Lumia with the power of sound</a></li>
<li><a href="../229473/index.html">Innovative entropy production method</a></li>
<li><a href="../229475/index.html">Wargaming Public API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>