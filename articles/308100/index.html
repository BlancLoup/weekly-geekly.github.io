<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trello Clone on Phoenix and React. Parts 4-5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of Contents (current material is highlighted) 

1. Introduction and selection of technology stack 
2. Initial setup of the Phoenix Framework pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trello Clone on Phoenix and React. Parts 4-5</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/088/cf9/bc4/088cf9bc45114ff4975aee1fde9dcb63.png"><br><br><div class="spoiler">  <b class="spoiler_title">Table of Contents (current material is highlighted)</b> <div class="spoiler_text"><ol><li>  <a href="https://habrahabr.ru/post/308056/">Introduction and selection of technology stack</a> </li><li>  <a href="https://habrahabr.ru/post/308056/">Initial setup of the Phoenix Framework project</a> </li><li>  <a href="https://habrahabr.ru/post/308056/">User Model and JWT Authentication</a> </li><li>  <strong>Front-end for registration on React and Redux</strong> </li><li>  <strong>Initial database population and controller to enter the application</strong> </li><li>  <a href="https://habrahabr.ru/post/308248/">Front-end authentication on React and Redux</a> </li><li>  <a href="https://habrahabr.ru/post/308248/">We configure sockets and channels</a> </li><li>  <a href="https://habrahabr.ru/post/308382/">We display the list and create new boards</a> </li><li>  <a href="https://habrahabr.ru/post/308382/">Add new board users</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">We trace the connected users of boards</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">Add lists and cards</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">We spread the project on Heroku</a> </li></ol></div></div><br><a name="4"></a><br><h2 id="front-end-dlya-registracii-na-react-i-redux">  Front-end for registration on React and Redux </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-4">Original</a> </p><br><p> We finished the <a href="https://habrahabr.ru/post/308056/">previous publication by</a> creating a <code>User</code> model with validation and the transformations of the changeset needed to generate an encrypted password;  we also updated the router file and created the <code>RegistrationController</code> controller, which processes the request to create a new user and returns user data and its <strong>jwt</strong> -token to authenticate future requests in <strong>JSON format</strong> .  Now let's move on - to the front-end. </p><a name="habracut"></a><br><h3 id="podgotovka-marshrutizatora-react">  Preparing the React Router </h3><br><p>  The main goal is to have two public routes, <code>/sign_in</code> and <code>/sign_up</code> , which can be used by any visitor in order to enter the application or register a new account, respectively. </p><br><p>  In addition, we will need <code>/</code> as the root route to show all the boards related to the user, and finally the <code>/board/:id</code> route to display the contents of the board selected by the user.  To access the last two routes, the user must be authenticated, otherwise we will redirect him to the registration screen. </p><br><p>  Update the <code>routes</code> file for <strong>react-router</strong> to reflect what we want to do: </p><br><pre> <code class="hljs pgsql">// web/static/js/routes/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { IndexRoute, Route } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MainLayout <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../layouts/main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AuthenticatedContainer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../containers/authenticated'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HomeIndexView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/home'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RegistrationsNew <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/registrations/new'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SessionsNew <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/sessions/new'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BoardsShowView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../views/boards/show'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> ( &lt;Route component={MainLayout}&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/sign_up" component={RegistrationsNew} /&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/sign_in" component={SessionsNew} /&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/" component={AuthenticatedContainer}&gt; &lt;IndexRoute component={HomeIndexView} /&gt; &lt;Route <span class="hljs-type"><span class="hljs-type">path</span></span>="/boards/:id" component={BoardsShowView} /&gt; &lt;/Route&gt; &lt;/Route&gt; );</code> </pre> <br><p>  The tricky moment is the <code>AuthenticatedContainer</code> , let's take a look at it: </p><br><pre> <code class="hljs perl">// web/static/js/containers/authenticated.js import React from <span class="hljs-string"><span class="hljs-string">'react'</span></span>; import { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } from <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; import { routeActions } from <span class="hljs-string"><span class="hljs-string">'redux-simple-router'</span></span>; class AuthenticatedContainer extends React.Component { componentDidMount() { const { dispatch, currentUser } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'phoenixAuthToken'</span></span>)) { dispatch(Actions.currentUser()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dispatch(routeActions.push(<span class="hljs-string"><span class="hljs-string">'/sign_up'</span></span>)); } } render() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } } const mapStateToProps = (<span class="hljs-keyword"><span class="hljs-keyword">state</span></span>) =&gt; ({ currentUser: state.session.currentUser, }); export default <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(mapStateToProps)(AuthenticatedContainer);</code> </pre> <br><p>  In short, what we are doing here is: when the component is connected, we <strong>check</strong> whether the <strong>jwt</strong> -token is present in the browser‚Äôs local storage.  Later we will figure out how to save this token, but for now let's imagine that the token does not exist;  as a result, thanks to the <strong>redux-simple-route</strong> library, <strong>we will</strong> redirect the user to the registration page. </p><br><h3 id="komponent-predstavleniya-view-component-dlya-registracii">  View component for registration </h3><br><p>  This is what we will show the user if we find that he is not authenticated: </p><br><pre> <code class="hljs pgsql">// web/static/js/views/registrations/<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {PropTypes} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Link } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { setDocumentTitle, renderErrorsFor } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../utils'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../actions/registrations'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RegistrationsNew extends React.Component { componentDidMount() { setDocumentTitle(<span class="hljs-string"><span class="hljs-string">'Sign up'</span></span>); } _handleSubmit(e) { e.preventDefault(); const { dispatch } = this.props; const data = { first_name: this.refs.firstName.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, last_name: this.refs.lastName.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, email: this.refs.email.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: this.refs.<span class="hljs-keyword"><span class="hljs-keyword">password</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, password_confirmation: this.refs.passwordConfirmation.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, }; dispatch(Actions.signUp(data)); } render() { const { errors } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className="view-container registrations new"&gt; &lt;main&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>&gt; &lt;div className="logo" /&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>&gt; &lt;form onSubmit={::this._handleSubmit}&gt; &lt;div className="field"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="firstName" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="text" placeholder="First name" required={<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>} /&gt; {renderErrorsFor(errors, <span class="hljs-string"><span class="hljs-string">'first_name'</span></span>)} &lt;/div&gt; &lt;div className="field"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="lastName" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="text" placeholder="Last name" required={<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>} /&gt; {renderErrorsFor(errors, <span class="hljs-string"><span class="hljs-string">'last_name'</span></span>)} &lt;/div&gt; &lt;div className="field"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="email" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="email" placeholder="Email" required={<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>} /&gt; {renderErrorsFor(errors, <span class="hljs-string"><span class="hljs-string">'email'</span></span>)} &lt;/div&gt; &lt;div className="field"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="password" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="password" placeholder="Password" required={<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>} /&gt; {renderErrorsFor(errors, <span class="hljs-string"><span class="hljs-string">'password'</span></span>)} &lt;/div&gt; &lt;div className="field"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="passwordConfirmation" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="password" placeholder="Confirm password" required={<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>} /&gt; {renderErrorsFor(errors, <span class="hljs-string"><span class="hljs-string">'password_confirmation'</span></span>)} &lt;/div&gt; &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="submit"&gt;Sign up&lt;/button&gt; &lt;/form&gt; &lt;Link <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>="/sign_in"&gt;Sign <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>&lt;/Link&gt; &lt;/main&gt; &lt;/div&gt; ); } } const mapStateToProps = (state) =&gt; ({ errors: state.registration.errors, }); export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(mapStateToProps)(RegistrationsNew);</code> </pre> <br><p>  Not much can be said about this component ... it changes the title of the document when it connects, displays the registration form and redirects the result of the action creator of the <code>singUp</code> registration. </p><br><h3 id="konstruktor-deystviya-action-creator">  Action Creator </h3><br><p>  When the previous form has been submitted, we need to send the data to the server, where it will be processed: </p><br><pre> <code class="hljs pgsql">// web/static/js/actions/registrations.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { pushPath } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-simple-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Constants <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { httpPost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../utils'</span></span>; const Actions = {}; Actions.signUp = (data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { httpPost(<span class="hljs-string"><span class="hljs-string">'/api/v1/registrations'</span></span>, {<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: data}) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>((data) =&gt; { localStorage.setItem(<span class="hljs-string"><span class="hljs-string">'phoenixAuthToken'</span></span>, data.jwt); dispatch({ <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Constants.<span class="hljs-built_in"><span class="hljs-built_in">CURRENT_USER</span></span>, currentUser: data.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, }); dispatch(pushPath(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)); }) .catch((error) =&gt; { error.response.json() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>((errorJSON) =&gt; { dispatch({ <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Constants.REGISTRATIONS_ERROR, errors: errorJSON.errors, }); }); }); }; }; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Actions;</code> </pre> <br><p>  When the <code>RegistrationsNew</code> component calls the action constructor, passing it form data, a new <strong>POST</strong> request is sent to the server.  The request is filtered by the Phoenix router and processed by the <code>RegistrationController</code> controller that we created in the <a href="https://habrahabr.ru/post/308056/">previous publication</a> .  If successful, the <strong>jwt-</strong> token received from the server is stored in <code>localStorage</code> , the data of the created user is transferred to the <code>CURRENT_USER</code> action, and finally, the user is redirected to the root path.  On the contrary, if there are any errors related to the registration data, the action <code>REGISTRATIONS_ERROR</code> with errors in the parameters will be triggered, so that we can show them to the user in the form. </p><br><p>  To work with http requests, we are going to rely on the <a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a> package, called from an auxiliary file, which for this purpose includes several methods: </p><br><pre> <code class="hljs lua">// web/static/js/utils/index.js import React from <span class="hljs-string"><span class="hljs-string">'react'</span></span>; import fetch from <span class="hljs-string"><span class="hljs-string">'isomorphic-fetch'</span></span>; import { polyfill } from <span class="hljs-string"><span class="hljs-string">'es6-promise'</span></span>; export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span> &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { var <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> = new Error(response.statusText); <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>.response = response; throw <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>; } } export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json(); } export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url, data)</span></span></span></span> { const headers = { Authorization: localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'phoenixAuthToken'</span></span>), Accept: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, } const body = JSON.stringify(data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url, { method: <span class="hljs-string"><span class="hljs-string">'post'</span></span>, headers: headers, body: body, }) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(checkStatus) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(parseJSON); } // ...</code> </pre><br><h3 id="preobrazovateli-reducers">  Reducers </h3><br><p>  The final step is to process these results of actions with the help of converters, with the result that we can create a new state tree that is required by our application.  First, take a look at the <code>session</code> converter, in which the <code>currentUser</code> will be saved: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web/static/js/reducers/session.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Constants <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const initialState = { currentUser: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> function reducer(state = initialState, action = {}) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { case Constants.CURRENT_USER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, currentUser: action.currentUser }; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  In the case of any type of registration errors, you must add them to the new state so that we can show them to the user.  Add them to the <code>registration</code> converter: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web/static/js/reducers/registration.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Constants <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const initialState = { errors: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> function reducer(state = initialState, action = {}) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { case Constants.REGISTRATIONS_ERROR: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {...state, errors: action.errors}; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  Please note that for error output we refer to the function <code>renderErrorsFor</code> from this auxiliary file: </p><br><pre> <code class="hljs lua">// web/static/js/utils/index.js // ... export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">renderErrorsFor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(errors, ref)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!errors) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.map((<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>, i) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>[ref]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div key={i} className=<span class="hljs-string"><span class="hljs-string">"error"</span></span>&gt; {<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>[ref]} &lt;/div&gt; ); } }); }</code> </pre> <br><p>  In general, this is all that is needed for the registration process.  Next, we will see how an existing user can authenticate with the application and access their own content. </p><br><a name="5"></a><br><h2 id="nachalnoe-zapolnenie-bazy-dannyh-i-kontroller-dlya-vhoda-v-prilozhenie">  Initial database population and controller to enter the application </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-5">Original</a> </p><br><h3 id="vhod-polzovatelya-v-prilozhenie">  User login to the application </h3><br><p>  Previously, we have prepared everything so that visitors can register and create new user accounts.  In this part we are going to implement the functionality necessary to allow visitors to authenticate to the application using e-mail and password.  In the end, we will create a mechanism for obtaining user data using their authentication tokens. </p><br><h3 id="nachalnoe-zapolnenie-bazy-dannyh">  Initial database population </h3><br><p>  If you have experience with Rails, you will see that the initial population of the database in Phoenix looks very similar.  All we need for this is the presence of the file <code>seeds.exs</code> : </p><br><pre> <code class="hljs pgsql"># priv/repo/seeds.exs <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> PhoenixTrello.{Repo, <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>} [ %{ first_name: "John", last_name: "Doe", email: "john@phoenix-trello.com", <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: "12345678" }, ] |&gt; Enum.map(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.changeset(%<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>{}, &amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) |&gt; Enum.<span class="hljs-keyword"><span class="hljs-keyword">each</span></span>(&amp;Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>!(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><p>  In fact, in this file we simply add to the database all the data that we would like to provide to our application as initial data.  If you want to register any other user - just add him to the list and start filling the database: </p><br><pre> <code class="hljs ruby">$ mix run priv/repo/seeds.exs</code> </pre> <br><h3 id="kontroller-dlya-vhoda-v-prilozhenie">  Application Login Controller </h3><br><p>  Before you create a controller, you need to make some changes to the file <code>router.ex</code> : </p><br><pre> <code class="hljs lua"># web/router.ex defmodule PhoenixTrello.Router <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :router #... pipeline :api <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... plug Guardian.Plug.VerifyHeader plug Guardian.Plug.LoadResource <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> scope <span class="hljs-string"><span class="hljs-string">"/api"</span></span>, PhoenixTrello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> pipe_through :api scope <span class="hljs-string"><span class="hljs-string">"/v1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... post <span class="hljs-string"><span class="hljs-string">"/sessions"</span></span>, SessionController, :<span class="hljs-built_in"><span class="hljs-built_in">create</span></span> delete <span class="hljs-string"><span class="hljs-string">"/sessions"</span></span>, SessionController, :delete # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> #... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The first addition to be made is to add to the chain <code>:api</code> two <a href="http://www.phoenixframework.org/docs/understanding-plug">inserts</a> ( <strong>plugs</strong> , <em>then the original term will be used - plug, - since the word "insert" reflects the letter of the essence, but does not convey, as it seems to me, full sense; but if I'm wrong, I will be glad to have a normal Russian term. It also makes sense to read the <a href="https://habrahabr.ru/post/306334/">translation material</a> about <strong>plug</strong> and <strong>plug pipeline</strong> (interpreter's note</em> ): </p><br><ul><li>  <strong>VerifyHeader</strong> : this plug just checks for the presence of a token in the <code>Authorization</code> header ( <em>in fact, it also tries to decrypt it, simultaneously checking for correctness, and creates a structure with the contents of the token - comment of the translator</em> ) </li><li>  <strong>LoadResource</strong> : if the token is present, it makes the current resource ( <em>in this case, the specific entry from the <code>User</code> model - translator's comment</em> ) available as a result of the call to <code>Guardian.Plug.current_resource(conn)</code> </li></ul><br><p>  You also need to add two more routes to the <code>/api/v1</code> for creating and deleting a user session, both processed by the <code>SessionController</code> controller.  Let's start with the <code>:create</code> handler: </p><br><pre> <code class="hljs lua"># web/controllers/api/v1/session_controller.ex defmodule PhoenixTrello.SessionController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :controller plug :scrub_params, <span class="hljs-string"><span class="hljs-string">"session"</span></span> when action <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [:<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>] def <span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(conn, %{<span class="hljs-string"><span class="hljs-string">"session"</span></span> =&gt; session_params}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> case PhoenixTrello.Session.authenticate(session_params) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, user} -&gt; {:ok, jwt, _full_claims} = user |&gt; Guardian.encode_and_sign(:token) conn |&gt; put_status(:created) |&gt; render(<span class="hljs-string"><span class="hljs-string">"show.json"</span></span>, jwt: jwt, user: user) :<span class="hljs-built_in"><span class="hljs-built_in">error</span></span> -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; render(<span class="hljs-string"><span class="hljs-string">"error.json"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  To authenticate the user with the received parameters, we will use the <code>PhoenixTrello.Session</code> helper module.  If everything <code>:ok</code> , then we will encrypt the user ID and let it in (encode and sign in - a <em>somewhat free, but more understandable translation - comment of the translator</em> ).  This will give us a <strong>jwt-</strong> token, which we will be able to return with the <code>user</code> record as <strong>JSON</strong> .  Before continuing, let's take a look at the <code>Session</code> helper module: </p><br><pre> <code class="hljs pgsql"># web/helpers/<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.ex defmodule PhoenixTrello.<span class="hljs-keyword"><span class="hljs-keyword">Session</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> PhoenixTrello.{Repo, <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>} def authenticate(%{"email" =&gt; email, "password" =&gt; <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = Repo.get_by(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, email: String.downcase(email)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> check_password(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> -&gt; {:ok, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>} _ -&gt; :error <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp check_password(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> nil -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> _ -&gt; Comeonin.Bcrypt.checkpw(<span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.encrypted_password) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  He tries to find the user by e-mail and checks if the incoming password matches the encrypted user password.  If the user exists and the password is correct, a <a href="http://elixir-lang.org/getting-started/basic-types.html">tuple</a> containing <code>{:ok, user}</code> returned.  Otherwise, if the user is not found or the password is incorrect, the <a href="http://elixir-lang.org/getting-started/basic-types.html">atom is</a> returned <code>:error</code> . </p><br><p>  Returning to the <code>SessionController</code> controller, <code>SessionController</code> that it interprets the <code>error.json</code> template if the user authentication result is the atom mentioned earlier <code>:error</code> .  Finally, you need to create a <code>SessionView</code> module to display both results: </p><br><pre> <code class="hljs pgsql"># web/views/session_view.ex defmodule PhoenixTrello.SessionView <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :<span class="hljs-keyword"><span class="hljs-keyword">view</span></span> def render("show.json", %{jwt: jwt, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %{ jwt: jwt, <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def render("error.json", _) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %{error: "Invalid email or password"} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h3 id="polzovateli-uzhe-avtorizovavshiesya-v-prilozhenii">  Users already logged in </h3><br><p>  Another reason to return the user's <strong>JSON</strong> representation during application authentication is that we may need this data for different purposes;  for example, to show the username in the application header.  This corresponds to what we have already done.  But what if the user refreshes the browser page while on the first screen?  Everything is simple: the state of the application managed by <strong>Redux</strong> will be reset, and the information received earlier will disappear, which can lead to undesirable errors.  And this is not what we want, so to prevent such a situation, we can create a new controller responsible for returning, if necessary, the data of an authenticated user. </p><br><p>  Add a new route to the file <code>router.ex</code> : </p><br><pre> <code class="hljs vbscript"># web/router.ex defmodule PhoenixTrello.Router <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :router #... scope <span class="hljs-string"><span class="hljs-string">"/api"</span></span>, PhoenixTrello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> pipe_through :api scope <span class="hljs-string"><span class="hljs-string">"/v1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-string"><span class="hljs-string">"/current_user"</span></span>, CurrentUserController, :show # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> #... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Now we need a <code>CurrentUserController</code> controller that looks like this: </p><br><pre> <code class="hljs pgsql"># web/controllers/api/v1/current_user_controller.ex defmodule PhoenixTrello.CurrentUserController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :controller plug Guardian.Plug.EnsureAuthenticated, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>: PhoenixTrello.SessionController def <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>(conn, _) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = Guardian.Plug.current_resource(conn) conn |&gt; put_status(:ok) |&gt; render("show.json", <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  <code>Guardian.Plug.EnsureAuthenticated</code> checks for the presence of a previously verified token, and if it is not available, redirects the request to the <code>:unauthenticated</code> <code>SessionController</code> .  In this way, we will protect private controllers, so if there is a desire to make certain routes available only to authenticated users, all that is needed is to add this <strong>plug</strong> to the appropriate controllers.  Other functionality is quite simple: after confirming the presence of an authenticated token, <code>current_resource</code> will be translated, which in our case is the user's data. </p><br><p>  Finally, you need to add an <code>unauthenticated</code> handler to the <code>unauthenticated</code> : </p><br><pre> <code class="hljs vbscript"># web/controllers/api/v1/session_controller.ex defmodule PhoenixTrello.SessionController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :controller # ... def unauthenticated(conn, _params) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> conn |&gt; put_status(:forbidden) |&gt; render(PhoenixTrello.SessionView, <span class="hljs-string"><span class="hljs-string">"forbidden.json"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>: <span class="hljs-string"><span class="hljs-string">"Not Authenticated"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  It will return 403 - Forbidden code along with a simple textual description of the error in <strong>JSON</strong> .  At this point, we ended up with the back-end functionality related to <strong>logging into the application</strong> and subsequent <strong>authentication</strong> .  In the next post, we will cover how to handle this in the front-end and how to connect to <code>UserSocket</code> , the heart of all real-time snacks.  In the meantime, do not forget to take a look at the <a href="https://phoenix-trello.herokuapp.com/">live demo</a> and <a href="https://github.com/bigardone/phoenix-trello">source code of the</a> final result. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308100/">https://habr.com/ru/post/308100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308088/index.html">Safely use Go language in web programming</a></li>
<li><a href="../308090/index.html">About the division of labor and its consequences</a></li>
<li><a href="../308092/index.html">It's time to tell you how I was Beeline for 4 years on Habr√© - and what I learned about Habr during that time</a></li>
<li><a href="../308094/index.html">Training with reinforcements for the smallest</a></li>
<li><a href="../308098/index.html">CsvLogWriter plugin for JMeter</a></li>
<li><a href="../308102/index.html">Development for SailfishOS: menu</a></li>
<li><a href="../308104/index.html">From juniors to developers: we get the first job</a></li>
<li><a href="../308106/index.html">As I avoided burnout, having worked as a programmer for more than three decades</a></li>
<li><a href="../308108/index.html">What does HPE Mobile Center test?</a></li>
<li><a href="../308112/index.html">Joker Student Edition: The best videos of past conferences</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>