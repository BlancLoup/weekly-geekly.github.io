<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Add some virtuality to C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I then had to remember how to still need to write in C, although I work as a C + + programmer. And I lacked classes and methods so much that I began t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Add some virtuality to C</h1><div class="post__text post__text-html js-mediator-article">  I then had to remember how to still need to write in C, although I work as a C + + programmer.  And I lacked classes and methods so much that I began to think how to bring C to C ++ closer.  What for?  Just so the brains stretch. <br>  The main wish was as follows: I would like to work in C like this: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Iface* ptr )</span></span></span><span class="hljs-function"> </span></span>{ ptr-&gt;print_name(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ A a; B b; print_name( &amp;a ); <span class="hljs-comment"><span class="hljs-comment">//  "This is A object" print_name( &amp;b ); //  "This is B object" }</span></span></code> </pre> <br><br>  In fact, A and B inherit the same (and maybe several) interface (s).  At the same time, it is possible to invoke virtual methods on these objects, depending on the pointer that was supplied. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Who cares what happened in the end (and in some form the problem was solved) and who is interested in how virtual methods are implemented <b>approximately</b> in C ++, I ask for cat. <br><br><a name="habracut"></a><br><ul><li>  <a href="https://habr.com/ru/post/155439/">What is ready</a> </li><li>  <a href="https://habr.com/ru/post/155439/">How will we solve the problem?</a> </li><li>  <a href="https://habr.com/ru/post/155439/">Go!</a> <br><ul><li>  <a href="https://habr.com/ru/post/155439/">Interfaces</a> </li><li>  <a href="https://habr.com/ru/post/155439/">Classes</a> </li><li>  <a href="https://habr.com/ru/post/155439/">Usage example</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/155439/">findings</a> </li><li>  <a href="https://habr.com/ru/post/155439/">Related Literature</a> </li></ul><br><br><a name="Existing_Solutions"></a><h4>  What is ready </h4><br>  Naturally, I'm not the only one smart guy.  Methods on structures are implemented through function pointers.  Here is one of the <a href="http://stackoverflow.com/questions/3113583/how-could-one-implement-c-virtual-functions-in-c">solutions</a> from which we will build. <br><br>  What are the disadvantages of such a solution? <br><br><ul><li>  the need for explicit reference to the structure method table </li><li>  complexity (unreality?) to implement multiple "inheritance" of interfaces </li></ul><br><br><a name="My_Solution"></a><h4>  How will we solve the problem? </h4><br>  Instead of a separate structure that is a table of methods, we put in our structure explicitly pointers to functions.  And put it at the very beginning for simplicity. <br>  If you need to do multiple "inheritance", we will first put methods of one interface, then methods of the second, etc. <br><br>  In the function accepting pointers to the interface, we will pass a <b>pointer to the first interface method</b> in the structure.  Since this method will have an implementation specific to the structure, we can build on the offset of this address from the beginning of the address of the structure as a whole. <br><br>  The disadvantage here is obvious: we must take into account the bias in the structure.  Therefore, you need to either pack the structure, or somehow recognize the offset.  I made it easier: I scored and thought that aligning to the size of the pointer would be enough. <br><br>  Below is the implementation conceived using precompiled headers and VS2010 in compiler mode C. <br><br><a name="Start"></a><h4>  Go! </h4><br><a name="Interfaces"></a><h5>  Interfaces </h5><br>  So, we will enter two interfaces. <br>  The first, <b>base_iface</b> , allows you to call a method that returns a string describing the object. <br>  The second, <b>sizible_iface</b> , lets you know the size of the object. <br>  Examples are far-fetched, but we will get away. <br><div class="spoiler">  <b class="spoiler_title">base_iface.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once typedef struct base_iface* base_iface_ptr; typedef const char* (*get_name_func_ptr)( base_iface_ptr ); struct base_iface { get_name_func_ptr get_name; }; typedef struct base_iface base_iface;</span></span></code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">sizible_iface.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once typedef struct sizible_iface* sizible_iface_ptr; typedef unsigned int (*get_size_func_ptr)( sizible_iface_ptr ); struct sizible_iface { get_size_func_ptr get_size; }; typedef struct sizible_iface sizible_iface;</span></span></code> </pre><br></div></div><br><a name="Classes"></a><h5>  Classes </h5><br>  We make two structures, <b>point_t</b> and <b>d3_point_t</b> , representing a point in two-dimensional and three-dimensional space, respectively.  Each structure contains the coordinates of a point, as well as three function pointers: ‚Äúget object name‚Äù, ‚Äúget object size‚Äù, and ‚Äúprint point coordinates‚Äù. <br><br>  The first pointer is a virtual method, "inheriting" the <b>base_iface</b> interface. <br>  The second pointer is a virtual method, ‚Äúinheritance‚Äù of the <b>sizible_iface</b> interface. <br>  The third pointer is the usual method, not the virtual one. <br><br>  Header files are listed below: <br><div class="spoiler">  <b class="spoiler_title">point.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once typedef struct point_t* point_ptr; typedef void (*point_print_coordinates_func)( point_ptr ); struct point_t </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  base_iface  sizible_iface { // " " get_name_func_ptr get_name; get_size_func_ptr get_size; //  "" point_print_coordinates_func print_coordinates; //  int x; int y; }; typedef struct point_t point_t; //  point_t point_init( int x, int y ); //     point_ptr  base_iface_ptr base_iface_ptr point_to_base_iface( point_ptr ptr ); //     point_ptr  sizible_iface_ptr sizible_iface_ptr point_to_sizible_iface( point_ptr ptr );</span></span></span></span></code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">3d_point.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once typedef struct d3_point_t* d3_point_ptr; typedef void (*d3_point_print_coordinates_func)( d3_point_ptr ); struct d3_point_t </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  base_iface  sizible_iface { //  "" d3_point_print_coordinates_func print_coordinates; // " " get_name_func_ptr get_name; get_size_func_ptr get_size; //  int x; int y; int z; }; typedef struct d3_point_t d3_point_t; //  d3_point_t d3_point_init( int x, int y, int z ); //     d3_point_ptr  base_iface_ptr base_iface_ptr d3_point_to_base_iface( d3_point_ptr ptr ); //     d3_point_ptr  sizible_iface_ptr sizible_iface_ptr d3_point_to_sizible_iface( d3_point_ptr ptr );</span></span></span></span></code> </pre><br></div></div><br>  For the 3D point, I swapped the usual and virtual ‚Äúmethods‚Äù to demonstrate how virtuality works on different structures (not similar in placing their elements inside). <br><br>  Since we have a C compiler, we have to introduce an explicit type conversion from <b>point_t *</b> and from <b>d3_point_t *</b> to <b>base_iface *</b> and <b>sizible_iface *</b> and vice versa.  This is done so that the functions can take a pointer to the interface and not worry about the fact that they work with different types of structures. <br><br>  The implementation of the functions for the <b>point_t</b> and <b>d3_point_t structures is</b> given below: <br><div class="spoiler">  <b class="spoiler_title">point.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"std.h"</span></span></span><span class="hljs-meta"> static point_ptr base_iface_to_point( base_iface_ptr ptr ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  " "  base_iface static const char* point_get_name( base_iface_ptr ptr ) { static const char* null_point_ptr = "Null point"; static const char* some_point_ptr = "Some point"; point_ptr casted_ptr = base_iface_to_point( ptr ); const char* result = null_point_ptr; if( casted_ptr-&gt;x || casted_ptr-&gt;y ) { result = some_point_ptr; } return result; } static point_ptr sizible_iface_to_point( sizible_iface_ptr ptr ); //  " "  sizible_iface static unsigned int point_get_size( sizible_iface_ptr ptr) { point_ptr casted_ptr = sizible_iface_to_point( ptr ); unsigned int size = (unsigned int)( sizeof( casted_ptr-&gt;x ) + sizeof( casted_ptr-&gt;y ) ); return size; } //   ""  point_t static void point_print_coordinates( point_ptr ptr ) { printf( "x = %u, y = %u\n", ptr-&gt;x, ptr-&gt;y ); } //  point_t //       (private)  point_t point_init( int x, int y ) { point_t point; point.get_name = point_get_name; point.get_size = point_get_size; point.print_coordinates = point_print_coordinates; point.x = x; point.y = y; return point; } //       enum { num_get_name_offset = 0, num_get_size_offset = sizeof( get_name_func_ptr ), }; //    static point_ptr base_iface_to_point( base_iface_ptr ptr ) { return (point_ptr)( (char*)ptr - num_get_name_offset ); } base_iface_ptr point_to_base_iface( point_ptr ptr ) { return (base_iface_ptr)( (char*)ptr + num_get_name_offset ); } static point_ptr sizible_iface_to_point( sizible_iface_ptr ptr ) { return (point_ptr)( (char*)ptr - num_get_size_offset ); } sizible_iface_ptr point_to_sizible_iface( point_ptr ptr ) { return (sizible_iface_ptr)( (char*)ptr + num_get_size_offset ); }</span></span></span></span></code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">3d_point.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"std.h"</span></span></span><span class="hljs-meta"> static d3_point_ptr base_iface_to_d3_point( base_iface_ptr ptr ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  " "  base_iface static const char* d3_point_get_name( base_iface_ptr ptr ) { static const char* null_point_ptr = "Null 3D point"; static const char* some_point_ptr = "Some 3D point"; d3_point_ptr casted_ptr = base_iface_to_d3_point( ptr ); const char* result = null_point_ptr; if( casted_ptr-&gt;x || casted_ptr-&gt;y || casted_ptr-&gt;z ) { result = some_point_ptr; } return result; } static d3_point_ptr sizible_iface_to_d3_point( sizible_iface_ptr ptr ); //  " "  sizible_iface static unsigned int d3_point_get_size( sizible_iface_ptr ptr) { d3_point_ptr casted_ptr = sizible_iface_to_d3_point( ptr ); unsigned int size = (unsigned int) ( sizeof( casted_ptr-&gt;x ) + sizeof( casted_ptr-&gt;y ) + sizeof( casted_ptr-&gt;z ) ); return size; } //   ""  d3_point_t static void d3_point_print_coordinates( d3_point_ptr ptr ) { printf( "x = %u, y = %u, z = %u\n", ptr-&gt;x, ptr-&gt;y, ptr-&gt;z ); } //  d3_point_t //       (private)  d3_point_t d3_point_init( int x, int y, int z ) { d3_point_t point; point.get_name = d3_point_get_name; point.get_size = d3_point_get_size; point.print_coordinates = d3_point_print_coordinates; point.x = x; point.y = y; point.z = z; return point; } //       enum { num_get_name_offset = sizeof( d3_point_print_coordinates_func ), num_get_size_offset = num_get_name_offset + sizeof( get_name_func_ptr ), }; //    static d3_point_ptr base_iface_to_d3_point( base_iface_ptr ptr ) { return (d3_point_ptr)( (char*)ptr - num_get_name_offset ); } base_iface_ptr d3_point_to_base_iface( d3_point_ptr ptr ) { return (base_iface_ptr)( (char*)ptr + num_get_name_offset ); } static d3_point_ptr sizible_iface_to_d3_point( sizible_iface_ptr ptr ) { return (d3_point_ptr)( (char*)ptr - num_get_size_offset ); } sizible_iface_ptr d3_point_to_sizible_iface( d3_point_ptr ptr ) { return (sizible_iface_ptr)( (char*)ptr + num_get_size_offset ); }</span></span></span></span></code> </pre><br></div></div><br>  So, all internal functions have the <b>static</b> specifier, which makes them invisible to the external user. <br><br>  The implementation of virtual methods is trivial: obtaining a pointer to an interface, we perform the work of the C ++ compiler: <br><ul><li>  calculate the virtual function offset in the virtual functions table (we did this through constants) </li><li>  subtract this offset from the filed pointer and bring the result to the pointer to the structure </li><li>  having a pointer to the whole structure, you can implement any functionality </li></ul><br>  In the examples given, the content of the ‚Äúvirtual methods‚Äù is somewhat strained.  The main thing is that within these "methods" we have access to <b>all</b> elements of the structure. <br><br><a name="Example"></a><h5>  Usage example </h5><br>  And now I will show you with an example of how you can take advantage of such virtuality. <br>  First you need to create a header file that will be used as a precompiled header: <br><div class="spoiler">  <b class="spoiler_title">std.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// system #include "stdio.h" // program #include "base_iface.h" #include "sizible_iface.h" #include "point.h" #include "3d_point.h"</span></span></span></span></code> </pre><br></div></div><div class="spoiler">  <b class="spoiler_title">std.s</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"std.h"</span></span></span></span></code> </pre><br></div></div><br>  And, actually, the example itself: <br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"std.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ,      base_iface void print_name( base_iface_ptr ptr ) { printf( "name = \"%s\"\n", ptr-&gt;get_name( ptr ) ); } // ,      sizible_iface void print_size( sizible_iface_ptr ptr ) { printf( "size = %u\n", ptr-&gt;get_size( ptr ) ); } int main( int argc, const char* argv[] ) { //    point_t null_point = point_init( 0, 0 ); point_t some_point = point_init( 1, 5 ); d3_point_t d3_null_point = d3_point_init( 0, 0, 0 ); d3_point_t d3_some_point = d3_point_init( 0, 1, 0 ); //      print_name( point_to_base_iface( &amp;null_point ) ); //      print_size( point_to_sizible_iface( &amp;null_point ) ); //    null_point.print_coordinates( &amp;null_point ); puts( "\n" ); //       print_name( point_to_base_iface( &amp;some_point ) ); print_size( point_to_sizible_iface( &amp;some_point ) ); some_point.print_coordinates( &amp;some_point ); puts( "\n" ); print_name( d3_point_to_base_iface( &amp;d3_null_point ) ); print_size( d3_point_to_sizible_iface( &amp;d3_null_point ) ); d3_null_point.print_coordinates( &amp;d3_null_point ); puts( "\n" ); print_name( d3_point_to_base_iface( &amp;d3_some_point ) ); print_size( d3_point_to_sizible_iface( &amp;d3_some_point ) ); d3_some_point.print_coordinates( &amp;d3_some_point ); puts( "\nPress any key to exit...\n" ); getchar(); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  There are a few explanations for example: we declared two functions that take pointers to interfaces.  Therefore, before submitting pointers to our structures to these functions, we bring these pointers to the required type. <br><br><a name="Conclustion"></a><h4>  findings </h4><br>  Compiling the source code in VS2010 (works with the compiler) and running the resulting program, we will see the following: <br><pre> <code class="hljs matlab">name = <span class="hljs-string"><span class="hljs-string">"Null point"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">size</span></span> = <span class="hljs-number"><span class="hljs-number">8</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span> name = <span class="hljs-string"><span class="hljs-string">"Some point"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">size</span></span> = <span class="hljs-number"><span class="hljs-number">8</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">5</span></span> name = <span class="hljs-string"><span class="hljs-string">"Null 3D point"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">size</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = <span class="hljs-number"><span class="hljs-number">0</span></span> name = <span class="hljs-string"><span class="hljs-string">"Some 3D point"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">size</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>, z = <span class="hljs-number"><span class="hljs-number">0</span></span> Press any key to exit...</code> </pre><br>  Works!  We have ‚Äúvirtual interfaces‚Äù, there is ‚Äúmultiple inheritance‚Äù and there is a proof-of-concept!  True, the code does not look as beautiful as we would like.  This is due to the fact that we have done some of the work that the compiler does for us in C ++: <br><ul><li>  cast </li><li>  working with the virtual method table </li><li>  passing the pointer to the same structure (the same this) inside </li></ul><br>  But in general, the application code does just what it wanted from him.  Where can I apply this virtuality?  For example, in a vector of structures of different nature, but implementing the same interface.  Or a few. <br>  Or in cryptography, when you can use a hash interface, generally having two methods: add more data and get a hash from the entered data. <br><br>  Well, the opportunity to simply create a structure, and then look at it (through the "." Operator), what capabilities it provides ("methods") with clear names of functions and a hint, what parameters need to be passed, I am impressed. <br><br><a name="Literature"></a><h4>  Related Literature </h4><br><ol><li>  <a href="http://bit.ly/T90E">Object-Oriented Programming With ANSI-C</a> ( <a href="http://habrahabr.ru/users/xana4ok/" class="user_link">xana4ok</a> ) </li><li>  Beautiful Code (Greg Kroah-Hartman ( <a href="http://habrahabr.ru/users/burjui/" class="user_link">burjui</a> )) </li></ol></div><p>Source: <a href="https://habr.com/ru/post/155439/">https://habr.com/ru/post/155439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155429/index.html">What do programmers do and how to explain it to the others?</a></li>
<li><a href="../155431/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ27 (October 13 - 19, 2012)</a></li>
<li><a href="../155433/index.html">Using the Internet to control robots from space</a></li>
<li><a href="../155435/index.html">Development of Unity3d-plugin for working with Facebook</a></li>
<li><a href="../155437/index.html">Calculated fields for any LINQ provider</a></li>
<li><a href="../155443/index.html">Microsoft refuses to install Verizon rootkit, Windows Phone 8 sales may be postponed</a></li>
<li><a href="../155445/index.html">An example of the development of simple casual games for Windows 8</a></li>
<li><a href="../155447/index.html">Custom CSS Filters</a></li>
<li><a href="../155449/index.html">Curiosity sent the first soil sample for internal research</a></li>
<li><a href="../155451/index.html">A scientific journal in mathematics accepted an article from the text generator Mathgen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>