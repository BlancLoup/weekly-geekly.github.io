<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Minimum possible font</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Task: using the smallest possible amount of resources, render a meaningful text. 


- How small can a readable font be? 
- How much memory will it tak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Minimum possible font</h1><div class="post__text post__text-html js-mediator-article"><p>  Task: using the smallest possible amount of resources, render a meaningful text. </p><br><ul><li>  How small can a readable font be? </li><li>  How much memory will it take to store it? </li><li>  How much code will it take to use it? </li></ul><br><p>  Let's see what we can do.  Spoiler: </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><a name="habracut"></a><br><h2 id="vvedenie-v-bitmepy">  Introduction to bitmaps </h2><br><p> Computers represent bitmaps as bitmaps.  This is not about <code>.bmp</code> format, but about how to store pixels in memory.  To understand what is happening, we need to know something about this way. </p><br><h3 id="sloi">  Layers </h3><br><p>  The image usually contains several <em>layers</em> located one on top of the other.  Most often they correspond to the coordinates of the <a href="https://en.wikipedia.org/wiki/RGB_color_space">RGB color space</a> .  One layer for <em>red</em> , one for <em>green</em> and one for <em>blue</em> .  If the image format supports transparency, then a fourth layer is created for it, usually called <em>alpha</em> .  Roughly speaking, a color image is three (or four, if there is an alpha channel) of black and white, located one above the other. </p><br><ul><li>  RGB is not the only color space;  JPEG format, for example, uses <a href="https://en.wikipedia.org/wiki/YUV">YUV</a> .  But in this article we will not need the other color spaces, so we do not consider them. </li></ul><br><p>  A set of layers can be represented in memory in two ways.  Either they are stored separately, or values ‚Äã‚Äãfrom different layers are interspersed.  In the latter case, the layers are called <em>channels</em> , and this is how most modern formats work. </p><br><p>  Suppose we have a 4x4 pattern containing three layers: <em>R</em> for red, <em>G</em> for green, and <em>B</em> for the blue component of each of the pixels.  It can be represented like this: </p><br><pre> <code class="plaintext hljs"> RRRR RRRR RRRR RRRR GGGG GGGG GGGG GGGG BBBB BBBB BBBB BBBB</code> </pre> <br><p>  All three layers are stored separately.  Interleaved format looks different: </p><br><pre> <code class="plaintext hljs"> RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><ul><li>  each triple character matches <strong>exactly</strong> one pixel </li><li>  values ‚Äã‚Äãwithin three are in the order of <em>RGB</em> .  Sometimes a different order may be used (for example, <em>BGR</em> ), but this one is the most common. </li></ul><br><p>  For simplicity, I arranged the pixels in the form of a two-dimensional matrix, because it is so clearer where one or another triple is in the image.  But in fact, the computer's memory is not two-dimensional, but one-dimensional, so the 4x4 picture will be stored like this: </p><br><pre> <code class="plaintext hljs">RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><h3 id="bpp">  bpp </h3><br><p>  The abbreviation <em>bpp</em> stands for the number of bits or bytes per pixel (bits / bytes per pixel).  You might have come across <code>24bpp</code> or <code>3bpp</code> .  These two characteristics mean the same thing - <strong>24 <em>bits</em> per pixel</strong> or <strong>3 <em>bytes</em> per pixel</strong> .  Since the byte is always 8 bits, by the magnitude of the value you can guess which of the units in question. </p><br><h3 id="predstavlenie-v-pamyati">  Memory view </h3><br><p>  <code>24bpp</code> , also <code>3bpp</code> as <code>3bpp</code> is the most common format for storing colors.  So at the level of individual bits looks <strong>one pixel</strong> in the order of <em>RGB</em> . </p><br><pre> <code class="plaintext hljs"> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  RRRRRRRRGGGGGGGGBBBBB BBB</code> </pre> <br><ul><li>  One byte for <em>R</em> , one for <em>G</em> and one for <em>B</em> , for a total of three bytes. </li><li>  Each of them contains a value from 0 to 255. </li></ul><br><p>  So if this pixel has the following color: </p><br><ul><li> <code>R 255</code> </li> <li> <code>G 80</code> </li> <li> <code>B 100</code> </li> </ul><br><p>  Then <code>255</code> is stored in the first byte, <code>80</code> in the second, and <code>100</code> in the third. </p><br><p>  Most often, these values ‚Äã‚Äãare represented in <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a> .  Say, <code>#ff5064</code> .  So much more convenient and more compact: <code>R = 0xff</code> (ie, <code>R=255</code> in the decimal representation), <code>G = 0x50</code> (= <code>G=80</code> ), <code>B=0x64</code> (= <code>B=100</code> ). </p><br><ul><li>  The hexadecimal representation has one useful property.  Since each byte of color is represented by two characters, each character encodes <strong>exactly</strong> half a byte, or four bits.  4 bits, by the way, are called <a href="https://en.wikipedia.org/wiki/Nibble">nibble</a> . </li></ul><br><h3 id="shirina-stroki">  Line width </h3><br><p>  When the pixels go one after another and each contains more than one channel, it is easy to get confused in the data.  It is not known when one line ends and the next one begins, therefore, in order to interpret a file with a bitmap, you need to know the image size and <em>bpp</em> .  In our case, the picture has a width <code>w = 4</code> pixels and each of these pixels contains 3 bytes, so the string is encoded 12 (in the general case, <code>w*bpp</code> ) bytes. </p><br><ul><li>  The string is not always encoded with exactly <code>w*bpp</code> bytes;  often hidden pixels are added to it to bring the width of the image to a certain size.  For example, it is faster and more convenient to scale pictures when their size in pixels is equal to a power of two.  Therefore, the file may contain (user-accessible) image of 120x120 pixels, but stored as an image of 128x128.  When displaying an image on the screen, these pixels are ignored.  However, we do not need to know about them. </li></ul><br><p>  The coordinate of any pixel <code>(x, y)</code> in the one-dimensional representation is <code>(y * w + x) * bpp</code> .  This, in general, is obvious: <code>y</code> is the line number, each line contains <code>w</code> pixels, so <code>y * w</code> is the beginning of the desired line, and <code>+x</code> takes us to the desired <code>x</code> within it.  And since the coordinates are not in bytes, but in pixels, it all multiplies by the pixel size <code>bpp</code> , in this case in bytes.  Since the pixel has a non-zero size, you need to read exactly <code>bpp</code> bytes, starting with the received coordinate, and we will have a complete representation of the desired pixel. </p><br><h2 id="atlas-shrifta">  Font atlas </h2><br><p>  Real-life monitors do not display a pixel as a whole, but three sub-pixels ‚Äî red, blue, and green.  If you look at the monitor under magnification, you will see something like this: </p><br><p><img src="https://habrastorage.org/webt/w8/nb/c9/w8nbc98aixpbrxgvffsccmxelyk.png"></p><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Subpixel_rendering">Wikipedia</a> picture </li></ul><br><p>  We are interested in LCD, because, most likely, it is from such a monitor that you read this text.  Of course, there are pitfalls: </p><br><ul><li>  Not all matrices use just such an order of subpixels, sometimes BGR. </li><li>  If you turn the monitor (for example, look at the phone in landscape orientation), the pattern will also rotate and the font will stop working. </li><li>  Different matrix orientations and sub-pixel locations will require reworking of the font itself. </li><li>  In particular, it does not work on <a href="https://en.wikipedia.org/wiki/AMOLED">AMOLED displays</a> using the <a href="https://en.wikipedia.org/wiki/PenTile_matrix_family">PenTile layout</a> .  Such displays are most often used in mobile devices. </li></ul><br><p>  The use of hack-related subpixels to increase resolution is called <a href="https://en.wikipedia.org/wiki/Subpixel_rendering">subpixel rendering</a> .  You can read about its use in typography, for example, <a href="https://www.grc.com/ctwhat.htm">here</a> . </p><br><p>  Fortunately for us, Matt Sarnoff already guessed using subpixel rendering to create a tiny <a href="http://www.msarnoff.org/millitext/">millitext</a> font.  Manually, he created this tiny picture: </p><br><p><img src="https://habrastorage.org/webt/p7/jk/xe/p7jkxececbln6pxlatfoa9kyymq.png"></p><br><p>  Which, if you look at the monitor very carefully, looks like this: </p><br><p><img src="https://habrastorage.org/webt/8n/wz/fq/8nwzfqilnvn_jronmwqbfnodllg.png"></p><br><p>  And here it is, programmatically enlarged 12 times: </p><br><p><img src="https://habrastorage.org/webt/fa/9p/us/fa9puspiilp5ip-50cuyxfyrdva.png"></p><br><p>  Based on his work, I created a font atlas, in which each character corresponds to a column of <code>1x5</code> pixels.  The order of characters is as follows: </p><br><pre> <code class="plaintext hljs">0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> </pre> <br><p><img src="https://habrastorage.org/webt/qe/ip/_v/qeip_vlwmjwfnnbbuz9cq6rhfn4.png"></p><br><p>  The same atlas, enlarged 12 times: </p><br><p><img src="https://habrastorage.org/webt/m3/ds/eg/m3dseggtbsmpgnmvlekvlz2aqow.png"></p><br><p>  With 36 characters used, it turns out exactly <code>365</code> pixels.  If we assume that each pixel occupies 3 bytes, then we need <code>36*5*3 = 540</code> bytes to store the entire drawing ( <em>note: in the original, an intricate series of edits about the alpha channel, removal of metadata, etc. n. In translation, I dropped it and use only the final version of the file</em> ).  PNG file passed through <a href="https://pmt.sourceforge.io/pngcrush/">pngcrush</a> and <a href="http://optipng.sourceforge.net/">optipng</a> takes even less: </p><br><pre> <code class="plaintext hljs"># wc -c &lt; font-crushed.png 390</code> </pre> <br><p>  But you can achieve even smaller if you use a slightly different approach. </p><br><h1 id="szhatie">  Compression </h1><br><p>  The attentive reader may have noticed that the atlas uses only 7 colors: </p><br><ol><li> <code>#ffffff</code> </li> <li> <code>#ff0000</code> </li> <li> <code>#00ff00</code> </li> <li> <code>#0000ff</code> </li> <li> <code>#00ffff</code> </li> <li> <code>#ff00ff</code> </li> <li> <code>#ffff00</code> </li> </ol><br><h2 id="palitra">  Palette </h2><br><p>  In such situations it is often easier to create a palette.  Then for each pixel you can store not three bytes of color, but only the number of color in the palette.  In our case, 3 bits will be enough to choose from 7 colors ( <code>7 &lt; 2^3</code> ).  If each pixel is mapped to a three-bit value, then the entire atlas will fit in <em>68 bytes</em> . </p><br><ul><li>  A reader who understands data compression can answer that there is generally such a thing as ‚Äúfractional bits‚Äù and in our case, <strong>2.875 bits per pixel</strong> is enough.  This density can be achieved with the help of black magic, known as <a href="https://en.wikipedia.org/wiki/Arithmetic_coding">arithmetic coding</a> .  We will not do this, because arithmetic coding is a complicated thing, and 68 bytes are so little. </li></ul><br><h2 id="vyravnivanie">  Alignment </h2><br><p>  Three-bit coding has one serious drawback.  Pixels cannot be evenly distributed over 8-bit bytes, which is important because byte is the minimum addressable memory location.  Suppose we want to keep three pixels: </p><br><pre> <code class="plaintext hljs">ABC</code> </pre> <br><p>  If everyone takes 3 bits, then they will take 2 bytes to store ( <code>-</code> denotes unused bits): </p><br><pre> <code class="plaintext hljs">bit 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pixel AAABBBCCC - - - - - - -</code> </pre> <br><p>  What's important, the <strong>C</strong> pixel doesn't just leave a bunch of empty space;  it is <em>broken</em> between two bytes.  When we start to add the following pixels, they can be located arbitrarily relative to the boundaries of the bytes.  The simplest solution is to use nibbls per pixel, because 8 is perfectly divided by 4 and allows you to place exactly two pixels in each byte.  But it will increase the size of the atlas by a third, from <strong>68 bytes</strong> to <strong>90 bytes</strong> . </p><br><ul><li>  In fact, the file can be made even smaller using palindrome coding, interval coding, and other compression techniques.  Like arithmetic coding, we will postpone these techniques until the next article. </li></ul><br><h2 id="bitovyy-bufer">  Bit buffer </h2><br><p>  Fortunately, there is nothing fundamentally impossible to work with 3-bit values.  You just need to keep track of what position inside the byte we are writing or reading at the moment.  The following simple class converts a 3-bit data stream into a byte array. </p><br><ul><li>  For readability reasons, the code is written in JS, but the same method is generalized to other languages. </li><li>  Uses order from low byte to high ( <a href="https://en.wikipedia.org/wiki/Endianness">Little Endian</a> ) </li></ul><br><pre> <code class="plaintext hljs">class BitBuffer { constructor(bytes) { this.data = new Uint8Array(bytes); this.offset = 0; } write(value) { for (let i = 0; i &lt; 3; ) { // bits remaining const remaining = 3 - i; // bit offset in the byte ie remainder of dividing by 8 const bit_offset = this.offset &amp; 7; // byte offset for a given bit offset, ie divide by 8 const byte_offset = this.offset &gt;&gt; 3; // max number of bits we can write to the current byte const wrote = Math.min(remaining, 8 - bit_offset); // mask with the correct bit-width const mask = ~(0xff &lt;&lt; wrote); // shift the bits we want to the start of the byte and mask off the rest const write_bits = value &amp; mask; // destination mask to zero all the bits we're changing first const dest_mask = ~(mask &lt;&lt; bit_offset); value &gt;&gt;= wrote; // write it this.data[byte_offset] = (this.data[byte_offset] &amp; dest_mask) | (write_bits &lt;&lt; bit_offset); // advance this.offset += wrote; i += wrote; } } to_string() { return Array.from(this.data, (byte) =&gt; ('0' + (byte &amp; 0xff).toString(16)).slice(-2)).join(''); } };</code> </pre> <br><p>  Let's load and encode the file with the atlas: </p><br><pre> <code class="plaintext hljs">const PNG = require('png-js'); const fs = require('fs'); // this is our palette of colors const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // given a color represented as [R, G, B], find the index in palette where that color is function find_palette_index(color) { const [sR, sG, sB] = color; for (let i = 0; i &lt; Palette.length; i++) { const [aR, aG, aB] = Palette[i]; if (sR === aR &amp;&amp; sG === aG &amp;&amp; sB === aB) { return i; } } return -1; } // build the bit buffer representation function build(cb) { const data = fs.readFileSync('subpixels.png'); const image = new PNG(data); image.decode(function(pixels) { // we need 3 bits per pixel, so w*h*3 gives us the # of bits for our buffer // however BitBuffer can only allocate bytes, dividing this by 8 (bits for a byte) // gives us the # of bytes, but that division can result in 67.5 ... Math.ceil // just rounds up to 68. this will give the right amount of storage for any // size atlas. let result = new BitBuffer(Math.ceil((image.width * image.height * 3) / 8)); for (let y = 0; y &lt; image.height; y++) { for (let x = 0; x &lt; image.width; x++) { // 1D index as described above const index = (y * image.width + x) * 4; // extract the RGB pixel value, ignore A (alpha) const color = Array.from(pixels.slice(index, index + 3)); // write out 3-bit palette index to the bit buffer result.write(find_palette_index(color)); } } cb(result); }); } build((result) =&gt; console.log(result.to_string()));</code> </pre> <br><p>  As expected, the atlas fit <strong>68 bytes</strong> , which is 6 times smaller than the PNG file. </p><br><p>  ( <em>note: the author is somewhat cunning: he did not save the palette and image size, which according to my estimates would require 23 bytes with a fixed palette size and increase the image size to 91 bytes</em> ) </p><br><p>  Now let's convert the image to a string so that it can be inserted into the source code.  Essentially, the <code>to_string</code> method <code>to_string</code> this: it represents the contents of each byte as a hexadecimal number. </p><br><pre> <code class="plaintext hljs">305000000c0328d6d4b24cb46d516d4ddab669926a0ddab651db76150060009c0285 e6a0752db59054655bd7b569d26a4ddba053892a003060400d232850b40a6b61ad00</code> </pre> <br><p>  But the resulting string is still quite long, because we have limited ourselves to an alphabet of 16 characters.  You can replace it with <a href="https://en.wikipedia.org/wiki/Base64">base64</a> , in which there are four times more characters. </p><br><pre> <code class="plaintext hljs">to_string() { return Buffer.from(this.data).toString('base64'); }</code> </pre> <br><p>  The base64 atlas looks like this: </p><br><pre> <code class="plaintext hljs">MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=</code> </pre> <br><p>  This string can be hard-coded into the JS-module and used for rasterizing the text. </p><br><h1 id="rasterizaciya">  Rasterization </h1><br><p>  To save memory, only one letter will be decoded at a time. </p><br><pre> <code class="plaintext hljs">const Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const Atlas = Uint8Array.from(Buffer.from('MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=', 'base64')); const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // at the given bit offset |offset| read a 3-bit value from the Atlas read = (offset) =&gt; { let value = 0; for (let i = 0; i &lt; 3; ) { const bit_offset = offset &amp; 7; const read = Math.min(3 - i, 8 - bit_offset); const read_bits = (Atlas[offset &gt;&gt; 3] &gt;&gt; bit_offset) &amp; (~(0xff &lt;&lt; read)); value |= read_bits &lt;&lt; i; offset += read; i += read; } return value; }; // for a given glyph |g| unpack the palette indices for the 5 vertical pixels unpack = (g) =&gt; { return (new Uint8Array(5)).map((_, i) =&gt; read(Alphabet.length*3*i + Alphabet.indexOf(g)*3)); }; // for given glyph |g| decode the 1x5 vertical RGB strip decode = (g) =&gt; { const rgb = new Uint8Array(5*3); unpack(g).forEach((value, index) =&gt; rgb.set(Palette[value], index*3)); return rgb; }</code> </pre> <br><p>  The <code>decode</code> function takes a character as input and returns the corresponding column in the source image.  It is impressive here that decoding one character takes only <strong>5 bytes of</strong> memory, plus <strong>~ 1.875</strong> bytes to read the required piece of the array, i.e.  on average <strong>6.875</strong> per letter.  If you add <strong>68 bytes</strong> to the storage of the array and <strong>36 bytes</strong> to the storage of the alphabet, you can <em>theoretically</em> render the text with 128 bytes of RAM. </p><br><ul><li>  This is possible if you rewrite the code in C or assembler.  Against the background of the overhead projector, JS saves on matches. </li></ul><br><p>  It remains only to put these columns together and return the image with the text. </p><br><pre> <code class="plaintext hljs">print = (t) =&gt; { const c = t.toUpperCase().replace(/[^\w\d ]/g, ''); const w = c.length * 2 - 1, h = 5, bpp = 3; // * 2 for whitespace const b = new Uint8Array(w * h * bpp); [...c].forEach((g, i) =&gt; { if (g !== ' ') for (let y = 0; y &lt; h; y++) { // copy each 1x1 pixel row to the the bitmap b.set(decode(g).slice(y * bpp, y * bpp + bpp), (y * w + i * 2) * bpp); } }); return {w: w, h: h, data: b}; };</code> </pre> <br><p>  This will be the minimum possible font. </p><br><pre> <code class="plaintext hljs">const fs = require('fs'); const result = print("Breaking the physical limits of fonts"); fs.writeFileSync(`${result.w}x${result.h}.bin`, result.data);</code> </pre> <br><p>  Add a little <a href="https://imagemagick.org/index.php">imagemagick</a> to get the image in a readable format: </p><br><pre> <code class="plaintext hljs"># convert -size 73x5 -depth 8 rgb:73x5.bin done.png</code> </pre> <br><p>  And here is the final result: </p><br><p><img src="https://habrastorage.org/webt/jv/lf/gs/jvlfgsoyr4xbnxsbzuzax3shp4s.png"></p><br><p>  It is increased 12 times: </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><br><p>  It is also a macro shot from a poorly calibrated monitor: </p><br><p><img src="https://habrastorage.org/webt/pd/qp/li/pdqplibvzty8wtoxosah5d3phxe.png"></p><br><p>  And finally, it is better on the monitor: </p><br><p><img src="https://habrastorage.org/webt/ge/oz/rh/geozrhsclx2squmratxt8flet1a.png"></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460697/">https://habr.com/ru/post/460697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../46068/index.html">Formatting Long SQL Queries</a></li>
<li><a href="../460683/index.html">Laravel Event Projector and Event Generation Concept</a></li>
<li><a href="../460685/index.html">Distributing files from Google Drive via nginx</a></li>
<li><a href="../460687/index.html">How do the banks from the inside</a></li>
<li><a href="../460695/index.html">What is DAA, and how does this system help drones?</a></li>
<li><a href="../460699/index.html">Habr Weekly # 10 / Superservices and e-passport, smartphones and Russians, ‚Äúspy gadgets‚Äù, life without satellites</a></li>
<li><a href="../4607/index.html">"Thousands of" leave social networks</a></li>
<li><a href="../460701/index.html">The course "Start in Data Science": the first step in working with data</a></li>
<li><a href="../460703/index.html">Blue Ocean of opportunities: from scratch to 400 thousand video interviews</a></li>
<li><a href="../460707/index.html">Is it time for game developers to stop listening to their fans?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>