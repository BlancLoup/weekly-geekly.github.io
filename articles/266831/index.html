<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PE (Portable Executable): On Stranger Tides</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a story about how the executable files are arranged (to the point! These are the very things that are obtained after compiling applica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PE (Portable Executable): On Stranger Tides</h1><div class="post__text post__text-html js-mediator-article"><img width="400" height="300" src="https://habrastorage.org/files/fde/de5/8c7/fdede58c71204576a5040dbc53087833.jpg"><br><br>  This article is a story about how the executable files are arranged (to the point! These are the very things that are obtained after compiling applications with the .exe extension).  After the code is written, the libraries are connected, resources are loaded to the project (icons for windows, any text files, pictures, etc.), all of this is put together in one single executable file, mainly with the .exe extension.  That's it in this pool we dive. <br>  <i>* The article is under the auspices of "for beginners" and therefore will be replete with diagrams and descriptions of important elements of the load.</i> <br><a name="habracut"></a><br><h4>  Introduction </h4><br><img width="300" height="200" src="https://habrastorage.org/files/a1c/6c4/33c/a1c6c433c79e4816b8d0af972d256ef3.jpg"><br><br>  PE format is the format of executable files of all 32-bit and 64-bit Windows systems.  Currently there are two PE file formats: PE32 and PE32 +.  PE32 format for x86 systems, and PE32 + for x64.  The structures described can be seen in the <a href="">WINNT.h</a> header file that comes with the SDK.  A description of this format from microsoft can be downloaded <a href="https://msdn.microsoft.com/en-us/windows/hardware/gg463119.aspx">here</a> , but for now I‚Äôll leave a little schematic representation here.  Just run over your eyes, in the process of the article you will begin to grasp and everything will decompose on the shelves. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/e13/25b/7f0/e1325b7f099c426c88c722d765dbe8a4.gif"><br><br>  Any file, it is only a sequence of bytes.  And the format is like a special map (treasure) for it.  That is, it shows what is where, where are the islands with coconuts, where with bananas, where the sandy shores are, and where are the Somali ones, where it‚Äôs better not to go.  So let's explore the wide open spaces of this ocean.  Give off the moorings! <br><br><blockquote>  ‚ÄúNow you will hear a sad story.  about boy bobby <br>  (Treasure Island) </blockquote><br><h4>  Dos-Header (IMAGE_DOS_HEADER) and Dos-stub </h4><br><img width="300" height="200" src="https://habrastorage.org/files/335/6b9/216/3356b921699a4fc68b5558cc20f411d0.jpg"><br><br>  Dos title.  This is the very first structure (the very first island we met on the way) in the file and it is 64 bytes in size.  In this structure, the most important fields are <i>e_magic</i> and <i>e_lfnew</i> .  Let's see how the structure looks like: <br><br><img src="https://habrastorage.org/files/1f6/433/7db/1f64337db8d74d208557487895cf4b5c.png"><br><br>  To study all the fields at this stage is useless.  they don‚Äôt carry much meaning.  Consider only those that are necessary for download and are of particular interest.  (Further and below in the text, the format of the field description will be of the form <i>name</i> : TYPE - description). <br><br>  <i>e_magic</i> : WORD is the signature located at offset 0 from the beginning of the file and equal to ‚ÄúMZ‚Äù.  Rumor has it that MZ's abbreviation for Mark Zbinovski is the <s>most vicious pirate in the entire water space, the</s> leading developer of MS DOS and EXE format.  If this signature is not equal to MZ, then the file will not load. <br><br>  <i>e_lfnew</i> : DWORD - offset of the PE header relative to the beginning of the file.  A PE header should start with a signature (signature / signature) PE \ x0 \ x0.  PE header can be located anywhere in the file.  If you look at the structure, you can see that <i>e_lfnew</i> is at offset 0x3C (60 in decimal).  That is, in order to read this value, we have to ‚Äúadd‚Äù 60 bytes from the pointer to the beginning of the file (we introduce the notation - <u>ptrFile</u> ) and then we face face to face before e_lfnew.  We read this value (let it be <u>peStep</u> ) and add the value <u>peStep</u> to <u>ptrFile</u> .  Mission completed - we are the boss, this should be a PE header.  And we can certainly find out by checking the first four bytes of this header.  As mentioned above, they should be equal to PE \ x0 \ x0. <br><br>  After the first 64 bytes of the file, dos-stub starts (pirates also call it dos stub).  This area in memory is mostly filled with zeros.  (Take another look at the structure - the stub lies after the dos-header (a) and before the PE header) It serves only for backward compatibility; it does not need anything for current systems.  It can contain a mini version of the dos program limited to 192 bytes (256 is the end of the stub, 64 is the size of the dos header).  But it is easier to find an Access Point in Zimbabwe than such a program.  Standard behavior, if you run a program on dos, it will display messages like ‚ÄúThis program cannot be run in DOS mode.‚Äù Or ‚ÄúThis program must be run under win32‚Äù.  If you see these lines, it means that you have fallen ... to the distant 85th. <br><br><img width="80%" height="80%" src="https://habrastorage.org/files/cd2/79a/b6b/cd279ab6b9f347bc897423ad76385b75.PNG"><br><br><blockquote>  ‚ÄúTo hell with money, I'm talking about Flint's papers!‚Äù <br>  (Treasure Island) </blockquote><br><h4>  PE-Header (IMAGE_NT_HEADER) </h4><br><img width="300" height="200" src="https://habrastorage.org/files/a61/9cd/482/a619cd482fbb402ebcbad0f2fc59684f.jpg"><br><br>  Read <i>e_lfnew</i> , retreated from the beginning of the file to <u>peStep</u> bytes.  Now we can begin to analyze the PE header.  This is a new island for us and it should be located in the following 0x18 bytes.  <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms680336(v%3Dvs.85).aspx">The structure</a> is presented below: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_NT_HEADERS</span></span></span><span class="hljs-class"> {</span></span> DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER OptionalHeader; } IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;</code> </pre> <br>  This is an interesting structure, because  it contains substructures.  If you represent a PE file as an ocean, each structure is a mainland (or island).  On the continents there are states that can tell about their territory.  And the story is made up of the history of individual cities (fields) in this state.  So - NT Header - this is the mainland, which contains countries such as Signature (city-state), FileHeader, OptionalHeader.  As already mentioned, <i>Signature</i> : DWORD contains a 4-byte signature that characterizes the file format.  Consider what else this continent can tell us. <br><br><h4>  File Header (IMAGE_FILE_HEADER) </h4><br>  This is a country <s>where they always shoot, trade in drugs and engage in prostitution</s> where each city tells in which ideal state it is located.  This is with regard to the informal description, and the formal is as follows - a set of fields that describes the basic characteristics of the file.  Let's consider this <s>power</s> <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms680313(v%3Dvs.85).aspx">structure</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_FILE_HEADER</span></span></span><span class="hljs-class"> {</span></span> WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</code> </pre><br>  I just dryly describe these fields, because  The names are intuitive and are immediate meanings, and not VA, RVA, RAW, and other <s>terrible</s> intriguing things that we have only heard about from old pirates.  Although we have already encountered RAW, these are just offsets relative to the beginning of the file (they are also called raw pointers or file offset).  That is, if we have a RAW address, this means that we need to step from the beginning of the file to the RAW positions ( <u>ptrFile</u> + RAW).  Then you can start reading the values.  A prime example of this type is <i>e_lfnew</i> - which we covered above in the Dos header. <br><br>  * <i>Machine</i> : WORD is a number (2 bytes) specifies the processor architecture on which this application can run. <br>  <i>NumberOfSections</i> : DWORD - the number of sections in the file.  Sections (further we will call the section table) follow immediately after the header (PE-Header).  The documentation says that the number of sections is limited to 96. <br>  <i>TimeDateStamp</i> : WORD - the number storing the date and time of file creation. <br>  <i>PointerToSymbolTable</i> : DWORD is the offset (RAW) to the symbol table, and SizeOfOptionalHeader is the size of this table.  This table is designed to serve to store debug information, but the squad did not notice the loss of a fighter from the very beginning of the service.  Most often, this field is cleared with zeros. <br>  <i>SIzeOfOptionHeader</i> : WORD - the size of the optional header (which immediately follows the current one) The documentation indicates that it is set to 0 for the object file ... <br>  * <i>Characteristics</i> : WORD - file characteristics. <br><br>  * - fields that are defined by a range of values.  Tables of possible values ‚Äã‚Äãare presented in the description of the structure at the office.  site and will not be listed here, because  nothing particularly important for understanding the format they do not carry. <br><br>  Leave this island!  We need to move on.  Landmark - a country called Optional-Header. <br><br><blockquote>  ‚Äú- Where is the card, Billy?  I need a map. ‚Äù <br>  (Treasure Island) </blockquote><br><h4>  Optional-Header (IMAGE_OPTIONAL_HEADER) </h4><br><br><img width="300" height="200" src="https://habrastorage.org/files/c38/809/d1d/c38809d1da5a4227acf9600ad82d04e3.jpg"><br><br>  The name of <s>this continent</s> title is not very successful.  This header is mandatory and has 2 formats PE32 and PE32 + (IMAGE_OPTIONAL_HEADER32 and IMAGE_OPTIONAL_HEADER64, respectively).  The format is stored in the <i>Magic</i> : WORD field.  The header contains the necessary information to download the file.  <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms680339(v%3Dvs.85).aspx">As always</a> : <br><br><div class="spoiler">  <b class="spoiler_title">IMAGE_OPTIONAL_HEADER</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_OPTIONAL_HEADER</span></span></span><span class="hljs-class"> {</span></span> WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADE R, *PIMAGE_OPTIONAL_HEADER;</code> </pre><br></div></div><br>  * As always, we will study only the main fields that have the greatest impact on the idea of ‚Äã‚Äãloading and how to move further along the file.  Let's agree - in the fields of this structure, contain values ‚Äã‚Äãwith VA (Virtual address) and RVA (Relative virtual address) addresses.  These are already addresses not similar to RAW, and they need to be able to read (more precisely, to read).  We will certainly learn how to do it, but first we will analyze the structures that follow each other in order not to get confused.  For now, just remember - these are addresses that, after calculations, indicate a specific place in the file.  Also meet a new concept - alignment.  We will consider it in a compartment with RVA addresses, since  these are rather closely related. <br><br>  <i>AddressOfEntryPoint</i> : DWORD - RVA address of the entry point.  Can point to any point in the address space.  For .exe files, the entry point corresponds to the address from which the program starts to run and cannot be zero! <br>  <i>BaseOfCode</i> : DWORD - RVA of the beginning of the program code (code section). <br>  <i>BaseOfData</i> : DWORD - RVA of the beginning of the program code (data section). <br>  <i>ImageBase</i> : DWORD is the preferred base address for loading the program.  Must be a multiple of 64kb.  In most cases, equal to 0x00400000. <br>  <i>SectionAligment</i> : DWORD - the size of the alignment (bytes) of the section when unloaded into virtual memory. <br>  <i>FileAligment</i> : DWORD - the size of the alignment (bytes) of the section within the file. <br>  <i>SizeOfImage</i> : DWORD - the size of the file (in bytes) in memory, including all headers.  Must be a multiple SectionAligment. <br>  <i>SizeOfHeaders</i> : DWORD - the size of all headers (DOS, DOS-Stub, PE, Section) aligned with FileAligment. <br>  <i>NumberOfRvaAndSizes</i> : DWORD - the number of directories in the directory table (below the table itself).  At the moment, this field is always equal to the symbolic IMAGE_NUMBEROF_DIRECTORY_ENTRIES constant, which is 16. <br>  <i>DataDirectory</i> [NumberOfRvaAndSizes]: IMAGE_DATA_DIRECTORY - data directory.  Simply put, this is an array (size 16), each element of which contains a structure of two DWORD values. <br><br>  Consider what the <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms680305(v%3Dvs.85).aspx">IMAGE_DATA_DIRECTORY structure is</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_DATA_DIRECTORY</span></span></span><span class="hljs-class"> {</span></span> DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</code> </pre><br>  What we have?  We have an array of 16 elements, each element of which contains the address and size (what? How? Why? All in a minute).  The question is what exactly these characteristics are.  For this, microsoft has special constants to match.  They can be seen at the very end of the structure description.  For now: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Directory Entries #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor</span></span></code> </pre><br>  Aha  We see that each element of the array is responsible for the table attached to it.  But alas, while these shores are beyond our reach, because  We do not know how to work with VA and RVA addresses.  And in order to learn, we need to learn what sections are.  They will tell about their structure and work, after which it will become clear why VA, RVA and alignments are needed.  In this article, we will only cover export and import.  The purpose of the remaining fields can be found in the office.  documentation, or in books.  So here.  Actually fields: <br><br>  <i>VirtualAddress</i> : DWORD - RVA per table, which corresponds to the array element. <br>  <i>Size</i> : DWORD - the size of the table in bytes. <br><br>  So!  To get to such exotic beaches as tables of imports, exports, resources and others, we need to complete a quest with sections.  Well, young boy, let's take a look at the general map, determine where we are and move on: <br><br><img src="https://habrastorage.org/files/8a9/173/085/8a91730850d6439b9757fc9e925b6d1c.jpg"><br><br>  And we are not directly in front of the wide spaces of the sections.  We need to certainly elicit what they are doing and finally deal with a different kind of addressing.  We want real adventures!  We want to go to such republics as import and export tables as soon as possible.  The old pirates say that not everyone could get to them, and the one who got <s>back came with gold and women</s> with sacred knowledge about the ocean.  We leave and keep the path to the Section header. <br><br><blockquote>  ‚Äú- You are deposed, Silver!  Get down from the barrel! ‚Äù <br>  (Treasure Island) </blockquote><br><h4>  Section-header (IMAGE_SECTION_HEADER) </h4><br><img width="300" height="200" src="https://habrastorage.org/files/80c/36f/fe2/80c36ffe20054f70ba49f52b550ae126.jpg"><br><br>  Right after the <i>DataDirectory</i> array, <i>sections follow</i> one another.  The table of sections is a sovereign state, which is divided into the <i>NumberOfSections of</i> cities.  Each city has its own craft, its own rights, as well as the size of 0x28 bytes.  The number of sections is indicated in the <i>NumberOfSections</i> field, which is stored in the File-header-e.  So, consider the <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms680341(v%3Dvs.85).aspx">structure</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_SECTION_HEADER</span></span></span><span class="hljs-class"> {</span></span> BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</code> </pre><br>  <i>Name</i> : BYTE [IMAGE_SIZEOF_SHORT_NAME] - section name.  Currently has a length of 8 characters. <br>  <i>VirtualSize</i> : DWORD - section size in virtual memory. <br>  <i>SizeOfRawData</i> : DWORD - the size of the section in the file. <br>  <i>VirtualAddress</i> : DWORD - RVA section address. <br>  <i>SizeOfRawData</i> : DWORD - the size of the section in the file.  Must be a multiple <i>FileAligment</i> . <br>  <i>PointerToRawData</i> : DWORD - RAW offset to the beginning of the section.  It must also be a multiple of <i>FileAligment</i> ... <br>  <i>Characteristics</i> : DWORD - section access attributes and rules for its loading into virtual.  memory.  For example, an attribute to determine the contents of a section (initial. Data, not initial. Data, code).  Or access attributes - read, write, execute.  This is not their full range.  Characteristics are given by constants from the same WINNT.h, which begin with IMAGE_SCN_.  More details about the attributes of sections can be <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms680341(v%3Dvs.85).aspx">here</a> .  Attributes are also well described in the books of Chris Kaspersky - the list of references at the end of the article. <br><br>  Regarding the name, you should remember the following - the section with resources should always be named .rsrc.  Otherwise, the resources will not be loaded.  As for the rest of the sections - that name can be anything.  Usually there are meaningful names, such as .data, .src, etc ... But this also happens: <br><br><img width="80%" height="80%" src="https://habrastorage.org/files/2a0/b42/392/2a0b42392cbc4559a6279cee6084a262.png"><br><br>  Sections, this is an area that is unloaded into virtual memory and all work happens directly with this data.  The address in virtual memory without any offsets is called Virtual address, abbreviated VA.  The preferred address for downloading the application is set in the <i>ImageBase</i> field.  This is like the point from which the application area begins in virtual memory.  And relative to this point, RVA (Relative virtual address) offsets are counted.  That is, VA = <i>ImageBase</i> + RVA;  <i>ImageBase</i> is always known to us and having received VA or RVA at our disposal, we can express one through the other. <br><br>  It seems to have settled down.  But this is virtual memory!  And then we are in the physical.  Virtual memory for us now is like traveling to other galaxies, which we can only imagine.  So we don‚Äôt get into virtual memory at the moment, but we can find out what will be there, because it‚Äôs taken from our file. <br><br><h4>  Alignment </h4><br><img width="300" height="200" src="https://habrastorage.org/files/3c4/fc8/e08/3c4fc8e08ad442d5b1a953e3c33a35ed.jpg"><br><br>  In order to properly represent the discharge in Wirth.  memory, you need to deal with such a mechanism as alignment.  First, let's take a look at the diagram of how sections are unloaded into memory. <br><br><img src="https://habrastorage.org/files/7b9/8ce/fe9/7b98cefe95e94c45a2aed95ea7dd36e9.png"><br><br>  As you can see, the section is not being unloaded into memory in size.  Alignments are used here.  This is a value that must be a multiple of the size of the section in memory.  If you look at the scheme, we will see that the size of the section is 0x28, and it is unloaded in the amount of 0x50.  This is due to the size of the alignment.  0x28 ‚Äúdoes not reach‚Äù up to 0x50 and as a result, the section will be unloaded, and the rest of the space in the amount of 0x50-0x28 will vanish.  And if the section size would be larger than the alignment size, then what?  For example, <u>sectionSize</u> = 0x78, and <u>sectionAligment</u> = 0x50, i.e.  remained unchanged.  In this case, the section would occupy 0xA0 (0xA0 = 0x28 * 0x04) bytes in memory.  That is, a value that is a multiple of <u>sectionAligment</u> and fully covers <u>sectionSize</u> .  It should be noted that sections in the file are aligned in a similar way, only by the size of <i>FileAligment</i> .  Having obtained the necessary base, we can figure out how to convert from RVA to RAW. <br><br><blockquote>  ‚ÄúThis is not a plain here, the climate is different here.‚Äù <br>  (V.S. Vysotsky) </blockquote><br><h4>  A little lesson in arithmetic </h4><br><img width="300" height="200" src="https://habrastorage.org/files/46a/327/5b7/46a3275b75c8450090625c7cd181d135.jpg"><br><br>  Before starting execution, some part of the program must be sent to the address space of the processor.  The address space is the amount of RAM physically addressed by the processor.  The ‚Äúpiece‚Äù in the address space where the program is unloaded is called a virtual image (virtual image).  The image is characterized by the address of the base load (Image base) and size (Image size).  So, VA (Virtual address) is an address relative to the beginning of virtual memory, and RVA (Relative Virtual Address) is relative to the place where the program was downloaded.  How to find out the base download address of the application?  To do this, there is a separate field in the optional header called <i>ImageBase</i> .  It was a small prelude to brush up on.  Now consider a schematic representation of different addresses: <br><br><img src="https://habrastorage.org/files/933/66a/c43/93366ac439754f9ab80261139435ad31.png"><br><br>  Duck, how does one read the information from a file without unloading it into virtual memory?  To do this, you need to convert addresses to RAW format.  Then we can step inside the file to the area we need and read the necessary data.  Since RVA is an address in virtual memory, the data for which were projected from a file, we can reverse the process.  For this we need the <s>key nine for sixteen</s> simple arithmetic.  Here are a few formulas: <br><br><pre> <code class="cpp hljs">VA = ImageBase + RVA; RAW = RVA - sectionRVA + rawSection; <span class="hljs-comment"><span class="hljs-comment">// rawSection -       // sectionRVA - RVA  (    )</span></span></code> </pre><br>  As you can see, in order to calculate RAW, we need to determine the section that owns the RVA.  To do this, go through all sections and check the following conditions: <br><br><pre> <code class="cpp hljs">RVA &gt;= sectionVitualAddress &amp;&amp; RVA &lt; ALIGN_UP(sectionVirtualSize, sectionAligment) <span class="hljs-comment"><span class="hljs-comment">// sectionAligment -   .     Optional-header. // sectionVitualAddress - RVA  -     // ALIGN_UP() - ,      ,  </span></span></code> </pre><br>  Putting all the puzzles together, we‚Äôll get this listing: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> DWORD; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> WORD; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> BYTE; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ALIGN_DOWN(x, align) (x &amp; ~(align-1)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ALIGN_UP(x, align) ((x &amp; (align-1))?ALIGN_DOWN(x,align)+align:x) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// IMAGE_SECTION_HEADER sections[numbersOfSections]; // init array sections int defSection(DWORD rva) { for (int i = 0; i &lt; numberOfSection; ++i) { DWORD start = sections[i].VirtualAddress; DWORD end = start + ALIGN_UP(sections[i].VirtualSize, sectionAligment); if(rva &gt;= start &amp;&amp; rva &lt; end) return i; } return -1; } DWORD rvaToOff(DWORD rva) { int indexSection = defSection(rva); if(indexSection != -1) return rva - sections[indexSection].VirtualAddress + sections[indexSection].PointerToRawData; else return 0; }</span></span></span></span></code> </pre><br>  * I did not include in the code type declaration, and array initialization, but only provided functions that will help in calculating addresses.  As you can see, the code is not very complicated.  Is that a little confusing.  This passes ... if you take a little more time to pop up into the .exe through the disassembler. <br><br>  HOORAY!  Understood.  Now we can go to the edges of resources, libraries of import and export, and in general where the soul wants.  We just learned to work with a new type of addressing.  Let's hit the road! <br><br><blockquote>  "-Not bad, not bad!  Yet they got their ration today! ‚Äù <br>  (Treasure Island) </blockquote><br><h4>  Export table </h4><br><img width="300" height="200" src="https://habrastorage.org/files/3e2/927/e7f/3e2927e7ff524a79a0d96fccf8206191.jpg"><br><br>  In the very first element of the <i>DataDirectory</i> array, the <i>RVA</i> is stored on the export table, which is represented by the IMAGE_EXPORT_DIRECTORY structure.  This table is characteristic of dynamic library files (.dll).  The main task of the table is to link the exported functions with their RVA.  Description presented in the <a href="https://msdn.microsoft.com/en-us/library/ms809762.aspx">office.</a>  <a href="https://msdn.microsoft.com/en-us/library/ms809762.aspx">Specifications</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_EXPORT_DIRECTORY</span></span></span><span class="hljs-class"> {</span></span> DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; DWORD Base; DWORD NumberOfFunctions; DWORD NumberOfNames; DWORD AddressOfFunctions; DWORD AddressOfNames; DWORD AddressOfNameOrdinals; } IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</code> </pre><br>  This structure contains three pointers to three different tables.  This is a table of names (functions) ( <i>AddressOfNames</i> ), ordinals ( <i>AddressOfNamesOrdinals</i> ), addresses ( <i>AddressOfFunctions</i> ).  The Name field stores the RVA of the dynamic library name.  The ordinal is like an intermediary, between the name table and the address table, and is an array of indices (the size of the index is 2 bytes).  For greater clarity, consider the scheme: <br><br><img src="https://habrastorage.org/files/2a2/26d/7ad/2a226d7ad9b04e2aa96672599281c60c.gif"><br><br>  Consider an example.  Suppose the i-th element of the array of names indicates the name of the function.  Then the address of this function can be obtained by referring to the i-th element in the array of addresses.  Those.  i is the ordinal. <br><br>  <b>Attention!</b>  If you took for example the 2nd element in the table of ordinals, this does not mean 2 - this is the ordinal for the tables of names and addresses.  The index is the value stored in the second element of the array of ordinals. <br><br>  The number of values ‚Äã‚Äãin the name tables ( <i>NumberOfNames</i> ) and the ordinals are equal and do not always coincide with the number of elements in the address table ( <i>NumberOfFunctions</i> ). <br><br><blockquote>  ‚ÄúThey came for me.  Thanks for attention.  They must be killing now! ‚Äù <br>  (Treasure Island) </blockquote><br><h4>  Import table </h4><br><img width="300" height="200" src="https://habrastorage.org/files/807/ebd/d39/807ebdd398f4432a9cc5372ed4439ada.jpg"><br><br>  An import table is an integral part of any application that uses dynamic libraries.  This table helps to associate calls of functions of dynamic libraries with the corresponding addresses.  Import can occur in three different modes: standard, binding (bound import) and delayed (delay import).  Since  The topic of importing is quite multifaceted and draws on a separate article, I will describe only the standard mechanism, and I will describe the rest only with a ‚Äúskeleton‚Äù. <br><br>  <u>Standard import</u> - in <i>DataDirectory</i> under the index IMAGE_DIRECTORY_ENTRY_IMPORT (= 1) the import table is stored.  It is an array of IMAGE_IMPORT_DESCRIPTOR elements.  The import table stores (by array) the names of the functions / ordinals and to what place the loader must write the effective address of these functions.  This mechanism is not very effective, because  frankly, it all comes down to going through the entire export table for each necessary function. <br><br>  <u>Bound import</u> - with this work scheme, TimeDateStamp and ForwardChain are entered in the fields (in the first element of the standard import table) -1 and the binding information is stored in the <i>DataDirectory</i> cell with the index IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (= 11).  That is, it is a kind of flag for the loader that you need to use bound import.  Also for the "chain of bound imports" feature their structures.  The operation algorithm consists in the following - the necessary library is unloaded into the virtual memory of the application and all the necessary addresses are "bind" at the compilation stage.  One of the drawbacks is that when recompiling the dll, the application itself will need to be recompiled, since  function addresses will be changed. <br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delay import</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - with this method it is assumed that the .dll file is attached to the executable, but it is not immediately unloaded into memory (as in the previous two methods), but only when the application first accesses the symbol (this is how the unloading elements from dynamic libraries are called). </font><font style="vertical-align: inherit;">That is, the program runs in memory and as soon as the process reaches the function call from the dynamic library, a special handler is called that loads the dll and spreads the effective addresses of its functions. </font><font style="vertical-align: inherit;">For deferred import, the loader accesses DataDirectory [IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT] (item number 15). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having a little illuminated the import methods, we proceed directly to the import table.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äú-This is a sailor! </font><font style="vertical-align: inherit;">His clothes were sea. </font><font style="vertical-align: inherit;">- Yah? </font><font style="vertical-align: inherit;">Have you ever thought of finding a bishop here? ‚Äù </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Treasure Island ‚Äî John Silver)</font></font></blockquote><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Import-descriptor (IMAGE_IMPORT_DESCRIPTOR) </font></font></h4><br><img width="300" height="200" src="https://habrastorage.org/files/afa/321/11c/afa32111c6ee434ea2c5136e06e76be1.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to find out the coordinates of the import table, we need to access the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataDirectory</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> array </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Namely, to the element IMAGE_DIRECTORY_ENTRY_IMPORT (= 1). </font><font style="vertical-align: inherit;">And read the RVA table address. </font><font style="vertical-align: inherit;">Here is a general outline of the path that needs to be done: </font></font><br><br><img src="https://habrastorage.org/files/069/add/3c5/069add3c55d6425cb992001330e77e3a.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, from RVA, we get RAW, in accordance with the formulas given above, and then ‚Äústep along‚Äù the file. </font><font style="vertical-align: inherit;">Now we are right next to an array of structures called IMAGE_IMPORT_DESCRIPTOR. </font><font style="vertical-align: inherit;">A sign of the end of the array is the ‚Äúzero‚Äù structure.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I could not get a link to the structure description on msdn, but you can see it in the WINNT.h file. </font><font style="vertical-align: inherit;">Let's start to understand. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OriginalFirstThunk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : DWORD - RVA import name table (INT). </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TimeDateStamp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : DWORD - date and time. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForwarderChain</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : DWORD - the index of the first character forwarded. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : DWORD - RVA strings with the name of the library. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirstThunk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : DWORD - RVA Import Address Table (IAT). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's all a bit like export. </font><font style="vertical-align: inherit;">Also the name table (INT) </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and also the rags on it</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addresses (IAT). </font><font style="vertical-align: inherit;">Also RVA library name. </font><font style="vertical-align: inherit;">Only here INT and IAT refer to an array of IMAGE_THUNK_DATA structures. </font><font style="vertical-align: inherit;">It is presented in two forms - for the 64th and for the 32nd systems and differ only in the size of the fields. </font><font style="vertical-align: inherit;">Consider the example of x86:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_THUNK_DATA32</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { DWORD ForwarderString; DWORD Function; DWORD Ordinal; DWORD AddressOfData; } u1; } IMAGE_THUNK_DATA32,*PIMAGE_THUNK_DATA32;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to answer that further actions depend on the most significant bit of the structure. </font><font style="vertical-align: inherit;">If it is set, the remaining bits are the number of the character being imported (import by number). </font><font style="vertical-align: inherit;">Otherwise (high bit cleared), the remaining bits specify the RVA of the imported character (import by name). </font><font style="vertical-align: inherit;">If we have an import by name, then the pointer stores the address to the following structure:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMAGE_IMPORT_BY_NAME</span></span></span><span class="hljs-class"> {</span></span> WORD Hint; BYTE Name[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hint</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the number of the function, and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the name.</font></font><br><br>  What is all this for?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All these arrays, structures ... Consider for clarity, a wonderful scheme with </font></font><a href="https://exelab.ru/faq/%25D0%25A2%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0_%25D0%25B8%25D0%25BC%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582%25D0%25B0_PE_%25D1%2584%25D0%25B0%25D0%25B9%25D0%25BB%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exelab</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><img src="https://habrastorage.org/files/84f/5fc/785/84f5fc7851e44dbcb53704a48619ef1a.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is happening here ... The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OriginalFirstThunk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> field </font><font style="vertical-align: inherit;">refers to an array where information on imported functions is stored. </font><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirstThunk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> field </font><font style="vertical-align: inherit;">refers to a similar array of the same dimension, except that it is filled during loading with effective addresses of functions.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the loader analyzes the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OriginalFirstThunk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , determines the real address of the function for each of its elements, and enters this address in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FirstThunk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In other words, the binding of imported characters.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúI don't like this expedition! </font><font style="vertical-align: inherit;">I do not like these sailors! </font><font style="vertical-align: inherit;">And anyway ... what? !!!</font></font> Oh yes!  Not!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I don't like anything at all, sir! ‚Äù </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Treasure Island - Captain Smollett)</font></font></blockquote><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Overboard </font></font></h4><br><img width="300" height="200" src="https://habrastorage.org/files/0d5/e7a/b77/0d5e7ab771d5454eabba0f55de3cecf6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article presented only the base for executable files. </font><font style="vertical-align: inherit;">Other types of imports are not affected, the behavior of conflicting (for example, physical section size, more virtual) or ambiguous (in the same import - the question of which method to use) situations. </font><font style="vertical-align: inherit;">But this is all for more detailed study and depends on the specific loaders in the OS and the compilers that compiled the program. </font><font style="vertical-align: inherit;">Also not affected directories of resources, debugging and other. </font><font style="vertical-align: inherit;">For those who are interested, you can read more detailed guidance presented in the list of references at the end of the article.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúSay, Ham, will we wag for a long time like a bowling boat? </font><font style="vertical-align: inherit;">I'm sick of the captain to death. </font><font style="vertical-align: inherit;">Stop him commanding! </font><font style="vertical-align: inherit;">I want to live in his cabin. ‚Äù </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Treasure Island)</font></font></blockquote><br><h4>  Conclusion </h4><br><img width="300" height="200" src="https://habrastorage.org/files/c12/e83/d4a/c12e83d4a86947fea7e6f177dac55d7c.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After we returned from the trip, I‚Äôll summarize what we saw and what they carried out. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today we have understood a lot</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Namely, I will describe the process of downloading an application in general terms.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, the headers are read and checked that the file is executable. </font><font style="vertical-align: inherit;">Otherwise, the work stops before it starts.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The loader allocates the required amount of virtual memory for the application. </font><font style="vertical-align: inherit;">If possible, the application will be downloaded to the preferred address. </font><font style="vertical-align: inherit;">If not, then another part of the memory will be allocated for the application and loaded from this address.</font></font></li><li>           (   )   .            . </li><li>      ,    . </li><li>        dll.    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article ends. I think this information is quite enough to have a basic understanding of executable files. The most curious way on </font></font><a href="https://exelab.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exelab</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://www.wasm.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wasm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://msdn.microsoft.com/en-us/library/ms809762.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msdn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://asmworld.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assembler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and disassembler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For a clearer understanding, you can recommend to study the charts. It really gives a more complete picture of what is happening inside. As an example, I can offer this </font></font><a href="http://habrahabr.ru/post/148194/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by </font></font><a href="http://habrahabr.ru/users/alizar/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alizar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> user </font><font style="vertical-align: inherit;">or more general schemes in </font></font><a href="https://www.google.ru/search%3Fq%3Dpe%2Bfile%2Bstructure%26newwindow%3D1%26biw%3D1366%26bih%3D656%26source%3Dlnms%26tbm%3Disch%26sa%3DX%26ved%3D0CAYQ_AUoAWoVChMI8uSTyID1xwIVo49yCh3Ecgtu"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hope you enjoyed our trip.</font></font><br><br><h4>  Bibliography </h4><br> <a href="https://ru.wikipedia.org/wiki/Portable_Executable">ru.wikipedia.org/wiki/Portable_Executable</a> <br> <a href="https://msdn.microsoft.com/en-us/library/ms809762.aspx">msdn.microsoft.com/en-us/library/ms809762.aspx</a> <br> <a href="http://acmvm2.srv.mst.edu/wp-content/uploads/2014/07/PE-Header-Bible.pdf">acmvm2.srv.mst.edu/wp-content/uploads/2014/07/PE-Header-Bible.pdf</a> <br> <a href="http://cs.usu.edu.ru/docs/pe/">cs.usu.edu.ru/docs/pe</a> <br> <a href="http://www.litres.ru/kris-kasperski/tehnika-otladki-programm-bez-ishodnyh-tekstov/">  ‚Äî      </a> <br> <a href="https://exelab.ru/faq/">exelab.ru/faq</a> </div><p>Source: <a href="https://habr.com/ru/post/266831/">https://habr.com/ru/post/266831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266817/index.html">Kotlin and its almost language constructs</a></li>
<li><a href="../266821/index.html">Java Programmer Cheat Sheet 2: Three hundred and fifty of the most popular non-mobile Java opensource projects on github</a></li>
<li><a href="../266823/index.html">At the junction of ERP and ECM: how we automated the logistics process</a></li>
<li><a href="../266827/index.html">New Russian K-Meleon 75 for Real Pro</a></li>
<li><a href="../266829/index.html">Paradigm of situationally oriented programming</a></li>
<li><a href="../266833/index.html">15 year old code and newspaper ad</a></li>
<li><a href="../266835/index.html">Inventing servers - Open Compute Project</a></li>
<li><a href="../266837/index.html">Testing on Android: Robolectric + Jenkins + Ja–°o–°o</a></li>
<li><a href="../266839/index.html">Working with lighting in Unity - theory and practice</a></li>
<li><a href="../266843/index.html">Preparing Nexus Player (FUGU) for working with SoCWatch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>