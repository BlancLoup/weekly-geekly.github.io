<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why can LLVM call a function that is never called?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Whatever your dragon says to you, he lied. Dragons are false. You do not know what awaits you on the other side. 
 Michael Swanwick. "Daughter of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why can LLVM call a function that is never called?</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <i>Whatever your dragon says to you, he lied.</i>  <i>Dragons are false.</i>  <i>You do not know what awaits you on the other side.</i> <br>  Michael Swanwick.  "Daughter of the Iron Dragon" </blockquote><br>  Not so long ago, a post was published on Habr√© entitled " <a href="https://habrahabr.ru/company/infopulse/blog/338812/">How can a never called function be called?</a> ".  The conclusions from the article are simple: in case of undefined behavior, the compiler has the right to take any action, even if they are completely unexpected.  However, I was interested in the mechanism of this optimization.  I want to share result of the small research with dear community of a habr. <br><br><img src="https://habrastorage.org/webt/59/db/92/59db927f86faa183685625.jpeg"><br><a name="habracut"></a><br>  Let me remind you in a nutshell, what was the essence.  In the source below, the EraseAll function should not be called from main, and it is not really called when compiled with -O0, but it is suddenly called with optimization -O1 and higher. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int EraseAll() { return system("rm -rf /"); } void NeverCalled() { Do = EraseAll; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  This is explained as follows: in the above code, the variable Do is a pointer to a function, and is initially null.  When we try to call a function on a null pointer, the behavior of the program may be undefined (undefined behavior, UB) and the compiler has the right to optimize UB as it is more convenient for him.  In this case, the compiler immediately made the assignment Do = EraseAll. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Why did he do that, we will try to figure it out now.  In the rest of the text, LLVM and Clang version 5.0.0 are used as a compiler. <br><br>  Let's start by looking at the IR code when optimizing with -O0 and -O1.  Change the source a bit to make it less dramatic: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; typedef int (*Function)(); static Function Do; static int PrintHello() { return printf("hello world\n"); } void NeverCalled() { Do = PrintHello; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  And compile the IR code with -O0 (debugging information omitted for clarity): <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: <span class="hljs-function"><span class="hljs-function">store </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitcast</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i32 ()* @PrintHello to i32 (...)*)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">** @Do, align 8 ret </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> } </span></span>; Function Attrs: noinline nounwind optnone uwtable define i32 @main() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32 (...)*, i32 (...)** @Do, align <span class="hljs-number"><span class="hljs-number">8</span></span> %call = call i32 (...) %<span class="hljs-number"><span class="hljs-number">0</span></span>() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) #<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  And with -O1: <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.ll'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: noinline nounwind optnone uwtable define i32 @main() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %call = call i32 (...) bitcast (i32 ()* @PrintHello to i32 (...)*)() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  You can compile the executable files and make sure that in the first case a segmentation error occurs, and in the second - ‚Äúhello world‚Äù is output.  With other optimization options, the result is the same as with -O1. <br><br>  Now we find the part of the compiler code that performs this optimization.  I remind you that in the LLVM architecture the frontend is not engaged in optimization itself, i.e.  cfe (Clang Frontend) always generates code without optimizations, which we see in the variant for -O0, and the optimization is performed by the opt utility: <br><br><img src="https://habrastorage.org/webt/59/dc/db/59dcdb5825919280730461.png"><br><br>  When -O1, the following optimization passes are performed: <br><br><div class="spoiler">  <b class="spoiler_title">Impressive please do not look</b> <div class="spoiler_text"><pre> <code class="bash hljs">-targetlibinfo -tti -tbaa -scoped-noalias -assumption-cache-tracker -profile-summary-info -forceattrs -inferattrs -ipsccp -globalopt -domtree -mem2reg -deadargelim -domtree -basicaa -aa -instcombine -simplifycfg -basiccg -globals-aa -prune-eh -always-inline -functionattrs -domtree -sroa -basicaa -aa -memoryssa -early-cse-memssa -speculative-execution -domtree -basicaa -aa -lazy-value-info -jump-threading -lazy-value-info -correlated-propagation -simplifycfg -domtree -basicaa -aa -instcombine -libcalls-shrinkwrap -loops -branch-prob -block-freq -pgo-memop-opt -domtree -basicaa -aa -tailcallelim -simplifycfg -reassociate -domtree -loops -loop-simplify -lcssa-verification -lcssa -basicaa -aa -scalar-evolution -loop-rotate -licm -loop-unswitch -simplifycfg -domtree -basicaa -aa -instcombine -loops -loop-simplify -lcssa-verification -lcssa -scalar-evolution -indvars -loop-idiom -loop-deletion -loop-unroll -memdep -memcpyopt -sccp -domtree -demanded-bits -bdce -basicaa -aa -instcombine -lazy-value-info -jump-threading -lazy-value-info -correlated-propagation -domtree -basicaa -aa -memdep -dse -loops -loop-simplify -lcssa-verification -lcssa -aa -scalar-evolution -licm -postdomtree -adce -simplifycfg -domtree -basicaa -aa -instcombine -barrier -basiccg -rpo-functionattrs -globals-aa -float2int -domtree -loops -loop-simplify -lcssa-verification -lcssa -basicaa -aa -scalar-evolution -loop-rotate -loop-accesses -lazy-branch-prob -lazy-block-freq -opt-remark-emitter -loop-distribute -branch-prob -block-freq -scalar-evolution -basicaa -aa -loop-accesses -demanded-bits -lazy-branch-prob -lazy-block-freq -opt-remark-emitter -loop-vectorize -loop-simplify -scalar-evolution -aa -loop-accesses -loop-load-elim -basicaa -aa -instcombine -latesimplifycfg -domtree -basicaa -aa -instcombine -loops -loop-simplify -lcssa-verification -lcssa -scalar-evolution -loop-unroll -instcombine -loop-simplify -lcssa-verification -lcssa -scalar-evolution -licm -alignment-from-assumptions -strip-dead-prototypes -domtree -loops -branch-prob -block-freq -loop-simplify -lcssa-verification -lcssa -basicaa -aa -scalar-evolution -branch-prob -block-freq -loop-sink -lazy-branch-prob -lazy-block-freq -opt-remark-emitter -instsimplify -simplifycfg -verify</code> </pre> <br></div></div><br>  Turning off the passes one by one, we find the desired one, this is a globalopt.  We can only leave this optimization pass, and make sure that it is he, and no one else, that generates the code we need.  Its source is in the file /lib/Transforms/IPO/GlobalOpt.cpp.  You can familiarize yourself with the source code in the LLVM repository, and I will not fully bring it here, confining myself to only functions that are important for understanding its work. <br>  Let's see what this optimization pass does.  To begin with, it implements the runOnModule method, i.e.  when working, he sees and optimizes the module as a whole (which, however, is logical in this case).  The optimizeGlobalsInModule function deals directly with optimization: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeGlobalsInModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Module &amp;M, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL, TargetLibraryInfo *TLI, function_ref&lt;DominatorTree &amp;(Function &amp;)&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ SmallSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; NotDiscardableComdats; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LocalChange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LocalChange) { LocalChange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; NotDiscardableComdats.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GlobalVariable &amp;GV : M.globals()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GV.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GV.isDiscardableIfUnused() || !GV.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Function &amp;F : M) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = F.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!F.isDefTriviallyDead()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (GlobalAlias &amp;GA : M.aliases()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GA.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GA.isDiscardableIfUnused() || !GA.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-comment"><span class="hljs-comment">// Delete functions that are trivially dead, ccc -&gt; fastcc LocalChange |= OptimizeFunctions(M, TLI, LookupDomTree, NotDiscardableComdats); // Optimize global_ctors list. LocalChange |= optimizeGlobalCtorsList(M, [&amp;](Function *F) { return EvaluateStaticConstructor(F, DL, TLI); }); // Optimize non-address-taken globals. LocalChange |= OptimizeGlobalVars(M, TLI, LookupDomTree, NotDiscardableComdats); // Resolve aliases, when possible. LocalChange |= OptimizeGlobalAliases(M, NotDiscardableComdats); // Try to remove trivial global destructors if they are not removed // already. Function *CXAAtExitFn = FindCXAAtExit(M, TLI); if (CXAAtExitFn) LocalChange |= OptimizeEmptyGlobalCXXDtors(CXAAtExitFn); Changed |= LocalChange; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Move all global ctors functions to the end of the module for code // layout. return Changed; }</span></span></code> </pre> <br>  Let's try to describe in words what this function does.  For each global variable in the module, it queries the Comdat object. <br><div class="spoiler">  <b class="spoiler_title">What is Comdat</b> <div class="spoiler_text">  A comdat section is a section in an object file that contains objects that can be duplicated in other object files.  Each object has information for the linker, indicating what it should do when it detects duplicates.  The options can be the following: Any ‚Äî anything, ExactMatch ‚Äî duplicates must completely match, otherwise an error occurs, Largest ‚Äî take the object with the highest value, NoDublicates ‚Äî there should not be a duplicate, SameSize ‚Äî duplicates should be the same size, otherwise an error will occur. <br></div></div><br>  In LLVM, Comdat data is presented by listing: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionKind { Any, <span class="hljs-comment"><span class="hljs-comment">///&lt; The linker may choose any COMDAT. ExactMatch, ///&lt; The data referenced by the COMDAT must be the same. Largest, ///&lt; The linker will choose the largest COMDAT. NoDuplicates, ///&lt; No other Module may specify this COMDAT. SameSize, ///&lt; The data referenced by the COMDAT must be the same size. };</span></span></code> </pre> <br>  , and the Comdat class is actually a pair (Name, SelectionKind).  ( <i>In fact, everything is more complicated.</i> ) All variables, which for some reason cannot be deleted, are placed in the set NotDiscardableComdats.  We do the same with functions and global aliases - that which cannot be deleted, is placed in NotDiscardableComdats.  Then, separate optimization functions of global constructors, global functions, global variables, global aliases, and global destructors are called.  Optimizations continue in a loop until no optimization has been performed.  At each iteration of the loop, the NotDiscardableComdats set is reset. <br><br>  Let's see which of the listed objects contains our test source. <br><br>  <b>Global variables:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  (looking ahead a bit, I‚Äôll say that the optimizer will delete the first variable at the first iteration) <br><br>  <b>Functions:</b> <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() define i32 @main() define internal i32 @PrintHello() declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...)</code> </pre> <br>  Note that printf is only declared (declare), but not defined (define). <br>  Global aliases are missing. <br><br>  Let's use the example of this optimization pass to consider how this result was obtained.  Of course, to fully understand all the optimization options even in one pass is a very voluminous task, since  It provides many different particular cases of optimization.  We will focus on our example, simultaneously considering those functions and data structures that are important for understanding the work of this optimization pass. <br><br>  At first, the optimizer makes various tests of little interest in this case, and calls the processInternalGlobal function, which tries to optimize global variables.  This function is also quite complex and does many different things, but we are interested in one thing: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GS.StoredType == GlobalStatus::StoredOnce &amp;&amp; GS.StoredOnceValue) { ... <span class="hljs-comment"><span class="hljs-comment">//    ,   ,    //    ,    . if (optimizeOnceStoredGlobal(GV, GS.StoredOnceValue, GS.Ordering, DL, TLI)) return true; ... }</span></span></code> </pre> <br>  Information that a global variable is assigned a value one and only once is extracted from the GS (GlobalStatus) structure.  This structure is populated in the calling function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processGlobal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GlobalValue &amp;GV, TargetLibraryInfo *TLI, function_ref&lt;DominatorTree &amp;(Function &amp;)&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV.getName().startswith(<span class="hljs-string"><span class="hljs-string">"llvm."</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; GlobalStatus GS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalStatus::analyzeGlobal(&amp;GV, GS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ...</code> </pre> <br>  Here we see another interesting fact: objects whose names begin with ‚Äúllvm.‚Äù Are not optimizable (since they are runtime calls llvm).  And, just in case, variable names in the LLVM IR language can contain points (and even consist of one point with the prefix @ or%).  The analyzeGlobal function is a call to the LLVM API and we will not consider its internal work.  The structure of GlobalStatus is worth dwelling in more detail, since it contains very important information for optimization passes. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///     ,     .   /// ,     ,      ///    struct GlobalStatus { /// True,         bool IsCompared = false; /// True,     .  ,  ///    bool IsLoaded = false; ///      enum StoredType { ///   .       NotStored, ///  ,     ,    ///  .      . InitializerStored, ///  ,         ///  .   isStoredOnce,   , ///   ,   StoredOnceValue .      /// . StoredOnce, ///      ,  ///    . Stored } StoredType = NotStored; ///     (  )  ///    ,   . Value *StoredOnceValue = nullptr; ... };</span></span></code> </pre> <br>  It is probably worth explaining why "if we find that the taking of the address of a variable occurs, no information from this structure will be reliable."  In fact, if we take the address of a global variable, and then write something down at that address, rather than by name, then it will be extremely difficult to track down, and it is better to leave such variables as they are, not trying to optimize. <br><br>  So, we get into the optimizeOnceStoredGlobal function, in the arguments of which the variable (GV) and the stored value (StoredOnceVal) are passed.  Here they are: <br><br><pre> <code class="cpp hljs">@Do = internal unnamed_addr global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">// i32 (...)* bitcast (i32 ()* @PrintHello to i32 (...)*) // </span></span></code> </pre> <br>  Further, the value removes the insignificant bitcast, and the following condition is checked for the variable: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType()-&gt;isPointerTy() &amp;&amp; GV-&gt;getInitializer()-&gt;isNullValue()) { ...</code> </pre> <br>  that is, the variable must be initialized with a null pointer.  If this is the case, then create a new SOVC variable corresponding to the StoredOnceVal value cast to the GV type: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Constant *SOVC = dyn_cast&lt;Constant&gt;(StoredOnceVal)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType() != SOVC-&gt;getType()) SOVC = ConstantExpr::getBitCast(SOVC, GV-&gt;getInitializer()-&gt;getType());</code> </pre> <br>  Here, getBitCast is a method that returns a bitcast command that lists types in the LLVM IR language. <br>  After that, the OptimizeAwayTrappingUsesOfLoads function is called.  The global variable GV and the constant LV are passed to it. <br>  Directly optimization is performed by the function OptimizeAwayTrappingUsesOfValue (Value * V, Constant * NewV). <br>  For each use of the variable: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> UI = V-&gt;user_begin(), E = V-&gt;user_end(); UI != E; ) { Instruction *I = cast&lt;Instruction&gt;(*UI++);</code> </pre> <br>  if this is a Load command, replace its operand with a new value: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LoadInst *LI = dyn_cast&lt;LoadInst&gt;(I)) { LI-&gt;setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, NewV); Changed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  If the variable is used in the call or invoke function (and this is exactly what happens in our example), create a new function, replacing its argument with a new value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isa&lt;CallInst&gt;(I) || isa&lt;InvokeInst&gt;(I)) { <span class="hljs-function"><span class="hljs-function">CallSite </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CS.getCalledValue() == V) { <span class="hljs-comment"><span class="hljs-comment">// Calling through the pointer! Turn into a direct call, but be careful // that the pointer is not also being passed as an argument. CS.setCalledFunction(NewV); Changed = true; bool PassedAsArg = false; for (unsigned i = 0, e = CS.arg_size(); i != e; ++i) if (CS.getArgument(i) == V) { PassedAsArg = true; CS.setArgument(i, NewV); }</span></span></code> </pre> <br>  All other function arguments are simply copied. <br>  Similar replacement algorithms are also provided for the Cast and GEP instructions, but in our case this does not occur. <br><br>  Further actions are as follows: we review all uses of the global variable, trying to delete everything except the assignment of a value.  If it succeeds, we can delete the Do variable. <br><br>  So, we briefly reviewed the work of the LLVM optimization pass using a specific example.  In principle, there is nothing super-complicated here, but greater accuracy in programming is required in order to provide for all possible combinations of commands and types of variables.  Of course, all this should be covered by tests.  Examining the source code for LLVM optimizers will help you write your own optimizations that allow you to improve the code for some specific cases. <br><br><h3>  Examples of some interesting optimizations in LLVM </h3><br>  Let me give you some more examples of how LLVM can optimize code.  These examples are not relevant to the example that we have just analyzed, and are being done in other optimization passes, however, they are quite unusual and interesting. <br><br><h4>  First example </h4><br>  Consider a code that summarizes the numbers from 1 to n-1: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) s += i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }</code> </pre> <br><br>  Compile with -O1: <br><br><pre> <code class="cpp hljs">define i32 @sum(i32 %n) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %cmp6 = icmp sgt i32 %n, <span class="hljs-number"><span class="hljs-number">0</span></span> br i1 %cmp6, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond.cleanup.loopexit, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond.cleanup <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond.cleanup.loopexit: ; preds = %entry %<span class="hljs-number"><span class="hljs-number">0</span></span> = add i32 %n, <span class="hljs-number"><span class="hljs-number">-1</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = zext i32 %<span class="hljs-number"><span class="hljs-number">0</span></span> to i33 %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i32 %n, <span class="hljs-number"><span class="hljs-number">-2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = zext i32 %<span class="hljs-number"><span class="hljs-number">2</span></span> to i33 %<span class="hljs-number"><span class="hljs-number">4</span></span> = mul i33 %<span class="hljs-number"><span class="hljs-number">1</span></span>, %<span class="hljs-number"><span class="hljs-number">3</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = lshr i33 %<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">6</span></span> = trunc i33 %<span class="hljs-number"><span class="hljs-number">5</span></span> to i32 %<span class="hljs-number"><span class="hljs-number">7</span></span> = add i32 %<span class="hljs-number"><span class="hljs-number">6</span></span>, %n %<span class="hljs-number"><span class="hljs-number">8</span></span> = add i32 %<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond.cleanup <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond.cleanup: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond.cleanup.loopexit, %entry %s<span class="hljs-number"><span class="hljs-number">.0</span></span>.lcssa = phi i32 [ <span class="hljs-number"><span class="hljs-number">0</span></span>, %entry ], [ %<span class="hljs-number"><span class="hljs-number">8</span></span>, %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond.cleanup.loopexit ] ret i32 %s<span class="hljs-number"><span class="hljs-number">.0</span></span>.lcssa }</code> </pre> <br>  Suddenly, there is no cycle, but miraculous variables like i33 appeared (that is, a 33-bit integer).  How did it happen?  LLVM turned the sum of a series into a formula: (n-1) * (n-2) / 2 + n - 1. As during the calculation of intermediate variables an overflow of 32-bit grid may occur, LLVM inserted a variable of type i33.  Note that he did this by analyzing a non-optimized assembly code, and this is quite difficult.  Under the spoiler is a non-optimized code for the same function, which is directly counted in the loop: <br><br><div class="spoiler">  <b class="spoiler_title">non-optimized code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">define i32 @sum(i32 %n) #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %n.addr = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %s = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %i = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 %n, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %s, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc, %entry %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = load i32, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> %cmp = icmp slt i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> br i1 %cmp, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = load i32, i32* %s, align <span class="hljs-number"><span class="hljs-number">4</span></span> %add = add nsw i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, %<span class="hljs-number"><span class="hljs-number">2</span></span> store i32 %add, i32* %s, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %inc = add nsw i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> store i32 %inc, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond %<span class="hljs-number"><span class="hljs-number">5</span></span> = load i32, i32* %s, align <span class="hljs-number"><span class="hljs-number">4</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br></div></div><br>  It is even more interesting to see what happens with this example in the backend.  The i33 variable is converted to i64, and, if your processor is 32-bit, sequences of instructions are generated for multiplying and adding 64-bit numbers in a 32-bit system.  Even more interesting, if in the original example, change the data type to long.  Then the argument and the return value will be of type i64, and intermediate variables will become of type i65! <br><br><h4>  Second example </h4><br>  Suppose we decided to write a function that changes the sign of the float, changing the 31st bit of the float binary representation: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = *((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*) &amp;x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inv = val ^ (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">31</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;inv); }</code> </pre> <br>  When compiling on x86_64, nothing particularly interesting happens: <br><br><pre> <code class="cpp hljs">.LCPI0_0: .<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-number"><span class="hljs-number">2147483648</span></span> <span class="hljs-meta"><span class="hljs-meta"># float -0 .long 2147483648 # float -0 .long 2147483648 # float -0 .long 2147483648 # float -0 .text .globl sum .p2align 4, 0x90 .type sum,@function sum: # @sum .cfi_startproc # BB#0: # %entry xorps .LCPI0_0(%rip), %xmm0 retq</span></span></code> </pre> <br>  But if we compile for ARM 64 (AARCH64): <br><br><pre> <code class="cpp hljs">invert: <span class="hljs-comment"><span class="hljs-comment">// @invert // BB#0: // %entry fneg s0, s0 ret</span></span></code> </pre> <br>  LLVM recognized the fneg command in the 31st bit change, changing the float sign.  For comparison, GCC does not know how, producing a ‚Äúliteral‚Äù version. <br>  GCC 6.3 (ARM 64): <br><br><pre> <code class="cpp hljs">invert(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>): fmov w0, s0 eor w0, w0, <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> fmov s0, w0 ret</code> </pre> <br>  This is an example of target-specific optimization, which is done in the backend, not in the opt utility. <br><br>  About this example, you need to say a couple of words.  Such actions with pointers violate the strict aliasing rule, which can lead to undefined behavior when compiling with the -strict-aliasing flag on some compilers and on some platforms (in fact, in a very small number of cases).  For this example, the error occurs when compiling with gcc4.4.7 -m32 -O2, and disappears in more recent versions of gcc.  However, I inserted a link to an interesting aliasing lecture in the list of links at the end. <br><br><h4>  Third example </h4><br>  Another example of target-specific optimization, this time for x86-64, or rather, for Haswell architecture. <br>  We write the function of counting single bits in a word: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cntSetBits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(a) { cnt++; a &amp;= (a<span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cnt; }</code> </pre> <br>  Compile with -O1 -march = haswell: <br><br><pre> <code class="cpp hljs">cntSetBits(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): # @cntSetBits(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) popcnt eax, edi ret</code> </pre> <br>  The whole function fit into one popcnt instruction, which counts the number of units in a word. <br>  Look at IR: <br><br><pre> <code class="cpp hljs">; Function Attrs: norecurse nounwind readnone uwtable define i32 @cntSetBits(i32 %a) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %<span class="hljs-number"><span class="hljs-number">0</span></span> = call i32 @llvm.ctpop.i32(i32 %a), !range !<span class="hljs-number"><span class="hljs-number">2</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Here we see that the built-in function llvm.ctpop.i32 is used.  The front-end has already inserted it using high-level information about the code, and the backend for this architecture knows about this function and is able to replace it with a special command. <br><br><h3>  useful links </h3><br>  <a href="http://www.drdobbs.com/architecture-and-design/the-design-of-llvm/240001128">http://www.drdobbs.com/architecture-and-design/the-design-of-llvm/240001128</a> - Chris Lattner, "The Design of LLVM" <br>  <a href="https://youtu.be/bSkpMdDe4g4">https://youtu.be/bSkpMdDe4g4</a> - Matt Godbolt, "What has my compiler done for me lately?" <br>  <a href="https://youtu.be/ACW-7dktyDk">https://youtu.be/ACW-7dktyDk</a> Dmitry Kashitsyn ‚ÄúLoaf trolleybus: aliasing and vectorization in LLVM‚Äù </div><p>Source: <a href="https://habr.com/ru/post/339700/">https://habr.com/ru/post/339700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339690/index.html">Cocos2d-x - Working with sprites</a></li>
<li><a href="../339692/index.html">How to successfully implement the Help Desk? 12 examples (part 2)</a></li>
<li><a href="../339694/index.html">New 3CX Call Flow Designer: Complicated Call Routing Without Programming</a></li>
<li><a href="../339696/index.html">Knowledge sharing and copyright management platform. Look at the state order?</a></li>
<li><a href="../339698/index.html">Hello World's thorny path</a></li>
<li><a href="../339702/index.html">Comparing tick-to-trade delays with CEPappliance and Solarflare TCPDirect</a></li>
<li><a href="../339704/index.html">Telegram: sending messages to a mobile number to chat with a bot</a></li>
<li><a href="../339708/index.html">FrontFest.Vyorstka: let's talk about accessibility, saving traffic and future CSS</a></li>
<li><a href="../339710/index.html">Announcement: Veeam Backup & Replication 9.5 (and beyond) new features</a></li>
<li><a href="../339712/index.html">44 lesson control technicians</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>