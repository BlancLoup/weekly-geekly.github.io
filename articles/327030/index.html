<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monad transformers for practicing programmers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Applied introduction to monad transformers, from problem to solution 


 Imagine you are sitting at your desk, drinking coffee and getting ready to wr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monad transformers for practicing programmers</h1><div class="post__text post__text-html js-mediator-article"><h4 id="prikladnoe-vvedenie-v-monadnye-transformery-ot-problemy-k-resheniyu">  <em>Applied introduction to monad transformers, from problem to solution</em> </h4><br><p>  Imagine you are sitting at your desk, drinking coffee and getting ready to write code on Scala.  Functional programming was not as scary as it is painted, life is beautiful, you sit back, concentrate and start writing a new functionality that you need to pass this week. </p><br><p> Everything is as usual: a few laconic one-line expressions (yes, baby, this is Scala!), A few strange compiler errors (oh no, Scala, no!), A slight regret that you wrote such a tangled code ... And suddenly you come across strange problem: the <code>for</code> expression does not compile.  ‚ÄúIt's okay,‚Äù you think: ‚ÄúNow I‚Äôll look at StackOverflow,‚Äù as you do every day.  How we all do it daily. </p><br><p>  But today seems to be a bad day. </p><br><a name="habracut"></a><br><p>  At first it seems to you that the best answer is too abstruse.  Usually it is enough to scroll down, find a simpler solution and forget about the explanation using the theory of categories, monads, and all that without much remorse. </p><br><p>  However, this time the second answer is similar to the first, and the third, and the fourth.  What's happening? </p><br><p>  <strong>Monads.</strong>  <strong>Transformers.</strong> </p><br><p>  Even the names sound scary.  Let's take a closer look, what is your problem? </p><br><p>  First you wrote the functions: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUserById</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">User</span></span>] = ??? <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUser</span></span></span></span>(user: <span class="hljs-type"><span class="hljs-type">User</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>] = ???</code> </pre> <br><p>  It looked elegant: the <code>Future</code> class represents asynchronous computing, and it has a <code>flatMap</code> method, which means you can put it in a <code>for</code> expression.  Super! </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUserId</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { user &lt;- findUserById(id) address &lt;- findAddressByUser(user) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> address</code> </pre> <br><p>  Then you suddenly realized that a user does not exist for every identifier.  What to do if the user is not found?  Well, well, the <code>Option</code> class serves just this purpose: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUserById</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">User</span></span>]] = ???</code> </pre> <br><p>  And, for that matter, some users may not have an address: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUser</span></span></span></span>(user: <span class="hljs-type"><span class="hljs-type">User</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>]] = ???</code> </pre> <br><p>  But when you returned to this code, a compilation error appeared: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUserId</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { user &lt;- findUserById(id) address &lt;- findAddressByUser(user) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> address</code> </pre> <br><p>  Yes, that's right, because the return type is now <code>Future[Option[Address]]</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUserId</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>]] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { user &lt;- findUserById(id) address &lt;- findAddressByUser(user) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> address</code> </pre> <br><p>  The compiler must be satisfied.  But what does he write? </p><br><pre> <code class="hljs pgsql">error: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> mismatch; <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>] required: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> address &lt;- findAddressByUser(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>)</code> </pre> <br><p>  Not good.  Thinking a little, you remembered that <code>&lt;-</code> is just a convenient way to call the <code>flatMap</code> method, and if you called it on an object of the <code>Future[Option[User]]</code> , you got <code>Option[User]</code> , although you need a <code>User</code> object ... </p><br><p>  You tried this and that, but it's not that.  The best you could think of was as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUserId</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>]] = findUserById(id).flatMap { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(user) =&gt; findAddressByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span>.successful(<span class="hljs-type"><span class="hljs-type">None</span></span>) }</code> </pre> <br><p>  Ugly or at least not as beautiful as it was before.  Ideally, you would like something like: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUserId</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>]] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { user &lt;- userOption &lt;- findUserById(id) address &lt;- addressOption &lt;- findAddressByUser(user) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> address</code> </pre> <br><p>  Such a <code>flatMap</code> method, which immediately extracts the value from both <code>Option</code> and <code>Future</code> .  But on StackOverflow, no one mentioned it ... </p><br><p>  Still, what's the catch?  Why is there no flatMap supermethod that works with objects of the <code>Future[Option[X]]</code> ? </p><br><blockquote>  Dear reader, take a deep breath: we are going to mention a few things from theory, but don't despair.  Here is all you need to know to read further: <br><ol><li>  <code>Functor</code> is a class with a <code>map</code> function. </li><li>  <code>Monad</code> is a class with the <code>flatMap</code> function. <br>  It's all.  I promise. </li></ol><br></blockquote><p>  This basic knowledge of category theory helps to solve the riddle. </p><br><p>  If you have two functors <code>A</code> and <code>B</code> (that is, you can call the <code>map</code> method on objects of class <code>A[X]</code> and on objects of class <code>B[X]</code> ), you can group them without knowing anything else about these classes.  You can take the class <code>A[B[X]]</code> and get the <code>Functor[A[B[X]]</code> by assembling <code>Functor[B[X]]</code> and <code>Functor[A[X]]</code> . </p><br><p>  In other words, if you know how to display inside <code>A[X]</code> and inside <code>B[X]</code> , you can also display inside <code>A[B[X]]</code> .  Automatically.  Easily. </p><br><p>  For monads, this is not true: the ability to perform <code>flatMap</code> on <code>A[X]</code> and <code>B[X]</code> does not automatically give you the ability to perform <code>flatMap</code> on <code>A[B[X]]</code> . </p><br><p>  It turns out that this is a well-known fact: <strong><a href="http://blog.tmorris.net/posts/monads-do-not-compose/">monads are not arranged</a></strong> , at least in the general case. </p><br><p>  Well, monads are not compiled <strong>in the general case</strong> , but you need <code>flatMap</code> and <code>map</code> methods that work on objects of the <code>Future[Option[A]]</code> class. </p><br><p>  We can definitely do that.  Let's write a wrapper for <code>Future[Option[A]]</code> with the <code>map</code> and <code>flatMap</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FutOpt</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Future</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Option</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">]]</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">FutOpt</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = <span class="hljs-type"><span class="hljs-type">FutOpt</span></span>(value.map(optA =&gt; optA.map(f))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatMap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">FutOpt</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>]): <span class="hljs-type"><span class="hljs-type">FutOpt</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = <span class="hljs-type"><span class="hljs-type">FutOpt</span></span>(value.flatMap(opt =&gt; opt <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(a) =&gt; f(a).value <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span>.successful(<span class="hljs-type"><span class="hljs-type">None</span></span>) })) }</code> </pre> <br><p>  Not bad!  Let's use it! </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUserId</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>]] = (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { user &lt;- <span class="hljs-type"><span class="hljs-type">FutOpt</span></span>(findUserById(id)) address &lt;- <span class="hljs-type"><span class="hljs-type">FutOpt</span></span>(findAddressByUser(user)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> address).value</code> </pre> <br><p>  Works! </p><br><p>  Well, this is if you have an object of type <code>Future[Option[A]]</code> .  But what if you have, say, <code>List[Option[A]]</code> ?  Maybe another wrapper will help?  Let's try: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListOpt</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Option</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">]]</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">ListOpt</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = <span class="hljs-type"><span class="hljs-type">ListOpt</span></span>(value.map(optA =&gt; optA.map(f))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatMap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">ListOpt</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>]): <span class="hljs-type"><span class="hljs-type">ListOpt</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = <span class="hljs-type"><span class="hljs-type">ListOpt</span></span>(value.flatMap(opt =&gt; opt <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(a) =&gt; f(a).value <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">None</span></span>) })) }</code> </pre> <br><p>  Yeah, she looks like <code>FutOpt</code> , right? </p><br><p>  If you look closely, it is clear that we do not need to know anything about the "external" monad ( <code>Future</code> or <code>List</code> from the previous examples).  As long as we can do <code>map</code> and <code>flatMap</code> , everything is fine.  On the other hand, remember how we analyzed the <code>Option</code> object?  You need to know the specifics of the "inner" monad (in this case, <code>Option</code> ) that we have. </p><br><p>  So, we can write a general data structure that wraps any monad <code>M</code> around the <code>Option</code> class. </p><br><p>  Awesome news: we accidentally came up with a <strong>monad transformer</strong> , which is usually called <code>OptionT</code> ! </p><br><p>  <code>OptionT</code> has two parameters <code>F</code> and <code>A</code> , where <code>F</code> is the wrapping monad and <code>A</code> is the type inside <code>Option</code> .  In other words, <code>OptionT[F, A]</code> is a flat version of <code>F[Option[A]]</code> and has <code>map</code> and <code>flatMap</code> . </p><br><blockquote><h1 id="klass-optiontf-a---eto-ploskaya-versiya-klassa-foptiona-i-on-sam-yavlyaetsya-monadoy">  class OptionT [F, A] is a flat version of class F [Option [A]], and is itself a monad </h1><br></blockquote><p>  Notice that the <code>OptionT</code> class <code>OptionT</code> also a monad, so we can use it in a <code>for</code> expression (after all, we have a city or a garden for this). </p><br><p>  If you use libraries like <a href="http://typelevel.org/cats/">cats</a> , many monad transformers ( <code>OptionT</code> , <code>EitherT</code> , ...) already exist in them. </p><br><p>  Let's return to our original example: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">OptionT</span></span>, cats.std.future._ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUserId</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Address</span></span>]] = (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { user &lt;- <span class="hljs-type"><span class="hljs-type">OptionT</span></span>(findUserById(id)) address &lt;- <span class="hljs-type"><span class="hljs-type">OptionT</span></span>(findAddressByUser(user)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> address).value</code> </pre> <br><p>  Works! </p><br><p>  Can we improve on something else?  Perhaps if we use wrappers all the time, it‚Äôs worth returning <code>OptionT[F, A]</code> of these methods: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUserById</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">OptionT</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>, <span class="hljs-type"><span class="hljs-type">User</span></span>] = <span class="hljs-type"><span class="hljs-type">OptionT</span></span> { ??? } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUser</span></span></span></span>(user: <span class="hljs-type"><span class="hljs-type">User</span></span>): <span class="hljs-type"><span class="hljs-type">OptionT</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>, <span class="hljs-type"><span class="hljs-type">Address</span></span>] = <span class="hljs-type"><span class="hljs-type">OptionT</span></span> { ??? } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddressByUserId</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">OptionT</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>, <span class="hljs-type"><span class="hljs-type">Address</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { user &lt;- findUserById(id) address &lt;- findAddressByUser(user) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> address</code> </pre> <br><p>  And this is very similar to our original code.  And when we need an actual value of type <code>Future[Option[Address]]</code> , we can simply call <code>value</code> . </p><br><p>  Before completing the article, a little caveat: </p><br><ul><li>  Monad transformers work well in some common cases (as in this), but don't get too carried away: <strong>I do not advise investing more than two monads into each other</strong> , otherwise the code will become complicated.  For a sad example, see this README: <a href="https://github.com/djspiewak/emm">https://github.com/djspiewak/emm</a> ; </li><li>  Monad transformers are not given for free in terms of memory allocation.  They use a lot of wrappers, so <strong>if you are worried about the speed of work, think twice</strong> and run the performance tests; </li><li>  Since they are not standard in the language (there are several implementations in the <a href="https://github.com/typelevel/cats">cats</a> , <a href="https://github.com/scalaz/scalaz">scalaz</a> libraries, and possibly others) <strong>do not expose them in your API</strong> .  Call <code>value</code> on the transformers and return just the class <code>A[B[X]]</code> .  It does not impose any restrictions on your users, and also allows you to change the internal implementation without making changes to the API. </li></ul><br><p>  I will add that monad transformers are <strong>just one of the ways to</strong> get rid of nested monads.  They are suitable if you have a simple problem and you do not want to change the code much, but if you are ready for more, pay attention to <a href="https://github.com/atnos-org/eff">the Eff library</a> . </p><br><hr><br><p>  So, I repeat, monad transformers help us in working with nested monads, providing a flat view of two nested monads, and are themselves monads. </p><br><p>  I hope I have proved that they are not as scary as they are called, and that you could come up with them yourself (or maybe they came up with them to some degree or another). </p><br><p>  There are standard application cases for them, but do not abuse them. </p><br><p>  If you want to know more on this topic, I talked about monad transformers at the <a href="http://scala-italy.it/">Scala Italy</a> conference last year: <a href="https://vimeo.com/170461662">https://vimeo.com/170461662</a> </p><br><p>  Happy (functional) programming! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/327030/">https://habr.com/ru/post/327030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327018/index.html">Welcome to VeloCPPed Meetup in Tensor</a></li>
<li><a href="../327020/index.html">TypeScript in Slack, or how to stop worrying and start trusting the compiler</a></li>
<li><a href="../327022/index.html">Forecasting financial time series with MLP in Keras</a></li>
<li><a href="../327024/index.html">List of IT companies that regularly conduct internships for students of southern Russia</a></li>
<li><a href="../327026/index.html">What programming languages ‚Äã‚Äãare popular late at night</a></li>
<li><a href="../327038/index.html">Gorilla: fast, scalable in-memory time-series database</a></li>
<li><a href="../327042/index.html">Videos: Moscow Zabbix Meetup in the office of Badoo</a></li>
<li><a href="../327044/index.html">Critical vulnerabilities are discovered in 25 Linksys Smart Wi-Fi devices.</a></li>
<li><a href="../327046/index.html">Performance comparison of the iron server and the Amazon cloud</a></li>
<li><a href="../327048/index.html">Analysis of communication from the Tor network to the infrastructure using the ELK stack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>