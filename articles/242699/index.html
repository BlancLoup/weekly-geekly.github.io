<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explore the internal mechanisms of Hyper-V</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If the work of a hacker, or rather a programmer-researcher, proceeded as shown in classic films: he came, tapped the keys, everything on the screen fl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explore the internal mechanisms of Hyper-V</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/91f/49b/495/91f49b4951554c6f90573c19ad580bc3.jpg"><br><br>  If the work of a hacker, or rather a programmer-researcher, proceeded as shown in classic films: he came, tapped the keys, everything on the screen flashed green, the passwords broke, and the money suddenly moved from point A to point B, then it was would definitely be easier and more fun.  But in reality, any serious hack is always preceded by thorough and boring analytical work.  Here we will deal with it, and we will roll out the results to your court in the form of a cycle of two articles.  Make sure you have enough beer and cigarettes - reading these materials is dangerous for the unprepared brain :). <br><a name="habracut"></a><br><br>  Detection of the bug that subsequently received the MS13-092 number (an error in the Hyper-V component of Windows Server 2012 that allows you to send the hypervisor to the BSOD from the guest OS or execute arbitrary code in other guest OS running on the vulnerable host server) was a very unpleasant surprise for Microsoft engineers.  Prior to that, for almost three years, no one had discovered vulnerabilities in Hyper-V.  Before it was only MS10-102, which was found at the end of 2010.  Over these four years, the popularity of cloud services has greatly increased, and researchers have shown an increasing interest in the security of the hypervisors underlying cloud systems.  However, the number of publicly available works is extremely small: researchers are reluctant to spend their time studying such complex and poorly documented architectural solutions.  This article does not cover the specific vulnerabilities of the hypervisor, but it should shed light on the work of some of the internal mechanisms of Hyper-V and thereby partially simplify future research. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote><h3>  INFO </h3><br><br>  Before reading the article, it is recommended that you read the ERNW report, the ‚ÄúHyper-V debugging for beginners‚Äù material, as well as the official document Hypervisor TLFS. </blockquote><br><br><h3>  VMBus </h3><br><br>  At the time of writing, Windows Server 2012 R2 Update 1 (machine type - Generation 1) was used as a Hyper-V server and guest OS, but other versions of Windows operating systems were used to reflect some features of the bus, which will be clearly indicated in article.  It is better to deploy the test environment in VMware Workstation 2014 July TechPreview or later, because in earlier versions, the bug in Workstation does not allow debugging of virtual machines over the network (or you must force the use of UEFI in the virtual machine configuration).  Also in the future it will be assumed that the stand is deployed on the Intel hardware platform and the functions of the hypervisor are implemented in hvix64.exe. <blockquote><h3>  Terms and Definitions </h3><br><ul><li>  Root partition (parent partition, root OS) - Windows Server 2012 R2 with the Hyper-V component enabled; </li><li>  Guest OS - Hyper-V virtual machine with Windows Server 2012 R2 installed; </li><li>  TLFS - Hypervisor Top-Level Functional Specification: Windows Server 2012 R2; </li><li>  LIS - Linux Integration Services; </li><li>  ACPI - Advanced Configuration and Power Interface </li></ul><br></blockquote><br><br><blockquote><h4>  About Vmbus </h4><br>  <a href="http://goo.gl/ZKQDTp">MSDN Hyper-V Architecture Article</a> <br><br></blockquote><br><br>  In short, VMBus is a technology of interaction between guest operating systems and root OS.  Accordingly, both in guest and root OS there are components that implement this interaction through the interfaces provided by the hypervisor and described in TLFS 4.0.  Microsoft is developing guest components for Linux-based operating systems that are integrated into the Linux kernel and are laid out separately on GitHub: <a href="">github.com/LIS/LIS3.5</a> . <br><br>  Beginning with Windows Server 2008, features have appeared in the Windows kernel that optimize the operating system in a virtual Hyper-V environment.  For comparison, the Windows Server 2008 (x64) core implements only 25 functions with the Hvl prefix, which identifies their belonging to the hypervisor integration library, 109 Hvl functions are already present in Windows Server 2012 R2. <br><br>  Consider how the VMBus bus components interact with the hypervisor, the root OS, and the guest OS.  First, look at the LIS source code and see that VMBus is a device that supports ACPI.  ACPI allows you to standardize a hardware platform for various operating systems and is implemented in Hyper-V (as, indeed, in other popular virtualization platforms), which allows you to use standard utilities to obtain the necessary information for research. <br><br>  ACPI devices can be viewed using the ACPI tool included in the older version of AIDA64 (later it was removed).  With it, two devices are detected in _SB.PCI0.SBRG: VMB8 and VMBS (see Figure 1). <br><br><img src="https://habrastorage.org/files/8e1/207/1e1/8e12071e1e4f4a66b9117fb643201c6f.png"><br>  Fig.  1. VMB8 and VMBS devices <br><br>  We will build the ACPI DSDT (Differentiated System Description Table) table, which contains information about peripheral devices and additional functions of the hardware platform, using the same ACPI Tool utility and decompiling the <a href="http://goo.gl/1pOZPX">AML disassembler</a> in ASL.  Get the dump shown in fig.  2 <br><br><img src="https://habrastorage.org/files/907/123/5e6/9071235e622a4af4bc66ce3198f969dd.png"><br>  Fig.  2. ASL dump <br><br>  A surface reading of the Advanced Configuration and Power Interface Specification 5.0 made it clear that if the guest OS is Windows 6.2 and higher, then the VMB8 device will be involved, otherwise VMBS.  The only difference between these devices is the _UID (Unique ID) object, which is present in VMB8.  If you believe the specifications for ACPI, then the presence of this object in the table is optional and is required only if the device cannot otherwise provide the operating system with a permanent unique device identifier.  Also became known resources that uses the device - interrupt 5 and 7. <br><br>  For comparison: in a Generation 2 virtual machine, there is only a VMBS device located in _SB_.VMOD.VMBS (but with a _UID object) that only uses interrupt 5 (see Figure 3). <br><br><img src="https://habrastorage.org/files/96b/1c7/fc1/96b1c7fc14c84973a2b31bad6a4dd5cd.png"><br>  Fig.  3. Part of ASL Dump Gen2 <br><br><h3>  Interrupt handling in a virtual environment </h3><br><br>  In Windows, interrupt processing is performed by procedures registered in the Interrupt Dispatch Manager Table (IDT).  There is no direct connection between ACPI DSDT IRQ 5 and 7 and handlers in IDT, and in order to match the interrupt to its handler, Windows uses the interrupt arbitrator (in general, there are several arbitrator classes besides IRQ, DMA, I / O, memory). <br><br><blockquote><h3>  Www </h3><br>  Everything about the referees in the MSDN blog <br><br>  <a href="http://goo.gl/FuvG4R">goo.gl/FuvG4R</a> <br>  <a href="http://goo.gl/V3UV8z">goo.gl/V3UV8z</a> <br>  <a href="http://goo.gl/h1vXaf">goo.gl/h1vXaf</a> <br><br></blockquote><br><br>  Information about registered arbitrators can be seen in WinDBG using the! Acpiirqarb command. <br><br>  kd \&gt;! acpiirqarb - For guest Windows Server 2012 R2 Gen1 (fig. 4): <br><br><img src="https://habrastorage.org/files/a33/9a2/391/a339a239131f4179bb4b1eb55b1805e3.png"><br>  Fig.  4.! Acpiirqarb Windows Server 2012 R2 Gen1 Guest <br><br>  The output of the command shows that for IRQ 7 the address of the handler will be in the 0x71 IDT element, for IRQ 5 - in 0x81.  The generation of interrupt handler numbers occurs in the acpi! ProcessorReserveIdtEntries function at the stage of building the device tree by the PnP manager, when the functional device driver is not yet loaded.  Registration of an ISR in IDT occurs already at later stages, for example, when the IoConnectInterrupt procedure is performed by the device driver itself.  However, looking at the IDT elements, we see that the ISRs for the 0x71 and 0x81 interrupts are not registered: <br><br><pre><code class="cpp hljs">kd\&gt; !idt -a ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶. <span class="hljs-number"><span class="hljs-number">71</span></span>: fffff80323f73938 nt!KxUnexpectedInterrupt0+<span class="hljs-number"><span class="hljs-number">0x388</span></span> <span class="hljs-number"><span class="hljs-number">81</span></span>: fffff80323f739b8 nt!KxUnexpectedInterrupt0+<span class="hljs-number"><span class="hljs-number">0x408</span></span> ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶.</code> </pre> <br><br>  In Windows Server 2012 R2 Gen2 for IRQ 5, the 0x90th IDT element was mapped. <br><br><pre> <code class="cpp hljs">kd\&gt; !acpiirqarb Processor <span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>): Device Object: <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> Current IDT Allocation: <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> - <span class="hljs-number"><span class="hljs-number">0000000000000050</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> \&lt;Not on bus\&gt; A:<span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> IRQ(GSIV):<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">0000000000000090</span></span> - <span class="hljs-number"><span class="hljs-number">0000000000000090</span></span> <span class="hljs-function"><span class="hljs-function">D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ffffe001f35eb520</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vmbus)</span></span></span><span class="hljs-function"> A:ffffc00133972660 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IRQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GSIV)</span></span></span><span class="hljs-function">:5 ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶.</span></span></code> </pre><br><br>  However, as the debugger shows, the ISR procedure for vector 0x90 is also undefined: <br><br><pre> <code class="cpp hljs"> kd\&gt; !idt -a <span class="hljs-number"><span class="hljs-number">90</span></span>: fffff8014a3daa30 nt!KxUnexpectedInterrupt0+<span class="hljs-number"><span class="hljs-number">0x480</span></span></code> </pre><br><br>  In Windows 8.1 x86, we see a slightly different picture: <br><br><pre> <code class="cpp hljs">kd\&gt; !acpiirqarb Processor <span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>): Device Object: <span class="hljs-number"><span class="hljs-number">00000000</span></span> Current IDT Allocation: ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶. <span class="hljs-number"><span class="hljs-number">0000000000000081</span></span> - <span class="hljs-number"><span class="hljs-number">0000000000000081</span></span> D <span class="hljs-number"><span class="hljs-number">87f</span></span>2f030 (vmbus) A:<span class="hljs-number"><span class="hljs-number">881642</span></span><span class="hljs-function"><span class="hljs-function">a8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IRQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GSIV)</span></span></span><span class="hljs-function">:fffffffe ‚Äî      MSI-. ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶. 00000000000000b2 - 00000000000000b2 SB 87</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f31030</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s3cap)</span></span></span><span class="hljs-function"> A:8814b840 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IRQ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GSIV)</span></span></span><span class="hljs-function">:5</span></span></code> </pre><br><br>  In this case, for the interruption with the number 0x81, the ISR-procedure vmbus! XPartPncIsr is defined: <br><br><pre> <code class="cpp hljs">kd\&gt; !idt <span class="hljs-number"><span class="hljs-number">81</span></span>: <span class="hljs-number"><span class="hljs-number">81b</span></span>18a0c vmbus!XPartPncIsr (KINTERRUPT <span class="hljs-number"><span class="hljs-number">87b</span></span>59e40 - (. . <span class="hljs-number"><span class="hljs-number">5</span></span>)) b2: <span class="hljs-number"><span class="hljs-number">81b</span></span>18c58 nt!KiUnexpectedInterrupt130</code> </pre><br><br>  s3cap is an auxiliary driver for working with an emulated Hyper-V video card S3 Trio. <br><br><img src="https://habrastorage.org/files/17a/1e8/707/17a1e870735b464c9dcdd33259c9961c.png"><br>  Vmbus interrupt object <br><br>  Thus, ISR vmbus! XPartPncIsr is registered in IDT only in Windows 8.1 x86 (presumably, in other x86 operating systems that Microsoft supports as guest OS for Hyper-V, the same method is used).  The vmbus! XPartPncIsr procedure is used to process interrupts generated by the hypervisor. <br><br>  In x64-bit systems, starting with Windows 8 \ Windows Server 2012, integration with the hypervisor is implemented somewhat differently.  Handheld interrupt handlers generated by the hypervisor have been added to IDT operating systems.  Briefly consider how IDT is formed at the Windows startup stage. <br><br>  After initializing the Windows loader, winload.efi IDT looks like this (outputting the script to pykd at the WinDBG breakpoint in winload.efi when booting the operating system with the / bootdebug option): <br><br><pre> <code class="cpp hljs"> kd\&gt; !py D:\\hyperv4\\idt\_winload\_parse.py isr <span class="hljs-number"><span class="hljs-number">1</span></span> address = winload!BdTrap01 isr <span class="hljs-number"><span class="hljs-number">3</span></span> address = winload!BdTrap03 isr d address = winload!BdTrap0d isr e address = winload!BdTrap0e isr <span class="hljs-number"><span class="hljs-number">29</span></span> address = winload!BdTrap29 isr <span class="hljs-number"><span class="hljs-number">2</span></span>c address = winload!BdTrap2c isr <span class="hljs-number"><span class="hljs-number">2</span></span>d address = winload!BdTrap2d</code> </pre><br><br>  Then, during the execution of winload! OslArchTransferToKernel IDT is reset, control is transferred to the Windows kernel, where, in the nt! KiInitializeBootStructures IDT function, initialized with values ‚Äã‚Äãfrom the KiInterruptInitTable table: <br><br><pre> <code class="cpp hljs"> kd\&gt; dps KiInterruptInitTable L40 ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶. fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>9553c0 <span class="hljs-number"><span class="hljs-number">00000000</span></span>\`<span class="hljs-number"><span class="hljs-number">00000030</span></span> fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>9553c8 fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>377160 nt!KiHvInterrupt fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>9553d0 <span class="hljs-number"><span class="hljs-number">00000000</span></span>\`<span class="hljs-number"><span class="hljs-number">00000031</span></span> fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>9553d8 fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>3774c0 nt!KiVmbusInterrupt0 fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>9553e0 <span class="hljs-number"><span class="hljs-number">00000000</span></span>\`<span class="hljs-number"><span class="hljs-number">00000032</span></span> fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>9553e8 fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>377810 nt!KiVmbusInterrupt1 fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>9553f0 <span class="hljs-number"><span class="hljs-number">00000000</span></span>\`<span class="hljs-number"><span class="hljs-number">00000033</span></span> fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>9553f8 fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>377b60 nt!KiVmbusInterrupt2 fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>955400 <span class="hljs-number"><span class="hljs-number">00000000</span></span>\`<span class="hljs-number"><span class="hljs-number">00000034</span></span> fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>955408 fffff800\`<span class="hljs-number"><span class="hljs-number">1b</span></span>377eb0 nt!KiVmbusInterrupt3 ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶.</code> </pre><br><br>  Accordingly, the 0x30-0x34 system interrupt handlers after the completion of initialization will look like this: <br><br><pre> <code class="cpp hljs">kd\&gt; !idt ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶. <span class="hljs-number"><span class="hljs-number">30</span></span>: fffff8001b377160 nt!KiHvInterrupt <span class="hljs-number"><span class="hljs-number">31</span></span>: fffff8001b3774c0 nt!KiVmbusInterrupt0 <span class="hljs-number"><span class="hljs-number">32</span></span>: fffff8001b377810 nt!KiVmbusInterrupt1 <span class="hljs-number"><span class="hljs-number">33</span></span>: fffff8001b377b60 nt!KiVmbusInterrupt2 <span class="hljs-number"><span class="hljs-number">34</span></span>: fffff8001b377eb0 nt!KiVmbusInterrupt3 ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶.</code> </pre><br><br>  A second-generation virtual machine in Hyper-V can only be created on the basis of an OS containing five additional handlers in the kernel described above.  In order to generate interrupts, Intel introduces the hardware function of virtual interrupt delivery, however, Hyper-V does not use this capability to transfer control to these handlers.  Instead, in the hypervisor, the bit corresponding to the vector number is activated in a special memory area using an instruction like lock bts [rcx + 598h], rax, where rax is the interrupt vector number (0x30‚Äì0x32), so, perhaps, the developers of Hyper- V considered the option of registering the vmbus! XPartPncIsr procedure as a handler as a less productive solution than the option of generating interrupts via APIC virtualization based on data in the SINTx virtual registers. <br><br>  These handlers are registered with IDT even if the operating system is operating outside the Hyper-V environment.  Each handler calls HvlRouteInterrupt, passing the index as a parameter (see Figure 6). <br><br><img src="https://habrastorage.org/files/4f3/ba1/cec/4f3ba1cece424701a492d31be13f55cc.png"><br>  Fig.  6. Additional Windows System Handlers <br><br>  HvlRouteInterrupt looks as follows (Fig. 7). <br><br><img src="https://habrastorage.org/files/c86/1d4/786/c861d47865c04b95ace7719c36454979.png"><br>  Fig.  7. HvlRouteInterrupt <br><br>  This function calls the handler from the HvlpInterruptCallback pointer array, depending on the index value.  This array in root OS looks like this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">5</span></span>: kd\&gt; dps HvlpInterruptCallback fffff802\`fff5cc30 fffff800\`dc639d50 winhvr!WinHvOnInterrupt fffff802\`fff5cc38 fffff800\`dd5a9ec0 vmbusr!XPartEnlightenedIsr fffff802\`fff5cc40 fffff800\`dd5a9ec0 vmbusr!XPartEnlightenedIsr fffff802\`fff5cc48 fffff800\`dd5a9ec0 vmbusr!XPartEnlightenedIsr fffff802\`fff5cc50 fffff800\`dd5a9ec0 vmbusr!XPartEnlightenedIsr fffff802\`fff5cc58 <span class="hljs-number"><span class="hljs-number">00000000</span></span>\`<span class="hljs-number"><span class="hljs-number">00000000</span></span></code> </pre><br><br>  The XPartEnlightenedIsr on the index passed from KiVmbusInterruptX adds one of two possible functions from the array of DPC structures to the vmbusr to the DPC queue: vmbusr! ParentInterruptDpc or vmbusr! ParentRingInterruptDpc (Figure 8). <br><br><img src="https://habrastorage.org/files/049/1ff/1d6/0491ff1d68d34a52970d68da1bb7c2ce.png"><br>  Fig.  8. DPC objects <br><br>  The number of DPC structures in the array is determined by the function vmbusr! XPartPncPostInterruptsEnabledParent and depends on the number of logical processors in the root OS.  For each logical processor, DPC with vmbusr! ParentInterruptDpc and vmbusr! ParentRingInterruptDpc is added.  The vmbusr! ParentRingInterruptDpc function determines the address of the DPC procedure for nt! KeInsertQueueDpc based on which processor is currently running. <br><br>  In the guest OS, VMBus registers in the HvlpInterruptCallback array only one handler: <br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span>: kd\&gt; dps HvlpInterruptCallback fffff803\`<span class="hljs-number"><span class="hljs-number">1</span></span>d171c30 fffff800\`<span class="hljs-number"><span class="hljs-number">6</span></span>d7c5714 winhv!WinHvOnInterrupt fffff803\`<span class="hljs-number"><span class="hljs-number">1</span></span>d171c38 fffff800\`<span class="hljs-number"><span class="hljs-number">6</span></span>d801360 vmbus!XPartEnlightenedIsr fffff803\`<span class="hljs-number"><span class="hljs-number">1</span></span>d171c40 <span class="hljs-number"><span class="hljs-number">00000000</span></span>\`<span class="hljs-number"><span class="hljs-number">00000000</span></span></code> </pre><br><br>  The HvlpInterruptCallback array is filled with the kernel exported nt! HvlRegisterInterruptCallback function.  The WinHvOnInterrupt handler is registered when the winhvr.sys driver is loaded (winhvr! WinHvpInitialize-&gt; winhvr! WinHvReportPresentHypervisor-&gt; winhvr! WinHvpConnectToHypervisor-&gt; nt! HvlRegisterInterruptCallback) / <br><br>  The remaining four handlers are registered by the vmbusr.sys driver when it is loaded by the PnP manager (vmbusr! RootDevicePrepareHardwareParent-&gt; nt! HvlRegisterInterruptCallback). <br><br>  Let's try to figure out how the hypervisor passes control to the system interrupt handlers.  To do this, refer to the TLFS Virtual Interrupt Control section.  In short, Hyper-V manages interrupts in the guest OS via a synthetic interrupt controller (SynIC), which is an extension of the virtualized local APIC and uses an additional set of memory mapped registers.  That is, each virtual processor, in addition to the usual APIC, has an additional SynIC.  SynIC contains two pages: SIM (synthetic interrupt message flags) and SIEF (synthetic interrupt event flags).  SIEF and SIM are arrays of 16 elements, the element size is 256 bytes.  The physical addresses (to be more precise, GPA) of these arrays are located in the SIEF and SIMP MSR registers, respectively.  The addresses of these pages for each logical processor will be different.  Also for SynIC, 16 SINTx registers are defined.  Each of the elements of the SIEF and SIM arrays is associated with the corresponding SINTx register.  WinDBG displays the contents of the SINTx registers using the! Apic command (starting with WinDBG 6.3). <br><br><img src="https://habrastorage.org/files/cac/dc8/725/cacdc8725d1c4e7eba5bfa5e68f520a9.png"><br>  ! apic in root OS <br><br><img src="https://habrastorage.org/files/071/03e/425/07103e425f454986b2104f816a82bd26.png"><br>  ! apic in the guest OS <br><br>  The configuration of the SINT0 and SINT1 registers is performed by the nt! HvlEnlightenProcessor function by writing parameters to the MSR registers 40000090h and 40000091h, respectively.  SINT4 and SINT5 are configured by the driver vmbusr.sys: vmbusr! XPartPncPostInterruptsEnabledParent-&gt; winhvr! WinHvSetSint-&gt; winhvr! WinHvSetSintOnCurrentProcessor.  SINT2 in the guest OS is configured by the vmbus.sys driver in the winhv! WinHvSetSintOnCurrentProcessor function. <br><br>  Each SINTx has an 8-bit Vector field.  The value of this field determines to which interrupt handling procedure control will be transferred when executing hypercalls, in the parameters of which the PortID (HvSignalEvent, HvPostMessage) is set. <br><br>  SINTx can be specified implicitly (for example, for an interception message it will always be controlled by the SINT0 register and the SIM page is located in the first element), explicitly (for timer messages) or specified in the parameters of the port created using the HvCreatePort hypercall.  One of the parameters is PortTypeInfo.  If the port type is HvPortTypeMessage or HvPortTypeEvent, then in the PortTypeInfo parameter there is a TargetSint containing the SINT number to which the port will be attached and the value of which can be from 1 to 15 (SINT0 is reserved for messages from the hypervisor and cannot be specified as TargetSint when creating a port). <br><br>  An analysis of the values ‚Äã‚Äãof the active SINT registers in root OS shows that only three system interrupt handlers (KiHvInterrupt, KiVmbusInterrupt0, KiVmbusInterrupt1) out of five will be involved in the work.  For what purposes the KiVmbusInterrupt2 and KiVmbusInterrupt3 system handlers were added to the kernel, could not be detected.  They may be needed on servers with a large number of logical processors (for example, 64), but, unfortunately, we failed to verify this in the test environment.  Also, by the values ‚Äã‚Äãof the SINTx registers, it is clear that the nt! KiHvInterrupt handler (vector 30) will be called both when generating interrupts from the hypervisor and through ports created with the TargetSint parameter equal to 1. <br><br><h3>  Windows and TLFS </h3><br><br>  For example, consider the parameters of ports that are created when activating each of the services of guest components of Hyper-V integration.  In fig.  11 shows the characteristics of the ports created for the operation of integration services (one port for each component). <br><br><img src="https://habrastorage.org/files/d51/6c2/eca/d516c2ecae1442169a6550c4df070343.png"><br>  Fig.  11. Ports of integration services <br><br>  The interaction of the root OS and the guest OS during the operation of the Integration Services components occurs through the 5th element of the SIEF array, that is, the handler at root of the OS will be KiVmbusInterrupt1. <br><br>  The number of each next created port is equal to the previous one, increased by 1. That is, if you disable all integration services and then enable them again, the port numbers created for these services will be in the range from 0x22 to 0x27. <br><br>  You can see the port settings if you connect the debugger directly to the hypervisor and monitor the data passed to the HvCreatePort hypervisor callback, or you can connect the debugger to the kernel and track the WinHvCreatePort function parameters in the winhvr.sys driver. <br><br>  The remaining ports that are created when the guest OS is turned on (the number of ports depends on the configuration of the guest operating system) are shown in Figure.  12. The numbering is given in the order of creation of ports when you turn on the Windows Server 2012 R2 virtual machine with the default hardware configuration. <br><br><img src="https://habrastorage.org/files/d51/6c2/eca/d516c2ecae1442169a6550c4df070343.png"><br>  Fig.  12. Ports created when you start the virtual machine00000000000000. <br><br>  It is important to note that the zero SIM slot in both the guest and the parent OS is reserved for sending messages from the hypervisor.  The format of such messages is documented in TLFS.  When transferring data through the remaining slots, a different data format is used.  VMBus messages are not documented, but the necessary information to work with them is present in the LIS source codes. <br><br>  Some information about the processing of VMBus messages by the vmbusr.sys driver (see Figure 13).  Such messages in the root OS are processed by the vmbusr! ChReceiveChannelMessage function, which analyzes the contents of the 4th SIM slot and determines the code of the VMBus message.  If it is 0 (CHANNELMSG_INVALID) or more than 0x12, then the function returns an error and 0xC000000D (STATUS_INVALID_PARAMETER).  Otherwise, the function processes the message sent by the guest or root OS.  For example, when the Guest Services root OS component is enabled, the guest OS sends a message to CHANNELMSG_OFFERCHANNEL, in response, the caller system sends the changes to the current system, CHANNELMSG_GPADL_HEADER; .  It is worth paying attention to the fact that, before processing each valid message, the ChReceiveChannelMessage function checks the sent message (ChpValidateMessage), in particular for who the sender (root OS or guest OS) is, the minimum size of the message body.  Each type of message has its own verification conditions.  In fig.  13 marked those messages that will be processed if they are sent to the guest OS (may be interesting, for example, to create a fuzzer). <br><br><img src="https://habrastorage.org/files/6ba/b10/3a8/6bab103a8ebc4a9f89d2c7186390eb84.png"><br>  Fig.  13. VMBus messages processed by the vmbusr.sys driver <br><br><br>  In order to understand what kind of messages the root OS and the guest OS are exchanging, we will write a driver that replaces the addresses of the handlers from the HvlpInterruptCallback array in the root OS with their own handlers.  But about this - in the next article. <br><br><h3>  Conclusion </h3><br><br>  In the first part of the article, changes in the operating system kernel made by Microsoft to optimize work in a virtual environment and affecting the operation of VMBus were analyzed.  In this issue] [we have analyzed the theory, and the following will be published the practical part of the study, so please be patient. <br><br> <a href="http://xakep.ru/issue/xa-190/"><img src="https://habrastorage.org/files/b07/165/e66/b07165e660e2464eba72b7315b5edb85.png"></a> <br>  <i>First published in Hacker magazine dated 11/2014.</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://j.mp/Xakep_ipad_xakep_ru">Hacker on iOS / iPad</a> </li><li>  <a href="http://j.mp/Xakep_android_xakep_ru">"Hacker" on Android</a> </li></ul><br> <a href="http://j.mp/Xakep_ipad_xakep_ru"><img src="http://imageshack.com/a/img23/2983/mmzp.jpg"></a> <br><br> <a href="http://j.mp/Xakep_android_xakep_ru"><img src="http://imageshack.com/a/img541/6900/9wak.jpg"></a> </div><p>Source: <a href="https://habr.com/ru/post/242699/">https://habr.com/ru/post/242699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242685/index.html">Codeship.io: a free CI server for a private Github / Bitbucket repository</a></li>
<li><a href="../242687/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ21 (November 3 - 9, 2014)</a></li>
<li><a href="../242691/index.html">HR Acquisition Payoneer</a></li>
<li><a href="../242695/index.html">Expressive JavaScript: Regular Expressions</a></li>
<li><a href="../242697/index.html">Features of loading objects from a KML map onto a Yandex map</a></li>
<li><a href="../242701/index.html">A / B testing: 70 resources that will serve as a good start for beginners</a></li>
<li><a href="../242707/index.html">The story of how a mobile operator wrote off money from the developer Dr. Tariff (grab popcorn)</a></li>
<li><a href="../242709/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ133 (November 3 - 9, 2014)</a></li>
<li><a href="../242711/index.html">Polytech 2.0: First chips!</a></li>
<li><a href="../242713/index.html">Runner under iOS with five characters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>