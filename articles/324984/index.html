<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basic concepts of the chrono library (C ++)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Working with time as with a dimensionless quantity can lead to misunderstandings and errors in converting temporary units of measurement: 
 - Listen, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basic concepts of the chrono library (C ++)</h1><div class="post__text post__text-html js-mediator-article"><p>  Working with time as with a dimensionless quantity can lead to misunderstandings and errors in converting temporary units of measurement: </p><br><blockquote>  <em>- Listen, you do not remember, we pass seconds or milliseconds to sleep?</em> <br><br>  <em>- Damn, it turns out I have 360 ‚Äã‚Äãseconds in an hour, I missed zero.</em> </blockquote><p>  To avoid such errors, the chrono library (namespace std :: chrono) is provided.  It was added in C ++ 11 and refined in later standards.  Now everything is logical: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_answer_to_the_ultimate_question_of_life</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  std::this_thread::sleep_for(5s); //5  return 42; } std::future&lt;int&gt; f = std::async(find_answer_to_the_ultimate_question_of_life); //  2.5  if (f.wait_for(2500ms) == std::future_status::ready) std::cout &lt;&lt; "Answer is: " &lt;&lt; f.get() &lt;&lt; "\n"; else std::cout &lt;&lt; "Can't wait anymore\n";</span></span></code> </pre> <br><p>  The library implements the following concepts: </p><br><ul><li>  time intervals - <code>duration</code> ; </li><li>  time points - <code>time_point</code> ; </li><li>  Timers - <code>clock</code> . </li></ul><a name="habracut"></a><br><h2 id="stdratio">  std :: ratio </h2><br><p>  std :: ratio - template class that implements compile-time ordinary fraction (m / n).  It does not belong to chrono, but is actively used by this library, therefore, first of all, we will get acquainted with it, so that it does not cause further questions. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">intmax_t</span></span> Num, <span class="hljs-comment"><span class="hljs-comment">// std::intmax_t Denom = 1 // &gt; class ratio;</span></span></code> </pre> <br><p>  It is important that the numerator and denominator - constexpr template parameters.  This allows the type to be built at compile time.  This class is auxiliary (purely static, helper class), and generally speaking, not intended for mathematical calculations.  It is needed to effectively convert units of measurement.  For example, we want to work with different distance units: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ratio</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Length</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> length_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length_; } }; Length&lt;Mm&gt; len1(<span class="hljs-number"><span class="hljs-number">127.0</span></span>); Length&lt;Inches&gt; len2(<span class="hljs-number"><span class="hljs-number">5.0</span></span>); Length&lt;Mm&gt; len3 = len1 + len2;</code> </pre> <br><p>  Let the millimeter be the base unit, then: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Mm = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;; <span class="hljs-comment"><span class="hljs-comment">// == 1 //    ,   : using Inches = std::ratio&lt;254, 10&gt;; using Metre = std::ratio&lt;1000, 1&gt;;</span></span></code> </pre> <br><p>  In the constructor, it was possible to convert to the base unit.  But, more correctly, only where this transformation is needed.  Because meters to millimeters can be converted without fear of loss when rounding, which is not the opposite. </p><br><p>  In connection with the foregoing, just to complete the example, I cite not the most successful implementation of the addition operation, but a simple one: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ratio1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ratio2</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Length</span></span></span><span class="hljs-class">&lt;Mm&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Length</span></span></span><span class="hljs-class">&lt;_Ratio1&gt; &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">left</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Length</span></span></span><span class="hljs-class">&lt;_Ratio2&gt; &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">right</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> len = left.length() / _Ratio1::den * _Ratio1::num + right.length() / _Ratio2::den * _Ratio2::num; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Length&lt;Mm&gt;((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)len); }</code> </pre> <br><p>  It would be correct to receive meters when adding meters and kilometers. </p><br><h2 id="duration---interval-vremeni">  duration - time interval </h2><br><p>  The template class std :: chrono :: duration is a type of time interval.  The time interval in chrono is a certain number of periods (in the original tick period).  This number is characterized by the type, for example <code>int64_t</code> or <code>float</code> .  The duration of the period is measured in seconds and is represented as a natural fraction using the std :: ratio. </p><br><p>  Some popular intervals are already defined in the library.  Types may vary slightly in different implementations. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> nanoseconds = duration&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, nano&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> microseconds = duration&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, micro&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> milliseconds = duration&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, milli&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> seconds = duration&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> minutes = duration&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ratio&lt;<span class="hljs-number"><span class="hljs-number">60</span></span>&gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> hours = duration&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ratio&lt;<span class="hljs-number"><span class="hljs-number">3600</span></span>&gt; &gt;; <span class="hljs-comment"><span class="hljs-comment">// nano, micro, milli: using nano = ratio&lt;1, 1000000000&gt;; using micro = ratio&lt;1, 1000000&gt;; using milli = ratio&lt;1, 1000&gt;;</span></span></code> </pre> <br><p>  But you can define your own: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono; <span class="hljs-comment"><span class="hljs-comment">//3-   using Hourglass = duration&lt;long, std::ratio&lt;180&gt;&gt;; // using Hourglass = duration&lt;long, std::ratio_multiply&lt;std::ratio&lt;3&gt;, minutes::period&gt;&gt;; //      2.75  using MyTimeUnit = duration&lt;long, std::ratio&lt;11, 4&gt;&gt;; //  .   using fseconds = duration&lt;float&gt;; // -   using seconds16 = duration&lt;uint16_t&gt;;</span></span></code> </pre> <br><p>  Now how to work with them.  Implicit initialization is prohibited: </p><br><pre> <code class="cpp hljs">seconds s = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// void foo(minutes); foo(42); //</span></span></code> </pre> <br><p>  Only explicit: </p><br><pre> <code class="cpp hljs">seconds s{<span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(minutes)</span></span></span></span>; foo(minutes{<span class="hljs-number"><span class="hljs-number">42</span></span>});</code> </pre> <br><p>  By the way, why use curly braces can read, for example, <a href="https://stackoverflow.com/questions/18222926/why-is-list-initialization-using-curly-braces-better-than-the-alternatives">here</a> .  In short: to avoid implicit conversion of integral types with losses.  I will add another case when <code>T x(F());</code>  instead of initializing x, it is interpreted as a declaration of a function that takes a pointer to a function of type <code>F(*)()</code> and returns <code>T</code>  Solution: <code>T x{F()};</code>  or <code>T x((F()));</code>  . </p><br><p>  C ++ 14 adds custom literals for basic units: </p><br><pre> <code class="cpp hljs">seconds s = <span class="hljs-number"><span class="hljs-number">4</span></span>min; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(minutes)</span></span></span></span>; foo(<span class="hljs-number"><span class="hljs-number">42</span></span>min);</code> </pre> <br><p>  You can add, subtract and compare: </p><br><pre> <code class="cpp hljs">seconds time1 = <span class="hljs-number"><span class="hljs-number">5</span></span>min + <span class="hljs-number"><span class="hljs-number">17</span></span>s; minutes time2 = <span class="hljs-number"><span class="hljs-number">2</span></span>h - <span class="hljs-number"><span class="hljs-number">15</span></span>min; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> less = <span class="hljs-number"><span class="hljs-number">59</span></span>s &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>min;</code> </pre> <br><p>  As in the example above, you can implicitly convert hours to minutes, minutes to seconds, seconds to milliseconds, etc., but not vice versa: </p><br><pre> <code class="cpp hljs">minutes time3 = <span class="hljs-number"><span class="hljs-number">20</span></span>s; <span class="hljs-comment"><span class="hljs-comment">//   seconds time4 = 2s + 500ms; //  </span></span></code> </pre> <br><p>  In general, implicit conversion for integer types is allowed if the ratio of periods is an integer: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//(20/15) / (1/3) = 4. ! duration&lt;long, std::ratio&lt;1, 3&gt;&gt; t1 = duration&lt;long, std::ratio&lt;20, 15&gt;&gt;{ 1 };</span></span></code> </pre> <br><p>  Otherwise, there are 2 ways: rounding and conversion to float-type. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   -     minutes m1 = duration_cast&lt;minutes&gt;(-100s); //-1m //C++17.      minutes m2 = round&lt;minutes&gt;(-100s); //-2m //C++17.      minutes m3 = ceil&lt;minutes&gt;(-100s); //-1m //C++17.      minutes m4 = floor&lt;minutes&gt;(-100s); //-2m</span></span></code> </pre> <br><p>  The second option: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> fminutes = duration&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, minutes::period&gt;; fminutes m = <span class="hljs-number"><span class="hljs-number">-100</span></span>s;</code> </pre> <br><p>  Suppose you have a redundant representation of the number of seconds with the type uint64_t.  OK: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> seconds16 = duration&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>, seconds::period&gt;; seconds16 s = <span class="hljs-number"><span class="hljs-number">15</span></span>s;</code> </pre> <br><p>  But you still fear overflow.  You can use the class from the library to work safely with numbers.  There is no such standard in the standard (only a proposal), but there are third-party implementations.  Also in VS, we use it: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;safeint.h&gt; using sint = msl::utilities::SafeInt&lt;uint16_t&gt;; using safe_seconds16 = duration&lt;sint, seconds::period&gt;; safe_seconds16 ss = 60000s; try { ss += 10000s; } catch (msl::utilities::SafeIntException e) { // };</span></span></span></span></code> </pre> <br><p>  To display the interval value on the screen or in a file, you need to use count (): </p><br><pre> <code class="cpp hljs">seconds s = <span class="hljs-number"><span class="hljs-number">15</span></span>s; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s.count() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"s\n"</span></span>;</code> </pre> <br><p>  But do not use count for internal transformations! </p><br><h2 id="time_point---moment-vremeni">  time_point - time </h2><br><p>  The class time_point is intended to represent moments of time.  The moment of time can be characterized as a time interval measured on any timer, starting from a certain point of reference.  For example, if you are cooking soup using a stopwatch, your time points can be represented as follows: </p><br><pre> <code class="hljs">0 :      420 :   1300 : </code> </pre> <br><p>  And if on the minute hand of a wall clock, then the same points in time can be: </p><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-built_in"><span class="hljs-built_in"></span></span>:      <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-built_in"><span class="hljs-built_in"></span></span>:   <span class="hljs-number"><span class="hljs-number">39</span></span> <span class="hljs-built_in"><span class="hljs-built_in"></span></span>: </code> </pre> <br><p>  So the class itself: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duration</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clock</span></span></span><span class="hljs-class">:</span></span>:duration &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">time_point</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><p>  The type of time interval is already familiar to us, now let's move on to the Clock timer.  The library has 3 timers: </p><br><ol><li>  system_clock - represents the system time.  Usually this timer is not suitable for measuring intervals, since during the measurement time can be changed by the user or by the synchronization process.  Usually based on the amount of time elapsed since 01/01/1970, but this is not specified. </li><li>  steady_clock - represents the so-called stable clock, that is, the course of which is not subject to external changes.  Well suited for measuring intervals.  Usually its implementation is based on the time the system has been running after power on. </li><li>  high_resolution_clock is a timer with the smallest possible sample period available to the system.  It may be a pseudonym for one of those reviewed (almost certainly steady_clock). </li></ol><br><p>  Clock has a static variable <code>is_steady</code> , by which you can find out if the timer is monotonous.  Clock also has a now function, which returns the current time in the form of time_point.  By itself, the object of the class <code>time_point</code> not very interesting, since the moment of its origin is not specific and makes little sense.  But you can add time intervals to it and compare it with other points in time: </p><br><pre> <code class="cpp hljs">time_point&lt;steady_clock&gt; start = steady_clock::now(); <span class="hljs-comment"><span class="hljs-comment">// steady_clock::time_point start = steady_clock::now(); // auto start = steady_clock::now(); foo(); if (steady_clock::now() &lt; start + 1s) std::cout &lt;&lt; "Less than a second!\n";</span></span></code> </pre> <br><p>  <code>time_point</code> cannot be added to <code>time_point</code> , but you can subtract, which is useful for time tracking: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> start = steady_clock::now(); foo(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> end = steady_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> elapsed = duration_cast&lt;milliseconds&gt;(end - start);</code> </pre> <br><p>  To get the time interval that has passed since the beginning of the countdown, you can call <code>time_since_epoch</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now = system_clock::now(); system_clock::duration tse = now.time_since_epoch();</code> </pre> <br><p>  The <code>time_point</code> to a number, for example, for serialization or display, can be done through the time_t C-type: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now = system_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now_t</span></span> = system_clock::<span class="hljs-keyword"><span class="hljs-keyword">to_time_t</span></span>(now); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now2 = system_clock::<span class="hljs-keyword"><span class="hljs-keyword">from_time_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">now_t</span></span>);</code> </pre> <br><h2 id="vmesto-zaklyucheniya">  Instead of conclusion </h2><br><p>  The most common question: how to display the time and date in a readable form.  With the help of chrono in any way.  You can play with time_t or use <a href="https://howardhinnant.github.io/date/date.html">another library</a> from the chrono developer. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324984/">https://habr.com/ru/post/324984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324970/index.html">Adaptive Email Guide</a></li>
<li><a href="../324974/index.html">Open lecture by Sergei Zykov on April Fools ‚Äôactions in games</a></li>
<li><a href="../324978/index.html">Cones stuffed with 15 years of using actors in C ++. Part II</a></li>
<li><a href="../324980/index.html">Webinar "Testing applications for vulnerabilities. The practice of building SDLC</a></li>
<li><a href="../324982/index.html">First experience with Google API (for example, ContactsAPI) and OAuth2.0 on pure HTTP</a></li>
<li><a href="../324986/index.html">Calculation of the correcting FIR filter on the FPGA</a></li>
<li><a href="../324988/index.html">Java implementation of a hashed binary tree</a></li>
<li><a href="../324990/index.html">Advantages of SDN: on the example of VMware vSphere integration with Huawei Cloud Fabric</a></li>
<li><a href="../324992/index.html">How to create an Internet of things from LEGO bricks based on AWS IoT platform</a></li>
<li><a href="../324994/index.html">Native Data Centers: Overview of Russian Data Centers (Part 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>