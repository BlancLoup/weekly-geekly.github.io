<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features rendering in the game Metro: Exodus c raytracing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 After the release of the last game from the Metro series, I spent a few hours studying its internal work and decided to share what might se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features rendering in the game Metro: Exodus c raytracing</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6c/122/9f2/b6c1229f21aaaefc416b180a41759690.jpg" alt="image"></div><br><h3>  Foreword </h3><br>  After the release of the last game from the Metro series, I spent a few hours studying its internal work and decided to share what might seem interesting from a technological point of view.  I will not conduct a detailed analysis or study the disassembled shader code, but will show the high-level decisions made by the developers in the process of creating the game. <br><br>  At the moment, the developers have not yet talked about the rendering techniques used in the game.  The only official source of information is the <a href="https://schedule.gdconf.com/session/exploring-the-ray-traced-future-in-metro-exodus-presented-by-nvidia/865258" rel="noreferrer noopener">GDC report</a> , which cannot be found anywhere else on the Internet.  And it is annoying, because the game works on a very interesting own engine, which evolved from the previous games of the Metro series.  This is one of the first games that use <a href="https://en.wikipedia.org/wiki/DirectX_Raytracing">DXR</a> . <br><br>  Note: this article is not a complete description and I will come back to it if I find something worth adding.  Maybe I missed something, because some aspects appear only in the next stages of the game, or I just looked at the details. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  The first steps </h3><br>  It took me several days to search for an environment capable of working with this game.  Having tested several versions of RenderDoc and PIX, I stopped to study the results of ray tracing using Nvidia NSight.  I wanted to study rendering without raytracing functions, but NSight allowed me to explore the details of this function, so I decided to leave it turned on.  For the rest of the rendering, the PIX was quite appropriate.  Screenshots are made using both applications. <br><a name="habracut"></a><br>  NSight has one drawback - it does not support saving capture to a file, so I could not go back to the frames I studied. <br><br>  At the very beginning of my work, I also encountered another problem that was not related to frame debugging applications: the ray tracing functions required installing the latest Windows update, but the game made it possible to enable them in options without installing the update.  In this case, the inclusion of functions led to the failure of the game at launch.  GeForce Experience also did not report the need for the correct version of Windows to enable these features.  This problem needs to be addressed on both sides. <br><br>  For the sake of completeness, I made captures from a game launched with the highest possible parameters, but without DLSS. <br><br><h3>  Frame analysis </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/541/f12/e34/541f12e34559d73faa7eb743915e5cdd.png"></div><br>  <i>Ready frame</i> <br><br>  A brief analysis of the rendering demonstrates a fairly standard set of functions, with the exception of global illumination performed by ray-traced ray (GI). <br><br>  Before rendering the image, the scale of the previous frame is reduced in the compute queue and the average brightness is calculated. <br><br>  The graphic queue begins with the rendering of distortion particles (droplets on the camera), which are applied at the post-processing stage.  Then a quick preview of the depths creates a portion of the depths in front of the Gbuffer;  it seems that it renders only relief. <br><br>  The GBuffer pass fills the 4 render target as shown below, and also completes the depth buffer filling. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a67/9ef/332/a679ef3320584af81cc4d3c6970fecd1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/c7d/d77/97bc7dd7753e655aec4a8279851e78be.png"></div><br>  <i>1. Target in RGBA8 format with albedo and, possibly, Ambient Occlusion in the alpha channel;</i>  <i>on some surfaces it looks very dark.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ff/a5f/972/8ffa5f972989ecb5104c92cf1e56ddc0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/580/93a/6e158093ac061f9c993fc5d954d3a383.png"></div><br>  <i>2. Target in RGB10A2 format with normals and, possibly, a subsurface scattering mask in the alpha channel.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/cab/600/aedcab600ed86cab9d6fff32d005365b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/7e8/64e/d9e7e864ecc5794d64a9f0923153f673.png"></div><br>  <i>3. Target in RGBA8 format with different material parameters, probably metalness and roughness in the alpha channel.</i>  <i>Curiously, the RGB channels in this case contain exactly the same data.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/aaf/aa7/2aeaafaa75ea48daa6c9671ef02024e4.png"></div><br>  <i>4. Target in RG16F format with 2D motion vectors.</i> <br><br>  After the depths are completely filled, a linear depth buffer is built and its scale decreases.  All this is done in the compute queue.  In the same queue, the buffer is filled with something similar to directional lighting without the use of shadows. <br><br>  In the graphical queue, the GPU is engaged in tracing the rays of global illumination, but I will discuss this in more detail below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/205/368/6b1/2053686b1cb719229dc0ccce1540e5c1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/879/607/0ab/8796070abae27e9695fb82d6f5789375.png"></div><br>  In the compute queue, ambient occlusion, reflections, and something similar to edge detection are calculated. <br><br>  In the graphics queue, a four-casted shadow map is rendered into a 32-bit depth map of 6k * 6k.  More on this below.  After the completion of the directed shadows map, the resolution of the third cascade for unknown reasons decreases to 768 * 768. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a85/203/3e2/a852033e230487f7be913e94ee87a7fa.png"></div><br>  In the middle of the shadow rendering process there is a curious point: impostor atlas is supplemented with some objects before rendering local shadows from lighting (what impostors are, you can read <a href="https://docs.unrealengine.com/en-US/Engine/Content/Tools/RenderToTextureTools/3">here</a> ).  Both the impostor buffers and the shadows buffers of the local lighting are also textures of size 6k * 6k. <br><br>  After all the shadows are complete, the illumination calculation starts.  This part of the rendering is rather incomprehensible, because here there are a lot of drawings that perform some mysterious actions, and therefore require additional study. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e07/838/016/e078380165142b63cce7e340155e4aef.png"></div><br>  Rendering of the scene is completed with frontally lit objects (eyes, particles).  Visual effects are rendered into a half-resolution buffer, after which they are composited with opaque objects using an increase in scale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d95/88c/66e/d9588c66ecb2dbd09b0386fc481771c1.png"></div><br>  The final picture is achieved by tone correction and bloom calculation (decrease, and then increase the resolution of the frame with tone correction).  Finally, the UI is rendered into a separate buffer and, with bloom, compositing is superimposed on top of the scene. <br><br>  I did not find the part in which smoothing is performed, so I will leave it for later. <br><br><h3>  Global illumination ray tracing </h3><br>  Some information about the global illumination performed by ray tracing (raytraced GI).  This accelerating structure covers a large area of ‚Äã‚Äãthe game world, probably several hundred meters, while maintaining very high detail everywhere.  It looks like it is somehow streaming.  The scene of the accelerating structure does not coincide with the rasterized scene, for example, buildings in the image shown below are not visible in a rasterized form. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e98/f99/6d9/e98f996d9c2ad589d81fb6c5abac1208.png"></div><br>  <i>View from above</i> <br><br>  Here we can see four tiles surrounding the player‚Äôs position.  The absence of geometry tested on the alpha channel is also evident.  Trees have trunks, but no foliage, no grass, no bushes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/500/53a/089/50053a0898f262725ade46d2b5dadb88.png"></div><br>  <i>Near view</i> <br><br>  In the near view, the detail and density of objects are better seen.  Each object of a different color has its own accelerating structure of the lower level.  Only in this picture there are several hundred. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83e/5e8/dff/83e5e8dfff1709a0d38b1f4c5d012282.png"></div><br>  <i>Player items underfoot</i> <br><br>  Interestingly, player items are also part of the accelerating structure, but for some reason are located under his feet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/c2b/203/969c2b203e8abecbd7718e061db99984.png"></div><br>  <i>Broken skinning?</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/620/78d/36662078d0930dfb66fb3bf1d928f022.png"></div><br>  <i>Broken skinning again?</i> <br><br>  Some of the skinned objects look broken in the acceleration structure.  One of the observed problems is stretching the mesh (at the feet of the child).  Another problem is that the different parts of the character with skinning are in different positions.  Stretching is not, but the parts are separated from each other.  It seems that none of this is visible in global illumination with ray tracing, or at least I have not managed to notice this in the game. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/647/c7c/c2b/647c7cc2beab467af7223ed97f80fa08.png"></div><br>  <i>A huge number of objects</i> <br><br>  In more general terms, one can see how many different objects in the accelerating structure.  Most of them in fact will not make any contribution to the results of calculations of the global distribution.  It also shows that there is no LOD scheme.  All objects are added with full detail.  It would be interesting to know if this has any effect on ray tracing (I would suggest that yes). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/11b/0ec/64f11b0ec3d0882a84503875c5a1cb20.png"></div><br>  <i>Ultra high LOD, each scale and switch is fully simulated</i> <br><br>  Another screenshot shows a huge detail of objects, even away from the player.  Each switch and each scale in this image are clearly readable even without textures.  The place where I moved the camera to make this screenshot is located tens of meters from the player and the elimination of these details would in no way impair the quality of the picture.  An update of the accelerating structure is possible using LOD would be too costly, but there is a high probability that this update can be performed asynchronously.  This moment is definitely worth exploring in more detail. <br><br><h3>  Rendering directed shadows </h3><br>  The main part of shadow rendering is simple and does not require any special mention, but there are interesting points here too. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/016/0ea/d160160ea9d4dc571c97440f77d103a0.png"></div><br>  <i>Meshes for which shadows are less likely to drop</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/369/857/cb1/369857cb17bf6baeaae52295930b4ac5.png"></div><br>  <i>Huge detail in shadow maps</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e0/708/9ba/0e07089ba7b63f9c055a95a8ed783f09.png"></div><br>  <i>Meshes that seem to have the wrong index buffer.</i> <br><br>  It seems that, like accelerating structures, shadow rendering includes absolutely everything.  There are objects that almost do not contribute to the shadow map, but they are still rendered.  Interestingly, is this because of the resolution, or is there no easy way to exclude them in the engine? <br><br>  There are objects that are difficult to see even with shadows in the screen space.  Their conversion does not take much time, but it would be interesting to see if they can be removed to save some time. <br><br>  When studying a mesh, it seems that some of the meshes rendered in the shadow map have broken index buffers, but after the vertex shader they look correct (the results are the same in PIX and NSight).  This is the best example I could find, but it is far from the only one.  Maybe this is some kind of special packing position? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d9/079/80b/5d907980beab8411086ae95a3cd1069e.png"></div><br>  <i>It looks like meshes have bad skinning</i> <br><br>  It seems that skinning causes problems not only in accelerating structures.  Interestingly, that does not lead to visible artifacts on the screen. <br><br><h2>  Part 2 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/d1c/c6d/787d1cc6d642436ce05542678e27b807.png" alt="image"></div><br><h3>  Slight amendment </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efe/177/37b/efe17737bab902e3b3d1e4ae2a29edbf.png"></div><br>  In the previous part I wrote that the third render target buffer GBuffer most likely contains metalness, but it seems that in fact it contains a specular color.  At first, I did not see any colors and did not understand why all three RGB channels contained the same data, but probably it was because there were no color reflections in the scene.  For this weapon in the buffer contains much more different colors. <br><br>  I also forgot to add my favorite texture, which I found in the process of researching the rendering of the game.  It is definitely worth mentioning because it demonstrates the chaotic nature of game development when it‚Äôs not always possible to clean everything up. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/5b4/288/7bb5b428878a0be20dbe80d599256d80.png"></div><br>  <i>"Improve me!"</i> <br><br><h3>  Transparency compositing and anti-aliasing </h3><br>  Trying to figure out how to increase the resolution of the buffer size to half the size, and how the game performs antialiasing, I noticed something curious.  I needed a scene where there was much more contrast in order to clearly see what was happening.  Fortunately, I managed to capture a frame in which the player‚Äôs weapon between frames slightly shifted. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0c/974/612/a0c9746122e45a19786bdf51521015a9.png"></div><br>  <i>Before rendering transparency</i> <br><br>  It seems that before the transparency buffer is composted, the buffer already contains a fully rendered image, and since there are no sharp edges in this frame, it is logical to assume that this is the data from the previous frame. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/bd5/b89/c56bd5b8938a315f97def63dc7b8b214.png"></div><br>  <i>After compositing transparency of the current frame</i> <br><br>  When adding transparency to the current frame, we can notice some broken edges.  It happened because the weapon shifted slightly to the right.  Some clouds are rendered transparent, but they are clipped on the horizon (which is opaque), so compositing does not change the bottom, but already renders on top of the weapon mesh from the previous frame, using the depth buffer of the current frame. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/7a1/e93/64f7a1e9340dfe180e4807cf7c4da5be.png"></div><br>  <i>After adding the opacity of the current frame</i> <br><br>  After a few draw calls, compositing and opaque meshes are performed.  There seems to be no particular reason to do this in that order.  It is logical to compose the transparency buffer into the data of opaque objects of the current frame, but this does not happen, and it would be interesting to know why. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/963/bce/f23/963bcef23544573444acf29bf7a83a87.png"></div><br>  <i>After TAA</i> <br><br>  After completion of the full frame, the TAA (time smoothing) pass smooths the edges.  I was already interested in this before, because I did not see where the smoothing occurs.  But I missed it because immediately after this draw call, the downsampling for the bloom begins, and I missed this one draw call. <br><br><h3>  Lens flare </h3><br>  I usually don‚Äôt want to analyze individual effects, but there are many ways to implement lens flare, so I was curious as to which developers chose. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/d1c/c6d/787d1cc6d642436ce05542678e27b807.png"></div><br>  <i>Lens flare in the finished compositing</i> <br><br>  In most cases, the lens flare is hardly noticeable, but this is a beautiful effect.  It is difficult to show in the screenshot, so I will not put much effort into it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a32/554/efc/a32554efc67afb79416b6ce2fe337148.png"></div><br>  <i>Lens flare in bloom buffer</i> <br><br>  Searching, I found a draw call that adds this effect, and it turned out that it was a call after the last step of increasing the resolution of bloom.  In this buffer, the effect is much more noticeable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/f38/078/8a3f38078dc5d6c6451030ee3eb5c53b.png"></div><br>  <i>Geometry Lens flare</i> <br><br>  If you look at the geometry, the lens flare is pretty simple.  Not less than 6 quadrangles are involved in creating the finished result on the screen, but there is no series of smaller quadrangles that are getting closer to the position of the sun.  It can be concluded that this is a fairly standard solution, although some developers will render the lens flare directly into the render target scene, while others calculate the effect as post-processing. <br><br><h3>  Relief rendering </h3><br>  In all open world games, relief rendering is one of the most interesting challenges.  I decided that it might seem interesting to study this aspect, but, to be honest, I was a little disappointed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/125/7a6/89b/1257a689b93f0f7a0239b5514ce911af.png"></div><br>  At first glance, a fragment of the relief looks like some kind of tessellation is performed.  The way the relief is deformed when moving makes it logical to assume that there is some additional displacement.  In addition, on the PC, the game uses tessellation quite actively, so it would be logical to use it in relief. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99d/214/a4d/99d214a4dc8c15862b7e385edda0c25e.png"></div><br>  Perhaps I had the wrong parameters set, but the game renders all the relief fragments without tessellation.  For each fragment of the relief it uses this uniform 32 * 32 grid.  There is also no LOD. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/744/aa8/4bc/744aa84bce83c87e8c2a49338f7c8c13.png"></div><br>  Looking at the fragment of the relief after the vertex shader, you can see that most pairs of vertices have merged, forming an almost perfect 16 * 16 grid, except for some places that require greater accuracy (probably due to the curvature of the relief).  The deformation mentioned above is probably due to reading the mip-textures of the relief height map, when the relief is far from the camera. <br><br><h3>  Ray Tracing Tricks </h3><br>  And now about what everyone was waiting for. <br><br><h4>  Streaming data </h4><br>  One of the most interesting aspects of any DXR implementation at the moment is the way to work with data.  The most important thing is how data is loaded into accelerating structures and how it is updated.  To test this, I made two captures and compared the accelerating structures in NSight. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fc/7b7/0d2/3fc7b70d22199c5be429417fd6ed92a9.png"></div><br>  <i>The player is inside the ship</i> <br><br>  In the first capture, I stood inside a broken ship, which is visible in the middle of this image.  Only the nearest objects are loaded, except for large rocks on the edge of the map. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc4/e41/2fa/dc4e412fa02b74f7ca4384a53e1b8100.png"></div><br>  <i>The player has moved to the upper left corner of this image.</i> <br><br>  In the second capture, I moved away from the edge of the map and turned out to be closer to the upper left edge of the image.  The ship and everything around it is still loaded, but new objects also loaded.  Interestingly, I cannot define any tile structure.  Objects can be loaded / removed from the accelerating structure based on distance and visibility (possibly a bounding parallelogram?).  In addition, the upper right edge looks more detailed, although it has moved away from it.  It would be interesting to know more about this. <br><br><h4>  Relief and what's under it </h4><br>  We can mention several aspects of the implementation of DXR in Metro: Exodus, concerning the terrain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e97/386/8bf/e973868bf7b0bd40cfc58c0d94678acf.png"></div><br>  First, it is curious that the accelerating structures do not contain any meshes of the relief (except in special cases).  These monsters actually run on the ground in the game, but judging from the data in NSight, you might think that they are flying.  This raises an interesting question for us: can the implementation of global illumination somehow take into account the relief (perhaps with the help of a height map and relief material), or not. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/03e/860/a7a03e8601a37c6459eff55cc7dda39f.png"></div><br>  The next moment I would never have noticed if the relief was in place.  Having looked at the beginning of the level at the accelerating structure in NSight, I noticed some meshes under the relief. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/458/b77/ec3/458b77ec37a3db2b1d8ca0b3f1694dd8.png"></div><br>  Artists quite often for various reasons have debug meshes below the level, but before the release of the game they are usually deleted.  In this case, these meshes not only survived the release, but also became part of the accelerating structure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/64a/15d/27d64a15df609c55b8742d77637fca22.png"></div><br>  In addition to those mentioned above, I found other meshes scattered under the relief.  Basically, they are not worth much mention, but this one was very interesting - it is a character standing right below the starting point of the level.  He even has his own pool. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/5dd/66c/53f5dd66c2b959793151e3a59d1309a5.png"></div><br>  Finally, the last curious element of the accelerating structure is one-way meshes looking outside the level.  Unless they are considered two-sided, they are very unlikely to contribute to the game image.  Even if the meshes are two-sided, they are so far away from the playable area that they probably just stretch the accelerating structure.  It is interesting to see that they are not filtered.  This image also shows one of the special cases of the ‚Äúmesh of relief‚Äù in the lower right corner, between the train and the building. <br><br><h4>  Skinless Headlessness </h4><br>  I have already talked about the problems of skinning meshes, but at this level I noticed something else. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/0dd/a8c/1d10dda8c75112713b51c32771bb8ecb.png"></div><br>  Firstly, this monster shows both errors in one image, which I noticed above.  I'm still wondering what they are caused by. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/523/265/dd7/523265dd72a9613800831592706bd510.png"></div><br>  I also noticed that these small creatures that look like bats do not have heads in the accelerating structure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fd/1a9/801/6fd1a9801d440a719602ab30eb33a88e.png"></div><br>  One more example.  Note the hole where the head should be.  I have not seen a single case where the head was visible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/51e/741/e7f51e74194bf8cccf8e430e6ec8513d.png"></div><br>  The same kind of creatures in rasterization mode.  Note that the head is clearly visible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/d67/2ea/ebdd672ea50f7717c4b66afeb20b4cf8.png"></div><br>  But the frame display of the head. <br><br><h3>  Finally </h3><br>  That's all for today.  I hope you enjoyed this look at the insides of Metro: Exodus. <br><br>  I will continue to explore the rendering of the game, but I will not publish new parts of the article if I do not find any special parts that would be interesting to people, or find something worth sharing. </div><p>Source: <a href="https://habr.com/ru/post/447194/">https://habr.com/ru/post/447194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447182/index.html">Operating Systems: Three Easy Pieces. Part 3: Process API (Translation)</a></li>
<li><a href="../447184/index.html">What is Initial Exchange Offering (IEO) and how does it differ from ICO?</a></li>
<li><a href="../447186/index.html">How to run ML prototype in one day. Report Yandex.Taxi</a></li>
<li><a href="../447190/index.html">Predictions from mathematicians. We analyze the main methods of detection of anomalies</a></li>
<li><a href="../447192/index.html">What role can technology play in the ancient art of mixing spices?</a></li>
<li><a href="../447196/index.html">7. Check Point Getting Started R80.20. Access control</a></li>
<li><a href="../447198/index.html">Moon mission "Bereshit": landing-crash-fall on the moon</a></li>
<li><a href="../447204/index.html">April 17: Open lecture "Path of the game developer: from idea to launch" and the game library at VSBI</a></li>
<li><a href="../447208/index.html">SQA Days EU Conference Review</a></li>
<li><a href="../447210/index.html">Selection @pythonetc, March 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>