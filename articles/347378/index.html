<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is common in the interview coder and the game "Snake"?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you were born in the 80s or 90s, you probably heard about Snake . That is, most likely, you spent an insane amount of time on your Nokia 3310, grow...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is common in the interview coder and the game "Snake"?</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/iv/uj/ln/ivujlnza9apsi_qznrhitqbr0oc.jpeg"></div><br>  If you were born in the 80s or 90s, you probably heard about <em>Snake</em> .  That is, most likely, you spent an <em>insane</em> amount of time on your Nokia 3310, growing a huge snake on a small small screen.  What else do we remember about Nokia phones? <br><br>  Their non-retractable battery, right?  How did such a "primitive" phone withstand long hours of playing "Snake" without discharging the battery? <br><br>  The short (and incomplete) answer: it's all about the <strong>sliding window</strong> method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We would love to write an entire article about <em>Snake</em> , but in this post we will nevertheless consider a less spectacular, but nonetheless very important method, and answer questions like: <br><br><ul><li>  Why do we and other programmers consider it a fundamental algorithm? </li><li>  Why is it used so often in technical interviews? </li><li>  How was it used in <em>Snake</em> and other ‚Äúreal‚Äù applications? </li><li>  What are the most popular interview questions you can (better) answer using the sliding window method? </li></ul><br>  If you are preparing for an interview, reading an article out of interest, or want to learn something new, then continue to read.  In this case, you can safely skip the extra and move on to the most interesting sections. <br><br>  NB: If you are only worried about the <em>‚ÄúSnake‚Äù</em> (and we fully understand you), then you can go to the very end of the post. <br><a name="habracut"></a><br><hr><br>  Let's get started. <br><br>  Despite the complexity of algorithmic programming, there is a rather short list of principles necessary for solving problems.  One of these principles is <strong>the sliding window method</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c02/bf2/9b4/c02bf29b4e83c911320263991e1810e1.png"></div><br>  <i>Figure 1. Sliding Window</i> <br><br><h3>  Window paradigm </h3><br>  The sliding window method emerged from the more general principle of framing. <br><br>  Cropping is to obtain the state of the system and limit the field of view only to its part, called the ‚Äúwindow‚Äù.  This creates a separation between the framing algorithm and the algorithm applied to those elements that are visible through the window, which simplifies both algorithms. <br><br>  A special case is a state consisting of a sequence of objects, for example, an array or a string.  If we specify a window, we will see a subsequence.  Now we can apply any processing to this limited interval, as if the sequence no longer contains any values.  <strong>By limiting the interval, we make the whole task smaller</strong> .  Now consider the sliding property: move the window one position to the right, and get another subsequence, to which you can also apply processing. <br><br>  And here begins our adventure.  If we apply the algorithm to each window separately, then we end up with a brute force tactic. <br><br>  However, the beauty of the sliding window method is that it allows you to change the structure of the algorithm in such a way that it takes <strong>advantage of the window offset process itself</strong> .  And the purpose of all this is to create better and faster algorithms. <br><br>  We can increase the speed of execution of almost any algorithm applied to a sliding window, <em>at least theoretically</em> .  When the window is shifted, only two elements change.  The oldest is eliminated, and the newest one gets into the frame. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/200/9f0/5982009f0e72824f4d667483042d5e95.png"></div><br>  <i>Figure 2. Element Shift (Red: Out, Green: Arrived)</i> <br><br>  If a rough search requires <code>k</code> steps to process a single window of length <code>k</code> , and there are <code>n</code> windows in a sequence, then to perform the work, the rough search algorithm requires <code>n¬∑k</code> steps.  But since with each step only two elements change, we can achieve a total execution time approximately proportional to <code>2n</code> . <br><br>  If we say that a simple passage through the sequence takes <code>O(n)</code> , then this means that in a general sequence no algorithm can be faster than <code>O(n)</code> .  This analysis has shown us that the correct application of the sliding window method can lead to the invention of complete sequence processing algorithms that can be performed in <code>O(n)</code> . <br><br><blockquote>  In other words, he promises us that we can invent perfect algorithms for solving the problem, which can not be faster! </blockquote><br>  Having finished with the necessary introduction, we consider three programming problems that can be solved using this general concept of algorithms, and show specific examples of how they were used in real cases. <br><br><h3>  Programming Task 1: Moving Average </h3><br>  The task that needs to be solved is to create an algorithm that calculates the moving average of a number series. <br><br>  For a given row <code>a0, a1, ‚Ä¶ an-1</code> and the parameter <code>k, 0 &lt; k &lt;= n</code> we must generate a new sequence, such that each element is the average value of <code>k</code> consecutive elements of the original sequence: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ea/f92/71d/0eaf9271d63199618bd2a1fb1488e931.png"></div><br>  <i>Figure 3. Eq Average</i> <br><br>  Context: moving average is useful for smoothing the flow of input data.  If the numbers are affected by noise, then the raw data will be difficult to display.  As can be seen from the two illustrations below, smoothing provides a more informative scheme. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/585/6af/98b/5856af98bae4c21478b3013acb332ed8.png"></div><br>  <i>Figure 4. Moving average smooths input data</i> <br><br>  This problem can be effectively solved using the sliding window method.  He immediately reveals a common feature of most of these algorithms: the first <code>k-1</code> elements do not create output data.  Only when filling the entire window, we can get the first portion of the results.  All subsequent windows create one result each.  Therefore, a sequence of <code>n</code> elements using a sliding window algorithm creates a sequence of <code>n-k+1</code> results. <br><br>  Now for the implementation.  The average value of a window is the sum of all elements divided by the length of the window. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/372/a8a/d77/372a8ad77918f3ac839ce1805233b873.png"></div><br>  <i>Figure 5. Eq Sum</i> <br><br>  With this formulation, we can immediately see the advantage of using the sliding window method.  The sum of the window values ‚Äã‚Äãcan be calculated from the sum of the values ‚Äã‚Äãof the window preceding it: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dba/854/618/dba8546180ad98304e67cdeb3785842d.png"></div><br>  <i>Figure 6. Eq Optimization</i> <br><br>  The calculation of the sum of the first window takes <code>k</code> steps, and for each of the next window only two additional operations are required. <br><br>  The following shows the implementation of this response in C ++, passing the first <code>k</code> elements to create the first output.  All other output numbers are calculated using the optimized summation formula. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moving_average</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ assert(data != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); assert(n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; k &amp;&amp; k &lt;= n); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[n ‚Äî k + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k; i++) { sum += data[i]; } result[<span class="hljs-number"><span class="hljs-number">0</span></span>] = sum / k; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = k; i &lt; n; i++) { sum = sum ‚Äî data[i ‚Äî k] + data[i]; result[i ‚Äî k + <span class="hljs-number"><span class="hljs-number">1</span></span>] = sum / k; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  The main point of this algorithm is that each element in the original sequence is processed a maximum of twice, which creates a total time complexity <code>O(n)</code> . <br><br><h3>  Programming Task 2: Maximum Sum Subsequence </h3><br>  The task that needs to be solved is to create an algorithm for finding a subsequence with the largest sum of all possible subsequences. <br><br>  This can be a real problem if the input data contains negative values. <br><br>  And here again you can use the sliding window method to create a solution with the execution time <code>O(n)</code> .  Only this time the window length will not be constant.  In fact, since the task itself is to find the most suitable window, the window length can change in the process. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d12/cf5/f4d/d12cf5f4d864cad963c03827e07a0364.png"></div><br>  <i>Figure 7. Maximum amount, solution with sliding windows</i> <br><br>  The idea is to watch what happens when we already have a window with a certain amount.  Then we want to add the following value.  This value can be added to the amount of the window.  But it can also be taken as a completely new window of unit length.  Ask a question: which of them will have a greater amount?  Whatever it is, we will save it as a new window and move to the next input value, repeating the same procedure.  Look at the picture above, which shows how the windows gradually slide along the sequence. <br><br>  The winning option will always be a subsequence with a maximum amount ending on the current input element.  Each window is discarded immediately when its sum becomes negative: this is a situation in which the number alone is better than in combination with the maximum preceding window. <br><br>  We are left with the only last step - the determination of a common maximum.  Candidates are all windows because they slide towards the end of the sequence.  After the completion of the sequence, the window with the highest amount will be the subsequence with the maximum amount. <br><br>  Below is a straightforward implementation of the algorithm in C ++.  And again, each element of the sequence is considered no more than two times, which is the total time complexity of the function <code>O(n)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; max_sum_subsequence(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { assert(data != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); assert(n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bestStart = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bestLength = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxSum = data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curStart = bestStart; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curLength = bestLength; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curSum = maxSum; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curSum &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { curStart = i; curLength = <span class="hljs-number"><span class="hljs-number">1</span></span>; curSum = data[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { curLength += <span class="hljs-number"><span class="hljs-number">1</span></span>; curSum += data[i]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curSum &gt; maxSum) { bestStart = curStart; bestLength = curLength; maxSum = curSum; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(bestStart, bestLength, maxSum); }</code> </pre> <br><h3>  Programming objective 3: maxima of all k-subsequences </h3><br>  The task that needs to be solved is to create an algorithm that calculates the maxima of all subsequences of length <code>k</code> in a numerical sequence of length <code>n</code> .  Note: this is a difficult task. <br><br>  This algorithm is used in image processing, where, as you can guess, algorithms with the execution time <code>O(n)</code> are valued most of all others. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b41/997/235/b41997235adde0863816b0254bfcde88.png"></div><br>  <i>Figure 8. Maximums</i> <br><br>  When the window slides, it creates the maximum value contained in the output.  The difficult part of the solution is that there is no formula giving the maximum of a given window.  We can take as result one of the elements. <br><br>  But it cannot be said that we cannot benefit from the use of the sliding window method.  This is the idea: suppose we have a window with four values, as shown in the figure above. <br><br>  When an additional value enters the frame, we need to understand how it relates to the existing values.  To begin with, if you continue sliding the window, all previous values ‚Äã‚Äãfall out of it before this new value falls out.  This is an important conclusion.  If the previous value is less than the new, then it will never be the maximum, simply because the new, larger value will always overshadow it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0d/121/589/f0d12158979e4a2fa83b80a66bc6f772.png"></div><br>  <i>Figure 9.</i>  <i>Maximum slip</i> <br><br>  This leads us to the idea of ‚Äã‚Äãnot recognizing each new value and removing all the smaller values ‚Äã‚Äãthat it finds in the window when the window slides, as shown in the figure below.  This operation has another consequence. <br><br>  If each value added to the right removes all smaller values, then the window will contain only a non-increasing, discontinuous subsequence of the original window.  Another consequence is that it is now becoming obvious - the leftmost element of the window is the maximum value that we need to calculate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb8/12f/c24/bb812fc243cdb27724f7e58b0760e8f3.png"></div><br>  <i>Figure 10. Maximum screening.</i> <br><br>  It is necessary to clarify one more detail.  When the window slides, the leftmost value of the sequence drops out.  This value could already have been removed by a larger value.  Or it could survive all the values ‚Äã‚Äãfollowing it on the right.  In the latter case, the value from the input data will be the leftmost value in the frame, and now it is time to delete it. <br><br>  The figure below shows the entire process applied to a sequence of seven elements with a window length of four. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/5ae/15f/7a45ae15f4a0cfaee9a41fbd915660b1.png"></div><br>  <i>Figure 11. Maximums total</i> <br><br>  At this point, we complete the description of the algorithm and begin its implementation.  The normal implementation is based on a dequeue.  Dequeue supports adding to and removing from both sides of the queue, and we use these operations to implement the algorithm. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert_maximum_candidate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, bounded_deque&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;maximums)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!maximums.empty() &amp;&amp; maximums.back() &lt; value) maximums.pop_back(); maximums.push_back(value); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_maximum_candidate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, bounded_deque&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;maximums)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!maximums.empty() &amp;&amp; maximums.front() == value) maximums.pop_front(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range_maximums</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ assert(data != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); assert(n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; k &amp;&amp; k &lt;= n); bounded_deque&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; maximums(k); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k ‚Äî <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) insert_maximum_candidate(data[i], maximums); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n ‚Äî k + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = k ‚Äî <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { insert_maximum_candidate(data[i], maximums); result[i ‚Äî k + <span class="hljs-number"><span class="hljs-number">1</span></span>] = maximums.front(); remove_maximum_candidate(data[i ‚Äî k + <span class="hljs-number"><span class="hljs-number">1</span></span>], maximums); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  In this solution, we use our own implementation of Dequeue called <code>fixed_deque</code> .  Unlike <code>std::deque</code> , this class maintains a buffer for data of a fixed length that speeds up execution by at least one order of magnitude.  Inside it works as a ring buffer, which is extremely efficient.  Anyway, the <code>fixed_deque</code> class has the same public interface as <code>std::deque</code> (the only difference is that its constructor expects a buffer size) and if you wish, you can replace it with <code>std::deque</code> .  In addition to a significant reduction in the speed of execution, there will be no other consequences. <br><br>  As in the previous examples, we can analyze the time complexity of this implementation.  Each value from the input sequence is subjected to queuing and deletion from it no more than once.  That is, a maximum of two operations are performed on one input number, and the total time complexity of the algorithm is <code>O(n)</code> .  Also, this algorithm requires additional space <code>O(k)</code> , where k is the window length.  (It is worth noting that previous algorithms only needed <code>O(1)</code> spaces.) <br><br><h3>  Think outside the box </h3><br>  We considered three algorithms based on the sliding window method.  As we promised, each of them is executed in <code>O(n)</code> .  I would also like to show you how the same method is applied in two completely different areas. <br><br>  First, in packet routing protocols such as TCP / IP, a sliding window is used to negotiate the Internet Protocol (IP) with the Transmission Control Protocol (TCP).  IP can never guarantee that packets will be received in the same order in which they were sent.  At the same time, TCP just provides this guarantee.  Here, a sliding window is becoming one of the most important components of the success of the TCP / IP protocol bundle. <br><br>  The TCP receiver supports the expected packet window.  Packets arrive at a less perfect (but more realistic) IP, and may not come in the order needed to fill the corresponding window positions.  However, as soon as the leftmost packet arrives, the TCP window shifts as far as possible to the right, confirms to the sender that all adjacent packets have been received and sends them to the output.  This, in turn, signals the sender about the possibility of starting the transmission of subsequent packets to the IP network. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/264/1ea/779/2641ea77977126e044dd88a910794c17.png"></div><br>  <i>Figure 12. TCP-IP</i> <br><br>  You have already guessed what the second (and last) example will be devoted to. <br><br>  Of course, <em>"Snake"</em> .  When this game appeared a few decades ago, most knew it on Nokia cell phones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/97a/f50/bd297af50a239b687640d949bfd02725.png"></div><br>  <i>Figure 13. Snake</i> <br><br>  Guess?  The snake itself is a sliding window!  When the snake moves, it is enough for us to draw only two blocks on the screen - the tail becomes a background block, and the former background in front of the snake's head becomes a new head. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/856/71b/6dd/85671b6dd18cecfee1211849d2854b34.png"></div><br>  <i>Figure 14. "Snake" = sliding window</i> <br><br>  The result of the sliding window method is that each frame of the game costs us to draw a maximum of two primitive blocks, regardless of the length of the snake.  This made it possible to implement the game on a primitive "hardware" without unnecessary battery consumption. <br><br><h3>  Summarize </h3><br>  In this article, we analyzed a general algorithm called a sliding window.  You have learned that this technique can be used to optimize data sequence processing algorithms.  With a successful application, the technique provides the creation of algorithms that are executed during <code>O(n)</code> for a sequence of n objects, which is the most optimal design of the algorithms. <br><br>  As concrete examples of solving problems, we developed three different algorithms that work with numerical sequences.  All of these algorithms are used in the real world for general data processing and image processing.  This explains why the sliding window method has survived to our days and remains a useful tool in creating algorithms.  Therefore, you will most likely hear about him on technical interviews. </div><p>Source: <a href="https://habr.com/ru/post/347378/">https://habr.com/ru/post/347378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347366/index.html">The third invasion of the Martians</a></li>
<li><a href="../347368/index.html">Call Tracing Anatomy: Setup Guide</a></li>
<li><a href="../347370/index.html">Creating a chain of behaviors</a></li>
<li><a href="../347374/index.html">Apache Ignite.NET 2.4: Slim and Cross Platform</a></li>
<li><a href="../347376/index.html">Automatic assessment of the quality of Wikipedia articles in different languages</a></li>
<li><a href="../347380/index.html">7 Steps to a Xamarin Developer Career</a></li>
<li><a href="../347382/index.html">How did I manage to hack and unpack the resources of the old game for PSX</a></li>
<li><a href="../347384/index.html">Where to find and how to choose timlid</a></li>
<li><a href="../347386/index.html">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a></li>
<li><a href="../347388/index.html">Social Architecture: The Importance of Contracts and Unlimited Property</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>