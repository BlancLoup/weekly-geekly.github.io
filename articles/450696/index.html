<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CRUD widget generator for Yii</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What do the comments on the article on Habr√© and additional options when buying a car? 



 From the point of view of data modeling, both are ‚Äúnested‚Äù...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CRUD widget generator for Yii</h1><div class="post__text post__text-html js-mediator-article">  What do the comments on the article on Habr√© and additional options when buying a car? <br><br><img src="https://habrastorage.org/webt/4x/ex/_2/4xex_2tbdcc_iwesc63zed-dqzm.png"><br><br>  From the point of view of data modeling, both are ‚Äúnested‚Äù entities that have no independent meaning in isolation from the parent object. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In Yii ( <a href="https://www.yiiframework.com/">php framework</a> ), Gii is a built-in code generator that allows you to create basic CRUD interfaces on a data model with a few mouse clicks that significantly speed up development, but are applicable only to stand-alone entities, like an article or a machine in the examples above. <br><br>  It would be great if you could generate something like this for ‚Äúnested‚Äù data objects, right?  Now - you can, welcome under the cat for details. <br><a name="habracut"></a><br>  For the most impatient at the end of the article given instructions for a quick start. <br><br>  And for those interested in the article, aspects from business application to the internal structure are considered: <br><br><ul><li>  Business case: posting messages by topic <br><ul><li>  The list of topics on the main </li><li>  List of posts by topic </li></ul></li><li>  Under the hood: CRUD based gii generator <br><ul><li>  Gii Generator Template </li><li>  Widget base class </li><li>  Built-in facade controller </li></ul></li><li>  Fast start <br><ul><li>  About support and development </li></ul></li></ul><br><h2>  Business case: posting messages by topic </h2><br>  Perhaps comments on Habr√© are a bad example, because  are often more useful than the article itself, but, in any case, when developing an application, it often happens that a certain object of the data model is of little interest to the user as an independent entity. <br><br>  Consider a simplified business task: make a site for posting messages grouped by various topics. <br><br>  The site must have the following interfaces: <br><br><ol><li>  The main page should support various widgets in the future, but at the current stage of implementation there is only one: a list of topics filtered by some criterion. </li><li>  Full list of topics - a complete list of topics in a tabular format; </li><li>  Topic page - information about the topic and a list of messages published in it. </li></ol><br>  Pretty standard, right? <br><br>  Let's look at the data model: <br><br><img src="https://habrastorage.org/webt/f0/db/dp/f0dbdpmz9gbbxhsmxhu7vmzurem.png"><br><br>  No surprises too.  Two classes of models will contain our business logic: <br><br><ul><li>  The <b>Topic</b> class is topic data, validation, a list of posts in it, as well as a separate method that returns a list of topics filtered by criteria for the widget on the main page. </li><li>  <b>Post</b> class - only data and validation. </li></ul><br>  The application will be served by two controllers: <br><br><ul><li>  <b>SiteController</b> - standard pages (about us, contacts, etc.), authorization (not required by TK, but we know) and index - the main page.  Because  we assume in the future a variety of different widgets, the main page should be left in this controller, and not transferred to specific for one model. </li><li>  <b>TopicController</b> is a standard set of actions: list, create, edit, view and delete topics. </li></ul><br>  <b>PostController</b> can also be potentially generated - for administration purposes and / or copy-paste pieces of code into custom widgets, but we will leave this outside the scope of this article. <br>  Until now, most of the code can be generated using gii, which speeds up development and reduces risks (less manual code = less chance of making a mistake). <br><br>  Two questions remain: <br><br><ol><li>  How to display a filtered list of topics on the main page? </li><li>  How to display a list of posts on the topic? </li></ol><br>  If you can solve them with the help of an automatic generator, this will be a solid achievement. <br><br><h3>  The list of topics on the main </h3><br>  The main page served by the site / index should contain a list of topics filtered by a predetermined criterion.  The filtering criterion, as part of business logic, we included in the model. <br><br>  For display there are several options for implementation. <br><br>  The first is dirty and fast - everything is done directly in the presentation file ( <b>views / site / index.php</b> ): <br><br><ol><li>  Create <b>ActiveDataProvider</b> ; </li><li>  Fill it with data from the <b>Topic</b> model; </li><li>  Display using the standard <b>ListView</b> / <b>GridView</b> widget, specifying the required fields manually. </li></ol><br>  You can go a little further and pack it all into a separate view file, something like <b>views / site / _topic-list-widget.php</b> , by calling its render from the main file.  This will give a bit more manageability and expandability, but it still looks pretty messy. <br><br>  Most of us will most likely create a separate widget according to all the rules, in a separate namespace ( <b>app \ widgets</b> or <b>app \ components</b> for the basic template - depending on the version you are using), where the creation of <b>ActiveDataProvider</b> by model and display in an independent submission.  Further it will be necessary only to call this widget from the main page.  This solution is the most correct in terms of class decomposition, controllability and extensibility of the code. <br><br>  But is there a feeling that the code of this widget will very much repeat the <b>TopicController</b> code in terms of handling <b>actionIndex ()</b> ?  And so offensive to write this code manually. <br><br>  It would be much better to generate this code automatically and then just call the ready widget: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= \app\widgets\TopicControllerWidget::widget([ <span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'index'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'query'</span></span> =&gt; app\models\Topic::findBySomeSpecificCriteria() ], ]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br><h3>  List of posts by topic </h3>  The topic view page served by the <b>topic / view</b> address should contain information about the topic itself and a list of messages published in it.  We receive the list of messages for the topic in the model automatically, if we have the relationships between the tables correctly configured, so that only the display question remains. <br><br>  By analogy with the filtered list of topics, we have practically the same options. <br><br>  The first is to do everything in the code of the view file to view the topic ( <b>views / topic / view.php</b> ): <br><br><ol><li>  Create <b>ActiveDataProvider</b> ; </li><li>  Fill it with data from the model <b>$ model-&gt; getPosts ()</b> ; </li><li>  Display using the standard <b>ListView</b> / <b>GridView</b> widget, specifying the required fields manually. </li></ol><br>  The second is to isolate this code into a separate view file: <b>views / topic / _posts-list-widget.php</b> , just so that it does not hurt his eyes - re <b>-using</b> it anywhere will still not work. <br><br>  The third is a full-fledged widget that will largely duplicate the code of the conditional <b>PostController</b> in the <b>actionIndex () part</b> , but written by hand. <br><br>  Or generate the code automatically and call the ready widget: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([ <span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'index'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'query'</span></span> =&gt; $model-&gt;getPosts(), ], ]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre><br><h2>  Under the hood: CRUD based gii generator </h2><br>  The business task is defined, the requirements for the generated widget are outlined, let's figure out how we will generate it.  Gii already has a generator for a CRUD controller.  For the CRUD widget, we will need to create a new generator based on the existing one. <br><br>  A couple of links to the documentation before the start - it will also be useful if you decide to write your own extension: <br><br><ul><li>  <a href="https://www.yiiframework.com/doc/guide/2.0/ru/structure-extensions">Yii Extension</a> ; </li><li>  <a href="https://www.yiiframework.com/extension/yiisoft/yii2-gii/doc/guide/2.1/en/topics-creating-your-own-templates">Yii gii template</a> ; </li><li>  <a href="https://www.yiiframework.com/extension/yiisoft/yii2-gii/doc/guide/2.1/en/topics-creating-your-own-generators">Yii gii generator</a> . </li></ul><br>  Obviously, all the functionality is packaged in the Yii extension, which is installed through the composer and goes into the vendor folder of your project. <br><br>  The extension consists of three parts: <br><br><ol><li>  The <b>templates / crud directory</b> containing the gii generator template; </li><li>  File <b>Controller.php</b> - built-in facade controller for calling widgets; </li><li>  The <b>Widget.php</b> file is the base class for all generated widgets. </li></ol><br><img src="https://habrastorage.org/webt/uh/le/4c/uhle4cnzxzmubqgtoitn3ox5b_u.png"><br><br><h3>  Gii Generator Template </h3><br>  The extension must generate code, so the central part of it is the Gii generator. <br><br>  Initially it was assumed that to implement the expansion it would be enough to write your own template for the built-in CRUD-Controller generator.  By the way, this is why the directory is called templates, not generators.  But it turned out that the CRUD-Controller generator performs a very intensive validation of the entered data, which did not allow to implement many requirements, for example, to change the class for inheritance.  Therefore, the extension contains a full-fledged generator, and not just a template. <br><br>  The gii generator consists of the following parts (all are inside the templates / crud directory): <br><br><ul><li>  The <b>default</b> directory is a template where all the magic happens: each file in this directory will correspond to one generated file in your project; </li><li>  File <b>form.php</b> - as the name suggests, this is a form for entering generation parameters (class names, etc.); </li><li>  The <b>Generator.php</b> file is a generation orchestrator that receives data from the form, validates it, and then sequentially calls the template files to create the result. </li></ul><br>  The <b>Generator.php</b> and <b>form.php files</b> contain mostly cosmetic edits relative to the original ones from the CRUD generator: file names, validation, text descriptions and hints, etc. <br><br>  Template files are responsible for the generated view and the widget code itself.  First of all, the <b>templates / crud / default / controller.php</b> file is important, which is responsible for generating the widget class itself, which corresponds to the controller class from the original generator. <br><br>  The widget should have the same actions (actions) as the CRUD controller, but they are generated a little differently.  The examples below show the result of the generation with comments: <br><br><ul><li>  actionIndex - instead of the unconditional output of all models, the method takes the $ query parameter; <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($query)</span></span></span><span class="hljs-function"> </span></span>{ $dataProvider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActiveDataProvider([ <span class="hljs-string"><span class="hljs-string">'query'</span></span> =&gt; $query, ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;render(<span class="hljs-string"><span class="hljs-string">'index'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'dataProvider'</span></span> =&gt; $dataProvider, ]); }</code> </pre> </li><li>  actionCreate and actionUpdate - if successful, instead of a redirect, they simply return a success code, further processing is provided by the built-in facade controller; <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Post(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($model-&gt;load(Yii::$app-&gt;request-&gt;post()) &amp;&amp; $model-&gt;save()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'success'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;render(<span class="hljs-string"><span class="hljs-string">'create'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'model'</span></span> =&gt; $model, ]); }</code> </pre> <br></li><li>  actionDelete - supports the GET method for displaying the delete widget (the default is one button) and POST for performing the action;  if successful, it also does not perform the redirect, but returns the code. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionDelete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $model = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;findModel($id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Yii::$app-&gt;request-&gt;method == <span class="hljs-string"><span class="hljs-string">'GET'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;render(<span class="hljs-string"><span class="hljs-string">'delete'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'model'</span></span> =&gt; $model, ]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $model-&gt;delete(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'success'</span></span>; } }</code> </pre> </li></ul><br>  Finally, the presentation files contain the following basic edits: <br><br><ul><li>  All headers are translated to h2 instead of h1; </li><li>  The code responsible for displaying the title of the page and bread crumbs is removed - the widget should not affect these things; </li><li>  Creating and editing models using the modal window (built-in widget Modal); </li><li>  The template of the delete widget is added - with one big red button. </li></ul><br><h3>  Widget base class </h3><br>  When the generator finishes its work, it will create a widget class in the application namespace.  The inheritance chain looks like this: widgets generated for an application are inherited from the base extension widget, the class <b>\ ianikanov \ wce \ Widget</b> , which, in turn, is inherited from the base widget Yii, the class <b>\ yii \ base \ Widget</b> . <br><br>  The base class of the extension widget solves the following tasks: <br><br><ol><li>  Defines two main fields: $ action and $ params, through which control is transferred to the widget from the calling view; </li><li>  Defines a number of standard parameters that can be overridden in the generated class, such as the path to the widget view files, the name and path to the facade controller (described below), and error messages; </li><li>  Defines standard parameters when rendering views: render and renderFile; </li><li>  Provides an event infrastructure similar to that of a controller so that standard filters such as <b>AccessControl</b> and <b>VerbFilter work</b> ; </li><li>  Defines a run method that collects all of this together. </li></ol><br><h3>  Built-in facade controller </h3>  There are no problems with the display of data - the widgets are designed for this.  But for editing, whatever one may say, you need a controller.  Generate a unique controller for each widget - all its essence is lost.  Using standard CRUD is not always relevant, and I don‚Äôt want to depend on the additional launch of gii.  Therefore, a variant with a universal, integrated facade controller was used. <br><br>  This controller is registered in the application map via the configuration file and contains only one method - actionIndex, which performs the following actions: <br><br><ol><li>  Accepts a request from the client; </li><li>  Pass control to the appropriate widget class; </li><li>  Handles business errors resulting from the widget; </li><li>  Redirects back to the main application. </li></ol><br>  It is perhaps more important to indicate what this controller does NOT do: <br><br><ol><li>  It does not check access levels - this logic belongs to specific widgets; </li><li>  It does not perform any input manipulations ‚Äî the parameters are passed to the widget as is; </li><li>  It does not make any manipulations with the output, except for checking for a predetermined success code. </li></ol><br>  This approach allows us to preserve the versatility of the facade, leaving the implementation of business requirements, including security requirements, applied application code. <br><br><h2>  Fast start </h2>  The business challenge is clear, ready to start?  Using an extension consists of four steps: <br><br><ol><li>  Installation; </li><li>  Configuration; </li><li>  Generation; </li><li>  Application. </li></ol><br>  Installing the extension is done using composer: <br><br><pre> <code class="bash hljs">php composer.phar require --prefer-dist ianikanov/yii2-wce <span class="hljs-string"><span class="hljs-string">"dev-master"</span></span></code> </pre> <br>  Next, you need to make a few changes to the application configuration file. <br><br>  First, add an indication to the gii generator: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (YII_ENV_DEV) { $config[<span class="hljs-string"><span class="hljs-string">'modules'</span></span>][<span class="hljs-string"><span class="hljs-string">'gii'</span></span>] = [ <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'yii\gii\Module'</span></span>, <span class="hljs-string"><span class="hljs-string">'allowedIPs'</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, <span class="hljs-string"><span class="hljs-string">'::1'</span></span>, <span class="hljs-string"><span class="hljs-string">'192.168.0.*'</span></span>, <span class="hljs-string"><span class="hljs-string">'192.168.178.20'</span></span>], <span class="hljs-string"><span class="hljs-string">'generators'</span></span> =&gt; [ <span class="hljs-comment"><span class="hljs-comment">//here 'widgetCrud' =&gt; [ 'class' =&gt; '\ianikanov\wce\templates\crud\Generator', 'templates' =&gt; [ 'WCE' =&gt; '@vendor/ianikanov/yii2-wce/templates/crud/default', // template name ], ], ], ]; }</span></span></code> </pre> <br>  Second, add the built-in controller-facade to the map: <br><br><pre> <code class="php hljs">$config = [ ... <span class="hljs-string"><span class="hljs-string">'controllerMap'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'wce-embed'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\ianikanov\wce\Controller'</span></span>, ], ... ];</code> </pre> <br>  This completes the installation and configuration. <br><br>  To generate a widget you need: <br><br><ol><li>  Open gii; </li><li>  Select "CRUD Controller Widget"; </li><li>  Fill in the form fields; </li><li>  View and generate code. </li></ol><br>  Further, to use the widget, it must be called by specifying action and params - in much the same way as the controller is called. <br><br>  Widget view list of models: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([ <span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'index'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'query'</span></span> =&gt; $otherModel-&gt;getPosts(), ], ]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Widget view one model: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([<span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'view'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; $post_id]]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Model creation widget (button + form wrapped in Modal): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([<span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'create'</span></span>]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Model change widget (button + form wrapped in Modal): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([<span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'update'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span>=&gt;[<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; $post_id]]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Model delete widget (button): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([<span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'delete'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span>=&gt;[<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; $post_id]]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  The code of the widget and all views belongs to the application and can be easily changed - everything is exactly the same as when the controller was generated. <br><br><h3>  About support and development </h3><br>  A few words about how the extension will be maintained and developed.  I have a main job and a few pet-projects.  So, this extension is a side project from my side projects, so I will develop improvements to it only for the needs of my projects. <br><br>  In the best traditions of open source, the code is available on the <a href="https://github.com/ianikanov/yii2-wce">githaba</a> , and I will support it in terms of fixing bugs, and I will also try to do timely reviews if anyone wants to send a pull request, so if you are interested, join. </div><p>Source: <a href="https://habr.com/ru/post/450696/">https://habr.com/ru/post/450696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450684/index.html">Cool smart skipping ropes: review of the smart jump rope Tangram Smart Rope</a></li>
<li><a href="../450686/index.html">Three more non-obvious features of the Zimbra Collaboration Suite that will help improve employee productivity</a></li>
<li><a href="../45069/index.html">Were able, if you wanted ... Corvette 038 - "Great Soviet Turntable"</a></li>
<li><a href="../450692/index.html">How corporations use the 7 deadly sins in product sales</a></li>
<li><a href="../450694/index.html">Why does Jeff Bezos recommend scaling failures and watching science fiction</a></li>
<li><a href="../4507/index.html">Mail.Ru launches video hosting</a></li>
<li><a href="../45070/index.html">Project EmForge.</a></li>
<li><a href="../450702/index.html">The place is damned?</a></li>
<li><a href="../450710/index.html">Midi reconstruction from Synthesia video clips (and similar ones)</a></li>
<li><a href="../450712/index.html">DotNetRu at the DotNext 2019 Piter conference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>