<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of regular expressions in javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you sometimes glance at regular expressions, but you still cannot decide to master them, thinking that all this is incredibly difficult - know - yo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics of regular expressions in javascript</h1><div class="post__text post__text-html js-mediator-article">  If you sometimes glance at regular expressions, but you still cannot decide to master them, thinking that all this is incredibly difficult - know - you are not alone.  For anyone who does not understand what regular expressions are, or do not understand how they work, they look like complete nonsense. <br><br><img src="https://habrastorage.org/webt/ed/j5/fr/edj5fr1qlmyse5n_igkfhdt9bx4.png"><br>  <i><font color="#cccccc">Powerful picture to attract attention :) Caution, can suck!</font></i> <br><br>  But, in fact, regular expressions are a powerful tool that can help you save a lot of time.  In this article we will look at the basics of regular expressions in JavaScript. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Creating regular expressions in js</font> </h2><br>  In JavaScript, a regular expression is one of the object types used to search for combinations of characters in strings. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are two ways to create regular expressions. <br><br>  The first is to use regular expression literals.  With this approach, the regular expression pattern is enclosed in slashes.  It looks like this: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regexLiteral = <span class="hljs-regexp"><span class="hljs-regexp">/cat/</span></span>;</code> </pre> <br>  The second involves the <code>RegExp</code> object's constructor, which is passed a string from which it creates a regular expression: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regexConstructor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">"cat"</span></span>);</code> </pre> <br>  In both of the above examples, the same pattern is created - the character <code>c</code> , followed by the character <code>a</code> , followed by the character <code>t</code> . <br><br>  What way to create regular expressions to choose?  Here it is necessary to adhere to this rule: if you intend to use a regular expression in such a way that it remains unchanged - it is better to use a literal.  If your regular expression is dynamic, it may change during the execution of the program, it is better to use the <code>RegExp</code> constructor. <br><br><h2>  <font color="#3AC1EF">Regular expression methods</font> </h2><br>  Above, you may have noticed that regular expressions in JS are objects.  Objects, as you know, have methods, and regular expressions are no exception. <br><br>  One of the main regular expression methods is <code>.test()</code> , which returns a boolean value: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">RegExp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.test</span></span>()</code> </pre> <br>  Namely, this method returns <code>true</code> if the string contains a match with the specified regular expression pattern.  If no match is found, it returns <code>false</code> . <br><br>  Consider the following example.  We have two strings and one regular expression.  We can use a regular expression to check whether a given text pattern occurs in strings: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str1 = <span class="hljs-string"><span class="hljs-string">"the cat says meow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str2 = <span class="hljs-string"><span class="hljs-string">"the dog says bark"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasCat = <span class="hljs-regexp"><span class="hljs-regexp">/cat/</span></span>; hasCat.test(str1); <span class="hljs-comment"><span class="hljs-comment">// true hasCat.test(str2); // false</span></span></code> </pre> <br>  As expected, when we check the first line, <code>str1</code> , for the presence of a sequence of <code>cat</code> characters in it, we get <code>true</code> .  But after checking the second line, <code>str2</code> , we do not find <code>cat</code> in it, so the <code>.test()</code> method returns <code>false</code> . <br><br><h2>  <font color="#3AC1EF">Basic Regular Expression Constructs</font> </h2><br>  Fortunately (or, unfortunately, this is someone else), the basic approach to the study of regular expressions is to memorize the basic constructs denoting symbols and groups of symbols. <br><br>  Here is a short list of basic regular expression constructs.  If you are serious about studying them, set aside some 20 minutes and learn these constructions. <br><br><h3>  <font color="#3AC1EF">‚ñç Symbols</font> </h3><br><ul><li> <code>.</code>  (dot) - matches any single character except for line breaks. <br></li><li>  <code>*</code> - corresponds to the previous expression, which is repeated 0 or more times. <br></li><li>  <code>+</code> - matches the previous expression, which is repeated 1 or more times. <br></li><li> <code>?</code>  - corresponds to the previous expression, repeated 0 or 1 time. <br></li><li>  <code>^</code> - matches the beginning of the line. <br></li><li>  <code>$</code> - matches the end of the line. <br></li></ul><br><h3>  <font color="#3AC1EF">Group of characters</font> </h3><br><ul><li>  <code>\d</code> matches any single numeric character. <br></li><li>  <code>\w</code> - matches any character - a digit, letter, or underscore. <br></li><li>  <code>[XYZ]</code> - a set of characters.  Matches any single character in the set specified in brackets.  In addition, character ranges can be specified in a similar way, for example, <code>[AZ]</code> . <br></li><li>  <code>[XYZ]+</code> - Matches a character from brackets, repeated one or more times. <br></li><li>  <code>[^AZ]</code> - inside expressions defining character ranges, the symbol <code>^</code> used as a negation sign.  In this example, the pattern matches everything that is not uppercase. <br></li></ul><br><h3>  <font color="#3AC1EF">‚ñç Flags</font> </h3><br>  There are five optional regular expression flags.  They can be used together or separately, they are placed after the closing slash.  Regular expressions with flags look like this: <code>/[AZ]/g</code> .  We will consider here only two flags: <br><br><ul><li>  <code>g</code> - global search by string. <br></li><li>  <code>i</code> - case-insensitive search. <br></li></ul><br><h3>  <font color="#3AC1EF">‚ñç Additional constructions</font> </h3><br><ul><li>  <code>(x)</code> - exciting brackets.  This expression corresponds to <code>x</code> and remembers this correspondence; as a result, we can use it later. <br></li><li>  <code>(?:x)</code> - non-capturing brackets.  The expression matches <code>x</code> , but does not remember this match. <br></li><li>  <code>x(?=y)</code> is a forward match.  Matches <code>x</code> only if it is followed by <code>y</code> . <br></li></ul><br><h2>  <font color="#3AC1EF">More sophisticated regular expression examples</font> </h2><br>  Before we proceed to the educational project, let us dwell in more detail on the practical use of what we have just considered. <br><br>  First, check the string for the presence of any digits.  In order to do this, we can use the <code>\d</code> pattern.  Take a look at the code below.  It returns <code>true</code> in cases where there is at least one digit in the string under study. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/\d/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'12-34'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  As you can see, the code returns <code>true</code> - this is not surprising, since there are four numeric characters in the string under study. <br><br>  But what if we need to check a string for the presence of a certain sequence of digital characters?  In such a case, you can use the <code>\d</code> pattern repeated several times.  For example, in order for a regular expression to match line <code>11</code> , you can use the <code>\d\d</code> construct, which describes any two consecutive numeric characters.  Take a look at this code: <br><br><pre> <code class="hljs ruby">console.log(<span class="hljs-regexp"><span class="hljs-regexp">/\d-\d-\d-\d/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'1-2-3-4'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.log(<span class="hljs-regexp"><span class="hljs-regexp">/\d-\d-\d-\d/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'1-23-4'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  As you can see, here we check the string to see if there are sequences of single digits separated by lines in it.  The first line of this pattern matches, and the second - no. <br><br>  What if no matter how many digits are before or after the lines, if their number is greater than or equal to one?  In this situation, you can use the <code>+</code> sign to indicate that the <code>/d</code> pattern may occur one or more times.  Here's what it looks like: <br><br><pre> <code class="hljs ruby">console.log(<span class="hljs-regexp"><span class="hljs-regexp">/\d+-\d+/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'12-34'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.log(<span class="hljs-regexp"><span class="hljs-regexp">/\d+-\d+/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'1-234'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.log(<span class="hljs-regexp"><span class="hljs-regexp">/\d+-\d+/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'-34'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  In order to make life easier for ourselves, we can use brackets and group expressions with their help.  Let's say we want to check if there is something in the line that resembles a cat's meow.  To do this, you can use the following construction: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/me+(ow)+w/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'meeeeowowoww'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Happened.  Now let's look at this expression in more detail.  In fact, a lot of interesting things happen here. <br><br>  So, here is the regular expression. <br><br><pre> <code class="hljs lisp">/me+(<span class="hljs-name"><span class="hljs-name">ow</span></span>)+w/</code> </pre> <br><ul><li>  <code>m</code> - corresponds to a single letter <code>m</code> . <br></li><li>  <code>e+</code> - matches the letter <code>e</code> , repeated one or more times. <br></li><li>  <code>(ow)+</code> matches the combination of <code>ow</code> repeated one or more times. <br></li><li>  <code>w</code> - corresponds to a single letter <code>w</code> . <br></li></ul><br>  As a result, this expression interprets the string as follows: <br><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'m'</span></span> + <span class="hljs-string"><span class="hljs-string">'eeee'</span></span> +<span class="hljs-string"><span class="hljs-string">'owowow'</span></span> + <span class="hljs-string"><span class="hljs-string">'w'</span></span></code> </pre> <br>  As you can see, if operators like <code>+</code> are used immediately after the expressions enclosed in brackets, they refer to everything that is in brackets. <br><br>  Here is another example, does it concern the use of an operator <code>?</code>  .  The question mark indicates that the presence of the character preceding it in the string is optional. <br><br>  Take a look at this: <br><br><pre> <code class="hljs ruby">console.log(<span class="hljs-regexp"><span class="hljs-regexp">/cats? says?/i</span></span>.test(<span class="hljs-string"><span class="hljs-string">'the Cat says meow'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> console.log(<span class="hljs-regexp"><span class="hljs-regexp">/cats? says?/i</span></span>.test(<span class="hljs-string"><span class="hljs-string">'the Cats say meow'</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  As you can see, each of the expressions returns <code>true</code> .  This is because we made the <code>s</code> characters at the end of the sequences <code>cat</code> and <code>say</code> optional.  In addition, you can notice that at the end of the regular expression is the flag <code>i</code> .  Thanks to him when analyzing strings ignored case of characters.  That is why a regular expression reacts to both the <code>cat</code> line and the <code>Cat</code> line. <br><br><h2>  <font color="#3AC1EF">About escaping service characters</font> </h2><br>  Regular expressions are enclosed in slashes.  In addition, some characters like <code>+</code> <code>?</code>  , and others, have a special meaning.  If you need to organize a search in the strings of these special characters, they need to be escaped with a backslash.  Here's what it looks like: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slash = <span class="hljs-regexp"><span class="hljs-regexp">/\//</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> qmark = <span class="hljs-regexp"><span class="hljs-regexp">/\?/</span></span>;</code> </pre> <br>  In addition, it is important to note that you can use different regular expressions to search for the same string structures.  Here are a couple of examples: <br><br><ul><li>  <code>\d</code> is the same as <code>[0-9]</code> .  Each of these expressions matches any numeric character. <br></li><li>  <code>\w</code> is the same as <code>[A-Za-z0-9_]</code> .  Both will find in the string any single alphanumeric character or underscore. <br></li></ul><br><h2>  <font color="#3AC1EF">Project ‚Ññ1: adding spaces to lines built in camel Style</font> </h2><br>  Now it's time to put this knowledge into practice.  In our first project, we are going to write a function that accepts a string, like <code>CamelCase</code> , and adds spaces between the individual words of which it is composed.  Using a ready-made function, which we call <code>removeCc</code> , looks like this: <br><br><pre> <code class="hljs vhdl">removeCc(<span class="hljs-symbol"><span class="hljs-symbol">'camelCase</span></span>') // =&gt;  <span class="hljs-symbol"><span class="hljs-symbol">'camel</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Case</span></span>'</code> </pre> <br>  For starters, you need to write a skeleton of a function that accepts a string and returns a new string: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeCc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br>  Now we just need to write in the <code>return</code> expression of this function some kind of construction that uses regular expressions that process the input data.  In order to do this, you first need to find all capital letters in the string, using a construction that defines a range of characters and provides a global search in the string. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">/[AZ]/g</span></span></code> </pre> <br>  This regular expression will respond to the letter <code>C</code> in the string <code>camelCase</code> .  How to add a space before this letter <code>C</code> ? <br><br>  In order to do this, we need exciting brackets.  In regular expressions, exciting parentheses are used to find matches and to memorize them.  This allows us to use the stored values ‚Äã‚Äãwhen we need them.  Here's how to work with exciting brackets: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   /</span></span>([AZ])/ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     $1</code> </pre> <br>  Here you can see that we use the construct <code>$1</code> to refer to the captured value.  It is worth noting that if there are two sets of exciting brackets in the expression, you can use the expressions <code>$1</code> and <code>$2</code> to refer to the captured values ‚Äã‚Äãin the order they follow from left to right.  In this case, exciting brackets can be used as many times as needed in a particular situation. <br><br>  Notice that we do not need to capture the value in brackets.  It is possible and not to use it, or to use non-capturing brackets with the help of a construction of the form <code>(?:x)</code>  In this example, there is a match with <code>x</code> , but it is not remembered. <br><br>  Let's return to our project.  There is a <code>String</code> object method that can be used to work with exciting brackets ‚Äî this is <code>.replace()</code> .  In order to use it, we will search for any capital letters in the string.  The second argument of the method, representing the replacement value, will be the stored value: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeCc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/([AZ])/g</span></span>, <span class="hljs-string"><span class="hljs-string">'$1'</span></span>); }</code> </pre> <br>  We are already close to the solution, although the goals have not yet been achieved.  Take a look at our code again.  Here we capture capital letters, then change them to the same letters.  And we need to have spaces in front of them.  It's quite simple to do this - just add a space before the <code>$1</code> variable.  As a result, before each capital letter in the string that the function returns, there will be a space.  As a result, we got the following: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeCc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(/([AZ])/g, <span class="hljs-string"><span class="hljs-string">' $1'</span></span>); } removeCc(<span class="hljs-string"><span class="hljs-string">'camelCase'</span></span>) // <span class="hljs-string"><span class="hljs-string">'camel Case'</span></span> removeCc(<span class="hljs-string"><span class="hljs-string">'helloWorldItIsMe'</span></span>) // <span class="hljs-string"><span class="hljs-string">'hello World It Is Me'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Project ‚Ññ2: removing capital letters from a line</font> </h2><br>  We will continue to bring the lines written in camel Style to a normal form.  So far this problem has been solved only partially.  Namely, we are not satisfied with the fact that the final line contains an excessive number of capital letters. <br><br>  Now we will deal with the removal of extra capital letters from the line and replacing them with capital letters.  Before reading further, think about this problem and try to find a solution.  However, if you fail, don‚Äôt be discouraged, as the solution to our problem, although simple, cannot be called very simple. <br><br>  So, the first thing we need is to select all capital letters in the line.  It uses the same construction as in the previous example: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">/[AZ]/g</span></span></code> </pre> <br>  Here we will use the <code>.replace()</code> method already familiar to you, but this time we will need something new when calling this method.  This is how the outline of what we need will look like.  Question marks indicate this new, as yet unknown, code: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lowerCase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[AZ]/g</span></span>, ???); }</code> </pre> <br>  The <code>.replace()</code> method is remarkable in that we can use a function as its second parameter.  This function will be called after a match is found, and what this function returns will be used as a string, replacing what the regular expression has found. <br><br>  If we also use the global search flag, the function will be called for every match with the pattern found in the string.  With this in mind, we can use the <code>.toLowerCase()</code> method of the <code>String</code> object to convert the input string to the desired form.  Here is how, taking into account the above, the solution to our problem looks like: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lowerCase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(/[AZ]/g, u =&gt; u.toLowerCase()); } lowerCase(<span class="hljs-string"><span class="hljs-string">'camel Case'</span></span>) // <span class="hljs-string"><span class="hljs-string">'camel case'</span></span> lowerCase(<span class="hljs-string"><span class="hljs-string">'hello World It Is Me'</span></span>) // <span class="hljs-string"><span class="hljs-string">'hello world it is me'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Project ‚Ññ3: conversion to upper case the first letter of the first word of a line</font> </h2><br>  This will be our last training project, in which we are going to make the first letter of the line being processed capitalized.  This is what we expect from the new feature: <br><br><pre> <code class="hljs vhdl">capitalize(<span class="hljs-symbol"><span class="hljs-symbol">'camel</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>') // =&gt;     <span class="hljs-symbol"><span class="hljs-symbol">'Camel</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>'</code> </pre> <br>  Here, as before, we will use the <code>.replace()</code> method.  However, this time we need to find only the very first character of the string.  In order to do this, use the symbol <code>^</code> .  Recall one of the above examples: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/cat/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'the cat says meow'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  If you add the <code>^</code> symbol to the beginning of the template, <code>true</code> this construction will not return.  This will happen because the word <code>cat</code> is not at the beginning of the line: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/^cat/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'the cat says meow'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  We need the special character <code>^</code> affect any lower-case character at the beginning of a line.  Therefore, we add it right before the <code>[az]</code> construct.  As a result, the regular expression will only respond to the first letter of the string in lowercase: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">/^[az]/</span></span></code> </pre> <br>  In addition, here we do not use the global search flag, since we need to find only one match with the template.  Now all that is left to do is convert the found character to upper case.  This can be done using the string method <code>.toUpperCase()</code> : <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">capitalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(/^[az]/, u =&gt; u.toUpperCase()); } capitalize(<span class="hljs-string"><span class="hljs-string">'camel case'</span></span>) // <span class="hljs-string"><span class="hljs-string">'Camel case'</span></span> capitalize(<span class="hljs-string"><span class="hljs-string">'hello world it is me'</span></span>) // <span class="hljs-string"><span class="hljs-string">'Hello world it is me'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Sharing previously created functions</font> </h2><br>  Now we have everything necessary to turn the lines written in camel Style into lines, separate words in which are separated by spaces, and which begin with a capital letter, despite the fact that the words inside these lines will be written in capital letters.  Here's how the shared functions you just created will look like: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeCc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/([AZ])/g</span></span>, <span class="hljs-string"><span class="hljs-string">' $1'</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lowerCase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[AZ]/g</span></span>, u =&gt; u.toLowerCase()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">capitalize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/^[az]/</span></span>, u =&gt; u.toUpperCase()); } capitalize(lowerCase(removeCc(<span class="hljs-string"><span class="hljs-string">'camelCaseIsFun'</span></span>))); <span class="hljs-comment"><span class="hljs-comment">// "Camel case is fun"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  As you can see, although regular expressions look very unusual for an unprepared person, they can be easily mastered.  The best way to learn regular expressions is practice.  We suggest that you try the following: write, on the basis of the three functions we have created, one that converts the string passed to it, like camelCase, into a regular sentence and adds a period after its last word. <br><br>  <b>Dear readers!</b>  If you managed to write a function that was just discussed - we suggest sharing its code in the comments.  In addition, if you are familiar with regular expressions, please tell us if this familiarity helped you in real projects. <br><br>  Well, the <a href="https://habrahabr.ru/search/%3Ftarget_type%3Dposts%26q%3D%255B%25D1%2580%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5%2520%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%255D%26order_by%3Drating">top Habrapostov</a> about regular expressions. </div><p>Source: <a href="https://habr.com/ru/post/343798/">https://habr.com/ru/post/343798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343788/index.html">Patties in go</a></li>
<li><a href="../343790/index.html">Configuring Authentication in SAP Netweaver AS Java (Part 3 of 3)</a></li>
<li><a href="../343792/index.html">Digital events in Moscow from December 4 to 10</a></li>
<li><a href="../343794/index.html">Cross-platform IoT: Troubleshooting</a></li>
<li><a href="../343796/index.html">How to quickly design a site using CSS Grid</a></li>
<li><a href="../343800/index.html">Probabilistic interpretation of classical machine learning models</a></li>
<li><a href="../343802/index.html">Cross-platform IoT: Device Operations</a></li>
<li><a href="../343804/index.html">A bit about the .NET Framework and .NET Core [plus useful links]</a></li>
<li><a href="../343806/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ291 (November 27 - December 3, 2017)</a></li>
<li><a href="../343808/index.html">Where is my payment? How fraudsters earn freelancers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>