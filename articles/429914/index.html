<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenSceneGraph: Scene graph and smart pointers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In the last article, we looked at the build of OpenSceneGraph from source and wrote an elementary example in which a gray plane hangs i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenSceneGraph: Scene graph and smart pointers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><br><h1>  Introduction </h1><br>  In the <a href="https://habr.com/post/429816/">last article,</a> we looked at the build of OpenSceneGraph from source and wrote an elementary example in which a gray plane hangs in an empty purple world.  I agree, not too impressive.  However, as I said before, in this small example there are main concepts on which this graphics engine is based.  Consider them in more detail.  The following material uses illustrations from <a href="https://alexander-bobkov.ru/osg/">Alexander Bobkov's blog about OSG</a> (it‚Äôs a pity that the author abandoned writing about OSG ...).  The article is also based on the material and examples from the book <a href="https://www.amazon.com/OpenSceneGraph-3-0-Beginners-Rui-Wang/dp/1849512825">OpenSceneGraph 3.0.</a>  <a href="https://www.amazon.com/OpenSceneGraph-3-0-Beginners-Rui-Wang/dp/1849512825">Beginner's Guide</a> <br><br>  I must say that the previous publication was subjected to some criticism, with which I partially agree - the material was left unsaid and taken out of context.  I will try to correct this omission under the cut. <br><a name="habracut"></a><br><h1>  1. Briefly about the graph of the scene and its nodes </h1><br>  The central concept of the engine is the so-called <i>scene graph</i> (it is not by chance that it frayed into the very name of the framework) - a tree-like hierarchical structure that allows you to organize the logical and spatial representation of the three-dimensional scene.  The scene graph contains the root node and its associated intermediate and end nodes or <i>nodes</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      for example <br><br><img src="https://habrastorage.org/webt/va/m7/l4/vam7l4ap2qwqgyev2ofzlcbt-vo.png"><br><br>  This graph depicts a scene consisting of a house and a table in it.  The house has a certain geometric representation and is in a certain way located in space relative to a certain basic coordinate system associated with the root node (root).  The table is also described by some geometry, located in some way relative to the house, and together with the house - relative to the root node.  All nodes possessing common properties, because they are inherited from the same class osg :: Node, are divided into types according to their functional purpose <br><br><ol><li>  Group nodes (osg :: Group) are the base class for all intermediate nodes and are intended for combining other nodes into groups. </li><li>  Transformation nodes (osg :: Transform and its heirs) are intended to describe the transformation of object coordinates </li><li>  Geometrical nodes (osg :: Geode) are terminal (leaf) nodes of a scene graph containing information about one or several geometric objects. </li></ol><br>  The geometry of scene objects in OSG is described in its own local coordinate system.  Transformation nodes located between this object and the root node implement matrix coordinate transformations to obtain the position of the object in the base coordinate system. <br><br>  Nodes perform many important functions, in particular, they store the display state of objects, and this state affects only the subgraph associated with this node.  Several callbacks and event handlers can be associated with the nodes of a scene graph, allowing you to change the state of a node and its associated subgraph. <br><br>  All global operations on the graph of the scene related to obtaining the final result on the screen are performed by the engine automatically, by periodically traversing the graph in depth. <br><br>  In the example considered <a href="https://habr.com/post/429816/">last time</a> , our scene consisted of a single object ‚Äî an airplane model loaded from a file.  Running very far forward, I will say that this model is a leaf node of the scene graph.  It is tightly welded to the global base coordinate system of the engine. <br><br><h1>  2. Memory Management in OSG </h1><br>  Since the nodes of the scene graph store a lot of data about the scene objects and operations on them, it is necessary to allocate memory, including dynamically, to store this data.  In this case, when manipulating the scene graph, and, for example, removing some of its nodes, you need to carefully monitor that the remote nodes of the graph are no longer processed.  This process is always accompanied by errors, time-consuming debugging, since it is rather difficult for a developer to track which pointers to objects refer to existing data and which must be deleted.  Without effective memory management, segmentation errors and memory leaks are likely. <br><br>  Memory management is a critical task in OSG and its concept is based on two theses: <br><br><ol><li>  Memory Allocation: Ensuring the allocation of storage space required by an object. <br></li><li>  Freeing memory: Returning the allocated memory to the system at the moment when it is not necessary. <br></li></ol><br>  Many modern programming languages, such as C #, Java, Visual Basic .Net, and the like, use the so-called garbage collector to free allocated memory.  The concept of the C ++ language does not provide for a similar approach, but we can simulate it by using so-called smart pointers. <br><br>  Today, C ++ has smart pointers in its arsenal, which is called ‚Äúout of the box‚Äù (and the C ++ 17 standard has already managed to rid the language of some obsolete types of smart pointers), but this was not always the case.  The earliest of the official versions of OSG number 0.9 was born in 2002, and before the first official release was still three years.  At that time, the C ++ standard did not yet provide smart pointers, and even if <a href="https://habr.com/article/424221/">one</a> believes <a href="https://habr.com/article/424221/">one historical excursion</a> , the language itself was going through hard times.  So, the appearance of a bicycle in the form of its own smart pointers, which are implemented in OSG is not surprising at all.  This mechanism is deeply integrated into the structure of the engine, so it is absolutely necessary to understand its work from the very beginning. <br><br><h1>  3. Classes osg :: ref_ptr &lt;&gt; and osg :: Referenced </h1><br>  OSG provides its own smart pointer engine based on the osg :: ref_ptr &lt;&gt; template class to implement automatic garbage collection.  For its proper operation, OSG provides another class osg :: Referenced for managing memory blocks for which reference counts are made. <br><br>  The class osg :: ref_ptr &lt;&gt; provides several operators and methods. <br><br><ul><li>  get () is a public method that returns a "raw" pointer, for example, when using the template osg :: Node as an argument, this method will return osg :: Node *. <br></li><li>  operator * () is actually a dereference operator. <br></li><li>  operator -&gt; () and operator = () allow using osg :: ref_ptr &lt;&gt; as a classic pointer when accessing methods and properties of objects described by this pointer. <br></li><li>  operator == (), operator! = () and operator! () - allow you to perform comparison operations on smart pointers. <br></li><li>  valid () is a public method that returns true if the managed pointer has a valid value (not NULL).  The expression some_ptr.valid () is equivalent to the expression some_ptr! = NULL, if some_ptr is a smart pointer. <br></li><li>  release () is a public method, useful when you want to return a managed address from a function.  About him will be discussed in more detail later. <br></li></ul><br>  The osg :: Referenced class is the base class for all elements of the scene graph, such as nodes, geometry, rendering states, and other objects placed on the scene.  Thus, creating the root node of the scene, we indirectly inherit all the functionality provided by the class osg :: Referenced.  Therefore, in our program there is an announcement <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root;</code> </pre> <br>  The class osg :: Referenced contains an integer counter of references to the allocated block of memory.  This counter is initialized to zero in the class constructor.  It is incremented by one when an osg :: ref_ptr &lt;&gt; object is created.  This counter decreases as soon as any reference to the object described by this pointer is deleted.  The object is automatically destroyed when it is no longer referenced by any smart pointers. <br><br>  The osg :: Referenced class has three public methods: <br><br><ul><li>  ref () is a public method that increments the reference count by 1. <br></li><li>  unref () is a public method that reduces the reference count by 1. <br></li><li>  referenceCount () is a public method that returns the current value of the reference count, which is useful when debugging code. <br></li></ul><br>  These methods are available in all classes derived from osg :: Referenced.  However, it should be remembered that manual control of the reference count can lead to unpredictable consequences, and taking advantage of this, you should be clear about what you are doing. <br><br><h1>  4. How OSG performs garbage collection and why it is needed </h1><br>  There are several reasons why smart pointers and garbage collection should be used: <br><br><ul><li>  Minimize critical errors: the use of smart pointers allows you to automate the allocation and release of memory.  There are no dangerous "raw" pointers. <br></li><li>  Effective memory management: memory allocated for an object is released as soon as the object is no longer needed, which leads to economical use of system resources. <br></li><li>  Facilitating debugging of an application: having the ability to accurately track the number of references to an object, we have opportunities for all sorts of optimizations and experiments. <br></li></ul><br>  Suppose that a scene graph consists of a root node and several levels of child nodes.  If the root node and all child nodes are managed using the class osg :: ref_ptr &lt;&gt;, then the application can only track the pointer to the root node.  Deleting this node will lead to sequential, automatic deletion of all child nodes. <br><br><img src="https://habrastorage.org/webt/5r/az/ri/5razrigi8nvg-75jwcm4vhhurda.png"><br><br>  Smart pointers can be used as local variables, global variables, class members, and automatically reduce the reference count when the smart pointer goes out of scope. <br><br>  Smart pointers are strongly recommended by OSG developers for use in projects, but there are a few key points to consider: <br><br><ul><li>  Instances of osg :: Referenced and its derivatives can be created exclusively on the heap.  They cannot be created on the stack as local variables, since the destructors of these classes are declared as proteced.  for example <br></li></ul><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  osg::Node node; // </span></span></code> </pre><br><ul><li>  You can create temporary scene nodes using ordinary C ++ pointers, but this approach will not be safe.  Better to use smart pointers to ensure correct control of the scene graph. <br></li></ul><br><pre> <code class="cpp hljs">osg::Node *tmpNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Node; <span class="hljs-comment"><span class="hljs-comment">//  ,  ... osg::ref_ptr&lt;osg::Node&gt; node = tmpNode; //         !</span></span></code> </pre><br><ul><li>  In no case should cyclic references be used in the scene tree when a node references itself directly or indirectly through several levels. <br></li></ul><br><img src="https://habrastorage.org/webt/ds/af/er/dsafertsy4m2doboaeb9cgjdzyk.png"><br><br>  In the above example, the scene graph of a Child 1.1 node refers to itself, and the Child 2.2 node also references the Child 1.2 node.  Such links can lead to incorrect calculation of the number of links and undefined program behavior. <br><br><h1>  5. Tracked managed objects </h1><br>  To illustrate the operation of the smart pointer mechanism in OSG, we will write the following synthetic example <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/ref_ptr&gt; #include &lt;osg/Referenced&gt; #include &lt;iostream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class MonitoringTarget : public osg::Referenced { public: MonitoringTarget(int id) : _id(id) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Constructing target " &lt;&lt; _id &lt;&lt; std::endl; } protected: virtual ~MonitoringTarget() { std::cout &lt;&lt; "Dsetroying target " &lt;&lt; _id &lt;&lt; std::endl; } int _id; }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;MonitoringTarget&gt; target = new MonitoringTarget(0); std::cout &lt;&lt; "Referenced count before referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target; std::cout &lt;&lt; "Referenced count after referring: " &lt;&lt; target-&gt;referenceCount() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Create a descendant class osg :: Referenced that does nothing except in the constructor and destructor informing that its instance has been created and displaying the identifier defined when creating the instance.  Create a class instance using the smart pointer engine <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Next, display the reference count for the target object. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count before referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  After that, create a new smart pointer, assigning it the value of the previous pointer <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;MonitoringTarget&gt; anotherTarget = target;</code> </pre><br>  and again display the reference count <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Referenced count after referring: "</span></span> &lt;&lt; target-&gt;referenceCount() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Let's see what we did by analyzing the output of the program. <br><br><pre> <code class="plaintext hljs">15:42:39:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Dsetroying target 0 15:42:42:  </code> </pre><br>  When the class constructor is started, a corresponding message is displayed, telling us that the memory for the object is allocated and the constructor has worked normally.  Further, after creating a smart pointer, we see that the reference count for the created object has increased by one.  Creating a new pointer, with assigning it the value of the old pointer - in fact, creating a new link to the same object, so the reference count is increased by one more.  When you exit the program, the MonitoringTarget class destructor is called. <br><br><img src="https://habrastorage.org/webt/oi/hv/gh/oihvghcjfhchgrjkd0wpxm_hmr4.png"><br><br>  Let's conduct one more experiment, adding such code to the end of the main () function <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(i); }</code> </pre><br>  leading to such an "exhaust" program <br><br><pre> <code class="plaintext hljs">16:04:30:   Constructing target 0 Referenced count before referring: 1 Referenced count after referring: 2 Constructing target 1 Dsetroying target 1 Constructing target 2 Dsetroying target 2 Constructing target 3 Dsetroying target 3 Constructing target 4 Dsetroying target 4 Dsetroying target 0 16:04:32:  </code> </pre><br>  We create several objects in the body of the loop, using a smart pointer.  Since the scope of the pointer in this case extends only to the body of the loop, when you exit it, the destructor is automatically called.  This would not have happened, obviously, if we used ordinary pointers. <br><br>  Another important feature of working with smart pointers is associated with automatic memory freeing.  Since the destructor of classes derived from osg :: Referenced is made protected, we cannot explicitly call the delete operator to delete an object.  The only way to remove an object is to nullify the number of references to it.  But then our code becomes unsafe with multi-threaded data processing - we can access an object that has already been deleted from another thread. <br><br>  Fortunately, OSG provides a solution to this problem with its scheduler for deleting objects.  This scheduler is based on the use of the class osg :: DeleteHandler.  It works in such a way that it does not perform the operation of deleting an object right away, but executes it after a while.  All objects to be deleted are temporarily remembered until a moment comes for safe removal, and then they are all deleted at once.  The osg :: DeleteHandler removal scheduler is managed by the OSG render backend. <br><br><h1>  6. Return from function </h1><br>  Add the following function to our example code. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MonitoringTarget *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMonitoringTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;MonitoringTarget&gt; target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MonitoringTarget(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.release(); }</code> </pre><br>  and replace the call to the new operator in a loop with a call to this function. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { osg::ref_ptr&lt;MonitoringTarget&gt; subTarget = createMonitoringTarget(i); }</code> </pre><br>  Calling release () will reduce the number of references to the object to zero, but instead of deleting the memory, it returns directly the actual pointer to the allocated memory.  If this pointer is assigned to another smart pointer, then there will be no memory leaks. <br><br><h1>  findings </h1><br>  The concepts of the scene graph and smart pointers are basic for understanding the principle of operation, and hence the effective use of OpenSceneGraph.  With regard to OSG smart pointers, it should be remembered that their use is absolutely necessary when <br><br><ul><li>  It is assumed long-term storage facility </li><li>  One object stores a link to another object. </li><li>  You must return a pointer from the function </li></ul><br>  The sample code provided in the article <a href="https://github.com/maisvendoo/OSG-lessons">is available here</a> . <br><br>  <i><a href="https://habr.com/post/430212/">To be continued...</a></i> </div><p>Source: <a href="https://habr.com/ru/post/429914/">https://habr.com/ru/post/429914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429902/index.html">Page Rank in the Web 2.0 era - Part 1</a></li>
<li><a href="../429904/index.html">Funny and sad stories about the development of computer games</a></li>
<li><a href="../429908/index.html">How to use korutiny in prode and sleep well at night</a></li>
<li><a href="../429910/index.html">AppsConf Rises</a></li>
<li><a href="../429912/index.html">Library development: from API to public release</a></li>
<li><a href="../429916/index.html">How to build and build</a></li>
<li><a href="../429918/index.html">Intel Virtual World. Part 2: SMP</a></li>
<li><a href="../429920/index.html">The tragicomedy in NaN acts: how we made the game on JS and released it on Steam</a></li>
<li><a href="../429922/index.html">How to turn a simple project into unfinished or cutting off all unnecessary</a></li>
<li><a href="../429926/index.html">Roskomnadzor: Google confirms willingness to comply with Russian legislation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>