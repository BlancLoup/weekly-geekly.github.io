<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MVVM: a new look</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Attention! 
 More recent and progressive materials on the MVVM pattern are presented in the article Context Model Pattern via Aero Framework and are d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MVVM: a new look</h1><div class="post__text post__text-html js-mediator-article">  <i>Attention!</i> <br>  <u>More recent and progressive materials on the <i>MVVM</i> pattern are presented in the article <a href="http://habrahabr.ru/post/251347/">Context Model Pattern via Aero Framework</a> and are discussed in detail in the <a href="http://habrahabr.ru/users/makeman/topics/">next series of articles.</a></u> <br><br>  <b>Foreword</b> <br><br>  Some time ago I started developing a free text editor with a beautiful interface and wide user-friendly functionality on the WPF platform.  It was possible to solve a lot of technical problems, so I have gained some experience that I want to share with other people. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>To business</b> <br><br>  Developers of WPF, Silverlight and WinPhone applications are familiar with the MVVM design pattern (Model - View - ViewModel).  However, if you additionally apply a little more fantasy to it, then something more interesting may turn out, and I dare to assure you a little even that it is revolutionary. <a name="habracut"></a><br><br>  Suppose we have a classic window (View) of a text editor with a menu, a toolbar and a status bar that can be hidden if desired.  Our task is to preserve the position and size of the window, as well as the visual state of the elements when the application is closed, and then restore them. <br><br>  The usual solution that immediately comes to mind is to add a number of additional properties to the view model for snapping (Top, Left, Width, Heigth, ShowToolBarTray, ShowStatusBar and others), and then saving their values, for example, to a file.  But let's not hurry ... What if I tell you that you can create such a view model that implements the necessary functionality by default, so you don‚Äôt need ANY extra line of code to solve the problem? <br><br>  <b>Immediately I recommend downloading the sample application, which I made specifically for this article (link <a href="http://yadi.sk/d/_iq--fSVFThbk">one</a> or <a href="">two</a> )</b> , it will help you understand the main ideas and experience the beauty of the approach.  Here I will give certain parts of the code that you should pay special attention to. <br><br>  In WPF, property binding is often used, but it is also possible to bind to elements of an array, which is used quite rarely.  But here it opens up new horizons for us.  Let's try to consider the view model as a dictionary, where the key-index is the name of the property by which its value can be obtained. <br><br>  But how do we better preserve these values?  Let's try to serialize the view models!  But? .. This is not a DTO object, and how can they be deserialized, because the constructor often needs to inject other parameters, and for deserialization you usually need a constructor without parameters?  And you didn‚Äôt seem to be somewhat uncomfortable injecting into the constructor, for example, when adding or removing a parameter, unit tests broke, and they also needed to be edited, although the interface of the object under test remained essentially the same? <br><br>  Therefore, we give up injections into the constructor, thankfully, there are other ways for such purposes, and mark the view model with the [DataContract] attribute, and the properties that need to be serialized with the [DataMember] attribute (these attributes greatly simplify serialization). <br><br>  Now create a small class Store. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Store</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; StoredItemsDictionary = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TItem OfType&lt;TItem&gt;(<span class="hljs-keyword"><span class="hljs-keyword">params</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] args) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TItem : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (TItem); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StoredItemsDictionary.ContainsKey(itemType)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TItem) StoredItemsDictionary[itemType]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasDataContract = Attribute.IsDefined(itemType, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (DataContractAttribute)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = hasDataContract ? Serializer.DeserializeDataContract&lt;TItem&gt;() ?? (TItem) Activator.CreateInstance(itemType, args) : (TItem) Activator.CreateInstance(itemType, args); StoredItemsDictionary.Add(itemType, item); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TItem) StoredItemsDictionary[itemType]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Snapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StoredItemsDictionary .Where(p =&gt; Attribute.IsDefined(p.Key, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (DataContractAttribute))) .Select(p =&gt; p.Value).ToList() .ForEach(i =&gt; i.SerializeDataContract()); } }</code> </pre> <br><br>  Everything is simple - only two methods.  OfType returns us a static instance of an object of the required type, possibly deserializing it, and Snapshot takes a ‚Äúsnapshot‚Äù of the objects in the container, serializing them.  In general, a snapshot can be called only once when the application is closed, for example, in the Exit handler of the Application class. <br><br>  And write Json-serializer. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Serializer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> JsonExtension = <span class="hljs-string"><span class="hljs-string">".json"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;Type&gt; KnownTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Type&gt; { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Type), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (SolidColorBrush), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (MatrixTransform), }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializeDataContract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Type type = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { type = type ?? item.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(file)) file = type.Name + JsonExtension; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serializer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataContractJsonSerializer(type, KnownTypes); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = File.Create(file)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentCulture = Thread.CurrentThread.CurrentCulture; Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture; serializer.WriteObject(stream, item); Thread.CurrentThread.CurrentCulture = currentCulture; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception exception) { Trace.WriteLine(<span class="hljs-string"><span class="hljs-string">"Can not serialize json data contract"</span></span>); Trace.WriteLine(exception.StackTrace); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TItem DeserializeDataContract&lt;TItem&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> file = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(file)) file = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (TItem).Name + JsonExtension; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serializer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataContractJsonSerializer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (TItem), KnownTypes); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = File.OpenRead(file)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentCulture = Thread.CurrentThread.CurrentCulture; Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = (TItem) serializer.ReadObject(stream); Thread.CurrentThread.CurrentCulture = currentCulture; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(TItem); } } }</code> </pre><br><br>  The base class for twisting models is also not difficult. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DataContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ViewModelBase</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyNameProvider</span></span>, <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanging</span></span>, <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanged</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; Values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> IndexerName = System.Windows.Data.Binding.IndexerName; <span class="hljs-comment"><span class="hljs-comment">/* "Item[]" */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> PropertyChangingEventHandler PropertyChanging = (sender, args) =&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> PropertyChangedEventHandler PropertyChanged = (sender, args) =&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> key] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Values.ContainsKey(key) ? Values[key] : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { RaisePropertyChanging(IndexerName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Values.ContainsKey(key)) Values[key] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Values.Add(key, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); RaisePropertyChanged(IndexerName); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> defaultValue] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Values.ContainsKey(key)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Values[key]; Values.Add(key, defaultValue); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultValue; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[key] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaisePropertyChanging</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName</span></span></span><span class="hljs-function">)</span></span> { PropertyChanging(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyChangingEventArgs(propertyName)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaisePropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName</span></span></span><span class="hljs-function">)</span></span> { PropertyChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyChangedEventArgs(propertyName)); } [OnDeserializing] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">StreamingContext context = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default</span></span></span></span><span class="hljs-function"><span class="hljs-params">(StreamingContext</span></span></span><span class="hljs-function">))</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PropertyChanging == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) PropertyChanging = (sender, args) =&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PropertyChanged == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) PropertyChanged = (sender, args) =&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Values == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); } }</code> </pre><br><br>  We will also inherit from a small class PropertyNameProvider, which will be useful to us later on for working with lambda expressions. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DataContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PropertyNameProvider</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> GetPropertyName&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; expression) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memberExpression = expression.Body <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberExpression; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unaryExpression = expression.Body <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UnaryExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unaryExpression != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) memberExpression = unaryExpression.Operand <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memberExpression == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || memberExpression.Member.MemberType != MemberTypes.Property) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Invalid lambda expression format."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memberExpression.Member.Name; } }</code> </pre><br><br>  Well, at this stage, we implemented the ability to bind to the properties-indices.  You can write the following form in xaml <br><br>  Height = "{Binding '[Height, 600]', Mode = TwoWay}" <br><br>  where the first parameter is the name of the property, and the second (optional) is its default value. <br><br>  This approach is somewhat similar to the implementation of the standard IDataErrorInfo interface.  Why don't we implement it too?  Good idea, but let's not hurry, but take it into account ... Let's play with the redefinition of the indexer.  Everyone remembers about ICommand, and in WPF there is still a cool mechanism for working RoutedCommands and CommandBindings.  It would be great to write the implementation of commands in a view model in this way. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ApplicationCommands.Save].CanExecute += (sender, args) =&gt; args.CanExecute = HasChanged; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ApplicationCommands.New].CanExecute += (sender, args) =&gt; { args.CanExecute = !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(FileName) || !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(Text); }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ApplicationCommands.Help].Executed += (sender, args) =&gt; MessageBox.Show(<span class="hljs-string"><span class="hljs-string">"Muse 2014"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ApplicationCommands.Open].Executed += (sender, args) =&gt; Open(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ApplicationCommands.Save].Executed += (sender, args) =&gt; Save(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ApplicationCommands.SaveAs].Executed += (sender, args) =&gt; SaveAs(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ApplicationCommands.Close].Executed += (sender, args) =&gt; Environment.Exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ApplicationCommands.New].Executed += (sender, args) =&gt; { Text = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; FileName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; HasChanged = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre><br><br>  Well, what a view model without automatic notification of properties and expressions?  It should be anyway. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Text { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(() =&gt; Text); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Set(() =&gt; Text, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre><br><br>  But what if ... Create a PropertyBinding like a CommandBinding and play again a little bit with the indexer? <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[() =&gt; Text].PropertyChanged += (sender, args) =&gt; HasChanged = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[() =&gt; FontSize].Validation += () =&gt; <span class="hljs-number"><span class="hljs-number">4.0</span></span> &lt; FontSize &amp;&amp; FontSize &lt; <span class="hljs-number"><span class="hljs-number">128.0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : <span class="hljs-string"><span class="hljs-string">"Invalid font size"</span></span>;</code> </pre><br><br>  Looks good, isn't it? <br><br>  And, of course, our wonder-view model. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DataContract</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ViewModelBase</span></span>, <span class="hljs-title"><span class="hljs-title">IDataErrorInfo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Initialize(); } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> IDataErrorInfo.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PropertyBindings.ContainsKey(propertyName) ? PropertyBindings[propertyName].InvokeValidation() : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PropertyBinding <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[Expression&lt;Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt; expression] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertyName = GetPropertyName(expression); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PropertyBindings.ContainsKey(propertyName)) PropertyBindings.Add(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyBinding(propertyName)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PropertyBindings[propertyName]; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CommandBinding <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[ICommand command] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CommandBindings.ContainsKey(command)) CommandBindings.Add(command, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommandBinding(command)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CommandBindings[command]; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Error { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Dictionary&lt;ICommand, CommandBinding&gt; CommandBindings { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, PropertyBinding&gt; PropertyBindings { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CancelEventHandler OnClosing = (o, e) =&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TProperty Get&lt;TProperty&gt;(Expression&lt;Func&lt;TProperty&gt;&gt; expression, TProperty defaultValue = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(TProperty)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertyName = GetPropertyName(expression); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Values.ContainsKey(propertyName)) Values.Add(propertyName, defaultValue); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TProperty) Values[propertyName]; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Set&lt;TProperty&gt;(Expression&lt;Func&lt;TProperty&gt;&gt; expression, TProperty <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertyName = GetPropertyName(expression); RaisePropertyChanging(propertyName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Values.ContainsKey(propertyName)) Values.Add(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Values[propertyName] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RaisePropertyChanged(propertyName); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RaisePropertyChanging&lt;TProperty&gt;(Expression&lt;Func&lt;TProperty&gt;&gt; expression) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertyName = GetPropertyName(expression); RaisePropertyChanging(propertyName); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RaisePropertyChanged&lt;TProperty&gt;(Expression&lt;Func&lt;TProperty&gt;&gt; expression) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertyName = GetPropertyName(expression); RaisePropertyChanged(propertyName); } [OnDeserializing] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">StreamingContext context = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default</span></span></span></span><span class="hljs-function"><span class="hljs-params">(StreamingContext</span></span></span><span class="hljs-function">))</span></span> { CommandBindings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;ICommand, CommandBinding&gt;(); PropertyBindings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, PropertyBinding&gt;(); PropertyChanging += OnPropertyChanging; PropertyChanged += OnPropertyChanged; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPropertyChanging</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, PropertyChangingEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertyName = e.PropertyName; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PropertyBindings.ContainsKey(propertyName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> binding = PropertyBindings[propertyName]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binding != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) binding.InvokePropertyChanging(sender, e); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, PropertyChangedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertyName = e.PropertyName; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PropertyBindings.ContainsKey(propertyName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> binding = PropertyBindings[propertyName]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binding != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) binding.InvokePropertyChanged(sender, e); } }</code> </pre><br><br>  Now we are fully armed, but there is no limit to perfection.  As a rule, a twist model is associated with its view (twist) in C # code, but how beautiful it would be to do this binding directly in xaml!  Remember about our refusal of injections in the designer?  Here he gives us the opportunity.  Let's write a small markup extension *. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StoreExtension</span></span> : <span class="hljs-title"><span class="hljs-title">MarkupExtension</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StoreExtension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type itemType</span></span></span><span class="hljs-function">)</span></span> { ItemType = itemType; } [ConstructorArgument(<span class="hljs-string"><span class="hljs-string">"ItemType"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Type ItemType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProvideValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceProvider serviceProvider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = (IProvideValueTarget) serviceProvider.GetService(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (IProvideValueTarget)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frameworkElement = service.TargetObject <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FrameworkElement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dependancyProperty = service.TargetProperty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DependencyProperty; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodInfo = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Store).GetMethod(<span class="hljs-string"><span class="hljs-string">"OfType"</span></span>).MakeGenericMethod(ItemType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = methodInfo.Invoke(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (frameworkElement != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; dependancyProperty == FrameworkElement.DataContextProperty &amp;&amp; item <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ViewModel) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewModel = (ViewModel) item; frameworkElement.CommandBindings.AddRange(viewModel.CommandBindings.Values); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> window = frameworkElement <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Window; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) viewModel.OnClosing += (o, e) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!e.Cancel) window.Close(); }; frameworkElement.Initialized += (sender, args) =&gt; frameworkElement.DataContext = viewModel; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } }</code> </pre><br><br>  Voila, you're done! <br><br>  DataContext = "{Store viewModels: MainViewModel}" <br><br>  I draw attention to the fact that during binding, the control changes not only the DataContext, but also the CommandBindings collection is filled with values ‚Äã‚Äãfrom the view model. <br><br>  (* In order not to write prefixes like "{foundation: Store viewModels: MainViewModel}" before markup extensions, they should be implemented in a separate project and you need to write something like this in the AssemblyInfo.cs file <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: XmlnsDefinition(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Foundation"</span></span></span><span class="hljs-meta">)</span></span>] [assembly: XmlnsDefinition(<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span>, <span class="hljs-string"><span class="hljs-string">"Foundation.Converters"</span></span>)] [assembly: XmlnsDefinition(<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span>, <span class="hljs-string"><span class="hljs-string">"Foundation.MarkupExtensions"</span></span>)]</code> </pre>  ) <br><br>  In a similar way, we will embellish the binding to the indices, which was discussed above. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ViewModelExtension</span></span> : <span class="hljs-title"><span class="hljs-title">MarkupExtension</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> BooleanConverter BooleanToVisibilityConverter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BooleanConverter { OnTrue = Visibility.Visible, OnFalse = Visibility.Collapsed, }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FrameworkElement _targetObject; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyProperty _targetProperty; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewModelExtension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewModelExtension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key</span></span></span><span class="hljs-function">)</span></span> { Key = key; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewModelExtension</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> defaultValue</span></span></span><span class="hljs-function">)</span></span> { Key = key; DefaultValue = defaultValue; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Key { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> StringFormat { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ElementName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> DefaultValue { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> FallbackValue { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> TargetNullValue { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IValueConverter Converter { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RelativeSource RelativeSource { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProvideValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceProvider serviceProvider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = (IProvideValueTarget) serviceProvider.GetService(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (IProvideValueTarget)); _targetProperty = service.TargetProperty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DependencyProperty; _targetObject = service.TargetObject <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FrameworkElement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_targetObject == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || _targetProperty == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = Key; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_targetProperty == UIElement.VisibilityProperty &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(key)) key = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Show{0}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(_targetObject.Name) ? _targetObject.Tag : _targetObject.Name); key = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(key) ? _targetProperty.Name : key; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(StringFormat)) Key = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(StringFormat, _targetObject.Tag); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = DefaultValue == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? key : key + <span class="hljs-string"><span class="hljs-string">","</span></span> + DefaultValue; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(ElementName) &amp;&amp; RelativeSource == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-string"><span class="hljs-string">"["</span></span> + index + <span class="hljs-string"><span class="hljs-string">"]"</span></span> : <span class="hljs-string"><span class="hljs-string">"DataContext["</span></span> + index + <span class="hljs-string"><span class="hljs-string">"]"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_targetProperty == UIElement.VisibilityProperty &amp;&amp; Converter == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Converter = BooleanToVisibilityConverter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Binding(path) {Mode = BindingMode.TwoWay, Converter = Converter}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ElementName != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) binding.ElementName = ElementName; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FallbackValue != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) binding.FallbackValue = FallbackValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TargetNullValue != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) binding.TargetNullValue = TargetNullValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RelativeSource != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) binding.RelativeSource = RelativeSource; _targetObject.SetBinding(_targetProperty, binding); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> binding.ProvideValue(serviceProvider); } }</code> </pre><br><br>  You can write xaml like this: <br><br>  Width = "{ViewModel DefaultValue = 800}" <br><br>  <b>Results</b> <br><br>  Perhaps enough, I presented a lot of information in a compressed form, so for a complete understanding it is better to get acquainted with the example of the project. <br><br>  Summarizing all the above, we can distinguish the following advantages of the approach: <br>  - clean, concise and structured code.  Interface logic, weakly related to business logic, is encapsulated inside the base classes of the view model, while the specific implementation of the view model contains exactly the logic that is closely related to business rules; <br>  - simplicity and versatility.  Everything else, serialization allows very flexible configuration of the application interface using configuration files; <br>  - convenient implementation of validation through the IDataErrorInfo interface. <br><br>  Minuses: <br>  - refusal of injections into the constructor (although this is not a mandatory requirement); <br>  - some implicit decision for a person not familiar with it. <br><br>  <b>Having mastered this approach and having only a few basic classes at your disposal, you can write applications comfortably, quickly and efficiently with a rich interactive interface, while leaving the twist models clean and compact.</b> <br><br>  I really hope that the article will be useful for you!  Thanks for attention! <br><br>  PS I don‚Äôt know exactly how in Silverlight, but on the WinPhone-platform there are some limitations (there are no markup extensions, RoutedCommands and CommandBindings), but with a strong desire they can be circumvented.  This is described in more detail in the <a href="http://habrahabr.ru/post/210778/">WinPhone</a> article <a href="http://habrahabr.ru/post/210778/">: Ways to Perfection</a> . <br><br>  PPS As I said above, all the methods described are applied by me when creating a full-fledged text editor.  Those who are interested in, what ultimately turned out for the creation, can find it on <a href="http://poet.of.by/ru/">this link</a> or <a href="http://yadi.sk/d/eU7-sZkAFcv2B">backup</a> .  It seems to me that <b>in programming and poetry there is a lot in common</b> : just as a master of words is able to express with a few phrases what an ordinary person will take more than one paragraph, so an experienced programmer solves a complex problem with several lines of code. <br><br>  Inspiration to you! <br><br>  ~~~~~~~~~~~~~~~~~~~~~~~~~ <br>  <i>Comments:</i> <br><br>  - you can use any control as a view (View), so sometimes it is not necessary to select the view as a separate entity (new class), as well as add a property to another view model.  Let me explain with an example: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Window</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DataContext</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{Store</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">viewModels:MainViewModel</span></span></span><span class="hljs-tag">}&gt;</span></span> ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">&lt;!--&lt;TextBlock DataContext={Store viewModels:DetailsViewModel} Text={Binding Name}/&gt;--!&gt; &lt;TextBlock Text={Binding Name, Source={Store viewModels:DetailsViewModel}}/&gt; ‚Ä¶ &lt;/Window&gt;</span></span></code> </pre><br><br>  That is, we do not need to inject the DetailsViewModel into the MainViewModel, just to display the Name property somewhere on the interface, it is also not necessary, for example, to create the DetailsShortView.  The project has fewer classes, and the structure remains clear. <br><br>  - in the article I showed the basic principles, using which you can quickly and efficiently make a functional application.  It is absolutely not necessary to use everything as it is, you have the right to improve, modify and fantasize!  This is the development, success! </div><p>Source: <a href="https://habr.com/ru/post/208326/">https://habr.com/ru/post/208326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208308/index.html">About statistics, karma and rating</a></li>
<li><a href="../208314/index.html">We write virtual clipboard on C #</a></li>
<li><a href="../208318/index.html">Home CNC router as an alternative to 3D printer, part one - the choice of machine</a></li>
<li><a href="../208320/index.html">To work with a clear conscience</a></li>
<li><a href="../208322/index.html">Will SAFE replace convertible notes?</a></li>
<li><a href="../208328/index.html">Create a behavior for Yii2</a></li>
<li><a href="../208330/index.html">Google engineers told about the success in recognizing house numbers from StreetView photos</a></li>
<li><a href="../208332/index.html">Meet the Intel Edison - SD-sized computer</a></li>
<li><a href="../208334/index.html">Winners of the 22nd IOCCC competition</a></li>
<li><a href="../208336/index.html">Toyota will sell fuel cell vehicles in 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>