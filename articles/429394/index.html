<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 16: "Attacks through the side channel", part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 16: "Attacks through the side channel", part 3</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <br>  Lecture 4: "Separation of privileges" <a href="https://habr.com/company/ua-hosting/blog/418195/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418197/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418211/">Part 3</a> <br>  Lecture 5: "Where Security Errors Come From" <a href="https://habr.com/company/ua-hosting/blog/418213/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418215/">Part 2</a> <br>  Lecture 6: "Opportunities" <a href="https://habr.com/company/ua-hosting/blog/418217/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418219/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418221/">Part 3</a> <br>  Lecture 7: "Sandbox Native Client" <a href="https://habr.com/company/ua-hosting/blog/418223/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418225/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418227/">Part 3</a> <br>  Lecture 8: "Model of network security" <a href="https://habr.com/company/ua-hosting/blog/418229/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/423155/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/423423/">Part 3</a> <br>  Lecture 9: "Web Application Security" <a href="https://habr.com/company/ua-hosting/blog/424289/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/424295/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/424297/">Part 3</a> <br>  Lecture 10: "Symbolic execution" <a href="https://habr.com/company/ua-hosting/blog/425557/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/425561/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/425559/">Part 3</a> <br>  Lecture 11: "Ur / Web programming language" <a href="https://habr.com/company/ua-hosting/blog/425997/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/425999/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/426001/">Part 3</a> <br>  Lecture 12: "Network Security" <a href="https://habr.com/company/ua-hosting/blog/426325/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/427087/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/427093/">Part 3</a> <br>  Lecture 13: "Network Protocols" <a href="https://habr.com/company/ua-hosting/blog/427763/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/427771/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/427779/">Part 3</a> <br>  Lecture 14: "SSL and HTTPS" <a href="https://habr.com/company/ua-hosting/blog/427783/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/427785/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/427787/">Part 3</a> <br>  Lecture 15: "Medical Software" <a href="https://habr.com/company/ua-hosting/blog/428652/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/428654/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/428656/">Part 3</a> <br>  Lecture 16: "Attacks through the side channel" <a href="https://habr.com/company/ua-hosting/blog/429390/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/429392/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/429394/">Part 3</a> <a name="habracut"></a><br><br>  <b>Audience:</b> Do you use the Karatsuba method? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Professor:</b> Yes, this is a clever multiplication method that does not require four stages of computation.  Is the Karatsuba method taught in the .601 course, or how is it designated today? <br><br>  <b>Audience:</b> 042. <br><br>  <b>Prof:</b> 042, excellent.  Yes, this is a very good method.  It is used by almost every cryptographic library.  For those of you who are not graduates of our institute - I say that, because we have graduate students here - I will write about the Karatsuba method on the blackboard.  Here you need to calculate three values: <br><br>  a <sub>1</sub> b <sub>1</sub> <br>  (a <sub>1</sub> - a <sub>0</sub> ) (b <sub>1</sub> - b <sub>0</sub> ) <br>  a <sub>0</sub> b <sub>0</sub> <br><br>  Thus, you make 3 multiplications instead of four, and it turns out that you can recover this value a <sub>1</sub> b <sub>0</sub> + a <sub>0</sub> b <sub>1</sub> of these three multiplication results. <br><br><img src="https://habrastorage.org/webt/sg/_m/od/sg_modaezv2yehkmftzlhpybti0.jpeg"><br><br>  The special way to do this is this ... let me write it in a different form. <br><br>  So, we will have: <br><br>  (2 <sup>64</sup> + 2 <sup>32</sup> ) (a <sub>1</sub> b <sub>1</sub> ) + <br>  (2 <sup>32</sup> ) (- (a <sub>1</sub> - a <sub>0</sub> ) (b <sub>1</sub> - b <sub>0</sub> ) <br>  (2 <sup>32</sup> + 1) (a <sub>0</sub> b <sub>0</sub> ) <br><br>  This is not very clear, but if you work through the details, then ultimately convince yourself that this value in these 3 lines is equivalent to the value of ab, but at the same time reduces the computation by one multiplication.  And the way we apply this to more voluminous multiplications is that you continue to go down recursively.  So, if you have 512 bit values, you can break them into 256-bit multiplication.  You do three 256-bit multiplications, recursively using Karatsuba's method each time.  In the end, your calculations are reduced to machine size and can be processed by a single machine instruction. <br><br><img src="https://habrastorage.org/webt/gv/7s/ae/gv7saezq-q5xj52fvxnjxenikgo.jpeg"><br><br>  So where is the timings attack here?  How do these guys use Karatsuba multiplication?  It turns out that OpenSSL is worried about two types of multiplication that you may have to do. <br>  The first is the multiplication of two large numbers of approximately the same size.  This happens many times when we perform modular exponentiation, because all the values ‚Äã‚Äãthat we multiply will be approximately 512 bits in size.  Therefore, when we multiply c by y or square it, we multiply two things of about the same size.  In this case, the Karatsuba method makes a lot of sense, because it reduces the size of the numbers squared by about 1.58 times, which greatly speeds up the calculation process. <br>  The second type of multiplication is when OpenSSL multiplies two numbers, the size of which differs significantly from each other: one is very large and the other is very small.  In this case, you could also use the Karatsuba method, but it will run slower than primitive multiplication.  Suppose you multiply a number of 512 bits by a 64-bit number, you will have to raise each bit of the first number to 64 degrees, and as a result you will get a 2n slowdown instead of acceleration n / 1.58.  Therefore, these guys using OpenSSL, tried to get smarter, and this is where the problems started. <br><br>  They decided that they would dynamically switch between the effective Karatsuba method and the primary school multiplication method.  Their heuristics were as follows.  If the two numbers that you multiply consist of the same number of machine words, or at least have the same number of bits as 32-bit units, then the Karatsuba method is used.  If two numbers are very different in size from each other, squaring or direct simple, normal multiplication is performed. <br><br>  In this case, you can track how the switch to another multiplication method.  Since the moment of switching does not pass without a trace, it will be noticeable after it, whether it takes much more time to multiply now or much less than before.  This circumstance was used by researchers to organize an attack using the method of determining timings. <br><br>  I think that I‚Äôve finished telling you about all the strange tricks that people use to put RSA into practice.  Now let's try to put them together and use against a whole web server to figure out how you can ‚Äúpinch‚Äù the bits of interest to us from the input network packet. <br><br>  If you remember from the HTTPS lecture, the web server has a secret key.  He uses this secret key to prove that he is the correct owner of all certificates via HTTPS or TLS.  This is due to the fact that the clients send some randomly selected bits, these bits are encrypted using the server's public key, and the server decrypts the message using the TLS protocol.  And if the message is verified, then these random bits are used to establish a communication session. <br><br>  But in our case this message will not be checked, because it will be created in a special way, and when it turns out that the additional bits do not match, the server will return an error as soon as it finishes decrypting our message. <br><br>  That's what we're going to do here.  The server - you can assume that it is Apache with SSL open - will receive a message from the client, which will count the encrypted text with or some hypothetical encrypted text that the client has created.  The first thing we do with ciphertext is decrypt it using the formula c ‚Üí (c <sup>d</sup> mod n) = m. <br><br>  If you remember the first optimization, we are going to apply the Chinese remainder theorem and divide our text into two parts: one to calculate mod p, the other mod q, and then combine the results.  First, we take c and present it in two quantities: the first is called c <sub>0</sub> , it will be equal to mod q, and the second we will denote c <sub>1</sub> , and it will be equal to c mod p.  Then we do the same to calculate c for d mod p and c for d mod q. <br><br><img src="https://habrastorage.org/webt/re/sp/qo/respqor_rehsunlfqjtc9lbmeok.jpeg"><br><br>  Next we are going to switch to the Montgomery representation, because this will make our multiplications very fast.  So the next thing SSL is going to do with your number is to calculate c <sub>0</sub> ', which will be equal to c <sub>0</sub> R mod q and do the same here, for c1, I will not record it because it looks the same . <br><br>  Now that we are in the form of Montgomery, we can finally produce our multiplications, and here we will use the ‚Äúsliding window‚Äù technique.  As soon as we get c <sub>0</sub> ', we will complete this simple construction of c <sub>0</sub> ' to the power d by mod q.  And here, since we calculate this value for d, we will use ‚Äúsliding windows‚Äù for the exponent bits d, and also apply the Karatsuba method or the usual multiplication depending on what the size of our operands is. <br><br><img src="https://habrastorage.org/webt/ah/oa/um/ahoaumcorgtkbkeuj6uxli1yv9i.jpeg"><br><br>  So, if it turns out that this value is c <sub>0</sub> 'and the previously obtained squaring result is the same size, we use the Karatsuba method.  If c <sub>0</sub> 'is very small and the previous result of multiplication is large, then we will square it and multiply it in the usual way.  Here we use "sliding windows" and the Karatsuba method instead of normal multiplication. <br><br><img src="https://habrastorage.org/webt/pk/xc/wl/pkxcwlnkl3fndnsc-nx3rqk1auo.jpeg"><br><br>  Also at this stage, additional reductions appear.  Because with each multiplication, the additional abbreviations will be proportional to what we are raising to the power modulo q, that is, to the value (c <sub>0</sub> ') <sup>d</sup> .  Here, with a simple connection of the formula, the probability of additional reductions will be proportional to the value of c <sub>0</sub> 'mod q divided by 2R.  It is in this place that a bit appears that affects timing. <br><br>  In fact, there are two possible effects: the use of the Karatsuba method instead of normal multiplication and the appearance of additional cuts that you are going to make. <br><br>  In a second you will see how it can be used.  Now, when you got this result for mod q and are going to get a similar result for mod p, you can finally recombine these two parts above and below and use the CRT, the Chinese theorem on residuals. <br><br>  And what you end up with from CRT ... sorry, I think we first need to convert it back from the Montgomery form.  Therefore, before recombination, we transform the upper part into the expression (c <sub>0</sub> ') <sup>d</sup> / R mod q and return our value cd mod q.  In the lower part, we respectively obtain cd mod p. <br><br>  You can now use CRT to get the value of c <sup>d</sup> mod n.  Sorry for the small font, I did not have enough boards.  Approximately the same thing we have here below for with <sub>1</sub> , and we can finally get our result, that is, the message m. <br><br><img src="https://habrastorage.org/webt/vw/md/4x/vwmd4xcq0kjbfpsvw29dyqtglnk.jpeg"><br><br>  Thus, the server takes an incoming packet, which receives it, runs it through the whole pipeline, runs the two parts of this pipeline, and ends with the decoded message m, equal to cd mod m.  Then he is going to check the padding padding of this message.  In the case of our specific attack, we created with in such a way that in fact this addition will not coincide.  We chose the value of c for such heuristics that do not encrypt the real message with the correct padding padding. <br><br>  Thus, the addition will not withstand the checks, the server will need to write an error, send an error message to the client and terminate the connection.  So, we are going to measure the time it takes the server to pass our message through this pipeline.  Have questions about the message processing process of the server and the integration of all these optimizations? <br><br>  <b>Audience:</b> in my opinion, there is an error with the index of the value of c. <br><br>  <b>Professor:</b> yes, you are right, I finish the index 0, here it should be c <sub>0</sub> <sup>d</sup> mod q. <br><br><img src="https://habrastorage.org/webt/zf/c8/eb/zfc8ebgspz9g347khmvzs1n-9hc.jpeg"><br><br>  <b>Audience:</b> when you divide by R mod q, aren't there any assumptions about how much q you should add to further reduce low bits by zeros? <br><br>  <b>Professor:</b> yes, you are right, at this final stage (c <sub>0</sub> ') <sup>d</sup> / R mod q there may be additional abbreviations.  So we need to do this division of R in the right way, and probably should do the same thing as when doing the Montgomery cut here when we divide by R to convert the value back.  Since at the beginning of the calculations it is not clear how much q we should add, we use the selection method, destroy low zeros, then do mod q again, and possibly an additional abbreviation.  You say absolutely true, in this case it is exactly the same division by R mod q as for each step of the Montgomery multiplication. <br><br>  So how to use it?  How can an attacker unravel the server's secret key by measuring the time of operations?  These guys have a plan that is based on guessing one bit of the private key at a time.  We can assume that the secret key is an encrypted exponent d, because you know e and you know n, it is a public key.  The only thing you do not know is d. <br><br><img src="https://habrastorage.org/webt/qw/pv/cg/qwpvcgujkfsub1kworr1vy2bmea.jpeg"><br><br>  In fact, in this attack they do not directly guess the value of d, since it is rather difficult.  Instead, they consider the value of q or p, no matter which of these two quantities.  As soon as you guess what value is p or q, you can calculate n = pq.  Then, if you know the values ‚Äã‚Äãof p and q, you can calculate the function œÜ, which we talked about earlier.  This will allow you to get the value of d from the value of e.  Therefore, this factorization of the n value is extremely important; it must be kept secret to ensure RSA security. <br><br>  So actually, these guys intended to guess the value of q, analyzing the timing of this pipeline.  What are they doing for this?  They carefully select the initial value of c and measure its passage through the server pipeline. <br><br>  In particular, there are two parts to this attack, and you must take some initial steps to guess the first few bits.  Then, as soon as you have the first few bits, you can guess the next bit.  So let me not tell in detail how they guess the first couple of bits, because it's actually much more interesting to see how they guess the next bit.  If we have time, we will return to how the guessing of several initial bits in a lecture article is described. <br><br>  So let's say that you have an assumption g about which bits are in the meaning of this q.  Let this quantity consist of such bits: g = g <sub>0</sub> g <sub>1</sub> g <sub>2</sub> ... and so on.  Rather, it is not even g, but the real bits of q, so let me rewrite it in this form: g = q <sub>0</sub> q <sub>1</sub> q <sub>2</sub> ....  We believe that these q - high bits, and we are trying to guess the bits lower and lower.  Suppose we know the value of q up to the qj bit, and then all the zeros follow.  You do not know what the other bits are. <br><br><img src="https://habrastorage.org/webt/8c/ca/df/8ccadfhe0orkn4jalptuhmm_c9a.jpeg"><br><br>  These guys tried to inject this guess g into this place of our pipeline: (c0 ') d mod q.  Because this is the place where two types of optimization are used: the Karatsuba method instead of the usual multiplication and a different number of additional reductions depending on the value of c <sub>0</sub> '.  Actually, they tried to introduce two different guesses to this place of the pipeline: the first one, which looks like g = q <sub>0</sub> q <sub>1</sub> q <sub>2</sub> ... qj 000 ... 0000 and the second, which they called g <sub>high</sub> , which consists of the same high bits, but instead of all zeros at the end there is a one that means a high bit, followed by zeros again: <br><br>  g = q <sub>0</sub> q <sub>1</sub> q <sub>2</sub> ... qj 100 ... 0000. <br><br>  How does this help these guys understand what's going on?  There are two ways to do this.  Suppose that our guess g is equal to the value of c <sub>0</sub> '.  We can assume that these g and g <sub>high</sub> correspond to the value c <sub>0</sub> 'given on the left board.  In fact, it is quite simple to do this, because c <sub>0</sub> 'is quite easily calculated the opposite way from the encrypted input value c <sub>0</sub> , you simply multiply it by R. <br><br><img src="https://habrastorage.org/webt/u9/5k/yp/u95kypmv569-dhhozaeqfpcwgjo.jpeg"><br><br>  Therefore, in order to guess the value (c <sub>0</sub> ') <sup>d</sup> , they simply need to take their guess, their guess g, and first divide it by R, that is, divide by 512 mod something there.  Then they are going to enter it back, the server will multiply it by R and continue the process given in our pipeline scheme. <br><br>  So, suppose we managed to put our particular selected integer value in the right place.  So, what is the computation time from c <sub>0</sub> 'to d mod q? <br><br><img src="https://habrastorage.org/webt/zy/b5/ud/zyb5udmf96e2cvwliab80lhusum.jpeg"><br><br>  There are two possible options where q fits into this picture.  It may be that q is between these two values ‚Äã‚Äãof g and g <sub>high</sub> , because the next bit q is 0. Thus, this value ‚Äî the first 0 after qj ‚Äî will be less than q, but this value ‚Äî 1 after q ‚Äî will be greater than q.  This happens if the next bit q is 0, or it is possible that q is above both of these values ‚Äã‚Äãif the next bit q is 1. <br><br><img src="https://habrastorage.org/webt/g5/uk/mn/g5ukmnfmvzp_rdlyhwtptj-8e4o.jpeg"><br><br>  Now we can tell what the decryption time of these two values ‚Äã‚Äãwill be if q lies between them, or if q is located above both of them. <br><br>  Let's consider the situation where q is located above.  In this case, everything is pretty much the same.  Since both these values ‚Äã‚Äãare less than q, then the value of these things mod q will be about the same.  They are somewhat different due to this extra bit, but still more or less the same size.  And the number of extra reductions will probably also not differ much, because it is proportional to the value of c0 'mod q.  And for both the values ‚Äã‚Äãof g and g <sub>high</sub> , smaller than q, they are all about the same.  Neither of them will exceed q and will not cause a large number of additional reductions, because when q is greater than both of these guesses, the number of calculations by the Karatsuba method relative to the number of ordinary calculations will remain the same.  In terms of this relationship, the server will handle both g and g <sub>high in the</sub> same way.  Therefore, the server is going to make about the same additional reductions for both of these values.  Thus, if you see that the server spends the same time to answer these guesses, then you should probably assume that, in the value of g <sub>high, there is</sub> indeed 1 in this place. <br><br><img src="https://habrastorage.org/webt/ui/d_/tg/uid_tglidwosbzxkquvonqfrzi0.jpeg"><br><br>  On the other hand, if q is located between these two values, then there are two possible things that can cause switching and changing timings.  One of the things is that since g <sub>high is</sub> slightly larger than q, the number of additional cuts will be proportional to c <sub>0</sub> 'mod q, which is very small, because c <sub>0</sub> ' is q plus some bits in this additional sequence of 100 bits ... 00  Thus, the number of additional reductions will be more noticeable and everything will start to happen faster. <br>  Another possible thing that can happen is that the server will probably decide: ‚Äúoh, now it‚Äôs time to do normal multiplication instead of Karatsub‚Äôs method!‚Äù.  Perhaps, for this value of g, the value of c <sub>0</sub> 'will have the same number of bits as q, and if it turns out that g <sub>high is</sub> greater than q, then g <sub>high</sub> mod q will potentially have less bits.  And if it crosses a certain border, the server will suddenly switch to normal multiplication.  In this case, we will observe the reverse process - everything will start to flow more slowly, because the usual multiplication takes more time than the multiplication of Karatsuba. <br><br>  The number of additional cuts is proportional to c <sub>0</sub> 'mod q.  If c <sub>0</sub> which is this g <sub>high</sub> value, is slightly larger than q, then this is a tiny difference that will not be comparable to the difference between g and q.  In this case, there will also be a change in timings, which you can try to measure.  So actually, there are a few interesting things here, when these effects actually work in different directions.  So, if you set a 32-bit switching boundary between Karatsuba‚Äôs method and normal multiplication, then decoding this message will take much longer. <br><br>  On the other hand, if the 32-bit border is not applied here, perhaps the effect of additional cuts will tell you what is happening here.  Thus, in fact, you should monitor the various effects.         32 ,   ,    -  .   ,     ,  32, , ,     ,      . <br><br> ,  ,     ,            .    ,     q  1,         ,     q  0,   ,    g <sub>high</sub>  q   ,      ,   . <br><br>          . ,      .          ,    .   ,     ,  1-2 .        , ,   Ethernet. <br>      ,   .      .   ,        7    . ,   , -,         ,        ? <br><br> <b>:</b>     ? <br><br> <b>:</b> ,        ,           ,               ,     ,   .   ,       . <br><br>        ,    ,           7 ,        ,            7 .     7   g,   7   g + 1,  g + 2   7      g + 400.      g,     g, , 7   400,    ? <br><br><img src="https://habrastorage.org/webt/oo/at/9h/ooat9hm2htm-wjoamvqlpfv1vac.jpeg"><br><br> <b>:</b> ,    ,   ? <br><br> : ,     ,   ,        ‚Äî (c <sub>0</sub> ') <sup>d</sup> .      . ,  ,   ,     mod p.    ,           ,     .  ,         g,  1, 2, 3,  ,    . <br><br>       ,     ,          ‚Äì    100‚Ä¶00.  ,        mod p,    ,      mod p       .       ¬´ ¬ª,     ,        (c <sub>0</sub> ') <sup>d</sup> ,    .  It's clear? <br><br> <b>:</b>   ,     ? <br><br> <b>:</b>      -   ,       q. ,        q,   ,     ,     . <br><br> <b>:</b>    c <sub>0</sub> '? <br><br> <b>:</b>     c <sub>0</sub> ',     c,     c <sub>0</sub> '      R  mod n. <br><br><img src="https://habrastorage.org/webt/br/j9/xp/brj9xpzlbunothk8hhovxqsxcz8.jpeg"><br><br>      ,  ¬´¬ª  ,     c <sub>0</sub> =  mod q,       c <sub>0</sub> = ((c <sub>0</sub> ' R <sup>-1</sup> ) mod n) mod q.      R,     R.           c <sub>0</sub> ',     (c <sub>0</sub> ') <sup>d</sup> mod q.  ,     ,   ,  ,       R.   ,  R = 2 <sup>512</sup> .  ,    . <br><br> <b>:</b>            mod p    ? <br><br> <b>:</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is, you do not know what p is, but you want to define it at random? </font><font style="vertical-align: inherit;">If you succeed, you will do a great job! </font><font style="vertical-align: inherit;">Well, next week we will begin to discuss other issues.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3v5Von-oNUg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Full version of the course is available <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/">here</a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps until December for free</b> if you pay for a period of six months, you can order <a href="https://ua-hosting.company/vpsnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/429394/">https://habr.com/ru/post/429394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429384/index.html">Components of electric bike: motor</a></li>
<li><a href="../429386/index.html">Provider AT & T has become the largest copyright holder and will begin to disconnect users accused of piracy</a></li>
<li><a href="../429388/index.html">How to make a redesign of the site and not to make problems: 4 important steps</a></li>
<li><a href="../429390/index.html">MIT course "Computer Systems Security". Lecture 16: "Attacks through the side channel", part 1</a></li>
<li><a href="../429392/index.html">MIT course "Computer Systems Security". Lecture 16: "Attacks through the side channel", part 2</a></li>
<li><a href="../429396/index.html">How to test an application when interacting with an API using SoapUI</a></li>
<li><a href="../429400/index.html">Seals vs neural network 2. Or run SqueezeNet v.1.1 on Raspberry Zero in realtime (almost)</a></li>
<li><a href="../429402/index.html">ML.NET 0.7 (Machine Learning .NET)</a></li>
<li><a href="../429404/index.html">8 s ¬Ω ways to prioritize functionality</a></li>
<li><a href="../429406/index.html">"Monsters in games or how to create fear"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>