<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we doubled the speed of working with Float in Mono</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My friend Aras recently wrote the same ray tracer in different languages, including C ++, C # and the Unity Burst compiler. Of course, it is natural t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we doubled the speed of working with Float in Mono</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/c69/c73/49ac69c73ac3a6c124f04b468dfb90d5.png"></div><br>  My friend Aras <a href="https://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-3-CSharp-Unity-Burst/">recently wrote</a> the same ray tracer in different languages, including C ++, C # and the Unity Burst compiler.  Of course, it is natural to expect that C # will be slower than C ++, but it seemed to me interesting that Mono is so slower than .NET Core. <br><br>  The <a href="">figures</a> he published were bad: <br><br><ul><li>  C # (.NET Core): Mac 17.5 Mray / s, </li><li>  C # (Unity, Mono): Mac 4.6 Mray / s, </li><li>  C # (Unity, IL2CPP): Mac 17.1 Mray / s </li></ul><br>  I decided to see what was happening and document the areas that could be improved. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a result of this benchmark and the study of this problem, we found three areas in which improvement is possible: <br><br><ul><li>  First, you need to improve the default Mono settings, because users usually do not configure settings on their own. </li><li>  Secondly, we need to more actively acquaint the world with the backend of optimizing the LLVM code in Mono </li><li>  Thirdly, we improved the setting of some Mono parameters. </li></ul><br>  The reference point of this test was the results of the <a href="https://github.com/aras-p/ToyPathTracer">ray tracer</a> run on my machine, and since I have another iron, we cannot compare the numbers. <br><br>  The results on my home iMac for Mono and .NET Core were as follows: <br><br><table><thead><tr><th>  Workspace </th><th>  Results, MRay / sec </th></tr></thead><tbody><tr><td> .NET Core 2.1.4, <code>dotnet run</code> debug build </td><td>  3.6 </td></tr><tr><td>  .NET Core 2.1.4, <code>dotnet run -c Release</code> build </td><td>  21.7 </td></tr><tr><td>  Vanilla Mono, <code>mono Maths.exe</code> </td><td>  6.6 </td></tr><tr><td>  Vanilla Mono with LLVM and float32 </td><td>  15.5 </td></tr></tbody></table><a name="habracut"></a><br>  In the process of studying this problem, we found a couple of problems, after correcting which the following results were obtained: <br><br><table><thead><tr><th>  Workspace </th><th>  Results, MRay / sec </th></tr></thead><tbody><tr><td>  Mono with LLVM and float32 </td><td>  15.5 </td></tr><tr><td>  Enhanced Mono with LLVM, float32 and fixed inline </td><td>  29.6 </td></tr></tbody></table><br>  Overall picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/407/ecf/385/407ecf385de6261087b4395928076e02.png"></div><br>  By simply using LLVM and float32, you can increase the performance of the floating point code almost 2.3 times.  And after tuning, which we added to Mono as a result of these experiments, it is possible to increase productivity by 4.4 times in comparison with standard Mono - these parameters in future versions of Mono will become the default parameters. <br><br>  In this article I will explain our findings. <br><br><h2>  32-bit and 64-bit float </h2><br>  Aras uses 32-bit floating-point numbers for the main part of the computation (type <code>float</code> in C # or <code>System.Single</code> in .NET).  In Mono, we made a mistake long ago - all 32-bit floating-point calculations were performed as 64-bit, and the data was still stored in 32-bit areas. <br><br>  Today, my memory is not as sharp as before, and I can‚Äôt remember exactly why we made this decision. <br><br>  I can only assume that the trends and ideas of that time influenced him. <br><br>  Then around the float-calculations with increased accuracy soared a positive aura.  For example, in Intel x87 processors, 80-bit precision was used for floating-point calculations, even when the operands were double, which provided users with more accurate results. <br><br>  At that time, the idea that in one of my previous projects - Gnumeric spreadsheets - statistical functions were implemented more qualitatively than in Excel was also relevant.  Therefore, many communities are well aware of the idea that more accurate results can be used with increased accuracy. <br><br>  At the initial stages of Mono development, most of the mathematical operations performed on all platforms could receive only double at the input.  32-bit versions were added to C99, Posix and ISO, but in those days they were not widely available for the entire industry (for example, <code>sinf</code> is a float version of <code>sin</code> , <code>fabsf</code> is a version of <code>fabs</code> , and so on). <br><br>  In short, the beginning of the 2000s was a time of optimism. <br><br>  Applications paid a large price to increase computational time, but Mono was mainly used for Linux desktop applications serving HTTP pages and some server processes, so the speed of floating point calculations was not a problem that we encountered daily.  It became visible only in some scientific benchmarks, and in 2003 they were rarely developed on .NET. <br><br>  Today, games, 3D applications, image processing, VR, AR, and machine learning have made floating point operations a more common data type.  The trouble does not come alone, and there are no exceptions.  Float was no longer a friendly data type that was used in the code just in a couple of places.  They turned into an avalanche, from which no one can hide.  There are a lot of them and their distribution cannot be stopped. <br><br><h2>  Workspace float32 flag </h2><br>  Therefore, a couple of years ago we decided to add support for performing 32-bit float operations using 32-bit operations, as in all other cases.  We called this environment feature "float32".  In Mono, it is enabled by adding the option <code>--O=float32</code> in the working environment, and in Xamarin applications this parameter is changed in the project settings. <br><br>  This new flag was well received by our mobile users, because mostly mobile devices are still not very powerful, and they prefer to process data faster than to have increased accuracy.  We recommended that mobile users simultaneously enable the LLVM optimizing compiler and the float32 flag. <br><br>  Although this flag has been implemented for several years, we have not made it the default to avoid unpleasant surprises for users.  However, we started to encounter cases in which surprises arise due to standard 64-bit behavior, see this <a href="https://github.com/mono/mono/issues/7522">bug report sent by a Unity user</a> . <br><br>  Now we will use Mono <code>float32</code> , progress can be tracked here: <a href="https://github.com/mono/mono/issues/6985">https://github.com/mono/mono/issues/6985</a> . <br><br>  In the meantime, I returned to the project of my friend Aras.  He used new APIs that were added to .NET Core.  Although .NET Core always performed 32-bit float operations as 32-bit float, during its operation, the <code>System.Math</code> API still performs conversions from <code>float</code> to <code>double</code> .  For example, if you need to calculate the sine function for a float value, then the only option is to call <code>Math.Sin (double)</code> , and you will have to perform a conversion from float to double. <br><br>  To fix this, a new type of <code>System.MathF</code> was added to the .NET Core, which contains single-precision floating point math operations, and now we have just transferred this <code>[System.MathF]</code> <a href="https://github.com/mono/mono/pull/7941">to Mono</a> . <br><br>  The transition from 64-bit to 32-bit float significantly improves performance, which can be seen from this table: <br><br><table><thead><tr><th>  <strong>Work environment and options</strong> </th><th>  Mrays / second </th></tr></thead><tbody><tr><td>  Mono with System.Math </td><td>  6.6 </td></tr><tr><td>  Mono with System.Math and <code>-O=float32</code> </td><td>  8.1 </td></tr><tr><td>  Mono with System.MathF </td><td>  6.5 </td></tr><tr><td>  Mono with System.MathF and <code>-O=float32</code> </td><td>  8.2 </td></tr></tbody></table><br>  That is, the use of <code>float32</code> in this test actually improves performance, and MathF has little effect. <br><br><h1>  LLVM setup </h1><br>  In the course of this study, we found that although there is <code>float32</code> support in the Fast JIT Mono <code>float32</code> , we did not add this support to the LLVM backend.  This meant that Mono with LLVM was still performing costly conversions from float to double. <br><br>  Therefore, Zoltan added <code>float32</code> support to the LLVM code generation engine. <br><br>  Then he noticed that our code inline (inliner) uses the same heuristics for Fast JIT that were used for LLVM.  When working with Fast JIT, it is necessary to maintain a balance between JIT speed and execution speed, so we limited the amount of embedded code to reduce the workload of the JIT engine. <br><br>  But if you decide to use Mono LLVM, then you strive for the code as quickly as possible, so we changed the settings accordingly.  Today, this parameter can be changed using the <code>MONO_INLINELIMIT</code> environment <code>MONO_INLINELIMIT</code> , but in fact it needs to be written to its default values. <br><br>  Here are the results with the modified LLVM settings: <br><br><table><thead><tr><th>  Work environment and options </th><th>  Mrays / seconds </th></tr></thead><tbody><tr><td>  Mono with System.Math <code>--llvm -O=float32</code> </td><td>  16.0 </td></tr><tr><td>  Mono with System.Math <code>--llvm -O=float32</code> , persistent heuristics </td><td>  29.1 </td></tr><tr><td>  Mono with System.MathF <code>--llvm -O=float32</code> , persistent heuristics </td><td>  29.6 </td></tr></tbody></table><br><h1>  Next steps </h1><br>  To make all these improvements was enough minor effort.  These changes led to periodic discussions in Slack.  I even managed to carve out a few hours one evening to transfer the <code>System.MathF</code> to Mono. <br><br>  The ray tracer code Aras became an ideal object for study, because it was self-contained, was a real application, and not a synthetic benchmark.  We want to find other similar software that can be used to study the binary code we generate, and make sure that we are transmitting the best data to LLVM in order to perform its work optimally. <br><br>  We are also thinking about updating the LLVM used by us, and using new added optimizations. <br><br><h1>  Separate note </h1><br>  Extra accuracy has nice side effects.  For example, reading the Godot engine pull requests, I saw that there was an active discussion about whether the precision of floating-point operations was customizable at compile time ( <a href="https://github.com/godotengine/godot/pull/17134">https://github.com/godotengine/godot/pull/17134</a> ). <br><br>  I asked Juan why anyone would need this, because I thought that 32-bit floating point operations were enough for the games. <br><br>  Juan explained that, in general, float works great, but if you ‚Äúmove away‚Äù from the center, say, move 100 kilometers from the center of the game, a calculation error begins to accumulate, which can lead to interesting graphic glitches.  You can use different strategies to reduce the impact of this problem, and one of them is working with increased accuracy, for which you have to pay with performance. <br><br>  Shortly after our conversation in my Twitter feed, I saw a post demonstrating this problem: <a href="http://pharr.org/matt/blog/2018/03/02/rendering-in-camera-space.html">http://pharr.org/matt/blog/2018/03/02/rendering-in-camera-space.html</a> <br><br>  <em>The problem is shown in the images below.</em>  <em>Here we see a model of a sports car from the</em> <a href="http://pbrt.org/scenes-v3.html"><em>pbrt-v3-scenes</em></a> ** <em>package</em> <em>.</em>  <em>Both the camera and the scene are near the origin point, and everything looks great.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f1/702/725/4f1702725634faa3ba94aa930230fb6d.png"></div><br>  ** <em>(The author of the model car</em> <a href="http://twitter.com/MirageYM"><em>Yasutoshi Mori</em></a> <em>.)</em> <br><br>  Then we move the camera and the scene 200,000 units in xx, yy and zz from the origin point.  It can be seen that the model of the car has become rather fragmentary;  this is solely due to the lack of precision of floating-point numbers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/4b0/658/8424b065878f52bcd83b5d2de19321e5.png"></div><br>  <em>If we move further 5 √ó 5 √ó 5 times, 1 million units from the origin point, the model begins to decay;</em>  <em>the machine turns into an extremely coarse voxel approximation of itself, both interesting and terrifying.</em>  <em>(Keanu asked the question: is Minecraft so cubic simply because everything is rendered very far from the origin of the coordinates?)</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/c69/c73/49ac69c73ac3a6c124f04b468dfb90d5.png"></div><br>  ** <em>(I apologize to</em> <a href="http://twitter.com/MirageYM"><em>Yasutoshi Mori</em></a> <em>for what we did with his beautiful model.)</em> </div><p>Source: <a href="https://habr.com/ru/post/432176/">https://habr.com/ru/post/432176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432166/index.html">Apache NiFi: what it is and a brief overview of the features</a></li>
<li><a href="../432168/index.html">Chinese authorities are collecting information from electric vehicles of citizens of the country</a></li>
<li><a href="../432170/index.html">Carry data center in 14,400 seconds</a></li>
<li><a href="../432172/index.html">Dangerous invitation, or How does the combat load to a phishing email</a></li>
<li><a href="../432174/index.html">How to competently and effectively develop a software product</a></li>
<li><a href="../432178/index.html">... and a guarantee for projectors - enlarge</a></li>
<li><a href="../432180/index.html">How to pump your career through GitHub</a></li>
<li><a href="../432182/index.html">We take away mail without sms and registration</a></li>
<li><a href="../432184/index.html">Problem personalities among testers</a></li>
<li><a href="../432186/index.html">Using STP to create p2p channels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>