<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>USB support in KolibriOS: what's inside? Part 1: general scheme</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The USB architecture contains several levels. At the lowest level, a specially trained hardware, called the host controller , communicates with the US...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>USB support in KolibriOS: what's inside? Part 1: general scheme</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/882/61a/ae8/88261aae82f0dfcb06d32f7bfd94c4c6.png" align="left">  The USB architecture contains several levels.  At the lowest level, a specially trained hardware, called the <i>host controller</i> , communicates with the USB device with special signals.  Signals encode bits, bits add up into packets, packets form <i>transactions</i> , transactions make up <i>transfers</i> . <br><br>  I‚Äôm talking about USB software support, so the levels below are <i>almost</i> uninteresting: the host controller is responsible for them.  But it is important which interface represents the host controller software.  Three interfaces are now distributed, and the fourth is gradually spreading: <br><table><tbody><tr><th>  Abbr. </th><th>  Interface name </th><th>  Version </th><th>  Code support controller in KolibriOS </th></tr><tr><td>  Uhci </td><td>  Universal Host Controller Interface </td><td>  USB 1.1 </td><td>  <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fuhci.inc">kernel / trunk / bus / usb / uhci.inc</a> </td></tr><tr><td>  OHCI </td><td>  Open Host Controller Interface </td><td>  USB 1.1 </td><td>  <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fohci.inc">kernel / trunk / bus / usb / ohci.inc</a> </td></tr><tr><td>  EHCI </td><td>  Enhanced Host Controller Interface </td><td>  USB 2.0 </td><td>  <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fehci.inc">kernel / trunk / bus / usb / ehci.inc</a> </td></tr><tr><td>  Xhci </td><td>  eXtensible Host Controller Interface (new) </td><td>  USB 3.0 </td><td>  Not supported in KolibriOS </td></tr></tbody></table>  At the same level of interaction with controllers, there are files <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fhccommon.inc">kernel / trunk / bus / usb / hccommon.inc</a> , where some functions common to all controllers are implemented, and <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Finit.inc">kernel / trunk / bus / usb / init.inc</a> , which starts the whole subsystem.  However, do not rush into the code yet - firstly, I haven‚Äôt told yet what higher levels are expected of it, and secondly, after showing the general scheme, I will return to the individual components with details. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/ab5/093/0fd/ab50930fde89b3a78a05dce85352696d.png" align="right"><br><h3>  Some theory </h3><br>  From a software point of view, any USB device is a set of endpoints to which you can open pipes and organize <i>transfers of</i> various types.  Each endpoint has its own number, from 0 to 15. Two endpoints can have one number only if they are both unidirectional, one of which is intended for transmissions from host to device, and the other in the opposite direction. <br><br>  Depending on the type of gear being processed, there are four types of end points. <br><br clear="right"><ul><li>  <i>Management transfers (control transfers)</i> are small (as a rule) transfers used for configuration, control commands and status requests.  The only type of bidirectional exchange: here information is transmitted from the host to the device, and from the device to the host.  The control transmission consists of three stages ( <i>stages</i> ), one of which may be absent: <br><ol><li>  <b>The setup stage</b> transmits 8 bytes of the prescribed format information from the host to the device.  These bytes include the direction and length of the data.  The general format and standard queries are described in the main USB specification, and later I will talk about some of them. </li><li>  <b>The data stage</b> (absent if the data length is zero) transmits the data in the direction specified in the previous step. </li><li>  <b>The status stage</b> transmits in the opposite direction a sign of success. </li></ol><br>  Any USB device must have a control endpoint number 0: with its help, the USB infrastructure recognizes general information about the device (including ‚Äúwhich driver to load‚Äù) and performs the initial setup.  Almost all (if not all) devices lack a single control endpoint, which may also handle device-specific requests. </li><li>  <i>Transfers of data arrays (bulk transfers)</i> .  The main ‚Äúworkhorse‚Äù, when there is a lot of data, and it is important that they reach without distortion, but it doesn‚Äôt matter how much time it takes, flash drives, printers, etc.  For example, a typical USB flash drive has three endpoints ‚Äî a mandatory zero control and two for transmitting data in two directions. </li><li>  <i>Interrupt transfers (interrupt transfers)</i> .  They are used when there is little data, but it is important that they are processed within a certain time - mice, keyboards.  For example, a typical mouse has two endpoints - a mandatory zero control and one type of interrupt with the requirement to poll every 10 milliseconds (more often);  the required interval is a property of the end point, it can vary. </li><li>  <i>Isochronous transfers (isochronous transfers)</i> .  The only type that does not guarantee data delivery.  It is used when there is a lot of data, and it is important that they are processed within a certain time, but data loss is allowed - multimedia: webcams, USB-speakers. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/fb3/937/9c4/fb39379c46ad2c84e8e99eda5f4c7526.gif" align="right"><br>  USB bus time is measured in <i>frames</i> or <i>microframes</i> .  Frames appeared in USB1, one frame - one millisecond.  Microframes appeared in USB2, in one frame 8 microframes.  The USB infrastructure plans interrupt and isochronous transfers to specific (micro) frames so as to guarantee the requested time interval between transfers.  Planning has no right to use more than 90% of the frame or more than 80% of the microframe.  The remaining time (at least 10% / 20%, although it may be more, if not all the time is planned) is occupied by active control transmissions and, by residual, transmission of data arrays. <br><br clear="right"><h3>  Channel Support Level </h3><br>  The file <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fpipe.inc">kernel / trunk / bus / usb / pipe.inc</a> contains the implementation of channel handling functions.  Enough detailed documentation is in <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fdocs%252Fusbapi.txt">kernel / trunk / docs / usbapi.txt</a> .  Now 4 functions are implemented.  The first two of them are: <br><ul><li> The function of opening the channel <b>USBOpenPipe</b> , in the source code called <code>usb_open_pipe</code> .  It takes as input a previously opened channel, from which it copies the characteristics of the device, including its position on the USB bus, and the characteristics of the new channel, and returns the handle of the new channel, or zero on error.  So far it does not matter what the handle is. </li><li>  The function of closing the channel <b>USBClosePipe</b> , in the source code called <code>usb_close_pipe</code> .  Its purpose and sole parameter are fairly obvious. </li></ul><br>  The channel support level also handles a device shutdown event, closing all channels associated with the device.  So explicitly closing the channel is optional.  The attentive reader may be indignant here: ‚ÄúSo, the channel may suddenly close by itself?‚Äù But you should not worry - the device disconnect event, in addition to processing at the current level, is also broadcast ‚Äúupward‚Äù.  The channel is finally closed only after everyone has a chance to handle the device disconnect event.  More precisely, the channel handle can be used at least up to the moment when the handlers ‚Äúfrom above‚Äù finish their work.  The handler in the driver is described in the documentation as DeviceDisconnected, although the real name can be any ‚Äî the driver provides a pointer to this function. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before introducing the following two functions, I should note the following.  Each channel has its own transmission <i>queue</i> .  In the same queue can be several transmissions at the same time, but only one of them can be active - the one that is in the head of the queue.  The next transfer will begin only after the active transfer is fully successful.  If any transfer fails, the queue will stop.  Why do I need a queue?  For efficiency: software processing of the completed transfer may take some time, the host controller may well not wait for the handler's reaction, and in the meantime, proceed further.  Queues of different channels are independent, transmissions for different channels are performed in parallel. <br><ul><li>  The <b>USBNormalTransferAsync</b> data transfer function, called <code>usb_normal_transfer_async</code> in the source code, serves two types of transfers at once: the transfer of data arrays and the transmission by interrupt.  For both types, you need to know the data itself for transmission in the form of a pointer + length, a channel in the form of a handle returned by <b>USBOpenPipe</b> , and some flags;  so far, only one flag has been defined that allows or denies short transmissions in the direction from the device to the host.  The direction itself is not necessary to specify: it is uniquely determined at the time of opening the channel.  The ‚ÄúAsync‚Äù suffix indicates that the function only puts the transmission into a queue and then returns immediately;  when the transfer is completed - completed successfully, unsuccessfully or canceled altogether due to the device being disconnected - the callback function will be called, the pointer to which is also passed by one of the <b>USBNormalTransferAsync</b> arguments.  In order for the callback function to pass any additional information, an arbitrary parameter is passed along with the pointer to the function, which will be passed unchanged. </li><li>  The control transfer function <b>USBControlTransferAsync</b> , in the source code, called <code>usb_control_async</code> .  The interface is identical to the previous function with the addition of one parameter - a pointer to 8 bytes for the setup stage.  The direction is still not needed, but for a different reason: it is extracted from the data for the setup stage.  Strictly speaking, the length of the data could also be omitted for the same reason, but it is left for the unification of the interface. </li></ul><br>  The attentive reader, no doubt, noticed a lack of functions.  I'm working on it. <br>  The channel support level also includes the file <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fscheduler.inc">kernel / trunk / bus / usb / scheduler.inc</a> ;  he is responsible for scheduling gears that are time sensitive. <br><br><h3>  Logic level </h3><br>  In the theory summary, I have already said that any USB device must have a zero control endpoint, through which the infrastructure polls the device and performs the initial configuration.  The file <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fprotocol.inc">kernel / trunk / bus / usb / protocol.inc</a> is exactly what it does, based on the level of support for the channels.  The result of this level: a loaded device driver that received a call to the function described in the documentation as <b>AddDevice</b> .  Then everything is in the hands of the driver.  The first argument to the <b>AddDevice</b> function is the handle of the channel open to the null endpoint.  Using it, the driver can open the additional channels needed by him, as well as make additional tuning through the zero end point.  The return value of <b>AddDevice</b> ‚Äî either zero on error, or an abstract parameter that the USB infrastructure does not interpret, except for a comparison with zero ‚Äî stores it inside the device information and then passes it to the <b>DeviceDisconnected</b> function, which I already <b>mentioned</b> . <br>  To describe the two remaining parameters of the <b>AddDevice</b> function <b>,</b> I will need a little more theory. <br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/96e/f10/12a/96ef1012aa0f32506a0546aed52eb124.jpg" alt="2 * PS / 2 adapter - &amp; gt;  USB"><br>  A single physical device can provide multiple <i>interfaces</i> that can be programmed to one degree or another independently.  In particular, each interface has its own set of endpoints.  A good example is the numerous PS / 2 to USB adapters that provide two inputs for mouse and keyboard;  This USB device provides two unlinked interfaces.  A less obvious, but more common example: USB-keyboards with special buttons are often presented as two independent interfaces, one is a keyboard with standard buttons, the other is additional buttons. <br>  A USB device is required to support a request for various <i>descriptors</i> , in particular, a <i>configuration descriptor</i> .  In response to a request for a configuration descriptor, the device also returns a lot of related information, including descriptors for all interfaces and all endpoints associated with the interface.  The endpoint descriptor contains all the information necessary to open a channel to it. <br>  The second argument to the <b>AddDevice</b> function is a pointer to the data associated with the configuration descriptor, starting with the configuration descriptor itself;  one of its fields is the total data length.  The third argument to the <b>AddDevice</b> function is a pointer to an interface handle for which the driver is responsible. <br>  If a device implements multiple interfaces, then the logic device level will trigger the driver ‚Äî or several drivers ‚Äî several times.  The responsibility of one <b>AddDevice</b> call extends from the interface descriptor that was transferred to it, to the next interface descriptor, or to the end of the data;  On this interval are descriptors of all end points of this interface. <br><br><h3>  Device drivers </h3><br>  This is the highest level in USB architecture.  Device drivers use the API level support channels and information collected by the level of the logic device to support the desired functionality, depending on the device itself. <br>  Among the drivers, the hub driver <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fhub.inc">kernel / trunk / bus / usb / hub.inc stands</a> out because in some aspects it is close to the support level of the host controller and is an integral part of the USB infrastructure.  The USB specification allocates the part of the host controller responsible for controlling USB ports to the <i>root hub</i> in a special entity;  The root hub is related to the individual hubs interface for other levels, but they are fundamentally different in terms of programming. <br>  Hub support code interface: when a device is connected, the code informs the host device support code of the new device;  when the device is disconnected, the code transmits information about this level of channel support;  for the logic device level, the code provides the <b>AddDevice</b> + <b>DeviceDisconnected functions</b> , which in the source text are called <code>usb_hub_init</code> and <code>usb_hub_disconnect</code> respectively, as well as the function of blocking the port to which the new device is connected. <br>  Mice and keyboards are supported by the <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fdrivers%252Fusbhid.asm">kernel / trunk / drivers / usbhid.asm driver</a> .  The flash driver is supported by the <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fdrivers%252Fusbstor.asm">kernel / trunk / drivers / usbstor.asm driver</a> . <br><br><h3>  Host Controllers Support Code Interface </h3><br>  Finally, I am ready to explain the entire interface provided by the host controllers support code to other levels.  When a new device is connected, the <code>usb_new_device</code> function of the <code>usb_new_device</code> level is called.  Here I should note the following: <code>usb_new_device</code> will try to open the channel to zero point.  But the channel open function requires an already open channel, from where it copies the characteristics of the device.  For this to work, the host controller level creates a pseudo-channel, in the structure of which it fills only the fields with the characteristics of the device.  Opening a channel to the zero point will create a fully-fledged channel.  When the host controller has reconciled itself with the thought of the disappearance of the channel, the function <code>usb_pipe_closed</code> the channel support level is called.  In addition, the logic level during the initial setup changes the channel parameters;  when the host controller confirms that the changes are accepted, one of the <code>usb_after_set_address</code> and <code>usb_after_set_endpoint_size</code> level <code>usb_after_set_endpoint_size</code> the logical unit is called.  In more detail about why this is needed, I will describe in the framework of the analysis of the level of the logic device. <br><br>  Functions specific to a particular host controller and called from another code are assembled into the <code>usb_hardware_func</code> structure from <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fhccommon.inc">hccommon.inc</a> .  It includes: <br><ul><li>  Functions for working with the hardware of channels and queues used by the level of support for channels. </li><li>  Functions for obtaining and changing the device address on the bus, as well as the size of the channel packet used by the level of the logic device. </li><li>  Functions for working with USB ports: blocking, reset, used by the level of the logic device. </li><li>  A function that prepares parameters for <code>usb_new_device</code> and calls <code>usb_new_device</code> .  It is called from two places: from the inside of the same level and from the hub support code. </li><li>  A couple of functions for the controller-non-specific part of the same level. </li></ul><br><h3>  All articles of the series </h3><br>  Part 1: general scheme <br>  <a href="http://habrahabr.ru/company/kolibrios/blog/183184/">Part 2: Basics of working with host controllers</a> <br>  <a href="http://habrahabr.ru/company/kolibrios/blog/183284/">Part 3: Host Controller Support Code</a> <br>  <a href="http://habrahabr.ru/company/kolibrios/blog/186276/">Part 4: Channel Support Level</a> <br>  <a href="http://habrahabr.ru/company/kolibrios/blog/200172/">Part 5: logic level</a> <br>  <a href="http://habrahabr.ru/company/kolibrios/blog/203918/">Part 6: hub driver</a> <br><br>  PS If someone else does not know: we collect some money on Kickstarter to spend your Summer of Code.  So far, 65% has been collected, and the fundraising ends May 31 (tomorrow).  Article: <a href="http://habrahabr.ru/post/180197/">habrahabr.ru/post/180197</a> </div><p>Source: <a href="https://habr.com/ru/post/181586/">https://habr.com/ru/post/181586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181570/index.html">Ubuntu bug number 1 fixed</a></li>
<li><a href="../181572/index.html">What is common between Prince Igor and TCP / IP?</a></li>
<li><a href="../181578/index.html">Odessa Innovation Week</a></li>
<li><a href="../181580/index.html">About color spaces</a></li>
<li><a href="../181584/index.html">Atomic commit mechanism in SQLite</a></li>
<li><a href="../181588/index.html">Do I need undocumented APIs?</a></li>
<li><a href="../181592/index.html">Login to the site under someone else's account without having a password</a></li>
<li><a href="../181594/index.html">Communication experience with CyanogenMod 10.1</a></li>
<li><a href="../181596/index.html">CheckiNumber.ru: another result of code therapy</a></li>
<li><a href="../181598/index.html">XBMC 12.3 DSPlayer + SmoothVideo Project = dreams come true</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>