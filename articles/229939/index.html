<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make friends with a hedgehog and a man: the experience of using PowerShell in web applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article does not pretend to be a full PowerShell programming guide or step-by-step instructions for developing high-loaded .NET services. But it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make friends with a hedgehog and a man: the experience of using PowerShell in web applications</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/745/2ed/6e9/7452ed6e93c49e0d22ae1ef7ecd054ca.jpg" alt="image" align="left">  This article does not pretend to be a full PowerShell programming guide or step-by-step instructions for developing high-loaded .NET services.  But it contains useful techniques and an explanation of some features of PowerShell integration with .NET, which are still difficult or even impossible to find on the Web. <br><a name="habracut"></a><br>  It should be noted right away: PowerShell versions 1.0 and 2.0 is not a .NET programming language.  The <abbr title="Extended type system">ETS</abbr> PowerShell version 3.0 type system is already based on .NET, i.e.  PSObject is a dynamic <abbr title="Dynamic Language Runtime">DLR</abbr> object.  Since these and other innovations of PowerShell 3 are not fundamental for the main topic of the article, I will consider PowerShell version 2.0.  When not specified explicitly, under PowerShell is meant exactly version 2.0. <br><br>  Terms: <br><ul><li>  <b>Cmdlet</b> - PowerShell Team </li><li>  <b>Runspace</b> - .NET class object representing the PowerShell runtime of objects </li><li>  <b>Snap-In</b> - build .NET with a set of cmdlets, extending the PowerShell with new functionality </li></ul><br>  Our product PA (Parallels Automation) has a web application for activating and managing various services from cloud service providers such as Microsoft Exchange, IIS, SharePoint and others.  To manage most of its services, for example, the Exchange server, Microsoft provides a set of PowerShell cmdlets, so it was decided to write all of our PowerShell scripts.  Our web service written in .NET is essentially a driver that provides a low-level infrastructure for running scripts and implements the processing of network requests via <abbr title="Simple object access protocol">SOAP</abbr> , transactionality, logging, and so on.  When using PowerShell in many cases, you can make changes to the application logic ‚Äúon the fly‚Äù and avoid rebuilding the entire application, which is convenient for both developers and support services. <br><br>  Today we will talk about the following: <br><ol><li>  Configuring PowerShell settings for running scripts from .NET applications, specifying how to search for PS modules (PowerShell modules) used by the script, as well as error handling </li><li>  Remote and local script launches from .NET and passing parameters to PowerShell </li><li>  Ways to reduce memory used by Runspace objects </li></ol><br><h4>  Common Problems Integrating .NET with PowerShell </h4><br><h5>  Permission to run PowerShell scripts </h5><br>  By default, remote execution of PowerShell scripts is prohibited.  Execution policy must be set to RemoteSigned or Unrestricted (not recommended for security reasons).  What can be done with the following command: <br><pre><code class="dos hljs"><span class="hljs-function"><span class="hljs-function">C:\</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Users</span></span></span><span class="hljs-function">\</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user</span></span></span><span class="hljs-function">&gt; "%</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SystemRoot</span></span></span><span class="hljs-function">%\</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">system32</span></span></span><span class="hljs-function">\</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WindowsPowerShell</span></span></span><span class="hljs-function">\</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v1</span></span></span><span class="hljs-function">.0\</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PowerShell.exe</span></span></span><span class="hljs-function">" -</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NoLogo</span></span></span><span class="hljs-function"> -</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NoProfile</span></span></span><span class="hljs-function"> -</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NonInteractive</span></span></span><span class="hljs-function"> -</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inputformat</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">none</span></span></span><span class="hljs-function"> -</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Command</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutionPolicy</span></span></span><span class="hljs-function"> -</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutionPolicy</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoteSigned</span></span></span><span class="hljs-function"> -</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Force</span></span></span><span class="hljs-function"> -</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scope</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LocalMachine</span></span></span></span></code> </pre> <br>  We have this action performed by the application installation script. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Configuring PowerShell Modules Search Directories </h5><br>  Complex projects, as a rule, contain a large number of modules on PowerShell, placed in different directories.  For example, in our application, the directory structure with modules looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/45b/9a0/f0f/45b9a0f0f84a04b25a939d3406197abe.png"><br><br>  In our application, subsystems for managing end services, such as Exchange, are called <i>providers</i> .  They are separated by separate directories.  The provider contains a set of PowerShell modules, each of which performs a single function.  In the picture above, the directory with the Exchange management provider is highlighted.  We try to give the modules ‚Äúspeaking‚Äù names: <br><br><ul><li>  <b>CreateMailbox.ps1</b> - create mailbox </li><li>  <b>CreateGlobalAddressList.ps1</b> - Creating a GAL Exchange Object </li><li>  Etc. </li></ul><br>  In the <b>Common</b> directory we place utilitarian PowerShell modules that are used by several providers.  For the provider modules to work constructions of the form: <br><pre> <code class="python hljs">Import-Module ProviderUtils Import-Module -Name Utils\ExchangeADUtils.ps1</code> </pre><br>  You need to set the <i>PSModulePath</i> environment variable <i>correctly</i> .  In it you need to add directories that contain the modules used. <br><br><h5>  Error processing </h5><br>  PowerShell divides errors into terminating and nonterminating.  Simply put, terminating errors are errors, after which the normal continuation of the script is impossible, all other errors are non-terminating.  For example, syntax errors are terminating, and the script will be completed anyway.  The <b>$ ErrorActionPreference variable</b> allows <b>you</b> to specify how to handle nonterminating errors. <br><br>  When setting a variable to <b>Continue,</b> nonterminating errors will not cause the script to crash.  Non-terminating errors can be processed in .NET code as follows: <br><pre> <code class="cs hljs">result = PowerShell.Invoke(); checkErrors(PowerShell.Streams.Error); ... <span class="hljs-comment"><span class="hljs-comment">//    private static void CheckErrors(PSDataCollection&lt;ErrorRecord&gt; error) { if (error.Count == 1) { ErrorRecord baseObject = error[0]; throw baseObject.Exception; } if (error.Count &gt; 1) { foreach (ErrorRecord baseObject in error) { if (baseObject != null) { throw baseObject.Exception; } } } }</span></span></code> </pre><br><h4>  Types of PowerShell command calls </h4><br>  For remote calls, PowerShell uses the WinRM protocol, which is an implementation of the open WS-Management Protocol.  In fact, this is an extension of the SOAP protocol and all transport goes via http (s).  To serialize objects that are transferred from a remote host to a local PowerShell, xml is used.  This also needs to be remembered in the context of performance.  According to experience, it takes a lot of time to establish a connection with a remote host via WinRM - hence the desire to somehow cache the Runspace objects that have already established connections with hosts. <br><br>  Local script call from .NET looks like this: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  runspace using (Runspace runspace = RunspaceFactory.CreateRunspace()) { runspace.Open(); //   PowerShell   runspace.SessionStateProxy.SetVariable("ErrorActionPreference", stopOnErrors ? "Stop" : "Continue"); using (PowerShell powershell = PowerShell.Create()) { var command = new PSCommand(); command.AddCommand("Get-Item"); command.AddArgument(@"c:\Windows\*.*"); powershell.Commands = command; powershell.Runspace = runspace; ICollection&lt;PSObject&gt; result = powershell.Invoke(); //     if (!stopOnErrors) CheckErrors(powershell.Streams.Error); foreach (PSObject psObject in result) { Console.WriteLine("Item: {0}", psObject); } } }</span></span></code> </pre><br><br>  Calling a script or cmdlet on a remote host looks like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WSManConnectionInfo( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriBuilder(<span class="hljs-string"><span class="hljs-string">"http"</span></span>, server, <span class="hljs-number"><span class="hljs-number">5985</span></span>).Uri, <span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/powershell/Microsoft.PowerShell"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PSCredential(user, passw)) {AuthenticationMechanism = AuthenticationMechanism.Basic}; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (Runspace runspace = RunspaceFactory.CreateRunspace(connectionInfo)) { <span class="hljs-comment"><span class="hljs-comment">//   ,     ... }</span></span></code> </pre><br><blockquote>  ATTENTION: In the example, for simplicity, I used the http and Basic authentication protocol.  In a real application, you must use the https protocol and Kerberos or Digest authentication. <br></blockquote><br>  With remote cmdlet calls, for example, Exchange, if you do not have assemblies containing the types of returned objects, you will have to deserialize the objects received from the remote host yourself.  In the case of Exchange, for proper deserialization, you must have the <i>Exchange Management Tools</i> installed.  In the case when assemblies of serializable types are missing or there is no need for typed deserialization, you can work with objects as with primitive types: strings and arrays of strings.  You can do it like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPsObjectProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PSObject obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    null     //   null   , ,    //   return obj.Properties[propName].Value == null ? null : obj.Properties[propName].Value.ToString(); } public static string[] GetPSObjectCollection(PSObject obj, string propName) { object psColl = GetPsObjectProperty&lt;object&gt;(obj, propName); //         var psObj = psColl as PSObject; if (psObj == null) { var coll = GetPsObjectProperty&lt;ICollection&gt;(obj, propName); if (coll != null) { var arr = new string[coll.Count]; int idx = 0; foreach (object item in coll) { arr[idx++] = item.ToString(); } return arr; } } else { var collection = (ArrayList) psObj.BaseObject; return (string[]) collection.ToArray(typeof (string)); } return null; }</span></span></code> </pre><br><h5>  Calling scripts on a remote host </h5><br>  Often, on the objects obtained using cmdlet, it is necessary to perform some actions.  You can do this on the client, but in terms of performance and reducing network traffic, it is more efficient to do it on the server.  For these purposes, you can use the PowerShell feature to run scripts on a remote server.  First of all, create a local PowerShell session: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PsRemoteScript</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Runspace _runspace = RunspaceFactory.CreateRunspace(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _disposed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PsRemoteScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _runspace.Open(); } ...</code> </pre><br>  Passing the input and output parameters of the script is implemented by changing session variables; this is done by calling the <b>Runspace.SessionStateProxy.SetVariable</b> method. <br><br><pre> <code class="cs hljs">... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> varName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> variables.Keys) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> varValue = variables[varName]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (varValue == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException( <span class="hljs-string"><span class="hljs-string">"variables"</span></span>, String.Format(<span class="hljs-string"><span class="hljs-string">"Variable '{0}' has null value"</span></span>, varName)); } _runspace.SessionStateProxy.SetVariable(varName, varValue); } ...</code> </pre><br>  Next, you need to execute the PowerShell script in the current session, in which you can create a new remote PowerShell session using the cmdlet <b>New-PSSession</b> , and then import it by calling the cmdlet <b>Import-PSSession</b> : <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenRemoteSession</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WSManConnectionInfo connInfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] importExchangeCommands</span></span></span><span class="hljs-function">)</span></span> { _runspace.SessionStateProxy.SetVariable(<span class="hljs-string"><span class="hljs-string">"_ConnectionUri"</span></span>, connInfo.ConnectionUri.AbsoluteUri); _runspace.SessionStateProxy.SetVariable(<span class="hljs-string"><span class="hljs-string">"_Credential"</span></span>, connInfo.Credential); _runspace.SessionStateProxy.SetVariable(<span class="hljs-string"><span class="hljs-string">"_CommandsToImport"</span></span>, importExchangeCommands); Pipeline pipeline = _runspace.CreatePipeline(); pipeline.Commands.AddScript(<span class="hljs-string"><span class="hljs-string">@" $_my_session = $null $_my_session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri $_ConnectionUri -Credential $_Credential -Authentication Kerberos Import-PSSession $_my_session -CommandName $_CommandsToImport"</span></span>); pipeline.Invoke(); }</code> </pre><br>  Please note that the list of required cmdlets that will be called in a remote session is passed by the parameter when you call <b>Import-PSSession</b> . <br><br><h4>  Memory troubleshooting </h4><br><h5>  Performance and Memory </h5><br>  PowerShell itself is quite memory intensive, especially for remote calls. <br>  Another bad news: the Runspace object after an explicit call to Dispose () does not completely release the memory.  The fact is that Runspace stores executable pieces of PowerShell code, scripts and generated modules ( <i>proxies</i> ) for remote calls in the internal cache.  And the links really remain ‚Äúalive‚Äù, because <b>GC.Collect ()</b> , called directly in the application, does not reduce the consumption of physical memory.  When the profiler analyzes the dumps of the IIS process of the pool in which the application is running, a large number of line objects with run scripts lexemes are detected. <br>  There are at least three ways to combat excessive memory consumption: <br><ol><li>  Configure the application pool to restart in IIS after reaching some unreasonable amount of used memory (see <a href="http://technet.microsoft.com/en-us/library/cc725749(v%3Dws.10).aspx">Configure an Maximum Pool Used (IIS 7)</a> ) </li><li>  The most difficult way: execute PowerShell commands and scripts in a separate application domain (.NET Application Domain).  There are several problems to solve: <br><ul><li>  Data transfer between the main domain and the descendant domains in which the scripts will be executed.  It is solved using the .NET <b>AppDomain.SetData</b> and / or <b>AppDomain.DoCallBack</b> methods. </li><li>  Configure download paths for assemblies in descendant domains.  Solved by creating an <b>AppDomain.AssemblyResolve</b> event handler. </li><li>  Some global things, for example, writing the application log to the file, most likely, will have to be called in the context of the parent domain.  We used the <b>Logging Application Block</b> from the <a href="http://msdn.microsoft.com/en-us/library/ff632023.aspx">Microsoft Enterprise Library</a> - all log entries had to be performed in the context of the main domain. </li></ul></li><li>  Via .NET Reflection, access the cache and periodically force it to clear </li></ol><br>  We tried all the ways, only the first solves the problem with memory. <br><blockquote>  <b>Tip</b> : use <b>Import-PSSession</b> with explicitly specifying the cmdlets you will use in the body of the script.  Without explicitly specifying PowerShell, a special PowerShell proxy module will be generated for all cmdlet exported by Snap-In.  For example, for Microsoft.Exchange, a proxy is of the order of 2Mb of PowerShell code.  For unexplained reasons, PowerShell sometimes does not remove proxy modules.  These files gradually accumulate in the directory with temporary files, and it must be periodically cleaned.  Moreover, with the accumulation of a large number of proxy modules (several thousand), the execution speed of scripts is significantly reduced.  Exchange Management Tools themselves manage the generation of proxies for remote calls, thereby avoiding the generation of proxies for each remote session.  For details, see <b>RemoteExchange.cs</b> and <b>ConnectXXX.cs</b> from MS Exchange Management Tools.  For Exchange 2013, these files are located in the <i>C: \ Program Files \ Microsoft \ Exchange Server \ V15 \ Bin</i> folder. </blockquote><br><br>  For remote calls, if there is a possibility, it is better to call not a set of cmdlets with the subsequent processing of the results on the local host using C #, but transfer the processing to the script on PowerShell and call it.  It should be remembered that the script needs to load snapins (i.e., .NET assemblies) with used cmdlets. <br><br><h5>  Using RunspacePool to cache execution objects </h5><br>  The main purpose of the RunspacePool class is to organize asynchronous calls to cmdlets and scripts.  But since execution objects obtained via RunspacePool are not deleted by the environment, but are cached for later use, there is a natural desire to use this mechanism to speed up the ‚Äúcold‚Äù start of PowerShell scripts.  In fact, it does not look so bright.  Indeed, the execution time of scripts decreases, although problems arise: <br><ul><li>  PowerShell does not clear the variable namespace after the Runspace object is returned to the pool.  Memory consumption is growing, this is especially noticeable with the frequent release of exceptions from scripts. </li><li>  Care should be taken to ensure that after using an instance of RunspacePool (or before starting to use it in a new session), all confidential data, such as passwords, will be destroyed, that is, at least take care of deleting / cleaning instances of variables remaining in the pool after execution of a script. </li></ul><br><h4>  Outcome or "Will there be sugar after the uprising?" </h4><br>  I hope our experience will be useful for developers who would like to use PowerShell as a scripting language in .NET applications or for configuring various services with it.  We covered the main problems of integrating .NET applications and PowerShell, types of calls, and features of working with PowerShell memory.  Described some ways to deal with excessive memory consumption by PowerShell, these methods allow you to effectively use PowerShell in a busy system. <br><br>  That's all.  As they say in MSFT: ‚ÄúHappy Scripting!‚Äù. <br><br>  <a href="https://onedrive.live.com/redir%3Fresid%3D56EA5DF7AF5DCB19!7846%26authkey%3D!AG8mGJ0URyJ5rt8%26ithint%3Dfile%252C.zip">Full source for the article here.</a> <br>  I am ready to answer your questions in the comments. <br><br><blockquote>  Special thanks I want to say to Dmitry Maslakov, Alexey Varchenko and Nikita Popov for help in writing the article. </blockquote><br><br><h4>  Links </h4><br>  <a href="http://technet.microsoft.com/en-us/library/ee221100.aspx">Windows PowerShell Owner's Manual</a> <br>  <a href="http://msdn.microsoft.com/en-us/library/System.Management.Automation.Runspaces(v%3Dvs.85).aspx">System.Management.Automation.Runspaces Namespace</a> <br>  <a href="http://msdn.microsoft.com/en-us/library/aa384426(v%3Dvs.85).aspx">Windows remote management</a> <br>  <a href="http://technet.microsoft.com/en-us/library/bb124413(v%3Dexchg.150).aspx">Exchange 2013 cmdlets</a> <br>  <a href="http://blogs.msdn.com/b/kebab/archive/2013/06/09/an-introduction-to-error-handling-in-powershell.aspx">Handling in PowerShell</a> <br>  <a href="http://pubs.vmware.com/orchestrator-plugins/index.jsp%3Ftopic%3D%252Fcom.vmware.using.powershell.plugin.doc_10%252FGUID-D4ACA4EF-D018-448A-866A-DECDDA5CC3C1.html">Configure WinRM to Use HTTP</a> </div><p>Source: <a href="https://habr.com/ru/post/229939/">https://habr.com/ru/post/229939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229927/index.html">SpaceX will build a futuristic space center in Texas</a></li>
<li><a href="../229929/index.html">Why actually use micromarking. Review from Yandex</a></li>
<li><a href="../229931/index.html">Update Windows Phone 8.0 application to Windows Phone 8.1 (XAML)</a></li>
<li><a href="../229933/index.html">Wargaming Developers Contest: Seven Top Contest Questions</a></li>
<li><a href="../229937/index.html">Looking for a melody by fragment</a></li>
<li><a href="../229941/index.html">Facebook XHP. Object Templates</a></li>
<li><a href="../229943/index.html">The notorious programmer: Informal stories and frank conversations about the IT-industry</a></li>
<li><a href="../229945/index.html">WebCamp Special Rapporteur: Mobile Day - Andrian Budantsov, co-founder of Readdle</a></li>
<li><a href="../229947/index.html">Development of a payment system for the site using CyberSource Secure Acceptance</a></li>
<li><a href="../229949/index.html">Implementation and testing of facial recognition algorithm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>