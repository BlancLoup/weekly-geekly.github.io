<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python on wheels</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The package system infrastructure for Python has long been criticized from both developers and system administrators. For a long time, even the commun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python on wheels</h1><div class="post__text post__text-html js-mediator-article"> The package system infrastructure for Python has long been criticized from both developers and system administrators.  For a long time, even the community itself could not come to an agreement about which tools to use in each particular case.  Already there are distutils, setuptools, distribute, distutils2 as basic distribution mechanisms and virtualenv, buildout, easy_install and pip as high-level tools for managing all this mess. <br><br>  Prior to setuptools, the primary distribution format was source files or some binary MSI distributions for Windows.  Under Linux, there were initially broken <code>bdist_dumb</code> and <code>bdist_rpm</code> , which worked only on systems based on Red Hat.  But even <code>bdist_rpm</code> did not work well enough for people to start using it. <br><br>  A few years ago, <a href="https://twitter.com/pjeby">PJE</a> tried to fix this problem by providing a mix of setuptools and pkg_resources to improve distutils and add metadata to the Python packages.  In addition to this, he wrote the easy_install utility to install them.  Due to the lack of a distribution format supporting metadata, the format of 'eggs' [egg] was provided. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Python eggs - the usual zip-archives containing the python-package and the necessary metadata.  Although many people probably never deliberately collected eggs, their metadata format is still alive and well.  And everyone expands their projects using setuptools. <br><br>  Unfortunately, some time later, the community divided, and part of it proclaimed the death of binary formats and 'eggs' in particular.  After this pip, replacing easy_install, stopped accepting egg-format. <br><br>  Then a little more time passed, and the rejection of binary packages began to cause inconvenience.  People have become more and more deployed to cloud servers, and the need to recompile C-shnyh libraries on each machine is not too happy.  Since the ‚Äúeggs‚Äù at that time were obscure (I suppose), they were altered in the new PEPs, and were called ' <a href="http://www.python.org/dev/peps/pep-0427/">wheels</a> ' [wheels]. <br><a name="habracut"></a><br>  In the following, it is assumed that all actions take place in a <a href="http://www.virtualenv.org/en/latest/">virtualenv environment</a> . <br><br><h4>  What kind of wheel? </h4><br>  Let's start with the simple.  What are the 'wheels' and how do they differ from the 'eggs'?  Both formats are zip files.  The main difference is that the egg can be imported without unpacking, the wheel will have to be unpacked.  Although there are no technical reasons that make the 'wheels' non-imported, support for their direct import has never even been planned. <br><br>  Another difference is that the eggs contain compiled bytecode, and the ‚Äúwheels‚Äù do not.  The main advantage of this is that there is no need to create separate wheels for each version of Python until you have to distribute modules linked through libpython.  Although in new versions of Python 3, using stable ABI, even this can already be done. <br><br>  However, the wheel-format is also not without problems, some of which it inherits from the 'eggs'.  For example, binary distributions for Linux are still unacceptable for most because of two drawbacks: Python itself compiles for Linux in different forms, and modules are linked with different system libraries.  The first problem is caused by the coexistence of incompatible versions of Python 2: USC2 and USC4.  Depending on the compilation mode, the ABI changes.  Currently, wheel (as far as I can tell) does not contain information about which Unicode mode the library is associated with.  A separate problem is that Linux distributions are less compatible with each other than we would like, and circumstances may be such that an assembly compiled for one distribution will not work for the others. <br><br>  All this translates into the fact that, generally speaking, at the moment binary 'wheels' cannot be loaded onto PyPI as incompatible with different systems. <br><br>  In addition to all this, wheel now knows only two extremes: binary packages and packages containing pure python code.  Binary packages are specific to Python 2.x branches.  This does not seem to be a big problem now, because the 2.x cycle is coming to an end, and the packets collected for only 2.7 will last long.  But if suddenly it was about Python 2.8, it would be interesting to say that this package does not depend on the version of Python, but it contains binaries, so it can not depend on the architecture. <br><br>  The only case that justifies the existence of such a package is when it contains distributed libraries loaded with ctypes from CFFI.  Such libraries are not connected through libpython and are not dependent on the implementation of the language (they can even be used with pypy). <br><br>  But there is a bright side: nothing prohibits the use of binary wheels in their own homogeneous infrastructures. <br><br><h4>  Wheel assembly </h4><br>  So now we know what a wheel is.  How to make your own 'wheel'?  Building from your own libraries is the simplest process.  All you need is the latest version of <code>setuptools</code> and the <code>wheel</code> library.  Once both are installed, the 'wheel' is assembled with the following command: <br><pre> <code class="bash hljs">$ python setup.py bdist_wheel</code> </pre><br>  Wheel will be created in the package directory.  However, there is one thing to be aware of: the distribution of binaries.  By default, the collected 'wheel' (provided that no binary steps are used in setup.py) consists of pure-python code.  This means that even if you distribute <code>.so</code> , <code>.dylib</code> or <code>.dll</code> as part of your package, the resulting 'wheel' will look platform-independent. <br><br>  The solution to this problem is to manually implement Distribution from setuptools, removing the purity flag to <code>false</code> : <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> setuptools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> setup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> setuptools.dist <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Distribution <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryDistribution</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Distribution)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_pure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> setup( ..., include_package_data=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, distclass=BinaryDistribution, )</code> </pre><br><h4>  Wheel installation </h4><br>  Using the latest version of pip, the 'wheel' is set as follows: <br><pre> <code class="bash hljs">$ pip install package-1.0-cp27-none-macosx_10_7_intel.whl</code> </pre><br>  But what about addictions?  Here there are some difficulties.  Usually one of the requirements for the package is the ability to install it even without an internet connection.  Fortunately, pip allows you to disable booting from the index and set the directory containing everything needed for installation.  If we have wheels for all dependencies of the required versions, you can do the following: <br><pre> <code class="bash hljs">$ pip install --no-index --find-links=path/to/wheels package==1.0</code> </pre><br>  Thus, version <code>1.0</code> of the <code>package</code> will be installed in our virtual environment. <br><br><h4>  Wheels for addictions </h4><br>  OK, but what if we don't have .whl for all our dependencies?  Pip in theory solves this problem using the command <code>wheel</code> .  This should work something like this: <br><pre> <code class="bash hljs">pip wheel --wheel-dir=path/to/wheels package==1.0</code> </pre><br>  This command will download all the packages that our package depends on to the specified folder.  But there are a couple of problems. <br>  The first is that the team currently has a bug that does not unload dependencies, which are already 'wheels'.  So if the dependency is already available on PyPI in a wheel-format, it will not be loaded. <br><br>  This is temporarily solved by the shell script, which manually moves the downloaded wheels from the cache. <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh WHEEL_DIR=path/to/wheels DOWNLOAD_CACHE_DIR=path/to/cache rm -rf $DOWNLOAD_CACHE_DIR mkdir -p $DOWNLOAD_CACHE_DIR pip wheel --use-wheel -w "$WHEEL_DIR" -f "$WHEEL_DIR" \ --download-cache "$DOWNLOAD_CACHE_DIR" package==1.0 for x in "$DOWNLOAD_CACHE_DIR/"*.whl; do mv "$x" "$WHEEL_DIR/${x##*%2F}" done</span></span></code> </pre><br>  The second problem is a bit more serious: how will pip find our own package if it is not on PyPI?  Right, no way.  Documentation in this case recommends using not the <code>pip wheel package</code> , but the <code>pip wheel -r requirements.txt</code> , where the <code>requirements.txt</code> contains all the necessary dependencies. <br><br><h4>  Build packages using DevPI </h4><br>  Such a temporary solution to the dependency problem is quite applicable in simple situations, but what if there are many internal python packages that depend on each other?  This design is falling apart quickly. <br><br>  Fortunately, last year Holker Krekel created a solution to this trouble called <a href="http://doc.devpi.net/">DevPI</a> , which is essentially a hack that emulates the work of pip with PyPI.  Once installed on a computer, DevPI works as a transparent proxy in front of PyPI and allows pip to install packages from the local repository.  In addition, all packages downloaded from PyPI are automatically cached, so even if you turn off the network, these packages will be available for installation.  And in the end, it becomes possible to upload your own packages to the local server in order to refer to them in the same way as to those stored in the public index. <br><br>  I recommend installing DevPI in a local virtualenv, then adding links to <code>devpi-server</code> and <code>devpi</code> in <code>PATH</code> . <br><pre> <code class="bash hljs">$ virtualenv devpi-venv $ devpi-venv/bin/pip install --upgrade pip wheel setuptools devpi $ ln -s `<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span>`/devpi-venv/bin/devpi ~/.<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin $ ln -s `<span class="hljs-built_in"><span class="hljs-built_in">pwd</span></span>`/devpi-venv/bin/devpi-server ~/.<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin</code> </pre><br>  After that, it remains just to start the <code>devpi-server</code> , and it will work until manual stop. <br><pre> <code class="bash hljs">$ devpi-server --start</code> </pre><br>  After launching it, it is necessary to initialize it once: <br><pre> <code class="bash hljs">$ devpi use http://localhost:3141 $ devpi user -c <span class="hljs-variable"><span class="hljs-variable">$USER</span></span> password= $ devpi login <span class="hljs-variable"><span class="hljs-variable">$USER</span></span> --password= $ devpi index -c yourproject</code> </pre><br>  Since I use DevPI 'for myself', the DevPI username and system username are the same.  At the last step, an index is created by the name of the project (if necessary, you can create several). <br><br>  To redirect pip to the local repository, you can export the environment variable: <br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> PIP_INDEX_URL=http://localhost:3141/<span class="hljs-variable"><span class="hljs-variable">$USER</span></span>/yourproject/+simple/</code> </pre><br>  I will place this command in the <code>postactivate</code> script of my virtualenv to prevent accidental loading from the wrong index. <br><br>  To place your own wheels in the local DevPI, the <code>devpi</code> utility is <code>devpi</code> : <br><pre> <code class="bash hljs">$ devpi use yourproject $ devpi upload --no-vcs --formats=bdist_wheel</code> </pre><br>  The <code>--no-vcs</code> disables magic, which attempts to detect a version control system and moves some files first.  I don‚Äôt need this, because in my projects I distribute files that I don‚Äôt include in VCS (binaries, for example). <br><br>  Finally, I highly recommend splitting the setup.py files in such a way that PyPI will reject them, and DevPI will accept them so that they do not accidentally release their code using <code>setup.py resease</code> .  The easiest way to do this is to add the wrong PyPI classifier: <br><pre> <code class="python hljs">setup( ... classifier=[<span class="hljs-string"><span class="hljs-string">'Private :: Do Not Upload'</span></span>], )</code> </pre><br><h4>  Wrapping up </h4><br>  Now everything is ready to start using internal dependencies and build your own 'wheels'.  Once they appear, they can be archived, downloaded to another server and installed in a separate virtualenv. <br>  The whole process will become a bit easier when the <code>pip wheel</code> stops ignoring the existing wheel packages.  In the meantime, the above shell script is not the worst solution. <br><br><h4>  In comparison with the 'eggs' </h4><br>  Now wheel format is more attractive than egg.  Its development is more active, PyPI began to add its support and, as utilities start working with it, it looks like a better solution.  'Eggs' is currently supported only by easy_install, although most have long since switched to pip. <br><br>  I believe that the Zope community is still the largest one based on egg-format and buildout.  And I believe that if a solution based on 'eggs' is applicable in your case, it is worth applying it.  I know that many do not use eggs at all, preferring to create virtualenv-s, archive them and send them to different servers.  Just for this deployment wheels - the best solution, since different servers may have different paths to libraries.  There was a problem related to the fact that <code>.pyc</code> files were created on the build server for virtualenv, and these files contain specific paths to the files.  Using wheel, <code>.pyc</code> created after installation in a virtual environment and will automatically have the correct path. <br><br>  So now you have it.  Python on wheels.  And it even seems to work, and perhaps worth the time spent. </div><p>Source: <a href="https://habr.com/ru/post/210450/">https://habr.com/ru/post/210450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210438/index.html">New free courses of virtual academy of Microsoft Virtual Academy</a></li>
<li><a href="../210442/index.html">Twister: Windows version is available.</a></li>
<li><a href="../210444/index.html">Dungeons & Dragons turned 40 years old</a></li>
<li><a href="../210446/index.html">Windows Azure Media Services vs. Amazon Elastic Transcoder. Part 3: Comparison</a></li>
<li><a href="../210448/index.html">Modern technology for the benefit of</a></li>
<li><a href="../210452/index.html">Rule 3h when building a startup team Preply</a></li>
<li><a href="../210454/index.html">Sweet.js: Syntax JavaScript Extensions</a></li>
<li><a href="../210458/index.html">Transparent file encryption on the local computer using CyberSafe Files Encryption</a></li>
<li><a href="../210460/index.html">OpenVZ in Proxmox, margin notes</a></li>
<li><a href="../210462/index.html">SharePoint collection site, managed paths, and can subdomains?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>