<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I will calculate you over the networks: use the API of the largest social networks for my own selfish purposes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's no secret that modern social networks are huge databases containing a lot of interesting information about the privacy of their users. You can't ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I will calculate you over the networks: use the API of the largest social networks for my own selfish purposes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/eff/fa7/a52/efffa7a52db948febafdfd32bcfde903.jpg"><br><br>  It's no secret that modern social networks are huge databases containing a lot of interesting information about the privacy of their users.  You can't get too much data through the web-muzzle, but each network has its own API ... So let's see how this can be used to search for users and collect information about them. <br><br>  There is a discipline in American intelligence, such as OSINT (Open source intelligence), which is responsible for finding, collecting and selecting information from publicly available sources.  One of the largest providers of publicly available information include social networks.  After all, almost every one of us has accounting (and someone has more than one) in one or several social networks.  Here we share our news, personal photos, tastes (for example, like something or joining a group), around our acquaintances.  And we do this on our own free will and almost completely do not think about the possible consequences.  On the pages of the magazine, they have repeatedly considered how it is possible using various tricks to pull out interesting data from social networks.  Usually, it was necessary to manually perform some kind of manipulation.  But for successful intelligence it is more logical to use special utilities.  There are several open source utilities that allow users to pull information about users from social networks. <br><a name="habracut"></a><br><h4>  Creepy </h4><br>  One of the most popular is <a href="http://www.geocreepy.com/">Creepy</a> .  It is designed to collect geolocation information about a user based on data from his Twitter, Instagram, Google+ and Flickr accounts.  The advantages of this tool, which is regularly included in Kali Linux, include an intuitive interface, a very convenient process for obtaining tokens for using the API services, as well as displaying the results with labels on the map (which, in turn, allows you to follow all user movements).  The disadvantages I would consider rather weak functionality.  Tulsa knows how to collect geotags on the listed services and display them on a Google map, shows who and how many times a user retweets, counts statistics on the devices from which tweets were written, as well as on the time of their publication.  But due to the fact that this is an open source tool, its functionality can always be expanded by yourself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will not consider how to use the program - everything is perfectly shown in the <a href="http://www.youtube.com/watch%3Fv%3DJqJ4zaDIVAs">official video</a> , after watching which there should be no questions left about the work with the tool. <br><br><img src="https://habrastorage.org/files/da8/db3/dfc/da8db3dfc7244278aa6c84770062fa90.gif"><br><br><h4>  fbStalker </h4><br>  Two more tools that are less known, but have strong functionality and deserve your attention - <a href="https://github.com/milo2012/osintstalker">fbStalker and geoStalker</a> . <br><br>  fbStalker is designed to collect information about a user based on his Facebook profile.  Allows you to pull the following data: <br><ul><li>  video, photo, user posts; </li><li>  who and how many times liked his records; </li><li>  geolocation of photos; </li><li>  statistics of comments on his records and photos; </li><li>  the time in which he usually happens online. </li></ul><br>  To use this tool, you will need Google Chrome, ChromeDriver, which is installed as follows: <br><br><pre><code class="bash hljs">wget http://goo.gl/Kvh33W unzip chromedriver_linux32_23.0.1240.0.zip cp chromedriver /usr/bin/chromedriver chmod 777 /usr/bin/chromedriver</code> </pre> <br>  In addition, you will need to install Python 2.7, as well as pip to install the following packages: <br><br><pre> <code class="bash hljs">pip install pytz pip install tzlocal pip install termcolor pip install selenium pip install requests --upgrade pip install beautifulsoup4</code> </pre><br>  Finally, you need a library for parsing GraphML files: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/hadim/pygraphml.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> pygraphml python2.7 setup.py install</code> </pre><br>  After that, you can correct `fbstalker.py`, indicating there your soap, password, username, and start searching.  Using the tool is quite simple: <br><br><pre> <code class="bash hljs">python fbstalker.py -user [  ]</code> </pre><br><h4>  geoStalker </h4><br>  geoStalker is much more interesting.  He collects information on the coordinates that you gave him.  For example: <br><ul><li>  local Wi-Fi points based on `wigle.net` (in particular, their` essid`, `bssid`,` geo`); </li><li>  Foursquare checks; </li><li>  Instagram- and Flickr-accounts, from which photos were posted with reference to these coordinates; </li><li>  all tweets made in the area. </li></ul><br>  To use the tool, as in the previous case, you need Chrome &amp; ChromeDriver, Python 2.7, pip (to install the following packages: google, python-instagram, pygoogle, geopy, lxml, oauth2, python-linkedin, pygeocoder, selenium, termcolor, pysqlite , TwitterSearch, foursquare), as well as pygraphml and gdata: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/hadim/pygraphml.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> pygraphml python2.7 setup.py install wget https://gdata-python-client.googlecode.com/files/gdata-2.0.18.tar.gz tar xvfz gdata-2.0.18.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> gdata-2.0.18 python2.7 setup.py install</code> </pre><br>  After that, edit `geostalker.py`, filling in all the necessary API keys and access tokens (if for any social network these data are not specified, then it simply will not participate in the search).  Then run the tool with the command `sudo python2.7 geostalker.py` and specify the address or coordinates.  As a result, all data is collected and placed on a Google map, and also saved in an HTML file. <br><br><h4>  Go to action </h4><br>  Before that, it was about ready-made tools.  In most cases, their functionality will be missed and you will have to either refine them or write your tools - all popular social networks provide their API.  Usually they appear as a separate subdomain to which we send GET requests, and in return we get XML / JSON answers.  For example, for ‚ÄúInstagram‚Äù it is `api.instagram.com`, for‚Äú Contact ‚Äù-` api.vk.com`.  Of course, most of these APIs have their own libraries of functions for working with them, but we want to figure out how it works, and we can make the script too heavy with external libraries because of one or two functions that are not comme il faut.  So, let's take and write our own tool that would allow you to search for photos from the VC and Instagram on the given coordinates and time interval. <br><br>  Using the documentation for API VK and Instagram, we make requests for a list of photos according to geographic information and time. <br><br>  Instagram API Request: <br><br><pre> <code class="xml hljs"> url = "https://api.instagram.com/v1/media/search?" + "lat=" + location_latitude + "&amp;lng=" + location_longitude + "&amp;distance=" + distance + "&amp;min_timestamp=" + timestamp + "&amp;max_timestamp=" + (timestamp + date_increment) + "&amp;access_token=" + access_token</code> </pre><br>  Vkontakte API Request: <br><br><pre> <code class="xml hljs"> url = "https://api.vk.com/method/photos.search?" + "lat=" + location_latitude + "&amp;long=" + location_longitude + "&amp;count=" + 100 + "&amp;radius=" + distance + "&amp;start_time=" + timestamp + "&amp;end_time=" + (timestamp + date_increment)</code> </pre><br>  Here are the variables used: <br><ul><li>  location_latitude - latitude; </li><li>  location_longitude - longitude; </li><li>  distance - search radius; </li><li>  timestamp - the initial boundary of the time interval; </li><li>  date_increment - the number of seconds from the initial to the final limit of the time interval; </li><li>  access_token is a developer token. </li></ul><br>  As it turned out, access_token is required to access the Instagram API.  It's easy to get it, but you'll have to be a little confused (see the sidebar).  Contact is more loyal to strangers, which is very good for us. <br><br><blockquote><h4>  Getting Instagram Access Token </h4><br><br>  First you register on Instagram.  After registration, go to the following link: <br><br>  <a href="http://instagram.com/developer/clients/manage/">instagram.com/developer/clients/manage</a> <br><br>  You harvest ** Register a New Client **.  Enter the phone number, wait for text messages and enter the code.  In the window for creating a new client that opens, important fields for us should be filled in as follows: <br><ul><li>  OAuth redirect_uri: <a href="http://localhost/">localhost</a> </li><li>  Disable implicit OAuth: checkbox should be unchecked </li></ul><br>  The remaining fields are randomly filled.  Once everything is filled, create a new client.  Now you need to get a token.  To do this, enter the following URL into your browser: <br><pre> <code class="xml hljs">https://instagram.com/oauth/authorize/?client_id=[CLIENT_ID]&amp;redirect_uri=http://localhost/&amp;response_type=token</code> </pre><br>  where instead of [CLIENT_ID] specify the Client ID of the client you created.  After that, make the transition to the resulting link, and if you did everything right, then you will be redirected to <a href="http://localhost/">localhost</a> and Access Token will be written in the address bar. <br><pre> <code class="xml hljs"> http://localhost/#access_token=[Access Token]</code> </pre><br>  For more information about this method of obtaining a token, you can read the following link: <a href="http://jelled.com/instagram/access-token">jelled.com/instagram/access-token</a> . </blockquote><br><br><h4>  Automating the process </h4><br>  So, we have learned how to write the necessary requests, but manually parsing the server's response (in the form of JSON / XML) is not the coolest thing.  It is much more convenient to make a small script that will do it for us.  We will use again Python 2.7.  The logic is as follows: we are looking for all the photos that fall into a given radius relative to the given coordinates in a given period of time.  But consider one very important point - a limited number of photos are displayed.  Therefore, for a large period of time, you will have to make several requests with intermediate time intervals (just date_increment).  Also consider the accuracy of the coordinates and do not specify a radius of several meters.  And do not forget that the time must be specified in the timestamp. <br><br>  Begin to code.  To begin with we will connect all libraries necessary for us: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> httplib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> urllib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime</code> </pre><br>  We write functions for data acquisition from API through HTTPS.  Using the passed function arguments, we compile a GET request and return the server response as a string. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_instagram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(latitude, longitude, distance, min_timestamp, max_timestamp, access_token)</span></span></span><span class="hljs-function">:</span></span> get_request = <span class="hljs-string"><span class="hljs-string">'/v1/media/search?lat='</span></span> + latitude get_request+= <span class="hljs-string"><span class="hljs-string">'&amp;lng='</span></span> + longitude get_request += <span class="hljs-string"><span class="hljs-string">'&amp;distance='</span></span> + distance get_request += <span class="hljs-string"><span class="hljs-string">'&amp;min_timestamp='</span></span> + str(min_timestamp) get_request += <span class="hljs-string"><span class="hljs-string">'&amp;max_timestamp='</span></span> + str(max_timestamp) get_request += <span class="hljs-string"><span class="hljs-string">'&amp;access_token='</span></span> + access_token local_connect = httplib.HTTPSConnection(<span class="hljs-string"><span class="hljs-string">'api.instagram.com'</span></span>, <span class="hljs-number"><span class="hljs-number">443</span></span>) local_connect.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, get_request) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_connect.getresponse().read() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_vk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(latitude, longitude, distance, min_timestamp, max_timestamp)</span></span></span><span class="hljs-function">:</span></span> get_request = <span class="hljs-string"><span class="hljs-string">'/method/photos.search?lat='</span></span> + location_latitude get_request+= <span class="hljs-string"><span class="hljs-string">'&amp;long='</span></span> + location_longitude get_request+= <span class="hljs-string"><span class="hljs-string">'&amp;count=100'</span></span> get_request+= <span class="hljs-string"><span class="hljs-string">'&amp;radius='</span></span> + distance get_request+= <span class="hljs-string"><span class="hljs-string">'&amp;start_time='</span></span> + str(min_timestamp) get_request+= <span class="hljs-string"><span class="hljs-string">'&amp;end_time='</span></span> + str(max_timestamp) local_connect = httplib.HTTPSConnection(<span class="hljs-string"><span class="hljs-string">'api.vk.com'</span></span>, <span class="hljs-number"><span class="hljs-number">443</span></span>) local_connect.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, get_request) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_connect.getresponse().read()</code> </pre><br>  Let's also apply a small function to convert the timestamp to the human view: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timestamptodate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timestamp)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> datetime.datetime.fromtimestamp(timestamp).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span></span>)+<span class="hljs-string"><span class="hljs-string">' UTC'</span></span></code> </pre><br>  Now we are writing the main logic of the image search, having previously divided the time interval into parts, the results are saved in the HTML file.  The function looks cumbersome, but the main difficulty in it is the partitioning of the time interval into blocks.  The rest is the usual JSON parsing and saving the necessary data in HTML. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_instagram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(location_latitude, location_longitude, distance, min_timestamp, max_timestamp, date_increment, access_token)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'Starting parse instagram..'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'GEO:'</span></span>,location_latitude,location_longitude <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'TIME: from'</span></span>,timestamptodate(min_timestamp),<span class="hljs-string"><span class="hljs-string">'to'</span></span>,timestamptodate(max_timestamp) file_inst = open(<span class="hljs-string"><span class="hljs-string">'instagram_'</span></span>+location_latitude+location_longitude+<span class="hljs-string"><span class="hljs-string">'.html'</span></span>,<span class="hljs-string"><span class="hljs-string">'w'</span></span>) file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;html&gt;'</span></span>) local_min_timestamp = min_timestamp <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( local_min_timestamp &gt;= max_timestamp ): <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> local_max_timestamp = local_min_timestamp + date_increment <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( local_max_timestamp &gt; max_timestamp ): local_max_timestamp = max_timestamp <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> timestamptodate(local_min_timestamp),<span class="hljs-string"><span class="hljs-string">'-'</span></span>,timestamptodate(local_max_timestamp) local_buffer = get_instagram(location_latitude, location_longitude, distance, local_min_timestamp, local_max_timestamp, access_token) instagram_json = json.loads(local_buffer) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> local_i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instagram_json[<span class="hljs-string"><span class="hljs-string">'data'</span></span>]: file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>) file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;img src='</span></span>+local_i[<span class="hljs-string"><span class="hljs-string">'images'</span></span>][<span class="hljs-string"><span class="hljs-string">'standard_resolution'</span></span>][<span class="hljs-string"><span class="hljs-string">'url'</span></span>]+<span class="hljs-string"><span class="hljs-string">'&gt;&lt;br&gt;'</span></span>) file_inst.write(timestamptodate(int(local_i[<span class="hljs-string"><span class="hljs-string">'created_time'</span></span>]))+<span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>) file_inst.write(local_i[<span class="hljs-string"><span class="hljs-string">'link'</span></span>]+<span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>) file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>) local_min_timestamp = local_max_timestamp file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;/html&gt;'</span></span>) file_inst.close()</code> </pre><br>  HTML format is chosen for a reason.  It allows us not to save the pictures separately, but only to provide links to them.  When the page is launched, the results in the browser will automatically load the images. <br>  We write exactly the same function for the "Contact". <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_vk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(location_latitude, location_longitude, distance, min_timestamp, max_timestamp, date_increment)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'Starting parse vkontakte..'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'GEO:'</span></span>,location_latitude,location_longitude <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'TIME: from'</span></span>,timestamptodate(min_timestamp),<span class="hljs-string"><span class="hljs-string">'to'</span></span>,timestamptodate(max_timestamp) file_inst = open(<span class="hljs-string"><span class="hljs-string">'vk_'</span></span>+location_latitude+location_longitude+<span class="hljs-string"><span class="hljs-string">'.html'</span></span>,<span class="hljs-string"><span class="hljs-string">'w'</span></span>) file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;html&gt;'</span></span>) local_min_timestamp = min_timestamp <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( local_min_timestamp &gt;= max_timestamp ): <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> local_max_timestamp = local_min_timestamp + date_increment <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( local_max_timestamp &gt; max_timestamp ): local_max_timestamp = max_timestamp <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> timestamptodate(local_min_timestamp),<span class="hljs-string"><span class="hljs-string">'-'</span></span>,timestamptodate(local_max_timestamp) vk_json = json.loads(get_vk(location_latitude, location_longitude, distance, local_min_timestamp, local_max_timestamp)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> local_i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vk_json[<span class="hljs-string"><span class="hljs-string">'response'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(local_i) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> int: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>) file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;img src='</span></span>+local_i[<span class="hljs-string"><span class="hljs-string">'src_big'</span></span>]+<span class="hljs-string"><span class="hljs-string">'&gt;&lt;br&gt;'</span></span>) file_inst.write(timestamptodate(int(local_i[<span class="hljs-string"><span class="hljs-string">'created'</span></span>]))+<span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>) file_inst.write(<span class="hljs-string"><span class="hljs-string">'http://vk.com/id'</span></span>+str(local_i[<span class="hljs-string"><span class="hljs-string">'owner_id'</span></span>])+<span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>) file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>) local_min_timestamp = local_max_timestamp file_inst.write(<span class="hljs-string"><span class="hljs-string">'&lt;/html&gt;'</span></span>) file_inst.close()</code> </pre><br>  And of course, the function calls themselves: <br><br><pre> <code class="python hljs">parse_instagram(location_latitude, location_longitude, distance, min_timestamp, max_timestamp, date_increment, instagram_access_token) parse_vk(location_latitude, location_longitude, distance, min_timestamp, max_timestamp, date_increment)</code> </pre><br><br><img src="https://habrastorage.org/files/736/fe9/182/736fe9182132481fa04b7f1cc46179f4.gif"><br>  The result of our script in the console <br><br><img src="https://habrastorage.org/files/9b4/57d/32c/9b457d32ccc348d6b3ce51b69c0ab334.gif"><br>  One of the results of parsing Instagram <br><br><img src="https://habrastorage.org/files/0cf/ab7/8e8/0cfab78e86cf410abe3c8982c4c510be.gif"><br>  Result of parsing "Contact" <br><br><h4>  Baptism of fire </h4><br>  The script is ready, it remains only to try it in action.  And then I came up with one idea.  Those who were on PHD'14, certainly remembered very nice prododevochek from Mail.Ru.  Well, let's try to catch up - find them and meet them. <br><br>  Actually, what we know about PHD14: <br><br><ul><li>  venue - Digital October - 55.740701,37.609161; </li><li>  The date of the event is May 21‚Äì22, 2014 - 1400619600‚Äì1400792400. </li></ul><br>  We get the following data set: <br><br>  location_latitude = '55 .740701 ' <br>  location_longitude = '37 .609161 ' <br>  distance = '100' <br>  min_timestamp = 1400619600 <br>  max_timestamp = 1400792400 <br>  date_increment = 60 * 60 * 3 # every 3 hours <br>  instagram_access_token = [Access Token] <br><br><blockquote><h4>  Useful tips </h4><br>  If, as a result of the script, the photos are too small, you can try changing the `date_increment` variable, since it is responsible for the time intervals over which the photos are collected.  If the place is popular, then the intervals should be frequent (decreasing `date_increment)`, but if the place is deaf and photos are published once a month, then collecting photos at intervals of an hour does not make sense (increasing `date_increment`). </blockquote><br><br>  Run the script and go to analyze the results.  Yeah, one of the girls posted a photo made in a mirror in the toilet, with reference to the coordinates!  Naturally, the API did not forgive such an error, and soon the pages of all the other promodevochek found.  As it turned out, two of them are twins :). <br><br><img src="https://habrastorage.org/files/e0e/bfb/500/e0ebfb500bcf48558256cba17f267c61.gif"><br>  The same photo of a promo girl with PHD'14, taken in the toilet <br><br><h4>  Instructive example </h4><br>  As a second example, I would like to recall one of the tasks from the final CTF on PHD'14.  Actually, it was after him that I became interested in this topic.  Its essence was as follows. <br><br>  There is an evil hacker who developed some malware.  We are given a set of coordinates and the corresponding timestamps from which he went to the Internet.  You need to get the name and picture of this hacker.  The coordinates were as follows: <br><br>  55.7736147.37.6567926 30 Apr 2014 19:15 MSK; <br>  55.4968379,40.7731697 30 Apr 2014 23:00 MSK; <br>  55.5625259,42.0185773 1 May 2014 00:28 MSK; <br>  55.5399274,42.1926434 1 May 2014 00:46 MSK; <br>  55.5099579,47.4776127 May 1, 2014 05:44 MSK; <br>  55.6866654,47.9438484 May 1, 2014 06:20 MSK; <br>  55.8419686.48.5611181 May 1, 2014 07:10 MSK <br><br>  First of all, we naturally looked at the places where these coordinates correspond.  As it turned out, these are Russian Railways stations, with the first coordinate being Kazan Station (Moscow), and the last is Zelen Dol (Zelenodolsk).  The rest are stations between Moscow and Zelenodolsk.  It turns out that he went online from the train.  By the time of departure was found the desired train.  As it turned out, the train arrival station is Kazan.  And then the main question arose: where to look for the name and picture.  The logic was as follows: since you want to find a picture, it is quite reasonable to assume that you need to look for it somewhere in social networks.  The main targets were chosen for VKontakte, Facebook, Instagram and Twitter.  In addition to the Russian teams, foreigners participated in the competitions, so we considered that the organizers would hardly have chosen VKontakte.  It was decided to start with Instagram. <br><br>  We didn‚Äôt have any scripts for searching photos by coordinates and time, and we had to use public services that could do it.  As it turned out, there are quite a few of them and they provide a rather poor interface.  After hundreds of viewed photos at each station, the train movement was finally found the right one. <br><br>  As a result, it took less than an hour to find the train and the missing stations, as well as the logic of the further search.  But the search for the desired photo - a lot of time.  This once again underlines how important it is to have the right and convenient programs in your arsenal. <br><br><blockquote><h4>  Www </h4><br>  You can find the source code of the reviewed script in my <a href="https://bitbucket.org/BetepokNoname/photobygeo/src">Bitbucket repository.</a> </blockquote><br><br><h4>  findings </h4><br>  The article came to an end, and it was time to draw a conclusion.  And the conclusion is simple: you need to deliberately upload photos with geo-referencing.  Competitive intelligence officers are ready to catch on with any opportunity to get new information, and the social networking API can help them very well in this.  When I wrote this article, I studied several other services, including Twitter, Facebook and LinkedIn, is there any similar functionality.  Positive results were given only by Twitter, which undoubtedly pleases.  But Facebook and LinkedIn upset, although all is not lost, and perhaps in the future they will expand their API.  In general, be more attentive, laying out your photos with geo-referencing - suddenly someone will find them wrong.  :) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a8/146/7e0/7a81467e0c7a59782054603aeec3c678.jpg" alt="image"><br><br>  <i>First published in the magazine "Hacker" from 02/2015.</i> <i><br></i>  <i>Posted by: Arkady Litvinenko ( <a href="https://twitter.com/betepo_ok">@BetepO_ok</a> )</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/254129/">https://habr.com/ru/post/254129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254117/index.html">Servers for business: energy efficiency matters</a></li>
<li><a href="../254119/index.html">The warden for the freelancer: choose the system of accounting of working time</a></li>
<li><a href="../254121/index.html">Great review testing of programming languages</a></li>
<li><a href="../254123/index.html">Why bash script or carriage return did not work</a></li>
<li><a href="../254127/index.html">The Legend of Temptation: How to use Python to automate iOS</a></li>
<li><a href="../254131/index.html">Dedovskoye UX design: coder - pest</a></li>
<li><a href="../254133/index.html">Prologue - a declarative language capable of solving any rebuses and proving theorems</a></li>
<li><a href="../254137/index.html">How is the IT reception in Mail.Ru Group</a></li>
<li><a href="../254141/index.html">Private, financial and other non-public information of Fl.ru users is still in free access.</a></li>
<li><a href="../254143/index.html">IT rounded shapes as a factor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>