<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Fastify and Preact for rapid prototyping of web applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The author of the material, the translation of which we are publishing today, wants to share a story about what technologies he uses for the rapid dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Fastify and Preact for rapid prototyping of web applications</h1><div class="post__text post__text-html js-mediator-article">  The author of the material, the translation of which we are publishing today, wants to share a story about what technologies he uses for the rapid development of prototypes of web applications.  These technologies include the Fastify and Preact libraries.  He also uses the htm library.  It seamlessly integrates with Preact and is used to describe DOM elements using clear constructions that resemble JSX.  At the same time to work with it you do not need a transpiler like Babel.  Demonstrating the prototype development toolkit and how to work with it, the author of the material will show how to package such applications in Docker containers.  This makes it easy to demonstrate applications to anyone who interests them. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/442652/"><img src="https://habrastorage.org/webt/iq/mq/4a/iqmq4a-j0p_qnlayhqdbmbb2au4.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Start</font> </h2><br>  I started using the above-mentioned set of technologies a few weeks ago when I needed to create a very simple prototype of a web application designed to test, together with my colleagues, some assumptions. <br><br>  My experiment was extremely successful.  I was able to create a prototype very quickly, my colleagues were able to conveniently experiment with it, they were able to quickly express their impressions of it.  At the same time, they could test the project even if Node.js and NPM were not installed on their computers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All this led me to the idea that I should write material about my approach to rapid prototyping of web applications.  It is possible that this approach will be useful to someone else.  For those who are already familiar with Fastify and Preact, I will immediately outline the most important thing that will allow them to immediately use my ideas in practice. <br><br><h2>  <font color="#3AC1EF">Main ideas</font> </h2><br>  If you are already familiar with Fastify and Preact and want to learn how to organize the development of projects based on these technologies, then you are literally a couple of steps from the desired.  Namely, we are talking about the execution of the following commands: <br><br><pre><code class="plaintext hljs">git clone https://github.com/lmammino/fastify-preact-htm-boilerplate.git my-new-project cd my-new-project rm -rf .git npm install</code> </pre> <br>  Of course, you can change the name of the project, <code>my-new-project</code> , to the name of your project. <br><br>  After installing everything you need, you can start working on the project.  Namely, we are talking about the following: <br><br><ul><li>  The <code>src/ui</code> folder contains the client-side files of the application (Preact and htm are used here). </li><li>  The <code>src/server</code> folder contains files related to the server part of the application (Fastify is used here). </li></ul><br>  By editing the corresponding files, you can run the project: <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  After that, you can try it by going to <code>localhost:3000</code> in your browser. <br><br>  And something else.  If you like my development, I will be immensely grateful for the asterisk on <a href="https://github.com/lmammino/fastify-preact-htm-boilerplate">GitHub</a> . <br><br>  Now let's look at the technologies used here and the features of working with them. <br><br><h2>  <font color="#3AC1EF">Fastify</font> </h2><br>  Fastify is a fast and economical web framework for Node.js.  This project was originally created by two programmers.  Now the team of those who work on it, has 10 people, more than 130 people help in the development of the project, he gathered almost 10,000 stars on GitHub. <br><br>  Fastify was influenced by Node.js frameworks, like Express and Hapi, which have been around for quite some time.  It was initially aimed at performance, at the convenience of programmers and at expanding its capabilities with the help of plug-ins.  This, by the way, is one of my favorite features of Fastify. <br><br>  If you are not familiar with the Fastify framework or want to know it better, I can recommend its official <a href="https://www.fastify.io/docs/">documentation</a> . <br><br>  It should be noted that I am related to Fastify.  I am a member of the main development team and I am mainly engaged in supporting the project site and working on its documentation. <br><br><h2>  <font color="#3AC1EF">Preact</font> </h2><br>  Preact is a library for developing user interfaces for web projects, which was created by one person as a compact and fast replacement for React.  This project was quite successful, it is now engaged in a whole team of developers, on GitHub, he scored more than 20,000 stars. <br><br>  One of the reasons I like Preact is that this library has an extensible layer describing the visual components of the application.  Under normal conditions, this library can be used with JSX in combination with Babel to translate code, but if you do not want to install Babel and customize the application build process, you can use Preact, for example, in conjunction with the <a href="https://github.com/developit/htm">htm</a> library, which uses template literals and does not require Transpilation when running projects in which it is used in modern browsers. <br><br>  We will use the htm library in this material and will soon consider a few examples. <br><br><h2>  <font color="#3AC1EF">Project Overview</font> </h2><br>  Here we look at the whole process of creating a project.  Our goal will be to develop a simple web application that displays information about the time on the server at the time of its launch.  Here, in order to make it clearer what we will strive for. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/9fe/c12/4d89fec1291d3ab9b66f7673af992d06.png"></div><br>  <i><font color="#999999">Application in browser</font></i> <br><br>  This is a single-page application (Single Page Application, SPA), in which Preact and htm are used to form its client part, and Fastify is used to create an API designed to get server time. <br><br>  The attentive reader may have noticed that the page shown in the previous figure has a pretty favicon icon.  True, he is very small there, so I'm going to make it easier for those who, trying to break his eyes, try to make out.  Here is his larger version. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaa/3a8/c3b/aaa3a8c3b25bba5f361af23d9af0f22b.jpg"></div><br>  <i><font color="#999999">Favicon</font></i> <br><br><h2>  <font color="#3AC1EF">Setting up the server side of the application</font> </h2><br>  Let's start with creating a new folder: <br><br><pre> <code class="plaintext hljs">mkdir server-time cd server-time</code> </pre> <br>  Now we initialize the NPM project and install Fastify: <br><br><pre> <code class="plaintext hljs">npm init -y npm i --save fastify@next fastify-static@next fastify-cli</code> </pre> <br>  Please note that when describing some dependency packages, I used the <code>@next</code> construction.  This is done to ensure that the project uses the Fastify 2 library, which is currently in the release candidate state, but will very soon become the main stable version. <br><br>  Please note that you can also create a new project based on Fastify using the command tool <code>fastify-cli</code> : <br><br><pre> <code class="plaintext hljs">npx fastify-cli generate server-time</code> </pre> <br>  While writing this material, this team creates a project designed to use Fastify 1.x, but very soon, after the release of Fastify 2, this tool will be updated. <br><br>  Let's analyze the installed packages: <br><br><ul><li>  <code>fastify</code> is the main component of the framework. </li><li>  <code>fastify-static</code> is an additional plugin that allows you to conveniently serve static files with the Fastify server. </li><li>  <code>fastify-cli</code> is a command-line tool that allows you to create projects based on Fastify. </li></ul><br>  At the moment we are ready to create an API based on Fastify.  So let's put the server code in the <code>src/server/server.js</code> : <br><br><pre> <code class="plaintext hljs">const path = require('path') module.exports = async function(fastify, opts) { //      `src/ui` fastify.register(require('fastify-static'), {   root: path.join(__dirname, '..', 'ui'), }) //     API fastify.get('/api/time', async (request, reply) =&gt; {   return { time: new Date().toISOString() } }) }</code> </pre> <br>  I believe that the above code explains itself well, but there are some interesting details that are worth telling.  This will be especially useful for those who have no experience with Fastify. <br><br>  The first thing you can notice in this code is that the <code>async</code> keyword is used here.  Fastify supports both async / await style development, and a more traditional callback based approach.  What exactly to choose depends on the preferences of a particular developer. <br><br>  Another interesting detail is that we define the server as an exported module here.  This module (called ‚Äúplugin‚Äù in the Fastify jargon) is a function that takes as an argument an instance of Fastify ( <code>fastify</code> ) and a set of options ( <code>opts</code> ).  Inside the module declaration, we can use a <code>fastify</code> instance for registering plugins.  This is what happens with the <code>fastify-static</code> plugin.  We can also describe HTTP endpoints using special methods like <code>fastify.get</code> and <code>fastify.post</code> . <br><br>  The modular approach used here, although it looks a bit unusual, has its advantages.  First we need to note that it allows you to combine multiple servers.  Imagine that you created a server designed to serve your blog, and another one for the forum.  They can be easily embedded in an existing application by attaching them to paths like <code>/blog</code> and <code>/forum</code> . <br><br>  Moreover, this approach allows abstraction of applications and sub-applications from server bindings (we are talking about, for example, binding of sockets), passing the solution to this problem either to the root application or <code>fastify-cli</code> . <br><br>  Start the server using the <code>fastify</code> command line <code>fastify</code> : <br><br><pre> <code class="plaintext hljs">node_modules/.bin/fastify start --log-level info src/server/server.js</code> </pre> <br>  In order to simplify your life, we can add this command to the <code>scripts</code> section of our <code>package.json</code> file: <br><br><pre> <code class="plaintext hljs">{ "scripts": {   "start": "fastify start --log-level info src/server/server.js" } }</code> </pre> <br>  Before actually starting the server, we need to make sure that there is a folder in which static resources will be located.  Otherwise, <code>fastify-static</code> will <code>fastify-static</code> error.  Create this folder: <br><br><pre> <code class="plaintext hljs">mkdir src/ui</code> </pre> <br>  Now we can start the application using the <code>npm start</code> command and navigate using the browser to the address <code>localhost:3000/api/time</code> . <br><br>  If everything works correctly, in the browser you will see something like the following: <br><br><pre> <code class="plaintext hljs">{ "time": "2019-02-17T19:32:03.354Z" }</code> </pre> <br>  At this point, you can appreciate another nice opportunity Fastify.  It lies in the fact that JSON serialization, in the event that a route returns an object, is applied automatically. <br><br>  Now work on the server API is complete.  Let's do the frontend. <br><br><h2>  <font color="#3AC1EF">Setting frontend</font> </h2><br>  All the code of our project related to the frontend will be in the <code>src/ui</code> folder.  It will consist of 5 files: <br><br><ul><li>  <code>app.js</code> - Preact application code. </li><li>  <code>bootstrap.min.css</code> - CSS code for styling the application (it is taken directly from the Bootstrap framework). </li><li>  <code>favicon.ico</code> - favicon file.  If you are developing a serious application, you cannot do without a good favicon file. </li><li>  <code>index.html</code> is the main HTML file of our one-page application. </li><li>  <code>preacthtm.js</code> - code for Preact and htm libraries. </li></ul><br>  To begin with, we place in the folder the files, which are styles, libraries and the favicon icon: <br><br><pre> <code class="plaintext hljs">curl "https://unpkg.com/htm@2.0.0/preact/standalone.js" &gt; src/ui/preacthtm.js curl "https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" &gt; src/ui/bootstrap.min.css curl "https://github.com/lmammino/fastify-preact-htm-boilerplate/blob/master/src/ui/favicon.ico?raw=true" &gt; src/ui/favicon.ico</code> </pre> <br>  Now create the file <code>src/ui/index.html</code> : <br><br><pre> <code class="plaintext hljs">&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt;   &lt;meta charset="utf-8" /&gt;   &lt;meta     name="viewport"     content="width=device-width, initial-scale=1, shrink-to-fit=no"   /&gt;   &lt;!-- Bootstrap CSS --&gt;   &lt;link rel="stylesheet" href="/bootstrap.min.css" /&gt;   &lt;title&gt;My awesome server time&lt;/title&gt; &lt;/head&gt; &lt;body&gt;   &lt;div id="app"&gt;&lt;/div&gt;   &lt;!-- JavaScript --&gt;   &lt;script src="/preacthtm.js"&gt;&lt;/script&gt;   &lt;script src="/app.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;</code> </pre> <br>  Before us is a completely normal HTML page, with which we load all resources (CSS and JS) and create an empty <code>&lt;div&gt;</code> element with the <code>app</code> identifier, into which we will output our application during the execution of the project. <br><br>  Now let's take a look at the application code, which should be in the <code>src/ui/app.js</code> : <br><br><pre> <code class="plaintext hljs">/*  htmPreact */ const { html, Component, render } = htmPreact class App extends Component { componentDidMount() {   this.setState({ loading: true, time: null })   fetch('/api/time')     .then(response =&gt; response.json())     .then(data =&gt; this.setState({ loading: false, time: data.time })) } render(props, state) {   return html`     &lt;div class="container mt-5"&gt;       &lt;div class="row justify-content-center"&gt;         &lt;div class="col"&gt;           &lt;h1&gt;Hello from your new App&lt;/h1&gt;           &lt;div&gt;             ${state.loading &amp;&amp;               html`                 &lt;p&gt;Loading time from server...&lt;/p&gt;               `} ${state.time &amp;&amp;               html`                 &lt;p&gt;Time from server: &lt;i&gt;&lt;font color="#999999"&gt;${state.time}&lt;/font&gt;&lt;/i&gt; &lt;/p&gt;               `}           &lt;/div&gt;           &lt;hr /&gt;           &lt;div&gt;             Have fun changing the code from this boilerplate:             &lt;ul&gt;               &lt;li&gt;UI code available at &lt;code&gt;/src/ui&lt;/code&gt;&lt;/li&gt;               &lt;li&gt;Server-side code available at &lt;code&gt;/src/server&lt;/code&gt;&lt;/li&gt;             &lt;/ul&gt;           &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   ` } } render( html`   &lt;${App} /&gt; `, document.getElementById('app') )</code> </pre> <br>  In this application, there is only one state component, called the <code>App</code> .  The state of this component includes 2 variables: <br><br><ul><li>  <code>loading</code> is a boolean variable used to indicate whether a request is made to a server API at some point in time to get information about server time. </li><li>  <code>time</code> - the string that contains the latest time information received from the server. </li></ul><br>  If you are familiar with React, then you can easily understand the above code. <br>  Using Preact and htm, we can create components by declaring classes that extend the built-in class <code>Component</code> . <br><br>  In this class, we can describe the behavior of a component using life-cycle methods, like <code>componentDidMount()</code> , and also use a method that behaves like a normal <code>render()</code> method from React. <br><br>  In our case, as soon as the component is attached to the page (the <code>componentDidMount()</code> method), we set the state <code>loading</code> property and execute an API request using <code>fetch</code> . <br>  After the request is completed, we set the value of the <code>time</code> state property and reset the <code>loading</code> property to <code>false</code> . <br><br>  The <code>render()</code> method is called automatically every time a component changes state or when new properties are passed to it.  In this method, we describe the DOM component using htm. <br><br>  The htm library allows you to describe DOM nodes using tagged template literals with a special tag - <code>html</code> .  Within our template literal, there may be dynamic expressions, like the ones we use to check the state and to decide what to display on the screen if the application loads data from the server, and if the data already uploaded. <br><br>  Another thing to note is that we need to create an instance of the application and display it on an HTML page.  This is done using the <code>render()</code> function of the global <code>htmPreact</code> object. <br><br>  Now the work on the front-end application is complete.  You can restart the server, go to <code>localhost:3000</code> and experiment with what we just created.  For example, you can develop something based on this application.  And when what you build seems interesting enough to show it to someone else, you will probably find it useful to pack your application in a Docker container. <br><br><h2>  <font color="#3AC1EF">Containerization application</font> </h2><br>  I think the best way to show off your new small projects to others is to use Docker features for this purpose. <br><br>  Thanks to Docker, anyone who tries to run your application in their own hands will be relieved of thinking about whether he has the right version of Node.js and NPM installed, he will not need to download the application‚Äôs source code to ensure that by entering the correct sequence of commands , install its dependencies and start the server. <br><br>  In order to package the application into the Docker container, we need to create a very simple <code>Dockerfile</code> file in the root folder of our project: <br><br><pre> <code class="plaintext hljs">FROM node:11-alpine WORKDIR /app COPY . /app RUN npm install --production EXPOSE 3000 CMD ["npm", "start"]</code> </pre> <br>  Here we describe the following actions: <br><br><ul><li>  The image is created based on the image of Node.js 11, built on the basis of Alpine Linux. </li><li>  Everything from the current folder is copied to the container <code>/app</code> folder. </li><li>  After that we run the <code>npm install</code> command to download and install dependencies.  The use of the <code>--production</code> flag results in the fact that only the dependencies necessary for the deployment of the project in production will be installed.  This speeds up image creation if the project uses many development dependencies. </li><li>  We point out that the container must have 3000 open, on which, by default, the server will work. </li><li>  As a result, we describe the command, <code>npm start</code> , which will be executed during container startup.  She runs the application. </li></ul><br>  In order to build an image for a container, execute the following command: <br><br><pre> <code class="plaintext hljs">docker build -t server-time .</code> </pre> <br>  After a few seconds, the image should be ready and you should be able to run the container: <br><br><pre> <code class="plaintext hljs">docker run -it -p 3000:3000 server-time</code> </pre> <br>  The <code>-p</code> allows you to configure the connection port of container 3000 to the local port 3000. This will allow you to access the containerized application at <code>localhost:3000</code> . <br>  Now you are ready to share your application with other people.  In order to run it in the Docker environment, it is enough, provided that Docker is installed on the computer, to execute the above two commands in its folder. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In this article, we talked about how to create an environment for the rapid development of web applications using Fastify and Preact.  In addition, we talked about how to share the application with other people using Docker. <br><br>  As mentioned above, the proposed tools are designed for rapid prototyping, so now you may be wondering what is missing here for developing real-world applications.  Most likely, you, speaking of "real applications", mean the following possibilities: <br><br><ul><li>  Compilation of the resources of the interface of the application: the creation of optimized files (bundles), possibly using Webpack, Babel, or other means. </li><li>  Routing in the interface part of the application. </li><li>  Server rendering. </li><li>  Means of permanent data storage. </li></ul><br>  All these possibilities for developing real-world applications have not yet been added to the set of technologies considered here, so for the time being I perceive it as a means for developing prototypes.  I am sure that if you liked what you saw, and you consider all this as the basis for future applications that solve real problems, you can easily find what you need and create, based on Fastify and Preact, applications that are ready for release in production. <br><br>  <b>Dear readers!</b>  How do you create web application prototypes? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/442652/">https://habr.com/ru/post/442652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442638/index.html">App-based Kubernetes metrics scaling from Prometheus</a></li>
<li><a href="../442640/index.html">Ideal bug: Using Type Confusion in Flash. Part 1</a></li>
<li><a href="../442642/index.html">What to read in March: 22 new books for marketers, managers, developers and designers</a></li>
<li><a href="../442644/index.html">Most developer value does not increase programming skills</a></li>
<li><a href="../442648/index.html">Memory allocation mechanisms in Go</a></li>
<li><a href="../442658/index.html">8 techniques for working with CSS: parallax, "sticky" footer and others</a></li>
<li><a href="../442660/index.html">Mathematics, reconciling Newton with the quantum world</a></li>
<li><a href="../442662/index.html">How to watch SDDL and not break your eyes on semicolons</a></li>
<li><a href="../442664/index.html">QIWI Kitchen February 6 - as it was + speaker reports</a></li>
<li><a href="../442668/index.html">Intel SGX Card. Every server is worth its SGX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>