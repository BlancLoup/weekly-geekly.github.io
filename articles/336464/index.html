<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dealing with complexity in an application layer network protocol</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever realized volume networking through TCP or HTTP? How much, in the case of such an experience, were you satisfied with the maintainability...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dealing with complexity in an application layer network protocol</h1><div class="post__text post__text-html js-mediator-article">  Have you ever realized volume networking through TCP or HTTP?  How much, in the case of such an experience, were you satisfied with the <i><a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B6%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2581%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">maintainability of the</a></i> final solution?  An affirmative answer to the first question (even if without the ‚Äúbulkiness‚Äù of the exchange) and dissatisfaction with the flexibility of the resulting implementation allow us to recommend this article as containing one of the ways to get rid of such a misfortune. <br><br>  The value of the publication, as it seems to the author, also lies in the fact that everything is illustrated not by the simplest educational example and a little reality-related example, but by a small part of the real solution from the same mobile application previously mentioned in <a href="https://habrahabr.ru/post/311658">another article</a> . <br><br>  It should be noted that <a href="http://docwiki.embarcadero.com/RADStudio/Berlin/en/Indy">Indy is</a> used in the program code of the article, however, although it may seem strange in the material on network interaction, knowledge of this library as such is not required from the reader, because the point is to get acquainted with more abstract, high-level techniques Protocol - it is more about design. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Task setting on fingers </h2><br>  A mobile application, one of the functions of which - called <b>synchronization</b> - formed the basis of the article, is, generally speaking, a shopping list: the user, creating a list of goods, goes with him to the store himself, or assigns this business to another person (or group of ), but then, in the second case, it is required to transfer this list first to the server (as centralized storage), and then to the target mobile devices ‚Äî it is at these moments that there is a need to use the network;  It should be emphasized that synchronization is two-way, i.e., editing made by any participant (not necessarily the author) will be reflected in all others.  As a vivid example, consider a hypothetical case when two ambitious amateur agronomists decided to implement one of their ideas, for which they needed to pre-purchase the necessary tools: <br><table><tbody><tr><th>  Act </th><th>  List author </th><th>  Second participant <br>  sync </th></tr><tr><td>  Create a list </td><td><ol><li>  Bucket </li><li>  Watering can </li><li>  Semolina 0.5 kg </li></ol></td><td></td></tr><tr><td>  Add member <br>  and subsequent <br>  synchronization </td><td><ol><li>  Bucket </li><li>  Watering can </li><li>  Semolina 0.5 kg </li></ol></td><td><ol><li>  Bucket </li><li>  Watering can </li><li>  Semolina 0.5 kg </li></ol></td></tr><tr><td>  Edit content </td><td><ol><li>  Bucket </li><li>  Watering can </li><li>  Semolina 0.5 kg </li><li>  <b>Rake</b> </li></ol></td><td><ol><li>  Bucket <b>2 pcs</b> </li><li>  Watering can </li><li>  Semolina <b>1</b> kg </li></ol></td></tr><tr><td>  Synchronization </td><td><ol><li>  Bucket 2 pcs </li><li>  Watering can </li><li>  Semolina 1 kg </li><li>  Rake </li></ol></td><td><ol><li>  Bucket 2 pcs </li><li>  Watering can </li><li>  Semolina 1 kg </li><li>  Rake </li></ol></td></tr></tbody></table>  Visually, on the device, the entire synchronization process is represented by an animated indicator and a cancel button: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/c8c/661/daa/c8c661daab8041e2b29caa0be88b3bd4.png" alt="The synchronization process on the device" width="350"></div><br><h2>  Formalization </h2><br>  The table with the example above is just a sketch, the most superficial description of what should happen during synchronization, therefore, it can never be used as a serious <abbr title="Technical specifications">TZ</abbr> , let alone write code on such a shaky ground.  A full-fledged <b>protocol</b> is required - a detailed, step-by-step and exhaustive description of the steps for interaction - who, what and for what sends over the network;  on the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_OSI">OSI model,</a> it will be at the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB%25D1%258B_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BA%25D0%25BB%25D0%25B0%25D0%25B4%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D1%2583%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BD%25D1%258F">application level</a> (or, in other words, the application level).  As an example, a small part of a real document is given, containing about 10% of all actions (the time axis is directed downwards): <br><a name="Protocol_description"></a><table><tbody><tr><th>  Customer </th><th>  Data </th><th>  Server </th></tr><tr><td>  <i>Defining lists for synchronization</i> </td><td></td><td></td></tr><tr><td>  ... </td><td></td><td></td></tr><tr><td>  <i>Synchronization of goods directory</i> </td><td></td><td></td></tr><tr><td>  ... </td><td></td><td></td></tr><tr><td>  <i>User Sync</i> </td><td></td><td></td></tr><tr><td>  ... </td><td></td><td></td></tr><tr><td>  <i>Sync lists:</i> </td><td></td><td></td></tr><tr><td>  <i>1. Adding to the server</i> </td><td></td><td></td></tr><tr><td>  ... </td><td></td><td></td></tr><tr><td>  <i>2. Adding to the client</i> </td><td></td><td></td></tr><tr><td>  ... </td><td></td><td></td></tr><tr><td>  <i>3. Exchange of changes</i> </td><td></td><td></td></tr><tr><td>  Transfer lists requiring exchange of changes;  first level of hierarchy. </td><td><ol><li>  List ID </li><li>  List hash </li><li>  Hash his descendants: <ul><li>  Of users </li><li>  Items </li></ul></li></ol></td><td></td></tr><tr><td></td><td></td><td>  Hash Analysis: </td></tr><tr><td></td><td>  Notification of matching hashes. </td><td>  1. All match - the <u>end of synchronization</u> . </td></tr><tr><td>  <u>End of sync.</u> </td><td></td><td></td></tr><tr><td></td><td>  Requirement to transfer: <br><ol><li>  List fields changed on the client - in case of a hash mismatch. </li><li>  Details on direct descendants - if the hash of descendants is different. </li></ol><br></td><td>  2. At least one does not match. </td></tr><tr><td>  Transfer the requested data.  The second level of the hierarchy. </td><td><ol><li>  Modified list fields (if required) </li><li>  Detailing by its users (if required): <ul><li>  ID </li><li>  Hash (if not deleted) </li><li>  Added (for own authorship only)? </li><li>  Removed (only for his authorship)? </li></ul></li><li>  Detailing by its elements (if required): <ul><li>  ID </li><li>  Hash (if not deleted) </li><li>  Hash his descendants - chat (if not removed). </li><li>  Removed? </li></ul></li></ol></td><td></td></tr><tr><td>  ... </td><td></td><td></td></tr></tbody></table>  For further understanding, it is not necessary to delve into all the nuances of the above fragment of the protocol - the main thing is to understand that there are actions on the client side (left column), there is data (middle column) obtained as a result of performing actions by one of the parties, which, strictly speaking, pass over the network, and there is a server side (right column) that performs some analysis and other work. <br><br><h2>  Solution to the forehead </h2><br><h3>  Transport </h3><br>  Before implementing the protocol, it is necessary to decide on the transport - the protocol of the same or lower level responsible for the physical transfer of data;  There are two obvious alternatives - HTTP and TCP (UDP, for an understandable reason - non-guaranteed delivery, cannot be used here).  In the end, the choice fell on the second option due to two reasons: TCP, due to its binary nature, gives complete freedom over all the transmitted data and, on the same basis, has better performance, which is not the last thing in a mobile project . <br><br><h3>  The first version of the code </h3><br>  Having chosen a transport, we will consider the conditional implementation of the protocol on the example of the client side, taking <code>TIdTCPClient</code> as a basis (there will be no fundamental differences on the server - there only the component will change to <code>TIdTCPServer</code> ).  Now and further, everything will be shown on a small part of the <a href="https://habr.com/ru/post/336464/">fragment</a> just quoted: <br><a name="Protocol_description_part"></a><table><tbody><tr><td>  ... </td><td></td><td></td></tr><tr><td>  <i>3. Exchange of changes</i> </td><td></td><td></td></tr><tr><td>  Transfer lists requiring exchange of changes;  first level of hierarchy. </td><td><ol><li>  List ID </li><li>  List hash </li><li>  Hash his descendants: <ul><li>  Of users </li><li>  Items </li></ul></li></ol></td><td></td></tr><tr><td></td><td></td><td>  Hash Analysis: </td></tr><tr><td></td><td>  Notification of matching hashes. </td><td>  1. All match - the <u>end of synchronization</u> . </td></tr><tr><td>  <u>End of sync.</u> </td><td></td><td></td></tr><tr><td>  ... </td><td></td><td></td></tr></tbody></table>  Suppose there is a simple form with three components: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TForm1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) TCPClient: TIdTCPClient; ButtonSync: TButton; StoredProcLists: TFDStoredProc; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonSyncClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  The following button handler contains strong simplifications and, as a result, some errors will not be compiled, but the essence of the initial, straightforwardly obvious approach is passed: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonSyncClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Handler: TIdIOHandler; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TCPClient.Connect; Handler := TCPClient.IOHandler; <span class="hljs-comment"><span class="hljs-comment">//     ... //    ... //   ... //  : // 1.    ... // 2.    ... // 3.   //  ,   . StoredProcLists.Open; Handler.Write(StoredProcLists.RecordCount); while not StoredProcLists.Eof do begin Handler.Write( StoredProcLists.FieldByName('ListID').AsInteger ); Handler.Write( Length(StoredProcLists.FieldByName('ListHash').AsBytes) ); Handler.Write( StoredProcLists.FieldByName('ListHash').AsBytes ); Handler.Write( Length(StoredProcLists.FieldByName('ListUsersHash').AsBytes) ); Handler.Write( StoredProcLists.FieldByName('ListUsersHash').AsBytes ); Handler.Write( Length(StoredProcLists.FieldByName('ListItemsHash').AsBytes) ); Handler.Write( StoredProcLists.FieldByName('ListItemsHash').AsBytes ); StoredProcLists.Next; end; StoredProcLists.Close; //    . if Handler.ReadByte = 1 then //  ? ... //  -  . else ... //  -   . TCPClient.Disconnect; end;</span></span></code> </pre><br>  It is necessary to emphasize again that the given piece is much lighter in comparison with the original code from the application - therefore, in fact, this event, for the complete protocol, will grow to many thousands of lines.  If the volume is not so (up to several hundred lines), then it is quite possible to simply break it up into methods or local procedures according to the main stages and stop there, but not in this case - the scale introduces serious problems: <br><br><ul><li>  Soiling, blurring the structure of the protocol, its logical stages and transmitted data, which will make it extremely difficult to refine in the future. </li><li>  Binding to a specific network library (Indy): in the case of its change, it will require serious work on scrupulously combing the entire amount of code that is fraught with errors. </li><li>  A similar binding not only to the data source ( <abbr title="Database">DB</abbr> ), but also to the components of access to them ( <a href="http://docwiki.embarcadero.com/RADStudio/Berlin/en/FireDAC">FireDAC</a> ) - this causes the same problem. </li></ul><br>  Further narrative will suggest ways to eliminate these shortcomings. <br><br><h2>  First approach </h2><br><h3>  Protocol </h3><br>  The basic idea of ‚Äã‚Äãhelping to deal with the volume and the complexity resulting from this is not new - it is the introduction of abstractions reflecting the ‚Äúsubject area‚Äù: in this case, such is network interaction, therefore such a programmatic generalization as a <b>protocol</b> will be introduced first;  its implementation, as it is easy to guess, will be based on classes, which in turn will be grouped in modules, and the first of them will be <code>Net.Protocol</code> (blurry others will be added as needed): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f92/1f8/336/f921f8336d8f4b99bda3efc21fd06749.png" alt="New Net.Protocol Module" width="750"></div><br>  Since the term protocol has already been used, to avoid confusion, the table <a href="https://habr.com/ru/post/336464/">above</a> will be called a <i>protocol description</i> .  It should also be noted that while all modules are not divided into client and server modules, they are irrespective of the exchange side, common. <br><br>  Initially, the protocol is described by a fairly simple code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Net.Protocol; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> IdIOHandler; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TNetTransport = TIdIOHandler; TNetProtocol = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> FTransport: TNetTransport; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transport: TNetTransport)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TNetProtocol</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transport: TNetTransport)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FTransport := Transport; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  The key <code>RunExchange</code> method <code>RunExchange</code> designed to start a network exchange, that is, all those steps that are present in the protocol description.  The constructor, on the other hand, accepts the object that is directly responsible for the physical delivery, the very transport that, as mentioned earlier, is TCP, represented in this case by Indy components. <br><br>  If we now rewrite the very first version of the code, then it will become quite compact (in it the <code>TClientProtocol</code> is the successor of <code>TNetProtocol</code> ): <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonSyncClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Protocol: TClientProtocol; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TCPClient.Connect; Protocol := TClientProtocol.Create(TCPClient.IOHandler); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> Protocol.RunExchange; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> Protocol.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TCPClient.Disconnect; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Such a modification, of course, does not solve any of the indicated problems yet - this will be achieved by other means. <br><br><h3>  Package </h3><br>  The second abstraction, which will be used already in the implementation of the protocol, is a data <b>packet</b> (hereinafter referred to as a packet) - it will be responsible for the manipulation of the network.  If you look at the following description fragment, 2 packages correspond to it (highlighted in color; the first one is sent by the client, the second by the server): <br><table><tbody><tr><td>  ... </td><td></td><td></td></tr><tr><td>  <i>3. Exchange of changes</i> </td><td></td><td></td></tr><tr><td>  Transfer lists requiring exchange of changes;  first level of hierarchy. </td><td><ol><li>  List ID </li><li>  List hash </li><li>  Hash his descendants: <ul><li>  Of users </li><li>  Items </li></ul></li></ol></td><td></td></tr><tr><td></td><td></td><td>  Hash Analysis: </td></tr><tr><td></td><td>  <font color="#ae009e">Notification of matching hashes.</font> </td><td>  1. All match - the <u>end of synchronization</u> . </td></tr><tr><td>  <u>End of sync.</u> </td><td></td><td></td></tr><tr><td>  ... </td><td></td><td></td></tr></tbody></table>  The package code is also simple and highlighted in the new <code>Net.Packet</code> module: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/554/c67/73a/554c6773afdc4ff9b7b66fa235ca23fa.png" alt="New Net.Packet module" width="380"></div><br><a name="TPacket"></a><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Net.Packet; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Net.Protocol; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TPacket = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TPacketKind = UInt16; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> FTransport: TNetTransport; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kind</span></span></span><span class="hljs-function">:</span></span> TPacketKind; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transport: TNetTransport)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPacket</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Transport: TNetTransport)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FTransport := Transport; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPacket</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FTransport.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(Kind); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPacket</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ActualKind: TPacketKind; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ActualKind := FTransport.ReadUInt16; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Kind &lt;&gt; ActualKind <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">//    . ... end; end.</span></span></code> </pre><br>  The main methods of the packet are 2 methods: <code>Send</code> - it is used by the sender, and <code>Receive</code> is called by the receiving party;  Transport constructor receives from the protocol.  The <code>Kind</code> method is designed to identify specific successor packets and allows you to make sure that you have exactly expected. <br><br>  After describing the abstract package, we define a couple of those that will be directly used in the above <a href="https://habr.com/ru/post/336464/">description of the protocol</a> and contain useful data, for which we will declare a new module: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f50/178/475/f50178475a0940a289709f4309813767.png" alt="New Sync.Packets Module" width="380"></div><br><a name="Sync_Packets"></a><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Sync.Packets; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> System.Generics.Collections, Net.Packet; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TListHashesPacket</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPacket) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PacketKind = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> THashes = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FHash: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; FItemsHash: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; FUsersHash: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Hash: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FHash <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FHash; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> UsersHash: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FUsersHash <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FUsersHash; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> ItemsHash: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FItemsHash <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FItemsHash; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TListHashes = TObjectDictionary&lt;Integer, THashes&gt;; <span class="hljs-comment"><span class="hljs-comment">//   - ID . private FHashes: TListHashes; protected function Kind: TPacket.TPacketKind; override; public property Hashes: TListHashes read FHashes write FHashes; end; TListHashesResponsePacket = class(TPacket) private const PacketKind = 2; private FHashesMatched: Boolean; protected function Kind: TPacket.TPacketKind; override; public property HashesMatched: Boolean read FHashesMatched write FHashesMatched; end; //   . ... implementation function TListHashesPacket.Kind: TPacket.TPacketKind; begin Result := PacketKind; end; function TListHashesResponsePacket.Kind: TPacket.TPacketKind; begin Result := PacketKind; end; end.</span></span></code> </pre><br>  As you can see, neither these 2 packets, nor their ancestor, <code>TPacket</code> , contain the code that sends and receives data stored in the properties ( <code>Hashes</code> and <code>HashesMatched</code> in this case), however, showing the way to ensure this is a matter of the near future, but for now suppose that in some miraculous way everything works. <br><br><h3>  Protocol implementation </h3><br>  To demonstrate how the protocol uses packets, you need to enter 2 more modules - this time divisible into client and server, unlike all previous ones, is <code>Sync.Protocol.Client</code> and <code>Sync.Protocol.Server</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/edb/5ee/125/edb5ee125d924704927b969889a74e6f.png" alt="New modules Sync.Protocol.Client and Sync.Protocol.Server" width="750"></div><br>  By their name, it is clear which implementation they represent. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Sync.Protocol.Client; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Net.Protocol; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TClientProtocol</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TNetProtocol) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendListHashes</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListHashesMatched</span></span></span><span class="hljs-function">:</span></span> Boolean; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Sync.Packets; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TClientProtocol</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">// 3.   SendListHashes; if ListHashesMatched then //  ? ... //  -  . else ... //  -   . end; procedure TClientProtocol.SendListHashes; var ListHashesPacket: TListHashesPacket; begin ListHashesPacket := TListHashesPacket.Create(FTransport); try //  ListHashesPacket.Hashes   . ... ListHashesPacket.Send; finally ListHashesPacket.Free; end; end; function TClientProtocol.ListHashesMatched: Boolean; var ListHashesResponsePacket: TListHashesResponsePacket; begin ListHashesResponsePacket := TListHashesResponsePacket.Create(FTransport); try ListHashesResponsePacket.Receive; Result := ListHashesResponsePacket.HashesMatched; finally ListHashesResponsePacket.Free; end; end; end.</span></span></code> </pre><br>  And the paired module: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Sync.Protocol.Server; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Net.Protocol; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TServerProtocol</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TNetProtocol) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListHashesMatched</span></span></span><span class="hljs-function">:</span></span> Boolean; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Sync.Packets; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TServerProtocol</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">// 3.   if ListHashesMatched then //  ? ... //  -  . else ... //  -   . end; function TServerProtocol.ListHashesMatched: Boolean; var ClientListHashesPacket: TListHashesPacket; ListHashesResponsePacket: TListHashesResponsePacket; begin ClientListHashesPacket := TListHashesPacket.Create(FTransport); try ClientListHashesPacket.Receive; ListHashesResponsePacket := TListHashesResponsePacket.Create(FTransport); try //  ClientListHashesPacket.Hashes    , //  ListHashesResponsePacket.HashesMatched. ... ListHashesResponsePacket.Send; Result := ListHashesResponsePacket.HashesMatched; finally ListHashesResponsePacket.Free; end; finally ClientListHashesPacket.Free; end; end; end.</span></span></code> </pre><br><h2>  Final option </h2><br>  The previous sections only prepared the ground, created a framework for solving the problems indicated at the very beginning - it is now possible to start them, starting with access to the data. <br><br><h3>  Data </h3><br>  Just now, when implementing the protocols of both sides, the following code was encountered: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//  ListHashesPacket.Hashes   . ... ListHashesPacket.Send;</span></span></code> </pre><br>  and <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//  ClientListHashesPacket.Hashes    , //  ListHashesResponsePacket.HashesMatched. ... ListHashesResponsePacket.Send;</span></span></code> </pre><br>  To replace the given comments with real code, it is proposed to apply such a design pattern as a <b><a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D1%2581%25D0%25B0%25D0%25B4_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">facade</a></b> : instead of manipulating data directly, the protocol will only have the task of calling its high-level methods that implement any arbitrarily complex and voluminous actions to communicate with the database;  To do this, create the module <code>Sync.DB</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/280/6f1/202/2806f1202d0b42dc80d71ff8339fa278.png" alt="New Sync.DB Module" width="380"></div><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Sync.DB; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> FireDAC.Comp.Client; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TDBFacade = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> FConnection: TFDConnection; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTransaction</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommitTransaction</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RollbackTransaction</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TDBFacade</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FConnection := TFDConnection.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TDBFacade</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FConnection.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TDBFacade</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTransaction</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FConnection.StartTransaction; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TDBFacade</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommitTransaction</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FConnection.Commit; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TDBFacade</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RollbackTransaction</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FConnection.Rollback; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  The only <code>TDBFacade</code> class declared here contains 3 methods necessary for all his heirs to work with transactions (with a trivial code) and a field for a physical connection to the database ‚Äî there is little interesting, so let's immediately consider the implementation of the client and server facades, which are already introduced by methods specific for each of the parties. : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ccf/ba4/cb0/ccfba4cb04ed47a0a193ac67aa92a21d.png" alt="New modules Sync.DB.Client and Sync.DB.Server" width="750"></div><br>  Client facade: <br><br><a name="Facades"></a><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Sync.DB.Client; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Sync.DB, Sync.Packets; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TClientDBFacade</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TDBFacade) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcListHashes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Hashes: TListHashesPacket.TListHashes)</span></span></span><span class="hljs-function">;</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> FireDAC.Comp.Client; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TClientDBFacade</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcListHashes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Hashes: TListHashesPacket.TListHashes)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> StoredProcHashes: TFDStoredProc; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> StoredProcHashes := TFDStoredProc.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//  StoredProcHashes. ... StoredProcHashes.Open; while not StoredProcHashes.Eof do begin //  Hashes. ... StoredProcHashes.Next; end; finally StoredProcHashes.Free; end; end; end.</span></span></code> </pre><br>  And server: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Sync.DB.Server; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Sync.DB, Sync.Packets; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TServerDBFacade</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TDBFacade) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareListHashes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ClientHashes: TListHashesPacket.TListHashes)</span></span></span><span class="hljs-function">:</span></span> Boolean; ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> FireDAC.Comp.Client; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TServerDBFacade</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareListHashes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ClientHashes: TListHashesPacket.TListHashes)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> StoredProcHashes: TFDStoredProc; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := True; StoredProcHashes := TFDStoredProc.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//  StoredProcHashes. ... StoredProcHashes.Open; //   . while not StoredProcHashes.Eof do begin Result := Result and {       ClientHashes?}; StoredProcHashes.Next; end; finally StoredProcHashes.Free; end; end; end.</span></span></code> </pre><br>  If the reader, using the example of the client facade, it seems that the <code>CalcListHashes</code> method <code>CalcListHashes</code> quite simple and there is almost no sense in taking all the database work from the protocol into it, then it is recommended to compare the strong simplification presented here with <br><br><div class="spoiler">  <b class="spoiler_title">real code from the application.</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TClientSyncDBFacade</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcListHashes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Hashes: TListHashesPacket.THashesCollection)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Lists: TList&lt;TLocalListID&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareListsToHashing</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> PrepareStoredProcedureToWork(SyncPrepareListsToHashingProcedure); FStoredProcedure.Open; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FStoredProcedure.Eof <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Lists.Add( FStoredProcedure[<span class="hljs-string"><span class="hljs-string">'LIST_ID'</span></span>] ); FStoredProcedure.Next; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcTotalChildHashes</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ListID: TLocalListID; TotalUsersHash, TotalItemsHash: TMD5Hash; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ListID <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Lists <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> PrepareStoredProcedureToWork(SyncSelectListUsersForHashingProcedure); FStoredProcedure.ParamByName(<span class="hljs-string"><span class="hljs-string">'LIST_ID'</span></span>).Value := ListID; TotalUsersHash := CalcTotalHashAsBytes( FStoredProcedure, [<span class="hljs-string"><span class="hljs-string">'USER_AS_STRING'</span></span>] ); PrepareStoredProcedureToWork(SyncSelectListItemAndItemMessagesHashProcedure); FStoredProcedure.ParamByName(<span class="hljs-string"><span class="hljs-string">'LIST_ID'</span></span>).Value := ListID; TotalItemsHash := CalcTotalHashAsBytes( FStoredProcedure, [<span class="hljs-string"><span class="hljs-string">'ITEM_HASH'</span></span>, <span class="hljs-string"><span class="hljs-string">'ITEM_MESSAGES_HASH'</span></span>] ); PrepareStoredProcedureToWork(SyncAddTotalListHashesProcedure); FStoredProcedure.ParamByName(<span class="hljs-string"><span class="hljs-string">'LIST_ID'</span></span>).Value := ListID; FStoredProcedure.ParamByName(<span class="hljs-string"><span class="hljs-string">'TOTAL_USERS_HASH'</span></span>).AsHash := TotalUsersHash; FStoredProcedure.ParamByName(<span class="hljs-string"><span class="hljs-string">'TOTAL_ITEMS_HASH'</span></span>).AsHash := TotalItemsHash; FStoredProcedure.ExecProc; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillHashes</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ListHashes: TListHashesPacket.THashes; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> PrepareStoredProcedureToWork(SyncSelectListHashesProcedure); FStoredProcedure.Open; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FStoredProcedure.Eof <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ListHashes := TListHashesPacket.THashes.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ListHashes.Hash := HashToString( FStoredProcedure.FieldByName(<span class="hljs-string"><span class="hljs-string">'LIST_HASH'</span></span>).AsHash ); ListHashes.UsersHash := HashToString( FStoredProcedure.FieldByName(<span class="hljs-string"><span class="hljs-string">'LIST_USERS_HASH'</span></span>).AsHash ); ListHashes.ItemsHash := HashToString( FStoredProcedure.FieldByName(<span class="hljs-string"><span class="hljs-string">'LIST_ITEMS_HASH'</span></span>).AsHash ); <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ListHashes.DisposeOf; <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Hashes.Add( FStoredProcedure.FieldByName(<span class="hljs-string"><span class="hljs-string">'LIST_GLOBAL_ID'</span></span>).AsUUID, ListHashes ); FStoredProcedure.Next; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Lists := TList&lt;TLocalListID&gt;.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> PrepareListsToHashing; CalcRecordHashes(TListHashes); CalcRecordHashes(TListItemHashes); CalcRecordHashes(TListItemMessagesHashes); CalcTotalChildHashes; FillHashes; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> Lists.DisposeOf; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre></div></div><br>  I would like to dwell on one thing: both facades import the <code>Sync.Packets</code> module and then use the packages announced in it - this creates a strong <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">adhesion</a> between them, which is generally undesirable, since the facade and the packages are designed to be used by the protocol and know each other about a friend they absolutely no reason.  If the application were large, on which many developers would work, the coupling simply needed to be reduced, replacing the package-specific types in the facade methods with other, more general ones, such as the ‚Äúabstract list of lists‚Äù, but would have to pay for all this with increased complexity;  the current trade-off quite adequately distributes the risk, taking into account the small scale of the project. <br><br><h3>  The final form of the protocol </h3><br>  After the introduction of the facade, all protocol methods will take the final, stable form: <br><br><a name="TClientProtocol_final"></a><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Sync.Protocol.Client; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Net.Protocol, Sync.DB.Client; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TClientProtocol</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TNetProtocol) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FDBFacade: TClientDBFacade; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendListHashes</span></span></span><span class="hljs-function">;</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Sync.Packets; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TClientProtocol</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; FDBFacade.StartTransaction; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ... <span class="hljs-comment"><span class="hljs-comment">// 3.   SendListHashes; if ListHashesMatched then //  ? ... //  -  . else ... //  -   . FDBFacade.CommitTransaction; except FDBFacade.RollbackTransaction; raise; end; end; procedure TClientProtocol.SendListHashes; var ListHashesPacket: TListHashesPacket; begin ListHashesPacket := TListHashesPacket.Create(FTransport); try FDBFacade.CalcListHashes(ListHashesPacket.Hashes); ListHashesPacket.Send; finally ListHashesPacket.Free; end; end; ... end.</span></span></code> </pre><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Sync.Protocol.Server; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Net.Protocol, Sync.DB.Server; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TServerProtocol</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TNetProtocol) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FDBFacade: TServerDBFacade; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListHashesMatched</span></span></span><span class="hljs-function">:</span></span> Boolean; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Sync.Packets; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TServerProtocol</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunExchange</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; FDBFacade.StartTransaction; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ... <span class="hljs-comment"><span class="hljs-comment">// 3.   if ListHashesMatched then //  ? ... //  -  . else ... //  -   . FDBFacade.CommitTransaction; except FDBFacade.RollbackTransaction; raise; end; end; function TServerProtocol.ListHashesMatched: Boolean; var ClientListHashesPacket: TListHashesPacket; ListHashesResponsePacket: TListHashesResponsePacket; begin ClientListHashesPacket := TListHashesPacket.Create(FTransport); try ClientListHashesPacket.Receive; ListHashesResponsePacket := TListHashesResponsePacket.Create(FTransport); try ListHashesResponsePacket.HashesMatched := FDBFacade.CompareListHashes(ClientListHashesPacket.Hashes); ListHashesResponsePacket.Send; Result := ListHashesResponsePacket.HashesMatched; finally ListHashesResponsePacket.Free; end; finally ClientListHashesPacket.Free; end; end; end.</span></span></code> </pre><br><h3>  Refinement package </h3><br>  To complete the entire erected construction, it remains to drive the last, but very important, nail - to teach the package to transmit useful information, but this task is conveniently divided into two components (using the sending example): <br><br><ul><li>  you first need to <b>pack</b> ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">serialize</a> ) the data in a form suitable for transmission over the network; </li><li>  then you must perform the physical shipment of the packaged. </li></ul><br>  Packaging can be done differently: in a certain binary form, in XML, in JSON, etc. Since mobile devices do not have rich resources, it was the latter that was chosen, the JSON option, which requires less computational processing costs (compared to XML );  To implement the chosen path, add 2 methods to <a href="https://habr.com/ru/post/336464/"><code>TPacket</code></a> : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Net.Packet; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Net.Protocol, System.JSON; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TPacket = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PackToJSON</span></span></span><span class="hljs-function">:</span></span> TJSONObject; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnpackFromJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> JSON: TJSONObject)</span></span></span><span class="hljs-function">;</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Their implementation is not given, because 2 ways are possible: methods are declared protected and virtual and all the packages are inherited individually, depending on the properties added to them with data, they are packaged in JSON and unpacked from it, or the second option is that the methods remain private here) and contain code for automatic conversion to JSON, which completely eliminates offspring from "logistic" concerns.  The first option is valid for cases when the number of packages and their complexity are small (up to a dozen pieces, with the properties of the simplest types), but if the bill goes to large quantities, there are 32 of them in the author‚Äôs project, and the complexity is quite high, as for example <br><br><div class="spoiler">  <b class="spoiler_title">such a package</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TListPacket</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TStreamPacket) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TPhoto</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPackableObject) <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FSortOrder: Int16; FItemMessageID: TItemMessageID; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> ItemMessageID: TItemMessageID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FItemMessageID <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FItemMessageID; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> SortOrder: Int16 <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FSortOrder <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FSortOrder; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TPhotos = TStandardPacket.TPackableObjectDictionary&lt;TMessagePhotoID, TPhoto&gt;; <span class="hljs-title"><span class="hljs-title">TMessage</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPackableObject) <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FAuthor: TUserID; FAddDate: TDateTime; FText: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; FListItemID: TListItemID; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> ListItemID: TListItemID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FListItemID <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FListItemID; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Author: TUserID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FAuthor <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FAuthor; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> AddDate: TDateTime <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FAddDate <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FAddDate; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Text: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FText <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FText; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TMessages = TStandardPacket.TPackableObjectDictionary&lt;TItemMessageID, TMessage&gt;; <span class="hljs-title"><span class="hljs-title">TListDescendant</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPackableObject) <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FListID: TListID; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> ListID: TListID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FListID <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FListID; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-title"><span class="hljs-title">TItem</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TListDescendant) <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FAddDate: TDateTime; FAmount: TAmount; FEstimatedPrice: Currency; FExactPrice: Currency; FStandardGoods: TID; FInTrash: Boolean; FUnitOfMeasurement: TID; FStrikeoutDate: TDateTime; FCustomGoods: TGoodsID; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> StandardGoods: TID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FStandardGoods <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FStandardGoods; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> CustomGoods: TGoodsID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FCustomGoods <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FCustomGoods; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Amount: TAmount <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FAmount <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FAmount; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> UnitOfMeasurement: TID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FUnitOfMeasurement <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FUnitOfMeasurement; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EstimatedPrice: Currency <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEstimatedPrice <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEstimatedPrice; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> ExactPrice: Currency <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FExactPrice <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FExactPrice; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> AddDate: TDateTime <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FAddDate <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FAddDate; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> StrikeoutDate: TDateTime <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FStrikeoutDate <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FStrikeoutDate; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> InTrash: Boolean <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FInTrash <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FInTrash; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TItems = TStandardPacket.TPackableObjectDictionary&lt;TListItemID, TItem&gt;; <span class="hljs-title"><span class="hljs-title">TUser</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TListDescendant) <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FUserID: TUserID; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> UserID: TUserID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FUserID <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FUserID; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TUsers = TStandardPacket.TPackableObjectList&lt;TUser&gt;; <span class="hljs-title"><span class="hljs-title">TList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPackableObject) <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; FAuthor: TUserID; FAddDate: TDateTime; FDeadline: TDate; FInTrash: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Author: TUserID <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FAuthor <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FAuthor; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> AddDate: TDateTime <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FAddDate <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FAddDate; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Deadline: TDate <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FDeadline <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FDeadline; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> InTrash: Boolean <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FInTrash <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FInTrash; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TLists = TStandardPacket.TPackableObjectDictionary&lt;TListID, TList&gt;; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FLists: TLists; FMessages: TMessages; FItems: TItems; FUsers: TUsers; FPhotos: TPhotos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Lists: TLists <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FLists <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FLists; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Users: TUsers <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FUsers <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FUsers; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Items: TItems <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FItems <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FItems; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Messages: TMessages <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FMessages <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FMessages; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Photos: TPhotos <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FPhotos <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> SetPhotos; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> </div></div><br>  it‚Äôs already extremely reckless to do without automation of the packaging process.  ,    <a href="http://docwiki.embarcadero.com/RADStudio/Berlin/en/Working_with_RTTI">RTTI</a> ,         ,       ,  -    . <br><br>     JSON-    <a href="https://habr.com/ru/post/336464/"><code>TListHashesPacket</code></a> ,             : <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-number"><span class="hljs-number">16</span></span>: { Hash: <span class="hljs-string"><span class="hljs-string">"d0860029f1400147deef86d3246d29a4"</span></span>, UsersHash: <span class="hljs-string"><span class="hljs-string">"77febf816dac209a22880c313ffae6ad"</span></span>, ItemsHash: <span class="hljs-string"><span class="hljs-string">"1679091c5a880faf6fb5e6087eb1b2dc"</span></span> }, <span class="hljs-number"><span class="hljs-number">38</span></span>: { Hash: <span class="hljs-string"><span class="hljs-string">"81c8061686c10875781a2b37c398c6ab"</span></span>, UsersHash: <span class="hljs-string"><span class="hljs-string">"d3556bff1785e082b1508bb4e611c012"</span></span>, ItemsHash: <span class="hljs-string"><span class="hljs-string">"0e3a37aa85a14e359df74fa77eded3f6"</span></span> } }</code> </pre><br>        ‚Äì       <a href="https://habr.com/ru/post/336464/"><code>TPacket</code></a> : <br><br><a name="TPacket_Send_Receive"></a><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> Net.Packet; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> System.SysUtils, IdGlobal; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPacket</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DataLength: Integer; RawData: TBytes; JSON: TJSONObject; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FTransport.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(Kind); JSON := PackToJSON; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> SetLength(RawData, JSON.EstimatedByteSize); DataLength := JSON.ToBytes( RawData, Low(RawData) ); FTransport.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(DataLength); FTransport.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>( TIdBytes(RawData), DataLength ); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> JSON.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPacket</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ActualKind: TPacketKind; DataLength: Integer; RawData: TBytes; JSON: TJSONObject; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ActualKind := FTransport.ReadUInt16; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Kind &lt;&gt; ActualKind <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">//    . ... DataLength := FTransport.ReadInt32; FTransport.ReadBytes( TIdBytes(RawData), DataLength, False ); JSON := TJSONObject.Create; try JSON.Parse(RawData, 0); UnpackFromJSON(JSON); finally JSON.Free; end; end; ... end.</span></span></code> </pre><br><h2>  Conclusion </h2><br>           ?      ,  <a href="https://habr.com/ru/post/336464/"></a> ,        ,          ,       .           3  ( ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/45f/26c/8a1/45f26c8a13ea4d318ff73e2ba1f594a9.png" alt=" Net.Packet,   Sync.DB.Client  Sync.DB.Server" width="750"></div><br>  ,   Indy        <a href="https://habr.com/ru/post/336464/">2 </a>  <code>TPacket</code> ‚Äì <code>Send</code>  <code>Receive</code> ,   FireDAC     (       )     <a href="https://habr.com/ru/post/336464/"></a> ,      . <br><br>   ,   ,     ,       , . .        ‚Äì  :     , , ,          ,          (          );      ‚Äì        ,        .               ‚Äì  ,       (    ,   ). </div><p>Source: <a href="https://habr.com/ru/post/336464/">https://habr.com/ru/post/336464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336452/index.html">7 Tips for a UX Machine Learner</a></li>
<li><a href="../336456/index.html">The story of the apocalypse of Runet and Yashka, the heir of Yandex</a></li>
<li><a href="../336458/index.html">Ideas about new features of ordinary / parallel programming (extension C ++)</a></li>
<li><a href="../336460/index.html">Talk about Virtual Reality. Conversation number 1. Really about Virtuality</a></li>
<li><a href="../336462/index.html">Dagger 2.11 & Android. Part 2</a></li>
<li><a href="../336466/index.html">We check the browser for support of certain CSS properties</a></li>
<li><a href="../336468/index.html">Creating a programming language using LLVM. Part 7: Language Expansion: Variable Variables</a></li>
<li><a href="../336470/index.html">Why GitHub can't host the Linux kernel</a></li>
<li><a href="../336474/index.html">Work and life in Bulgaria</a></li>
<li><a href="../336476/index.html">Desktop GUI tests in Python. Lecture in Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>