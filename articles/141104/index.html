<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Summary of the monograph on λ-calculus</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This text is an extremely concise summary of the classical monograph on the λ-calculus (H. Barendregt, "Lambda-calculus. Its syntax and semantics", tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Summary of the monograph on λ-calculus</h1><div class="post__text post__text-html js-mediator-article">  This text is an extremely concise summary of the classical monograph on the λ-calculus (H. Barendregt, "Lambda-calculus. Its syntax and semantics", translated from English by G. E. Mints, edited by A. Kuzicheva, Moscow, "World" , 1985).  It may be of interest to all those who planned to undertake a systematic study of this topic, having familiarized with it in general terms, but postponed due to the complex structure of the main monograph, the definitions and main results in which are rather fragmented.  Here we will try to make the presentation, on the contrary, absolutely linear, and, of course, incomparably shorter, avoiding unnecessary definitions and examples, and focusing on the necessary terminology, notation and statements, which, in turn, are set out close to the original text.  We begin by defining the system λβη, that is, the classical typeless extensional λ-calculus.  Then we proceed to combinatorial logic, the fixed point theorem and syntactic sugar.  Finally, the final part of the abstract is the construction of a topology on the expressions of this system, designed to explain the apparent contradiction: the representations of the set of expressions in themselves are contained in the set itself with its countability.  In fact, a set is endowed with a proper topology, in which expressions are continuous mappings. <a name="habracut"></a><br><br><h4>  Theory </h4><br>  The set of λ- <i>expressions</i> Λ is constructed inductively from <i>variables</i> <br><br>  x, y, z ... ∈ Λ 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      using <i>abstractions</i> <br><br>  M ∈ Λ ⇒ λx.M ∈ Λ <br><br>  and <i>applications</i> <br><br>  M, N ∈ Λ ⇒ MN ∈ Λ, <br><br>  while the application is left-associative: <br><br>  (M) ≣ M, MNP ≣ (MN) P. <br><br>  The reflexive transitive relation Μ ⊂ N means that M is a <i>subexpression of the</i> expression N: <br><br>  M ⊂ M ⊂ λx.M; <br>  M ⊂ MN ⊃ N; <br>  M ⊂ N ∧ N ⊂ P ⇒ M ⊂ P. <br><br>  FV (M) is the set of <i>free</i> variables in the expression M: <br><br>  FV (x) ≣ {x}; <br>  FV (λx.M) ≣ FV (M) ∖ {x}; <br>  FV (MN) ≣ FV (M) ∪ FV (N). <br><br>  Variables that are not free are called <i>bound</i> and can be replaced with another variable (this conversion is called α-conversion): <br><br>  y ∉ FV (M) ⇒ λx.M ≣ λy.M [x: = y], where M [x: = N] is the result of the <i>substitution</i> : <br><br>  x [x: = P] ≣ P; <br>  y [x: = P] ≣ y; <br>  (λx.M) [x: = P] ≣ λx.M; <br>  (λy.M) [x: = P] ≣ λy.M [x: = P]; <br>  (MN) [x: = P] ≣ M [x: = P] N [x: = P]. <br><br>  In the fourth paragraph, it is not necessary to specifically stipulate the condition "x ≢ y and y FV (P)", since it is fulfilled by virtue of the agreement on variables: if the terms M <sub>1</sub> , ..., M <sub>n</sub> occur in a specific mathematical context, then it is assumed that related variables in them are chosen so that they are different from the free variables. <br><br>  If the set FV (M) is empty, then M is called a <i>combinator</i> .  The set of all combinators denote Λ <sub>0</sub> : <br><br>  Λ <sub>0</sub> ≣ {M ∈ Λ |  FV (M) = ∅}. <br><br>  The following ratios β, η, and βη are <i>reductions</i> : <br><br>  β ≣ {((λx.M) N, M [x: = N]) |  M, N ∈ Λ}; <br>  η ≣ {(λx.M x, M) |  M ∈ Λ, x ∉ FV (M)}; <br>  βη ≣ β ∪ η. <br><br>  The expression whose subexpression is a hole is called a <i>context</i> and is denoted by C [], while C [M] is the result of substituting the expression M instead of a hole in the context of C []. <br><br>  If σ is a reduction, then the expression M is a σ <i>-redex</i> if ∃N: (M, N) ∈ σ.  You can also talk about σ- <i>conversion</i> "= <sub>σ</sub> ": <br><br>  (M, N) ∈ σ ⇒ C [Μ] → <sub>σ</sub> C [N]; <br>  M ↠ <sub>σ</sub> M; <br>  M → <sub>σ</sub> N ⇒ M ↠ <sub>σ</sub> N; <br>  M → <sub>σ</sub> N ∧ N → <sub>σ</sub> P ⇒ M ↠ <sub>σ</sub> P; <br>  ∃P: M ↠ <sub>σ</sub> P ∧ N ↠ <sub>σ</sub> P ⇒ M = <sub>σ</sub> N. <br><br>  σ- <i>normal form</i> is the expression Μ, if ∄Ν: M → <sub>σ</sub> Ν.  In the extensional λ-calculus, under a <i>redex</i> mean βη-redex, and under the <i>normal form</i> - βη-normal form.  It is said that M <i>has the</i> normal form N, if M ↠ N. Moreover, the βη-conversion is usually denoted simply “=”, and this is not accidental: formally, the system λβη is an equational theory.  Since such theories are free from logic, consistency in them is determined somewhat differently. <br><br>  As equality, we consider a formula of the form M = N, where M, N are λ-expressions;  such an equality is <i>closed</i> if M and N are combinators.  Let T be a formal theory whose formulas are equalities.  Then they say that T is <i>consistent</i> (and they write Con (T)) if not every closed equality is provable in T.  Otherwise, it is said that T is <i>inconsistent</i> .  One of the reasons for considering λβη is that this theory has a certain property of completeness.  An equational theory T is called <i>Hilbert-Post full</i> (abbreviated HP-complete) if for any equality M = N in the language of the theory T or M = N is provable, or T + (M = N) is inconsistent.  HP-complete theories correspond to maximal consistent theories in the theory of models for first-order logic. <br><br>  <i>A strategy</i> is a mapping F: Λ → Λ such that ∀M: M ↠ F (M).  For a <i>one-step</i> strategy, ∀M: M → F (M) holds.  A strategy is called <i>normalizing</i> if for any expression M having the normal form N, for some number n, F <sup>n</sup> (M) N. The <i>left reduction</i> F <sub>l</sub> is one of the simplest one-step normalizing strategies: it consists of choosing β-redex, the icons “Λ” in which it is textually to the left than other β-Redexes, or <i>left</i> η-Redex, if β-Redexes do not exist.  Thus, if two terms have a common normal form, then using the left reduction, the proof of the corresponding formula can be obtained in a finite number of simple steps.  If the formula is unprovable, then either the process does not end at all, or it ends on different normal forms. <br><br><h4>  Sugar </h4><br>  The set of combinators Ξ <i>generates the</i> smallest set Ξ <sup>+</sup> as a closure by application: <br><br>  Ξ ⊆ Ξ <sup>+</sup> ; <br>  M, N ∈ Ξ <sup>+</sup> ⇒ Μ Ν ∈ Ξ <sup>+</sup> . <br><br>  A set is called a <i>basis</i> if ∀M ∈ Λ <sub>0</sub> : ∃N ∈ Ξ <sup>+</sup> : M = N. <br><br>  Arbitrary abstraction can be modeled with S and K: <br><br>  S ≣ λx.λy.λz.xz (yz); <br>  K ≣ λx.λy.x; <br>  I ≣ λx.x = SKK; <br>  x ∉ FV (P) ⇒ λx.P = KP; <br>  λx.PQ = S (λx.P) (λx.Q). <br><br>  Consequently, the combinators K and S define a basis.  An arbitrary combinator M is often described not as a λ-expression, but with the help of axioms.  For example, the formal system of <i>combinatorial logic</i> CL is defined by two axioms: <br><br>  KPQ = P; <br>  SPQR = PR (QR). <br><br>  There are also one-point bases: one of such bases is set by the combinator <br><br>  X ≣ λx.x KS K. <br><br>  Indeed, it is easy to verify that XXX = K and X (XX) = S. <br><br>  Standard combinators are not only components of some basis for combinatorial logic, but also many other useful λ-expressions.  One of the first examples is usually given by the simplest combinator, which has no normal form: <br><br>  Ω ω ω, where ω λx.x x. <br><br>  Further, the truth values ​​of T ≣ K and F ≣ λx.I allow us to use the expression BMN for the operation “if B, then M, otherwise, N”.  Indeed: if B = T, then the expression is M;  if B = F, then the expression is N. If B is different from T and F, then the result can be arbitrary. <br><br>  As in set theory, ordered pairs can be defined in λ-calculus: <br><br>  [M, N] ≣ λx.x MN, [M, N] T M, [M, N] F ↠ N. <br><br>  <i>The digital system</i> is a sequence of combinators ⎡0⎤, ⎡1⎤, ⎡2⎤ ..., for which there is a <i>following</i> S <sup>+</sup> and <i>a zero check for</i> Zero: <br><br>  S <sup>+</sup> ⎡n⎤ = ⎡n + 1⎤; <br>  Zero ⎡0⎤ = T; <br>  Zero ⎡n + 1⎤ = F. <br><br>  In the <i>standard</i> digital system selected <br><br>  ⎡0⎤ ≣ I; <br>  S <sup>+</sup> ≣ λx. [F, x]; <br>  Zero ≣ λx.x T. <br><br>  A digital system is called <i>adequate</i> if all recursive functions are definable relative to it.  To fulfill this property, it suffices that <i>the preceding function</i> P <sup>- be found</sup> .  For a standard digital system, this is a combinator. <br><br>  P <sup>-</sup> ≣ λx.x F. <br><br>  One of the main results of the λ-calculus is the fixed-point theorem: for any F, there exists X, such that FX = X. Its proof is constructive.  Let W ≣ λx.F (xx) and X ≣ W W. Then we have X ≣ (λx.F (xx)) W = F (WW) = FX, as required.  The reader may have noticed one feature in the proof of this theorem.  To establish that FX = X, we start with the term X and reduce it to FX, and not vice versa. <br><br>  <i>A fixed point combinator</i> is a term M, such that for any F, MF = F (MF) holds, that is, MF is a fixed point for F. An example of a fixed point combinator is often <br><br>  Y ≣ λf. (Λx.f (xx)) (λx.f (xx)). <br><br>  The fixed point combinator allows to solve problems of the following type: to construct F, such that <br><br>  F xy = F yx F. <br><br>  Indeed, the solution is simple: <br><br>  F xy = F yx F follows from the equality F = λx.λy.F yx F, <br><br>  and it follows from F = (λf.λx.λy.fyxf) F. <br><br>  Now we put F ≣ Y (λf.λx.λy.fyxf), and everything is in order. <br><br><h4>  Topology </h4><br>  We introduce some notation.  First, the <i>metalambda abstraction</i> <b>λ</b> x.f (x) is an unnamed record of the set-theoretic function f, for example ( <b>λ</b> x.x <sup>2</sup> + 1) (3) = 10. Secondly, we define the set of <i>codes of</i> finite sequences (for some standard their coding is natural numbers) <br><br>  Seq = {&lt;n <sub>1</sub> , ..., n <sub>k</sub> &gt; |  k ∈ N, n <sub>1</sub> , ..., n <sub>k</sub> ∈ N} ∪ {&lt;&gt;}; <br>  lh (&lt;&gt;) = 0; <br>  α = &lt;n <sub>1</sub> , ..., n <sub>k</sub> &gt; ∈ Seq ⇒ lh (α) = k; <br>  α = &lt;m <sub>1</sub> , ..., m <sub>p</sub> &gt;, β = &lt;n <sub>1</sub> , ..., n <sub>q</sub> &gt; ∈ Seq ⇒ a * b = &lt;m <sub>1</sub> , ..., m <sub>p</sub> , n <sub>1</sub> , ..., n <sub>q</sub> &gt;; <br>  α = &lt;m <sub>1</sub> , ..., m <sub>p</sub> &gt;, β = &lt;n <sub>1</sub> , ..., n <sub>q</sub> &gt; ∈ Seq ∧ p ≤ q ∧ m <sub>1</sub> = n <sub>1</sub> ∧… ∧ m <sub>p</sub> = n <sub>p</sub> ⇒ α ≤ β. <br><br>  Let D = (D, ⊑) be a partially ordered set with a reflexive relation ⊑.  Then a subset X ⊆ D is called <i>directional</i> if <br><br>  X ≠ ∅ ∧ ∀x, y ∈ X: ∃z ∈ X: x ⊑ z ∧ y ⊑ z. <br><br>  Moreover, D is called <i>complete</i> if for any directed subset X ⊆ D there is a <i>supremum</i> ⊔X ∈ D and there is a <i>bottom</i> : <br><br>  ∃⊥ ∈ D: ∀x ∈ D: ⊥ ⊑ x. <br><br>  <i>The Scott topology</i> on a complete partially ordered set (D, ⊑) is defined as follows: O ⊆ D is considered <i>open</i> if <br><br>  1) x ∈ O ∧ x ⊑ y ⇒ y ∈ O; <br>  2) X ⊆ D ∧ ⊔X ∈ O ⇒ X ∩ O ≠ ∅. <br><br>  <i>A partial mapping</i> φ: X ↝ Y is a mapping φ such that the domain of definition Dom (φ) ⊆ X. For x ∈ X, φ (x) ↓ means that φ (x) is defined, that is, x ∈ Dom (φ );  φ (x) means that φ (x) is not defined, that is, x ∉ Dom (φ). <br><br>  If Σ is a set of symbols, then a <i>partially Σ-labeled tree</i> is a partial mapping φ: Seq ↝ Σ × N, such that <br><br>  1) φ (σ) ↓ ∧ τ ≤ σ ⇒ φ (τ) ↓; <br>  2) φ (σ) = &lt;a, n&gt; ⇒ ∀k ≥ n: φ (σ * &lt;k&gt;). <br><br>  <i>The bare tree underlying the</i> partially Σ-labeled tree φ is a tree <br><br>  T <sub>φ</sub> = {&lt;&gt;} ∪ {σ |  σ = σ '* &lt;k&gt; ∧ φ (σ') = &lt;a, n&gt; ∧ k &lt;n}. <br><br>  If σ ∈ T <sub>φ</sub> and φ (σ) = &lt;a, n&gt;, then a is called a <i>label</i> in the <i>node</i> σ.  If for σ ∈ T <sub>φ</sub> φ (σ) ↑, then we say that the node σ is unlabeled.  Partially labeled trees will be denoted by capital letters and we will write σ ∈ A instead of σ ∈ T <sub>A</sub> and A (α) = ⊥, when A (α) ↑, but still α ∈ A. <br><br>  If Σ = {λx <sub>1.</sub> … Λx <sub>n</sub> .x |  n ≥ 0, x <sub>1</sub> , ..., x <sub>n</sub> , x ∈ Λ}, then the partially Σ-labeled tree is called <i>a Böhm type tree</i> .  We denote the set of all such trees by B. The <i>subtree of tree A, originating from node</i> α, is A <sub>α</sub> = <b>λ</b> β.A (α * β).  Obviously, ∈A ∈ B: ∀α: A <sub>α</sub> ∈ B. <br><br>  The combinator M is <i>solvable</i> if <br><br>  ∃n: ∃N <sub>1</sub> , ..., N <sub>n</sub> ∈ Λ <sub>0</sub> : MN <sub>1</sub> ... N <sub>n</sub> = I. <br><br>  For example, a fixed point combinator is solvable, since Y (KI) = KI (Y (KI)) = I. On the other hand, Ω is insoluble.  An arbitrary λ-expression is <i>soluble</i> if the combinator λx <sub>1.</sub> … Λx <sub>n</sub> .M is solvable, where {x <sub>1</sub> ,…, x <sub>n</sub> } = FV (M). <br><br>  The λ-expression M is a <i>head normal form</i> if it is <br><br>  M ≣ λx <sub>1.</sub> ... λx <sub>n</sub> .x M <sub>1</sub> ... M <sub>m</sub> , m, n ≥ 0. <br><br>  It is said that M <i>has a</i> head normal form N, if M = N. <i>The main one</i> is that head normal form of expression, which is first achieved by its left reduction. <br><br>  Wadsworth introduced a class of λ-expressions that do not have a head normal form, and argued that the elements of this class should be considered as meaningless expressions in λ-calculus.  He also owns the following important result: A λ-expression is solvable if and only if it has a head normal form.  Thus, from the insolubility of M it follows that for any expressions N <sub>1</sub> , ..., N <sub>n the</sub> expression MN <sub>1</sub> ... N <sub>n</sub> has no normal form. <br><br>  <i>The Boma tree</i> for the term M, denoted by BT (M), is a Bem tree of type defined as follows: <br><br>  1) if M is insoluble, then ∀σ: BT (Μ) (σ) ↑, <br>  2) if M is soluble and has the principal head normal form λx <sub>1.</sub> ... λx <sub>n</sub> .x M <sub>0</sub> ... M <sub>m - 1</sub> , then <br><br>  BT (M) (&lt;&gt;) = &lt;λx <sub>1.</sub> … Λx <sub>n</sub> .x, m&gt;; <br>  k &lt;m ⇒ BT (M) (&lt;k&gt; * σ) = BT (M <sub>k</sub> ) (σ); <br>  k ≥ m ⇒ BT (M) (&lt;k&gt; * σ). <br><br>  Consider the complete partially ordered set B = (B,) with the Scott topology.  <i>The tree topology</i> on the set Λ is the smallest topology in which the mapping BT is continuous: Λ → B. In other words, the open subsets of Λ are BT <sup>-1</sup> (O), where O is open in the Scott topology on B. <br><br>  Using the tree topology, one can express the usual concepts related to λ-calculus in topological terms.  For example, normal forms turn out to be isolated points, and unsolvable expressions are <i>compactification points</i> , that is, such points whose only neighborhood is the topological space itself. <br><br>  It is proved that application and abstraction are continuous in the tree topology on Λ, and for application it is a non-trivial result, which has interesting consequences.  For example, the set Sol ⊆ Λ of soluble terms is open.  Indeed, in any complete partially ordered set {x |  x ≠ ⊥} open to Scott.  Therefore, the set Sol = BT <sup>-1</sup> {A |  A ≠ ⊥} is open in Λ. </div><p>Source: <a href="https://habr.com/ru/post/141104/">https://habr.com/ru/post/141104/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141097/index.html">Microsoft requires manufacturers to take seriously the quality of touch panels for Windows 8</a></li>
<li><a href="../141098/index.html">Alternativa3D is now open source</a></li>
<li><a href="../141099/index.html">How to beat piracy?</a></li>
<li><a href="../141102/index.html">Howto: Amazon SES PHP mailer</a></li>
<li><a href="../141103/index.html">Making Home VirusTotal</a></li>
<li><a href="../141106/index.html">Using ShtumiUsefulBundle in Symfony2 - several useful things in one bundle</a></li>
<li><a href="../141107/index.html">WPF: Several parameters for the converter</a></li>
<li><a href="../141108/index.html">WEXLER. Flex ONE: the first review of the world's first e-book with a flexible screen</a></li>
<li><a href="../141109/index.html">The graphs of math functions on google now in 3D</a></li>
<li><a href="../141110/index.html">Monitor Memcache with Zabbix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>