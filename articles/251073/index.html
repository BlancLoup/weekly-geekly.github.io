<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Own Flash on HTML5: the union of vector images (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once upon a time, in a far-away galaxy (that is, more than a year ago and beyond the default city), one web programmer decided to write his Flash (he ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Own Flash on HTML5: the union of vector images (part 1)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/476/a24/205/476a242053a14a6689fcfc523f0143e9.png" align="left" width="400">  Once upon a time, in a far-away galaxy (that is, more than a year ago and beyond the default city), one web programmer decided to write <a href="http://nanofl.com/">his Flash</a> (he was not without delusions of grandeur, of course).  The task then seemed difficult and very interesting.  This article will discuss one of the problems that stood in his way. <br>  Those who drew in Flash know that in it the figures (shaded areas) within one layer never overlap, and the lines are always drawn over the shaded figures.  This approach has, in my opinion, a good plus - you have what you see on the image.  However, when writing a vector editor, this leads to the need to solve the problem of correctly superimposing drawn objects (lines and filled shapes) onto existing ones.  Below I will try to show in stages how this can be done. <br><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Please take into consideration!</b> <div class="spoiler_text">  This article is an attempt to describe the solution, as the author sees it.  Far from perfect.  The author will be grateful for useful thoughts about the improvement of the algorithm. </div></div><br><img src="https://habrastorage.org/files/0f8/b56/e79/0f8b56e79e80468188d878a66de2dbd6.png" align="right" height="250"><br>  For simplicity, hereinafter I will call <b>polygons</b> shaded areas bounded by straight lines and quadratic Bezier curves.  As a rule, when mentioning <b>edges</b> , I will keep in mind the visible drawn straight or curved lines (stroke lines). <br><br><h1>  Initial data </h1><br>  So, we have two images that we want to combine.  Each is defined by a set of edges and polygons. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is what we know about the ribs: <br><ul><li>  may be straight line segments; </li><li><div class="spoiler">  <b class="spoiler_title">may be Bezier curves;</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b1d/39b/6dd/b1d39b6dd41542b3b2f3b71107fe6022.gif" align="right">  The quadratic Bezier curve is the simplest case when the curve has one control point and, in fact, is drawn inside the triangle defined by its three vertices.  Excellent illustration from Wikipedia: </div></div></li><li>  each edge has its own color; </li><li>  no two edges intersect (but they can, of course, have a common starting or ending point); </li><li>  no two edges match. </li></ul><br>  So, on the right you can see 5 edges: two blue and three dark yellow. <br><br>  But what we know about landfills: <br><img src="https://habrastorage.org/files/968/e01/28f/968e0128f1ed4984b890912febc1db76.png" align="left"><br><ul><li>  limited to straight or curved segments; </li><li>  never intersect; </li><li>  can adjoin each other, i.e.  have a common border (in this case, the colors of the polygons should be different, or the border should be explicitly highlighted with edges; thus, there should not be polygons that nothing prevents to unite into one); </li><li>  have their own fill option (in the simplest case - color); </li><li>  can be translucent (color can be set with indication of alpha channel); </li><li>  may be non-convex; </li><li>  may have ‚Äúholes‚Äù (i.e., areas defined by straight / curved segments where there is no fill). </li></ul><br>  In the light of the fact that a polygon is a complex object, we will describe it as a closed outer contour + a set of internal non-intersecting contours that define holes. <br><br><h1>  Subtasks </h1><br>  It is clear that finding the union of two vector images is a difficult task, and therefore it is worth splitting it into several subtasks.  Here's what I got: <br><ul><li>  searching for intersections of all segments of one image with segments of another and splitting these segments by the points found; </li><li>  search for all contours (closed chains of segments) on the union of segments of two images; </li><li>  determining the presence / absence of the fill and its color for each contour with respect to each of the two images; </li><li>  removal of all edges of the original image, which are completely inside the shaded areas of the overlay image; </li><li>  removal from the original image of all polygons present in the overlay image without taking into account the color; </li><li>  adding to the edges and polygons of the original image of all the edges and polygons of the overlay image (in this case, the coinciding edges of the original image are rubbed with the edges of the overlay); </li><li>  the union on the original image of adjacent polygons that have the same fill and do not have a clear separation of the edges. </li></ul><br>  As a result of all these actions in the original image, we must get the desired result of the union. <br><br>  I think it is clear that each of the subtasks is a sometimes trivial problem.  Therefore, we consider them separately. <br><br><h2>  Search for the intersection of two segments </h2><br>  We have different segments, so we consider three possible cases separately. <br><br><h3>  Both segments are straight </h3><br>  As you know, finding the intersection of two straight line segments is not particularly difficult, it‚Äôs worth remembering that it is convenient to represent them in a parametric form when calculating (formulas of the form y = kx + b have a fatal disadvantage: they quickly lose accuracy when the segment approaches the vertical position, and for vertical segments require separate consideration): <br><img src="https://habrastorage.org/files/b13/903/4e2/b139034e23f747f2aaf8d53ba8945704.png" align="right"><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ M -   , S -  , D -  , t -    [0; 1] M1 = S1 + (D1-S1) * t1 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     M2 = S2 + (D2-S2) * t2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -   M1 = M2 -   , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      t1: Xs1 + (Xd1-Xs1) * t1 = Xs2 + (Xd2-Xs2) * t2 Ys1 + (Yd1-Ys1) * t1 = Ys2 + (Yd2-Ys2) * t2</span></span></code> </pre> <br>  I will not describe the output of t1 (I think everyone will cope here without much difficulty).  After obtaining the value of t1, you need to make sure that it lies in the interval [0;  1] (otherwise, the segments do not intersect), after which you can substitute it in the formula that defines the first segment, thus obtaining the coordinates of the intersection point: <br><br><pre> <code class="hljs lisp">Xm = Xs1 + (<span class="hljs-name"><span class="hljs-name">Xd1-Xs1</span></span>) * t1 Ym = Ys1 + (<span class="hljs-name"><span class="hljs-name">Yd1-Ys1</span></span>) * t1</code> </pre><br><br><h3>  Bezier curve and straight line segment </h3><br>  The intersection of a Bezier curve and a straight line is no longer so simple, but it is quite analytically solvable, especially if you guess beforehand to rotate the line and the curve so that the line becomes strictly horizontal: <br><img src="https://habrastorage.org/files/72d/aa2/e4d/72daa2e4df0c4e90a13bd30014f77115.png" align="left" width="240"><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// P0, P1, P2 - ,  ; t -    [0; 1] M1 = (1-t1)^2 * P0 + 2*t1*(1-t1) * P1 + t1^2 * P2 //    // S -  , D -  M2 = S + (DS) * t2 //     //   P0, P1, P2, S  D   a = -atan2(Yd-Ys, Xd-Xs); //        // (,   (X, Y)    (Xn, Yn)) Xn = X*cos(a) - Y*sin(a) Yn = X*sin(a) + Y*cos(a)</span></span></code> </pre><br><pre> <code class="hljs markdown">//     (   P0, P1  P2) Xm1 = (1-t1)^2 <span class="hljs-bullet"><span class="hljs-bullet">* Xp0 + 2*</span></span>t1<span class="hljs-emphasis"><span class="hljs-emphasis">*(1-t1) *</span></span> Xp1 + t1^2 <span class="hljs-bullet"><span class="hljs-bullet">* Xp2 Ym1 = (1-t1)^2 *</span></span> Yp0 + 2<span class="hljs-emphasis"><span class="hljs-emphasis">*t1*</span></span>(1-t1) <span class="hljs-bullet"><span class="hljs-bullet">* Yp1 + t1^2 *</span></span> Yp2 //       Y: Xm2 = Xs + (Xd-Xs) <span class="hljs-bullet"><span class="hljs-bullet">* t2 Ym2 = Ys // ..     Ys = Yd // M1 = M2, .. Xm1 = Xm2 Ym1 = Ym2 //      Y, ..    : (1-t1)^2*</span></span>Yp0 + 2<span class="hljs-emphasis"><span class="hljs-emphasis">*t1*</span></span>(1-t1)<span class="hljs-emphasis"><span class="hljs-emphasis">*Yp1 + t1^2*</span></span>Yp2 = Ys</code> </pre><br>  Solving this quadratic equation, we find the values ‚Äã‚Äãof t1 (there can be two of them).  For each value of t1, as in the case of straight line segments, it is worth making sure that it lies within the limits [0;  one].  Substituting the values ‚Äã‚Äãof t1 in the original (before the rotation) formula of the curve, we obtain the coordinates of the desired points of intersection. <br><br><h3>  Two Bezier curves </h3><br><img src="https://habrastorage.org/files/a67/c72/683/a67c726832c5472dbb0bf1da459062c7.png" align="right" width="350">  Analytically calculating the intersection points of two quadratic Bezier curves (there can be up to 4 such points) is not very easy: the complexity is so high that even MathCAD comes to indignation, giving out messages about too long formulas.  Also, as far as I understand the situation, in this case you will have to work with complex numbers.  Fortunately, there are numerical iterative methods for obtaining the intersection points of arbitrary curves with a given accuracy.  Everything is simple: <br><ol><li>  if the considered segments have a size less than a given accuracy - we approximate them by straight lines and consider their intersection; </li><li>  if at least one of the segments is more accurate - we beat it into two (more or less equal) parts and recursively apply the algorithm for the obtained segments. </li></ol><br>  Here you can enter optimization: first check whether segments can intersect in principle (for example, using bounding rectangles) and if not, then stop the current recursion branch. <br><br><img src="https://habrastorage.org/files/368/6c4/19a/3686c419a86f49d8a323d258df0c5d90.png" align="left" width="170"><br>  The moment that can cause difficulty is splitting the Bezier curve into two parts (ie, calculating new control points; determine the end point of the first curve, which coincides with the initial point of the second curve, easily substituting t = 0.5 into the curve formula).  As it turned out, for this it is enough to calculate the coordinates of the centers of the segments defining the supporting triangle - the obtained points and will be the control points for the new curves.  The figure on the left illustrates the solution: the curve (P0, P1, P2) is divided into two curves, the reference triangle of the first one (P0, P1 ', P2') is highlighted in blue.  The reference point of the second curve (P2 ', ..., P2) is calculated quite similarly. <br><br>  To be continued‚Ä¶ <br><br><div class="spoiler">  <b class="spoiler_title">PS</b> <div class="spoiler_text"><ul><li>  Initially, the author planned only one article on the topic ‚ÄúUnion of Vector Images‚Äù, but since  material turns out a lot, decided to break it apart. </li><li>  The author is grateful to Thematic Media for the opportunity to talk about the <a href="http://nanofl.com/">NanoFL</a> project in Habr√©. </li><li>  For those who get to look at the current version of NanoFL: meanwhile, the implementation of the algorithm contains errors that the author will try to fix for the next version of the program. </li></ul></div></div></div><p>Source: <a href="https://habr.com/ru/post/251073/">https://habr.com/ru/post/251073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251049/index.html">Introduction to GStreamer: Initialization</a></li>
<li><a href="../251053/index.html">Remote debugging in Linux using the GDB-gdbserver bundle</a></li>
<li><a href="../251063/index.html">Optimized command system for microcontrollers</a></li>
<li><a href="../251065/index.html">/ ^ 777 $ / or / ^ 7 {3} $ / or number of luck</a></li>
<li><a href="../251069/index.html">Lenovo laptops come with Superfish malware and its CA certificate and private key in storage</a></li>
<li><a href="../251077/index.html">Some interesting and useful things for web developer # 39</a></li>
<li><a href="../251079/index.html">Increase conversion with callback widget UpToCall</a></li>
<li><a href="../251081/index.html">Developing a simple game in Code :: blocks using Direct3D 9</a></li>
<li><a href="../251083/index.html">Chat VKontakte as a terminal</a></li>
<li><a href="../251085/index.html">Quantum sandbox: part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>