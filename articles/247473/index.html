<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JSON, which you can comment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not all JSON can not be commented on (for example, Chrome [ium] completely transfers comments to manifest.json), but the standard does not provide com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JSON, which you can comment</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://spmbt.github.io/jsonComm/"><img src="https://habrastorage.org/files/cc8/4ea/cfa/cc84eacfa8964b13811d1780dc355096.png" title="jsomComm" align="right"></a>  Not all JSON can not be commented on (for example, Chrome [ium] completely transfers comments to manifest.json), but the standard <a href="http://stackoverflow.com/questions/244777/can-i-comment-a-json-file">does not provide comments to it</a> .  Therefore, a number of functions in NodeJS do not process comments in the JS format and consider them to be a mistake.  Similarly, AJAX with JSON format takes them for an error.  Therefore, for configuration files in JSON format there is a lot of inconvenience when trying to use them as human-readable files.  Maybe this is sometimes good.  If we want to comment, we will be forced to issue a comment under or above the line as ‚Äúkey-value‚Äù. <br><pre><code class="javascript hljs">...{... <span class="hljs-string"><span class="hljs-string">"some-key_comment"</span></span>:<span class="hljs-string"><span class="hljs-string">"my comment for key and value"</span></span>, <span class="hljs-string"><span class="hljs-string">"some-key"</span></span>:<span class="hljs-string"><span class="hljs-string">"some-value"</span></span>, ...}...</code> </pre>  But if we do not write comments, following the rigor of the protocols, errors arise because of another factor - forgetting the meaning of the settings when editing by a person. <br><pre> <code class="javascript hljs">...{... <span class="hljs-string"><span class="hljs-string">"some-key"</span></span>:<span class="hljs-string"><span class="hljs-string">"some-value"</span></span>, <span class="hljs-comment"><span class="hljs-comment">//- key?? ,  - ! ...}...</span></span></code> </pre><br>  We will come up with a JSON-like format with comments in the JS style, so that they can be performed as JS, and, having cleared comments, is read as JSON.  (" <a href="https://github.com/spmbt/jsonComm">TL: DR: show me the code.</a> ") <br><a name="habracut"></a><br><h3>  Syr-boron and source </h3><br>  By the way, Douglas Crockford, who arranged it all <a href="https://plus.google.com/%2BDouglasCrockfordEsq/posts/RK8qyGVaGSr">, explained in 2012</a> :) <br><br><blockquote>  I removed the comments from JSON because I saw people using them to store parsing directives ‚Äî a practice that would destroy compatibility (of the format).  I know that the absence of comments some saddens, but their (comments) should not be. <br><br>  Suppose you use JSON to store configuration files that are used to comment.  Insert any comments as you like.  Then pass them through JSMin before running the JSON parser. </blockquote><br>  He did it on G +, where you can put only "pluses", and comments closed.  So, whatever the reaction of society under the explanation, we will see only ‚Äúpluses‚Äù (or look at those who shared this post). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And Crockford's quote from another place: <br><blockquote>  The main reason why I deleted the comments was that there were people who tried to parse the data based on the comments, which completely broke compatibility.  I could not control them at all, so the best way out was to delete the comments. </blockquote><br><br>  Therefore, we read further by clicking and agreeing to the promise: <table><tbody><tr><td>  <abbr title="XA-XA-XA, they will find ways to do wrong"><font color="#0033ff">‚ÄúI promise that I will be careful and will not use comments for parsing data!</font></abbr> </td></tr></tbody></table><br><h3>  Everything has been done before us </h3><br>  The fact of the matter is that another parser is required, and so - there is no big problem.  And the problem is not limited to this - sometimes you need to slightly change the file, leaving comments.  The first part (the parser) was decided, for example, via <a href="http://blog.getify.com/json-comments/">JSON.minify ()</a> .  The second and a number of other problems (end commas or none at all, multiline comments, keys and value strings without quotes) were not too lazy to solve in <a href="https://github.com/laktak/hjson-js">Hjson</a> , spending 750 lines on JS code (with comments for 10-15%). <br><br><h3>  Stop, is it really necessary? </h3><br>  Undoubtedly, <i>severe programmers</i> (those who write comments as key values ‚Äã‚Äãin JSON), as well as robots (network and in general) do not need it.  They perfectly recode the names of the keys in any familiar config, and programmers - in general, they still have the intellect, allowing them to understand unfamiliar names and build heuristics on their decoding without any computer.  The rest, including non-tough programmers, find comments useful and spend time not only on reading them sometimes, but also on writing them.  Undoubtedly, Crockford refers to the harsh programmers, and the creators of YAML - no.  With this we have to put up and connect the worlds of robots (and sec. P.) And people. <br><br>  There are also hackers who are perfectly hacker-like, a valid way to write JSON with sequential repetition of identical keys (in JS + "use strict" will give an error). The value of the first key in most parsers will not be saved, so you can use it (and all such, except the last) as comments. The method also suffers from "machine". <br><br><pre> <code class="javascript hljs">...{... <span class="hljs-string"><span class="hljs-string">"some-key"</span></span>:<span class="hljs-string"><span class="hljs-string">"comments_comments"</span></span>, <span class="hljs-string"><span class="hljs-string">"some-key"</span></span>:<span class="hljs-string"><span class="hljs-string">"some-value"</span></span>, ...}...</code> </pre><br>  Total, not all will be for "another format, the 16th in a row."  Any attempt to build, and even more so, apply a format converter will lead to ignoring some part of the developer units of this format.  In the same individuals, in which strange fragments of different worlds, which have not yet decided on their essence, are combined in a strange way, the <s>n</s> conversion procedures will prove useful.  At least at first, as far as turning. <br><br>  Therefore, this format contains the incompatible, like a computer for a blonde: on the one hand, transformation methods that only robots can use, on the other hand, the results appear in a more human-readable form. <br><br><h2>  Bridge between robots and humans </h2><br>  You can come up with a plugin for Grunt / Gulp (for example, <a href="https://www.npmjs.com/package/grunt-strip-json-comments">grunt-strip-json-comments</a> , <a href="https://github.com/sindresorhus/gulp-strip-json-comments">Gulp</a> ...) to clean up files from comments.  But the essence of the action is reduced to a small (up to 1 K) regular expression, which is easier to write in Gruntfile.js, than to enter another plug-in into it.  Moreover, the same expression is needed for JS on the client in order to read the same JSON, so we will not run away from its explicit form anyway. <br><br>  Methods for format conversions are compiled into a <b>jsonComm</b> object that works in a Javascript environment.  To solve particular problems, the entire object is not needed - it does not always make sense to take all the methods into the project.  For example, the task of simply deleting comments (as in gulp-strip-json-comments) is handled by a method consisting of one regular expression ( <b>jsonComm.unComment ()</b> , up to 1 KB of uncompressed code; example further; in the test section of the jsonComm project there are tests and benchmarks to assess the correctness and speed), which even compile is not necessary if there is no goal to apply different settings of the rules. <br><br>  Settings can be, for example, such.  What symbol to mark the beginning of a comment?  If in the environment of pure JS there is a confident answer - "//", then Python supporters or YAML will say - "#".  Attempts to combine the irreconcilable lead to the settings of the rules and to the converters - thus, from which, among other things, they began.  Among the JS adepts, there is no need for settings, and they will burn from the project the mention of "#".  Because you can not spend 36 microsecond (micro) to generate regexp for the sake of loyalty to such a heresy.  Loyalists will also be burned out, but they will extend the regex and will spend 0.1-0.5 (conditionally) microseconds (micro) not for generation, but for each recoding cycle.  For this they are hated by the Puritans.  After all, robots think much faster, and they see slowness on a different scale. <br><br>  <i>What tasks can be solved when commenting JSON?</i> <br><ul><li>  just read jsonComm format (with comments) in JS or NodeJS, delete comments from them and then verify it as usual JSON in JSON.parse ();  the same thing that most projects do to add comments to JSON.  It works quickly (tens to hundreds of microseconds). </li><li>  read not JSON, but JS files (with code) in order to take some constants from the rest of them as settings (for example, in NodeJS), when the JS file will also use them when it is executed elsewhere (on the client) - a kind of template with a simplified structure configurations; </li><li>  as in the previous paragraph, but I already want to change some settings after reading (for example, in Noda, update the build number or make the config settings), so that further JS on the client, not knowing it, would use them.  This is an analogue of the read-write template. </li></ul><br>  Here - not all conceivable tasks, but a group that is sufficient for simple project configuration.  Instead of Yaml with comments or crutches comments in pure JSON - we write jsonComm with the extension * .js, which can either be read as JSON (on the server, when building the project or on the client), or run as JS, having comments in JS or YAML- style. <br><br>  Tasks are divided into 2 practical cases - when we <b><u>do not</u></b> need to edit our jsonComm, and when <b><u>we need to</u></b> edit, while leaving all the comments.  When only reading occurs (the same is the case of client AJAX), we restrict ourselves to the only <i><b>jsonComm.unComment ()</b></i> method with one regexp, and further - JSON.parse (). <br><br>  The case of writing changed values ‚Äã‚Äãor keys will require a small procedure of parsing a text JsonComm file (with comments, without deleting them) or JS to change the required pointwise.  Manipulation is possible for the "* .js" files, if we don‚Äôt touch the language codes with scripts, all we need to do is not to err in writing the key values.  A second method is added to the required methods: <i><b>jsonComm.change ()</b></i> . <br><br>  <i>What <b>other</b> tasks can be solved when commenting on JSON?</i> <br>  Tasks of academic type: <br><ul><li>  get ‚Äúvalid‚Äù access to jsonComm comments, first translating them into ‚Äúkey #‚Äù - ‚Äúcomment‚Äù pairs, selecting the key foundation from the line it was found near, and then, after parsing from the correct JSON, process them further (for example, transferring to another format); </li><li>  work with Yaml directly (but lose the basis for validation recognized by the browser / JS environment) </li><li>  mutual conversion to Yaml and back through the above made valid JSON; </li><li>  the same for XML;  then a cluster of four data description languages ‚Äã‚Äãwill be obtained, 2 of which are recognized in browsers and numerous computing environments. </li></ul><br>  The peculiarity of these tasks is that there is no practical need for them, but seeing a niche, space is reserved for them (toYaml, toXml, fromYaml, fromXml, to functions; the latter is ‚Äúin jsonComm‚Äù).  No comments - such a cluster already exists in the works of other libraries.  To join it with comments, you need to start at least with the function of translating jsonComm comments into one of the valid and recognized formats.  Obviously, the first candidate is JSON. <br><br>  The very first acquaintance with commenting methods creates many questions - to which keys to attach comments to the found pair, and which ones after?  For example, comments after the comma separator, but standing on the same line, usually refer to the previous pair, therefore the line separator will also affect the separator.  Second, multi-line comments can logically refer to different adjacent pairs.  Third: what are the comments in the arrays?  Their keys are implicitly expressed, and it would be logical to create a lying array next to it.  And if it is multidimensional and with rare filling?  Fourth: comments on the line can be several;  a pair can be stretched to 3 or more lines. <br><br>  This whole circle is no less contrived, but real problems will require a well-thought-out approach so that the automatic conversion of comments does not lead to a deterioration in the readability of formats.  Therefore, we will not hurry with their manufacture.  Let us deal better with the formal description of the jsonComm grammar. <br><br><h2>  JsonComm grammar </h2><br>  The most common pairs in JSON files are written on separate lines: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">  &gt;</span></span>"<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>": <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The value is a quoted string or other terms according to all JSON rules.  The key is any string, only with special escaping of quotes inside of it.  Between elements there can be whitespace characters, and pairs are separated by commas or brackets, which can stand anywhere before or after the pair, including on adjacent lines. <br><br>  We will have a very similar format (jsonComm), with the difference that there can be 2 types of comments in place of white space characters. <br><br>  It turns out that it‚Äôs more economical to navigate not by lines, but by separators (brackets, commas).  Line breaks for multi-line comments do not matter at all, but for single-line comments they are a sign of the end.  This will affect which parser will work in the conversion algorithm. <br><br>  Further, when solving a creative problem on the question of which pair the comments belong to, the location of the separator and the line breaks will again matter.  To simply delete comments, it turns out that line breaks are not important (you shouldn‚Äôt just remove the end of the line comment of a single-line comment). <br><br>  With that said, the basic construction of the jsonComm grammar looks like this: <br><pre> <code class="html hljs xml">(("{" | "[" | ",")<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span><span class="hljs-tag">&gt;</span></span> (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>"<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>"<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span><span class="hljs-tag">&gt;</span></span> (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>(":")<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span><span class="hljs-tag">&gt;</span></span> (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span><span class="hljs-tag">&gt;</span></span> | <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span><span class="hljs-tag">&gt;</span></span> (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">-</span></span></span><span class="hljs-tag">&gt;</span></span> (<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span>("}" | "]" | ","))</code> </pre><br>  After filtering, everything that is not in brackets is thrown out, and everything that is shown in parentheses remains.  With some features, of course, which are not displayed in this simplified scheme (an empty value means a value-structure).  The scheme may skip the wrong JSON, may skip any text except comments, for example, a program or a book text.  And this is good because during validation, if it is done, JSON is still checked, and if there is no validation, and the text is parsed by the JS compiler, then there is no need to delete comments, the scheme does not work in this mode. <br><br>  A similar, more complex scheme will be needed to insert comment-values ‚Äã‚Äã( <i><b>jsonComm.comm2json ()</b></i> function).  In it from jsonComm of a type <br><pre> <code class="hljs objectivec">... ,<span class="hljs-string"><span class="hljs-string">"some-key"</span></span>:<span class="hljs-string"><span class="hljs-string">"some-value"</span></span> <span class="hljs-comment"><span class="hljs-comment">//comments_comments ...}...</span></span></code> </pre><br>  create <br><pre> <code class="hljs erlang">... <span class="hljs-string"><span class="hljs-string">"some-key#"</span></span>:<span class="hljs-string"><span class="hljs-string">"comments_comments"</span></span>, <span class="hljs-string"><span class="hljs-string">"some-key"</span></span>:<span class="hljs-string"><span class="hljs-string">"some-value"</span></span>, ...}...</code> </pre><br>  or without a line with a comment key.  If there are several comments in the text area related to the pair, they are all copied to the value ‚Äúsome-key #‚Äù.  But if the comment is not met in the region of the pair (in the array, before or after all the brackets), it is ignored.  All comment characters must be converted to valid JSON.  For example, tabs - in "\ t", "\" - in "\\", .... <br><br><h2>  How to practice contain JsonComm? </h2><br>  Until now, we could write without problems and plug-ins only JSON with all the stipulations of the absence of comments or with the presence, but in the form of values ‚Äã‚Äã(or edit JS as text files, or store in the database).  Now we will use the jsonComm files that are editable (for NodeJS) and have the extension <b>* .js</b> . <br><br>  Two practical niches for using JsonComm files were revealed: for reading configurations decorated with comments, for updating configurations, and one academic format converter. <br><br>  If the files need only be read (client JS, etc.), read them as xhr.responseText in AJAX or as * .js and convert JsonComm to structure objects with validation via JSON.parse (). <br><br>  If the files need to be modified, then for speed of work we use the search and replace algorithm using unique keys that are not repeated in the file (jsonComm.change ()).  Then there is no need to do a parse tree, while at the same time bypassing comments (however, this should not be slow, too, but a separate complex one-pass algorithm). <br><br>  No problem adding Python style single line comments (#comments_comments).  But then the way of reading as a * .js file will not work.  The project code has the ability to disable the "#" syntax for comments (at the initial stage of the regexp compilation). <br><br>  Simple cases when it is needed: <br><br>  * In the project builder on Grunt / Gulp / ... we calculate the new version number and store it in the same configuration file. <br><br>  * ibid, in the collector, create project constants based on other build parameters and write them as parameters for JS. <br><br>  A little more complicated, client-side JS can also acquire the function of recording such files, by sending the result to the server.  This will give even more use cases (assembly panel on the client), leaving comments in the file.  To do this, it needs to modify and send the line (the image of a multi-line file) to the server, and then write it to a file (of course, with the solution of security issues). <br><br><h2>  Implementation </h2><br>  In order not to twist cycles for a long time, the transformation is performed in one fell swoop on regular expressions. <br><br><h4>  Snatching comments </h4><br>  The converter actually works as a loop in rows, methodically biting through comments and skipping valid JSON fragments.  It is easy to build comment text recognizers on its base in order to save them into special key values.  In this way, we allow comments for further operations, but not to ‚Äúbreak compatibility‚Äù (if you wish, it is always possible), but for the code with a comment to be more convenient to write worse than the readable expression from 2 pairs ‚Äúkey-comment‚Äù and ‚Äú key value. <br><br>  Not <br><pre> <code class="html hljs xml"> "_": "", "": "",</code> </pre><br>  , but <br><pre> <code class="html hljs xml"> "": "" //</code> </pre><br><br>  The solution also performs the task of distributing responsibility for the validity of the code.  Everything related to comments is controlled visually and with syntax highlighting in the IDE by the developer.  The correctness of the rest of JSON parses the standard JSON.parse () parser. <br><br>  Let's start with the simple.  How does parsing on regexp work?  Let's try to delete end comments.  (The code is not used further, it is for example only.) <br><br> <code>('\n'+_).replace(/(^|\r?\n)(([^"\r\n:]*"(\\"|[^"\r\n])*"|[^"\r\n:]*):?([^"\r\n]*"[^"\r\n]*"|[^"\r\n]*)[^\/"\r\n]*?|[^\/"\r\n]*?)(\/\*\*\/|\/\*([\s\S]?(?!\*\/))+.{3}|\/\/[^\r\n]*)/g,'$1$2')</code> <br> <br>  To understand how it is arranged, let's pay attention to the functional parts: <br><br>  <code>(^|\r?\n)</code> - exciting brackets to display the previous line breaks. <br>  The next bracket and its pair is ... <code>[^\/"\r\n]*?)</code> - the second exciting brackets used for copying. <br>  <code>"(\\"|[^"\r\n])*"</code> - key or quoted string;  if there are no quotes, then an alternative from simply <br><br>  <code>\s*\/\*\*\/|\s*\/\*([\s\S]?(?!\*\/))+.{3}</code> is a multi-line parser. <br>  <code>\/\/[^\r\n]*</code> - single-line comment parser to the end of the line. <br><br>  With biting comments at the end of the line, this simple expression is fine.  Worse, biting out comments with an asterisk between keys and values.  You can ignore and not write such comments.  Moreover, the "competitor" YAML has only terminal ones.  But, having functional parts, it is already possible to construct a more complex expression in order not to impose such restrictions.  In this case, it is necessary not only to leave ‚Äúeverything before the comment in the line‚Äù, but also between them - the fragments left behind become more complicated.  In fact, this is the entire <b>jsonComm.unComment</b> (jsonCommString).  This line can be copied to Gruntfile.js instead of connecting a module to clear the JSON string from comments. <br><br> <code>jsonCommString.replace(/(?:(?:((?:\{|,)\s*)(?:(?:\s*(?:\/\/|#)[^\r\n]*(\r?\n|$))*(?:\s*\/\*\*\/|\s*\/\*(?:[\s\S]?(?!\*\/))+.{3})*)*(\s*"(?:\\"|[^\r\n"])*"\s*)(?:(?:\s*(?:\/\/|#)[^\r\n]*(\r?\n|$))*(?:\s*\/\*\*\/|\s*\/\*(?:[\s\S]?(?!\*\/))+.{3})*)*(\s*:\s*)(?:(?:\s*(?:\/\/|#)[^\r\n]*(\r?\n|$))*(?:\s*\/\*\*\/|\s*\/\*(?:[\s\S]?(?!\*\/))+.{3})*)*(\s*(?:[0-9.eE+-]+|true|false|null|"(?:\\"|[^\r\n"])*"|(?!:\{|:\[))\s*)(?:(?:\s*(?:\/\/|#)[^\r\n]*(\r?\n|$))*(?:\s*\/\*\*\/|\s*\/\*(?:[\s\S]?(?!\*\/))+.{3})*)*(\s*(?:\}|(?!,))\s*)?)+?|(?:((?:\[|,)\s*)(?:(?:\s*(?:\/\/|#)[^\r\n]*(\r?\n|$))*(?:\s*\/\*\*\/|\s*\/\*(?:[\s\S]?(?!\*\/))+.{3})*)*(\s*(?:[0-9.eE+-]+|true|false|null|"(?:\\"|[^\r\n"])*"|(?!:\{|:\[))\s*)(?:(?:\s*(?:\/\/|#)[^\r\n]*(\r?\n|$))*(?:\s*\/\*\*\/|\s*\/\*(?:[\s\S]?(?!\*\/))+.{3})*)*(\s*(?:\]|(?!,))\s*)?)+?|(?:(?:\s*(?:\/\/|#)[^\r\n]*(\r?\n|$))*(?:\s*\/\*\*\/|\s*\/\*(?:[\s\S]?(?!\*\/))+.{3})*)*\s*)/g,'$1$2$3$4$5$6$7$8$9$10$11$12$13$14')</code> <br> <br>  Non-capturing brackets are widely used here to leave only exciting, for further simplicity, the second argument in .replace ().  (Hack-hacking: these lines are best read in an editor with highlighting and highlighting of pair brackets, for example from jetbrains.) <br><br>  To convert a jsonComm string to JSON, this expression is sufficient.  As the benchmarks show, this transformation flies quite well - the execution time is tens to hundreds of <b>micro</b> seconds per page (it depends a lot on the complexity of parsing).  It will be worse to deal with an academic script for outputting comments in JSON, when a function is needed in replace (). <br><br>  So, we received valid JSON, having solved the first part of the task - to read jsonComm. <br><br>  Then, the parsing of the validity of the remaining code, as intended, is assigned to the standard JSON.parse (), after which we get the data structure in JS.    ‚Äî -     ,    . <br><br><h4>     </h4><br>            ,   . ,        ¬´-¬ª      ,         . <br><br>  ,    . <br><ul><li>   jsonComm    ( ).     .         ‚Äî        . </li><li>     (    ) </li><li>  ,      ‚Äî  ,           .             . </li><li>   ;   ‚Äî   null  "".  ,        ,     . </li><li>   ;      .        (   ). </li><li>  ()  ,   -         ,    .  , ,     (  ,  ). </li></ul><br><br>       ,    ‚Äî    .           ,    jsonComm. <br><br>       :        ¬´¬ª (  ),        ‚Äî ,   . <br><br>     <b>jsonComm.change(h)</b> ,  h ‚Äî    ¬´¬ª-¬´ ¬ª. (   ‚Äî ¬´¬ª- {¬´ ¬ª:¬´ ¬ª}.) <br><br>  ,  .change()  ()      JSON        .unComment().    JS-,    (,   ,          JSON),       .  Those. .change() ‚Äî       . <br><br><h2>  :    </h2><br>       ,    . <br><br> <font color="#cc33ff">‚óè</font>    JSON (  ‚Äî <b>jsonComm.comm2json</b> ), <br> <font color="#cc33ff">‚óè</font>   YAML, <br> <font color="#cc33ff">‚óè</font>   ¬´jsonComm ‚Äî YAML¬ª. <br> <font color="#cc33ff">‚óè</font>    ¬´jsonComm ‚Äî XML¬ª. <br><br>    ,    -,    (comm2json)    ,     ‚Äî    .   replace,       ,              JSON  . <br><br>   ‚Äî    30        ,  .      1 ,      .       ¬´ ¬ª       (Yaml, XML). <br><br><h2>   </h2><br> ,       3      jsonComm,   (,  )   .   ‚Äî  ,          <a href="http://spmbt.github.io/jsonComm/TEST/jsonCommTest.htm"> </a>     .  Firefox 34 (jsonComm.unComment): <br><div style="text-align:center;"> <nobr><img src="https://habrastorage.org/files/18b/8ae/557/18b8ae557b1243c6b221407b4d65a0d1.png"></nobr> </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Chrome in this test - twice the best results. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to parse comments (jsonComm.comm2json)? Here the replacement works through replace (, function).</font></font><br><div style="text-align:center;"> <nobr><img src="https://habrastorage.org/files/e00/499/b19/e00499b19bf2404daf2e3981a61f8a7c.png"></nobr> </div><br>      ‚Äî  .  ,        (.replace())  .   ,   ‚Äî  ,  ‚Äî . <br><br>   ,       ,     ‚Äî   JSON   .       (.stringify),      (  ). <br><br>     (jsonComm.change)?      ‚Äî    ,       .      jCommChanges. <br><div style="text-align:center;"> <nobr><img src="https://habrastorage.org/files/daf/1f2/b3d/daf1f2b3dbb14ce099d547af8c60b010.png"></nobr> </div><br>    ,          .    ¬´multiline1: {newKey:'newValue'}¬ª,   ,      . <br><br>          jsonComm,     ( ).    ,  ,      JSON.  ,  ‚Äî  ,         . <br><br>  ,           1 .   3       ‚Äî 2.1  (src/jsonComm.min.js). <br><br><h2>     </h2><br>         ? <br><br> 1)   ,   ,       ,     (     <i>jsonCommTest.htm</i>   ¬´jsonWithComm¬ª,   .comm2json()   ). ,  JSON.stringify      ,        ¬´jsObjWithComm¬ª. <br><br> 2)        . <br><br> 3)     .   JSON    . <br><br> 4)   Grunt, Gulp,‚Ä¶. <br><br>             issues,       (     ,     ). <br><br> ‚óè ,   ‚Äî  : <a href="https://github.com/spmbt/jsonComm">jsonComm ‚Äî  (Github)</a> , <a href="http://spmbt.github.io/jsonComm/">  (.)</a> . <br> ‚óè <a href="http://www.json.org/">Json ‚Äî </a> , <a href="http://www.ietf.org/rfc/rfc4627.txt">rfc-4627   </a> , <a href="http://rfc7159.net/rfc7159">rfc-7159 ( 2014):  </a> . <br> ‚óè  " <a href="http://stackoverflow.com/questions/244777/can-i-comment-a-json-file">   JSON?</a> "  SO. <br> ‚óè <a href="http://blog.getify.com/json-comments/">JSON.minify() ()</a>  <a href="http://github.com/getify/JSON.minify">Github</a> . <br> ‚óè <a href="https://github.com/sindresorhus/grunt-strip-json-comments">grunt-</a> , <a href="https://github.com/sindresorhus/gulp-strip-json-comments">gulp</a> , <a href="https://github.com/sindresorhus/broccoli-strip-json-comments">broccoli-</a> , <a href="https://github.com/sindresorhus/strip-json-comments">strip-json-comments (Github)</a> <br> ‚óè <a href="https://github.com/numbcoder/json-comments">JSON Comments</a> ( ) <br> ‚óè <a href="http://bolinfest.com/essays/json.html">   JSON</a> (., 2011) <br> ‚óè <a href="http://json5.org/">JSON5</a> (  ) <br> ‚óè <a href="http://laktak.github.io/hjson/">Hjson, the Human JSON</a> (Hjson keep my comments when updating a config file.) </div><p>Source: <a href="https://habr.com/ru/post/247473/">https://habr.com/ru/post/247473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247461/index.html">How to Install Btier on Debian Wheezy</a></li>
<li><a href="../247465/index.html">imarker - commercial SORM-like web analytics already with your provider</a></li>
<li><a href="../247467/index.html">Open-rynda: crowdsourcing solutions for emergency situations and volunteer network coordination</a></li>
<li><a href="../247469/index.html">Some interesting and useful things for web developer # 36</a></li>
<li><a href="../247471/index.html">Messages in depth: the amazing story of the underwater Internet</a></li>
<li><a href="../247475/index.html">Real-Time Interactive Cyber ‚Äã‚ÄãAttack Maps</a></li>
<li><a href="../247477/index.html">QQuickRenderControl, or how to make QML friends with someone else's OpenGL context. Part I</a></li>
<li><a href="../247481/index.html">Year npm in numbers: 2014</a></li>
<li><a href="../247483/index.html">Dnipropetrovsk Discussion Meetup: CQRS Problem / Solution</a></li>
<li><a href="../247487/index.html">Why vi-ax programmer 21st century</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>