<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ruby and GOST cryptographic algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In life, not every developer comes the moment when they have to interact with government systems. And few of them have to interact with the Russian st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ruby and GOST cryptographic algorithms</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e19/0fb/39a/e190fb39ac35b29a24e8ebca65c2ae3e.png" align="left" alt="Ruby Logo and Stern GOST Padlock">  In life, not every developer comes the moment when they have to interact with government systems.  And few of them have to interact with the Russian state systems.  And so it happened the stars, that I was one of these "lucky ones". <br><br>  The peculiarity of the Russian sovereign IT is that everywhere where it is necessary to ensure security (encryption) and integrity (signature) of information, it is necessary to use only domestic cryptoalgorithms (which are standardized and described in a good dozen of state standards and RFCs).  This is very logical from the point of view of national security, but it is very painful from the point of view of development in a not very popular language (these are javisty favored by attention from all sides). <br><br>  And so, when we faced the task of a very dense exchange of messages with a GOST electronic signature from one of these systems, the proposed solution in the form of a network SOAP service that signed requests (and answers) I didn‚Äôt like the word ‚Äúabsolutely‚Äù (wrapping SOAP SOAP is some kind of nightmare squared).  The long May weekend came, and when it was over - I had a better decision ... <br><a name="habracut"></a><br>  And this is Ruby with <b>native</b> support for GOST cryptoalgorithms.  No new external dependencies.  Want to try?  Go! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Installation </h4><br><h5>  OpenSSL setup </h5><br>  In order for everything related to GOST algorithms to work, a configured OpenSSL, version 1.0.0 or later, is required.  In Linux, there is an "out of the box", in OS X, you need to install from HomeBrew (because Apple is a sloop box): <br><br><pre><code class="bash hljs">brew install openssl brew link --force openssl</code> </pre> <br>  How to configure OpenSSL for GOST on the Internet have been written many, many times, I recommend using the original manual: <a href="">README.gost</a> <br><br><div class="spoiler">  <b class="spoiler_title">Read immediately, do not follow third-party links!</b> <div class="spoiler_text">  In Ubuntu Linux, the configuration file is on the path <code>/etc/ssl/openssl.cnf</code> , in OS X - on the path <code>/usr/local/etc/openssl/openssl.cnf</code> . <br><br>  It is necessary to add the following line to the very beginning of the file: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">openssl_conf</span></span> = openssl_def</code> </pre><br>  And the following sections at the very end of the file: <br><br><pre> <code class="hljs objectivec">[openssl_def] engines = engine_section [engine_section] gost = gost_section [gost_section] default_algorithms = ALL engine_id = gost CRYPT_PARAMS = <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>-Gost28147<span class="hljs-number"><span class="hljs-number">-89</span></span>-CryptoPro-A-ParamSet</code> </pre><br>  The last section may require the <code>dynamic_path</code> parameter, but is not needed in recent versions of Linux and Mac OS X.  If necessary, its value can be found with the command <code>locate libgost.so</code> . <br><br>  After these actions, if the <code>openssl ciphers | tr ":" "\n" | grep GOST</code> <code>openssl ciphers | tr ":" "\n" | grep GOST</code>  <code>openssl ciphers | tr ":" "\n" | grep GOST</code> will return the following lines, everything is configured correctly: <br><br><pre> <code class="hljs">GOST2001-GOST89-GOST89 GOST94-GOST89-GOST89</code> </pre><br></div></div><br><h5>  Ruby </h5><br>  In order for Ruby to also begin to understand everything GOST, I‚Äôll need to put a couple of patches from my <a href="https://bugs.ruby-lang.org/issues/9822"># 9022</a> and <a href="https://bugs.ruby-lang.org/issues/9830"># 9030</a> bug reports.  These patches successfully superimposed on Ruby versions 2.0.0 and 2.1.x, with other versions did not check. <br><br><div class="spoiler">  <b class="spoiler_title">What are these patches?</b> <div class="spoiler_text">  Well, look at them yourself, that you have never seen C code, have you? <br><br>  The first one inserts a call to the OPENSSL_config magic OpenSSL function <code>OPENSSL_config</code> where Ruby initializes OpenSSL for itself.  This causes OpenSSL to become interested in the config, which we have just ruled with and apply it.  Thanks to the xtron <a href="https://habrahabr.ru/users/xtron/" class="user_link">habraiser</a> , which in <a href="http://habrahabr.ru/post/189352/">its article</a> did the same, but for PHP (and struggled with the same problem as we, by the way).  With this patch, Ruby can already access HTTPS hosts with GOST encryption, for example (but without certificate authorization). <br><br>  The second patch, by means of forgery of conditions and unauthorized removal of checks, makes Ruby naively believe that the GOST keys are the keys on the elliptic curves (Elliptic Curve, EC), which, however, although it seems, is true, but the solution‚Äôs catholicity is not justifies.  With this patch, Ruby will begin to ‚Äúrecognize‚Äù GOST private and public keys, make an electronic signature and encryption.  In general, everything will be fine. <br></div></div><br>  Using RVM, installation is done with the command: <br><br><pre> <code class="bash hljs">rvm install ruby-2.1.2-gost --patch https://bugs.ruby-lang.org/attachments/download/4420/respect_system_openssl_settings.patch --patch https://bugs.ruby-lang.org/attachments/download/4415/gost_keys_support_draft.patch</code> </pre><br>  In the case of Rbenv (ruby-build), everything is somewhat more complicated, you will have to execute two commands (this method is not specifically tested): <br><br><pre> <code class="bash hljs">cp ~/.rbenv/plugins/ruby-build/share/ruby-build/{2.1.2,ruby-2.1.2-gost} <span class="hljs-comment"><span class="hljs-comment">#  ,    Ruby   .   ,      ‚Äî     curl -sSL https://gist.githubusercontent.com/Envek/82be109c58a0a565d382/raw/44e2330f233d7e5be707482ca94754a3a71cbe68/ruby_enable_gost.patch | rbenv install ruby-2.1.2-gost --patch</span></span></code> </pre><br>  Done! <br><br>  As a result, you will have a separate Ruby installed named <code>ruby-2.1.2-gost</code> .  This name can be written to a <code>.ruby-version</code> file, and this instruction in the <code>README</code> , and then it will always be clear that the project needs an unusual Ruby ... <br><br><div class="spoiler">  <b class="spoiler_title">Installation on servers using Puppet</b> <div class="spoiler_text">  When the time comes to put Ruby on the server, the Rbenv module for Puppet can help you, for example, but not simple, but also patched.  You will need a patch from the gitamub-gsamokovarov user who is here: <a href="https://github.com/alup/puppet-rbenv/pull/95">github.com/alup/puppet-rbenv/pull/95</a> .  In order not to suffer much - here is the instruction for installing the module on the server: <br><br><pre> <code class="ruby hljs">git clone git@github.<span class="hljs-symbol"><span class="hljs-symbol">com:</span></span>Envek/puppet-rbenv.git <span class="hljs-comment"><span class="hljs-comment">#         gem install puppet cd puppet-rbenv puppet module build .</span></span></code> </pre><br>  Now, from the <code>pkg</code> directory, you can get a freshly baked archive with the module, upload it to the server and install it with the command <code>puppet module install /path/to/alup-rbenv-1.2.1.tar.gz</code> (the <code>--force</code> key may still be required) and restart Puppet -master (puppet likes to cache ruby-code of used modules). <br></div></div><br><h5>  Convert key pairs to a format that OpenSSL understands </h5><br>  Your keys and self-signed certificates can be generated by the <a href="">official manual</a> . <br><br>  However, of course, of interest are the original key pairs on the token (most likely), either in the form of a daddy with six files or a floppy disk image. <br><br>  Unfortunately, so far the only working option to export the keys in the desired format is the Lissy-Software utility <a href="http://soft.lissi.ru/products/utils/p12fromcsp/">P12fromCSP</a> .  Unfortunately, only under Windows and paid.  You have to buy, but before this demo version of the program you can check whether it will help you in principle.  Be warned that the program is purchased by bank transfer (via online banking), and this is unbearably long - 3-4 days. <br><br>  You need a machine with Windows and Crypto Pro.  Using Crypto Pro, install the certificate from the key carrier into the system.  If the keys are in the form of a file folder, create a virtual diskette and copy them there, this Krypto Pro diskette will recognize it as a key carrier.  After installing the certificate, make sure that it is in the system (there is a ‚ÄúCertificates‚Äù shortcut in the ‚ÄúStart‚Äù folder in the Crypto Pro folder).  And run the utility, it should show the list, and in it your certificate, select it and save it to a file (at this stage the utility will ask you to eat). <br><br>  If you did everything right, but the certificate was not displayed in the utility, then there are two possible reasons: <br><br><ol><li>  You have a smart card token.  The private key cannot be exported physically.  Alas. </li><li>  The key is marked as unexported, the utility will refuse to export it.  Is it possible to get around this - I do not know. </li></ol><br>  The resulting file with the extension .p12 or .pfx drag on the machine with OpenSSL and pull out of it the certificate and private key with the following commands: <br><br>  Certificate: <code>openssl pkcs12 -engine gost -in gost.pfx -clcerts -nokeys -out gost.crt</code> <br><br>  Private key: <code>openssl pkcs12 -engine gost -in gost.pfx -nocerts -nodes -out gost.pem</code> <br><br>  Now you can work and work! <br><br><h4>  What to do with it? </h4><br>  If you are interested, it means that you ALREADY have to do something.  Look, here are just a small fraction of what is now possible and accessible to us: <br><br><h5>  General </h5><br>  In order for everything related to GOST algorithms to work in Ruby, you must first get OpenSSL goss engine, like this: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'openssl'</span></span> OpenSSL::Engine.load @gost_engine = OpenSSL::Engine.by_id(<span class="hljs-string"><span class="hljs-string">'gost'</span></span>) @gost_engine.set_default(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   ,    ,     </span></span></code> </pre><br>  After executing this magic piece of code, all further examples will start working.  We still need the <code>@gost_engine</code> variable. <br><br><h5>  Digital signature of a piece of data and its verification </h5><br>  Simple signature: <br><br><pre> <code class="ruby hljs">pkey = OpenSSL::PKey.read(File.read(<span class="hljs-string"><span class="hljs-string">'gost.pem'</span></span>)) data = <span class="hljs-string"><span class="hljs-string">'Same message'</span></span> digester = @gost_engine.digest(<span class="hljs-string"><span class="hljs-string">'md_gost94'</span></span>) signature = privkey.sign(digester, data)</code> </pre><br>  Simple signature verification: <br><br><pre> <code class="ruby hljs">cert = OpenSSL::X509::Certificate.new(File.read(<span class="hljs-string"><span class="hljs-string">'gost.crt'</span></span>)) digester = @gost_engine.digest(<span class="hljs-string"><span class="hljs-string">'md_gost94'</span></span>) data = <span class="hljs-string"><span class="hljs-string">'Same message'</span></span> cert.public_key.verify(dgst94, signature, data) <span class="hljs-comment"><span class="hljs-comment"># Should be true cert.public_key.verify(dgst94, signature, data.sub('S', 'Not s')) # Should be false</span></span></code> </pre><br>  Creating a detached-signature (hello to the registry of prohibited sites): <br><br><pre> <code class="ruby hljs">cert = OpenSSL::X509::Certificate.new(File.read(<span class="hljs-string"><span class="hljs-string">'gost.crt'</span></span>)) pkey = OpenSSL::PKey.read(File.read(<span class="hljs-string"><span class="hljs-string">'gost.pem'</span></span>)) data = <span class="hljs-string"><span class="hljs-string">'Some message'</span></span> signed = OpenSSL::PKCS7::sign(crt, key, data, [], OpenSSL::PKCS7::DETACHED)</code> </pre><br>  Validation of detached signatures with certificate verification: <br><br><pre> <code class="ruby hljs">cert_store = OpenSSL::X509::Store.new cert_store.set_default_paths <span class="hljs-comment"><span class="hljs-comment">#        #      ,               (,    OS X) cert_store.add_file 'uec.cer' #     ,  ‚Äî    data = File.read('-') #   signature = OpenSSL::PKCS7.new(File.read('-.sig')) #   signature.verify(signature.certificates, cert_store, data, OpenSSL::PKCS7::DETACHED) #  -OR-  OpenSSL::PKCS7::NOVERIFY,     </span></span></code> </pre><br><h5>  Digital Signature XML (incl. SOAP) messages </h5><br>  Gem <a href="https://github.com/ebeigarts/signer">signer</a> , which, after several pull requests, perfectly signs ‚Äúaccording to GOST‚Äù, will perfectly cope with this.  Thanks to Edgars Beigarts for creating the gem, as well as patience and help in the process of receiving pull requests. <br><br>  Here, for example, is how to sign XML with the help of signer for SMEV: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sign_for_smev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xml)</span></span></span></span> signer = Signer.new(xml) signer.cert = OpenSSL::X509::Certificate.new(File.read(Settings.smev.cert_path)) signer.private_key = OpenSSL::PKey.read(File.read(Settings.smev.pkey_path)) signer.digest_algorithm = <span class="hljs-symbol"><span class="hljs-symbol">:gostr3411</span></span> namespaces = { <span class="hljs-string"><span class="hljs-string">'soap'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'http://schemas.xmlsoap.org/soap/envelope/'</span></span>, } <span class="hljs-comment"><span class="hljs-comment"># Digest soap:Body tag signer.document.xpath('/soap:Envelope/soap:Body', namespaces).each do |node| signer.digest!(node) end # Sign document itself signer.sign!(security_token: true) signer.to_xml end</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">And here is another example, for another system whose requirements are stricter</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sign_for_system_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xml)</span></span></span></span> signer = Signer.new(xml) signer.cert = OpenSSL::X509::Certificate.new(File.read(Settings.smev.cert_path)) signer.private_key = OpenSSL::PKey.read(File.read(Settings.smev.pkey_path)) signer.digest_algorithm = <span class="hljs-symbol"><span class="hljs-symbol">:gostr3411</span></span> namespaces = { <span class="hljs-symbol"><span class="hljs-symbol">wsa:</span></span> <span class="hljs-string"><span class="hljs-string">'http://www.w3.org/2005/08/addressing'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">soap:</span></span> <span class="hljs-string"><span class="hljs-string">'http://www.w3.org/2003/05/soap-envelope'</span></span>, } <span class="hljs-comment"><span class="hljs-comment"># Digest WS-Addressing nodes signer.document.xpath('/soap:Envelope/soap:Header/wsa:*', namespaces).each do |node| signer.digest!(node) end # Digest soap:Body tag signer.document.xpath('/soap:Envelope/soap:Body', namespaces).each do |node| signer.digest!(node) end # Digest our own certificate signer.digest!(signer.binary_security_token_node) # Sign document itself signer.sign! signer.to_xml end</span></span></code> </pre></div></div><br>  To check these messages, the <code>Akami::WSSE::VerifySignature</code> from the <code>Akami::WSSE::VerifySignature</code> <a href="https://github.com/savonrb/akami">master</a> can be useful.  It will verify the signature is correct, but the verification of the certificate and whether all the necessary tags have been signed remains with you: <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signed_xml)</span></span></span></span> verifier = Akami::WSSE::VerifySignature.new(signed_xml) verifier.verify! <span class="hljs-comment"><span class="hljs-comment">#   ,     verifier.certificate #   ,      ‚Äî   . signed_xml end</span></span></code> </pre><br><h5>  HTTPS walking with encryption according to GOST and certificate authentication </h5><br>  There are no differences at all.  The only thing you need is to add root certificates from the servers that you go to to the system (here, however, Mac OS X has problems). <br><br>  You take your favorite library ( <code>Net::HTTP</code> is it, <a href="httpirb.com/"><code>HTTPI</code></a> is), give it an https address, your key and certificate, and let's go! <br><br>  As a test, you can try to access the <a href="https://ssl-gost.envek.name/">ssl-gost.envek.name</a> website <a href="https://ssl-gost.envek.name/">.</a> Attention, regular browsers (and unpatched Ruby) will not go to it and the page will not show you, because GOST cryptoalgorithms are not understood, and only Firefox will show a clear error message. <br><br><h5>  And many many others </h5><br>  In general, the use of GOST algorithms does not differ from the use, for example, RSA.  Therefore, all materials on the Internet, such as <a href="https://github.com/augustl/ruby-openssl-cheat-sheet">Ruby OpenSSL Cheat Sheet</a> will help you.  I, it seems, said everything I knew. <br><br>  It is important to note that OpenSSL (and, accordingly, Ruby) so far supports only old algorithms: ** GOST 28147-89 ** (symmetric encryption), ** GOST R 34.11-94 ** (hashing algorithm) and ** GOST P 34.10-2001 ** (asymmetric encryption and digital signature).  Patches to support the new algorithms have already been sent to OpenSSL by someone, apparently, very cool, by the name of Dmitry Olshansky and they can be viewed on the githaba: <a href="https://github.com/openssl/openssl/pull/68">openssl / openssl # 68</a> and <a href="https://github.com/openssl/openssl/pull/75">openssl / openssl # 75</a> , so we are waiting and hoping that they will accept . <br><br><h4>  Finally </h4><br>  This is how it is pleasant and ‚Äúnative‚Äù to work with GOST EDS and other things.  It's really simple and cool (and fast - after all, the methods for working with OpenSSL in Ruby are just ‚Äúwrappers‚Äù around the C library). <br><br>  If you have additions, corrections and questions, I look forward to it! </div><p>Source: <a href="https://habr.com/ru/post/231261/">https://habr.com/ru/post/231261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231249/index.html">Plastic, steel and two Teflon nozzles. New 3d ÊâìÂç∞Êú∫ from China</a></li>
<li><a href="../231251/index.html">Extreme sister of the Earth. The Past and Future of the Morning Star</a></li>
<li><a href="../231253/index.html">What is publicly available information?</a></li>
<li><a href="../231255/index.html">Python-digest # 34. News, interesting projects, articles and interviews [July 20, 2014 - July 27, 2014]</a></li>
<li><a href="../231259/index.html">Sense: smart alarm clock, sleep quality tracker and air quality analyzer</a></li>
<li><a href="../231263/index.html">Simple Science - Experiment Digest # 35</a></li>
<li><a href="../231265/index.html">"Roskosmos" briefly lost control over the satellite with geckos on board</a></li>
<li><a href="../231267/index.html">A tale about a white bull or how to stay invisible behind glass</a></li>
<li><a href="../231269/index.html">Fast creation of graphic resources from mdpi to xxhdpi</a></li>
<li><a href="../231271/index.html">Stanford is experimenting with carbon coating for lithium batteries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>