<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for repetitions in a two-dimensional array, or computational complexity by example</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear habrasoobschestvo. 

 When I studied at the institute in the second or third year (that is, in general, not so long ago), I had, among ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for repetitions in a two-dimensional array, or computational complexity by example</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear habrasoobschestvo. <br><br>  When I studied at the institute in the second or third year (that is, in general, not so long ago), I had, among others, a subject called ‚Äúalgorithms and data structures‚Äù.  They told there, however, not only about the algorithms and structures themselves, but also about such a concept as ‚Äúcomputational complexity‚Äù.  I admit, then it did not really interest me. <br><br>  ‚ÄúSurely bothering with the study of the algorithm for spatial and temporal complexity is necessary only when developing either very high-performance / high-loaded systems, or when working with really <b>large</b> amounts of data,‚Äù some such thoughts visited me (and, probably, not only me) then. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, recently I had to greatly change my opinion because of a seemingly simple task. <br><a name="habracut"></a><br>  The task consisted of the following: there were Excel tables with some (mostly numerical) data.  These data, without going into details, were identifiers used in the subsystems.  It was necessary to find duplicate values ‚Äã‚Äãin the tables, and, depending on various factors, to decide what to do with them.  At this stage, you may already have the question: "Why not do it automatically?".  In fact, the tables contained those data sets that the automated system could not cope with and which required human intervention. <br>  Naturally, manually selecting a large amount of data (on average about 5-10 columns and 1000 lines per document) is a thankless job, so I decided to simplify the process a little, at least in terms of searching for repetitions. <br>  Since it was impossible to write a separate utility on C because of the strict rules of the organization, I had to read a little about VBA (which I did not know completely), and come up with a solution in the form of a VBA macro. <br><br>  So, we proceed directly to the algorithms. <br>  In fact, the task of finding repetitions on an Excel sheet is simply the task of finding repetitions in a two-dimensional array.  But how to do that?  Oddly enough, Google was completely unable to help me in solving such a seemingly trivial task, and I had to think a little about it. <br><br><h5>  A simple solution </h5><br><br>  The simplest, most direct and elementary solution that comes to mind is simply element-wise comparison.  On VBA, it looks like this: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Sub </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindMatches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> Dim sCol, sRow, cCol, cRow As Integer For sCol </span></span>= <span class="hljs-number"><span class="hljs-number">1</span></span> To <span class="hljs-number"><span class="hljs-number">10</span></span> For sRow = <span class="hljs-number"><span class="hljs-number">1</span></span> To <span class="hljs-number"><span class="hljs-number">10</span></span> For cCol = sCol + <span class="hljs-number"><span class="hljs-number">1</span></span> To <span class="hljs-number"><span class="hljs-number">10</span></span> For cRow = <span class="hljs-number"><span class="hljs-number">1</span></span> To <span class="hljs-number"><span class="hljs-number">10</span></span> If Cells(sRow, sCol) = Cells(cRow, cCol) Then If Cells(sRow, sCol).Font.Color = RGB(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) Then Cells(sRow, sCol).Font.Color = RGB(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) End If Cells(cRow, cCol).Font.Color = RGB(<span class="hljs-number"><span class="hljs-number">150</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) End If Next cRow Next cCol Next sRow Next sCol End Sub</code> </pre> <br><br>  Thus, we take each cell of the table, and compare it with all the cells that are after it (it is worth noting that in the column where the occurrence of an element occurs for the first time, there can be no repetitions, so we start the comparison with the next column) and if we find a match, paint them in red.  Conveniently?  Full  However, it is here that computational complexity shows teeth.  This is how long the processing takes on my not very seemingly weak machine: <br><br><ul><li>  100 cells (10x10) - 70 milliseconds </li><li>  200 cells (10x20) - 240 milliseconds </li><li>  400 cells (10x40) - 920 milliseconds </li><li>  2000 cells (20x100) - 23535 milliseconds </li></ul><br><br>  In general, we can say that with an increase in the number of elements at the input n times, the operation time will increase n <sup>2</sup> times.  Of course, such a decision was unacceptable to me. <br><br><h5>  Slightly less simple solution </h5><br><br>  So, let's try to speed up our algorithm a bit.  The first thing I realized is that the access operation directly to the cells of the sheet takes a huge amount of time, and the number of these operations should be tried to be minimized.  As a solution to this problem, I chose the original data entry from the cells into the memory, and work with this memory.  For this we are ideally suited a two-dimensional array. <br><br>  For the general reduction in the number of operations, I decided to write each unique value to a separate array, and make a comparison only with this array of unique elements.  It looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Sub </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindMatches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> Dim row As Integer </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  Dim col As Integer //  Dim Values(5000, 5) As Integer //   Dim DistinctValues() As Integer //  Dim DistinctCount As Integer //   Dim i As Integer // Dim IsUnique As Boolean //  //        ReDim DistinctValues(0 To 0) DistinctCount = 0 //   Values   . For col = 1 To 5 For row = 1 To 5000 Values(row, col) = Cells(row, col) Next row Next col // . For col = 1 To 5 For row = 1 To 5000 //    Values  .            DistinktValues. IsUnique = True For i = 0 To DistinctCount - 1 If DistinctValues(i) = Values(row, col) Then //  ,       . IsUnique = False Cells(row, col).Font.Color = RGB(255, 75, 75) Exit For End If Next i //  ,      ,       DistinctValues,      If IsUnique = True Then DistinctCount = DistinctCount + 1 ReDim Preserve DistinctValues(0 To DistinctCount) DistinctValues(DistinctCount - 1) = Values(row, col) Cells(row, col).Font.Color = RGB(75, 175, 75) End If Next row Next col End Sub</span></span></span></span></code> </pre><br><br>  So, we have significantly reduced the number of element comparison operations by comparing only with the unique elements already encountered.  We also reduced the number of operations on cells in the sheet to two (the first is the preservation of the cell value in the array, the second is the painting of the cell).  How much has the running time decreased? <br><br>  Unfortunately, the speed of this algorithm is highly dependent on the entropy of the input data.  Since we are comparing with an array of unique elements, the larger this array is, the more time we will need.  In other words, the more unique elements in the input data, the slower the algorithm will work.  I conducted two tests for 25,000 cells (5 columns and 5000 rows).  In the first test, all cells were filled with the same value (1); in the second, on the contrary, they were filled with different values ‚Äã‚Äãwithout repetitions. <br>  For the first case, the work of the algorithm took 816 milliseconds, and for the second - almost <b>19 seconds</b> .  And yet, it is much faster than our first full brute force, which could digest 25,000 cells in a breathtaking 58 <i>minutes</i> . <br><br>  However, the pursuit of the best knows no limit.  After some thought, I decided not to reinvent the wheel, but to use proven algorithms.  My choice fell on the quick sort algorithm, which is known to have O (n log n) complexity. <br><br><h5>  Fast decision </h5><br><br>  So, how can you use quick sorting to solve my problem? <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  . Type MyCell row As Long col As Long Value As Long End Type //  ,            . Sub QSort(sortArray() As MyCell, ByVal leftIndex As Long, _ ByVal rightIndex As Long) Dim compValue As MyCell Dim i As Long Dim J As Long Dim tempNum As MyCell i = leftIndex J = rightIndex compValue = sortArray(CLng((i + J) / 2)) //  . Do Do While (sortArray(i).Value &lt; compValue.Value And i &lt; rightIndex Or _ (sortArray(i).Value = compValue.Value And sortArray(i).col &lt; compValue.col) Or _ (sortArray(i).Value = compValue.Value And sortArray(i).col = compValue.col And sortArray(i).row &lt; compValue.row)) i = i + 1 Loop Do While (compValue.Value &lt; sortArray(J).Value And J &gt; leftIndex Or _ (sortArray(J).Value = compValue.Value And sortArray(J).col &gt; compValue.col) Or _ (sortArray(J).Value = compValue.Value And sortArray(J).col = compValue.col And sortArray(J).row &gt; compValue.row)) J = J - 1 Loop If i &lt;= J Then tempNum = sortArray(i) sortArray(i) = sortArray(J) sortArray(J) = tempNum i = i + 1 J = J - 1 End If Loop While i &lt;= J If leftIndex &lt; J Then QSort sortArray(), leftIndex, J If i &lt; rightIndex Then QSort sortArray(), i, rightIndex End Sub Sub FindMatches() //   Dim myRange As Range Set myRange = Selection //      Dim ColCount, RowCount As Integer ColCount = myRange.Columns.Count RowCount = myRange.rows.Count Dim FirstCol, FirstRow As Integer FirstCol = myRange.Column FirstRow = myRange.row //   ,       . Dim MyCells() As MyCell ReDim MyCells(ColCount * RowCount) Dim col, row As Integer Dim i As Long For col = FirstCol To FirstCol + ColCount - 1 For row = FirstRow To FirstRow + RowCount - 1 MyCells(CLng((col - FirstCol) * RowCount + row - FirstRow)).row = row MyCells(CLng((col - FirstCol) * RowCount + row - FirstRow)).col = col MyCells(CLng((col - FirstCol) * RowCount + row - FirstRow)).Value = CLng(Val(Cells(row, col))) Next row Next col //      Call QSort(MyCells, 0, ColCount * RowCount - 1) // . Cells(1, 1).Font.Color = RGB(0, 255, 0) For i = 1 To ColCount * RowCount - 1 If MyCells(i).Value &lt;&gt; MyCells(i - 1).Value Then Cells(MyCells(i).row, MyCells(i).col).Font.Color = RGB(0, 255, 0) Else Cells(MyCells(i).row, MyCells(i).col).Font.Color = RGB(255, 0, 0) End If Next i Cells(MyCells(firstOccurance).row, MyCells(firstOccurance).col).Font.Color = RGB(0, 255, 0) End Sub</span></span></code> </pre><br><br>  In addition to the sorting itself, I also added the processing of the selected area on the sheet, because it is more convenient. <br><br>  The principle of operation of this algorithm is very simple.  We create a data structure that stores the cell address (row and column number) and its value.  Then from these structures an array is created, into which all data from the sheet are entered.  The array is sorted by quick sort. <br>  After that, it is enough to go through the sorted array once, coloring the elements: the first element in the group with the same values ‚Äã‚Äãis green, all the rest are red. <br><br>  It should be noted that the quick sort algorithm itself is unstable, that is, it does not preserve the order of elements with the same key.  Since, in our case, the key was the cell value, in the classical version, in each group of elements with the same value, the elements would be arranged in a random order.  Obviously, this does not suit me, since then in order to search for the first occurrence in the table, it would be necessary to sort each group once more, already by the cell number.  To avoid this, I expanded the quick sort key by adding two additional conditions for rearranging placema elements: now, if the values ‚Äã‚Äãmatch, the elements will be arranged in the order in which they occur on the sheet. <br><br>  How big was the performance gain?  A sheet with 100,000 cells with random values ‚Äã‚Äãis processed by this algorithm in 4.2 seconds, which, in my opinion, is an acceptable result. <br><br>  So, what conclusions can be drawn from all this? <br><ol><li>  First, the problem of the computational complexity of the algorithm is relevant even for completely seemingly simple tasks, and in order to face it it is not necessary to work with some absolutely incredible amounts of data; </li><li>  Secondly, do not try to reinvent the wheel.  In many cases, the best option would be to adapt proven classical algorithms for a specific task. </li></ol><br><br><pre>  PS Since the &lt;source&gt; tag does not support VBA highlighting, in order to highlight at least comments, I had to use C highlighting and C-style comments. </pre></div><p>Source: <a href="https://habr.com/ru/post/141258/">https://habr.com/ru/post/141258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141253/index.html">Flexible "electronic paper"</a></li>
<li><a href="../141254/index.html">Digest of new materials in Russian MSDN for March</a></li>
<li><a href="../141255/index.html">Do not store any extra information: it is too expensive</a></li>
<li><a href="../141256/index.html">Questions at the Google interview</a></li>
<li><a href="../141257/index.html">Data structures in haskell and how they affect garbage collector</a></li>
<li><a href="../141259/index.html">Test Automation / Customize Cucumber, Capybara & Selenium-WebDriver</a></li>
<li><a href="../141260/index.html">Stars of the world frontend 3. Here the Russian spirit, here Russia smells</a></li>
<li><a href="../141261/index.html">Displaying neighboring documents in MODX Evolution</a></li>
<li><a href="../141262/index.html">Error in most browsers</a></li>
<li><a href="../141263/index.html">Freeware does not happen much?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>