<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple Stack Fragment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good time of day, dear readers of Habr! I want to bring to your attention an article based on my experience in the Single Activity Architecture, in pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple Stack Fragment</h1><div class="post__text post__text-html js-mediator-article">  Good time of day, dear readers of Habr!  I want to bring to your attention an article based on my experience in the Single Activity Architecture, in particular, with a stack of user views. <br><br>  When I first met Single Activity Architecture, I had many questions: ‚ÄúHow can I manage the moment of adding and deleting fragments?‚Äù, ‚ÄúHow can you keep the button pressed back?‚Äù, ‚ÄúIs it possible to run a fragment on the result?‚Äù, ‚ÄùHow can I understand when a user returned to the fragment? ‚Äùand so on. <br><a name="habracut"></a><br>  The first question is almost trivial.  You can create a single navigation class in which to transfer the fragment manager and use the transition function to the screen. <br><br>  The second question is also partially resolved by notifying the navigation class that a click on the back button has occurred.  But in this case, the navigator begins to be something more than just a keeper of paths, logic appears in it, which, in my opinion, is absolutely not justified.  But should someone in the system handle forward and backward movements? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are also some difficulties with returning a user to the fragment.  One of the most critical, in my opinion, is the repeated call to onCreateView.  As we all know, there appears a custom view as a View.  I also think it is no secret to anyone that this operation is quite voracious. <br><br>  The result is a class with a large number of transition logic, the creation of fragments of various kinds, questionable inserts of ‚Äúvery useful functionality‚Äù into the methods of processing a transition back (if the user added something on the previous screen, it is necessary to add it to the list).  In my opinion, this is not exactly what is required of the class that is responsible for navigating within the application.  The smart solution is to delegate part of the functionality to other parts of the system.  Thus, the essence of the stack of fragments appeared in my program. <br><br>  The requirements for the stack of fragments are almost trivial: add a fragment, go back, go to, except for some nuances.  For me, as a designer, the main problem was the life cycle of the added / removed fragments. Also a problem was the completion of the fragment with the result and sending the result to the consumer.  Fortunately, the solution was found rather quickly.  The internal logical structure I chose a slightly improved stack: a layer cake.  The idea is that the layers are stacked on the cake.  As a cake for our abstract cake, you can consider the entry point to the application (main fragment, home page, etc.).  Layers in turn have the following properties: <br><br><ul><li>  When you add a layer in the first place it is created.  Then carefully laid on the cake or layer that is on top. </li><li>  When removing a layer, the lower layer becomes visible, and the removed layer is ejected.  And really, why do we need a layer smeared in cream? </li></ul><br>  If you deviate from the sweet example, the addition is a transaction consisting of hiding the previous fragment and adding a new one.  Also in this operation, I added an alert to the hidden fragment that the user had gone from it, and a limit on the size of the stack.  The delete operation is more ornate, so everything is in more detail. <br><br>  The logic that is responsible for sending the result from the vendor fragment to the fragment is reasonable to put in a separate class.  For example, an imaginary screen for adding a record to the user's diary could return the added record for subsequent processing to the called block of the program.  This is a kind of onActivityResult. <br><br>  If we present all of the above in the diagram, it will look like this. <br><br><div class="spoiler">  <b class="spoiler_title">Scheme</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/aq/6_/xt/aq6_xtr_mcyfg-i_yy2llznt7ja.jpeg"><br></div></div><br><h3>  Effective fragments </h3><br>  To ensure performance, I created a separate ResultUtils class and a ResultableFragment interface. <br><br>  A consumer can be any fragment that extends the ResultableFragment interface.  This interface consists of a single function void onFragmentResult (final int requestCode, final int resultCode, final Bundle data).  This function is similar to onActivityResult. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResultableFragment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFragmentResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> requestCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Bundle data)</span></span></span></span>; }</code> </pre> <br>  The implementation of the <b>ResultUtils</b> class is a set of the following methods: <br><br><ul><li>  void addPromise (final Fragment currentFragment, final Fragment targetFragment, final int requestCode) - this method creates certain obligations (by the requestCode key) from the target fragment to the current one.  Here the current fragment is where the user goes from, and the target is where he wants to go.  The commitment system is a HashMap &lt;Integer, Integer&gt; in which the key is the hash of the current fragment, and the value is requestCode. </li><li>  void sendResultIfPossible (final Pair &lt;Fragment, Fragment&gt; fromToFragmentPair) - to call the onFragmentResult method and pass the corresponding parameters.  Why whenever possible?  Because not every fragment wants to send or receive results.  If successful, the result of the commitment can be considered fulfilled, and they are removed from the structure. </li><li>  void setResult (final Fragment fragment, final Bundle data, final int resultCode) - designed to set the result to the fragment.  The result, as well as the key, is stored in the arguments of this fragment. </li><li>  void onBackPressed (final Pair &lt;Fragment, Fragment&gt; fromToFragmentPair) - used to process the back button, sets the result ‚Äúfragment closed‚Äù with empty data. </li></ul><br><h3>  Advanced Life Cycle Techniques </h3><br>  I also needed an interface that combines all the fragments that obey the new life cycle.  I called this interface LifeBoundFragment.  The following methods are included: <br><br><ul><li>  onUserLeaveScreen - called when the user leaves the screen; </li><li>  onUserBack - called when the user returns to the screen. </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifeBoundFragment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUserLeaveScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUserBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><h3>  Stack </h3><br>  Working through the external interface of the stack, I identified the following main functions: <br><br><ul><li>  pushEntryPoint (Fragment home) - this method is designed to add an entry point to the stack.  In my case, this is a home fragment (the fragment, on which the user leaves the application by pressing the back button). </li><li>  push (Fragment target) - add a new fragment to the stack. </li><li>  push (final T target, final int requestCode) - add a new fragment to the stack with a request for some result. </li><li>  popToTarget (Class target) - go down until we meet the requested fragment.  If such a fragment is not found, then stop the descent at our entry point. </li><li>  pop is a direct transition backwards. </li><li>  boolean handleBackPressed - this method is passed from activation to the stack upon the onBackPressed event.  Returns true if the stack can handle pressing back.  Otherwise false. </li><li>  onActivityPause, onActivityResume are activation lifecycle methods.  These methods call the corresponding LifeBoundFragment methods to notify that the user has left / returned to the current screen. </li></ul><br>  I myself have organized the stack on a LinkedList structure.  The most interesting, from my point of view, are the methods: push (final T target, final int requestCode), pop () and popToTarget (Class target). <br><br><h4>  Push method (final T target, final int requestCode) </h4><br>  As mentioned earlier, this method adds a new fragment to the screen, hides the previous one and adds keys to the new one.  In order to hide the internal implementation, I created a private method <b>pushFragment</b> , which was responsible for all the logic of adding and deleting a fragment.  The pushFragment method returns Pair &lt;Fragment, Fragment&gt;.  This is essentially the direction of movement, where the key is a fragment from which the user goes, and the value is where.  As planned, when adding a fragment, we need to notify the fragment that is hidden, that the user leaves it.  To do this, it is enough to make sure that the hidden fragment extends the <b>LifeBoundFragment</b> interface, and send the <b>onUserLeaveScreen</b> event. <br><br>  Also in this method it is worth adding commitments through the ResultUtils utility class using the addPromise method. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Fragment target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultCode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pair&lt;Fragment, Fragment&gt; fromToFragmentPair = pushFragment(target); callPauseIfPossible(fromToFragmentPair.first); mResultUtils.addPromise(fromToFragmentPair.first, fromToFragmentPair.second, resultCode); }</code> </pre><br>  The most interesting here is the pushFragment method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Pair&lt;Fragment, Fragment&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Fragment navigationTargetFragment)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mStackLinkedList.size() &gt;= STACK_SIZE) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Fragment outOfStackFragment = mStackLinkedList.remove(<span class="hljs-number"><span class="hljs-number">1</span></span>); fragmentTransaction.remove(outOfStackFragment); } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Fragment leaveFragment = mStackLinkedList.getLast(); fragmentTransaction.hide(leaveFragment); mStackLinkedList.add(navigationTargetFragment); fragmentTransaction.add(R.id.fragmentContainer, navigationTargetFragment); fragmentTransaction.commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(leaveFragment, navigationTargetFragment); }</code> </pre><br>  In this method, all the main manipulation of the stack takes place, the previous fragment is hidden and the number of stack elements is limited. <br><br><h3>  Pop () method </h3><br>  The pop () method is also a kind of collective method. <br>  A feature of this method is the sendResultIfPossible call of the ResultUtils class. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pair&lt;Fragment, Fragment&gt; fromToFragmentPair = popFragment(); mResultUtils.sendResultIfPossible(fromToFragmentPair); }</code> </pre><br>  The basic logic of the popFragment method is quite predictable.  So I don‚Äôt see any sense in lingering on it. <br><br><div class="spoiler">  <b class="spoiler_title">PopFragment method</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Pair&lt;Fragment, Fragment&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Fragment leaveFragment = mStackLinkedList.removeLast(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Fragment targetFragment = mStackLinkedList.getLast(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction(); fragmentTransaction.remove(leaveFragment); callResumeIfPossible(targetFragment); fragmentTransaction.show(targetFragment); fragmentTransaction.commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(leaveFragment, targetFragment); }</code> </pre><br></div></div><br><h3>  PopToTarget method </h3><br>  This method, in my opinion, is the most interesting.  It combines almost everything. <br><br>  When I started developing the ResultUtils class functionality, one of my internal limitations was that the result when going backwards is passed along the chain.  Based on this limitation, the onFragmentResult method will be called along the chain until it hits the root call.  The fragments located in the middle of the chains, I began to call transit.  Indeed, they receive an onFragmentResult call, in which they can set the result for the next fragment of the chain. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popToTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Class&lt;? extends Fragment&gt; target)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Iterator&lt;Fragment&gt; iterator = mStackLinkedList.descendingIterator(); Pair&lt;Fragment, Fragment&gt; fromTransactionFragmentToCurrent = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iterator.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Fragment targetFragment = iterator.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetFragment.getClass() == target) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } fragmentTransaction.remove(targetFragment); iterator.remove(); fromTransactionFragmentToCurrent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(targetFragment, mStackLinkedList.getLast()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mStackLinkedList.getLast().getClass() != target) { mResultUtils.sendResultIfPossible( fromTransactionFragmentToCurrent); } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Fragment frontFragment = mStackLinkedList.getLast(); callResumeIfPossible(frontFragment); mResultUtils.sendResultIfPossible(fromTransactionFragmentToCurrent); fragmentTransaction.show(frontFragment); fragmentTransaction.commit(); }</code> </pre><br><h3>  In custody </h3><br>  In my opinion, a flexible, simple and reliable fragment management system was obtained.  At the moment I have been able to successfully apply this approach in a number of projects in which I participated.  Of the minuses that I encountered when using this approach is leanback (Android TV), but in part the system itself does not have to Single Activity Architecture.  Next, I plan to come up with a mechanism for storing / restoring history, launching an application with a given history (it will be useful for push notifications).  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/348996/">https://habr.com/ru/post/348996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348984/index.html">I wrote a mobile application - I want a patent</a></li>
<li><a href="../348986/index.html">‚ÄúCI doesn‚Äôt cope well with mobile development requirements‚Äù: interview with fastlane creator Felix Krause</a></li>
<li><a href="../348988/index.html">Mozilla has developed an open gateway for the Internet of things</a></li>
<li><a href="../348990/index.html">Autodial: Good and Evil</a></li>
<li><a href="../348994/index.html">Intellectual Innovation: New HPE Webinar Series</a></li>
<li><a href="../349000/index.html">Report of the Information Security Monitoring Center for the II half of 2017</a></li>
<li><a href="../349002/index.html">Win 100k on the hackathon of the Food Party and Touch Instinct in Petersburg</a></li>
<li><a href="../349004/index.html">The book "Linux API. Comprehensive Guide ¬ª</a></li>
<li><a href="../349006/index.html">Coding without a keyboard: creating a hands-free game</a></li>
<li><a href="../349010/index.html">Technical support: a technological approach to solving technical problems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>