<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to use linux epoll in python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes: 


- Examples of using blocking sockets 
- Benefits of asynchronous sockets and linux epoll 
- Examples of asynchronous use of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to use linux epoll in python</h1><div class="post__text post__text-html js-mediator-article">  The article describes: <br><ul><li>  Examples of using blocking sockets </li><li>  Benefits of asynchronous sockets and linux epoll </li><li>  Examples of asynchronous use of sockets through epoll </li><li>  Performance issues </li><li>  Source </li></ul><a name="habracut"></a><br><h4>  Introduction </h4><br>  Since version 2.6, Python includes an API for working with the <a href="http://linux.die.net/man/4/epoll">epoll</a> Linux library.  This article briefly demonstrates this API with Python 3 code examples. <br><br>  <i>From the translator.</i> <i><br></i>  <i>I tried not to abuse English terms as much as possible.</i>  <i>So ‚Äúregister / unregister‚Äù became ‚Äúsubscription / unsubscribe‚Äù, ‚Äúprint to the console‚Äù - ‚Äúconsole output‚Äù.</i>  <i>‚ÄúProduction server‚Äù decided to translate as ‚Äúloaded server‚Äù, since nothing better than ‚Äúproduction server‚Äù does not occur to me.</i>  <i>‚ÄúThread‚Äù translated as ‚Äústream‚Äù, not ‚Äúthread‚Äù.</i> <i><br></i>  <i>The names of events, modes and flags decided not to translate at all, giving only a one-time example of a possible translation.</i> <i><br></i>  <i>Although it is written that the code is for Python 3, everything works fine on Python 2.6.</i> <br><br><h4>  Examples of using blocking sockets </h4><br>  The first example is a simple Python 3.0 server that listens on port 8080 for incoming HTTP requests, displays them on the console, and sends an HTTP response message to the client. <br><ul><li>  <b>Line 9:</b> Create a server socket. </li><li>  <b>Line 10: We</b> allow <b>bind</b> () to be executed on line 11 even if another program has recently listened to the same port.  Without this, the program will not be able to work with the port for 1-2 minutes after the end of work with the same port in the previously launched program. </li><li>  <b>Line 11:</b> We hang (bind'im) server socket on port 8080 for all available IPv4 addresses of this machine. </li><li>  <b>Line 12: We</b> tell the server socket to start accepting incoming connections from clients. </li><li>  <b>Line 14:</b> The program will stop at this point until an incoming connection is received.  When this happens, the server socket will create a new socket that will be used on this machine to communicate with the client.  This new socket is represented by a <b>clientconnection</b> object, which is returned by a call to <b>accept</b> ().  The <b>address</b> object contains the IP address and port number of the remote machine. </li><li>  <b>Lines 15-17:</b> Generate the data that will be sent to the client to complete the HTTP request.  HTTP protocol is described <a href="http/">here</a> . </li><li>  <b>Line 18:</b> Display the request in the console as a validation action. </li><li>  <b>Line 19:</b> Sending response to client. </li><li>  <b>Lines 20-22:</b> Close the connection to the client as well as the listening server socket. </li></ul><br>  The official <a href="http://docs.python.org/3.0/howto/sockets.html">HOWTO</a> contains a more detailed description of socket programming in Python. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Example 1 <br><blockquote>  <font color="black"><a href="http://s-c.me/22051/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22051/h">Copy HTML</a></font> <ol><li>  <font color="#0000ff">import</font> socket </li><li></li><li>  EOL1 = b <font color="#008000">'\ n \ n'</font> </li><li>  EOL2 = b <font color="#008000">'\ n \ r \ n'</font> </li><li>  response = b <font color="#008000">'HTTP / 1.0 200 OK \ r \ nDate: Mon, 1 Jan 1996 01:01:01 GMT \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Content-Type: text / plain \ r \ nContent-Length: 13 \ r \ n \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Hello, world!'</font> </li><li></li><li>  serversocket = <b>socket</b> .  <b>socket</b> ( <b>socket</b> .AF_INET, <b>socket</b> .SOCK_STREAM) </li><li>  serversocket.setsockopt ( <b>socket</b> .SOL_SOCKET, <b>socket</b> .SO_REUSEADDR, <font color="#008000">1</font> ) </li><li>  serversocket.bind (( <font color="#008000">'0.0.0.0'</font> , <font color="#008000">8080</font> )) </li><li>  serversocket.listen ( <font color="#008000">1</font> ) </li><li></li><li>  connectiontoclient, address = serversocket.accept () </li><li>  request = b <font color="#008000">''</font> </li><li>  <font color="#0000ff">while</font> EOL1 is <font color="#0000ff">not in</font> request <font color="#0000ff">and</font> EOL2 is <font color="#0000ff">not in</font> request: </li><li>  request + = connectiontoclient.recv ( <font color="#008000">1024</font> ) </li><li>  <font color="#0000ff">print</font> (request.decode ()) </li><li>  connectiontoclient.send (response) </li><li>  connectiontoclient.close () </li><li></li><li>  serversocket.close () </li></ol></blockquote><br>  Example 2 adds a loop in line 15 to re-process client connections that are performed before a user interrupt (for example, from the keyboard).  This more clearly shows that the server socket is never used to exchange data with the client.  Rather, it only accepts the connection from the client and creates a new socket, which is already used for communication. <br>  The <b>finally</b> block in lines 23-24 is needed so that the listening server socket is closed in any case, even if errors occur. <br><br>  Example 2 <br><blockquote>  <font color="black"><a href="http://s-c.me/22052/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22052/h">Copy HTML</a></font> <ol><li>  <font color="#0000ff">import</font> socket </li><li></li><li>  EOL1 = b <font color="#008000">'\ n \ n'</font> </li><li>  EOL2 = b <font color="#008000">'\ n \ r \ n'</font> </li><li>  response = b <font color="#008000">'HTTP / 1.0 200 OK \ r \ nDate: Mon, 1 Jan 1996 01:01:01 GMT \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Content-Type: text / plain \ r \ nContent-Length: 13 \ r \ n \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Hello, world!'</font> </li><li></li><li>  serversocket = <b>socket</b> .  <b>socket</b> ( <b>socket</b> .AF_INET, <b>socket</b> .SOCK_STREAM) </li><li>  serversocket.setsockopt ( <b>socket</b> .SOL_SOCKET, <b>socket</b> .SO_REUSEADDR, <font color="#008000">1</font> ) </li><li>  serversocket.bind (( <font color="#008000">'0.0.0.0'</font> , <font color="#008000">8080</font> )) </li><li>  serversocket.listen ( <font color="#008000">1</font> ) </li><li></li><li>  <font color="#0000ff">try</font> : </li><li>  <font color="#0000ff">while</font> true: </li><li>  connectiontoclient, address = serversocket.accept () </li><li>  request = b <font color="#008000">''</font> </li><li>  <font color="#0000ff">while</font> EOL1 is <font color="#0000ff">not in</font> request <font color="#0000ff">and</font> EOL2 is <font color="#0000ff">not in</font> request: </li><li>  request + = connectiontoclient.recv ( <font color="#008000">1024</font> ) </li><li>  <font color="#0000ff">print</font> ( <font color="#008000">'-'</font> * <font color="#008000">40</font> + <font color="#008000">'\ n'</font> + request.decode () [: - <font color="#008000">2</font> ]) </li><li>  connectiontoclient.send (response) </li><li>  connectiontoclient.close () </li><li>  <font color="#0000ff">finally</font> : </li><li>  serversocket.close () </li></ol></blockquote><br><br><h4>  Benefits of asynchronous sockets and linux epoll </h4><br>  The sockets shown in Example 2 are called blocking sockets, because the Python program pauses its execution until the event arrives.  The <b>accept</b> () call on line 16 is blocked until the connection is received from the client.  The <b>recv</b> () call on line 19 is blocked until receiving data from the client (or until there is no data to receive).  The <b>send</b> () call on line 21 is blocked before all data sent to the client is added to the Linux send queue. <br><br>  When a program uses blocking sockets, it often uses a separate thread (or even process) to perform interaction with each of these sockets.  The main program flow contains a listening server socket, which accepts incoming connections from clients.  It accepts these connections one at a time, passing the newly created client socket to a separate thread that will interact with the client.  Since each of these flows is associated with only one client, it is acceptable that network locks occur in some places.  These locks do not prevent other threads from performing their tasks. <br><br>  Using blocking sockets with multiple threads leads to simple code, but is associated with a <a href="http://www.virtualdub.org/blog/pivot/entry.php%3Fid%3D62">series of flaws</a> .  It is difficult to be sure of the correct sharing of streams to shared resources.  And this programming style is not very effective on computers with a single CPU. <br><br>  <a href="http://www.kegel.com/c10k.html">Issue C10K</a> discusses alternative processing options for multiple concurrent sockets.  One of them is to use asynchronous sockets.  Such sockets are not blocked until the event arrives.  On the contrary, the program performs an action on an asynchronous socket and immediately receives a notification of success or error.  This information allows the program to decide how to proceed.  Since asynchronous sockets are non-blocking, there is no need for multiple execution threads.  All work can be done in a single thread.  Such a single-threaded approach has its own problems and is not a good choice for many programs.  But it can be combined with a multi-threaded approach: asynchronous sockets applied in a single stream can be used for the network component of the server, and streams can be used to access external blocking resources, such as databases. <br><br>  Linux 2.6 has a number of mechanisms for managing asynchronous sockets, three of which are represented in the Python API through <b>select</b> , <b>poll</b> and <b>epoll.</b>  <b>epoll</b> and <b>poll are</b> better than <b>select</b> , because the Python program does not need to keep track of all events of interest in the socket.  Instead, you can rely on the operating system to report which events occurred on which sockets.  And <b>epoll,</b> in turn, is better than <b>poll</b> , because it does not require the operating system to check all sockets for events of interest every time it is requested by the Python program.  Rather, when requesting from Python, Linux checks if these events have occurred, and returns a list of events.  So, <b>epoll is a</b> more efficient and scalable mechanism for a large number (thousands) of simultaneous connections, as shown in <a href="http://lse.sourceforge.net/epoll/index.html">these graphs</a> . <br><br><h4>  Examples of asynchronous use of sockets through epoll </h4><br>  Programs using epoll often work on the following principle: <br><ol><li>  An <b>epoll</b> object is created. </li><li>  <b>The epoll</b> object is indicated to monitor certain events on certain sockets. </li><li>  The <b>epoll</b> object is requested on which sockets the specified events occurred since the previous poll </li><li>  Some actions are performed on these sockets. </li><li>  <b>The epoll</b> object is indicated to change the list of sockets and / or observable events. </li><li>  Repeat steps 3 through 5 to completion. </li><li>  The <b>epoll</b> object is <b>destroyed.</b> </li></ol><br>  Example 3 repeats the functionality of Example 2 using asynchronous sockets.  The program is more complicated because one thread interacts with multiple clients in turn. <br><ul><li>  <b>Line 1:</b> The <b>select</b> module contains <b>epoll</b> functionality. </li><li>  <b>Line 13:</b> Default blocking sockets should be used in non-blocking (asynchronous) mode. </li><li>  <b>Line 15:</b> Create an <b>epoll</b> object. </li><li>  <b>Line 16:</b> Subscribe to read events on the server socket.  A read event occurs when the server socket accepts a connection. </li><li>  <b>Line 19:</b> The connection dictionary maps file descriptors (integers) to their corresponding network connection objects. </li><li>  <b>Line 21:</b> Query the <b>epoll</b> object to find out if any of the expected events have occurred.  The parameter ‚Äú1‚Äù indicates that we are ready to wait for events up to 1 second.  If any of the events of interest occur earlier, the request will immediately return a list of these events. </li><li>  <b>Line 22:</b> Events are returned in a sequence of tuples ( <b>fileno</b> , <b>event code</b> ).  fileno is a synonym for a file descriptor and is always an integer. </li><li>  <b>Line 23:</b> If a read event occurs on the server socket, then you can create a new client socket. </li><li>  <b>Line 25:</b> Set the new socket to non-blocking mode. </li><li>  <b>Line 26:</b> Subscribe to read events ( <b>EPOLLIN</b> ) on a new socket. </li><li>  <b>Line 31:</b> If a read event occurs on the client socket, then we read the new data that came from the client. </li><li>  <b>Line 33:</b> After receiving the request, we unsubscribe from reading events and subscribe to write events ( <b>EPOLLOUT</b> ).  These events occur when you can send response data to a client. </li><li>  <b>Line 34: We</b> print the request, indicating that despite the switch between clients, the data can be gathered together and processed as a single message. </li><li>  <b>Line 35:</b> If a write event has occurred on the client socket, then you can try to send new data to the client. </li><li>  <b>Lines 36-38:</b> Sending response data in chunks at a time until the entire response is transferred to the operating system for sending. </li><li>  <b>Line 39:</b> After the response has been completely sent, we unsubscribe from further read or write events. </li><li> <b>Line 40:</b> A <b>shutdown</b> call to the socket is not necessary for closing the connection explicitly.  This example uses it to force the client to terminate the connection first.  The <b>shutdown</b> call informs the client that it will no longer send or receive data and that it should close the socket for its part. </li><li>  <b>Line 41:</b> The <b>HUP</b> (hang-up, hang) event reports that the client socket has disconnected (was closed), that is, it should be closed.  No need to subscribe to <b>HUP</b> events.  They always occur on sockets that are signed in the <b>epoll</b> object. </li><li>  <b>Line 42:</b> Unsubscribe from events in this socket. </li><li>  <b>Line 43:</b> Close the socket. </li><li>  <b>Lines 18-45:</b> The <b>try-catch block is</b> used in this example because the program can be interrupted by the keyboard. </li><li>  <b>Lines 46-48:</b> Open sockets do not need to be closed, because Python closes them when the program ends.  However, explicit closure is a good practice. </li></ul><br>  Example 3 <br><blockquote>  <font color="black"><a href="http://s-c.me/22053/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22053/h">Copy HTML</a></font> <ol><li>  <font color="#0000ff">import</font> socket, select </li><li></li><li>  EOL1 = b <font color="#008000">'\ n \ n'</font> </li><li>  EOL2 = b <font color="#008000">'\ n \ r \ n'</font> </li><li>  response = b <font color="#008000">'HTTP / 1.0 200 OK \ r \ nDate: Mon, 1 Jan 1996 01:01:01 GMT \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Content-Type: text / plain \ r \ nContent-Length: 13 \ r \ n \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Hello, world!'</font> </li><li></li><li>  serversocket = <b>socket</b> .  <b>socket</b> ( <b>socket</b> .AF_INET, <b>socket</b> .SOCK_STREAM) </li><li>  serversocket.setsockopt ( <b>socket</b> .SOL_SOCKET, <b>socket</b> .SO_REUSEADDR, <font color="#008000">1</font> ) </li><li>  serversocket.bind (( <font color="#008000">'0.0.0.0'</font> , <font color="#008000">8080</font> )) </li><li>  serversocket.listen ( <font color="#008000">1</font> ) </li><li>  serversocket.setblocking ( <font color="#008000">0</font> ) </li><li></li><li>  epoll = <b>select</b> .epoll () </li><li>  epoll.register (serversocket.fileno (), <b>select</b> .EPOLLIN) </li><li></li><li>  <font color="#0000ff">try</font> : </li><li>  connections = {};  requests = {};  responses = {} </li><li>  <font color="#0000ff">while</font> true: </li><li>  events = epoll.poll ( <font color="#008000">1</font> ) </li><li>  <font color="#0000ff">for</font> fileno, event <font color="#0000ff">in</font> events: </li><li>  <font color="#0000ff">if</font> fileno == serversocket.fileno (): </li><li>  connection, address = serversocket.accept () </li><li>  connection.setblocking ( <font color="#008000">0</font> ) </li><li>  epoll.register (connection.fileno (), <b>select</b> .EPOLLIN) </li><li>  connections [connection.fileno ()] = connection </li><li>  requests [connection.fileno ()] = b <font color="#008000">''</font> </li><li>  responses [connection.fileno ()] = response </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLIN: </li><li>  requests [fileno] + = connections [fileno] .recv ( <font color="#008000">1024</font> ) </li><li>  <font color="#0000ff">if</font> EOL1 <font color="#0000ff">in</font> requests [fileno] <font color="#0000ff">or</font> EOL2 <font color="#0000ff">in</font> requests [fileno]: </li><li>  epoll.modify (fileno, <b>select</b> .EPOLLOUT) </li><li>  <font color="#0000ff">print</font> ( <font color="#008000">'-'</font> * <font color="#008000">40</font> + <font color="#008000">'\ n'</font> + requests [fileno] .decode () [: - <font color="#008000">2</font> ]) </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLOUT: </li><li>  byteswritten = connections [fileno] .send (responses [fileno]) </li><li>  responses [fileno] = responses [fileno] [byteswritten:] </li><li>  <font color="#0000ff">if</font> <b>len</b> (responses [fileno]) == <font color="#008000">0</font> : </li><li>  epoll.modify (fileno, <font color="#008000">0</font> ) </li><li>  connections [fileno] .shutdown ( <b>socket</b> .SHUT_RDWR) </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLHUP: </li><li>  epoll.unregister (fileno) </li><li>  connections [fileno] .close () </li><li>  <font color="#0000ff">del</font> connections [fileno] </li><li>  <font color="#0000ff">finally</font> : </li><li>  epoll.unregister (serversocket.fileno ()) </li><li>  epoll.close () </li><li>  serversocket.close () </li></ol></blockquote><br>  <b>epoll</b> has two modes of operation, called edge-triggered and level-triggered.  In the edge-triggered mode, a call to <b>epoll.poll</b> () will return an event only after a read or write event occurs on the socket.  The caller must process all the data associated with this event without having to call <b>epoll.poll</b> () <b>again</b> .  When data from a particular event is exhausted, additional attempts to work with the socket will lead to exceptions.  On the contrary, in the level-triggered mode, repeated calls to <b>epoll.poll</b> () will give repeated notifications about the events of interest until all the data associated with the events has been processed.  No exceptions occur during normal operation in the level-triggered mode. <br><br>  For example, suppose a server socket was signed in the <b>epoll</b> object for read events.  In the edge-triggered mode, the program should call <b>accept</b> () to accept new connections until a <b>socket.error</b> exception <b>occurs</b> .  In level-triggered mode, a single <b>accept</b> () call can be made, and then an epoll object can be requested again for the next event in the queue. <br><br>  Example 3 uses level-triggered mode, which is the default mode.  Example 4 demonstrates how to use edge-triggered mode.  In lines 25, 36 and 45, cycles are entered that I work until an exception occurs (or it becomes known that all data has been processed).  Lines 32, 38 and 48 catch exceptions.  Finally, lines 16, 28, 41, and 51 add an <b>EPOLLET</b> mask, which defines an edge-triggered mode. <br><br>  Example 4 <br><blockquote>  <font color="black"><a href="http://s-c.me/22054/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22054/h">Copy HTML</a></font> <ol><li>  <font color="#0000ff">import</font> socket, select </li><li></li><li>  EOL1 = b <font color="#008000">'\ n \ n'</font> </li><li>  EOL2 = b <font color="#008000">'\ n \ r \ n'</font> </li><li>  response = b <font color="#008000">'HTTP / 1.0 200 OK \ r \ nDate: Mon, 1 Jan 1996 01:01:01 GMT \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Content-Type: text / plain \ r \ nContent-Length: 13 \ r \ n \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Hello, world!'</font> </li><li></li><li>  serversocket = <b>socket</b> .  <b>socket</b> ( <b>socket</b> .AF_INET, <b>socket</b> .SOCK_STREAM) </li><li>  serversocket.setsockopt ( <b>socket</b> .SOL_SOCKET, <b>socket</b> .SO_REUSEADDR, <font color="#008000">1</font> ) </li><li>  serversocket.bind (( <font color="#008000">'0.0.0.0'</font> , <font color="#008000">8080</font> )) </li><li>  serversocket.listen ( <font color="#008000">1</font> ) </li><li>  serversocket.setblocking ( <font color="#008000">0</font> ) </li><li></li><li>  epoll = <b>select</b> .epoll () </li><li>  epoll.register (serversocket.fileno (), <b>select</b> .EPOLLIN | <b>select</b> .EPOLLET) </li><li></li><li>  <font color="#0000ff">try</font> : </li><li>  connections = {};  requests = {};  responses = {} </li><li>  <font color="#0000ff">while</font> true: </li><li>  events = epoll.poll ( <font color="#008000">1</font> ) </li><li>  <font color="#0000ff">for</font> fileno, event <font color="#0000ff">in</font> events: </li><li>  <font color="#0000ff">if</font> fileno == serversocket.fileno (): </li><li>  <font color="#0000ff">try</font> : </li><li>  <font color="#0000ff">while</font> true: </li><li>  connection, address = serversocket.accept () </li><li>  connection.setblocking ( <font color="#008000">0</font> ) </li><li>  epoll.register (connection.fileno (), <b>select</b> .EPOLLIN | <b>select</b> .EPOLLET) </li><li>  connections [connection.fileno ()] = connection </li><li>  requests [connection.fileno ()] = b <font color="#008000">''</font> </li><li>  responses [connection.fileno ()] = response </li><li>  <font color="#0000ff">except</font> <b>socket</b> .error: </li><li>  <font color="#0000ff">pass</font> </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLIN: </li><li>  <font color="#0000ff">try</font> : </li><li>  <font color="#0000ff">while</font> true: </li><li>  requests [fileno] + = connections [fileno] .recv ( <font color="#008000">1024</font> ) </li><li>  <font color="#0000ff">except</font> <b>socket</b> .error: </li><li>  <font color="#0000ff">pass</font> </li><li>  <font color="#0000ff">if</font> EOL1 <font color="#0000ff">in</font> requests [fileno] <font color="#0000ff">or</font> EOL2 <font color="#0000ff">in</font> requests [fileno]: </li><li>  epoll.modify (fileno, <b>select</b> .EPOLLOUT | <b>select</b> .EPOLLET) </li><li>  <font color="#0000ff">print</font> ( <font color="#008000">'-'</font> * <font color="#008000">40</font> + <font color="#008000">'\ n'</font> + requests [fileno] .decode () [: - <font color="#008000">2</font> ]) </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLOUT: </li><li>  <font color="#0000ff">try</font> : </li><li>  <font color="#0000ff">while</font> <b>len</b> (responses [fileno])&gt; <font color="#008000">0</font> : </li><li>  byteswritten = connections [fileno] .send (responses [fileno]) </li><li>  responses [fileno] = responses [fileno] [byteswritten:] </li><li>  <font color="#0000ff">except</font> <b>socket</b> .error: </li><li>  <font color="#0000ff">pass</font> </li><li>  <font color="#0000ff">if</font> <b>len</b> (responses [fileno]) == <font color="#008000">0</font> : </li><li>  epoll.modify (fileno, <b>select</b> .EPOLLET) </li><li>  connections [fileno] .shutdown ( <b>socket</b> .SHUT_RDWR) </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLHUP: </li><li>  epoll.unregister (fileno) </li><li>  connections [fileno] .close () </li><li>  <font color="#0000ff">del</font> connections [fileno] </li><li>  <font color="#0000ff">finally</font> : </li><li>  epoll.unregister (serversocket.fileno ()) </li><li>  epoll.close () </li><li>  serversocket.close () </li></ol></blockquote><br>  For all the similarities, the level-triggered mode is often used when porting applications using <b>select</b> or <b>poll</b> mechanisms, while the edge-triggered mode can be used by the programmer in the case when there is no need for such support for managing the state of events from the operating system. <br><br>  In addition to these two modes, sockets can also be signed in the <b>epoll</b> to an <b>EPOLLONESHOT</b> event.  When using this option, the event is correct only for a single call to <b>epoll.poll</b> (), after which it is automatically removed from the list of observed events. <br><br><h4>  Performance issues </h4><br><h5>  The length of the server connection queue </h5><br>  The 12th line of all examples shows the call to the <b>serversocket.listen</b> () method.  The parameter for this method is the length of the server connection queue (listen backlog).  It tells the operating system about the maximum accepted number of TCP / IP connections that can be placed in the system queue before the Python program accepts them.  Each time a Python program calls <b>accept</b> () on a server socket, one of the connections is removed from the queue and the space freed up can be used for another incoming connection.  When the queue is full, new incoming connections are silently ignored, resulting in unnecessary delays on the client side.  A busy server typically handles hundreds and thousands of simultaneous connections, so a value of 1 will be inadequate.  As an example, using ab for load testing the above examples with hundreds of simultaneous HTTP 1.0 clients, the queue length of less than 50 can sometimes lead to a dramatic drop in performance. <br><br><h5>  TCP settings </h5><br>  The <a href="http://www.baus.net/on-tcp_cork">TCP_CORK</a> option can block (bottle up) sending data until it is ready.  This option, illustrated in lines 34 and 40 of Example 5, can be useful for an HTTP server using the HTTP / 1.1 pipeline. <br><br>  Example 5 <br><blockquote>  <font color="black"><a href="http://s-c.me/22055/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22055/h">Copy HTML</a></font> <ol><li>  <font color="#0000ff">import</font> socket, select </li><li></li><li>  EOL1 = b <font color="#008000">'\ n \ n'</font> </li><li>  EOL2 = b <font color="#008000">'\ n \ r \ n'</font> </li><li>  response = b <font color="#008000">'HTTP / 1.0 200 OK \ r \ nDate: Mon, 1 Jan 1996 01:01:01 GMT \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Content-Type: text / plain \ r \ nContent-Length: 13 \ r \ n \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Hello, world!'</font> </li><li></li><li>  serversocket = <b>socket</b> .  <b>socket</b> ( <b>socket</b> .AF_INET, <b>socket</b> .SOCK_STREAM) </li><li>  serversocket.setsockopt ( <b>socket</b> .SOL_SOCKET, <b>socket</b> .SO_REUSEADDR, <font color="#008000">1</font> ) </li><li>  serversocket.bind (( <font color="#008000">'0.0.0.0'</font> , <font color="#008000">8080</font> )) </li><li>  serversocket.listen ( <font color="#008000">1</font> ) </li><li>  serversocket.setblocking ( <font color="#008000">0</font> ) </li><li></li><li>  epoll = <b>select</b> .epoll () </li><li>  epoll.register (serversocket.fileno (), <b>select</b> .EPOLLIN) </li><li></li><li>  <font color="#0000ff">try</font> : </li><li>  connections = {};  requests = {};  responses = {} </li><li>  <font color="#0000ff">while</font> true: </li><li>  events = epoll.poll ( <font color="#008000">1</font> ) </li><li>  <font color="#0000ff">for</font> fileno, event <font color="#0000ff">in</font> events: </li><li>  <font color="#0000ff">if</font> fileno == serversocket.fileno (): </li><li>  connection, address = serversocket.accept () </li><li>  connection.setblocking ( <font color="#008000">0</font> ) </li><li>  epoll.register (connection.fileno (), <b>select</b> .EPOLLIN) </li><li>  connections [connection.fileno ()] = connection </li><li>  requests [connection.fileno ()] = b <font color="#008000">''</font> </li><li>  responses [connection.fileno ()] = response </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLIN: </li><li>  requests [fileno] + = connections [fileno] .recv ( <font color="#008000">1024</font> ) </li><li>  <font color="#0000ff">if</font> EOL1 <font color="#0000ff">in</font> requests [fileno] <font color="#0000ff">or</font> EOL2 <font color="#0000ff">in</font> requests [fileno]: </li><li>  epoll.modify (fileno, <b>select</b> .EPOLLOUT) </li><li>  <u>connections [fileno] .setsockopt ( <b>socket</b> .IPPROTO_TCP, <b>socket</b> .TCP_CORK, <font color="#008000">1</font> )</u> </li><li>  <font color="#0000ff">print</font> ( <font color="#008000">'-'</font> * <font color="#008000">40</font> + <font color="#008000">'\ n'</font> + requests [fileno] .decode () [: - <font color="#008000">2</font> ]) </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLOUT: </li><li>  byteswritten = connections [fileno] .send (responses [fileno]) </li><li>  responses [fileno] = responses [fileno] [byteswritten:] </li><li>  <font color="#0000ff">if</font> <b>len</b> (responses [fileno]) == <font color="#008000">0</font> : </li><li>  <u>connections [fileno] .setsockopt ( <b>socket</b> .IPPROTO_TCP, <b>socket</b> .TCP_CORK, <font color="#008000">0</font> )</u> </li><li>  epoll.modify (fileno, <font color="#008000">0</font> ) </li><li>  connections [fileno] .shutdown ( <b>socket</b> .SHUT_RDWR) </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLHUP: </li><li>  epoll.unregister (fileno) </li><li>  connections [fileno] .close () </li><li>  <font color="#0000ff">del</font> connections [fileno] </li><li>  <font color="#0000ff">finally</font> : </li><li>  epoll.unregister (serversocket.fileno ()) </li><li>  epoll.close () </li><li>  serversocket.close () </li></ol></blockquote><br>  On the other hand, the <a href="http://articles.techrepublic.com.com/5100-10878_11-1050878.html">TCP_NODELAY</a> option tells the system that any data passed to <b>socket.send</b> () should immediately be sent to the client without buffering by the operating system.  This option, illustrated in line 14 of Example 6, can be useful for SSH clients and other real-time applications. <br><br>  Example 6 <br><blockquote>  <font color="black"><a href="http://s-c.me/22056/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22056/h">Copy HTML</a></font> <ol><li>  <font color="#0000ff">import</font> socket, select </li><li></li><li>  EOL1 = b <font color="#008000">'\ n \ n'</font> </li><li>  EOL2 = b <font color="#008000">'\ n \ r \ n'</font> </li><li>  response = b <font color="#008000">'HTTP / 1.0 200 OK \ r \ nDate: Mon, 1 Jan 1996 01:01:01 GMT \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Content-Type: text / plain \ r \ nContent-Length: 13 \ r \ n \ r \ n'</font> </li><li>  response + = b <font color="#008000">'Hello, world!'</font> </li><li></li><li>  serversocket = <b>socket</b> .  <b>socket</b> ( <b>socket</b> .AF_INET, <b>socket</b> .SOCK_STREAM) </li><li>  serversocket.setsockopt ( <b>socket</b> .SOL_SOCKET, <b>socket</b> .SO_REUSEADDR, <font color="#008000">1</font> ) </li><li>  serversocket.bind (( <font color="#008000">'0.0.0.0'</font> , <font color="#008000">8080</font> )) </li><li>  serversocket.listen ( <font color="#008000">1</font> ) </li><li>  serversocket.setblocking ( <font color="#008000">0</font> ) </li><li>  <u>serversocket.setsockopt ( <b>socket</b> .IPPROTO_TCP, <b>socket</b> .TCP_NODELAY, <font color="#008000">1</font> )</u> </li><li></li><li>  epoll = <b>select</b> .epoll () </li><li>  epoll.register (serversocket.fileno (), <b>select</b> .EPOLLIN) </li><li></li><li>  <font color="#0000ff">try</font> : </li><li>  connections = {};  requests = {};  responses = {} </li><li>  <font color="#0000ff">while</font> true: </li><li>  events = epoll.poll ( <font color="#008000">1</font> ) </li><li>  <font color="#0000ff">for</font> fileno, event <font color="#0000ff">in</font> events: </li><li>  <font color="#0000ff">if</font> fileno == serversocket.fileno (): </li><li>  connection, address = serversocket.accept () </li><li>  connection.setblocking ( <font color="#008000">0</font> ) </li><li>  epoll.register (connection.fileno (), <b>select</b> .EPOLLIN) </li><li>  connections [connection.fileno ()] = connection </li><li>  requests [connection.fileno ()] = b <font color="#008000">''</font> </li><li>  responses [connection.fileno ()] = response </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLIN: </li><li>  requests [fileno] + = connections [fileno] .recv ( <font color="#008000">1024</font> ) </li><li>  <font color="#0000ff">if</font> EOL1 <font color="#0000ff">in</font> requests [fileno] <font color="#0000ff">or</font> EOL2 <font color="#0000ff">in</font> requests [fileno]: </li><li>  epoll.modify (fileno, <b>select</b> .EPOLLOUT) </li><li>  <font color="#0000ff">print</font> ( <font color="#008000">'-'</font> * <font color="#008000">40</font> + <font color="#008000">'\ n'</font> + requests [fileno] .decode () [: - <font color="#008000">2</font> ]) </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLOUT: </li><li>  byteswritten = connections [fileno] .send (responses [fileno]) </li><li>  responses [fileno] = responses [fileno] [byteswritten:] </li><li>  <font color="#0000ff">if</font> <b>len</b> (responses [fileno]) == <font color="#008000">0</font> : </li><li>  epoll.modify (fileno, <font color="#008000">0</font> ) </li><li>  connections [fileno] .shutdown ( <b>socket</b> .SHUT_RDWR) </li><li>  <font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLHUP: </li><li>  epoll.unregister (fileno) </li><li>  connections [fileno] .close () </li><li>  <font color="#0000ff">del</font> connections [fileno] </li><li>  <font color="#0000ff">finally</font> : </li><li>  epoll.unregister (serversocket.fileno ()) </li><li>  epoll.close () </li><li>  serversocket.close () </li></ol></blockquote><br><h4>  Source </h4><br>  The examples on this page are publicly available and can be downloaded <a href="">here</a> . <br><br><h4>  From translator </h4><br>  When a remote client <b>closes a</b> socket, an <b>EPOLLIN</b> event <b>arrives</b> on the local socket, but nothing will be received when <b>recv is</b> read.  So moment <br><blockquote>  <font color="black"><a href="http://s-c.me/22059/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22059/h">Copy HTML</a></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLIN:</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">try</font> :</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">while</font> true:</font> <font color="black"><br></font>  <font color="black">requests [fileno] + = connections [fileno] .recv ( <font color="#008000">1024</font> )</font> <font color="black"><br></font> </blockquote><br>  You can write this: <br><blockquote>  <font color="black"><a href="http://s-c.me/22058/s">Copy Source</a> |</font>  <font color="black"><a href="http://s-c.me/22058/h">Copy HTML</a></font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">elif</font> event &amp; <b>select</b> .EPOLLIN:</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">try</font> :</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">while</font> true:</font> <font color="black"><br></font>  <font color="black">data = connections [fileno] .recv ( <font color="#008000">1024</font> )</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">if not</font> data:</font> <font color="black"><br></font>  <font color="black">epoll.modify (fileno, <b>select</b> .EPOLLET)</font> <font color="black"><br></font>  <font color="black">connections [fileno] .shutdown ( <b>socket</b> .SHUT_RDWR)</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">else</font> :</font> <font color="black"><br></font>  <font color="black">requests [fileno] + = data</font> <font color="black"><br></font> </blockquote><br>  In this case, there will be no looping when the connection is broken.  Encountered a code where the gap does not occur immediately, but after several consecutive such idle positives, in order to eliminate the possibility of erroneous determination. </div><p>Source: <a href="https://habr.com/ru/post/121103/">https://habr.com/ru/post/121103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121097/index.html">Google begins to take into account in issuing meta tags rel = "author" and rel = "me"</a></li>
<li><a href="../1211/index.html">Poll among linuksoidov.</a></li>
<li><a href="../12110/index.html">Love is the forerunner of technological success.</a></li>
<li><a href="../121100/index.html">kedDroid - S03E06. Video review software for Android</a></li>
<li><a href="../121101/index.html">Maybe not to extremes?</a></li>
<li><a href="../121104/index.html">What can Ctrl in Visual Studio</a></li>
<li><a href="../121106/index.html">Mayor Cupertino approved Apple spacecraft</a></li>
<li><a href="../121107/index.html">ICQ dropped</a></li>
<li><a href="../12111/index.html">Alternative replacement popup windows</a></li>
<li><a href="../121113/index.html">Quick build C ++ libraries for Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>