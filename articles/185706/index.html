<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Technique of writing await / async analogue from C # for C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Usually in such articles they make a heading like ‚Äúanalogue await / async for C ++‚Äù, and their content comes down to the description of another librar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Technique of writing await / async analogue from C # for C ++</h1><div class="post__text post__text-html js-mediator-article">  Usually in such articles they make a heading like ‚Äúanalogue await / async for C ++‚Äù, and their content comes down to the description of another library laid out somewhere on the Internet.  But in this case, we do not need anything like this and the title accurately reflects the essence of the article.  Why so see below. <a name="habracut"></a><br><br><h5>  Prehistory </h5><br>  All code samples from this article were invented by me for argumentation in one of the ‚Äúclassical‚Äù disputes of the form ‚ÄúC # vs.  C ++ in one forum.  The dispute ended, and the code remained, and I thought why not arrange it in the form of a normal article, which would serve as input on Habr√©.  Due to such historical reasons, there will be many comparisons of C # and C ++ approaches in the article. <br><br><h4>  Problem Statement - Asynchronous Programming </h4><br>  Very often in the work there is a task to perform some actions in a separate thread and then process the result in the original (usually UI) thread.  This is one of the varieties of the so-called asynchronous programming.  This task is well known and has many different solutions in most programming languages.  For example in C ++ it might look like this: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> r=async(launch::async, [&amp;]{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CalcSomething(params);}); DoAnother(); ProcessResult(r.get());<span class="hljs-comment"><span class="hljs-comment">//get - </span></span></code> </pre> <br>  for a caller blocking scheme.  Or so: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> r=async(launch::async, [&amp;]{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CalcSomething(params);}); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(r.wait_for(chrono::seconds(<span class="hljs-number"><span class="hljs-number">0</span></span>))!=future_status::ready) DoAnother(); ProcessResult(r.get());</code> </pre><br>  with a polling scheme.  Well, for UI threads in general, the easiest way is to use the already running cycle and make a notification scheme: <br><pre> <code class="cpp hljs">thread([=]{PostMessage(CalcSomething(params));}).detach(); ... OnDataMessage(Data d){ProcessResult(d.get&lt;type&gt;());}</code> </pre><br>  As you can see, there is nothing particularly difficult here.  This is C ++ code, but let's say in C # everything will be written in the same way, only instead of thread and the future there will be Thread and Task.  But the last option has one small minus: the computation code and the processing code are in different contexts (and can even be in different source files).  Sometimes it is even useful for more stringent architecture, but you always want less scribbling ... In recent versions of C #, a curious solution has appeared. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  C # implementation </h4><br>  In recent versions of C #, we can write simply: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Params prms</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; CalcSomething(prms)); ProcessResult(r); }</code> </pre><br>  For those who do not know, I will explain how the sequence of calls takes place here.  Suppose the Handler function is called from a UI stream.  The return from the Handler function occurs immediately after the launch of the asynchronous CalcSomething task.  Further, it runs in parallel with the UI thread, and after it is completed, and when the UI thread is freed from its current tasks, it will execute a ProcessResult with data obtained from the second thread. <br><br>  Is there some kind of magic?  In fact, of course, there are a couple of minuses (which, by the way, we will eliminate in our implementation), but in general it looks like exactly what we need for the convenience of writing asynchronous code.  How does this magic work?  In fact, it is very simple - the so-called coroutine co-procedures are used here. <br><br><h4>  Procedures </h4><br>  A simple procedure is a block of code with multiple entry points.  They are used most often for cases of a very large number of parallel tasks (for example, in a server implementation), where the presence of a similar number of threads is completely inefficient.  In this case, they allow you to create the appearance of threads (cooperative multitasking) and this greatly simplifies the code.  Also with the help of coprocedure, you can implement the so-called generators.  The implementation of co-procedures can be either built into the language, or as a library, and even provided by the OS (in Windows, co-procedures are called Fiber). <br><br>  In C #, co-procedures were used not for such classical purposes, but for the implementation of curious syntactic sugar.  The implementation here is built into the language, but far from the best.  This is the so-called stackless implementation, which essentially is a finite state machine that stores the necessary local variables and entry points.  It is from this that most of the drawbacks of the C # implementation result.  And the need to arrange "async" throughout the call stack and the extra overhead of the machine.  By the way, await is not the first appearance of coprocedures in C #.  yield is the same thing, only more limited. <br><br>  What about C ++?  There is no co-procedure in the language itself, but there are many different implementations in the form of libraries.  There is it in Boost as well, and there the most effective variant is implemented - stackfull.  It works through saving / restoring all the registers of the processor and the stack, respectively - in fact, like real threads, only this is all without accessing the OS, so it is almost instantaneous.  And like everything in Boost, it works fine on different operating systems, compilers, processors. <br><br>  Well, since in C ++ we have an even more powerful implementation of co-procedures than in C #, it‚Äôs just a sin not to write our own version of await / async syntactic sugar. <br><br><h4>  C ++ implementation </h4><br>  Let's see what the Boost.Coroutine library gives us.  First, we need to create an instance of the coroutine class, passing it our constructor (functor, lambda function) to the constructor, and this function should have one (maybe more, already for our purposes) parameter to which the special functor will be passed. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Coro=boost::coroutines::coroutine&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt;; <span class="hljs-function"><span class="hljs-function">Coro </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([](Coro::caller_type&amp; yield){ ... yield();</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//  ... yield();//  ... }); ... c();//      </span></span></span></span></span></span></code> </pre><br>  The execution of our function begins immediately in the constructor of the co-procedure, but it continues only until the first call to the yield functor.  Then immediately comes back from the constructor.  Further, we can call our co-procedure at any time (which is also a functor) and execution will continue inside our function in the same context as it terminated after the yield call.  Does this description not exactly correspond to the one required for the realization of the syntactic sugar we need? <br><br>  Now we have everything we need.  It remains to apply a bit of the magic of templates and macros (this is only to make it look quite like the C # option) and we get <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> __Coro=boost::coroutines::coroutine&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post2UI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* coro)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __await_async(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __Coro* coro, __Coro::caller_type&amp; yield, L lambda)-&gt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(lambda()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f=async(launch::async, [=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> r=lambda(); Post2UI(coro); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }); yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallFromUI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* c)</span></span></span><span class="hljs-function"> </span></span>{ __Coro* coro=<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;__Coro*&gt;(c); (*coro)(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*coro) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> coro; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> async_code(block) { __Coro* __coro=new __Coro; *__coro=__Coro([=](__Coro::caller_type&amp; __yield){block});} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> await_async(l) __await_async(__coro, __yield, l)</span></span></code> </pre><br>  All implementation occupies some miserable 20 lines of the elementary code!  Of course, you can put them in a separate hpp file and call them something like a library, but it will be ridiculous.  True, we need to define a couple more lines already dependent on the choice of our GUI framework (or native api in general).  Something like: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post2UI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* coro)</span></span></span><span class="hljs-function"> </span></span>{PostMessage(coro);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Event&amp; event)</span></span></span><span class="hljs-function"> </span></span>{CallFromUI(event.Get&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;());}</code> </pre><br>  But this is just a couple of lines, one for the whole application and the same for all applications on the same framework.  After that we can easily write such code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Params params)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_code</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r = await_async([&amp;]{</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CalcSomething(params);}); ProcessResult(r); )</span></span></span></span></code> </pre><br>  And the sequence of calculations will be exactly the same as in the C # variant.  And we did not have to change the function signature (add async throughout the call stack) as in C #.  Moreover, here we are not limited to running one asynchronous task for functions.  We can start several asynchronous blocks for parallel execution at once, or even go through a loop in general.  For example, this code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; urls)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> url: urls) async_code ( result+=await_async([&amp;]{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CheckServer(url);}); ) }</code> </pre><br>  runs a parallel CheckServer for each item in the list and collects all the results in the result variable.  And it is obvious that no synchronization, locks and other things are required, since  result + = ... code will be executed only in the UI stream.  In C #, this is naturally also recorded without problems, but you have to do a separate function, which you call in a loop. <br><br><h4>  Testing </h4><br>  Despite the size and simplicity of our implementation, we will still test it to make sure that it works correctly.  To do this, it is best to write on your favorite GUI framework the simplest test application from one input field (multi-line) and one button.  Then our test will be generalized (removed extra details) look like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWindow</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Window { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_code</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( output&lt;&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">L"    "</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;&lt;this_thread::get_id()&lt;&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\n'</span></span></span></span><span class="hljs-function"><span class="hljs-params">; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r=await_async([&amp;]{ this_thread::sleep_for(chrono::seconds(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)); wostringstream res; res&lt;&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">L"    "</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;&lt;this_thread::get_id()&lt;&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">L"   "</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;&lt;n; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res.str(); }); output&lt;&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">L"    "</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;&lt;this_thread::get_id()&lt;&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">L": "</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;&lt;r&lt;&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\n'</span></span></span></span><span class="hljs-function"><span class="hljs-params">; )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Event&amp;)</span></span></span><span class="hljs-function"> </span></span>{ TestAsync(<span class="hljs-number"><span class="hljs-number">12345</span></span>); TestAsync(<span class="hljs-number"><span class="hljs-number">67890</span></span>); output&lt;&lt;<span class="hljs-string"><span class="hljs-string">L" MessageBox   "</span></span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="hljs-string"><span class="hljs-string">'\n'</span></span>; MessageBox(<span class="hljs-string"><span class="hljs-string">L"!"</span></span>); output&lt;&lt;<span class="hljs-string"><span class="hljs-string">L"MessageBox    "</span></span>&lt;&lt;this_thread::get_id()&lt;&lt;<span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } Editbox output; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApp</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> App { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SetTopWindow(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyWindow); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Event&amp; event)</span></span></span><span class="hljs-function"> </span></span>{ CallFromUI(event.Get&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;()); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post2UI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* coro)</span></span></span><span class="hljs-function"> </span></span>{ GetApp().PostMessage(ID_ASYNC, coro); }</code> </pre><br>  MessageBox is worth checking for working with modal windows.  The result: <br><blockquote>  Run asynchronous from stream 1 <br>  Run asynchronous from stream 1 <br>  Showing MessageBox from Stream 1 <br>  Showing result in stream 1: Work in stream 2 completed on data 12345 <br>  Displaying result in stream 1: Work completed in stream 3 on data 67890 <br>  MessageBox is closed on stream 1 </blockquote><br><br><h4>  Results </h4><br>  I think that now it is not necessary to explain the remark at the beginning of the article about libraries.  With modern tools (C ++ 11, Boost), any C ++ programmer is able to write a full await / async implementation from C # in a few minutes and a dozen lines of code.  Moreover, this implementation will also be more flexible (several async blocks per function), more convenient (no need to multiply async by the call stack) and much more efficiently (in the sense of overhead). <br><br><h4>  Literature </h4><br>  1. <a href="http://en.cppreference.com/w/cpp/thread">en.cppreference.com/w/cpp/thread</a> - support for multithreading in the standard library. <br>  2. <a href="http://www.boost.org/doc/libs/1_54_0/libs/coroutine/doc/html/index.html">www.boost.org/doc/libs/1_54_0/libs/coroutine/doc/html/index.html</a> - implementation of <a href="http://www.boost.org/doc/libs/1_54_0/libs/coroutine/doc/html/index.html">co</a> -procedures in Boost. <br><br><h4>  Supplement 1 </h4><br>  The comments rightly noted that await / async from C # can work not only with different threads, but also within one.  Well, actually it is obviously the way it should be, because  this is just not the best implementation of coprocedural procedures, and they were originally created just for this kind of work.  And it‚Äôs natural that with the help of a co-procedure from Boost, this is implemented quite trivially.  I did not show such a code just because it was not part of my initial formulation of the problem (see the beginning of the article), and I don‚Äôt see much sense in this code at all.  But once in the comments they became interested in the community (to show that such a solution completely replaces await / async), I‚Äôll show you here. <br><br>  And so, we add to our implementation (which is of 20 lines) a few more: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __await(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __Coro* coro, __Coro::caller_type&amp; yield, L lambda)-&gt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(lambda()) { Post2UI(coro); yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda(); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> await(l) __await_async(__coro, __yield, l)</span></span></code> </pre><br>  And after that we will be able to write like this (the code is exactly the same as before, only replaced await_async with await): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Params params)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_code</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r = await([&amp;]{</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CalcSomething(params);}); ProcessResult(r); )</span></span></span></span></code> </pre><br>  Here again, there will be a return of control from Handler immediately after calling await, but the remaining code will be executed in the same UI thread as Handler was executed, only sometime later, when it is free.  No additional threads are naturally created here. </div><p>Source: <a href="https://habr.com/ru/post/185706/">https://habr.com/ru/post/185706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185694/index.html">Cyber ‚Äã‚ÄãSecurity. Weekly Review June 24 - June 30, 2013</a></li>
<li><a href="../185696/index.html">Networking in Android: traffic, security, and battery</a></li>
<li><a href="../185698/index.html">Take part in the international final of the Imagine Cup 2013! - Support ours and don‚Äôt miss the opportunity to meet with leading Microsoft experts</a></li>
<li><a href="../185700/index.html">Extending Git and Mercurial Repositories with Amazon S3</a></li>
<li><a href="../185704/index.html">UEFI BIOS File Device, Part One: UEFI Capsule and Intel Flash Image</a></li>
<li><a href="../185710/index.html">RMI for multiple network interfaces</a></li>
<li><a href="../185712/index.html">Happy Farm Demo Day: happy harvest!</a></li>
<li><a href="../185714/index.html">Maps traffic and Yandex Navigator become free for three months at MTS-Ukraine</a></li>
<li><a href="../185716/index.html">We will help lazy dogs or give an idea ...</a></li>
<li><a href="../185720/index.html">DIY oxy-acetylene welding</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>