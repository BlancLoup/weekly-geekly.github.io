<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Downloading large files or How to get around the limitations of cheap shared hosting</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once again, the problem arose of downloading relatively large files. Specifically, the client wanted to upload videos of 20-40 megabytes to the site t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Downloading large files or How to get around the limitations of cheap shared hosting</h1><div class="post__text post__text-html js-mediator-article">  Once again, the problem arose of downloading relatively large files.  Specifically, the client wanted to upload videos of 20-40 megabytes to the site through the admin panel.  It would seem that in our enlightened time, a similar size is such a trifle, and it is a shame to talk about it.  But suddenly it all came up against the settings of the virtual hosting.  We were horrified to find that the maximum size of the uploaded file is 2M, and there is no possibility to change this figure.  And it is impossible to change hosting for a number of reasons - at least not now. <br><br>  We face the challenge - to circumvent the limitations of a poor virtual hosting.  The very principle of such a workaround is obvious: the file must be cut into pieces, filled with parts, and on the server side assemble into a single whole.  But this should not be done manually - the user must select the file and click on the "Send" button.  How to do it? <br><br><a name="habracut"></a><br>  Our very first reaction is to see the possibilities of various flash-uploaders.  After all, it cannot be that world technical thought does not implement such a useful thing as downloading a file in parts.  We iterate through Uploadify, SWFUpload, FancyUpload, jqUploader, jquery-transmit.  But all in vain.  We do not see the desired feature.  It is likely that we need to dig further, but time is running out, and we have to do something already ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The above is sad.  However, the fact that this is an admin panel is playing into our hands.  Those.  we do not need to focus on cross-browser compatibility.  It is enough that this mechanism will work on the client's browser, which (lo and behold!) Is FF. <br><br>  We also recall that in the latest versions of FF, it is possible to get the contents of a file loaded in the file-upload field into a line.  And the desire to break this line into pieces and pump in parts using Ajax comes to mind. <br><br><h4>  Client part </h4><br>  First, draw the necessary in static HTML: <br><br><blockquote><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"myfile"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"big_file_upload($('#myfile'))"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></blockquote><br>  Those.  when you click on the link, the big_file_upload function should be called, into which the object is transferred, from which you need to take the contents of the file.  Note the $ ('# myfile') construct.  I think there is no need to dwell on the need to connect the jQuery library, which we will also use for ajax requests when transferring a file to the server. <br><br>  Now we need to write the same function big_file_upload: <br><br><blockquote><pre> var upload_chunk_size = 120000;
 // In this variable is the size of the pieces into which we will divide the file.
 
 function big_file_upload (file) {
   // .....
 }
</pre></blockquote><br><h5>  Retrieving file contents </h5><br>  To get the contents of the file we will use the following construction: <br><br><blockquote><pre>   var data = file.get (0) .files.item (0) .getAsDataURL ();
</pre></blockquote><br>  I explain its meaning: <br><ul><li>  <b>file.get (0)</b> - getting a DOM object from a jQuery object passed to a function </li><li>  <b>files.item (0)</b> - getting the first file from the list.  Here we have it only, however, let me remind you that there is already the possibility of multiple downloading files from one control. </li><li>  <b>getAsDataURL ()</b> - getting the contents of a file in the Data: URL format.  There are also methods getAsText and getAsBinary, however we need to transfer to the server using the POST method, therefore it is desirable to get the contents of the file encoded in Base64. </li></ul><br>  Similar construction get the file name: <br><br><blockquote><pre>   var filename = file.get (0) .files.item (0) .fileName;
</pre></blockquote><br>  Since the content is in the Data: URL format, it would be nice to cut off the header part, which contains information about the MIME type and the encoding method.  In a more general version of our function, this information should be used, but in this example, it will only get in our way when decoding.  Therefore, simply cut off all the first comma (inclusive), which is separated by the title: <br><br><blockquote><pre>   var comma = data.indexOf (',');
   if (comma&gt; 0) data = data.substring (comma + 1);
</pre></blockquote><br><h5>  Sending a file in chunks </h5><br>  Here everything is trite: <br><br><blockquote><pre>  var pos = 0;
 
  while (pos &lt;data.length) {
 
     $ .post ('/ upload.php', {
       filename:
       chunk: data.substring (pos, pos + upload_chunk_size)
     });
 
     pos + = upload_chunk_size;
   }
</pre></blockquote><br><h4>  Server part </h4><br>  Now we will do on the server the receiving PHP upload.php script.  As an example, it is also extremely simple: <br><br><blockquote><pre>   $ filename = $ _POST ['filename'];
   $ f = fopen ("/ dir / to / save / $ filename", "a");
   fputs ($ f, base64_decode ($ _ POST ['chunk']));
   fclose ($ f);
</pre></blockquote><br>  The file opens with the ‚Äúa‚Äù option, i.e.  it is suggested not to overwrite the existing file, but to supplement it.  In this way, we will assemble a whole file from the pieces. <br><br>  I think everyone understands that this script should lie in the closed admin part of the site so that different personalities do not have access to it.  In addition, the file name and the file itself should be checked for validity.  Otherwise, it‚Äôs not even a vulnerability, but ... I don‚Äôt know such words ... <br><br><h4>  We try to run </h4><br>  Have tried?  Happened?  I bet that it turned out not at all what was expected.  The file seems to be downloaded.  It seems to be even the correct length.  But the contents - some kind of porridge. <br><br>  Why did this happen?  The answer is simple: POST requests are sent in asynchronous mode in several pieces at a time, so no one guarantees that they will be sent to the server exactly in the sequence in which sending commands were sent.  Not only does no one guarantee, but I downright claim that they will never come in the right order.  There will always be porridge. <br><br>  Therefore, as it is sad, it is necessary to disconnect asynchrony.  Before sending the file, do the following: <br><br><blockquote><pre>  $ .ajaxSetup ({async: false});
</pre></blockquote><br>  Now everything is fine.  The file is assembled in the correct sequence, but at the time of downloading the execution of other scripts is suspended.  Therefore, in order not to irritate the user, it would be nice to show percentiles or a progress bar somewhere.  Thus, a workable script looks like this: <br><br><blockquote><pre> var upload_chunk_size = 120000;  // Size of the piece
 
 function big_file_upload (file) {
   var data = file.get (0) .files.item (0) .getAsDataURL ();  // Get the file contents
   var filename = file.get (0) .files.item (0) .fileName;  // Get the file name
 
   var comma = data.indexOf (','); 
   if (comma&gt; 0) data = data.substring (comma + 1);  // Cut off the header Data :: URL
 
   var pos = 0;
   $ .ajaxSetup ({async: false});  // Disable Asynchrony
 
   while (pos &lt;data.length) {
 
     $ .post ('/ upload.php', {// Send POST
       filename: // Filename
       chunk: data.substring (pos, pos + upload_chunk_size) // chunk file
     });
 
     pos + = upload_chunk_size;
 
     var p = Math.round (pos * 100 / data.length);  // Calculate the percentage sent
     $ ('# progress'). text (p + '%');  // Draw a number to keep the user calm
   }
 }
</pre></blockquote><br><h4>  disadvantages </h4><br>  As without them ... <br><br><ol><li>  In this example, it is assumed that the getAsDataURL method always returns base64 encoded data.  In fact, I would not bet that it will always be so.  In an amicable way, the title should not be thrown out, but transferred to the server part, which, in turn, should be taught to process data encoded in different ways. </li><li>  A file sent two times will be recorded on the server two times.  And complement himself.  To avoid this, apparently, you need to transfer in addition to the name also some kind of unique identifier of the download.  But this, generally speaking, is a matter of the method of generating and transmitting the file name.  There is no universal recipe, and there can not be. </li><li>  The client script runs for a long time (depending on the file size and the thickness of the channel), and FF may even ask if you are sure that you have to wait for the end, or kill it so that it does not suffer? </li><li>  Cross-browser compatibility.  Getting the contents of the file, alas, only works on FF.  Tested on 3.0, 3.5 and 3.6.  Earlier it was not checked for the lack of those at hand.  FF developers themselves recommend using FileAPI instead of this method, but it appeared only in 3.6. </li><li>  Really large files (hundreds of megabytes, gigabytes) download in this way will not work.  The limit depends on the amount of memory available to the browser. </li></ol><br><br><h4>  What to do? </h4><br>  Probably need to try all the same in asynchronous mode.  For each piece to transfer more and information about its location within the file.  In this case, the server part is seriously complicated. </div><p>Source: <a href="https://habr.com/ru/post/100189/">https://habr.com/ru/post/100189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../100174/index.html">Once again about invites and how to get them</a></li>
<li><a href="../100176/index.html">A serious vulnerability was discovered in the WPA2 data protection protocol.</a></li>
<li><a href="../100177/index.html">New version of the sniffer 0x4553-Intercepter 0.8 + 0x4553-NAT</a></li>
<li><a href="../100181/index.html">AB OVO: the original promo "FROM THE EGG"</a></li>
<li><a href="../100186/index.html">Windows - business, webOS - to the masses!</a></li>
<li><a href="../100191/index.html">HTC Will Release Versions of HTC Desire and Google Nexus One with Super LCD Displays</a></li>
<li><a href="../100192/index.html">Chronicle of a single query "plastic windows calculator"</a></li>
<li><a href="../100193/index.html">Opteron in the Cloud: New HP BL685c G7 / BL465c G7 Server Blades</a></li>
<li><a href="../100196/index.html">New Facebook games attract adult ladies</a></li>
<li><a href="../100199/index.html">MacPaint and QuickDraw sources sent to the museum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>