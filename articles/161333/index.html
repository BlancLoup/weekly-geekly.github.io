<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The road to victory at Russian AI Cup 2012</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habravchane! 
 I bring to your attention the history of your participation and victory in the final of the CodeTanks 2012 programming contest. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The road to victory at Russian AI Cup 2012</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habravchane! <br>  I bring to your attention the history of your participation and victory in the final of the CodeTanks 2012 programming contest. <br><br><img src="https://habrastorage.org/storage2/50b/937/68f/50b93768ff51d986490a38f330bfd44c.png"><br><br>  I found out about the competition on Habr√©, decided to find out more, went to the project site.  I was delighted to write in C ++ under Linux without dancing with a tambourine.  It was immediately thought that there would be a performance gain compared with participants writing in languages ‚Äã‚Äãlike Java / Python.  Well, I liked the format of the competition itself: two weeks before the first round, further down the week break between rounds.  You do not need to give birth to a properly working code in a creepy tseynote, but you can think over and program everything relatively calmly.  Further study of the rules and viewing of fights on the site only strengthened the decision to participate: it is much more interesting for me to program AI in a complex and poorly defined environment than in a fully formalized type of board games. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h2>  Brief description of the game world </h2><br>  6 rectangular tanks drive and shoot at a rectangular field.  First, every man for himself (round 1), then three teams of two (round 2) and two teams of three tanks (final).  The field is rather small, the shelter appeared only in fights three for three, so the fights turn into real meat.  To move, you need to independently control the right and left tracks, and the physics is quite complicated, something like Box2D (later reverse engineering showed that its Java analogue Phys2D is used).  Tanks are rather cumbersome, they can only go straight ahead anyway, they almost stop during a turn.  For firing, tanks have a turret with a cannon, and the turret rotational speed is much less than the rotation speed of the whole hull with the help of tracks.  The speed of the shells is also small and at long distances it is quite possible to dodge. <br><br>  Tanks have two types of life points: crew health and tank armor.  A tank is considered dead if either of these two values ‚Äã‚Äãreaches zero.  The damage inflicted by the projectile is determined by its type, speed, side of the tank, which was hit, and the angle at which it happened.  The projectile can penetrate or not penetrate the armor, in the second case the damage goes only on the armor, and in the first case it still goes to the crew.  The crew health is a very important characteristic: with low health, the engine power transmitted to the tracks and the speed of reloading the implement are twice as low.  You can restore health and armor by collecting bonuses that randomly appear on the map.  In addition to the bonuses for the restoration of points of life there is a third type: a box with three premium shells.  Such projectiles differ from the usual impossibility of rebounding, greater damage and lower speed. <br><br>  The game is played until only one player‚Äôs tanks remain on the field, or 5000 tick time is reached.  Moreover, the survivors are not guaranteed victory: points are being counted for inflicting damage on the enemy, for finishing tanks, for resurrecting their own (this is if you push the killed tank onto the recovery bonus), for killing all enemies, and the places are distributed according to the points collected. <br><br><h2>  Initial strategy </h2><br>  After analyzing the behavior of tanks, I decided to take as a model the movement along the broken line.  That is, the tank moves straight to the turning point, then makes a turn in place and continues to move straight along the next segment.  Accordingly, at each moment of time it is necessary to decide whether to continue moving further along a straight line or to begin a turn.  For this, I started an array of directions, where I kept the distance to the obstacle along this direction.  The zero direction in the array corresponded to the forward direction, the others were evenly distributed around the circumference.  Based on the distance to the obstacles, as well as the presence / absence of bonuses in this direction, I evaluated each direction and chose the best one (the forward direction received an additional bonus).  Further, based on the sector in which the best direction was located, I included one of several discrete gears on the tracks. <br><br>  Local tests immediately showed the inadequacy of the discrete dialing: if the tank first saw the bonus almost straight along the course, and having approached closer, had already seen it at an angle, it sharply slowed down and began to turn.  I rewrote the code so that in a small sector around the forward direction the power supply varied smoothly from ‚Äúfull forward‚Äù (1.0 1.0) to ‚Äúfastest turn‚Äù (1.0 -1.0).  The tank began to drive quite quickly and collect bonuses.  I also tried to implement the simplest system of evading the attack vectors of enemy tanks, but did not take off.  Having screwed the target selection system on the basis of the shortest time for aiming the gun, taking into account the body rotation and the simplest anticipation, I sent the first version of the strategy to the site. <br><br>  Real fights forced to add movement backwards along with moving forward and taking into account the distance to enemy tanks when choosing a target.  I also changed the code for calculating the lead time, adding the exact formula for the projectile flight time, but introduced a bug, which, as a result, completely zeroed the lead.  Nevertheless, with this strategy, I got to the 200th place in the rating, and proceeded to implement a more complex algorithm, which I conceived almost from the very beginning of the competition. <br><br><h2>  Danger field </h2><br>  The main idea of ‚Äã‚Äãthe new algorithm was to build a ‚Äúdanger field‚Äù and move along it in order to minimize this very ‚Äúdanger‚Äù.  The degree of danger was calculated on a regular grid with square cells (the size of the cells at different times varied from 10 to 16 units), taking into account the distance to enemy tanks, their visibility and the direction of the gun.  The danger of being on the path of a flying projectile also seriously added.  Specific formulas have changed many times, the coefficients were adjusted in them, so I will not give them here.  In order for the tank to go around obstacles, the value of the degree of danger inside solid objects was set to a sufficiently large number.  The resulting field was blurred by a circular filter with a radius of about 3.5 cells, which roughly corresponded to the size of my own tank. <br><br>  To implement this functionality, we had to seriously address the geometry.  Before that, I only had a vector class copied from another project and corrected.  Now I have implemented the class of an arbitrarily rotated rectangle and the function of determining the overlap of two such rectangles.  To check the visibility from a certain point of the enemy tank, I built a thin rectangle from this point to the location of the tank with a width of projectile diameter and checked its intersection with other objects. <br><br>  Unlike many other participants in the competition, I was too lazy to fasten the graphical interface to my debugging strategy, so I spent the evening learning the capabilities of the regular Linux terminal.  It found commands for specifying colors on a fixed 256-color palette (xterm-256color), in which there was a black and white gradient in 25 gradations.  As a result, the ability to display a picture with the values ‚Äã‚Äãof the hazard field in the terminal has become the chip of my strategy.  At first, two spaces with the corresponding background color value corresponded to one cell, then I replaced the spaces with the U + 2584 () symbol and doubled the resolution of the image. <br><br><h2>  Movement through the field of danger </h2><br>  The resulting hazard field was used to select the direction of motion.  The movement model remained the same - along the broken line, only the first segment was used to select the optimal direction.  That is, I believed that the tank first turns into a certain angle on the spot, goes straight ahead at a constant speed, and stops, having traveled a certain distance.  In the first versions of the algorithm, there was a separate branch in case the tank was already traveling fast, but it did not justify itself.  Using the chosen motion model, I carried out the integration of the hazard field with the weight linearly decreasing with time: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/807/2e3/46b/8072e346b4886c99f204ecf2fc63c30a.png"><br><br>  Where <img src="https://habrastorage.org/getpro/habr/post_images/982/3a7/ea3/9823a7ea35cf7b3f39df8e3d603b14cf.png">  - field of danger, and <img src="https://habrastorage.org/getpro/habr/post_images/1ef/514/93f/1ef51493f52cb71d1a5387336c1d38c7.png">  - position of the tank at the moment of time <i>t</i> , according to the movement model.  The integration was carried out numerically, the time step was chosen such that the corresponding space step was in the area of ‚Äã‚Äãthe hazard field grid step.  The value of the hazard field at arbitrary points was considered using bilinear filtering. <br><br>  In the program, I chose the direction of motion, calculated the time required for rotation (in the constant speed approximation) and wrote down the field value at the starting point multiplied by the coefficient corresponding to the rotation time to the current integral value.  Further, moving along the chosen direction, I updated the current value of the integral and considered the full integral for the case if we stopped at the last point considered.  If a bonus fell on the way, I took some value from the current value of the hazard integral.  Having found the optimal distance along one direction, I proceeded to the next.  Driving in the chosen direction was organized similarly to previous strategies. <br><br>  At first, I tried to realize the collection of bonuses by lowering the value of the hazard field in their position.  This led to the fact that the tank began to strive to spend as much time as possible near the bonuses instead of eating them quickly and continuing to move.  I had to organize bonuses in an array, sort by distance from the starting position of the tank and take into account the achievement of each bonus only once. <br><br>  Although the tank became much smarter, learned to hide behind obstacles, it did not greatly affect the rating of the strategy.  I made a slight decrease in danger in areas where at least one enemy is visible, so that my tank would not be ambushed at the end of the game.  The tops of that time carried him out almost immediately: he traveled to the center of the field and received several hits at once, respectively, tried to increase the danger value in the center.  Changed the weighting function when integrating danger: replaced the linear decay by the exponent.  I found a bug in calculating the time of flight of the projectile - I fixed the lead. <br><br>  The change of weight function to exponential was planned from the very beginning, but was postponed due to the complexity of implementation: there is no maximum time after which the weight is reset.  It was necessary to replace the cycle stopping condition with a comparison of the lower estimate of the hazard integral with its minimum value found by the current moment. <br><br><h2>  Physically accurate movement and avoidance </h2><br>  After all this, I paid attention to the problems with the movement: sometimes the tank missed the bonus and began to ride around it.  Since the calculation of the hazard integral was almost independent of the motion model, I decided to use a physicist close to reality.  After experimenting with the local-runner, I got all the necessary constants (knowledge of the design of physical engines and the ability to determine the exponent by eye on the schedule helped greatly).  Replaced a set of directions of motion to a set of pairs of power supplied to the tracks.  In the algorithm for calculating the integral of danger, he took the field value in the coordinates corresponding to the predicted position of the tank.  Although there was an instantaneous stop at the end point from previous versions, it did not affect the efficiency of the algorithm.  The new motion algorithm has become a real breakthrough.  I quickly moved to the 20-30th place in the ranking.  Even then, it became clear that the key to victory is the exact simulation of physics. <br><br>  Although the strategy has become much stronger, against the tops of this was not enough.  I tried to reduce the danger value in the corners, adjust various factors, removed the instantaneous stop in the calculation of the hazard integral, and tried to increase the recursion depth: simulate more than one pair of tracks per track, and first apply the first, and after a while - the second, but it was not enough CPU time. <br><br>  Then I decided to improve the dodging of shells.  Prior to this, the projectile trajectory made a great contribution to the danger field and the tank tried to drive away.  But the resolution of the field is quite low, and there is little time to dodge, because this method is ineffective.  But I already had exactly the predicted position of the tank at future points in time (as well as the function of determining the overlap of the rectangles), so I could know for sure if the projectile would fall into my tank and, if so, at what angle.  By adding the appropriate values ‚Äã‚Äãto the hazard integral for specific trajectories, I could choose one on which there would be a minimum number of hits and they were more likely to be rebounded.  This was the second breakthrough, again connected with exact physics.  With this strategy, I climbed up to 10-20th places in the sandbox and took 3rd place in the first round. <br><br>  And just to determine the hit / miss of the projectile in the tank was not enough.  Serious win gave account of the angle at which the shells hit.  Thanks to him, I began to reduce most of the hits at medium distances to ricochets.  At the same time, I tried to take into account collisions with the walls in order to improve the dodge from the projectiles while being near the field boundaries, but I got absurd from the physical point of view results for the impulse transmitted at impact and postponed the implementation of this improvement. <br><br><h2>  Selection of constants </h2><br>  A week before the second round, I spent on refactoring and code optimization, on experiments with coefficients and on a system for synchronizing the firing of several tanks.  The synchronization system did not justify itself, and therefore subsequently I gradually reduced the synchronicity coefficient until I turned it off completely.  Also made an account of the orientation of the enemy tank when choosing a target, which brought me to first place in the sandbox.  However, the second round showed that my strategy is relatively weak in a team battle. <br><br>  In order to improve the situation, I modified the field of danger so that the tanks tried to keep close to each other, but not very close, and also decided to seriously address the problem of choosing the optimal constants in the algorithms.  To do this, I implemented a system to automatically launch strategies with an arbitrary set of constants (thanks to <b>ud1</b> for local-runner and Run.class reverse engineering for running strategies in any combination) and organized a genetic algorithm: there is a pool of strategies with different constants, they play paired Each of the battles with each one and by the results is discarded the worst and is copied with the mutations the best.  It was based on the results of such optimization that my strategy began to aggressively attack the enemy.  Also, the collective mind dealt with the physics of hitting the walls: in the engine Phys2D there was an error and the absurd expression I received for the transmitted impulse actually corresponded to reality.  As a result, my tank became more intelligent to behave near the boundaries of the field. <br><br><h2>  Shooting with exact physics </h2><br>  But all this was not enough, but before the final there was less time left.  And I decided to drastically improve the shooting system: to take into account the exact physics of enemy tanks when choosing the direction to the target.  Since going through all the options is not enough resources, I decided to limit myself to cases when the tank delivers the same power to both tracks.  These cases include full forward and full back, defining the main range of possible positions of the tank in the future.  Since in these cases the angular momentum of the forces is absent, all the angular values ‚Äã‚Äãare common, and only the position and speed of the tank differ.  Moreover, the position can be set with two vectors, for example, the position for the ‚Äúfull forward‚Äù case and the ‚Äúfull back‚Äù position (I have a position at zero power on the tracks and a vector of the ‚Äúfull forward‚Äù position offset from zero).  All other positions can be obtained by linear interpolation. <br><br>  Knowing the range of possible positions of the tank at some point in time, as well as the position of the projectile at the same moment, I find the subrange in which the hit occurs, assign a certain amount of points to this subrange depending on the time and angle of hit, and proceed to the next point in time.  Integrating over the full range of possible positions, I find the total number of points corresponding to this projectile.  Looking through the possible directions of the shot and taking into account the time of the turn of the tower, I find the optimal and, if possible, shoot.  This was the third breakthrough, again connected with exact physics.  The updated strategy won the first place in the first part of the final, and during the break I improved it by correcting the intersection bug, taking into account points from projectiles already flying in order to block the widest possible range of positions, as well as dropping those positions in which the enemy tank turns out to be inside the obstacles. <br><br>  To implement all of my plans, I again had to go into geometry, the previously written intersection of the rectangles was not enough.  Now I found a range of positions when moving an arbitrarily oriented rectangle along a straight line at which this rectangle overlaps another stationary rectangle.  Also separately implemented a special case when a moving rectangle has zero dimensions, that is, is a point. <br><br>  Integrating across a range of possible positions was not exactly trivial.  So that the tank would prefer to overlap the unclosed sectors, rather than adding the density of fire to where there is already an impact, I increased the effect on the integral of low points and weakened the influence of large with a power conversion: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/769/a95/1c7/769a951c75735d984a290c10a921a093.png"><br><br>  I made the search for the best direction of the shot not by a simple search, but by an algorithm similar to the method of dividing in half.  Having checked several equally spaced directions around the beam to an enemy tank, I chose the best one, reduced the angular pitch twice, and checked the directions around the one found.  Repeating this procedure recursively several times and additionally checking the current direction of the gun, I switched to another enemy tank. <br><br><h2>  Unrealized ideas </h2><br>  Perhaps the most important improvement I missed is the automatic orientation of the tank sideways to the enemies.  Due to the lack of this system, my tanks were relatively weak in long-range combat and I had to arrange a rush in which the risks were much greater.  My physical education prompted me to replace the scalar hazard field with a quadrupole one, that is, to store five circular harmonics at each point.  But this would slow down more than five times the sampling functions of the hazard field, and my strategies were already executed at the limit of the available processor time. <br><br>  Another unrealized opportunity is to account for the collision of shells in the air.  I was stopped here by the impossibility of confining myself to simply avoiding other projectiles when firing.  A sufficiently large percentage of enemy shells get off their own, and if you add avoidance, you will have to write code to fire at dangerous enemy shells. <br><br>  Watch records of fights in my <a href="http://russianaicup.ru/profile/Mr.Smile">profile</a> on the competition website. <br>  The source code of the final version of the strategy can be found <a href="http://pastebin.com/HA4vnAnL">here</a> . <br>  Constant optimizer code is <a href="http://pastebin.com/ismLE6Wa">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/161333/">https://habr.com/ru/post/161333/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161321/index.html">Rockchip RK3066 compatible version of Ubuntu appeared</a></li>
<li><a href="../161323/index.html">What do you think of Windows 8?</a></li>
<li><a href="../161325/index.html">We continue acquaintance with Technopark Skolkovo</a></li>
<li><a href="../161327/index.html">Kotlin M4 released</a></li>
<li><a href="../161329/index.html">Playing Portal on TI-83 and TI-84 Calculators</a></li>
<li><a href="../161335/index.html">JAVA library padeg - New Year's gift habr</a></li>
<li><a href="../161337/index.html">How to blow fire from water</a></li>
<li><a href="../161341/index.html">Flowmaster: Notsen Wireless HDMI</a></li>
<li><a href="../161345/index.html">We remind users to change their password in Windows 7 / Windows 8: NetWrix Password Expiration Notifier</a></li>
<li><a href="../161351/index.html">Why the motorcycle could not replace the tank, or the translation of the REG.RU website from the Template :: Toolkit to Text :: Xslate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>