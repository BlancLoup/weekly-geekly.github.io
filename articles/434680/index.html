<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The evolution of task planners</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The iFunny application we are working on has been available in more than five years. During this time, the mobile team had to go through a lot of diff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The evolution of task planners</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/bv/mr/ps/bvmrpspwu-kyhojb5tiu4lqbdi8.jpeg"><br><br>  The iFunny application we are working on has been available in more than five years.  During this time, the mobile team had to go through a lot of different approaches and migrations between the tools, and a year ago it was time to switch from a samopisny decision and look in the direction of something more ‚Äúfashionable‚Äù and common.  This article is a small squeeze of what has been learned, what solutions they looked at and what they came to. <a name="habracut"></a><br><br>  <b>Why do we need all this?</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's immediately determine what this article is for and why this topic turned out to be important for the Android development team: <br><br><ol><li>  There are many scenarios when it is necessary to run tasks outside the active user interface; </li><li>  the system imposes a large number of restrictions on the launch of such tasks; </li><li>  It was rather difficult to choose between existing solutions, since each tool has its own pros and cons. </li></ol><br><h3>  <b>Chronology of events</b> </h3><br>  <b>Android 0</b> <b><br></b> <h3>  AlarmManager, Handler, Service </h3><br>  Initially, their solutions for running background-based tasks on services were implemented.  There was also a mechanism that tied tasks to the life cycle and knew how to cancel and restore them.  It suited the team for a long time, as the platform did not impose any restrictions on such tasks. <br>  Google advised to do this based on the following diagram: <br><br><img src="https://habrastorage.org/webt/e-/46/zn/e-46znleyxvynpm35pbebgrkdhk.png"><br><br>  At the end of 2018 it makes no sense to understand this, it is enough to estimate the scale of the disaster. <br>  In fact, nobody cared how much work was going on in the background.  Applications did what they wanted and when they wanted. <br><br>  <i><b>Pros</b> :</i> <i><br></i>  <i>available everywhere;</i> <i><br></i>  <i>available to all.</i> <i><br><br></i>  <i><b>Cons</b> :</i> <i><br></i>  <i>the system strongly limits the work;</i> <i><br></i>  <i>no launches by condition;</i> <i><br></i>  <i>The API is minimal and you need to write a lot of code.</i> <i><br></i> <br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  JobScheduler </h3><br>  After 5 (!) Years, closer to 2015, Google noticed that tasks are launched ineffectively.  Users began to regularly complain that their phones are discharged simply by lying on a table or in a pocket. <br><br>  With the release of Android 5, a tool such as JobScheduler appeared.  This is a mechanism with whose help it is possible to perform various tasks in the background, the start of which has been optimized and simplified due to the centralized launch system for these tasks and the ability to set conditions for this launch itself. <br><br>  In the code, it all looks quite simple: a service is announced, to which start and end events occur. <br>  From the nuances: if you want to do the work asynchronously, then from onStartJob you need to start the stream;  the main thing is not to forget to call the jobFinished method at the end of the work, otherwise the system will not let go of WakeLock, your task will not be considered completed and will be lost. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  From anywhere in the application you can initiate the execution of this work.  Tasks are performed in our process, but are initiated at the IPC level.  There is a centralized mechanism that controls their execution and wakes up the application only at the necessary points.  You can also set different trigger conditions and transfer data through the Bundle. <br><br><pre> <code class="java hljs">JobInfo task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobInfo.Builder(JOB_ID, serviceName) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); JobScheduler scheduler = (JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE); scheduler.schedule(task);</code> </pre> <br>  In general, compared to nothing, it was already something.  But this mechanism is only available with API 21, and at the time of release of Android 5.0, it would be strange to stop supporting all old devices (3 years have passed, and we still support fours). <br><br>  <i><b>Pros</b> :</i> <i><br></i>  <i>API is simple;</i> <i><br></i>  <i>conditions to run.</i> <i><br></i> <br>  <b><i>Cons</i></b> : <br>  <s>available starting at API 21;</s> <br>  in fact, only with API 23; <br>  easy to make a mistake. <br><br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  <b>GCM Network Manager</b> </h3><br>  Also was presented an analogue of JobScheduler - GCM Network Manager.  This is a library that provided similar functionality, but it already worked with API 9. However, it demanded that Google Play Services be available instead.  Apparently, the functionality necessary for JobScheduler‚Äôs work began to be delivered not only through the Android version, but also at the GPS level.  It should be noted that the framework developers quickly thought better of it and decided not to link their future with GPS.  Thank them for that. <br><br>  Everything looks absolutely identical.  Same service: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmNetworkManagerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GcmTaskService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TaskParams taskParams)</span></span></span><span class="hljs-function"> </span></span>{ doWork(taskParams); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  The same task launch: <br><br><pre> <code class="java hljs">OneoffTask task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OneoffTask.Builder() .setService(GcmNetworkManagerService.class) .setTag(TAG) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); GcmNetworkManager mGcmNetworkManager = GcmNetworkManager.getInstance(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); mGcmNetworkManager.schedule(task);</code> </pre> <br>  Such similarity of architecture was dictated by the inherited functionality and the desire to get a simple migration between tools. <br><br>  <i><b>Pros</b> :</i> <i><br></i>  <i>API similar to JobScheduler;</i> <i><br></i>  <i>available starting at API 9.</i> <i><br><br></i>  <i><b>Cons</b> :</i> <i><br></i>  <i>You must have Google Play Services;</i> <i><br></i>  <i>easy to make a mistake.</i> <br><br>  <b>Android 5. Lollipop</b> <b><br></b> <h3>  <b>WakefulBroadcastReceiver</b> </h3><br>  Next, I will write a few words about one of the basic mechanisms that is used in JobScheduler and is available to developers directly.  This is WakeLock and WakefulBroadcastReceiver based on it. <br><br>  With the help of WakeLock, you can prevent the system from going to suspend, that is, keep the device active.  This is necessary if we want to do some important work. <br>  When creating a WakeLock, you can specify its settings: keep the CPU, screen or keyboard. <br><br><pre> <code class="java hljs">PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE) PowerManager.WakeLock wl = pm.newWakeLock(PARTIAL_WAKE_LOCK, <span class="hljs-string"><span class="hljs-string">"name"</span></span>) wl.acquire(timeout);</code> </pre> <br>  Based on this mechanism, WakefulBroadcastReceiver works.  We start the service and hold WakeLock. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleWakefulReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WakefulBroadcastReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ Intent service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, SimpleWakefulService.class); startWakefulService(context, service); } }</code> </pre> <br>  After the service has completed the necessary work, we release it through similar methods. <br><br>  After 4 versions, this BroadcastReceiver will become deprecated, and the following alternatives will be described on developer.android.com: <br><br><ul><li>  JobScheduler; </li><li>  SyncAdapter; </li><li>  DownloadManager; </li><li>  FLAG_KEEP_SCREEN_ON for Window. </li></ul><br>  <b>Android 6. Marshmallow</b> <b><br></b> <h3>  <b>DozeMode: sleep on the go</b> </h3><br>  Next, Google began to apply various optimizations for applications running on the device.  But what is optimization for the user is a restriction for the developer. <br><br>  First of all, DozeMode appeared, which puts the device into sleep mode if it lay without action for a certain time.  In the first versions, this lasted an hour, in subsequent periods, the duration of sleep was reduced to 30 minutes.  Periodically, the phone wakes up, performs all pending tasks and falls asleep again.  The DozeMode window grows exponentially.  All transitions between modes can be tracked via adb. <br><br>  When DozeMode occurs, the following restrictions apply to the application: <br><br><ul><li>  the system ignores all WakeLock; </li><li>  AlarmManager is delayed; </li><li>  JobScheduler does not work; </li><li>  SyncAdapter is not working; </li><li>  access to the network is limited. </li></ul><br>  You can also add your application to whitelist so that it does not fall under DozeMode restrictions, but at least Samsung completely ignored this list. <br><br>  <b>Android 6. Marshmallow</b> <b><br></b> <h3>  <b>AppStandby: inactive applications</b> </h3><br>  The system identifies applications that are inactive, and imposes all the same restrictions on them as in DozeMode. <br>  An application is sent to isolation if: <br><br><ul><li>  does not have a process in the foreground; </li><li>  does not have active notification; </li><li>  not added to the list of exceptions. </li></ul><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>Background Optimizations.</b>  <b>Svelte</b> </h3><br>  Svelte is a project in which Google is trying to optimize the consumption of RAM by applications and the system itself. <br>  In Android 7, within the framework of this project, it was decided that implicit broadcasts are not very effective, since a huge number of applications listen to them and the system spends a large amount of resources when these events occur.  Therefore, the following event types were prohibited from being declared in the manifest: <br><br><ul><li>  CONNECTIVITY_ACTION; </li><li>  ACTION_NEW_PICTURE; </li><li>  ACTION_NEW_VIDEO. </li></ul><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>FirebaseJobDispatcher</b> </h3><br>  At the same time, a new version of the task launching framework, FirebaseJobDispatcher, was published.  In fact, it was added by GCM NetworkManager, which was put in order a bit and made a bit more flexible. <br><br>  Visually, everything looked exactly the same.  Same service: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobSchedulerService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ doWork(params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStopJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobParameters params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  The only thing that distinguished him was the possibility of installing his driver.  A driver is a class that is responsible for the task launch strategy. <br><br>  The very start of tasks over time has not changed. <br><br><pre> <code class="java hljs">FirebaseJobDispatcher dispatcher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirebaseJobDispatcher(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GooglePlayDriver(context)); Job task = dispatcher.newJobBuilder() .setService(FirebaseJobDispatcherService.class) .setTag(TAG) .setConstraints(Constraint.ON_UNMETERED_NETWORK, Constraint.DEVICE_IDLE) .build(); dispatcher.mustSchedule(task);</code> </pre><br>  <i><b>Pros</b> :</i> <i><br></i>  <i>API similar to JobScheduler;</i> <i><br></i>  <i>available starting at API 9.</i> <i><br><br></i>  <i><b>Cons</b> :</i> <i><br></i>  <i>You must have Google Play Services;</i> <i><br></i>  <i>easy to make a mistake.</i> <i><br></i> <br>  I was hoping to be able to install my driver in order to get rid of GPS.  We even searched, but eventually found the following: <br><br><img src="https://habrastorage.org/webt/3n/39/ua/3n39uanajermu--vb5qrzgfl8jq.png"><br><br><img src="https://habrastorage.org/webt/zm/rq/i3/zmrqi3pnt_0hx8lcspdy8k6xio8.png"><br><br>  Google has been aware of this, but these tasks have remained open for several years. <br><br>  <b>Android 7. Nougat</b> <b><br></b> <h3>  <b>Android Job by Evernote</b> </h3><br>  As a result, the community could not stand it, and a self-written solution appeared in the form of a library from Evernote.  It was not the only one, but it was the solution from Evernote that was able to prove itself and ‚Äúbroke into people‚Äù. <br><br>  Architecturally, this library was more convenient than its predecessors. <br>  There was an entity responsible for creating tasks.  In the case of JobScheduler, they were created through reflection. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJobCreator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobCreator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: String)</span></span></span><span class="hljs-function">: Job? </span></span>{ when (tag) { SendLogsJob.TAG -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SendLogsJob() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br>  There is a separate class, which is the task itself.  In JobScheduler, this was all dumped into a switch inside onStartJob. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendLogsJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRunJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Params)</span></span></span><span class="hljs-function">: Result </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doWork(params) } }</code> </pre> <br>  Running tasks is identical, but besides the inherited events, Evernote has also added its own ones, such as starting daily tasks, unique tasks, running within a window. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JobRequest.Builder(JOB_ID) .setRequiresDeviceIdle(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiresCharging(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .setRequiredNetworkType(JobRequest.NetworkType.UNMETERED) .build() .scheduleAsync();</code> </pre> <br>  <i><b>Pros</b> :</i> <i><br></i>  <i>convenient API;</i> <i><br></i>  <i>supported on all versions;</i> <i><br></i>  <i>no need google play services.</i> <i><br><br></i>  <i><b>Cons</b> :</i> <i><br></i>  <i>third-party solution.</i> <i><br></i> <br>  The guys actively supported their library.  Although there were quite a few critical issues, she worked on all versions and on all devices.  As a result, last year, our Android team chose a solution from Evernote, since the libraries from Google cut off a large layer of devices that they cannot support. <br>  Inside she worked on solutions from Google, in extreme cases with the AlarmManager. <br><br>  <b>Android 8. Oreo</b> <b><br></b> <h3>  <b>Background Execution Limits</b> </h3><br>  Let's return to our limitations.  With the advent of the new Android came new optimizations.  The guys from Google found another problem.  This time the whole thing turned out to be in services and broadcasts (yes, nothing new). <br><br><ul><li>  <s>startService if applications in background</s> </li><li>  <s>implicit broadcast in manifest</s> </li></ul><br>  Firstly, it was forbidden to start services from the background.  In the "framework of the law" there were only foreground services.  Services can now be said deprecated. <br>  The second limitation is the same broadcasts.  This time, the registration of ALL implicit broadcasts in the manifest has become banned.  Implicit Broadcast is a Broadcast that is not just for our application.  For example, there is Action ACTION_PACKAGE_REPLACED, and there is ACTION_MY_PACKAGE_REPLACED.  So, the first is implicit. <br><br>  But any broadcast can still be registered through Context.registerBroadcast. <br><br>  <b>Android 9. Pie</b> <b><br></b> <h3>  <b>Workmanager</b> </h3><br>  This optimization has stopped for now.  Perhaps the devices began to work quickly and carefully in terms of energy consumption;  users may have complained less about it. <br>  In Android 9, the developers of the framework thoroughly approached the tool for running tasks.  In an attempt to solve all the pressing problems, a library was introduced to Google I / O for running the Background task of the WorkManager. <br><br>  Google has recently been trying to form its own vision of the architecture of an Android application and gives developers the tools they need to do this.  This is how architectural components with LiveData, ViewModel and Room appeared.  WorkManager looks like a reasonable addition to their approach and paradigm. <br><br>  If we talk about how the WorkManager is arranged inside, then there is no technological breakthrough in it.  In fact, it is a wrapper of existing solutions: JobScheduler, FirebaseJobDispatcher and AlarmManager. <br><br><div class="spoiler">  <b class="spoiler_title">createBestAvailableBackgroundScheduler</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Scheduler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBestAvailableBackgroundScheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context, WorkManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= MIN_JOB_SCHEDULER_API_LEVEL) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemJobScheduler(context, workManager); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tryCreateFirebaseJobScheduler(context); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemAlarmScheduler(context); } }</code> </pre> <br></div></div><br>  The selection code is pretty simple.  But it should be noted that JobScheduler is available starting from API 21, but using it only with API 23, since the first versions were rather unstable. <br><br>  If the version is lower than 23, then through reflection we try to find FirebaseJobDispatcher, otherwise we use AlarmManager. <br><br>  It is worth noting, the wrapper came out quite flexible.  This time, the developers broke everything into separate entities, and architecturally it looks comfortable: <br><br><ul><li>  Worker - work logic; </li><li>  WorkRequest - task launch logic; </li><li>  WorkRequest.Builder - parameters; </li><li>  Constrains - conditions; </li><li>  WorkManager - a manager who manages tasks; </li><li>  WorkStatus - task status. </li></ul><br><br><img src="https://habrastorage.org/webt/n_/ts/xi/n_tsxiw0wsxv6a5abotzdzokcba.png"><br><br>  Startup conditions inherited from JobScheduler. <br>  It can be noted that the trigger for changing the URI appeared only with API 23. In addition, you can subscribe to change not only a specific URI, but all nested in it using the flag in the method. <br><br>  If we talk about us, then at the alpha stage it was decided to switch to the WorkManager. <br>  There are several reasons for this.  In Evernote, there are a couple of critical bugs that library developers promise to fix with the transition to the version with the integrated WorkManager.  Yes, and they agree that the decision from Google negates the advantages of Evernote.  In addition, this solution fits well with our architecture, since we use Architecture Components. <br><br>  Further I would like to show, in a simple example, in what form we try to use this approach.  It is not very critical, you WorkManager or JobScheduler. <br><br><img src="https://habrastorage.org/webt/ox/yd/0p/oxyd0pizr6h8tx4egaz_kub5wqy.png" width="300" height="430"><img src="https://habrastorage.org/webt/6m/ec/hd/6mechdqawzamahgaij7df-isocg.png" width="300" height="430"><br><br>  Let's look at an example with a very simple case: click on republish or like. <br><br>  Now all applications are trying to get away from blocking requests to the network, as this unnerves the user and makes him wait, although at this time he can make purchases inside the application or watch ads. <br><br>  In such cases, local data is first changed - the user immediately sees the result of his action.  Then in the background there is a request to the server, if it fails, the data is reset to the initial state. <br><br>  Next, I will show an example of how it looks like with us. <br><br>  JobRunner contains logic for running tasks.  Its methods describe the configuration of tasks and pass parameters. <br><br><div class="spoiler">  <b class="spoiler_title">JobRunner.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">likePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(content: IFunnyContent)</span></span></span><span class="hljs-function"> </span></span>{ val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() val input = Data.Builder() .putString(LikeContentJob.ID, content.id) .build() val request = OneTimeWorkRequest.Builder(LikeContentJob::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setInputData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setConstraints</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constraints</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getInstance</span></span></span><span class="hljs-class">().</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enqueue</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br></div></div><br>  The task itself within the WorkManager is as follows: we take the id from the parameters and call the method on the server to like this content. <br><br>  We have a base class that contains the following logic: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">() </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>{ val workerInjector = WorkerInjectorProvider.injector() workerInjector.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> performJob(inputData) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: Data)</span></span></span><span class="hljs-function">: Result }</span></span></code> </pre><br>  First, it allows you to get away a little from the explicit knowledge of the Worker.  It also contains the logic of dependency injection through WorkerInjector. <br><br><div class="spoiler">  <b class="spoiler_title">WorkerInjectorImpl.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkerInjectorImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Ovierride</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Worker job)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AppCrashedEventSendJob) { Injector.getAppComponent().inject((AppCrashedEventSendJob) job); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worker <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> CheckNativeCrashesJob) { Injector.getAppComponent().inject((CheckNativeCrashesJob) job); } } }</code> </pre><br></div></div><br>  He simply proxies calls to Dagger, but it helps us in testing: we replace the injector implementations and inject the necessary environment into the tasks. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testRegisterPushProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WorkManagerTestInitHelper.initializeTestWorkManager(context) val testDriver = WorkManagerTestInitHelper.getTestDriver() WorkerInjectorProvider.setInjector(TestInjector()) <span class="hljs-comment"><span class="hljs-comment">// mock dependencies val id = jobRunner.runPushRegisterJob() testDriver.setAllConstraintsMet(id) Assert.assertTrue(‚Ä¶) }</span></span></code> </pre><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jobRunner</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JobRunner</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interactor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ iFunnyContentDao.like(getContent().id) jobRunner.likePost(getContent()) } }</code> </pre> <br>  Interactor is an entity that ViewController pulls to initiate the passage of a script (in this case ‚Äî like).  We mark the content locally as ‚Äúzaikanny‚Äù and send the task for execution.  If the task fails, the like is removed. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iFunnyContentDao</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentDao</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class">() </span></span>{ val likeState = MediatorLiveData&lt;Boolean&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentId = MutableLiveData&lt;String&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iFunnyContentState: LiveData&lt;IFunnyContent&gt; = attachLiveDataToContentId(); init { likeState.addSource(iFunnyContentState) { likeState.postValue(it!!.hasLike) } } }</code> </pre> <br>  We use Google‚Äôs Architecture Components: ViewModel and LiveData.  This is our ViewModel.  Here we associate the update of the object in the DAO with the status of the like. <br><br><div class="spoiler">  <b class="spoiler_title">IFunnyContentViewController.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewController</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">likePostInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikePostInteractor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFunnyContentViewModel</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: View)</span></span></span><span class="hljs-function"> </span></span>{ viewModel.likeState.observe(lifecycleOwner, { updateLikeView(it!!) }) } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLikePost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ likePostInteractor.setContent(getContent()) likePostInteractor.execute() } }</code> </pre> <br></div></div><br>  ViewController, on the one hand, subscribes to the change of the likes status, on the other hand, it initiates the passage of the script we need. <br><br>  And this is almost all the code we need.  It remains to add the behavior of the View itself with a like and implementation of your DAO;  if you use Room, then simply register the fields in the object.  It looks quite simple and effective. <br><br><h3>  <b>If to sum up</b> </h3><br>  <b>JobScheduler, GCM Network Manager, FirebaseJobDispatcher:</b> <br><br><ul><li>  don't use them </li><li>  don't read any more articles about them </li><li>  do not watch reports </li><li>  don't think which one to choose. </li></ul><br>  <b>Android Job by Evernote:</b> <br><br><ul><li>  inside will use WorkManager; </li><li>  critical bugs are blurred between solutions. </li></ul><br>  <b>WorkManager:</b> <br><br><ul><li>  API LEVEL 9+; </li><li>  does not depend on Google Play Services; </li><li>  Chaining / InputMergers; </li><li>  reactive approach; </li><li>  support from Google (I want to believe it). </li></ul></div><p>Source: <a href="https://habr.com/ru/post/434680/">https://habr.com/ru/post/434680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434670/index.html">Annual Report Habrapost - 2018</a></li>
<li><a href="../434672/index.html">Fintech digest: the most popular products in 2018, doubling the volume of transfers from card to card, tax on cryptocurrency</a></li>
<li><a href="../434674/index.html">We respond to cable vandalism quickly, everywhere and without physical traps</a></li>
<li><a href="../434676/index.html">Top 10 - what it costs to learn in 2019</a></li>
<li><a href="../434678/index.html">Morning admin: add space on dozens of servers for coffee</a></li>
<li><a href="../434682/index.html">Personal city teleportator</a></li>
<li><a href="../434684/index.html">Rust in 2019 and beyond: growth restrictions</a></li>
<li><a href="../434686/index.html">Course of lectures on JavaScript and Node.js in KPI</a></li>
<li><a href="../434688/index.html">FreeBSD plans to upgrade to ZFSonLinux</a></li>
<li><a href="../434690/index.html">Haiku operating system: porting applications and creating packages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>