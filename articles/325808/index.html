<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Image filtering by mathematical morphology on FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to consider one, in my opinion, noteworthy approach to image filtering by the method of mathematical morphology. Many articles ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Image filtering by mathematical morphology on FPGA</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/eff/379/2eb/eff3792ebc7c47d99bab92cf6ae380ca.png"></div><br>  In this article I want to consider one, in my opinion, noteworthy approach to image filtering by the method of mathematical morphology.  Many articles have been written about mathematical morphology, and <a href="https://habrahabr.ru/post/113626/">one of them is located here</a> in Habr√©.  To the reader unfamiliar with this topic, I recommend first reading the material at the link above. <br><br>  In the <a href="https://habrahabr.ru/post/324070/">article</a> about image filtering, I talked about the filtering method with a median filter.  This filter proved to be very good, but it has a number of limitations and inconveniences: <br>  cumbersome even in the implementation of 3x3: <br><br><ul><li>  requires the formation of a window function </li><li>  very complicated for expanding the window </li><li>  large latency when serially connected with other window functions. </li></ul><br>  All these inconveniences do not in the least detract from the degree of its applicability in digital image processing systems, however, there is another approach. <br><a name="habracut"></a><br>  Filtration of images using mathematical morphology is a long-known topic, and all I want is to introduce the reader a little closer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As we have already learned from the article above, from the basic morphological operations <b>narrowing (erosion)</b> and <b>expansion (dilation),</b> we can construct <b>opening (opening)</b> and <b>closing (closing)</b> operations. <br><br>  The <b>open</b> operation is the sequential execution of <b>erosion -&gt; dilation</b> .  This combination will lead to the fact that single pixels and their small clusters will be irretrievably devoured by contraction, as large objects will be gnawed) on the sides.  If inside large objects there were small holes, then they will become larger.  The subsequent expansion operation will restore the gnawed objects to their original size, but there will no longer be small debris that has been devoured by contraction. <br><br>  The <b>closing</b> operation is the sequential execution of <b>dilation ‚Üí erosion</b> .  This operation will first fill the holes inside the objects and make them slightly thicker, and then reduce their thickness to the original, but there will be no more holes. <br><br>  Consecutive opening ‚Üí closing operations are a very good filter, no worse than the median, but on the contrary, it also makes objects less full of holes.  A prerequisite is the same window size for basic operations. <br><br>  However, each basic <b>erosion</b> or <b>dilation</b> operation is all the same window function, requiring at least 2 FIFOs to implement a 3x3 window and logical <b>AND</b> or <b>OR</b> operations depending on the function. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/4ee/14c/23e/4ee14c23e4164ceda298eac4aa385f6f.png"></div><br>  For deeper filtering, a 5x5 and 7x7 window is often used, which entails an increase in the memory capacity of the FIFO elements and the total lag time. <br><br>  To implement such operations on Altera's FPGAs, you can use the FIFO mega-function and the built-in 2-port memory, but for one such FIFO only 1 bit wide, we don‚Äôt need more for a binarized image, such as M4K also not very economical. <br><br><h3>  Low complexity method </h3><br>  While searching for alternative solutions, I came across the so-called <b>low complexity method</b> on the network.  The essence of this method is the decomposition of the matrix of the window function.  The initial matrix is ‚Äã‚Äãdecomposed into two: <br><br><img src="https://habrastorage.org/files/063/ed0/cd1/063ed0cd14104d078219fc30afdd1c8e.png"><br><br>  And it works according to this image: <br><br><img src="https://habrastorage.org/files/22c/473/63d/22c47363d42e42d3815063a639ef9e8c.png"><br><br>  To my shame and regret, I am not strong in mathematics and the topic of decomposition of matrices in the university, I passed, but only by.  For this reason, I will not tell you how it works from a mathematical point of view and why it is so and not otherwise for understandable reasons. <br><br>  The aforementioned article presented a functional scheme for implementing <b>erosion</b> and <b>dilation</b> operations using the low complexity method.  This scheme consists of two blocks, each of which represents a structural element <b>SE1</b> and <b>SE2</b> . <br><br><img src="https://habrastorage.org/files/410/371/37c/41037137c3c94c109ca01f72b6e01ec2.png"><br><br>  From this scheme, it is clear that the choice of erosion / dilation operations is performed by inverting the input data, since  these operations are symmetrical. <br><br>  The output of the <b>Stage-1</b> block depends on the value of the input pixel and the accumulated sum in the <b>ff</b> trigger.  As soon as this sum becomes equal to the width of the window of the structural element SE1, the output of the block will be ‚Äú1‚Äù, otherwise ‚Äú0‚Äù.  Any ‚Äú0‚Äù at the block input resets the accumulated amount in the <b>ff</b> trigger to zero.  Obviously, this unit counts the number of consecutive units under the structural element <b>SE1</b> . <br><br>  The output of the <b>Stage-1</b> block is fed to the input of the <b>Stage-2</b> block, which operates on the same principle.  The difference from the <b>Stage-1</b> block is the use of the Row_mem memory depth in the number of columns of the input image, and the amount is stored separately for each column in this memory.  The output of the block ‚Äú1‚Äù is only when the sum over the column is equal to the height of the structural element <b>SE2</b> .  The output of the <b>Stage-2</b> unit can be inverted depending on the <b>erosion</b> or <b>dilation</b> operation performed. <br><br>  Thus, it turns out that in the <b>Stage-1</b> block, the circuit tracks all ‚Äú1‚Äù under the horizontal element <b>SE1</b> and transfers the result to the <b>Stage-2</b> block, which in turn tracks all the ‚Äú1‚Äù under the vertical element <b>SE2,</b> taking into account the result of the output <b>SE1</b> . <br><br>  Also, this scheme provides signals that ensure the operation of the structural element <b>SE</b> at the edges of the image. <br><br><img src="https://habrastorage.org/files/c4f/a34/29d/c4fa3429d3c445e0a61afc33d2ce7745.png"><br><br>  The borders of the image are conventionally denoted by the names of the cardinal points: North, South, West and East.  When the structural element SE is located at the borders of the image, it is possible to insert ( <b>padding</b> ) the required number of ones or zeros corresponding to the half size of the structural element. <br><br>  The big advantage of this method is saving memory.  The amount of memory required for the <b>Stage-1</b> and <b>Stage-2</b> blocks is determined by the word size ( <b>WL</b> ) equal to <br>  <b>Log2 (SE1_width)</b> and <b>Log2 (SE2_height)</b> .  For the <b>Stage-2</b> block, not the trigger is used, but the <b>Row_mem</b> memory, the size of which is <b>Image_width x Log2 (SE2_height)</b> . <br><br>  Obviously, the result of the calculation of the logarithm must be rounded to the nearest digit capacity <b>SE1_width</b> and <b>SE2_height</b> , i.e.  if the window is 3x5, then the rounded value of <b>Log2 (SE1_width) = 2 bits</b> , and <b>Log2 (SE2_height) = 3 bits</b> . <br><br>  It is not difficult to notice that there is no difference in the use of memory for the 3x3 window in the low complexity method and the usual window method.  That in the first case, the amount of memory is 320 columns x 2 bits, which is second: two single-bit FIFO elements of 320 elements each.  If the window size changes to 5x5 or 7x7, then the number of FIFOs increases in proportion to the number of rows in the window, but for the low complexity method, the word size will increase by only 1 bit, and the Row_mem memory will be 320x2, not 320x3. <br><br>  Thus, you can pre-set the maximum window size and use, for example, the altsyncram <b>mega-function of</b> this size.  It will be much more economical than using FIFO to form a window function. <br><br>  The code for the erosion / dilation module in Verilog: <br><br><div class="spoiler">  <b class="spoiler_title">Low complexity erosion / dilation</b> <div class="spoiler_text"><pre><code class="hljs vhdl">module low_complexity #(<span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BW = <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BH = <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> <span class="hljs-literal"><span class="hljs-literal">WIDTH</span></span> = <span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> HEIGH = <span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> START_X = <span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> START_Y = <span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span> ) ( input wire clk, input wire er_dil, input wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_in, input wire input_valid, input wire [<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x_in, y_in, output wire output_valid, output wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_out ); localparam END_X = (<span class="hljs-literal"><span class="hljs-literal">WIDTH</span></span> + START_X) - <span class="hljs-number"><span class="hljs-number">1</span></span>; localparam END_Y = HEIGH - <span class="hljs-number"><span class="hljs-number">1</span></span>; wire e_bound, s_bound, n_bound, w_bound; assign n_bound = (y_in == START_Y &amp;&amp; x_in == START_X) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; assign s_bound = (y_in == END_Y &amp;&amp; x_in == END_X) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; assign w_bound = (x_in == START_X) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; assign e_bound = (x_in == END_X) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; // stage <span class="hljs-number"><span class="hljs-number">1</span></span> wire mux1_out, mux2_out; wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mux3_out; wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mux4_out; reg [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] ff = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] ff_d = <span class="hljs-number"><span class="hljs-number">0</span></span>; wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] sum1; wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mux5_out; wire cmp1_out; wire [<span class="hljs-number"><span class="hljs-number">8</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mem_addr = input_valid ? x_in[<span class="hljs-number"><span class="hljs-number">8</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] - START_X : <span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; assign mux1_out = er_dil ? ~data_in : data_in; assign mux2_out = (e_bound | s_bound) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : mux1_out; assign mux3_out = mux2_out ? sum1 : <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; assign mux4_out = cmp1_out ? mux5_out : mux3_out; always @(posedge clk) ff_d = mux4_out; always @* ff = ff_d; assign mux5_out = w_bound ? BH - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : ff; assign sum1 = mux5_out + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; assign cmp1_out = (mux3_out == BW) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; // stage2 <span class="hljs-number"><span class="hljs-number">2</span></span> wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] sum2; wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mux6_out, mux7_out; wire cmp2_out; wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mux8_out; wire [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] mem_out; alt_ram320x3 row_mem ( .clock(clk), .data(mux7_out), .rdaddress(mem_addr), .wraddress(mem_addr), .wren(<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>), .q(mem_out) ); assign mux6_out = cmp1_out ? sum2 : <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; assign mux7_out = cmp2_out ? mux8_out : mux6_out; assign mux8_out = n_bound ? BW : mem_out; assign sum2 = mux8_out + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; assign cmp2_out = (mux6_out == BH) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; assign data_out = er_dil ? ~cmp2_out : cmp2_out; assign output_valid = input_valid; endmodule</code> </pre> <br></div></div><br>  Opening and closing operations: <br><br><div class="spoiler">  <b class="spoiler_title">opening / closing</b> <div class="spoiler_text"><pre> <code class="hljs vhdl">wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] er1_out, dil1_out, er2_out, dil2_out; wire dil_input = line_data_out; // OPENING // EROSION <span class="hljs-number"><span class="hljs-number">3</span></span>x3 low_complexity #( .BW(<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h3</span></span>), .BH(<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h3</span></span>), .<span class="hljs-literal"><span class="hljs-literal">WIDTH</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>), .HEIGH(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>), .START_X(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>), .START_Y(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>) ) er_1 ( .clk(clk), .er_dil(<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>), .data_in(dil_input), .input_valid(line_rd_rq), .x_in(x_in), .y_in(y_in), .output_valid(), .data_out(er1_out) ); // DILATION <span class="hljs-number"><span class="hljs-number">3</span></span>x3 low_complexity #( .BW(<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h3</span></span>), .BH(<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h3</span></span>), .<span class="hljs-literal"><span class="hljs-literal">WIDTH</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>), .HEIGH(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>), .START_X(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>), .START_Y(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>) ) dil_1 ( .clk(clk), .er_dil(<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>), .data_in(er1_out), .input_valid(line_rd_rq), .x_in(x_in), .y_in(y_in), .output_valid(), .data_out(dil1_out) ); // CLOSING // DILATION <span class="hljs-number"><span class="hljs-number">3</span></span>x3 low_complexity #( .BW(<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h3</span></span>), .BH(<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h3</span></span>), .<span class="hljs-literal"><span class="hljs-literal">WIDTH</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>), .HEIGH(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>), .START_X(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>), .START_Y(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>) ) dil_2 ( .clk(clk), .er_dil(<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>), .data_in(dil1_out), .input_valid(line_rd_rq), .x_in(x_in), .y_in(y_in), .output_valid(), .data_out(dil2_out) ); // EROSION <span class="hljs-number"><span class="hljs-number">3</span></span>x3 low_complexity #( .BW(<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h3</span></span>), .BH(<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h3</span></span>), .<span class="hljs-literal"><span class="hljs-literal">WIDTH</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>), .HEIGH(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>), .START_X(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>), .START_Y(<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>) ) er_2 ( .clk(clk), .er_dil(<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>), .data_in(dil2_out), .input_valid(line_rd_rq), .x_in(x_in), .y_in(y_in), .output_valid(), .data_out(er2_out) );</code> </pre><br></div></div><br><br><h3>  Result </h3><br>  This video demonstrates the efficiency of image filtering using the mathematical morphology (low complexity method) with a 3x3 window compared to a median filter with a window of the same size. <br><br>  Green marker - median filter <br>  Yellow marker - morphology <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YF7ARlx9pgY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  It is noticeable that unfiltered garbage appears on the video with a green marker and the detector places it in a frame, and in the video with a yellow marker, the garbage disappears and only a large object falls into the frame. <br><br>  From this experiment, we can conclude that the filter based on mathematical morphology does a little better than the median. <br><br><h3>  findings </h3><br>  Based on the method of low complexity erosion / dilation, it is possible to construct the basic elements of morphological image processing much more efficiently in terms of memory consumption than by forming a window function. <br><br>  The result of image filtering by the method of mathematical morphology is no worse than the result of filtering by the median filter, and is a good alternative to the latter. <br><br><h3>  Materials on the topic </h3><br>  ‚Üí <a href="https://pdfs.semanticscholar.org/7073/cb42d5b74d08bf150de12c74c8f99c1fc419.pdf">Low complexity method</a> <br>  ‚Üí <a href="https://www.cs.auckland.ac.nz/courses/compsci773s1c/lectures/ImageProcessing-html/topic4.htm">Morphological image processing</a> <br>  ‚Üí <a href="https://habrahabr.ru/post/113626/">Mathematical morphology</a> </div><p>Source: <a href="https://habr.com/ru/post/325808/">https://habr.com/ru/post/325808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325796/index.html">How to reduce the time to launch applications for iOS</a></li>
<li><a href="../325798/index.html">Kinetics of large clusters</a></li>
<li><a href="../325802/index.html">Working in the cloud on Hyper-V, part 4: creating backup copies of a virtual machine</a></li>
<li><a href="../325804/index.html">Who are you in a startup: hipster, hustler, hacker or analyst</a></li>
<li><a href="../325806/index.html">Y Combinator 2017 Startup School: ‚ÄúWhy?‚Äù (Part One)</a></li>
<li><a href="../325810/index.html">Convenient localization of iOS applications in Interface Builder</a></li>
<li><a href="../325812/index.html">Around the noise. Chat bot: empty HYIP or new era?</a></li>
<li><a href="../325814/index.html">Battle for adults: how to exclude children's channels from advertising on Youtube 24/7?</a></li>
<li><a href="../325816/index.html">Moxy Strategies (Part 1)</a></li>
<li><a href="../325818/index.html">Quick Start: Overview of Core Deep Learning Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>