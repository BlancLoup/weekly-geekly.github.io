<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pattern matching with macros</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Julia language does not support such a programming technique that is well-proven in Haskell, Prolog, Erlang, Scala, and Mathematica, as pattern ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pattern matching with macros</h1><div class="post__text post__text-html js-mediator-article">  The Julia language does not support such a programming technique that is well-proven in Haskell, Prolog, Erlang, Scala, and Mathematica, as <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> .  But allows you to write macros that allow you to fix this fatal flaw.  It looks like this: <br><pre><code class="hljs pgsql">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> X a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> Y a ; b <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; @<span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(Y(X(<span class="hljs-number"><span class="hljs-number">9</span></span>),<span class="hljs-number"><span class="hljs-number">2</span></span>), Y(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)-&gt; <span class="hljs-number"><span class="hljs-number">55</span></span>, Y(X(k),<span class="hljs-number"><span class="hljs-number">2</span></span>)-&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>+k) <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br>  Source code is available on <a href="https://github.com/potan/adt.jl/">github</a> . <br>  Similar (but much more developed and ready for use) can be taken <a href="">here</a> , but it is too big to sort it out as an example in the article. <br><a name="habracut"></a><br>  As in Scala, for each alternative that needs to be recognized, a type is created (in this case, as it should be in functional programming, immutable, but this code will work with types).  If desired, they can be inherited from one abstract. <br><br>  The code for Julia, with which the macros work, <a href="http://docs.julialang.org/en/latest/manual/metaprogramming/">is presented</a> in the form of an Abstract Syntactic Tree (AST).  In this tree, the leaves will be simple language constants (numbers, strings) and symbols (having the type Symbol), and nodes will have type Expr with the head and args fields.  To create an object of type Expr or Symbol, syntactic sugar is available <b>:: v</b> is just a symbol, and <b>: (1 + 2)</b> indicates <b>Expr (: call,: +, 1, 2)</b> (Expr, the first argument of the constructor puts in the head, the rest in the array args).  When constructing expressions, you can ‚Äúquote‚Äù the subexpression created by the program <b>:: ($ (a) + 1)</b> is an expression, adding subexpressions from the variable <b>a</b> with unit.  The quotation was invented in Lisp and found to be in demand in many languages ‚Äã‚Äãthat support metaprogramming. <br><br>  The macro 'case' receives the analyzed expression as the first argument, and the rest, the sample-&gt; reaction pairs.  Let's see how such expressions look in AST. <pre> <code class="hljs coffeescript">julia&gt; :<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Y(X(k),</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)-&gt;</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">+k)</span></span></span><span class="hljs-function">.head :-&gt;</span></span> julia&gt; :<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Y(X(k),</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)-&gt;</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">+k)</span></span></span><span class="hljs-function">.args 2-element Array{Any,1}: :</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Y(X(k),</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> quote # none, line 1: 1 + k end</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider the code that processes such expressions. <pre> <code class="hljs ruby"> casev(v,np,e1) = let ...     spat <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(e1.head == <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(-&gt;)) (p,c) = e1.args <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(p.head == <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(call)) t = eval(p.args[<span class="hljs-number"><span class="hljs-number">1</span></span>]) es = map(spat, t.names, p.args[<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">:end</span></span>]) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isa($v,$t)) ; $(pcomp(c,np,es)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> $np <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The casev function takes arguments: v is the symbol associated with the expression being analyzed (and not the expression itself, so as not to calculate it several times), e1 is the sample-&gt; reaction, and np is what to do if the sample is not recognized (a technique that resembles <a href="http://en.wikipedia.org/wiki/Continuation-passing_style">programming in continuations</a> ). <br>  First it is checked that this expression is of the form '-&gt;' and its arguments are stored in the variables 'p' (sample) and 'c' (the processing code). <br>  A sample that looks like a call is broken down into a symbol for the type and expression of the arguments.  The type symbol needs to be converted into the type itself (the types in Julia are ‚Äúfirst order values‚Äù) in order to understand what can be done with it.  The symbol can be calculated using the eval function.  (It calculates the expression in the context of the current module, so I did not manage to select the macro and auxiliary functions into a separate module.) <br>  Next, we call the function 'spat' for each pair of the name of the type field corresponding to this field subsample. <br><pre> <code class="hljs coffeescript"> spat(n::Symbol, p::Symbol) = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(:(=), :($p = $v.$n))</span></span></span><span class="hljs-function"> spat</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n::Symbol, p::Expr)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(:(m), let s = gensym() ; (m) -&gt; :(let $s = $v.$n $(casev(s,np,:($p-&gt;$m))) end) end)</span></span></span><span class="hljs-function"> spat</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n::Symbol, p::Any)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(:(==), :($p == $v.$n))</span></span></span></span></code> </pre><br>  This is a multimethod, which is dispersed by the type of sample.  For the Symbol and Any types (all constants fall under this) a code is generated and a mark, what to do with it later.  For a complex subsample (of type Expr), a closure is created that the recognizer of the subsample creates recursively, leaving the response free (closure argument 'm') - the processing of the current sample will be transferred there. <br>  Now you can create sample processing <pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isa($v,$t)) ; $(pcomp(c,np,es)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> $np <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br>  'isa' verifies that the value being analyzed is of type 't' (the character of which we received from the sample), 'pcomp' compiles the pieces of the unrecognizing sample code into a single expression, 'np' is a ‚Äúcontinuation‚Äù that other samples recognize if it is not will be recognized.  This approach leads to the fact that the "continue" code will be duplicated during the processing of each possible recognition failure.  While this macro is used by man, this is a permissible luxury.  If the code on Julia with pattern matching starts writing robots, it will be necessary to arrange it into a local function and pass its symbol. <br><pre> <code class="hljs ruby"> pcomp(c,np,p) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(p) == <span class="hljs-number"><span class="hljs-number">0</span></span>) c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (r,d) = p[<span class="hljs-number"><span class="hljs-number">1</span></span>] n1 = pcomp(c,np,p[<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">:end</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r == <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(=)) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(let $d ; $n1 ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) elseif(r == <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(==)) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $(d) ; $n1 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> $np <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) elseif(r == <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(m)) d(n1) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The function receives an array of pieces that recognize individual parts of the sample.  If this array is empty, the sample is already recognized in this place of the generated program and the response code must be called (from the 'c' argument). <br>  If there was a symbol in this place in the sample, it is necessary to arrange the block 'let' with the initialization of the variable with this name and place the code for further processing there. <br>  If there was a constant, create the appropriate 'if' (in the alternative 'else', the ‚Äúcontinue‚Äù code is found on failure). <br>  And if a closure arrives, we call it, passing the pattern recognition code of the sample residue - it will figure out what to do with it. <br><br>  Now it‚Äôs clear how to process several alternative samples and implement the macro itself: <pre> <code class="hljs ruby"> casen(v,el) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(el) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> casev(v,casen(v,el[<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">:end</span></span>]),el[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> macro <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(v,e1...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isa(v,Symbol)) casen(v,e1) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> let s = getsym() <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>(let $(s) = $(v) ; $(casen(s,e1)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Code that it hits <div class="spoiler">  <b class="spoiler_title">can not read</b> <div class="spoiler_text"><pre> <code class="hljs delphi">julia&gt; macroexpand(:(@<span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(Y(X(<span class="hljs-number"><span class="hljs-number">9</span></span>),<span class="hljs-number"><span class="hljs-number">2</span></span>),Y(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)-&gt; <span class="hljs-number"><span class="hljs-number">55</span></span>, Y(X(k),<span class="hljs-number"><span class="hljs-number">2</span></span>)-&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>+k))) :(let <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span> = Y(X(<span class="hljs-number"><span class="hljs-number">9</span></span>),<span class="hljs-number"><span class="hljs-number">2</span></span>) # line <span class="hljs-number"><span class="hljs-number">48</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isa(<span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>,Y) # line <span class="hljs-number"><span class="hljs-number">32</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>.a # line <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>.b # line <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> # none, line <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isa(<span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>,Y) # line <span class="hljs-number"><span class="hljs-number">32</span></span>: let # line <span class="hljs-number"><span class="hljs-number">21</span></span>: <span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span> = <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>.a # line <span class="hljs-number"><span class="hljs-number">22</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isa(<span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span>,X) # line <span class="hljs-number"><span class="hljs-number">32</span></span>: let <span class="hljs-string"><span class="hljs-string">#245</span></span>#k = <span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span>.a # line <span class="hljs-number"><span class="hljs-number">9</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> # ADT.jl, line <span class="hljs-number"><span class="hljs-number">22</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>.b # line <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> # none, line <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">#245</span></span>#k <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">11</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">32</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">32</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isa(<span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>,Y) # line <span class="hljs-number"><span class="hljs-number">32</span></span>: let # line <span class="hljs-number"><span class="hljs-number">21</span></span>: <span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span> = <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>.a # line <span class="hljs-number"><span class="hljs-number">22</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isa(<span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span>,X) # line <span class="hljs-number"><span class="hljs-number">32</span></span>: let <span class="hljs-string"><span class="hljs-string">#245</span></span>#k = <span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span>.a # line <span class="hljs-number"><span class="hljs-number">9</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> # ADT.jl, line <span class="hljs-number"><span class="hljs-number">22</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>.b # line <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> # none, line <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">#245</span></span>#k <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">11</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">32</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">32</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">32</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isa(<span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>,Y) # line <span class="hljs-number"><span class="hljs-number">32</span></span>: let # line <span class="hljs-number"><span class="hljs-number">21</span></span>: <span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span> = <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>.a # line <span class="hljs-number"><span class="hljs-number">22</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isa(<span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span>,X) # line <span class="hljs-number"><span class="hljs-number">32</span></span>: let <span class="hljs-string"><span class="hljs-string">#245</span></span>#k = <span class="hljs-string"><span class="hljs-string">#244</span></span>##<span class="hljs-string"><span class="hljs-string">#11040</span></span>.a # line <span class="hljs-number"><span class="hljs-number">9</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> # ADT.jl, line <span class="hljs-number"><span class="hljs-number">22</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-string"><span class="hljs-string">#246</span></span>##<span class="hljs-string"><span class="hljs-string">#11039</span></span>.b # line <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> # none, line <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">#245</span></span>#k <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">11</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">32</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> # line <span class="hljs-number"><span class="hljs-number">32</span></span>: () <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre></div></div></div><p>Source: <a href="https://habr.com/ru/post/242201/">https://habr.com/ru/post/242201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242191/index.html">Calling to mobile phones from the browser with recording conversations</a></li>
<li><a href="../242193/index.html">Honeymoon Manager: how to spend it with benefit</a></li>
<li><a href="../242195/index.html">The digest of interesting materials for the mobile developer # 77 (October 26 - November 2)</a></li>
<li><a href="../242197/index.html">Cloud Connect: Private and Secure Surfing. Bye for free</a></li>
<li><a href="../242199/index.html">Why does the speed of writing to the RAID decrease as the SSD fills, or why do we need TRIM</a></li>
<li><a href="../242203/index.html">Why is the future behind remote work (part 2)</a></li>
<li><a href="../242205/index.html">Osquery exposes the OS as a relational database</a></li>
<li><a href="../242207/index.html">ah - better than history</a></li>
<li><a href="../242209/index.html">Writing plugins with AppDomain is fun</a></li>
<li><a href="../242211/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ132 (October 27 - November 2, 2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>