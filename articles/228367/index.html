<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tic-tac-toe: compiler against man - extreme metaprogramming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""- After the Revolt, the Galactic Commonwealth imposed strict restrictions on higher-order metafunctions . And not only for ethical reasons; their aut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tic-tac-toe: compiler against man - extreme metaprogramming</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  "- After the Revolt, the Galactic Commonwealth imposed strict restrictions on <b>higher-order metafunctions</b> . And not only for ethical reasons; their authorities fear in general any manifestation of delusions of grandeur ..." <br>  ( <i>from google search results</i> ) </blockquote>  I suggest you play tic-tac-toe with a compiler.  For the game, knowledge of c ++ is not required, it is enough to have cmake, python and the c ++ compiler itself (it will pull even as ancient as gcc-3.3).  Python is used only to enter user data, run the compiler after each turn, and the compiled program to get the result.  All calculations (the next move, determination of the winner or statement of a draw) are made at the compilation stage, at run-time only the output of the result. <br><a name="habracut"></a><br>  For those who have a desire to understand how it works: everything will be fair, no tricky tricks, hacks and code generation by the script (well, almost).  At the output of the script, two files, one with the initial position, is a string of the form e, x, e, o, e, e, e, e, x, where e is an empty field, and in the second file the number 0.1 or 2 is level of difficulty.  There will be 3 levels of difficulty, and the compiler's moves will be random depending on this level.  We will also teach the compiler to play with itself at different levels of complexity. <br><br>  There will be a bit of code - we will use what has already been implemented in the <a href="http://faslib.com/">faslib</a> library.  This library is designed to implement aspect-oriented concepts using patterns based on type lists.  The topics of <acronym>AOP</acronym> , this time we will not touch, and use the packages to work with lists of types and meta-algorithms. <br><br>  To play, we load the project from github (faslib is connected as a submodule): <br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/migashko/tictactoe.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> tictactoe/ git submodule init git submodule update</code> </pre> <br>  Make sure that cmake and c ++ are available, and run the game: <br><pre> <code class="bash hljs">./tictactoe.py</code> </pre><br>  When you first start the script itself will create the build directory and run cmake.  If something went wrong, do it manually: <br><pre> <code class="bash hljs">mkdir build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ./build cmake .. make tictactoe</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Example of one round of the game</b> <div class="spoiler_text"><pre> <code class="bash hljs">Level [0,1,2]: 2 Figure [X,x,1,O,o,0]: o compiling... - - - - X - - - - Move [0..8, a1..c3]: a2 compiling... - O - - X - X - - Move [0..8, a1..c3]: a3 compiling... XOO - X - X - - Move [0..8, a1..c3]: b2 BUSSY Move [0..8, a1..c3]: b1 compiling... XOO OX - X - X X winner (compiler)</code> </pre><br></div></div><br>  The script at the beginning of the game writes the number entered by the user to the level.inl file, which sets the level of difficulty, and after each move to the board.inl file, a new arrangement of figures (crosses or zeros), analyzing which, the compiler makes a move.  These actions can be done manually, run the compiler and see the result.  As an example, write a second level of difficulty in level.inl: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 2 &gt; level.inl</code> </pre><br>  and in board.inl, set the initial positions using a text editor (you can insert line breaks): <br><pre> <code class="cpp hljs">e,e,e, x,o,e, e,e,e</code> </pre><br>  or so: <br><pre> <code class="cpp hljs">echo <span class="hljs-string"><span class="hljs-string">"e,e,e,x,o,e,e,e,e"</span></span> &gt; board.inl</code> </pre><br>  go to build and run make, then ./tictactoe. <br><div class="spoiler">  <b class="spoiler_title">Multiple compilation example</b> <div class="spoiler_text"><pre> <code class="bash hljs">$&gt; make $&gt; ./tictactoe - - - XO - - - X $&gt; make $&gt; ./tictactoe - - X XO - - - - $&gt; make $&gt; ./tictactoe X - - XO - - - -</code> </pre><br></div></div><br>  In addition to tictactoe, there is a program tictactoe_its, which loses the game to the end (also at the compilation stage).  For the initial location of the figures used board.inl.  If you want to play the game from the beginning, just delete this file. <br><div class="spoiler">  <b class="spoiler_title">Example for a starting position with two moves</b> <div class="spoiler_text"><pre> <code class="bash hljs">$&gt; ./tictactoe_its - - - XO - - - - X - - XO - - - - X - - XO - O - - X - X XO - O - - XOX XO - O - - XOX XO - OX - Draw</code> </pre><br></div></div><br>  The algorithm used by the compiler is not perfect, so for a given location, even for the second level of complexity, no one‚Äôs death is guaranteed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Win-win algorithm: <br><ol><li>  We go to the position leading to the victory </li><li>  We block the victory of the enemy </li><li>  <s>Fork</s> </li><li>  To the center </li><li>  <s>If the opponent went to the corner, move to the opposite corner.</s> </li><li>  To any angle </li><li>  In any free position </li></ol><br>  In the current implementation, at the second level of complexity, the compiler ignores points 3 and 5. If you follow this algorithm yourself, even taking into account points 3 and 5, the compiler will reduce the game to a draw.  At the first level, the fourth point is not taken into account, but at the simplest, zero, sixth. <br><br>  To get a chance to win the compiler on the second level of difficulty, you need to make the first move to the ‚Äúwrong‚Äù position - in the side cage.  The progress of the compiler will be in the center.  Your next turn should be at one of the opposite corners, relative to your first turn.  The compiler, following the algorithm, will make a move to any of the free corners, and if he chooses a corner not near your first move, then you are guaranteed to put the fork and win. <br><div class="spoiler">  <b class="spoiler_title">Fork compiler on the second level of complexity</b> <div class="spoiler_text"><pre> <code class="bash hljs">e&gt; ./tictactoe.py Level [0,1,2]: 2 Figure [X,x,1,O,o,0]: x Move [0..8, a1..c3]: b1 compiling‚Ä¶ - - - XO - - - - Move [0..8, a1..c3]: c3 compiling... - - O XO - - - X Move [0..8, a1..c3]: c1 compiling... - - O XO - XOX Move [0..8, a1..c3]: a1 compiling... X - O XO - XOX X winner (you)</code> </pre><br></div></div><br>  At this game we finish and get down to the most interesting.  Next, you need a good knowledge of C ++, especially all that concerns templates.  At the beginning I will give a brief overview of faslib (only those packages that we need to implement the game), then we will teach the compiler to make one move, identify the winner and determine the draw.  And finally, we will teach him to play the whole game with himself. <br><br><h2>  Faslib overview </h2><br>  Orientation in the library is simple - each design (even the simplest) in a separate file.  It is enough to look through the list of files to determine the available functionality.  faslib is a meta-library, there is practically no run-time code, therefore, by functions and algorithms we will mean meta-functions and meta-algorithms. <br><br>  The design of faslib was influenced by several libraries.  Type lists ( <a href="https://github.com/migashko/faslib/tree/master/fas/type_list">fas / type_list</a> ), as well as various types of operations on types ( <a href="https://github.com/migashko/faslib/tree/master/fas/typemanip">fas / typemanip</a> ) are, of course, <a href="http://ru.wikipedia.org/wiki/Loki">Loki</a> .  Many constructions from typemanip can be replaced by analogs of &lt;type_traits&gt; in c ++ 11.  The ideas for the <a href="https://github.com/migashko/faslib/tree/master/fas/mp">fas / mp</a> package (placeholder expressions and lambda meta-functions) and <a href="https://github.com/migashko/faslib/tree/master/fas/integral">fas / integral</a> (wrappers over integral types and operations on them) are taken from boost :: mpl.  I tried to make interfaces for <a href="https://github.com/migashko/faslib/tree/master/fas/algorithm">meta-algorithms</a> similar to STL algorithms. <br><br>  Let's start with integral types.  When working with templates, it is not always convenient to use numbers; for this purpose, special wrappers are more convenient, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::int_&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; level;</code> </pre><br>  The definition of this construction, as well as for other integral types in the package fas / integral.  You can also find basic operations there, for example, additions: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; fas::plus&lt; fas::int_&lt;1&gt;, fas::int_&lt;2&gt; &gt;::value &lt;&lt; std::endl; // 3</span></span></code> </pre><br>  An example of how to find the smallest common multiple at compile time can be explored <a href="">here</a> . <br><br>  The fas / typemanip package contains a set of constructions for working with various data types.  We will need the same_type to determine if the two types are the same: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; fas::same_type&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;::value; <span class="hljs-comment"><span class="hljs-comment">// 0 std::cout &lt;&lt; fas::same_type&lt;int, int&gt;::value; // 1</span></span></code> </pre><br>  Couples and tuples of types and functions of getting the type from a certain position <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::pair&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; &gt; pair; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::tuple&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt; &gt; tuple; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; fas::first&lt;pair&gt;::type::value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; fas::second&lt;tuple&gt;::type::value &lt;&lt; std::endl; // 4 std::cout &lt;&lt; fas::third&lt;tuple&gt;::type::value &lt;&lt; std::endl; // 5</span></span></code> </pre><br>  A tuple can take up to five types.  If more is needed, it is more convenient to use type lists.  Functions for getting the fourth and fifth types: fourth and fifth. <br><br>  Conditional operations: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; fas::if_&lt; fas::true_, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">42</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>&gt; &gt;::type::value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 42 std::cout &lt;&lt; fas::switch_&lt; fas::case_&lt; fas::false_, fas::int_&lt;24&gt; &gt;, fas::case_c&lt; 1, fas::int_&lt;42&gt; &gt;, fas::default_&lt; fas::int_&lt;44&gt; &gt; &gt;::type::value &lt;&lt; std::endl; // 42</span></span></code> </pre><br>  Type Lists.  I will not describe in detail the concept, I will only indicate the features of the implementation.  So, the basic structures: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">empty_list</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> metalist::empty_list metatype; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R = empty_list &gt; struct type_list { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> metalist::type_list metatype; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> L left_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> R right_type; };</code> </pre><br>  List of four types: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list&lt;A, fas::type_list&lt;B, fas::type_list&lt;C, fas::type_list&lt;D &gt; &gt; &gt; &gt; list_abcd; <span class="hljs-comment"><span class="hljs-comment">// [A,B,C,D,empty_list]</span></span></code> </pre><br>  Incorrect list: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list&lt;A, B &gt; list2_ab_invalid;</code> </pre><br>  In faslib, in contrast to Loki, the type list should always end with the type fas :: empty_list.  If this rule is not observed, then this list is called unorganized.  The function of fas :: organize will help to correct the situation, for example like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list&lt; A, B &gt; list_ab_invalid; <span class="hljs-comment"><span class="hljs-comment">// [A,B] typedef fas::type_list&lt; C, D &gt; list_cd_invalid; // [C,D] typedef fas::type_list&lt; list_ab_invalid, list_cd_invalid&gt; list_abcd_invalid; // [[C,D],[C,D]] typedef fas::organize&lt;list2_abcd_invalid&gt;::type list_abcd; // [A,B,C,D,empty_list]</span></span></code> </pre><br>  I sincerely do not understand why Alexandrescu and followers use #define to form a list of types, can be much more elegant, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt;A,B,C&gt;::type <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; <span class="hljs-comment"><span class="hljs-comment">// [A,B,C,empty_list]</span></span></code> </pre><br>  Up to c ++ 11 type_list_n accepts up to 26 parameters, after it is unlimited (variadic templates). <br><div class="spoiler">  <b class="spoiler_title">More about type lists</b> <div class="spoiler_text">  In addition to building type lists, type_list_n can organize them using fas :: organize, removing the restriction on the number of parameters, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; fas::type_list_n&lt;A,B&gt;::type, <span class="hljs-comment"><span class="hljs-comment">// [A,B,empty_list] fas::type_list_n&lt;C,D&gt;::type // [C,D,empty_list] &gt;::type list; // [A,B,C,D,empty_list]</span></span></code> </pre><br>  The following remarkable feature of typelists in faslib is the possibility of their shielding by structures, for example, like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_bc</span></span></span><span class="hljs-class">:</span></span> fas::type_list&lt;B, fas::type_list&lt;C&gt; &gt; {}; <span class="hljs-comment"><span class="hljs-comment">// [B,C,empty_list] struct list_abc: fas::type_list&lt;B, list_bc &gt; {}; // [A,list_bc]</span></span></code> </pre><br>  All operations and algorithms that work with type lists are designed to detect shielding and, if possible, not rebuild them.  Let me explain with the example of combining lists: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::merge&lt; list_bc, <span class="hljs-comment"><span class="hljs-comment">// [B,C,empty_list] list_abc // [A,list_bc] &gt;::type list; // [B,C,A,list_bc]</span></span></code> </pre><br>  A trivial implementation of this operation would rearrange the list in [B, C, A, B, C, empty_list].  Implementation in faslib is not much more complicated, but it does not provide a real profit in terms of optimizing compile time and practical reduction of the log in case of errors when screening the tail of the list.  But the very possibility of screening can be useful for the formation of a list, for example, like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> C&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list123</span></span></span><span class="hljs-class">:</span></span> fas::type_list_n&lt; fas::int_&lt;A&gt;, fas::int_&lt;B&gt;, fas::int_&lt;C&gt; &gt;::type {};</code> </pre><br>  In addition, the screened list, when passed as a template parameter to any class, allows you to make the error log more readable: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;fas/integral.hpp&gt; #include &lt;fas/type_list.hpp&gt; typedef fas::type_list_n&lt; fas::int_&lt;1&gt;, fas::int_&lt;2&gt; , fas::int_&lt;2&gt; &gt;::type list1; struct list2: list1 {}; template&lt;typename L&gt; class test {}; int main() { // test&lt;list2&gt; tst; test&lt;list1&gt; tst; tst.doit(); }</span></span></span></span></code> </pre><br>  In this embodiment, the compiler will produce something like this: <br><pre> <code class="bash hljs">error: <span class="hljs-string"><span class="hljs-string">'class test&lt;fas::type_list&lt;fas::int_&lt;1&gt;, fas::type_list&lt;fas::int_&lt;2&gt;, fas::type_list&lt;fas::int_&lt;2&gt;, fas::empty_list&gt; &gt; &gt; &gt;'</span></span> has no member named <span class="hljs-string"><span class="hljs-string">'doit'</span></span></code> </pre><br>  and for list2: <br><pre> <code class="bash hljs">error: <span class="hljs-string"><span class="hljs-string">'class test&lt;list2&gt;'</span></span> has no member named <span class="hljs-string"><span class="hljs-string">'doit'</span></span></code> </pre><br>  You will feel the difference if there are a dozen or more items on the list.  So, let's reveal the secret of how screening works, using the example of defining a function that determines the length of a list.  Implementation without screening: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class">&lt; type_list&lt;L, R&gt; &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-number"><span class="hljs-number">1</span></span> + length&lt;R&gt;::value }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class">&lt; empty_list &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-number"><span class="hljs-number">0</span></span> }; };</code> </pre><br>  If a shielded list comes to the input of the length function, in this implementation, we get an error at the compilation stage.  In order to distinguish the list of types from other constructions, we use the magic metatype defined in the structures fas :: type_list and fas :: empty_list, declaring additionally: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class"> :</span></span> length_impl&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L::metatype, L&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length_impl</span></span></span><span class="hljs-class">&lt;metalist::type_list, L&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L::right_type tail; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-number"><span class="hljs-number">1</span></span> + length&lt; tail&gt;::value }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length_impl</span></span></span><span class="hljs-class">&lt;metalist::empty_list, L&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-number"><span class="hljs-number">0</span></span> }; };</code> </pre><br>  The idea is that if the specializations of length on fas :: type_list or fas :: empty_list do not work, then specializations based on the type metatype, which is defined in the input parameter, will be involved.  If it is not defined or is not the type fas :: metalist :: type_list or fas :: metalist :: empty_list, then we get a compilation error.  If you delete the specialization length &lt;type_list &lt;L, R&gt;&gt; and length &lt;empty_list&gt;, then the code will work, but it will be compiled slower.  It is much easier for a compiler (in this case, g ++) to work out specializations without ‚Äúopening‚Äù input types. <br><br>  In addition, all operations are able to check the input type lists for validity.  This option is disabled by default, because  it increases compile time.  If you want to experiment with type lists, I recommend that you enable FASLIB_TYPE_LIST_CHECK, for this you just uncomment the line in CMakeLists.txt: <br><br>  #add_definitions (-DFASLIB_TYPE_LIST_CHECK) <br><br>  You can also disable the specialization of operations and algorithms by type_list, leaving only the specialization on the meta type, and evaluate the effect in terms of compile time: <br><br>  #add_definitions (-DDISABLE_TYPE_LIST_SPEC) <br></div></div><br>  Further, in the comments, when describing the type list, for brevity, I will not specify empty_list.  We will work only with the correct type lists. <br><div class="spoiler">  <b class="spoiler_title">How does type_list_n work?</b> <div class="spoiler_text">  Slightly simplified, but working implementation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T2 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T3 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T4 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T5 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T6 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T7 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T8 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T9 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T10 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T11 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T12 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T13 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T14 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T15 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T16 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T17 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T18 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T19 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T20 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T21 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T22 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T23 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T24 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T25 = empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T26 = empty_list &gt; struct type_list_n { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> type_list&lt; T1, type_list&lt; T2, type_list&lt; T3, type_list&lt; T4, type_list&lt; T5, type_list&lt; T6, type_list&lt; T7, type_list&lt; T8, type_list&lt; T9, type_list&lt; T10, type_list&lt; T11, type_list&lt; T12, type_list&lt; T13, type_list&lt; T14, type_list&lt; T15, type_list&lt; T16, type_list&lt; T17, type_list&lt; T18, type_list&lt; T19, type_list&lt; T20, type_list&lt; T21, type_list&lt; T22, type_list&lt; T23, type_list&lt; T24, type_list&lt; T25, type_list&lt; T26 &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; bar; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> organize&lt;bar&gt;::type type; };</code> </pre><br>  We form a list of types from all 26 template parameters, in the head of the list there will be explicitly specified parameters, and the tail of the list will consist of a set of fas :: empty_list - this is an incorrect list of types in the context of faslib.  The operation fas :: organize removes unnecessary fas :: empty_list and as a result we get a list of types from the required number of elements. <br><br>  Option for c ++ 11: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head = fas::empty_list, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args &gt; struct type_list_n { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::organize&lt; fas::type_list&lt; Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> type_list_n&lt;Args...&gt;::type &gt; &gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_list_n</span></span></span><span class="hljs-class">&lt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::empty_list type; };</code> </pre><br>  Also, a simplified implementation - fas :: organize is applied to the list at each stage of its formation.  In an amicable way, you first need to create a list and then organize it once.  Here, fas :: organize is needed in order to be able to pass type lists in the parameters of fas :: type_list_n. <br></div></div><br><br><h4>  Type list operations </h4><br>  For manipulations with type lists, there is a set of operations that, in addition to the type list L, can take type T and index I, an integral type.  For operations with an index, there is an alternative with the suffix _c, in which the index is given by a number, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::erase&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, fas::type_list&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::type empty; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::erase_c&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, fas::type_list&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; &gt;::type empty;</code> </pre><br>  List of all available operations for type lists: <br><ul><li> <b><code>erase&lt;I,L&gt;::type</code></b> <br> <b><code>erase_c&lt;int,L&gt;::type</code></b> <br>  Removes item at position I from list L </li><li> <b><code>head::type</code> <br></b>  <b>Returns the list item L (list head)</b> <br> <b><code>index_of&lt;T,L&gt;::value</code></b> <br>  Returns the position of the first occurrence of type T in the list L. If the type is not found, then -1 <br> <b><code>length::value</code> <br></b>  <b>Specifies the length of the L type list.</b> <br> <b><code>merge&lt;L1,L2&gt;::type</code></b> <br>  Combines two lists L1 and L2 into one list <br> <b><code>organize::type</code> <br></b>  <b>Converts the wrong type list L to the correct list.</b> <br> <b><code>normalize::type</code> <br></b>  <b>Same as organize, but if L is not a type list, translates it into a single-item list.</b> <br> <b><code>push_back&lt;T,L&gt;::type</code></b> <br>  Adds type T to the end of the list L <br> <b><code>push_front&lt;T,L&gt;::type</code></b> <br>  Adds type T to the top of list L <br> <b><code>reverse::type</code> <br></b>  <b>Changes the order of the elements of the list L to the opposite</b> <br> <b><code>split&lt;I,L&gt;::left_list</code></b> <br> <b><code>split&lt;I,L&gt;::right_list</code></b> <br> <b><code>split_c&lt;int,L&gt;::left_list</code></b> <br> <b><code>split_c&lt;int,L&gt;::right_list</code></b> <br>  Splits list L into two lists at position I <br> <b><code>tail::type</code> <br></b>  <b>Returns the tail of list L (deletes the first element of the list)</b> <br> <b><code>type_at&lt;I,L&gt;::type</code></b> <br> <b><code>type_at_c&lt;int,L&gt;::type</code></b> <br>  Returns the type at position I of list L <br> <b><code>type_count&lt;T,L&gt;::value</code></b> <br>  The number of types T in the list of types L <br> <b><code>unique::type</code> <br></b>  <b>Removes all duplicate items in the L type list, leaving the last entry.</b> <br> <b><code>unique_first::type</code> <br></b>  <b>Same as unique, but leaves the first occurrence of an element.</b> <br><br>  There are no obvious operations in this list, such as replacing the type in the set_at position (we will need it in order to make a move) and getting the last element of the list of last types.  This is due to the fact that the faslib packages considered in this article were developed mainly to support the fas / aop package - the main package of faslib.  And operations like set_at were simply not needed for this.  Well, let's correct this misunderstanding. <br><br>  To get the last element, you need to calculate the length of the type list (fas :: length) and get the type in the penultimate position (fas :: type_at): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::type_at_c&lt; fas::length&lt; L &gt;::value<span class="hljs-number"><span class="hljs-number">-1</span></span>, L &gt;::type type; };</code> </pre><br>  The set_at operation will set the type at the specified position in the type list.  We also develop a set_at_c which takes a number as a position.  To minimize the compilation time, it is more efficient to implement this operation on specializations, but we will make it easier - we use the available operations.  For this: <br><ol><li>  We divide the type list into two lists (fas :: split) </li><li>  In the second list, cut off the head (fas :: tail) </li><li>  Add the specified type to the beginning of the decapitated list (fas :: push_front) </li><li>  Combine left and right, modified lists (fas :: merge) </li></ol><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Pos, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set_at_c</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::split_c&lt;Pos, L&gt; splitter; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> splitter::left_list left_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> splitter::right_list right_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::tail&lt; right_list &gt;::type headless; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::push_front&lt; T, headless &gt;::type pollywog; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; left_list, pollywog &gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pos, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set_at</span></span></span><span class="hljs-class"> :</span></span> set_at_c&lt; Pos::value, T, L&gt; { };</code> </pre><br><br><h4>  Algorithms </h4><br>  In addition to operations on type lists, faslib implements a number of compile-time algorithms, by analogy with stl algorithms.  Unlike operations, an algorithm is always a meta-function (the structure in which the type is defined is the resultant type).  Many algorithms accept as input, in addition to the type list, a unary or binary operation ‚Äî this is a template meta-function with one or two parameters.  If the algorithm is a condition, then a unary or binary predicate is needed (also a meta-function).  Comparisons of integral types, functions from the fas / typemanip package (for example, same_type, super_subclass), or stl &lt;type_traits&gt; classes (for example, std :: is_base_of if you use c ++ 11) can be used as a predicate. <br><br>  All algorithms that use operations and / or predicates have a version with the _t suffix, which accepts operations and predicates in the form of template-template parameters, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_t</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  which for each element of the type list L applies operation F, for example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt; &gt;::type lst; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::<span class="hljs-keyword"><span class="hljs-keyword">transform_t</span></span>&lt;lst2, fas::inc &gt;::type res; <span class="hljs-comment"><span class="hljs-comment">// [2,3,4,5]</span></span></code> </pre><br>  As a result, we obtain a list of integral types, where each element of the list is incremented by one.  A variant without a suffix implies the use of placeholder expressions: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  For example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::transform&lt;lst, fas::inc&lt; fas::_ &gt; &gt;::type res2;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">More about placeholders</b> <div class="spoiler_text">  Placeholders are a thing that is much easier to use than to explain how to use it.  In general, everything is similar to boost :: mpl and c ++ 11, the limitation is that there are only five of them in faslib: _1, _2, _3, _4, _5 and there is also a universal _, the use of which is easier to describe with examples: <br><table><tbody><tr><th>  Example </th><th>  Alternative </th></tr><tr><td>  foo &lt;_&gt; </td><td>  foo &lt;_1&gt; </td></tr><tr><td>  foo &lt;_, _&gt; </td><td>  foo &lt;_1, _2&gt; </td></tr><tr><td>  foo &lt;_1, _, _ 2&gt; </td><td>  foo &lt;_1, _1, _2&gt; </td></tr><tr><td>  foo &lt;_1, _, _ 2, _, _&gt; </td><td>  foo &lt;_1, _1, _2, _2, _3&gt; </td></tr></tbody></table><br>  In other words, the first _ in the expression is equivalent to _1, the second - _2, etc.  If placeholders other than _ are used in the expression, then it is better to refuse the latter altogether, otherwise the expression becomes difficult to understand.  At the same time, in simple versions, they are very convenient. <br><br>  In the example with fas :: transform, we used the function fas :: inc to get the integral type increased by one.  However, the result of this function is a type of the form fas :: integral_c &lt;int, 4&gt; which is semantically equivalent to fas :: int_ &lt;4&gt;, but this is a different type.  To convert fas :: integral_c to fas :: int_, you can use the fas :: make_int function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::transform&lt; lst, fas::make_int&lt; fas::inc&lt; fas::_ &gt; &gt; &gt;::type res2;</code> </pre><br></div></div><br>  List of available algorithms: <br><ul><li> <b><code>accumulate&lt;L, I, F&lt;_,_&gt;=plus &gt;</code></b> <br>  For a list of integral types, calculates the sum of the value of I and the list L using the operation F (the default is addition).  It can be used for any type, since  for each type T from the list of types L, applies F &lt;Pred, T&gt;, where Pred at the first iteration is the initial type I, and at subsequent results the result of the previous F </li><li> <b><code>count&lt;T, L&gt;</code></b> <br>  Specifies the number of types T in the list of types L, analogue of fas :: type_count, but uses fas :: count_if and fas :: same_type </li><li> <b><code>count_if&lt;L, &lt;_&gt; &gt;</code></b> <br>  Specifies the number of types in the list L that satisfy the condition C &lt;_&gt; </li><li> <b><code>erase_if&lt;L, C&lt;_&gt; &gt;</code></b> <br>  Removes all types from the list L that satisfy the condition C &lt;_&gt; </li><li> <b><code>find_if&lt;L, C&lt;_&gt; &gt;</code></b> <br>  Finds a type in the list that satisfies the C &lt;_&gt; condition (first occurrence) </li><li> <b><code>for_&lt;I, C&lt;_&gt;, F&lt;_&gt; &gt;</code></b> <br>  Recursively applies F &lt;_&gt; using the initial type I, as long as the condition C &lt;_&gt; is satisfied </li><li> <b><code>generator&lt; T, F&lt;_&gt; &gt;</code></b> <br>  Generates a new type using F </li><li> <b><code>generate&lt; N, F &gt;</code></b> <br>  Generates a list of N long types using the F type generator (for example, fas :: generator) </li><li> <b><code>index_of_if&lt;L, C&lt;_&gt; &gt;</code></b> <br>  The position of the element in the type list that satisfies the condition C &lt;_&gt; </li><li> <b><code>is_sorted&lt;L, &lt;_,_&gt;=less &gt;</code></b> <br>  Defines the ordering of the L type list using the binary predicate C </li><li> <b><code>random_shuffle&lt;R, L&gt;</code></b> <br>  Pseudo-randomly mixes the list of types L, using the integral type R as the grain </li><li> <b><code>select&lt; L, &lt;_&gt; &gt;</code></b> <br>  Extracts types from a list of L that satisfy the condition C &lt;_&gt;.  At the exit a list of types. </li><li> <b><code>shuffle&lt; L, RL&gt;</code></b> <br>  Shuffles the list of types L using the list of integral types RL </li><li> <b><code>sort&lt;L, &lt;_,_&gt;=less &gt;</code></b> <br>  Sorts the list of types L </li><li> <b><code>transform&lt;L, F&lt;_&gt; &gt;</code></b> <br>  Returns a list of types whose elements are the result of F &lt;_&gt; </li><li> <b><code>transform2&lt;L1, L2, F&lt;_,_&gt; &gt;</code></b> <br>  Returns a list of types whose elements are the result of F &lt;_1, _2&gt;, where _1 and _2 are elements of the first and second lists, respectively </li><li> <b><code>transform_if&lt; L, F&lt;_&gt;, C&lt;_&gt; &gt;</code></b> <br>  Returns a list of types whose elements are the result of F &lt;_&gt;, provided that C &lt;_&gt;.  If the condition is not met, the type does not change. </li><li> <b><code>transform_tail&lt;L, F&lt;_&gt; &gt;</code></b> <br>  Changes the tail of the list for each element (including the element itself, as the head of the list) using F &lt;_&gt; </li><li> <b><code>transform_tail_if&lt; L, F&lt;_&gt;, C&lt;_&gt; &gt;</code></b> <br>  Changes the tail of the list for each element (including the element itself, as the head of the list) using F &lt;_&gt; if the current element is C &lt;_&gt; </li><li> <b><code>unique_if&lt;L, &lt;_,_&gt;=same_type &gt;</code></b> <br>  ,  &lt;_,_&gt;    </li><li> <b><code>unique_first_if&lt;L, &lt;_,_&gt;=same_type &gt;</code></b> <br>  ,  &lt;_,_&gt;    </li></ul><br>    compile-time : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &gt;::type list1; <span class="hljs-comment"><span class="hljs-comment">//[3,2,3,1] typedef fas::sort_t&lt;list1&gt;::type res1; //[1,2,3,3] typedef fas::sort&lt;list1&gt;::type res2; //[1,2,3,3] typedef fas::sort_t&lt;list1, fas::greater&gt;::type res3; //[3,3,2,1] typedef fas::sort&lt; list1, fas::greater&lt; fas::_1, fas::_2&gt; &gt;::type res4; //[3,3,2,1] typedef fas::sort&lt; list1, fas::greater&lt; fas::_2, fas::_1&gt; &gt;::type res5; //[1,2,3,3]</span></span></code> </pre><br>      . ,      : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">:</span></span>A{}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">:</span></span>B{}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">:</span></span>C{}; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; C, B, A, A, D &gt;::type list2; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::sort&lt; list2, fas::f&lt; fas::super_subclass&lt; fas::_1, fas::_2&gt; &gt; &gt;::type res5; <span class="hljs-comment"><span class="hljs-comment">// [A,A,B,C,D]</span></span></code> </pre><br>  super_subclass   typemanip   -    faslib, ..      type,   value,    1,      ,     .   fas::f   .     c++11,     fas::super_subclass,    std::is_base_of,     type  value.  Moreover, since     ,      - : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::sort&lt; list2, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt; fas::_1, fas::_2&gt; &gt;::type res5; <span class="hljs-comment"><span class="hljs-comment">// [A,A,B,C,D] typedef fas::sort_t&lt;list2, std::is_base_of &gt;::type res5; // [A,A,B,C,D]</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">  ?</b> <div class="spoiler_text">  fas::is_sorted  fas::true_,         .  fas::sort    ,      ,      ,     . <br><br> ,     ‚Äî       .           ‚Äî      .   ,   fas::for_, fas::shuffle  fas::random_shuffle     ,       .          faslib. <br></div></div><br>    ‚Äî       fas::accumulate <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; A, B, C &gt;::type list4; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::accumulate&lt; list4, empty_list, push_front&lt;_2, _1&gt; &gt;::type res4; <span class="hljs-comment"><span class="hljs-comment">// [C,B,A]</span></span></code> </pre><br>       faslib,     ,      -. <br><br><h4> -.   </h4><br>    ,    : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o</span></span></span><span class="hljs-class"> {</span></span>};</code> </pre><br>      ,   python : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::int_&lt; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"level.inl"</span></span></span><span class="hljs-meta"> &gt; level; typedef fas::type_list_n</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; #include "board.inl" &gt;::type board;</span></span></span></span></code> </pre><br>   *.lnl ,      (. CMakeLists.txt).         .          rand.inl    ‚Äî        .   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::int_&lt; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rand.inl"</span></span></span><span class="hljs-meta"> &gt; initial_rand;</span></span></code> </pre><br>     : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; e, e, e, e, e, e, e, e, e &gt;::type empty_board;</code> </pre><br>       .   : <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; s, e) { s &lt;&lt; <span class="hljs-string"><span class="hljs-string">"-"</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; s, o) { s &lt;&lt; <span class="hljs-string"><span class="hljs-string">"O"</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; s, x) { s &lt;&lt; <span class="hljs-string"><span class="hljs-string">"X"</span></span>; }</code> </pre><br>      ,      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; s, fas::type_list&lt;L, R&gt;) { s &lt;&lt; L(); <span class="hljs-comment"><span class="hljs-comment">//   int len = fas::length&lt;R&gt;::value; //    if ( len%3 == 0 ) //     ,     s &lt;&lt; std::endl; else if (len != 0) // ,    ,   s &lt;&lt; " "; s &lt;&lt; R(); // ‚Äú‚Äù    } std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, fas::empty_list) { //  .    }</span></span></code> </pre><br>  ‚Äú‚Äù      : <br><ol><li> ,   .    fas::int_&lt;-1&gt;, ,   (  ,     ) </li><li>  .   ,   e ( ) </li><li>    ( ).   ,    </li></ol><br>    ‚Äú‚Äù   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pos, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt; ( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; s, fas::tuple&lt; Pos, Fig, Board&gt; ) { s &lt;&lt; Board(); <span class="hljs-comment"><span class="hljs-comment">//  Board  ,     enum { //   nopos = fas::same_type&lt; Pos, fas::int_&lt;-1&gt; &gt;::value, //   nofig = fas::same_type&lt; e, Fig&gt;::value, }; if ( nopos ) { //   ,      if (nofig) s &lt;&lt; "Draw" &lt;&lt; std::endl; else s &lt;&lt; Fig() &lt;&lt; " winner (you)" &lt;&lt; std::endl; } else if ( !nofig ) { //      -   s &lt;&lt; Fig() &lt;&lt; " winner (compiler)" &lt;&lt; std::endl; } }</span></span></code> </pre><br>       ,     (    fas::empty_list     ): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pos, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tail&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; s ,fas::type_list&lt;fas::tuple&lt; Pos, F, S&gt;, Tail&gt;) { s &lt;&lt; fas::tuple&lt;Pos, F, S&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; s &lt;&lt; Tail(); }</code> </pre><br>     .      game: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Level, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">game</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  R ‚Äî     ,    , Level ‚Äî  , Board ‚Äî   ‚Äî      ().  ,    ,    : ,    ( -1   ),   (e ‚Äî  ),      (empty_list   ). <br><br>  The algorithm is as follows: <br><ol><li>   ( ) </li><li>        ‚Äî   : [, ] </li><li>     ,   </li><li>     </li><li>   </li><li>   (   ) </li></ol><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Level, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">game</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> figure&lt;Board&gt;::type fig; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> available_moves&lt;R, Level, fig, Board&gt;::type moves; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::head&lt;moves&gt;::type result_move; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::first&lt;result_move&gt;::type position; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::second&lt;result_move&gt;::type win_fig; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> do_move&lt;position, fig, Board&gt;::type board; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::tuple&lt; position, win_fig, board &gt; type; };</code> </pre><br> ,     , :     ,   ,    ‚Äî : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">figure</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::if_c&lt; fas::type_count&lt; e, Board&gt;::value % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>, x, o &gt;::type type; };</code> </pre><br>    ,   ,    , ..           . <br><br>      (available_moves)   : [, ],        ‚Äî      .   ,         -1.  : <br><ul><li> [-1,e] ‚Äî  ( ),   ,     ( ) </li><li> [-1,x] ‚Äî  ,   </li><li> [N,e] ‚Äî     N </li><li> [N,x] ‚Äî  ,    (   ) </li></ul><br>  available_moves  ,    ,            : <br><ol><li> winner_list ‚Äî     ,  [-1,x].        </li><li> winning_moves ‚Äî     ,      ,  [4,o].        </li><li> blocking_moves ‚Äî             ,  [7,x].        </li><li> draw_list ‚Äî     [-1,e]    </li><li>    ,  [3,e].        </li></ol><br>   ,   ,    ,      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Level, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">available_moves</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::type_list_n&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> winner_list&lt; Fig, Board &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> winning_moves&lt; Fig, Board &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> blocking_moves&lt; Fig, Board &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> draw_list&lt; Board &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> free_moves&lt;R, Level, Board &gt;::type &gt;::type type; };</code> </pre><br>     : winner_list, winning_moves  blocking_moves.       ,         [, ].   :   ,       . ,  : <br><pre> <code class="cpp hljs">x - - <span class="hljs-number"><span class="hljs-number">0</span></span> x - - - <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>   : <br><pre> <code class="cpp hljs">[[<span class="hljs-number"><span class="hljs-number">0</span></span>,e],[<span class="hljs-number"><span class="hljs-number">1</span></span>,e],[<span class="hljs-number"><span class="hljs-number">2</span></span>,e]] [[<span class="hljs-number"><span class="hljs-number">3</span></span>,e],[<span class="hljs-number"><span class="hljs-number">4</span></span>,e],[<span class="hljs-number"><span class="hljs-number">5</span></span>,e]] [[<span class="hljs-number"><span class="hljs-number">6</span></span>,e],[<span class="hljs-number"><span class="hljs-number">7</span></span>,e],[<span class="hljs-number"><span class="hljs-number">8</span></span>,e]] [[<span class="hljs-number"><span class="hljs-number">0</span></span>,e],[<span class="hljs-number"><span class="hljs-number">3</span></span>,e],[<span class="hljs-number"><span class="hljs-number">6</span></span>,e]] [[<span class="hljs-number"><span class="hljs-number">1</span></span>,e],[<span class="hljs-number"><span class="hljs-number">4</span></span>,e],[<span class="hljs-number"><span class="hljs-number">7</span></span>,e]] [[<span class="hljs-number"><span class="hljs-number">2</span></span>,e],[<span class="hljs-number"><span class="hljs-number">5</span></span>,e],[<span class="hljs-number"><span class="hljs-number">8</span></span>,e]] [[<span class="hljs-number"><span class="hljs-number">0</span></span>,e],[<span class="hljs-number"><span class="hljs-number">4</span></span>,e],[<span class="hljs-number"><span class="hljs-number">8</span></span>,e]] [[<span class="hljs-number"><span class="hljs-number">2</span></span>,e],[<span class="hljs-number"><span class="hljs-number">4</span></span>,e],[<span class="hljs-number"><span class="hljs-number">6</span></span>,e]]</code> </pre><br>   ,  ,      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> PairList3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">winner_line</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::switch_&lt; fas::case_c&lt; is_win_line&lt;x, PairList3&gt;::value, fas::pair&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;, x&gt; &gt;, fas::case_c&lt; is_win_line&lt;o, PairList3&gt;::value, fas::pair&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;, o&gt; &gt;, fas::default_&lt; fas::empty_list &gt; &gt;::type type; };</code> </pre><br>     (is_win_line&lt;x, PairList3&gt;),   [-1,x] ‚Äî  , ..  ,    ,  [-1,o].    ‚Äî  . <br><br>  ,  ,         ,   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> PairList3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_win_line</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = fas::count_if&lt; PairList3 , fas::same_type&lt; Fig, fas::second&lt;fas::_1&gt; &gt; &gt;::value == <span class="hljs-number"><span class="hljs-number">3</span></span> }; };</code> </pre><br>       (   ,      )  .    ,    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> PairList3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">has_win_pos</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = fas::count_if&lt; PairList3 , fas::same_type&lt; e, fas::second&lt;fas::_1&gt; &gt; &gt;::value == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; fas::count_if&lt; PairList3 , fas::same_type&lt; Fig, fas::second&lt;fas::_1&gt; &gt; &gt;::value == <span class="hljs-number"><span class="hljs-number">2</span></span> }; };</code> </pre><br>    value   1,       ,      . <br><br>      ,      ,      e,  ,        ‚Äî      ,      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> PairList3 &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">win_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::if_c&lt; has_win_pos&lt; Fig, PairList3 &gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::select&lt; PairList3, fas::same_type&lt; fas::second&lt;fas::_1&gt;, e&gt; &gt;::type, fas::empty_list &gt;::type type; };</code> </pre><br>  ,      ,    (     )   win_helper: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> PairList3 &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocking_move</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::if_&lt; fas::same_type&lt;Fig, x&gt;, o, x &gt;::type rev_fig; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> win_helper&lt; rev_fig, PairList3 &gt;::type type; };</code> </pre><br>        ,       (    ,            e,  [8,e])    .     transform: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> PairList3&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">winning_move</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::transform&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> win_helper&lt; Fig, PairList3 &gt;::type, fas::pair&lt; fas::first&lt;fas::_1&gt;, Fig &gt; &gt;::type type; };</code> </pre><br>   win_helper  ,      .    win_helper     ,  [[4,e]] ,   ,    e    (Fig).    ,  win_helper    ,       fas::if_. <br><br> ,   ,    ,   .  ,  : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Move</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fig</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P2</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">move_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::type_list_n&lt; fas::pair&lt; fas::int_&lt;P0&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::type_at_c&lt;P0, Board&gt;::type &gt;, fas::pair&lt; fas::int_&lt;P1&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::type_at_c&lt;P1, Board&gt;::type &gt;, fas::pair&lt; fas::int_&lt;P2&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::type_at_c&lt;P2, Board&gt;::type &gt; &gt;::type pos_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Move&lt;Fig, pos_list&gt;::type type; };</code> </pre><br>  Move        (winner_line, blocking_move  winning_move).  move_t      [, ],      P0, P1  P2     Move. <br>    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Move</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fig</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">moves_list_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::type_list_n &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">move_t</span></span>&lt; Move, Fig, Board, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">move_t</span></span>&lt; Move, Fig, Board, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">move_t</span></span>&lt; Move, Fig, Board, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">move_t</span></span>&lt; Move, Fig, Board, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">move_t</span></span>&lt; Move, Fig, Board, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">move_t</span></span>&lt; Move, Fig, Board, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">move_t</span></span>&lt; Move, Fig, Board, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">move_t</span></span>&lt; Move, Fig, Board, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> &gt;::type &gt;::type type; };</code> </pre><br>        (  )  . <br><br>   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">winner_list</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">moves_list_t</span></span>&lt; winner_line, Fig, Board&gt; {};</code> </pre><br>   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">winning_moves</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">moves_list_t</span></span>&lt; winning_move, Fig, Board&gt; {};</code> </pre><br>   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocking_moves</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">moves_list_t</span></span>&lt; blocking_move, Fig, Board&gt; {};</code> </pre><br> ,          (winner_line, blocking_move  winning_move),   .    ‚Äî  .    ‚Äî     ,   .    ,  ,  ,   ,         .      (winner_line, blocking_move  winning_move)   ,   . ,     ,      ,    ,     . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">draw_list</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::if_c&lt; fas::type_count&lt; e, Board &gt;::value &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>, fas::pair&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;, e &gt;, fas::empty_list &gt;::type type; };</code> </pre><br>   ,     ,    [-1,e] ‚Äî  , . <br><br>   ,    ,   ‚Äî     .    ,          (   )     ‚Äú ‚Äù,      . <br><br>    free_moves    .  ,    ,     ,      .       [, ]      ,      e ( ). <br><br>  ,               ,    ¬Æ   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Level&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">priority_positions</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>    : <br><ol><li>  ( 4) </li><li>   ([0,2,6,8]) </li><li>    ([1,3,5,7]) </li></ol><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::int_&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt; center; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt;::type corner_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt; &gt;::type edge_list;</code> </pre><br>         corner_list  edge_list    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; center, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::random_shuffle&lt; R, corner_list&gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::random_shuffle&lt; R, side_list&gt;::type &gt;::type &gt;::type level2_list;</code> </pre><br>        : , ,  .   fas::merge   ‚Äú‚Äù fas::type_list_n. <br><div class="spoiler"> <b class="spoiler_title">  random_shuffle?</b> <div class="spoiler_text">        , , ,   ,     .  In fact, everything is simple. ,      : <br><pre> <code class="hljs json">[A,B,C,D]</code> </pre><br>  ,   ,    -     , : <br><pre> <code class="hljs json">[<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">44</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>]</code> </pre><br>        : <br><pre> <code class="hljs json">[[<span class="hljs-number"><span class="hljs-number">10</span></span>,A],[<span class="hljs-number"><span class="hljs-number">2</span></span>,B],[<span class="hljs-number"><span class="hljs-number">44</span></span>,C],[<span class="hljs-number"><span class="hljs-number">7</span></span>,D]]</code> </pre><br>       : <br><pre> <code class="cpp hljs">[[<span class="hljs-number"><span class="hljs-number">2</span></span>,B],[<span class="hljs-number"><span class="hljs-number">7</span></span>,D],[<span class="hljs-number"><span class="hljs-number">10</span></span>,A],[<span class="hljs-number"><span class="hljs-number">44</span></span>,C]]</code> </pre><br>       : <br><pre> <code class="cpp hljs">[B,D,A,C]</code> </pre><br>       ,       .   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::generator&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, fas::inc&lt; fas::_ &gt; &gt;::next_type result; <span class="hljs-comment"><span class="hljs-comment">// fas::int_&lt;2&gt;</span></span></code> </pre><br>    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::generator&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, fas::rand&lt; fas::_&gt; &gt;::next_type result; <span class="hljs-comment"><span class="hljs-comment">// fas::int_&lt;12461757&gt;</span></span></code> </pre><br>  fas::generate       .  fas::random_shuffle   fas::shuffle,               ( fas::transform2),  ,        (fas::transform). <br><br>   fas::random_shuffle,         fas::shuffle ‚Äî  .   fas::random_shuffle: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">random_shuffle</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> generate_c&lt; length&lt;L&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">generator_t</span></span>&lt;rand&lt;R&gt;, rand &gt; &gt;::type rand_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> shuffle&lt; L, rand_list&gt;::type type; };</code> </pre><br>  fas::shuffle: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RL&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shuffle</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transform2_t</span></span>&lt; RL, L, make_pair &gt;::type pair_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> sort&lt; pair_list, less&lt; first&lt;_1&gt;, first&lt;_2&gt; &gt; &gt;::type sorted_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transform_t</span></span>&lt; sorted_list, second &gt;::type type; };</code> </pre><br></div></div><br>       ,     : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::random_shuffle&lt; R, level2_list &gt;::type level0_list;</code> </pre><br>              ,  ,      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; corner_list, edge_list &gt;::type side_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; center, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::random_shuffle&lt; R, side_list&gt;::type &gt;::type level1_list;</code> </pre><br>       ,    ,    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::switch_&lt; fas::case_c&lt; Level::value == <span class="hljs-number"><span class="hljs-number">0</span></span>, level0_list &gt;, fas::case_c&lt; Level::value == <span class="hljs-number"><span class="hljs-number">1</span></span>, level1_list &gt;, fas::default_&lt; level2_list &gt; &gt;::type type;</code> </pre><br>  Total: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Level&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">priority_positions</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::int_&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt; center; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt;::type corner_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::type_list_n&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt; &gt;::type edge_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; corner_list, edge_list &gt;::type side_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; center, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::random_shuffle&lt; R, corner_list&gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::random_shuffle&lt; R, side_list&gt;::type &gt;::type &gt;::type level2_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::merge&lt; center, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::random_shuffle&lt; R, side_list&gt;::type &gt;::type level1_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::random_shuffle&lt; R, level2_list &gt;::type level0_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::switch_&lt; fas::case_c&lt; Level::value == <span class="hljs-number"><span class="hljs-number">0</span></span>, level0_list &gt;, fas::case_c&lt; Level::value == <span class="hljs-number"><span class="hljs-number">1</span></span>, level1_list &gt;, fas::default_&lt; level2_list &gt; &gt;::type type; };</code> </pre><br>   priority_positions    ‚Äî         .    free_moves    ,   [N,e],      : <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::transform &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> priority_positions&lt; R, Level &gt;::type, fas::pair&lt; fas::_1, fas::type_at&lt; fas::_1, Board&gt; &gt; &gt;::type pair_list;</code> </pre><br>    : <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::select&lt; pair_list, fas::same_type&lt; e, fas::second&lt;fas::_&gt; &gt; &gt;::type type;</code> </pre><br> , ,            : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Level, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">free_moves</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::transform&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> priority_positions&lt; R, Level &gt;::type, fas::pair&lt; fas::_1, fas::type_at&lt; fas::_1, Board&gt; &gt; &gt;::type pair_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::select&lt; pair_list, fas::same_type&lt; e, fas::second&lt;fas::_&gt; &gt; &gt;::type type; };</code> </pre><br>     game ‚Äî  .   ,    e,    ,    .       (     ,      ): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pos, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_move</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> set_at&lt; Pos, Fig, Board &gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Fig, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Board&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_move</span></span></span><span class="hljs-class">&lt; fas::int_&lt;-1&gt;, Fig, Board&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::empty_list type; };</code> </pre><br> . , .  : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"tictactoe.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"show_board.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { typedef game&lt; initial_rand, level, board &gt;::type result; std::cout &lt;&lt; result() ; return 0; }</span></span></span></span></code> </pre><br> ,         .      ,          ‚Äî  . <br><br><h4> -.  The consignment </h4><br>     ,    game,   ,       .      .   ( ): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) : <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factorial</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = N * factorial&lt;N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::value }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factorial</span></span></span><span class="hljs-class">&lt;1&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { value = <span class="hljs-number"><span class="hljs-number">1</span></span> };};</code> </pre><br>  : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; result*=i, --i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>;i++); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>   fas::for_: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fas::for_&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, fas::less&lt;fas::_, fas::int_&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>&gt; &gt;, fas::inc&lt;fas::_&gt; &gt;::type result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; result::value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>    for  fas::for_  :  ,   .      ,  ,  , ,   ,  . ,  ,   ,     ..      .      ,     .     ,          . <br><br>           ‚Äî    : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factorial</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> fas::for_&lt; <span class="hljs-comment"><span class="hljs-comment">//   fas::pair&lt; fas::int_&lt;I&gt;, //  fas::int_&lt;1&gt; //   &gt;, //  (   ) fas::greater&lt; fas::first&lt; _1 &gt;, int_&lt;0&gt; &gt;, //  (       ) fas::pair&lt; fas::dec&lt; fas::first&lt; _1 &gt; &gt;, fas::times&lt; fas::second&lt; _1 &gt;, fas::first&lt; _1 &gt; &gt; &gt; &gt;::type result; //  :  (  )   typedef typename fas::second&lt;result&gt;::type type; // int_&lt; I! &gt; enum { value = type::value}; };</span></span></code> </pre><br>    ,           (  ).      ,   game   .    fas::for_    .         ,           ,       fas::int_&lt;-1&gt;,          . ,  : <br><pre> <code class="cpp hljs">fas::type_list&lt; fas::tuple&lt; fas::empty_type, <span class="hljs-comment"><span class="hljs-comment">//   e, //   board //   &gt; &gt;</span></span></code> </pre><br>     ,          ,   ,   .   ,     ,   ‚Äî   . <br><br>        ,        ,  fas::int_&lt;-1&gt; ( )  ,   e ( ): <br><pre> <code class="cpp hljs">fas::and_&lt; fas::not_&lt; fas::same_type&lt; fas::int_&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;, fas::first&lt; last&lt; fas::_1&gt; &gt; &gt; &gt;, fas::same_type&lt; e, fas::second&lt; last&lt; fas::_1&gt; &gt; &gt; &gt;</code> </pre><br>           : <br><pre> <code class="cpp hljs">fas::push_back&lt; game&lt; initial_rand, <span class="hljs-comment"><span class="hljs-comment">// ‚Äú‚Äù  level, //   fas::third&lt; last&lt; fas::_1&gt; &gt; //    // (   ) &gt;, fas::_1 //     &gt;</span></span></code> </pre><br>      ,         (  &lt;&lt;         ): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"show_board.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"tictactoe.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.hpp"</span></span></span><span class="hljs-meta"> int main() { typedef fas::for_</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; fas::type_list&lt; fas::tuple&lt; fas::empty_type, e, board &gt; &gt;, fas::and_&lt; fas::not_&lt; fas::same_type&lt; fas::int_&lt;-1&gt;, fas::first&lt; last&lt; fas::_1&gt; &gt; &gt; &gt;, fas::same_type&lt; e, fas::second&lt; last&lt; fas::_1&gt; &gt; &gt; &gt;, fas::push_back&lt; game&lt; initial_rand, level, fas::third&lt; last&lt; fas::_1&gt; &gt; &gt;, fas::_1 &gt; &gt;::type result_list; typedef fas::tail&lt;result_list&gt;::type game_list; std::cout &lt;&lt; board() &lt;&lt; std::endl; std::cout &lt;&lt; game_list() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br><h4>  Conclusion </h4><br>      -,  ,   .              (     ),     .         ,      ,     .    ,   . <br><br>      ,      .     -   ‚Äî     ,            fas::for_  .     -,  -    - (    -  ). <br><br>       -   .      XP.     ,    (    ),  .   .           , ,      ( ,  ),    <br><pre> <code class="cpp hljs">error: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> instantiation depth exceeds maximum of <span class="hljs-number"><span class="hljs-number">900</span></span></code> </pre><br>     ,   ,           ,     .     ,     (,     ),      ( )  Internal Compiler Error. ,    fas::for_,    -,  board , , fas::empty_type,  128    ( gcc-4.8). <br><br>           ,   fas::type_list_n    .       fas/aop (   - ),          8 .     ,        ,   , ,   . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/228367/">https://habr.com/ru/post/228367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228357/index.html">New free courses virtual academy Microsoft Virtual Academy, July 2014</a></li>
<li><a href="../228359/index.html">How we created a massive accounting service. Experience of the company "Singuru"</a></li>
<li><a href="../228361/index.html">404 post</a></li>
<li><a href="../228363/index.html">My favorite feature of generators</a></li>
<li><a href="../228365/index.html">Android Studio for NDK for Windows</a></li>
<li><a href="../228369/index.html">Simulation of the world and dynamic systems</a></li>
<li><a href="../228371/index.html">Link Doctrine Entity and Doctrine Document on the form in the Sonata Admin Bundle</a></li>
<li><a href="../228373/index.html">The eight queen problem on Oracle SQL (another solution)</a></li>
<li><a href="../228375/index.html">Effective or effective? Master class on creating a site design</a></li>
<li><a href="../228377/index.html">Feature # 3 - Podcast on entrepreneurs and current trends in the IT ecosystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>