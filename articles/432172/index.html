<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dangerous invitation, or How does the combat load to a phishing email</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, PT ESC specialists discovered a Publisher format document entitled ‚ÄúInvitation 29‚Äì30 November 2018.pub‚Äù (1edd5b6a02ec82cec381c1a1ec74a67e). ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dangerous invitation, or How does the combat load to a phishing email</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/hh/mj/f1/hhmjf18rranoihy6liikn8gvlq0.jpeg"><br><br>  Recently, PT ESC specialists discovered a Publisher format document entitled ‚ÄúInvitation 29‚Äì30 November 2018.pub‚Äù (1edd5b6a02ec82cec381c1a1ec74a67e).  In this article we will describe how an ordinary-looking document turns into a trojan, allowing an attacker to capture images from webcams, record sound with a command or when a Skype window is detected, launch PowerShell scripts, take screenshots, copy files from media devices. <a name="habracut"></a><br><br>  So, when you open the document, a window appears with a blurred blank document and a request to enable the Microsoft Publisher script. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/6z/gx/0e/6zgx0evgnzve3k9tdrjtlkqhvhe.png"><br><br>  After the user turns it on, the javascript embedded in the document will be executed.  It looks like this: <br><br><img src="https://habrastorage.org/webt/wt/ig/pt/wtigptknnjdcp4noozibkmcisci.png"><br><br>  The result of the script will be decoding the two files, PDF and EXE, from Base64.  Both files will be written to C: \ Users \ {Username} \ AppData \ Roaming \ DBFUpdate.  Accordingly, both files will be executed, and the user will see such a cap on the document screen: <br><br><img src="https://habrastorage.org/webt/oc/az/v_/ocazv_kws7t4hvkhq4r5jpqw6xi.png"><br><br><h2>  Treasure hunter rat </h2><br>  Attackers use multi-module RAT with a large set of functions, which provides full access to the infected machine. <br><br>  Code features: <br><br><ol><li>  Entirely written in C ++ with a large number of STL constructs that are used internally. </li><li>  The use of the boost library, in particular JSON and Archive. </li><li>  Debugging functions (more details in the section devoted to stager). </li></ol><br><h2>  Main trojan </h2><br>  The main trojan is fixed on the victim's machine and is a platform onto which malicious modules are loaded from C2. <br><br>  First, stager initializes the working directory in which the information collected by the modules, the utilities necessary for the modules to work, etc. will be stored subsequently. <br><br><img src="https://habrastorage.org/webt/_h/qg/ba/_hqgbarp_rsej6ubiv1v8zuy32c.png"><br><br>  Below is the initialization of the paths to create a working directory: <br><br><img src="https://habrastorage.org/webt/78/tg/ot/78tgotzxv4jl_vrucszwktoaef4.png"><br><br>  After the necessary directories have been created, the main trojan collects information about the infected machine and sends it to the monitoring server. <br><br>  The trojan is interested in such data: <br><br><ul><li>  identifier of the OS version on which the main trojan is running; </li><li>  the default interface language; </li><li>  the major version number of the Service Pack OS; </li><li>  computer name and machine identifier (for more information on obtaining a machine identifier, see the section on the network protocol). </li></ul><br>  This is how information about the infected machine is collected: <br><br><img src="https://habrastorage.org/webt/0n/rn/xn/0nrnxnxdov8bp85g6dmlwzzvwzs.png"><br><br>  Next, the main trojan is fixed on the infected machine by modifying the value in the registry at HKCU \ Environment \ UserInitMprLogonScript.  Here you can write the name of the executable file that was allocated during the initialization of the working directory, in this case it is equal to ‚ÄúDCTHOST.exe‚Äù.  This method is <a href="http://www.hexacorn.com/blog/2014/11/14/beyond-good-ol-run-key-part-18/">described in the Hexacorn blog</a> , and was also used by APT28 and the Cobalt group in their ComDLLDroper. <br><br><img src="https://habrastorage.org/webt/j3/tl/0g/j3tl0gm0n3zb3vzxfpps_abdgq0.png"><br><br>  And the last step in the initialization of the main Trojan is to copy the executable file from its current location to the working directory with the same name that was allocated when initializing the working directory. <br><br>  After the main trojan is initialized, preparations are made for receiving commands.  The Core module is added to the list of running modules, which is the main Trojan.  Then the command from the Core module with ID 0 is launched. The implementation of this command in the main module is missing, instead of it is just a stub.  The constructor object of the Core module is presented below. <br><br><img src="https://habrastorage.org/webt/mi/hy/us/mihyuspzzqd5fwesqr1em7jyiqu.png"><br><br>  At the end, two threads are started.  One of the threads starts a timer that wakes up by default every second and tries to request a command from C2. <br><br><img src="https://habrastorage.org/webt/o9/53/um/o953um8yermaycyqre2jugxbzly.png"><br><br>  The second stream loads additional libraries and standard modules.  Libraries, like modules, have an identifier, but, unlike modules, library identifiers are negative, starting at ‚Äì1, growing in the direction of smaller numbers.  Below is a list of libraries loaded from C2. <br><br><img src="https://habrastorage.org/webt/8n/bl/pj/8nblpjayad6etstkkqxvwtaplts.png"><br><br><h2>  Debugging functions of the main trojan </h2><br>  At the very beginning of its work, immediately after initialization, the main Trojan installs an exception handler via SetUnhandledExceptionFilter, which contains an interesting functionality.  When exceptions occur, they fall into a handler that writes the minidump of the application, while also storing information about the exception.  After which it restarts itself.  On the screenshot - the creation of a minidump: <br><br><img src="https://habrastorage.org/webt/1w/sw/3j/1wsw3jy1hd8wpgcvfw0yliwt_yy.png"><br><br><h2>  Network protocol </h2><br>  The exchange between software and C2 takes place using a self-written binary protocol.  Each message is described using BinPackage (the name is taken from RTTI).  Each BinPackage is in its essence a wrapper over std :: vector, which stores the PackageRecord set (the name is coined).  PackageRecord is the minimum unit for data storage. <br><br><pre><code class="bash hljs">struct PackageRecord { _DWORD dataId; _DWORD datatype; _DWORD szData; char[] data; };</code> </pre> <br>  More details about the fields of this structure: <br><br><ul><li>  <b>dataId</b> - indicates the type of record.  Either the entry is a module identifier, or a command identifier, or a payload. </li><li>  <b>szData</b> is the size of the data stored in the record. </li><li>  <b>datatype</b> is a data type. </li></ul><br>  A total of three types of data were recorded: <br><ul><li>  The value ‚Äú0‚Äù means that the data stored in the record must be interpreted as a DWORD. </li><li>  The value ‚Äú1‚Äù - the data stored in the record must be interpreted as an ASCIIZ string. </li><li>  The value ‚Äú2‚Äù - the data stored in the record must be interpreted as encrypted data / raw buffer. </li></ul><br><br>  When BinPackage is sent to the control server, a machine ID is added to it.  The identifier is a GUID of the section from which all special characters are cut.  In the picture - getting the machine ID: <br><br><img src="https://habrastorage.org/webt/iw/kn/le/iwknleyhgrfk7tfu2fxiggdx_7w.png"><br><br>  Before sending, all records stored in the BinPackage are collected sequentially into a single buffer and encrypted.  For encryption, the <a href="">WinAES</a> library is <a href="">used</a> , specifically AES-128-CBC. <br><br>  Using CryptoAPI Windows, two pseudo-random arrays of 16 bytes are generated.  One for IV, the other for the key.  Encryption is performed, and the encrypted data is added back to BinPackage, which contains an encrypted packet and consists of three entries: <br><br><ul><li>  record with ID 0x777 - contains the key used for encryption; </li><li>  record with ID 0x555 - contains IV used for encryption; </li><li>  record with ID 0x999 - contains encrypted data (in general, an entry with that ID indicates the payload and is used not only to store encrypted data). </li></ul><br>  After the end of the encryption process, the generated BinPackage is again collected into a single buffer and sent via an HTTP POST request to the managing server 151.80.237.222. <br><br><img src="https://habrastorage.org/webt/zj/8b/dd/zj8bdd1d7hlb1ozmxarkmmkf60q.png"><br><br>  Below is an example of a package containing information about the machine: <br><br><img src="https://habrastorage.org/webt/ma/gu/du/magudufvut9bwna3qk9g8atebju.png"><br><br>  And this is an example of an encrypted packet with information about the system: <br><br><img src="https://habrastorage.org/webt/tv/rm/0s/tvrm0sniivu5dxahli4lfnsnfwa.png"><br><br><h2>  Modules </h2><br>  Each module, with the exception of Core, is loaded from the control server.  All modules can be divided into two categories - modules that are loaded automatically, and modules that are loaded upon request from the monitoring server. <br><br>  An example of a packet requesting a module: <br><br><img src="https://habrastorage.org/webt/zw/_o/mw/zw_omw8mqjoa74a0gouuylkgnk8.png"><br><br>  Response to module request: <br><br><img src="https://habrastorage.org/webt/9u/2g/qc/9u2gqcvb1mhw4kuky3fl6f1zljq.png"><br><br>  Each module has a simple interface consisting of three functions: called when the module is loaded, Init, called when fini is completed, and a function that changes the module configuration.  Also, each module has an export named GetModule, which builds an object that represents this module and returns it to the main Trojan.  All modules found by us are started in memory by means of reflective loading. <br><br><img src="https://habrastorage.org/webt/p7/rz/qk/p7rzqkvwrfbybtduak7hfttchgy.png"><br><br>  Further, the names of the modules are given in the form in which they appear in RTTI as class names. <br><br><h2>  CCore module </h2><br>  This module represents the basic functionality and is built directly into the main Trojan.  Its constructor can be seen in the table below: <br><table><tbody><tr><th width="100">  Module ID </th><th width="100">  Team ID </th><th>  Description </th></tr><tr><td rowspan="6">  0 </td><td>  0 </td><td>  Most Trojans instead of a command stub, and its exact purpose could not be established </td></tr><tr><td>  one </td><td>  Modify Module Configuration </td></tr><tr><td>  2 </td><td>  Request computer information </td></tr><tr><td>  3 </td><td>  Download the utility from the control server </td></tr><tr><td>  four </td><td>  Request a listing of the directory containing utilities </td></tr><tr><td>  five </td><td>  Load module and execute it. </td></tr></tbody></table><br><h2>  CShell module </h2><br>  This module provides a remote shell to an infected machine.  When the module is initialized, a cmd.exe process is created to which two pipes are attached: one for standard input and one for standard output, through which commands are received and transmitted from the control server and back.  Also at this moment a stream is started, which automatically takes all the output and sends it to the control server.  In the picture - initialization of the Shell module. <br><br><img src="https://habrastorage.org/webt/73/g3/6v/73g36vgr-tbimku5nrr-x1r8l1u.png"><br><table><tbody><tr><th width="100">  Module ID </th><th width="100">  Team ID </th><th>  Description </th></tr><tr><td rowspan="4">  2 </td><td>  0 </td><td>  Send command to shell </td></tr><tr><td>  one </td><td>  Display the file.  The file is read, the path to which is transmitted from the control server, and the contents of this file is uploaded to the control server. </td></tr><tr><td>  2 </td><td>  Get a list of all disks existing in the system.  Data is sent to the control server in JSON format. </td></tr><tr><td>  3 </td><td>  Download the file from the control server.  The path where to save the file, and the data is obtained from the control server </td></tr></tbody></table><br><h2>  CFileSystemBrowser module </h2><br>  This is a passive module that, upon request, allows you to receive information about the file system structure.  This is how the CFileSystemBrowser module is initialized: <br><br><img src="https://habrastorage.org/webt/sm/as/pn/smaspn0xpx9jmukbwfsupllke88.png"><br><table><tbody><tr><th width="100">  Module ID </th><th width="100">  Team ID </th><th>  Description </th></tr><tr><td rowspan="4">  3 </td><td>  0 </td><td>  Get a list of all disks existing in the system.  Data is sent to C2 in JSON format. </td></tr><tr><td>  one </td><td>  Get directory listing.  Listing is formed in JSON format </td></tr><tr><td>  2 </td><td>  Display the file.  A file is being read, the path to which is transmitted from C2, and the contents of this file is downloaded to C2. </td></tr><tr><td>  3 </td><td>  Delete a file.  The path to the file is transmitted from C2 </td></tr></tbody></table><br><h2>  CScreenShot module </h2><br>  This module allows you to create screenshots of the screen or capture images from a webcam.  It can do this both on request and with a certain period by timer. <br><img src="https://habrastorage.org/webt/nw/km/qg/nwkmqgynrgbuywc05kwjrvkq1ye.png"><br><table><tbody><tr><th width="100">  Module ID </th><th width="100">  Team ID </th><th>  Description </th></tr><tr><td rowspan="4">  four </td><td>  0 </td><td>  Take a screenshot and send it to the control server </td></tr><tr><td>  one </td><td>  Start the timer, after triggering which takes a screenshot of the machine.  The resulting screenshots are packaged in BinPackage and saved in the logs folder.  File names are generated using the GetTempFileName API prefixed with ‚ÄúMS_‚Äù. </td></tr><tr><td>  2 </td><td>  Get video of devices available on the infected machine. </td></tr><tr><td>  3 </td><td>  Capture a frame from the webcam and send it to the control server </td></tr></tbody></table><br><h2>  CSender module </h2><br>  This module is initially not activated.  It downloads the contents of the logs folder to the control server.  It is activated when there is a request for a change in the configuration, which contains the verification period. <br><br><img src="https://habrastorage.org/webt/wd/64/0e/wd640e65m5umn66eyqrg1vuwolu.png"><br><br><h2>  CKeylogger module </h2><br>  This module is also not initially activated.  It is activated when there is a request for a configuration change, containing the size of the buffer in which the log is stored.  Interception of input is carried out through <a href="https://eyeofrablog.wordpress.com/2017/06/11/windows-keylogger-part-1-attack-on-user-land/">rawinput</a> .  In addition, the keylogger keeps track of the window in which the user makes input, and logs its title. <br><br><img src="https://habrastorage.org/webt/wu/ek/r6/wuekr6dftcwhuubqmce3h5n49vg.png"><br><br><h2>  CDictaphone module </h2><br>  This module records sound by command or when a Skype window is detected.  When launched, it starts a stream that lists all windows and their child windows in the system and searches among the classes for a window whose class name is TLiveConversation or TCallMonitorControl.  If such a window was found, recording begins.  Below is the initialization of the CDictaphone module: <br><br><img src="https://habrastorage.org/webt/y7/kq/e0/y7kqe0xqb1lytearyqn--ojslpu.png"><br><br>  And Skype window search <br><br><img src="https://habrastorage.org/webt/6j/49/br/6j49brec889qzpw8hqqd0mjo-5g.png"><br><br>  Recording is done through MCI by sending special commands.  This is what the CDictaphone recording cycle looks like: <br><br><img src="https://habrastorage.org/webt/nh/ef/zk/nhefzkr0smgjs0xpnabh9oglqzy.png"><br><br>  After closing the window or receiving a command to complete the recording, the received data is stored in a temporary folder, after which the lame MP3 encoder is encoded (it is considered a utility and should already be loaded, it was not possible to get it from the control server).  The encoded file is saved to the logs folder.  Generating a folder name is similar to generating names for screenshots. <br><table><tbody><tr><th width="100">  Module ID </th><th width="100">  Team ID </th><th>  Description </th></tr><tr><td rowspan="3">  7 </td><td>  0 </td><td>  Start recording and complete it after 15 minutes </td></tr><tr><td>  one </td><td>  Stop recording </td></tr><tr><td>  2 </td><td>  Check status: is recording now? </td></tr></tbody></table><br><h2>  CProcessesManager module </h2><br>  This is a passive module that, upon request, is able to return a list of processes or terminate using the PID transmitted to it. <br><br><img src="https://habrastorage.org/webt/us/if/sf/usifsfffgu9i_sfbbus6xc5_ch4.png"><br><table><tbody><tr><th width="100">  Module ID </th><th width="100">  Team ID </th><th>  Description </th></tr><tr><td rowspan="2">  eight </td><td>  0 </td><td>  Returns a list of processes: their names, PID and the name of the user who owns the process. </td></tr><tr><td>  one </td><td>  Completing the process by PID </td></tr></tbody></table><br><h2>  CDownloader module </h2><br>  The module is designed to upload large files to the control server.  Transfers data by chunks, the size of which is set by its configuration.  The module reads data from the file, the path to which it receives from the control server, and packs the chunks into BinPackage.  For each BinPackage containing a chunk, an entry with the identifier 0x888 is added, including the path to the file.  After the transfer of each chunk, sleep is performed for 5 seconds. <br><img src="https://habrastorage.org/webt/ch/-1/wj/ch-1wjtsdqiwbglodlmf25cp3om.png"><br><table><tbody><tr><th width="100">  Module ID </th><th width="100">  Team ID </th><th>  Description </th></tr><tr><td rowspan="3">  9 </td><td>  0 </td><td>  Stub, exact value could not be set </td></tr><tr><td>  one </td><td>  Transmits a large amount of data (0x500000 bytes), then measures the time spent on the transfer, and sends this value to C2 </td></tr><tr><td>  2 </td><td>  It downloads a file from the machine. </td></tr></tbody></table><br><h2>  CPS module </h2><br>  This module allows you to run PowerShell scripts. <br><br><img src="https://habrastorage.org/webt/ua/nn/vn/uannvn5wtvk7p2jnfaz6exur2ia.png"><br><table><tbody><tr><th width="100">  Module ID </th><th width="100">  Team ID </th><th>  Description </th></tr><tr><td>  ten </td><td>  0 </td><td>  Receives a PowerShell script from C2 and executes it. </td></tr></tbody></table><br><h2>  CDeviceMonitor module </h2><br>  A passive module that monitors connected media devices and copies files from them.  It uses WM_DEVICECHANGE broadcast messages to detect device connectivity.  After connecting the device to the control server, information is sent about when the device was connected, its volume label and the path to the device.  The code used to get the path to the device is very similar to this.  All files are copied to the logs folder.  Names are generated the same as for screenshots.  Separately, the file fsIndex.dat is created, which contains the dictionary serialized with boost :: archive.  This dictionary stores the original paths to the files that were copied, and their MD5 hashes.  Below is getting the DevicePath: <br><br><img src="https://habrastorage.org/webt/3y/k0/ap/3yk0apdk8elf3rhhjqnsako0zne.png"><br><br>  As an epilogue a few recommendations: <br><br><ul><li>  You do not need to open attachments in letters from unknown recipients, let alone include the Microsoft Publisher script. </li><li>  It is equally dangerous to click on the links in the letters of unknown senders.  On the site where you go, malware can be placed, which will automatically download to your PC. </li><li>  It is necessary to regularly update the software, especially Microsoft Windows and Microsoft Office, which will close access to a wide range of malware. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/432172/">https://habr.com/ru/post/432172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432160/index.html">Android Kolesa Mobile video: modular development, backend driven UI and continuous integration</a></li>
<li><a href="../432162/index.html">‚ÄúWe try to give real life stories‚Äù: about the Heisenbug 2018 Moscow program</a></li>
<li><a href="../432166/index.html">Apache NiFi: what it is and a brief overview of the features</a></li>
<li><a href="../432168/index.html">Chinese authorities are collecting information from electric vehicles of citizens of the country</a></li>
<li><a href="../432170/index.html">Carry data center in 14,400 seconds</a></li>
<li><a href="../432174/index.html">How to competently and effectively develop a software product</a></li>
<li><a href="../432176/index.html">How we doubled the speed of working with Float in Mono</a></li>
<li><a href="../432178/index.html">... and a guarantee for projectors - enlarge</a></li>
<li><a href="../432180/index.html">How to pump your career through GitHub</a></li>
<li><a href="../432182/index.html">We take away mail without sms and registration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>