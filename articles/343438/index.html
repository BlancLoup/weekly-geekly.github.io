<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Model-View-Presenter - a compromise and universal recipe</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="MVP abbreviation can be interpreted in different ways, but the article is not about sports. 

 The network has a large number of articles on architect...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Model-View-Presenter - a compromise and universal recipe</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/tv/bx/n3/tvbxn3hmwh75lyg9eentg0cwhui.jpeg" alt="image"><br><br>  MVP abbreviation can be interpreted in different ways, but the article is not about sports. <br><br>  The network has a large number of articles on architectural patterns for iOS and Android developers, and MVP in particular.  Sometimes a pattern is considered in the context of both platforms.  Someone chooses this pattern to improve the testability of their code, someone uses it mainly to separate the presentation code from the model.  Also there are solutions that use MVP to unify the platform code, provided that the developers in the company own these technologies.  But common words and conclusions are sometimes not enough for a pragmatic developer.  When designing commercial applications, inevitably many details arise that the overall architectural concept cannot reveal, and it cannot be said that there is a single canonical solution. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the article I will try to describe the situations that mobile developers often encounter on real projects, and when it is really worth thinking about switching to an architectural pattern more complicated than ‚ÄúOne UIView Controller (Activity) to rule them all‚Äù.  Or better said, when it will be profitable for us.  The following discussion focuses on the trade-off between time and development complexity in the realities of ‚Äúordinary‚Äù projects that mostly come to be assessed and developed. <br><a name="habracut"></a><br><h4>  <font color="#2b2b2b">Introduction</font> </h4><br>  Most mobile projects for native SDKs are now client-server applications.  In turn, such applications can vary greatly in system complexity and lifetime.  There are ‚Äúone-day‚Äù applications for work within one event or an annual holiday, after which nobody needs them.  There are serious projects that require a large percentage of code coverage of tests, to ensure stable operation when changes are made by different team members. <br><br>  What projects are ‚Äúnormal‚Äù can be determined by the following criteria: <br><br><ul><li>  number of screens: 5-20 pieces, or as many screens should be in the first version; </li><li>  The application must be designed for two main mobile platforms: iOS and Android; </li><li>  authorization is present; </li><li>  there is a caching system using, as a rule, a local database; </li><li>  not only GET, but also POST, PUT, DELETE requests are made, and these requests make changes to the cached data downloaded in the previous step; </li><li>  The app will expand. </li></ul><br><h4>  <font color="#2b2b2b">Comparing MVPs with default patterns</font> </h4><br>  Consider the simplest pattern, namely iOS MVC with a passive model, which is essentially a rigid bundle of presentation layers and a model where all the logic is in a UIViewController.  A similar approach is obtained on Android, if you write your leadership projects from video tutorials for beginners or from most training sites. <br><br><img src="https://habrastorage.org/webt/-s/o2/vc/-so2vcupud3ftkd_hyabyifq-dm.png" alt="image" width="350"><br><br>  If we compare it with MVP, the main difference is the class Presenter, in which we bring the logic of event handling, data formatting and the View control.  By View, we mean a layer that includes the child classes UIViewController, Activity or Fragment and their combination with classes of various controls.  Thus, we ‚Äúunload‚Äù classes similar to the UIViewController from those duties that they should not be engaged in, leaving only the initialization code for views and animations inside. <br><br><img src="https://habrastorage.org/webt/9h/0g/yg/9h0gygxyvsrba4ynqwpeyqrzzeu.png" alt="image" width="350"><br><br>  As is often the case, during the development of the first version of the application, additional functionality is added that is associated with insufficient study of the TOR.  Sometimes the changes are so radical that you have to rewrite most of the work already done.  The most common situation when asked to add an additional field to the entity and display the formatted information.  Let us see which classes we change in the project when adding a new UI element that displays a formatted date: <br><br><ul><li>  using MVC with a passive model: </li></ul><br><img src="https://habrastorage.org/webt/gq/u1/aj/gqu1ajddq-lnakbat1c_1m69q0o.png" alt="image" width="600"><br><br><ul><li>  using MVP: </li></ul><br><img src="https://habrastorage.org/webt/it/og/8z/itog8ztzck7lbvzzj52jyo9zzrq.png" alt="image" width="600"><br><br>  Obviously, we have complicated the system by introducing the MVP pattern, since the number of classes that have undergone a change by simply adding a new property of the entity has increased.  Separately, it is worth noting that, when implementing MVP, they create a separate interface for View and try to make sure that Presenter has as little code as possible associated with the platform and there are no direct links to specific heirs of UIViewController, Activity or Fragment, because the temptation is to write the presentation code directly to the Presenter. <br><br>  For small and weakly subject to change projects, the approach without a clear separation of the presentation from the logic business is, in my opinion, the best approach, since it significantly reduces development time.  A small project is usually written by one person, and the amount of code is not difficult for another team member to figure out the task in a few hours and make changes if required. <br><br><h4>  <font color="#2b2b2b">In search of a compromise</font> </h4><br>  A logical question arises, why complicate things? <br><br>  First, in order to clearly distribute the responsibility between the classes.  This is especially true if you are a member of the development team.  It is important to understand that no programmer thinks the same.  For example, the date formatting code from the example may end up both in the table cell and in the controller, as well as in the code of the class responsible for mapping data received from the server. <br><br>  In addition to formatting, there are quite a few such details in your project.  You can give a more complex example of displaying in the list item a composite view model that is collected in parts from cached data.  We transfer all the work on formatting and preparing the model for presentation to Presenter, so there is no ambiguity in where to format the data. <br><br><img src="https://habrastorage.org/webt/ss/d_/gn/ssd_gnaogepw21bunzhuycrlv44.png" alt="image" width="600"><br><br>  Do not confuse the presentation model in this article with the ViewModel from MVVM, the name only indicates the entity storing the formatted and ready to be shown in the View information. <br><br>  When using the usual approach, we would most likely place the model code for the cell in the heir of the UIViewController or Activity (Fragment), which resulted in an increase in the code in the class, in which there is a lot of work related to the presentation. <br><br>  Writing ‚Äúuseful‚Äù integration tests also becomes possible with the introduction of MVP, where the main object of testing is Presenter.  Of course, using only unit testing, you can test the components used in the application, which are God-objects and the heirs of UIViewController or Activity (Fragment), but this will not be quite effective. <br><br>  Consider the moment associated with the expansion of the project.  Additional features on the project may not come immediately after the release of the first version, so it is important that developers adopt conventions on how to write code.  MVP in this case is a set of rules that can be clearly described in the following diagram: <br><br><img src="https://habrastorage.org/webt/7x/c2/bu/7xc2buizqfhc26qj0eyvsgz8iw0.png" alt="image" width="600"><br><br>  Small adjustments to the chart: <br><br><ol><li>  For Android, it is not relevant to store the reference to Presenter directly in the Activity, so in practice we use Retained Fragment and base classes for the Activity and the usual Fragment, which describe the logic of initialization and retrieval of the already created Presenter. <br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasePresenterActivity</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasePresenter</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PRESENTER_FRAGMENT_TAG = <span class="hljs-string"><span class="hljs-string">"presenter_fragment_tag"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> P mPresenter; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); getPresenter().bindView(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinishing()) { PresenterFragment presenterFragment = (PresenterFragment) getSupportFragmentManager() .findFragmentByTag(PRESENTER_FRAGMENT_TAG); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (presenterFragment != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { getSupportFragmentManager().beginTransaction().remove(presenterFragment).commit(); } } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isFinishing() &amp;&amp; mPresenter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { mPresenter.unbindView(); } <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPresenter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPresenter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mPresenter; } PresenterFragment fragment = getPresenterFragment(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragment.isPresenterSet()) { mPresenter = fragment.getPresenter(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mPresenter = createPresenter(); fragment.setPresenter(mPresenter); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mPresenter; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPresenter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PresenterFragment </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPresenterFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PresenterFragment presenterFragment = (PresenterFragment) getSupportFragmentManager() .findFragmentByTag(PRESENTER_FRAGMENT_TAG); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (presenterFragment == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { presenterFragment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PresenterFragment(); getSupportFragmentManager() .beginTransaction() .add(presenterFragment, PRESENTER_FRAGMENT_TAG) .commit(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> presenterFragment; } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PresenterFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fragment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BasePresenter mPresenter; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;P extends BasePresenter&gt; <span class="hljs-function"><span class="hljs-function">P </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPresenter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (P) mPresenter; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;P extends BasePresenter&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPresenter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(P presenter)</span></span></span><span class="hljs-function"> </span></span>{ mPresenter = presenter; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPresenterSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mPresenter != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasePresenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> V mView; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(V view)</span></span></span><span class="hljs-function"> </span></span>{ mView = view; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unbindView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mView = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre><br></div></div></li><li>  Interfaces are introduced only for View and Service for integration testing of Presenter logic.  In order to create truly effective tests, Presenter must be aware of all the events generated by the View, and View should not respond to them, even if the event handler contains only one method call. </li><li>  Earlier in the article, the class EntityToViewModelFormatter was not mentioned.  Its introduction is due to the fact that on different screens you may need information from the same entities, which is formatted in the same or similar way.  Obviously, this class is optional and is used only where it is needed. </li></ol><br>  Using MVP, we can also divide the development of one screen into several people.  At least the View and Presenter bundle is well separated from the Model.  Typically, developers associate Model with an entity in MV * patterns.  I am more impressed by the attitude to the model layer as a data service, which Presenter uses to receive and update information.  We use the service as a facade and combine requests to the API, into a database and application settings. <br><br>  This reveals the only drawback of the described MVP variation, namely that the service grows within the same class file.  If in iOS we can use categories and extensions to separate one large class-service, then in Java it is necessary to split the service into classes of sub-services to work with a specific screen. <br><br><div class="spoiler">  <b class="spoiler_title">Diagram of splitting a service into several sub-services for Android</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hq/gt/as/hqgtasowicx_kc7kqiey0_fee4k.png" alt="image"><br></div></div><br>  If you have no more than 20-25 API methods, then the code remains readable within a single file, provided that it is correctly formatted and commented.  For the first version of the product, you can describe all the logic for receiving and sending data within the same class.  But do not get carried away, as technical debt will increase over time. <br><br>  Since the presentation can be separated from the model, it will not be difficult for you to show your work to the customer, even if with static data, in case the backend is not yet ready or is unstable.  Fortunately, there are many ways to lock the server part.  If an independent team is involved in the backend, if you have agreed documentation, you can be more or less sure that when this service appears, it will not surprise you which fields are sent to the API, and you will have time to debug the part related to formatting data for the presentation. <br><br>  Without documentation, I would still stop the development at the stage of creating the design of the screens and the output of test data based on the presentation models.  In this case, you will also get a less functional interface suitable for a demo, but most importantly you will not spend a lot of time changing entities to fit them under a real API, as Presenter acts as an adapter in which data from the service will be converted to formatted view model data. <br><br><h4>  <font color="#2b2b2b">Versatility</font> </h4><br>  Another advantage of using the MVP pattern is its versatility for iOS and Android.  If you have a large number of projects being developed for both platforms, then the Presenter logic will be universal, and if application development takes place in turn, the adaptation on the other platform will be faster and more predictable, since the logic code in Presenter is almost the same.  Moreover, at the stage of starting work on adaptation for another platform, ready-made test cases will already be available.  Of course, if you bother to spend time and write them. <br><br>  The next advantage of using the MVP pattern is the division of developer resources for different platforms.  For example, iOS signor can write part of the code under Android at the junior or middle level and be useful in this case so that he does not have to redo everything.  I myself am not a supporter of ‚Äúuniversal soldiers‚Äù, since it is better to know one technology well than several at the junior or middle level.  I haven‚Äôt come across practicing senior developers (not timblids or technical directors) for both platforms, but I won‚Äôt argue that such professionals exist.  The main reason for the shortage of such people, in my opinion, is that nowadays it is very difficult to keep track of the development of both technologies.  Even if iOS and Android borrow some designs from each other, the implementation is still different under the hood.  But for small teams and ‚Äúnormal‚Äù projects, the approach using a non-core developer is quite adequate.  Many iOS programmers would like to try their hand at Android and vice versa.  You can give this ‚Äúlegionary‚Äù a write part of the code associated with the Model or Presenter.  It would also be nice if a person could write a simple UI.  But tasks with complex UI elements with animation, optimization, profiling and multithreading, with the exception of service API calls, of course, have to be solved by an already more experienced specialized developer. <br><br>  An interesting case is when testers find a bug on two platforms at once.  It turns out that if the bug is in logic, then the task can not be divided into several developers, but given to repair one person.  At the same time, he will not have much time to understand the logic of different platforms, since they use the same architectural solutions. <br><br><h4>  <font color="#2b2b2b">Comparison with other famous architectural patterns</font> </h4><br>  There is another very important question: why was MVP chosen as the basis, and not patterns based on pure architecture or MVVM?  At the beginning of the article we tried to concentrate on what we are dealing with ‚Äúordinary‚Äù projects, which we would like to write quickly, but with proper quality and the possibility of long-term support. <br><br>  Pure architecture will suit large teams that have experienced programmers on their staff for a specific platform, simply because the code has to be written many times more than in MVP, and this code needs to be properly positioned in a specific module. <br><br>  In MVVM, we have to rebuild the logic of thinking on the declarative.  MVVM is also often associated with Rx * libraries, which programmers should be familiar with, and this immediately puts a limit when searching for a new developer, or you consciously spend time learning it.  In this regard, MVP is more transparent and has less restrictions on developer skills. <br><br><h4>  <font color="#2b2b2b">findings</font> </h4><br>  We turn to the conclusions.  The advantages that we were able to identify for the MVP pattern, if we look at it from the side of the benefits of implementation in the development: <br><br><ol><li>  The present separation of the presentation logic from the model, in contrast, for example, from Apple MVC; </li><li>  A clear division of responsibility between classes: <br><ul><li>  View - drawing, animations, transitions between screens; </li><li>  Presenter - formatting, reaction to events, presentation logic and View control; </li><li>  Model - working with loading data by API, extracting data from the database and caching it; </li></ul></li><li>  Almost universal implementation of Model-View-Presenter interfaces on mobile platforms for ‚Äúordinary‚Äù projects; </li><li>  Presenter integration testing; </li><li>  Separation of tasks in a team as part of developing a single screen into presentation tasks (along with the Presenter) and models; </li><li>  The ability to display an interactive demo to the customer, without a working backend.  When a real service appears, we don‚Äôt throw out all the code that we wrote, but adapt the API; </li><li>  The ability to effectively attract non-core developers from the team to write code on another platform; </li><li>  Expansion and addition of new features will not cause the effect of ‚Äúsomeone else's code‚Äù when a person returns to the project development after a long break due to a set of simple rules for placing code in strictly defined modules. </li></ol><br>  The disadvantages include not so fast development speed as when using Apple MVC or a similar approach for Android.  Also in the concretely presented variation of MVP there was deliberately an emphasis on one common class-service due to simplicity, but this would require some techniques for its separation. <br><br>  Summing up, we can say the following: if you have a small team of experts ready for implementation of projects for the main mobile platforms, you need universal architectural rules, as well as the possibility of parallelizing tasks within the screen and the need to show a demo to a customer with partially working functionality, if sprints are practiced, then MVP is definitely your choice.  An additional bonus is the convenient support for the project, which should not lead to the phrase ‚Äúbut if we had written everything again‚Äù and situations where more than to spend time sorting out the code of one huge UIViewController or Activity the feature itself. </div><p>Source: <a href="https://habr.com/ru/post/343438/">https://habr.com/ru/post/343438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343418/index.html">We invite you to the exhibition-conference on the gaming industry on December 9 at VSBI</a></li>
<li><a href="../343420/index.html">Analysis of Cisco CDR and Microsoft Exchange Server Logs with Splunk</a></li>
<li><a href="../343430/index.html">To box or not to box? That is the question</a></li>
<li><a href="../343432/index.html">Tutorial: create a simple application for watchOS 4</a></li>
<li><a href="../343434/index.html">10 Things Newbie Android Developers Face</a></li>
<li><a href="../343440/index.html">Definitions Axioms</a></li>
<li><a href="../343442/index.html">Developing a web designer tool based on a web application (Figma). Transfer</a></li>
<li><a href="../343444/index.html">Ecowaterair - another scam or something worse? Smells like burnt</a></li>
<li><a href="../343446/index.html">In a section: the news aggregator on Android with backend. Android Development: Architecture Development</a></li>
<li><a href="../343448/index.html">Does CDROM have a long time?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>