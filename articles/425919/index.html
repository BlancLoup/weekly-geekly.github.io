<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hexagon maps in Unity: save and load, textures, distances</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parts 1-3: mesh, cell colors and heights 

 Parts 4-7: bumps, rivers and roads 

 Parts 8-11: water, landforms and walls 

 Parts 12-15: saving and lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hexagon maps in Unity: save and load, textures, distances</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habr.com/post/424257/">Parts 1-3: mesh, cell colors and heights</a> <br><br>  <a href="https://habr.com/post/424491/">Parts 4-7: bumps, rivers and roads</a> <br><br>  <a href="https://habr.com/post/425463/">Parts 8-11: water, landforms and walls</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habr.com/post/425919/">Parts 12-15: saving and loading, textures, distances</a> <br><br>  <a href="https://habr.com/post/426481/">Parts 16-19: Pathfinding, Player Squads, Animations</a> <br><br>  <a href="https://habr.com/post/427003/">Parts 20-23: fog of war, map exploration, procedural generation</a> <br><br>  <a href="https://habr.com/post/427567/">Parts 24-27: water cycle, erosion, biomes, cylindrical map</a> <br><br><h1>  Part 12: Save and Load </h1><br><ul><li>  We track the type of relief instead of color. </li><li>  Create a file. </li><li>  Write the data to a file, and then read it. </li><li>  Serialize these cells. </li><li>  Reduce the file size. </li></ul><br>  We already know how to create quite interesting maps.  Now you need to learn how to save them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i>Loaded from <a href="">test.map</a> file.</i> <br><br><h2>  Relief type </h2><br>  When you save the map, we do not need to store all the data that we track during the execution of the application.  For example, we only need to memorize the height of the cell.  Its very vertical position is taken from this data, so it is not necessary to store it.  In fact, it is better if we do not store these calculated metrics.  This way the map data will remain correct, even if we later decide to change the height offset.  The data is separated from their presentation. <br><br>  Similarly, we do not need to store the exact color of the cell.  You can write that the cell is green.  But the exact shade of green can change when you change the visual style.  For this, we can save the color index, not the colors themselves.  In fact, it may be enough for us to store this index in the cells instead of real colors even at run time.  This will allow later to move to a more complex visualization of the relief. <br><br><h3>  Moving an array of colors </h3><br>  If the cells no longer have color data, then it should be stored somewhere else.  The most convenient way to store it in <code>HexMetrics</code> .  So let's add an array of colors to it. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br>  Like all other global data, such as noise, we can initialize these colors with a <code>HexGrid</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br>  And since now we do not assign colors directly to the cells, we will get rid of the default color. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; ‚Ä¶ void CreateCell (int x, int z, int i) { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; ‚Ä¶ }</span></span></code> </pre> <br>  Adjust the new colors to match the common array of the hexagon map editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>Colors added to the grid.</i> <br><br><h3>  Refactoring cells </h3><br>  Remove the color field from <code>HexCell</code> .  Instead, we will store the index.  And instead of the color index, we use a more general relief type index. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  The color property can use this index only to get the corresponding color.  It is no longer specified directly, so we will remove this part.  In this case, we get a compilation error, which we will fix soon. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // ‚Ä¶ // } }</span></span></code> </pre> <br>  Add a new property to get and set a new index of the relief type. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3>  Editor refactoring </h3><br>  Inside <code>HexMapEditor</code> remove all code related to colors.  This will fix the compilation error. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ // Color activeColor; ‚Ä¶ // bool applyColor; ‚Ä¶ // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } ‚Ä¶ // void Awake () { // SelectColor(0); // } ‚Ä¶ void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } ‚Ä¶ } }</span></span></code> </pre> <br>  Now we add a field and a method for managing the active index of the relief type. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br>  We use this method as a replacement for the now missing <code>SelectColor</code> method.  Connect the color widgets in the UI with <code>SetTerrainTypeIndex</code> , leaving everything else unchanged.  This means that a negative index is still in use and indicates that the color should not change. <br><br>  <code>EditCell</code> so that the relief type index is assigned to the cell being edited. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } ‚Ä¶ } }</code> </pre> <br>  Although we removed the given colors from the cells, the map should work the same way as before.  The only difference is that the default color is now first in the array.  In my case it is yellow. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>Yellow is the new default color.</i> <br><br>  <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-12/terrain-type/terrain-type.unitypackage" rel="nofollow">unitypackage</a> <br><br><h2>  Saving data in a file </h2><br>  To manage the saving and loading of the map, we use <code>HexMapEditor</code> .  We will create two methods that will deal with this, and for the time being we will leave them empty. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Add two buttons to the UI ( <em>GameObject / UI / Button</em> ).  Connect them to the buttons and give the appropriate labels.  I put them in the bottom of the right pane. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>Save and Load buttons.</i> <br><br><h3>  File location </h3><br>  To store the card you need to save it somewhere.  As done in most games, we will store the data in a file.  But where in the file system to put this file?  The answer depends on which operating system the game is running on.  Each OS has its own standards for storing files related to applications. <br><br>  We do not need to know these standards.  Unity knows the proper path we can get using the <code>Application.persistentDataPath</code> .  You can check how it will be with you in the <code>Save</code> method by outputting it to the console and pressing the button in the Play mode. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br>  On desktop systems, the path will contain the name of the company and product.  This path is used and the editor, and assembly.  Names can be configured in <em>Edit / Project Settings / Player</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>Name of company and product.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Why can't I find the Library folder on a Mac?</b> <div class="spoiler_text">  <em>Library</em> folder is often hidden.  The way in which it can be displayed depends on the version of OS X. If you are not old, select the home folder in Finder and go to <em>Show View Options</em> .  There is a checkbox for the <em>Library</em> folder. </div></div><br><div class="spoiler">  <b class="spoiler_title">What about webgl?</b> <div class="spoiler_text">  WebGL games cannot access the user's file system.  Instead, all file operations are redirected to the in-memory file system.  It is transparent to us.  However, in order to save the data, you will need to manually order a web page to reset the data in the browser storage. </div></div><br><h3>  File creation </h3><br>  To create a file, we need to use classes from the <code>System.IO</code> namespace.  Therefore, we add a <code>using</code> statement for it over the <code>HexMapEditor</code> class. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br>  First we need to create the full path to the file.  We use <em>test.map</em> as the file <em>name</em> .  It must be added to the stored data path.  Whether to insert a slash or backslash (slash or backslash) depends on the platform.  This will deal with the <code>Path.Combine</code> method. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br>  Next we need to access the file at this location.  We do this using the <code>File.Open</code> method.  Since we want to write data to this file, we need to use its create mode.  At the same time, at the specified path, either a new file will be created, or an existing file will be replaced. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br>  The result of calling this method will be an open data stream associated with this file.  We can use it to write data to a file.  And we need to remember to close the stream when we no longer need it. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br>  At this stage, when you click the <em>Save</em> button, a <em>test.map</em> file will be created in the folder specified as the path to the stored data.  If you examine this file, it will be empty and have a size of 0 bytes, because so far we have not recorded anything in it. <br><br><h3>  Write to file </h3><br>  To write data to a file, we need a way to stream data to it.  This is easiest to do with <code>BinaryWriter</code> .  These objects allow you to write primitive data to any stream. <br><br>  Create a new <code>BinaryWriter</code> object, and its argument will be our file stream.  Closing the writer closes the stream that it uses.  Therefore, we no longer need to store a direct link to the stream. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br>  To transfer data to a stream, we can use the <code>BinaryWriter.Write</code> method.  There is a variant of the <code>Write</code> method for all primitive types, such as integer and float.  It can also write strings.  Let's try write integer 123. <br><br><pre> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br>  Press the <em>Save</em> button and examine <em>test.map</em> again.  Now its size is 4 bytes, because the size of the integer is 4 bytes. <br><br><div class="spoiler">  <b class="spoiler_title">Why does my file manager show that the file takes up more space?</b> <div class="spoiler_text">  Because file systems divide space into blocks of bytes.  They do not track individual bytes.  Since <em>test.map</em> occupies only four bytes so far, it requires one block of storage space. </div></div><br>  Notice that we store binary data, not human readable text.  Therefore, if we open the file in a text editor, we will see a set of vague characters.  You will probably see the <em>{</em> character, for which there is nothing or there are several placeholders. <br><br>  You can open the file in a hex editor.  In this case, we will see <em>7b 00 00 00</em> .  These are four bytes of our integer, displayed in hexadecimal notation.  In ordinary decimal numbers this is <em>123 0 0 0</em> .  In binary notation, the first byte looks like <em>01111011</em> . <br><br>  The ASCII code for <em>{</em> equals 123, so this symbol can be displayed in a text editor.  ASCII 0 is a null character that does not match any visible characters. <br><br>  The remaining three bytes are zero, because we wrote down a number less than 256. If we recorded 256, then we would see <em>00 01 00 00</em> in the hex editor. <br><br><div class="spoiler">  <b class="spoiler_title">Should not 123 be stored as 00 00 00 7b?</b> <div class="spoiler_text">  <code>BinaryWriter</code> uses little-endian format to save numbers.  This means that the least significant bytes are written first.  This format has been used by Microsoft in developing the .Net framework.  It was probably chosen because little-endian format is used in Intel CPUs. <br><br>  The alternative to it is big-endian, in which the most significant bytes are stored first.  This corresponds to the usual order of numbers in numbers.  123 is a hundred and twenty-three, because we mean big-endian.  If it were little-endian, then 123 would mean three hundred and twenty-one. </div></div><br><h3>  Make it so that resources are released. </h3><br>  It is important that we close the writer.  While it is open, the file system locks the file, preventing other processes from writing to it.  If we forget to close it, then we block ourselves too.  If we press the save button twice, then the second time we will not be able to open the stream. <br><br>  Instead of closing the writer manually, we can create a <code>using</code> block for this.  It defines the scope within which the writer is valid.  When executable code goes beyond this scope, the writer is deleted and the stream is closed. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br>  This will work because the writer and file stream classes implement the <code>IDisposable</code> interface.  These objects have a <code>Dispose</code> method, which is indirectly called when going outside the scope of <code>using</code> . <br><br>  The big advantage of <code>using</code> is that it works no matter how the execution of the program goes out of scope.  Early returns, exceptions and errors do not interfere with it.  In addition, it is very concise. <br><br><h3>  Data acquisition </h3><br>  To read previously recorded data, we need to insert the code into the <code>Load</code> method.  As with saving, we need to create a path and open the file stream.  The difference is that now we open the file for reading, not for writing.  And instead of writer, we will need a <code>BinaryReader</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br>  In this case, we can use the <code>File.OpenRead</code> method to open the file to read it. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Why we can not use when writing File.OpenWrite?</b> <div class="spoiler_text">  This method creates a stream that adds data to existing files, rather than replacing them. </div></div><br>  When reading, we need to explicitly specify the type of data received.  To read from the integer stream, we need to use <code>BinaryReader.ReadInt32</code> .  This method reads a 32-bit integer, that is, four bytes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br>  It is necessary to consider that when receiving <em>123</em> it will be enough for us to count one byte.  But at the same time in the stream will remain three bytes belonging to this integer.  In addition, it does not work for numbers outside the range of 0‚Äì255.  So do not do this. <br><br>  <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-12/storing-data-a-file/storing-data-in-a-file.unitypackage" rel="nofollow">unitypackage</a> <br><br><h2>  Write and read card data </h2><br>  When saving data, the important question is whether to use a human-readable format.  Usually, JSON, XML and simple ASCII with some kind of structure are used as human-readable formats.  Such files can be opened, interpreted and edited in text editors.  In addition, they simplify the exchange of data between different applications. <br><br>  However, such formats have their own requirements.  Files will take up more space (sometimes much more) than when using binary data.  They can also greatly increase the cost of encoding and decoding data, in terms of both runtime and memory usage. <br><br>  In contrast, binary data is compact and fast.  This is important when writing large amounts of data.  For example, when autosaving a large card in each course of the game.  therefore <br>  we will use binary format.  If you can handle it, you can work with more detailed formats. <br><br><div class="spoiler">  <b class="spoiler_title">What about automatic serialization?</b> <div class="spoiler_text">  Immediately during the serialization of Unity data, we can directly write serialized classes to the stream.  Details of the recording of individual fields will be hidden from us.  However, we cannot serialize the cells directly.  They are <code>MonoBehaviour</code> classes that have data that we do not need to save.  Therefore, we need to use a separate hierarchy of objects, which eliminates the simplicity of automatic serialization.  In addition, it will be more difficult to maintain future code changes.  Therefore, we will adhere to full control through manual serialization.  In addition, it will make us really understand what is happening. </div></div><br>  To serialize the map, we need to store the data of each cell.  To save and load a single cell, add the <code>Save</code> and <code>Load</code> methods to <code>HexCell</code> .  Since they need a writer or reader to work, we add them as parameters. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  Add <code>Save</code> and <code>Load</code> methods to <code>HexGrid</code> .  These methods simply bypass all the cells by calling their <code>Load</code> and <code>Save</code> methods. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br>  If we load a map, it needs to be updated after the cell data has been changed.  To do this, just update all the fragments. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br>  Finally, we replace our test code in <code>HexMapEditor</code> with calls to the <code>Save</code> and <code>Load</code> methods of the grid, passing with them a writer or reader. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3>  Saving terrain type </h3><br>  At the current stage, re-saving creates an empty file, and the download does nothing.  Let's start gradually, by recording and loading only the <code>HexCell</code> type relief <code>HexCell</code> . <br><br>  Directly assign the value to the <code>terrainTypeIndex</code> field.  We will not use properties.  Since we are explicitly updating all fragments, the <code>Refresh</code> property calls are not needed.  In addition, since we only keep the correct maps, we will assume that all the maps that are loaded are also correct.  Therefore, for example, we will not check whether the river or the road is permissible. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br>  When saving to this file one after another, the index of the type of relief of all cells will be recorded.  Since the index is an integer, its size is equal to four bytes.  My map contains 300 cells, that is, the file size will be 1200 bytes. <br><br>  The download reads the indexes in the order in which they are written.  If you changed the colors of the cells after saving, loading the map will return the colors to the state when they were saved.  Since we do not save anything else, the remaining cell data will remain the same.  That is, the load will change the type of relief, but not its height, water level, relief objects, etc. <br><br><h3>  Saving All Integer </h3><br>  Preserving the relief type index is not enough for us.  It is necessary to save and all other data.  Let's start with all the fields integer.  These are terrain type index, cell height, water level, city level, farm level, vegetation level, and index of particular objects.  They will need to be read in the same order in which they were recorded. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br>  Now try saving and loading the map, making changes between these operations.  Everything that we included in the stored data was restored as much as we can, except for the height of the cell.  This happened because when you change the height level, you need to update the vertical position of the cell.  This can be done by assigning it to the property, and not the field, the value of the loaded height.  But this property does extra work that we don‚Äôt need.  So let's extract the code that updates the position of the cell from the <code>Elevation</code> setter and insert it into a separate <code>RefreshPosition</code> method.  The only change that needs to be made here is to replace <code>value</code> reference to the <code>elevation</code> field. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br>  Now we can call the method when setting the property, as well as after loading the height data. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); ‚Ä¶ } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); ‚Ä¶ }</code> </pre> <br>  After this change, the cells will correctly change their apparent height when loading. <br><br><h3>  Saving all data </h3><br>  The presence in the cell walls and incoming / outgoing rivers is stored in Boolean fields.  We can write them simply as integer.  In addition, road data is an array of six boolean values ‚Äã‚Äãthat we can write using a loop. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br>  Directions of incoming and outgoing rivers are stored in the fields <code>HexDirection</code> .  The <code>HexDirection</code> type is an enumeration that is internally stored as several integer values.  Therefore, we can serialize them too as an integer using an explicit conversion. <br><br><pre> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br>  Boolean values ‚Äã‚Äãare read using the <code>BinaryReader.ReadBoolean</code> method.  River directions are integer, which we need to convert back to <code>HexDirection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br>  Now we save all the data cells, which are necessary for the complete preservation and restoration of the card.  This requires nine integers and nine booleans per cell.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each boolean value is one byte, so we use a total of 45 bytes per cell. </font><font style="vertical-align: inherit;">That is, a card with 300 cells requires a total of 13,500 bytes. </font></font><br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-12/writing-and-reading-map-data/writing-and-reading-map-data.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduce file size </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although it seems that 13,500 bytes is not very much for 300 cells, perhaps we can get along with less. </font><font style="vertical-align: inherit;">In the end, we have complete control over how data is serialized. </font><font style="vertical-align: inherit;">Let's see, maybe there is a more compact way to store them.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Decrease in numeric interval </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different levels and cell indices are stored as integer. </font><font style="vertical-align: inherit;">However, they use only a small range of values. </font><font style="vertical-align: inherit;">Each of them will definitely stay in the range of 0‚Äì255. </font><font style="vertical-align: inherit;">This means that only the first byte of each integer will be used. </font><font style="vertical-align: inherit;">The remaining three will always be zero. </font><font style="vertical-align: inherit;">There is no point in storing these empty bytes. </font><font style="vertical-align: inherit;">We can drop them by converting an integer to byte before writing to a stream.</font></font><br><br><pre> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, to return these numbers, we have to use </font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The conversion from byte to integer is implicit, so we don‚Äôt need to add explicit conversions.</font></font><br><br><pre> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we get rid of three bytes on integer, which gives a saving of 27 bytes per cell. Now we spend 18 bytes per cell, and only 5,400 bytes per 300 cells. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that the old map data becomes meaningless at this stage. When the old save is loaded, the data is mixed up and we get messed up cells. This is because now we read less data. If we read more data than before, we would get an error when trying to read beyond the end of the file.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The impossibility of processing old data suits us, because we are in the process of defining the format. </font><font style="vertical-align: inherit;">But when we decide on the format of the save, we will need to ensure that future code can always read it. </font><font style="vertical-align: inherit;">Even if we change the format, then ideally we should still be able to read the old format.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Byte Consolidation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, we use four bytes for storing the data of rivers, two for each direction. </font><font style="vertical-align: inherit;">For each direction we keep the presence of the river and the direction in which it flows </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems obvious that we do not need to keep the direction of the river if it is not there. </font><font style="vertical-align: inherit;">This means that cells without a river need two bytes less. </font><font style="vertical-align: inherit;">In fact, it will be enough for us one byte per direction of the river, regardless of its existence.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have six possible directions that are stored as numbers in the range of 0‚Äì5. </font><font style="vertical-align: inherit;">For this, it suffices to use binary bits, because in binary form, numbers from 0 to 5 look like 000, 001, 010, 011, 100, 101 and 110. That is, five more bits remain unused in one byte. </font><font style="vertical-align: inherit;">We can use one of them to indicate whether a river exists. </font><font style="vertical-align: inherit;">For example, you can use the eighth bit corresponding to the number 128. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, we will add 128 to it before converting the direction to byte. That is, if we have a river flowing to the north-west, we will write 133, which is equal to 10000101 in binary form. And if there is no river, we will simply write zero byte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, we still have four unused bits, but this is normal. </font><font style="vertical-align: inherit;">We can combine both directions of the river into one byte, but this will be too confusing.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To decode river data, we first need to count back bytes. </font><font style="vertical-align: inherit;">If its value is not less than 128, then this means that there is a river. </font><font style="vertical-align: inherit;">To get its direction, subtract 128, and then convert to </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we got 16 bytes per cell. </font><font style="vertical-align: inherit;">The improvement seems to be not great, but it is one of those tricks that are used to reduce the size of binary data.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saving roads in one byte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can use a similar trick to compress road data. </font><font style="vertical-align: inherit;">We have six boolean values ‚Äã‚Äãthat can be stored in the first six bits of a byte. </font><font style="vertical-align: inherit;">That is, each direction of the road is represented by a number that is a power of two. </font><font style="vertical-align: inherit;">These are 1, 2, 4, 8, 16 and 32, or in binary form 1, 10, 100, 1000, 10000 and 100000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a finished byte, we need to set the bits corresponding to the used directions of the roads. </font><font style="vertical-align: inherit;">We can use the operator to get the right direction for the direction </font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then combine them using the bitwise OR operator. </font><font style="vertical-align: inherit;">For example, if the first, second, third and sixth roads are used, then the finished byte will be 100111.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does &lt;&lt; work?</font></font></b> <div class="spoiler_text">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To get the boolean value of the road back, you need to check if the bit is set. </font><font style="vertical-align: inherit;">If so, then mask all other bits using the bitwise AND operator with the corresponding number. </font><font style="vertical-align: inherit;">If the result is not zero, then the bit is set and the road exists.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Squeezing six bytes into one, we got 11 bytes per cell. </font><font style="vertical-align: inherit;">At 300 cells, this is only 3,300 bytes. </font><font style="vertical-align: inherit;">That is, having worked a little with the bytes, we reduced the file size by 75%.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preparing for the future </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before declaring our save format complete, add one more detail. </font><font style="vertical-align: inherit;">Before saving the card data, make the </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">record an integer zero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will add four empty bytes to the beginning of our data. </font><font style="vertical-align: inherit;">That is, before loading the card we will have to read these four bytes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although these bytes are useless for the time being, they are used as a header that will ensure backward compatibility in the future. </font><font style="vertical-align: inherit;">If we had not added these zero bytes, the contents of the first few bytes depended on the first cell of the map. </font><font style="vertical-align: inherit;">Therefore, in the future it would be more difficult for us to figure out which version of the preservation format we are dealing with. </font><font style="vertical-align: inherit;">Now we can just check the first four bytes. </font><font style="vertical-align: inherit;">If they are empty, then we are dealing with the version of format 0. In future versions, it will be possible to add something else to it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, if the header is non-zero, we are dealing with some unknown version. </font><font style="vertical-align: inherit;">Since we cannot find out what data is there, we must refuse to load the map.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-12/smaller-file-size/smaller-file-size.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 13: Card Management </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create new maps in Play mode. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add support for various card sizes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add the size of the map to the saved data. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Save and load arbitrary maps. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Display a list of maps. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part we will add support for various map sizes, as well as saving different files. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting from this part, tutorials will be created in Unity 5.5.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library of maps.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating new maps </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point, the grid of hexagons, we created only once - when loading the scene. </font><font style="vertical-align: inherit;">Now we will make it possible to start a new card at any time. </font><font style="vertical-align: inherit;">A new card will simply replace the current one. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Awake </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, some metrics are initialized, then the number of cells is determined and the necessary fragments and cells are created. </font><font style="vertical-align: inherit;">Creating a new set of fragments and cells, we create a new map. </font><font style="vertical-align: inherit;">Let's divide </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into two parts - the initialization source code and the general method </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a button to the UI to create a new map. </font><font style="vertical-align: inherit;">I made it big and placed it under the save and load buttons.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Button. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event of </font><font style="vertical-align: inherit;">this button with the method of </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our object </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">That is, we will not go through the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but directly call the method of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a map by pressing.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clear old data </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now when you click on the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">, a new set of fragments and cells will be created. </font><font style="vertical-align: inherit;">However, old ones are not automatically deleted. </font><font style="vertical-align: inherit;">Therefore, as a result, we will have several meshes of maps superimposed on each other. </font><font style="vertical-align: inherit;">To avoid this, we first need to get rid of old objects. </font><font style="vertical-align: inherit;">This can be done by destroying all the current fragments at the beginning </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can we reuse existing objects?</font></font></b> <div class="spoiler_text">  ,         .     ,       .  ,    ‚Äî    ,      . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is it possible to destroy child elements in a loop?</font></font></b> <div class="spoiler_text">  Of course.         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Specify the size in the cells instead of fragments </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For now we set the size of the map through the fields </font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the </font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But it will be much more convenient to indicate the size of the map in the cells. </font><font style="vertical-align: inherit;">At the same time, we can even further change the size of the fragment without changing the size of the maps. </font><font style="vertical-align: inherit;">So let's swap the field for the number of cells and the number of fragments.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; ‚Ä¶ // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; ‚Ä¶ public void CreateMap () { ‚Ä¶ // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will lead to a compilation error, because it </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses fragment sizes </font><font style="vertical-align: inherit;">to limit its position </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's change it </font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it uses directly the number of cells that it still needs.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fragment has a size of 5 to 5 cells, and the default maps are 4 to 3 fragments. </font><font style="vertical-align: inherit;">Therefore, in order for the cards to remain the same, we will have to use a size of 20 by 15 cells. </font><font style="vertical-align: inherit;">And although we assigned default values ‚Äã‚Äãin the code, the grid object will still not use them automatically, because the fields already existed and were set to 0 by default.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The default map size is 20 by 15.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbitrary card sizes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to support the creation of maps of any size, not just the default size. </font><font style="vertical-align: inherit;">To do this, add to the </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters X and Z. They will replace the existing number of cells. </font><font style="vertical-align: inherit;">Inside, </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we'll just call them with the current numbers of cells.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this will only work correctly with the number of cells multiple of the fragment size. </font><font style="vertical-align: inherit;">Otherwise, the integer division will create too few fragments. </font><font style="vertical-align: inherit;">Although we can add support for fragments partially filled with cells, let's just forbid the use of dimensions that do not correspond to the fragments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can use the operator </font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to calculate the remainder of dividing the number of cells by the number of fragments. </font><font style="vertical-align: inherit;">If it is not equal to zero, then there is a discrepancy and we will not create a new map. </font><font style="vertical-align: inherit;">And while we are doing this, let's add protection from zero and negative sizes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menu of new maps </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the current stage, the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">no longer works, because the method </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">now has two parameters. We cannot directly connect Unity events with such methods. In addition, to support different sizes of maps we need a few buttons. Instead of adding all these buttons to the main UI, let's create a separate popup menu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a new canvas to the scene ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). We use the same settings as the existing canvas, except that its </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sort Order</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should be equal to 1. Due to this, it will be on top of the UI of the main editor. I made both the canvas and the event system the children of a new UI object so that the scene hierarchy remains clean.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canvas menu New Map. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> panel, covering the entire screen. </font><font style="vertical-align: inherit;">It is needed to darken the background and not allow the cursor to interact with everything else when the menu is open. </font><font style="vertical-align: inherit;">I gave it a uniform color, clearing its </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Image</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font><font style="vertical-align: inherit;">set it </font><font style="vertical-align: inherit;">as </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (0, 0, 0, 200).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Background image settings. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a menu bar to the canvas center, similar to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> panels </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Create a clear label and buttons for small, medium and large maps. </font><font style="vertical-align: inherit;">We will also add a cancel button to it in case the player changes his mind. </font><font style="vertical-align: inherit;">Having finished creating the design, we deactivate the whole </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu New Map. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To manage the menu, create a component </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and add it to the canvas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To create a new map, we need access to a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Therefore, we add a common field to it and connect it.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component New Map Menu.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opening and closing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can open and close the popup menu by simply activating and deactivating the canvas object. </font><font style="vertical-align: inherit;">Let's add in </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two general methods that will deal with this.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now connect the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font><font style="vertical-align: inherit;">button of the </font><font style="vertical-align: inherit;">editor to the method </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opening the menu by pressing. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also connect the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">to the method </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This will allow us to open and close the popup menu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating new maps </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create new maps, we need to call a </font><font style="vertical-align: inherit;">method </font><font style="vertical-align: inherit;">in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In addition, after that we need to close the pop-up menu. </font><font style="vertical-align: inherit;">Add to the </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method that deals with this, taking into account an arbitrary size.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method should not be general, because we still cannot connect it directly to button events. </font><font style="vertical-align: inherit;">Instead, create one method per button that will be called </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the specified size. </font><font style="vertical-align: inherit;">For a small map, I used a size of 20 by 15, corresponding to the size of the default map. </font><font style="vertical-align: inherit;">For an average card, I decided to double this size, getting 40 by 30, and double it again for a large card. </font><font style="vertical-align: inherit;">Connect the buttons with the appropriate methods.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Camera lock </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can use the pop-up menu to create new maps with three different sizes! Everything works well, but we need to take care of a little detail. When the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu is</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> active, we can no longer interact with the UI editor and edit the cells. However, we can still control the camera. Ideally, when the menu is open, the camera should be blocked. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we only have one camera, a quick and pragmatic solution would be to simply add a static property to it </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For widespread use, this solution is not very suitable, but for our simple interface it is enough. This requires that we track the static instance inside </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is set when the camera is awake.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A property </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be a simple static boolean property only with a setter. </font><font style="vertical-align: inherit;">All it does is disable the instance </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when it is locked, and turn it on when it is unlocked.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now </font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can block the camera, and </font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- unlock it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keeping the correct camera position </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is another likely issue with the camera. </font><font style="vertical-align: inherit;">When creating a new card that is smaller than the current one, the camera may be beyond the boundaries of the card. </font><font style="vertical-align: inherit;">She will stay there until the player tries to move the camera. </font><font style="vertical-align: inherit;">And only then will it become limited to the new card. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve this problem, we can add to the </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static method </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Invoking a </font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero offset instance </font><font style="vertical-align: inherit;">method will </font><font style="vertical-align: inherit;">force the camera to the map boundaries. </font><font style="vertical-align: inherit;">If the camera is already inside the borders of the new card, then it will remain in place.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call the method inside </font></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after creating a new map.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-13/creating-new-maps/creating-new-maps.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saving card size </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although we can create maps of different sizes, it is not taken into account when saving and loading. </font><font style="vertical-align: inherit;">This means that loading a map will result in an error or an incorrect map if the size of the current map does not match the size of the map being loaded. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve this problem, before loading the data cells, we need to create a new map of the appropriate size. </font><font style="vertical-align: inherit;">Let's assume that we have a small map saved. </font><font style="vertical-align: inherit;">In this case, everything will be fine if we create </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a 20 by 15 map </font><font style="vertical-align: inherit;">at the beginning </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Card size storage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, we can store a card of any size. </font><font style="vertical-align: inherit;">Therefore, a generalized solution will be to preserve the size of the map in front of the data cells.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we can get the true size and use it to create a map with the correct size. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since now we can download maps of different sizes, we again face the problem of the camera position. </font><font style="vertical-align: inherit;">We will solve it by checking its position in </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after loading the map.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> New file format </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although this approach works with maps that we will save in the future, it will not work with old ones. </font><font style="vertical-align: inherit;">And vice versa - the code from the previous part of the tutorial will not be able to correctly load new map files. </font><font style="vertical-align: inherit;">To distinguish between old and new formats, we will increase the integer header value. </font><font style="vertical-align: inherit;">The old format of saving without the size of the card was version 0. The new format with the size of the map will be version 1. Therefore, when recording </font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, instead of 0, it should write 1</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From now on, the maps will be saved as version 1. If we try to open them in the assembly from the previous tutorial, they will refuse to load and report an unknown map format. </font><font style="vertical-align: inherit;">In fact, this will happen if we already try to load such a map. </font><font style="vertical-align: inherit;">You need to change the method </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it accepts the new version.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> backward compatibility </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, if you want, we can still load version 0 maps, assuming that they all have the same size of 20 by 15. That is, the title does not have to be 1, it can be zero. </font><font style="vertical-align: inherit;">Since each version requires its own approach, it </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must pass the header to the method </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">header </font><font style="vertical-align: inherit;">to the </font><font style="vertical-align: inherit;">parameter and use it to make decisions about further actions. </font><font style="vertical-align: inherit;">If the header is at least 1, then you need to read the card size data. </font><font style="vertical-align: inherit;">Otherwise, use the old fixed card size 20 by 15 and skip reading the size data.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); ‚Ä¶ }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">version 0 map file</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Check card size </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As with the creation of a new map, it is theoretically possible that we will have to load a map that is incompatible with the size of the fragment. </font><font style="vertical-align: inherit;">When this happens, we must interrupt the loading of the map. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">already refuses to create a map and displays an error to the console. </font><font style="vertical-align: inherit;">To tell this to the caller, let's return a bool indicating whether a map has been created.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">too, can stop executing if the map creation fails.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the download overwrites all the data in the existing cells, we do not need to create a new map if the map is loaded the same size. </font><font style="vertical-align: inherit;">Therefore, this step can be skipped.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-13/saving-map-size/saving-map-size.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> File management </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can save and load maps of different sizes, but always write and read </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Now we will add support for different files. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of saving or loading the map directly, we use another pop-up menu that provides advanced file management. </font><font style="vertical-align: inherit;">Create another canvas, as in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but this time we will call it </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save Load Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This menu will deal with saving and loading maps, depending on the button pressed to open it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will create a </font><em><font style="vertical-align: inherit;">Save Load Menu</font></em><font style="vertical-align: inherit;"> design.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as if it's a save menu. Later we will dynamically turn it into the boot menu. Like the other menu, it should have a background and menu bar, menu label and cancel button. Then add scroll view ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Scroll View</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) to the menu to display the file list. Below we insert an input field ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Input Field</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) to specify the names of the new maps. We also need an action button to save the map. And finally. add a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delete</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">to remove unwanted maps.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design Save Load Menu.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By default, scroll view allows you to perform both horizontal and vertical scrolling, but we only need a list with vertical scrolling. Therefore, turn off the scrolling </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and disconnect the horizontal scroll bar. Also set the </font><font style="vertical-align: inherit;">value </font><font style="vertical-align: inherit;">for the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movement Type</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clamped and disable </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inertia</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so that the list </font><font style="vertical-align: inherit;">seems more restrictive </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameters File List. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remove the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrollbar Horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> child </font><font style="vertical-align: inherit;">from the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File List</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">, because we don‚Äôt need it. </font><font style="vertical-align: inherit;">Then change the size of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrollbar Vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so that it </font><em><font style="vertical-align: inherit;">reaches the</font></em><font style="vertical-align: inherit;"> bottom of the list. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The placeholder text of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">can be changed in its </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placeholder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> child element </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I used descriptive text, but you can just leave it blank and get rid of the placeholder.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changed menu design. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We‚Äôve finished with the design, and now we deactivate the menu so that it is hidden by default.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menu management </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the menu to work, we need another script, in this case - </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As well </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it needs a reference to the grid, as well as methods </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add this component to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and give it a link to the grid object.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component SaveLoadMenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The menu will open for saving or loading. </font><font style="vertical-align: inherit;">To simplify the work, add a </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boolean parameter </font><font style="vertical-align: inherit;">to the method </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It determines whether the menu should be in save mode. </font><font style="vertical-align: inherit;">We will track this mode in the field to know what action to take later.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now combine the buttons </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Object </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the method </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the object </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save Load the Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Check the boolean parameter for the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button only </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opening the menu in save mode. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have not done so already, connect the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button event </font><font style="vertical-align: inherit;">to the method </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save Load Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can open and close.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change in appearance </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We created the menu as a save menu, but its mode is determined by the button pressed to open. </font><font style="vertical-align: inherit;">We need to change the appearance of the menu depending on the mode. </font><font style="vertical-align: inherit;">In particular, we need to change the menu label and the action button label. </font><font style="vertical-align: inherit;">This means that we will need links to these tags.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connection with tags. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the menu opens in save mode, we use the existing labels, that is, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the menu and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Save</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the action button. </font><font style="vertical-align: inherit;">Otherwise, we are in load mode, that is, we use </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enter Card Name </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's leave a list of files for now. </font><font style="vertical-align: inherit;">The user can specify the file to be saved or loaded by entering the name of the card in the input field. </font><font style="vertical-align: inherit;">To obtain this data, we need a reference to the component </font></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connection to the input field. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The user does not need to force to enter the full path to the map file. </font><font style="vertical-align: inherit;">It will be enough just the name of the map without the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> extension </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's add a method that takes user input and creates the right path for it. </font><font style="vertical-align: inherit;">This is not possible when the input is empty, so in this case we will return </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What happens if a user enters invalid characters?</font></font></b> <div class="spoiler_text">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Save and Load </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now will be engaged in saving and loading </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Therefore we will move methods </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">They are no longer required to be shared, and will work with the path parameter instead of the fixed path.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we are now loading arbitrary files, it would be nice to check that the file actually exists, and only then try to read it. </font><font style="vertical-align: inherit;">If not, then we give an error and stop the operation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now add a general method </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It starts with getting the path selected by the user. </font><font style="vertical-align: inherit;">If there is a path, then we save or load it. </font><font style="vertical-align: inherit;">Then close the menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By attaching the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Action Button</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event to this method </font><font style="vertical-align: inherit;">, we can save and load using arbitrary map names. </font><font style="vertical-align: inherit;">Since we do not reset the input field, the selected name will be saved until the next save or load. </font><font style="vertical-align: inherit;">It is convenient to save or load from one file several times in a row, so we will not change anything.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Map List Items </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we will fill in the file list with all the cards that are in the data storage path. </font><font style="vertical-align: inherit;">When you click on one of the items in the list, it will be used as text in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Let's add in </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for this a common method.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need something that is a list item. </font><font style="vertical-align: inherit;">A regular button will do. </font><font style="vertical-align: inherit;">Create it and reduce the height to 20 units, so that it does not take up much space vertically. </font><font style="vertical-align: inherit;">It should not look like a button, so clear the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Image</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> link of </font><font style="vertical-align: inherit;">its </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> component </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">At the same time it will become completely white. </font><font style="vertical-align: inherit;">In addition, we will make the label align to the left and that there is space between the text and the left side of the button. </font><font style="vertical-align: inherit;">Having finished with button design, we will turn it into prefab.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Button-list item. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We cannot directly connect a button event to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because this is a prefab and does not exist in the scene yet. </font><font style="vertical-align: inherit;">Therefore, the menu item needs a link to the menu so that it can call the method when pressed </font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">He also needs to keep track of the name of the card he represents, and set his text. </font><font style="vertical-align: inherit;">Create a small component for this </font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a component to the menu item and make the button call its method </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component item.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filling the list </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To populate the list, you </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need a reference to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inside the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viewport</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File List</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">He also needs a link to the prefab point.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Combining the contents of the list and prefab. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To fill this list, we use a new method. </font><font style="vertical-align: inherit;">The first step is to identify the existing map files. </font><font style="vertical-align: inherit;">To obtain an array of all file paths within the directory, we can use the method </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This method has a second parameter that allows filtering files. </font><font style="vertical-align: inherit;">In our case, only files corresponding to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mask are required </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, file order is not guaranteed. </font><font style="vertical-align: inherit;">To display them in alphabetical order, we need to sort the array with </font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we will create instances of the prefab for each element of the array. </font><font style="vertical-align: inherit;">Bind the item to the menu, set its card name and make it a child of the list.</font></font><br><br><pre> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since it </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the full paths to the files, we need to clear them. </font><font style="vertical-align: inherit;">Fortunately, this is exactly what a convenient method does </font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before displaying the menu, we need to fill out the list. </font><font style="vertical-align: inherit;">And since the files are likely to change, we need to do this every time the menu is opened.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When re-filling the list, we need to remove all old ones before adding new items. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Items without placement.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arrangement of points </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the list will display items, but they will overlap and be in a bad position. To make them turn into a vertical list, we add a </font><em><font style="vertical-align: inherit;">Vertical Layout Group</font></em><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">Component / Layout / Vertical Layout Group</font></em><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">component </font><font style="vertical-align: inherit;">to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object of the </font><font style="vertical-align: inherit;">list </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For the alignment to work properly, we </font><em><font style="vertical-align: inherit;">‚Äôll</font></em><font style="vertical-align: inherit;"> enable </font><em><font style="vertical-align: inherit;">Width</font></em><font style="vertical-align: inherit;"> of both </font><em><font style="vertical-align: inherit;">Child Control Size</font></em><font style="vertical-align: inherit;"> and </font><em><font style="vertical-align: inherit;">Child Force Expand</font></em><font style="vertical-align: inherit;"> . Both options </font><em><font style="vertical-align: inherit;">Height</font></em><font style="vertical-align: inherit;"> must be disabled.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use the vertical layout group. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a beautiful list of items. </font><font style="vertical-align: inherit;">However, the size of the contents of the list does not adjust to the true number of items. </font><font style="vertical-align: inherit;">Therefore, the scroll bar never changes size. </font><font style="vertical-align: inherit;">We can make </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> automatically resize by adding a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content Size Fitter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> component </font><font style="vertical-align: inherit;">( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component / Layout / Content Size Fitter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) to it. </font><font style="vertical-align: inherit;">His </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertical Fit</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mode </font><font style="vertical-align: inherit;">should be set to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preferred Size</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use content size fitter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, with a small number of points, the scroll bar will disappear. </font><font style="vertical-align: inherit;">And when there are too many items in the list that do not fit in the viewing window, the scroll bar appears and has the corresponding size.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A scrollbar appears.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deleting cards </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can conveniently work with a variety of map files. </font><font style="vertical-align: inherit;">However, sometimes it is necessary to get rid of some cards. </font><font style="vertical-align: inherit;">For this you can use the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delete</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Create a method for this and make the button call it. </font><font style="vertical-align: inherit;">If there is a selected path, simply delete it with </font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we also need to check that we are working with a really existing file. </font><font style="vertical-align: inherit;">If this is not the case, then we should not try to delete it, but this does not lead to an error.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After removing the card, we do not need to close the menu. </font><font style="vertical-align: inherit;">This makes it easier to delete several files at once. </font><font style="vertical-align: inherit;">However, after deleting, we need to clear the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Name Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as update the file list.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-13/file-management/file-management.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 14: relief textures </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use the vertex colors to create a splat map. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating an array of textures. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adding relief indices to meshes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transitions between relief textures. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point, we used solid colors for coloring maps. </font><font style="vertical-align: inherit;">Now we will apply the texture.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drawing textures.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Three types mixing </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although homogeneous colors are clearly distinguishable and fully cope with the task, they do not look very interesting. </font><font style="vertical-align: inherit;">The use of textures will greatly increase the appeal of maps. </font><font style="vertical-align: inherit;">Of course, for this we have to mix textures, not just colors. </font><font style="vertical-align: inherit;">In the </font></font><a href="https://catlikecoding.com/unity/tutorials/rendering/part-3/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3, Combining Textures</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tutorial </font><a href="https://catlikecoding.com/unity/tutorials/rendering/part-3/"><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> I talked about how to mix multiple textures using a splat map. </font><font style="vertical-align: inherit;">In our maps of hexagons, you can use a similar approach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In tutorial </font></font><a href="https://catlikecoding.com/unity/tutorials/rendering/part-3/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only four textures are mixed, and with one splat map we can support up to five textures. </font><font style="vertical-align: inherit;">At the moment we are using five different colors, so this is fine for us. </font><font style="vertical-align: inherit;">However, we can add other types later. </font><font style="vertical-align: inherit;">Therefore, the need to support an arbitrary number of types of relief. </font><font style="vertical-align: inherit;">When using explicit texture properties, this is not possible, so you will have to apply an array of textures. </font><font style="vertical-align: inherit;">Later we will create it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using texture arrays, we somehow need to tell the shader which textures to mix. </font><font style="vertical-align: inherit;">The most complex mixing is necessary for angular triangles, which can be between three cells with their type of relief. </font><font style="vertical-align: inherit;">Therefore, we need support for mixing between the three types per triangle.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using vertex colors as splat maps </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assuming that we can tell you which textures to blend, you can use the vertex colors to create a splat map for each triangle. </font><font style="vertical-align: inherit;">Since in each of the cases a maximum of three textures are used, we need only three channels of color. </font><font style="vertical-align: inherit;">Red will represent the first texture, green will represent the second, and blue will represent the third.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangle Splat map.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is the sum of the splat map triangle always equal to one?</font></font></b> <div class="spoiler_text">  Yes.         .     . ,        (1, 0, 0)  ,  (¬Ω, ¬Ω, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the triangle needs only one texture, we use only the first channel. </font><font style="vertical-align: inherit;">That is, its color will be completely red. </font><font style="vertical-align: inherit;">In the case of mixing between two different types, we use the first and second channels. </font><font style="vertical-align: inherit;">That is, the color of the triangle will be a mixture of red and green. </font><font style="vertical-align: inherit;">And when all three types are found, it will be a mixture of red, green and blue.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Three splat map configurations. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will use these splat map configurations regardless of which textures actually blend. </font><font style="vertical-align: inherit;">That is, the splat map will always be the same. </font><font style="vertical-align: inherit;">Only the textures will change. </font><font style="vertical-align: inherit;">How to do this, we will find out later. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to change </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it to create these splat maps, rather than using the colors of the cells. </font><font style="vertical-align: inherit;">Since we will often use three colors, we will create static fields for them.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cell Centers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with replacing the color of the cell centers by default. </font><font style="vertical-align: inherit;">There is no blending, so we just use the first color, that is, red.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red cell centers. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The cell centers are now red. </font><font style="vertical-align: inherit;">All of them use the first of the three textures, no matter what the texture is. </font><font style="vertical-align: inherit;">Their splat maps are the same, regardless of the color with which we paint the cells.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Neighborhood </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We changed the segments only inside the cells without rivers flowing through them. </font><font style="vertical-align: inherit;">We need to do the same for the segments adjacent to the rivers. </font><font style="vertical-align: inherit;">In our case, this is a strip of an edge, and a fan of edge triangles. </font><font style="vertical-align: inherit;">Here we also need only red.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red segments adjacent to rivers.</font></font></i> <br><br><h3>  Rivers </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we need to take care of the geometry of the rivers inside the cells. </font><font style="vertical-align: inherit;">All of them should also turn red. </font><font style="vertical-align: inherit;">For a start, let's start the beginning and end of the rivers.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then the geometry that makes up the banks and the river bed. </font><font style="vertical-align: inherit;">I grouped calls to the color method to make the code easier to read.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red river along the cells.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ribs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All edges are different, because they are located between cells, which may have different types of relief. </font><font style="vertical-align: inherit;">We use the first color for the current cell type, and the second color for the neighbor type. </font><font style="vertical-align: inherit;">As a result, the splat map will become a red-green gradient, even if both cells are of the same type. </font><font style="vertical-align: inherit;">If both cells use the same texture, it will simply become a mixture of the same texture on both sides.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red-green edges, with the exception of ledges.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doesn't a sharp transition between red and green cause problems?</font></font></b> <div class="spoiler_text">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The edges with ledges are slightly more complicated, because they have additional vertices. </font><font style="vertical-align: inherit;">Fortunately, the existing interpolation code works fine with the splat map colors. </font><font style="vertical-align: inherit;">Just use the first and second colors, not the colors of the cells of the beginning and end.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red-green edge ledges.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corners </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The corners of the cells are the most difficult because they have to mix three different textures. </font><font style="vertical-align: inherit;">We use red for the lower top, green for the left and blue for the right. </font><font style="vertical-align: inherit;">Let's start with the corners of one triangle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red-green-blue corners, with the exception of ledges. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we can again use the existing color interpolation code for ledges. </font><font style="vertical-align: inherit;">Just interpolation is performed between three, not two colors. </font><font style="vertical-align: inherit;">First consider the ledges that are not located near the cliffs.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red-green-blue corner ledges, except for the ledges along the cliffs. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When it comes to cliffs, we need to use the method </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This method received as parameters the initial and left cell. </font><font style="vertical-align: inherit;">However, now we need appropriate splat colors, which can vary depending on the topology. </font><font style="vertical-align: inherit;">Therefore, we replace these parameters with colors.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Change it </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it uses the right colors.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And do the same for </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full splat map of relief. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-14/blending-three-types/blending-three-types.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texture Arrays </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that our terrain has a splat map, we can transfer a texture collection to the shader. </font><font style="vertical-align: inherit;">We cannot simply assign a C # texture array to the shader, because the array must exist in the GPU memory as a single entity. </font><font style="vertical-align: inherit;">We should use special object </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which is supported in Unity since version 5.4.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do all GPUs support texture arrays?</font></font></b> <div class="spoiler_text">  GPU  ,         .      <a href="https://docs.unity3d.com/Manual/SL-TextureArrays.html"> Unity</a> . <br><ul><li> Direct3D 11/12 (Windows, Xbox One) </li><li> OpenGL Core (Mac OS X, Linux) </li><li> Metal (iOS, Mac OS X) </li><li> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li>  Playstation 4 </li></ul></div></div><br><br><h3>  Master </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, Unity Editor support for texture arrays in version 5.5 is minimal. </font><font style="vertical-align: inherit;">We cannot simply create an array of textures and assign textures to it. </font><font style="vertical-align: inherit;">We have to do it manually. </font><font style="vertical-align: inherit;">We can either create an array of textures in Play mode, or create an asset in the editor. </font><font style="vertical-align: inherit;">Let's create an asset.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why create an asset?</font></font></b> <div class="spoiler_text">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create an array of textures, we will assemble our own master. </font><font style="vertical-align: inherit;">Create a script </font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and place it inside the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folder </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead, </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it must extend the type </font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the namespace </font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can open the wizard through a generic static method </font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its parameters are the names of the wizard window and its creation buttons. </font><font style="vertical-align: inherit;">We will call this method in a static method </font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To access the wizard through the editor, we need to add this method to the Unity menu. </font><font style="vertical-align: inherit;">This can be done by adding an attribute to the method </font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's add it to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menu </font><font style="vertical-align: inherit;">, and more specifically in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets / Create / Texture Array</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our custom master. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the new menu item, you can open the popup menu of our custom wizard. </font><font style="vertical-align: inherit;">It is not very beautiful, but it is suitable for solving the problem. </font><font style="vertical-align: inherit;">However, it is still empty. </font><font style="vertical-align: inherit;">To create an array of textures, we need an array of textures. </font><font style="vertical-align: inherit;">Add for him in the master common field. </font><font style="vertical-align: inherit;">The standard wizard GUI will display it, as the standard inspector does.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wizard with textures.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create something </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you click the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button of the </font><font style="vertical-align: inherit;">wizard, it will disappear. </font><font style="vertical-align: inherit;">In addition, Unity will complain that there is no method </font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is the method that is called when the create button is clicked, so we need to add it to the wizard.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we will create our array of textures. </font><font style="vertical-align: inherit;">At least if the user added texture to the wizard. </font><font style="vertical-align: inherit;">If not, then there is nothing to create and the work must be stopped.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to ask where to save the texture array array. </font><font style="vertical-align: inherit;">The save file panel can be opened by the method </font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its parameters define the panel name, default file name, file extension, and description. </font><font style="vertical-align: inherit;">For texture arrays, the common </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asset</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file extension is used </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the user-selected file path. </font><font style="vertical-align: inherit;">If the user clicked cancel on this panel, the path will be an empty string. </font><font style="vertical-align: inherit;">Therefore, in this case, we must interrupt the work.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating an array of textures </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we have the right path, then we can move on and create a new object </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">His constructor method requires specifying the width and height of the texture, the length of the array, the format of the textures, and the need for mipmapping. </font><font style="vertical-align: inherit;">These parameters must be the same for all textures in the array. </font><font style="vertical-align: inherit;">To configure the object, we use the first texture. </font><font style="vertical-align: inherit;">The user himself must check that all textures have the same format.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the texture array is a single GPU resource, it uses the same filtering and folding modes for all textures. </font><font style="vertical-align: inherit;">Here we again use the first texture to adjust all this.</font></font><br><br><pre> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can copy the textures into an array using the method </font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The method copies raw texture data, one mip level at a time. </font><font style="vertical-align: inherit;">Therefore, we need to loop around all the textures and their mip levels. </font><font style="vertical-align: inherit;">The parameters of the method are two sets consisting of a texture resource, an index, and a mip-level. </font><font style="vertical-align: inherit;">Since the original textures are not arrays, their index is always zero.</font></font><br><br><pre> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, we have in memory the correct array of textures, but it is not yet an asset. </font><font style="vertical-align: inherit;">The final step will be a call </font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with an array and its path. </font><font style="vertical-align: inherit;">The data will be written to a file in our project, and it will appear in the project window.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { ‚Ä¶ } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textures </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a real array of textures, we need the original textures. Here are five textures that match the colors we used up to this point. Yellow becomes sand, green becomes grass, blue becomes earth, orange becomes stone, and white becomes snow.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textures of sand, grass, earth, stone and snow. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that these textures are not photographs of this relief. </font><font style="vertical-align: inherit;">These are light pseudo-random patterns that I created using </font></font><a href="https://catlikecoding.com/numberflow/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I tried to create recognizable types and relief details that do not conflict with abstract polygonal relief. </font><font style="vertical-align: inherit;">Photorealism turned out to be inappropriate. </font><font style="vertical-align: inherit;">In addition, despite the fact that the patterns add variations, they have few distinct features that would make repetitions immediately noticeable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add these textures to the wizard array, making sure that their order matches the colors. </font><font style="vertical-align: inherit;">That is, first sand, then grass, earth, stone, and finally snow.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create an array of textures. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After creating an array of textures, select it and look at it in the inspector.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture array inspector.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is the simplest display of a piece of texture array data. Notice that there is an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Readable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> switch </font><font style="vertical-align: inherit;">that is initially enabled. Since we do not need to read the pixel data from the array, turn it off. We cannot do this in the wizard, because we have </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no methods or properties to access this parameter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(In Unity 5.6 there is a bug that corrupts texture arrays in assemblies on several platforms. You can bypass it without disabling </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Readable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also worth noting that there is a </font><em><font style="vertical-align: inherit;">Color Space</font></em><font style="vertical-align: inherit;"> field</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is assigned the value 1. This means that the textures are assumed to be in gamma space, which is true. </font><font style="vertical-align: inherit;">If they were to be in linear space, then the field had to be assigned the value 0. In fact, the designer </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has an additional parameter to specify the color space, but </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not indicate whether it is in linear space or not, therefore, in any case, you need to specify value manually.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have an array of textures, we need to teach the shader to work with it. </font><font style="vertical-align: inherit;">So far, for rendering terrain, we use the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VertexColors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since now instead of colors we use textures, we rename it to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Then turn its </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameter </font><font style="vertical-align: inherit;">into an array of textures and assign an asset to it.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material relief with an array of textures. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To enable texture arrays on all platforms supporting them, increase the target level of the shader from 3.0 to 3.5.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the variable </font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">now refers to an array of textures, we need to change its type. </font><font style="vertical-align: inherit;">The type depends on the target platform and the macro will take care of this </font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in other shaders, for sampling the textures of the relief we need the coordinates of the XZ world. </font><font style="vertical-align: inherit;">Therefore, we will add a position in the world to the input shader structure. </font><font style="vertical-align: inherit;">We also remove the default UV coordinates, because we don‚Äôt need them.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To sample an array of textures, we need to use a macro </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It requires three coordinates to sample the array. </font><font style="vertical-align: inherit;">The first two are the usual UV coordinates. </font><font style="vertical-align: inherit;">We will use the XZ coordinates of the world, scaled to 0.02. </font><font style="vertical-align: inherit;">So we get a good resolution of textures at full magnification. </font><font style="vertical-align: inherit;">Textures will be repeated approximately every four cells. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third coordinate is used as an index of an array of textures, as in a regular array. </font><font style="vertical-align: inherit;">Since the coordinates have float values, before indexing the array, the GPU rounds them. </font><font style="vertical-align: inherit;">Since we do not know yet what texture is needed, let's always use the first one. </font><font style="vertical-align: inherit;">Also, the color of the vertex will not affect the final result, because it is a splat map.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything became sand. </font></font></i> <br><br> <a href="http://texture-arrays/texture-arrays.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texture selection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need a splat map of relief, mixing three types per triangle. </font><font style="vertical-align: inherit;">We have an array of textures with a texture for each type of relief. </font><font style="vertical-align: inherit;">We have a shader that samples the array of textures. </font><font style="vertical-align: inherit;">But so far we have no opportunity to tell the shader which textures to choose for each triangle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since each triangle mixes up to three types in itself, we need to associate three indices with each triangle. </font><font style="vertical-align: inherit;">We cannot store information for triangles, so we have to store indexes for vertices. </font><font style="vertical-align: inherit;">All three vertices of the triangle will simply store the same indices as in the case of solid color.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesh data </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can use one of the UV mesh sets for storing indexes. </font><font style="vertical-align: inherit;">Since three indexes are stored at each vertex, the existing 2D UV sets will not be enough. </font><font style="vertical-align: inherit;">Fortunately, UV sets can contain up to four coordinates. </font><font style="vertical-align: inherit;">Therefore, we will add to the </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second list </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which we will refer to as relief types.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enable terrain types for the </font><em><font style="vertical-align: inherit;">Hex Grid Chunk</font></em><font style="vertical-align: inherit;"> Prefab Sub </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> child </font><font style="vertical-align: inherit;">.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use relief types. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If necessary, we will take another list </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for terrain types during mesh cleaning.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of applying the mesh data, we save the terrain types in the third UV set. </font><font style="vertical-align: inherit;">Because of this, they will not conflict with the other two sets if we ever decide to use them together.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To set the types of relief triangle we use </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since the same triangle is the same for the whole triangle, we simply add the same data three times.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mixing in quad works similarly. </font><font style="vertical-align: inherit;">All four vertices have the same types.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fan triangles edges </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to add types to the mesh data in </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's start with </font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">First, for the sake of better readability, we divide the calls to the vertex and color methods. </font><font style="vertical-align: inherit;">Recall that with each call of this method we pass to it </font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so we can use this color directly, and not use the parameter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the colors we add terrain types. </font><font style="vertical-align: inherit;">Since the types in the triangle can be different, it must be a parameter that replaces the color. </font><font style="vertical-align: inherit;">Use this simple type to create </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Only the first four channels are important to us, because in this case the splat map is always red. </font><font style="vertical-align: inherit;">Since all three components of the vector need to be assigned something, let's assign one type to them.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to change all the calls to this method, replacing the color argument with the index of the cell type relief. </font><font style="vertical-align: inherit;">Make this change to </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, when you start the Play mode, errors will appear indicating that the third set of UV meshes are out of bounds. </font><font style="vertical-align: inherit;">It happened because we are not adding relief types to each triangle and quad. </font><font style="vertical-align: inherit;">So let's continue to change </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rib stripes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when creating the edge band, we need to know which types of relief are on both sides. </font><font style="vertical-align: inherit;">Therefore, we add them as parameters, and then create a vector of types, the two channels of which are assigned these types. </font><font style="vertical-align: inherit;">The third channel is not important, so just equate it to the first. </font><font style="vertical-align: inherit;">After adding colors, add to quad types.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to change the challenges </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">First </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must use the cell type for both sides of the edge strip.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, the simplest edge case </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should use the cell type for the nearest edge and the neighbor type for the far edge. </font><font style="vertical-align: inherit;">They may be the same or different.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same applies to </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">who triggers </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Types for ledges are the same.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corners </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest case of a corner is a simple triangle. </font><font style="vertical-align: inherit;">The lower cell transmits the first type, the left - the second, and the right - the third. </font><font style="vertical-align: inherit;">With their help, create a vector of types and add it to the triangle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use the same approach in </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, only here we create a group of quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When mixing ledges and cliffs, we need to use </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Simply give it a type vector parameter and add it to all its triangles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will create a vector of types on the basis of the transferred cells. </font><font style="vertical-align: inherit;">Then add it to the same triangle and transfer it to </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same applies to </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3>  Rivers </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last method requiring change is this </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since here we are in the center of the cell, we deal only with the type of the current cell. </font><font style="vertical-align: inherit;">Therefore, create a vector for it and add it to the triangles and quad-am.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type mixing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, the meshes contain the necessary relief indices. </font><font style="vertical-align: inherit;">All we have to do is force the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader to </font><font style="vertical-align: inherit;">use them. </font><font style="vertical-align: inherit;">In order for indexes to fall into a fragmentary shader, we need to first pass them through the vertex shader. </font><font style="vertical-align: inherit;">We can do this in our own vertex function, as we did in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In this case, we add a field to the input structure </font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and copy it into it </font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> ‚Ä¶ struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to sample the array of textures three times per fragment. </font><font style="vertical-align: inherit;">Therefore, let's create a convenient function for creating texture coordinates, sampling an array and modulating a sample with a splat map for a single index.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can we work with a vector as with an array?</font></font></b> <div class="spoiler_text">  Yes.   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using this function, we will simply sample the array of textures three times and combine the results. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textured relief. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can draw relief textures. </font><font style="vertical-align: inherit;">They are mixed just like solid colors. </font><font style="vertical-align: inherit;">Since we use the coordinates of the world as UV coordinates, they do not change with altitude. </font><font style="vertical-align: inherit;">As a result, along the sharp cliffs textures are stretched. </font><font style="vertical-align: inherit;">If the textures are neutral enough and very variable, the results will be acceptable. </font><font style="vertical-align: inherit;">Otherwise, we get big ugly stretch marks. </font><font style="vertical-align: inherit;">You can try to hide it with additional geometry or textures of cliffs, but we will not do this in the tutorial.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cleaning up </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when we use textures instead of colors, it will be logical to change the editor panel. </font><font style="vertical-align: inherit;">We can create a beautiful interface that can even display relief textures, but I will focus on abbreviations corresponding to the style of the existing scheme.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variants of choice of relief. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, you </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no longer need the color property, so remove it.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can also delete an array of colors and its associated code.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ ‚Ä¶ void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, an array of colors is also not needed in </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="http://selecting-textures/selecting-textures.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 15: distances </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Display the grid lines. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Switch between edit and navigation modes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calculate the distance between cells. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We find ways around obstacles. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We take into account the variable costs of moving. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Having created quality maps, we will begin to navigate. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The shortest path is not always straight.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grid display </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation on the map is performed by moving from cell to cell. </font><font style="vertical-align: inherit;">To get somewhere, you need to go through a number of cells. </font><font style="vertical-align: inherit;">To estimate the distances it was easier, let's add the option to display the grid of hexagons on which our map is based.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesh texture </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the irregularities of the mesh of the map, the underlying grid is ideally even. </font><font style="vertical-align: inherit;">We can show this by projecting a grid pattern onto the map. </font><font style="vertical-align: inherit;">This can be done using a repeating mesh texture.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repeating mesh texture. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The texture shown above contains a small part of the grid of hexagons, covering 2 to 2 cells. </font><font style="vertical-align: inherit;">This area is rectangular, not square. </font><font style="vertical-align: inherit;">Since the texture itself is a square, the pattern looks stretched. </font><font style="vertical-align: inherit;">When sampling, we need to compensate for this.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesh projection </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To project the mesh pattern, we need to add </font><font style="vertical-align: inherit;">a texture property to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief material with mesh texture. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sample the texture using the XZ coordinates of the world, and then multiply it by albedo. </font><font style="vertical-align: inherit;">Since the grid lines on the texture are gray, this will weave the pattern into the relief.</font></font><br><br><pre> <code class="hljs pgsql"> sampler2D _GridTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albedo multiplied by a fine grid. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to scale the pattern to match the cells of the map. </font><font style="vertical-align: inherit;">The distance between the centers of neighboring cells is 15, it must be doubled to move up two cells. </font><font style="vertical-align: inherit;">That is, we need to divide the coordinates of the V grid by 30. The inner radius of the cells is 5‚àö3, and to move two cells to the right, you need four times as much. </font><font style="vertical-align: inherit;">Therefore, it is necessary to divide the coordinates of the U grid by 20‚àö3.</font></font><br><br><pre> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The correct size of the grid cells. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the grid lines correspond to the map cells. </font><font style="vertical-align: inherit;">Like terrain textures, they ignore the height, so lines will be stretched along the line breaks.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projecting onto cells with height. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deformation of the grid is usually not so bad, especially if you look at the map from a long distance.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid in the distance.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enable Mesh </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although the display of the grid is convenient, it is not always required. </font><font style="vertical-align: inherit;">For example, you should turn it off when you take a screenshot. </font><font style="vertical-align: inherit;">In addition, not everyone prefers to see the grid all the time. </font><font style="vertical-align: inherit;">So let's make it optional. </font><font style="vertical-align: inherit;">We will add the multi_compile directive to the shader to create variants with and without a grid. </font><font style="vertical-align: inherit;">For this we use the keyword </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The conditional compilation of shaders is described in the </font></font><a href="https://catlikecoding.com/unity/tutorials/rendering/part-5/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tutorial </font><a href="https://catlikecoding.com/unity/tutorials/rendering/part-5/"><font style="vertical-align: inherit;">, Multiple Lights</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When declaring a variable, </font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first assign it a value of 1. As a result, the grid will be disabled. </font><font style="vertical-align: inherit;">Then we will sample the mesh texture only for the variant with a specific keyword </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the keyword is </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not included in the relief shader, the grid will disappear. </font><font style="vertical-align: inherit;">To enable it again, we will add a switch to the map editor UI. </font><font style="vertical-align: inherit;">For this to be possible, you </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must receive a link to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> material </font><font style="vertical-align: inherit;">and a method for enabling or disabling a keyword </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor March hexagons with reference to the material. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> switch to the UI </font><font style="vertical-align: inherit;">and connect it to the method </font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grid switch.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Save state </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now in Play mode we can switch the display of the grid. </font><font style="vertical-align: inherit;">During the first check, the grid is initially disabled and becomes visible when we enable the switch. </font><font style="vertical-align: inherit;">When it is turned off, the grid will disappear again. </font><font style="vertical-align: inherit;">However, if we exit Play mode when the grid is visible, the next time Play mode is started, it will be turned on again, although the switch is turned off. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is because we are changing the keyword for the common </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> material </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We edit the asset of the material, so the change is saved in the Unity editor. </font><font style="vertical-align: inherit;">In the assembly, it will not be saved. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To always start the game without a grid, we will disable the keyword </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Awake </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-15/showing-the-grid/showing-the-grid.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edit mode </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we want to control the movement on the map, then we need to interact with it. </font><font style="vertical-align: inherit;">At a minimum, we need to select a cell as the starting point of the path. </font><font style="vertical-align: inherit;">But when you click on a cell, it will be edited. </font><font style="vertical-align: inherit;">We can disable all editing options manually, but this is inconvenient. </font><font style="vertical-align: inherit;">In addition, we do not want movement calculations to be performed while editing the map. </font><font style="vertical-align: inherit;">So let's add a switch that determines whether we are in edit mode.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edit switch </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add to the </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boolean field </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as well as the method that defines it. </font><font style="vertical-align: inherit;">Then add another switch to the UI to control it. </font><font style="vertical-align: inherit;">Let's start with the navigation mode, that is, the edit mode will be disabled by default.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editing mode switch. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To really disable editing, let's make the call </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependent on </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debug tags </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While we do not have units of measure to move around the map. </font><font style="vertical-align: inherit;">Instead, we visualize the distances of movement. </font><font style="vertical-align: inherit;">To do this, you can use existing cell labels. </font><font style="vertical-align: inherit;">Therefore, we will make them visible when editing mode is disabled.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we start with the navigation mode, the default labels should be included. </font><font style="vertical-align: inherit;">He is currently </font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turning them off, but he should not do this anymore.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Label Coordinates. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The coordinates of the cells now become visible immediately after starting the Play mode. </font><font style="vertical-align: inherit;">But we do not need coordinates, we use labels to display distances. </font><font style="vertical-align: inherit;">Since you only need one number per cell, you can increase the font size so that they read better. </font><font style="vertical-align: inherit;">Change the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Cell Label</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> prefab </font><font style="vertical-align: inherit;">to use bold font size 8.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags are in bold size 8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now, after launching Play mode, we will see large labels. </font><font style="vertical-align: inherit;">Only the first coordinates of the cell are visible, the rest are not placed in the label.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Large tags. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we don‚Äôt need coordinates anymore, we‚Äôll remove the </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assignment value </font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also remove the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Labels</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> switch </font><font style="vertical-align: inherit;">and its associated method </font><font style="vertical-align: inherit;">from the UI </font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no more switch method. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-15/edit-mode/edit-mode.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finding distances </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have a tagged navigation mode, we can begin to display distances. </font><font style="vertical-align: inherit;">We will select a cell and then display the distance from this cell to all the cells on the map.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Distance display </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To track the distance to the cell, add to the </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integer field </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will indicate the distance between this cell and the selected one. </font><font style="vertical-align: inherit;">Therefore, it will be zero for the selected cell itself, 1 for the immediate neighbor, and so on.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the distance is set, we need to update the cell label to display its value. </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has a link to the </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI object. </font><font style="vertical-align: inherit;">We will need to call him </font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get to the cell. </font><font style="vertical-align: inherit;">Consider what </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is in the namespace </font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so use it at the beginning of the script.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shouldn't we keep a direct link to the Text component?</font></font></b> <div class="spoiler_text"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Make the common property get and set the distance to the cell, as well as update its label. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add to the </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">general method </font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the cell parameter. </font><font style="vertical-align: inherit;">For now, we will simply set the zero distance to each cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the edit mode is not enabled, then we </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">call the new method with the current cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Distances between coordinates </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now in the navigation mode after touching one of them, all cells display zero. </font><font style="vertical-align: inherit;">But, of course, they should display the true distance to the cell. </font><font style="vertical-align: inherit;">To calculate the distance to them, we can use the coordinates of the cell. </font><font style="vertical-align: inherit;">Therefore, suppose you </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have a method </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use it in </font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now add to the </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">He must compare his own coordinates with the coordinates of another set. </font><font style="vertical-align: inherit;">Let's start with just measuring X, and subtract X coordinates from each other.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we get the offset along X relative to the selected cell. </font><font style="vertical-align: inherit;">But the distances can not be negative, so you need to return the difference of coordinates X modulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distances in X.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So we get the right distances, only if we take into account only one dimension. </font><font style="vertical-align: inherit;">But in the grid of hexagons three dimensions. </font><font style="vertical-align: inherit;">So let's add distances in all three dimensions and see what it gives us.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sum of the XYZ distances. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that we get double the distance. </font><font style="vertical-align: inherit;">That is, to get the correct distance, this amount should be divided in half.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real distances.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is the sum equal to twice the distance?</font></font></b> <div class="spoiler_text">  ,       .      ,  (1, ‚àí3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-15/finding-distances/finding-distances.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Work with obstacles </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The distances we calculate correspond to the shortest paths from the selected cell to every other cell. </font><font style="vertical-align: inherit;">We can not find a shorter way. </font><font style="vertical-align: inherit;">But these paths are guaranteed to be correct if the route does not block anything. </font><font style="vertical-align: inherit;">Cliffs, water and other obstacles can make us go around. </font><font style="vertical-align: inherit;">Some cells may not be able to be reached at all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To find a way around obstacles, we need to use a different approach instead of simply calculating the distance between the coordinates. </font><font style="vertical-align: inherit;">We can no longer treat each cell separately. </font><font style="vertical-align: inherit;">We will have to perform a search on the map until we find every cell that can be reached.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search visualization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map search is an iterative process. </font><font style="vertical-align: inherit;">To understand what we are doing, it would be useful to see each stage of the search. </font><font style="vertical-align: inherit;">We can do this by turning the search algorithm into a quortenine, for which we will need a search space </font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The refresh rate of 60 iterations per second is small enough for us to see what is happening, and the search on a small map does not take too much time.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to make it so that at any time only one search is active. </font><font style="vertical-align: inherit;">Therefore, before starting a new search, we stop all the Korutins.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition, we need to complete the search when loading a new map. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search Breadth (Breadth-First Search) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even before we start the search, we know that the distance to the selected cell is zero. And, of course, the distance to all its neighbors is 1 if they can be reached. Then we can take a look at one of these neighbors. This cell most likely has its own neighbors, which can be reached and which have not yet calculated the distance. If so, then the distance to these neighbors should be 2. We can repeat this process for all neighbors at a distance of 1. After that we repeat it for all neighbors at a distance of 2. And so on, until we reach all the cells.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, first we find all the cells at a distance of 1, then we find everything at a distance of 2, then at a distance of 3, and so on, until we finish. </font><font style="vertical-align: inherit;">This ensures that we find the smallest distance to each reachable cell. </font><font style="vertical-align: inherit;">This algorithm is called breadth-first search. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To make it work, we need to know if we have already determined the distance to the cell. </font><font style="vertical-align: inherit;">Often, cells are placed in a collection called a ready-made or closed set for this. </font><font style="vertical-align: inherit;">But we can set the distance to the cell value </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to indicate that we have not visited it yet. </font><font style="vertical-align: inherit;">We need to do this for all the cells right before performing the search.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also use this to hide all unvisited cells by changing </font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">After that we will begin each search on an empty map.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we need to track the cells that need to be visited, and the order of their visit. </font><font style="vertical-align: inherit;">Such a collection is often called a border or an open set. </font><font style="vertical-align: inherit;">We just need to process the cells in the same order in which we met them. </font><font style="vertical-align: inherit;">You can use a queue for this </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is part of the namespace </font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The selected cell will be the first to be placed in this queue, and will have a distance of 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From this point on, the algorithm performs a loop while there is something in the queue. </font><font style="vertical-align: inherit;">At each iteration, the frontmost cell is extracted from the queue.</font></font><br><br><pre> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have the current cell, which can be at any distance. </font><font style="vertical-align: inherit;">Next, we need to add all its neighbors to the queue one step further from the selected cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But we need to add only those cells that have not yet been assigned a distance. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Search wide.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avoid water </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After making sure that a wider search finds the correct distances on a flat map, we can begin to add obstacles. </font><font style="vertical-align: inherit;">This can be done by refusing to add cells to the queue if certain conditions are met. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, we are already missing some cells: those that do not exist, and those to which we have already indicated the distance. </font><font style="vertical-align: inherit;">Let's rewrite the code so that we explicitly skip the neighbors in this case.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's also skip all the cells that are under water. </font><font style="vertical-align: inherit;">This means that when searching for the shortest distances we consider only the movement on the ground.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distances without moving through the water. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm still finds the shortest distances, but now it avoids all the water. </font><font style="vertical-align: inherit;">Therefore, submarine cells never receive distances, as do isolated plots of land. </font><font style="vertical-align: inherit;">An underwater cell receives a distance only if it is selected.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avoid cliffs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, to determine the possibility of visiting a neighbor, we can use the type of edge. </font><font style="vertical-align: inherit;">For example, you can make the cliffs block the path. </font><font style="vertical-align: inherit;">If you allow movement on the slopes, the cells on the other side of the cliff can still be reachable, only along other paths. </font><font style="vertical-align: inherit;">Therefore, they can be at very different distances.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distances without crossing cliffs. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-15/dealing-with-obstacles/dealing-with-obstacles.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relocation costs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can avoid cells and edges, but these options are binary. </font><font style="vertical-align: inherit;">It can be imagined that it is easier to move in some directions than in others. </font><font style="vertical-align: inherit;">In this case, the distance is measured in labor or time.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fast roads </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will be logical that it is easier and faster to travel along the roads, so let's make the intersection of the edges with the roads less costly. </font><font style="vertical-align: inherit;">Since we use integer values ‚Äã‚Äãto set the distance, we will leave the cost of traveling on roads equal to 1, and we will increase the cost of crossing other edges to 10. This is a big difference, which allows us to immediately see if we get the right results.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads with wrong distances.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Border sorting </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, it turns out that a wide search cannot work with variable translation costs. </font><font style="vertical-align: inherit;">He assumes that the cells are added to the border in order of increasing distance, but for us this is irrelevant. </font><font style="vertical-align: inherit;">We need a priority queue, that is, a queue that sorts itself. </font><font style="vertical-align: inherit;">There are no standard priority queues, because you cannot program them so that they fit all situations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can create our own queue with priority, but we will leave its optimization for the next tutorial. </font><font style="vertical-align: inherit;">For now, we simply replace the queue with a list that has a method </font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unless it is impossible to use ListPool &lt;HexCell&gt;?</font></font></b> <div class="spoiler_text"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To make the border true, we need to sort it after adding a cell to it. </font><font style="vertical-align: inherit;">In fact, we can postpone sorting until all the neighbors of the cell are added, but, I repeat, we are not interested in optimizations yet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We want to sort the cells by distance. </font><font style="vertical-align: inherit;">To do this, we need to call the list sorting method with reference to the method that performs this comparison.</font></font><br><br><pre> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does this Sort method work?</font></font></b> <div class="spoiler_text">     .     ,       .        . <br><br><pre> <code class="cs hljs"> frontier.Sort(CompareDistances); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sorted border is still not valid.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Border update </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the border began to be sorted, we began to get better results, but errors still exist. This is because when a cell is added to the boundary, we do not necessarily find the shortest distance to that cell. This means that now we can no longer miss neighbors who have already been assigned a distance. Instead, we need to check if we have found a shorter way. If so, then we need to change the distance to the neighbor, instead of adding it to the border.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The correct distances. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when we get the right distances, we start to consider the cost of moving. </font><font style="vertical-align: inherit;">You may notice that the distances to some cells are initially too large, but are corrected when they are removed from the border. </font><font style="vertical-align: inherit;">This approach is called the Dijkstra algorithm, it is named after Edsger Dijkstra, who first invented it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Slopes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We do not want to limit ourselves to differing costs only for roads. </font><font style="vertical-align: inherit;">For example, you can reduce the cost of crossing flat edges without roads to 5, leaving 10 for slopes without roads.</font></font><br><br><pre> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To overcome the slopes need to make more work, and the roads are always fast.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objects of relief </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can add costs in the presence of terrain objects. </font><font style="vertical-align: inherit;">For example, in many games in the woods to move more difficult. </font><font style="vertical-align: inherit;">In this case, we simply add to the distance all levels of objects. </font><font style="vertical-align: inherit;">And here again the road accelerates everything.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objects slow down if there is no road.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Walls </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, let's take the walls into account. </font><font style="vertical-align: inherit;">Walls should block movement if the road does not pass through them.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The walls do not let us through, you need to look for the gate. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-15/movement-costs/movement-costs.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/425919/">https://habr.com/ru/post/425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425905/index.html">How to write an assembler program with overlapping instructions (another bytecode obfuscation technique)</a></li>
<li><a href="../425907/index.html">Making a machine learning project in Python. Part 2</a></li>
<li><a href="../425911/index.html">Moving cloud CRM to boxed version</a></li>
<li><a href="../425915/index.html">How inter-transport communication can replace traffic lights and shorten the way to work</a></li>
<li><a href="../425917/index.html">The fighter for justice did not give Waymo to patent the key technology of lidar</a></li>
<li><a href="../425921/index.html">Meet the .NET community at CLRium # 4 + online</a></li>
<li><a href="../425923/index.html">25 years DOOM</a></li>
<li><a href="../425925/index.html">3D printing in creating layouts on the example of STUDIO 911</a></li>
<li><a href="../425927/index.html">Weather Station on Arduino from A to Z. Part 2</a></li>
<li><a href="../425929/index.html">Google Corporation has abandoned the struggle for the billionth Pentagon contract</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>