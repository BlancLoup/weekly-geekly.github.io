<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MindStream. How do we write software under FireMonkey. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 . 

 Hello. 

 In this article I will continue the story about how we write under FireMonkey. 2 interesting objects will be added. Both will re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MindStream. How do we write software under FireMonkey. Part 2</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/232955/">Part 1</a> . <br><br>  Hello. <br><br>  In this article I will continue the story about how we write under FireMonkey.  2 interesting objects will be added.  Both will remind us of vector algebra and trigonometry.  Also in the post will be shown techniques from the PLO, which we use. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  A number of lines (differing only in dotted line, dot-dash, point-to-point, etc), which we added, were made by analogy with the description of the previous primitives.  Now is the time to move to more complex shapes (including composite ones). <br><br>  The first primitive that we add will be a line with an arrow (an arrow will draw a regular triangle, but smaller sizes). <br><br>  To begin, we introduce a triangle that "looks to the right."  To do this, we will inherit the usual triangle and rewrite the Polygon method, which is responsible for the coordinates of the vertices. <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsTriangleDirectionRight</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Polygon</span></span></span><span class="hljs-function">:</span></span> TPolygon; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(Result, <span class="hljs-number"><span class="hljs-number">4</span></span>); Result[<span class="hljs-number"><span class="hljs-number">0</span></span>] := TPointF.Create(StartPoint.X - InitialHeight / <span class="hljs-number"><span class="hljs-number">2</span></span>, StartPoint.Y - InitialHeight / <span class="hljs-number"><span class="hljs-number">2</span></span>); Result[<span class="hljs-number"><span class="hljs-number">1</span></span>] := TPointF.Create(StartPoint.X - InitialHeight / <span class="hljs-number"><span class="hljs-number">2</span></span>, StartPoint.Y + InitialHeight / <span class="hljs-number"><span class="hljs-number">2</span></span>); Result[<span class="hljs-number"><span class="hljs-number">2</span></span>] := TPointF.Create(StartPoint.X + InitialHeight / <span class="hljs-number"><span class="hljs-number">2</span></span>, StartPoint.Y); Result[<span class="hljs-number"><span class="hljs-number">3</span></span>] := Result[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br>  Here are our triangles: <br><br><img src="https://habrastorage.org/files/c29/86a/3f7/c2986a3f7c474cf7a3b5b195a53649ba.PNG"><br><br>  Next, inherit the so-called "small triangle": <br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TmsSmallTriangle</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TmsTriangleDirectionRight) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillColor</span></span></span><span class="hljs-function">:</span></span> TAlphaColor; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitialHeight</span></span></span><span class="hljs-function">:</span></span> Single; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TmsSmallTriangle</span></span></code> </pre><br><br>  As we see, all that we have done is to redefine the functions unique to the new triangle. <br><br>  The next class will add a line with an arrow, which we will inherit from the usual line.  The class will override only the procedure for drawing the primitive itself, that is, the line will draw the base class, but the triangle will inherit. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsLineWithArrow</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoDrawTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCtx: TmsDrawContext)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l_Proxy : TmsShape; l_OriginalMatrix: TMatrix; l_Matrix: TMatrix; l_Angle : Single; l_CenterPoint : TPointF; l_TextRect : TRectF; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StartPoint &lt;&gt; FinishPoint) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> l_OriginalMatrix := aCtx.rCanvas.Matrix; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> l_Proxy := TmsSmallTriangle.Create(FinishPoint); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//       0 , //        l_Angle := DegToRad(0); l_CenterPoint := TPointF.Create(FinishPoint.X , FinishPoint.Y); //    l_Matrix := l_OriginalMatrix; //           l_Matrix := l_Matrix * TMatrix.CreateTranslation(-l_CenterPoint.X, -l_CenterPoint.Y); //  -   l_Matrix := l_Matrix * TMatrix.CreateRotation(l_Angle); //      l_Matrix := l_Matrix * TMatrix.CreateTranslation(l_CenterPoint.X, l_CenterPoint.Y); //        aCanvas.SetMatrix(l_Matrix); //  l_Proxy.DrawTo(aCanvas, aOrigin); finally FreeAndNil(l_Proxy); end; // try..finally finally //       ,    . aCanvas.SetMatrix(l_OriginalMatrix); end; end;//(StartPoint &lt;&gt; FinishPoint) end;</span></span></code> </pre><br><br>  There is nothing special to analyze here, everything is already indicated in the comments, but for those who want to remember what vector algebra is and how it works with vector graphics (moving, rotating various shapes, etc.), I recommend a <a href="http://habrahabr.ru/post/126269/">wonderful post on Habr√©</a> on this topic, but There are also <a href="http://mathprofi.ru/vektory_dlya_chainikov.html">vectors for dummies.</a>  <a href="http://mathprofi.ru/vektory_dlya_chainikov.html">Actions with vectors.</a>  <a href="http://mathprofi.ru/vektory_dlya_chainikov.html">Coordinates of the vector.</a>  <a href="http://mathprofi.ru/vektory_dlya_chainikov.html">The simplest problems with vectors ‚Äù</a> and <a href="http://mathprofi.ru/linejnaja_nezavisimost_vektorov_bazis_vektorov.html">‚Äú Linear dependence and linear independence of vectors.</a>  <a href="http://mathprofi.ru/linejnaja_nezavisimost_vektorov_bazis_vektorov.html">The basis of vectors.</a>  <a href="http://mathprofi.ru/linejnaja_nezavisimost_vektorov_bazis_vektorov.html">Affine coordinate system "</a> . <br><br>  As you can see from the picture, our triangle is currently drawn only when we draw a line from left to right: <br><br><img src="https://habrastorage.org/files/048/82f/e46/04882fe469c54df88802c4357616442e.PNG"><br><br>  Further the task becomes more interesting.  We need to rotate the triangle, right perpendicular to the line that drew it.  To do this, we introduce the GetArrowAngleRotation method, which will calculate the rotation angle. <br>  To do this, imagine that our line is the hypotenuse of a right triangle;  then we find the angle with the leg, which will be the angle of rotation of the triangle relative to the line: <br><br><img src="https://habrastorage.org/files/7b3/dc6/86c/7b3dc686cbec48de92804c9e97e239ba.PNG"><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsLineWithArrow</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetArrowAngleRotation</span></span></span><span class="hljs-function">:</span></span> Single; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l_ALength, l_CLength, l_AlphaAngle, l_X, l_Y, l_RotationAngle: Single; l_PointC: TPointF; l_Invert: SmallInt; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       l_X := (FinishPoint.X - StartPoint.X) * (FinishPoint.X - StartPoint.X); l_Y := (FinishPoint.Y - StartPoint.Y) * (FinishPoint.Y - StartPoint.Y); //      l_CLength := sqrt(l_X + l_Y); l_PointC := TPointF.Create(FinishPoint.X, StartPoint.Y); //       l_X := (l_PointC.X - StartPoint.X) * (l_PointC.X - StartPoint.X); l_Y := (l_PointC.Y - StartPoint.Y) * (l_PointC.Y - StartPoint.Y); //    l_ALength := sqrt(l_X + l_Y); //    l_AlphaAngle := ArcSin(l_ALength / l_CLength); l_RotationAngle := 0; l_Invert := 1; if FinishPoint.X &gt; StartPoint.X then begin l_RotationAngle := Pi / 2 * 3; if FinishPoint.Y &gt; StartPoint.Y then l_Invert := -1; end else begin l_RotationAngle := Pi / 2; if FinishPoint.Y &lt; StartPoint.Y then l_Invert := -1; end; Result := l_Invert * (l_AlphaAngle + l_RotationAngle); end;</span></span></code> </pre><br>  Now our line looks like this: <br><br><br>  The next object we add will be responsible for moving the shapes. <br><br>  The algorithm that we use: <br>  1. We need a method to determine if a point hits a specific figure, say, ContainsPt, for each figure;  since the formulas for calculating the hit for each figure are unique, we use virtual functions. <br>  2. We need the following method to determine which piece we hit, if they intersect.  Since the figures fall into the list as they appear on the form, for the case of the intersection of the figures, that of the figures that is at the top of the list is the last one that appears, respectively, "above".  In fact, there is a puncture in this logic, but for the time being we‚Äôll decide that this is correct and leave corrections for the next post. <br>  3. When you first click on a shape that you hit, we must change its outline or a number of other characteristics. <br>  4. With the second click, we have to move the shape that we hit. <br><br>  The relocation class itself will be inherited from the standard shape, but it will keep in itself the shape that it moves, and it was he who, with the second click (in the last post I described what the line drawing feature) will redraw the shape. <br><br>  We implement the methods that I described. <br>  1. The method determines whether a point falls into a shape (in our case, a rectangle): <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsRectangle</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainsPt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aPoint: TPointF)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l_Finish : TPointF; l_Rect: TRectF; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; l_Finish := TPointF.Create(StartPoint.X + InitialWidth, StartPoint.Y + InitialHeight); l_Rect := TRectF.Create(StartPoint,l_Finish); Result := l_Rect.Contains(aPoint); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  2. When pressed, this method answers our question - what kind of figure did we hit: <br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsShape</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShapeByPt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aPoint: TPointF; aList: TmsShapeList)</span></span></span><span class="hljs-function">:</span></span> TmsShape; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l_Shape: TmsShape; l_Index: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l_Index := aList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> l_Shape := aList.Items[l_Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> l_Shape.ContainsPt(aPoint) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := l_Shape; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">// l_Shape.ContainsPt(aPoint) end; // for l_Index end;</span></span></code> </pre><br><br>  3. When you first click on a shape that you hit, we must change its outline or a number of other characteristics. <br>  To implement the following method we will do a little refactoring.  We introduce the so-called ‚Äúdrawing context‚Äù: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TmsDrawContext = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> rCanvas: TCanvas; rOrigin: TPointF; rMoving: Boolean; <span class="hljs-comment"><span class="hljs-comment">// - ,     -  constructor Create(const aCanvas: TCanvas; const aOrigin: TPointF); end; // TmsDrawContext</span></span></code> </pre><br>  If we indicate to the figure in the context of drawing that it is ‚Äúmoved‚Äù, then drawing will be different. <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsShape</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCtx: TmsDrawContext)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> aCtx.rCanvas.Fill.Color := FillColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aCtx.rMoving <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> aCtx.rCanvas.Stroke.Dash := TStrokeDash.sdDashDot; aCtx.rCanvas.Stroke.Color := TAlphaColors.Darkmagenta; aCtx.rCanvas.Stroke.Thickness := <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> aCtx.rCanvas.Stroke.Dash := StrokeDash; aCtx.rCanvas.Stroke.Color := StrokeColor; aCtx.rCanvas.Stroke.Thickness := StrokeThickness; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; DoDrawTo(aCtx); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><br>  4. With the second click, we have to move the shape that we hit. <br>  To begin with, we introduce a factory method that is responsible for building the shape (we need a list of shapes so that TmsMover can refer to all the shapes that are drawn within the current chart). <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsShape</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStartPoint: TPointF; aListWithOtherShapes: TmsShapeList)</span></span></span><span class="hljs-function">:</span></span> TmsShape; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Create(aStartPoint); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsMover</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStartPoint: TPointF; aListWithOtherShapes: TmsShapeList)</span></span></span><span class="hljs-function">:</span></span> TmsShape; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l_Moving: TmsShape; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     l_Moving := ShapeByPt(aStartPoint, aListWithOtherShapes); if (l_Moving &lt;&gt; nil) then Result := Create(aStartPoint, aListWithOtherShapes, l_Moving) else Result := nil; end;</span></span></code> </pre><br><br>  Through the use of the class function, we fundamentally divided the creation of the object of movement and all the other figures.  However, this approach has a negative side.  For example, we entered the creation parameter aListWithOtherShapes, which is completely unnecessary for other figures. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TmsMover</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TmsShape) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> f_Moving: TmsShape; f_ListWithOtherShapes: TmsShapeList; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoDrawTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCtx: TmsDrawContext)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStartPoint: TPointF; aListWithOtherShapes: TmsShapeList; aMoving: TmsShape)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStartPoint: TPointF; aListWithOtherShapes: TmsShapeList)</span></span></span><span class="hljs-function">:</span></span> TmsShape; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsNeedsSecondClick</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aFinishPoint: TPointF)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TmsMover implementation uses msRectangle, FMX.Types, System.SysUtils; constructor TmsMover.Create(const aStartPoint: TPointF; aListWithOtherShapes: TmsShapeList; aMoving: TmsShape); begin inherited Create(aStartPoint); f_ListWithOtherShapes := aListWithOtherShapes; f_Moving := aMoving; end; class function TmsMover.Make(const aStartPoint: TPointF; aListWithOtherShapes: TmsShapeList): TmsShape; var l_Moving: TmsShape; begin l_Moving := ShapeByPt(aStartPoint, aListWithOtherShapes); if (l_Moving &lt;&gt; nil) then Result := Create(aStartPoint, aListWithOtherShapes, l_Moving) else Result := nil; end; class function TmsMover.IsNeedsSecondClick: Boolean; begin Result := true; end; procedure TmsMover.EndTo(const aFinishPoint: TPointF); begin if (f_Moving &lt;&gt; nil) then f_Moving.MoveTo(aFinishPoint); f_ListWithOtherShapes.Remove(Self); // -    ,      ,       end; procedure TmsMover.DoDrawTo(const aCtx: TmsDrawContext); var l_Ctx: TmsDrawContext; begin if (f_Moving &lt;&gt; nil) then begin l_Ctx := aCtx; l_Ctx.rMoving := true; f_Moving.DrawTo(l_Ctx); end; // f_Moving &lt;&gt; nil end; initialization TmsMover.Register; end.</span></span></code> </pre><br><br><br>  In the controller, we only need to change the methods for creating shapes: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsDiagramm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStart: TPointF)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Assert(CurrentClass &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); FCurrentAddedShape := CurrentClass.Make(aStart, FShapeList); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FCurrentAddedShape &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FShapeList.Add(FCurrentAddedShape); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FCurrentAddedShape.IsNeedsSecondClick <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">// -    SecondClick,    -  FCurrentAddedShape := nil; Invalidate; end; // FCurrentAddedShape &lt;&gt; nil end; procedure TmsDiagramm.EndShape(const aFinish: TPointF); begin Assert(CurrentAddedShape &lt;&gt; nil); CurrentAddedShape.EndTo(aFinish); FCurrentAddedShape := nil; Invalidate; end;</span></span></code> </pre><br><br>  Calling CurrentAddedShape.EndTo (aFinish) in the case of a mover will cause MoveTo, that is, move the shape;  redrawing, as seen above, is initiated by the controller: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsMover</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aFinishPoint: TPointF)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f_Moving &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> f_Moving.MoveTo(aFinishPoint); f_ListWithOtherShapes.Remove(Self); <span class="hljs-comment"><span class="hljs-comment">// -    ,          end;</span></span></code> </pre><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsShape</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aFinishPoint: TPointF)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FStartPoint := aFinishPoint; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Since the controller is responsible for the logic of the behavior of the figures, we will move the checkout method ‚Äúhitting the figure‚Äù to the controller, and when creating objects we will transfer the check function: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TmsShapeByPt = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aPoint: TPointF)</span></span></span><span class="hljs-function">:</span></span> TmsShape <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStartPoint: TPointF; aShapeByPt: TmsShapeByPt)</span></span></span><span class="hljs-function">:</span></span> TmsShape; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsDiagramm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStart: TPointF)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Assert(CurrentClass &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    FCurrentAddedShape := CurrentClass.Make(aStart, Self.ShapeByPt); if (FCurrentAddedShape &lt;&gt; nil) then begin FShapeList.Add(FCurrentAddedShape); if not FCurrentAddedShape.IsNeedsSecondClick then // -    SecondClick,    -  FCurrentAddedShape := nil; Invalidate; end;//FCurrentAddedShape &lt;&gt; nil end;</span></span></code> </pre><br><br>  Since it is necessary to transfer 2 parameters to create objects, we create a ‚Äúcreation‚Äù context: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TmsMakeShapeContext = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> rStartPoint: TPointF; rShapeByPt: TmsShapeByPt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aStartPoint: TPointF; aShapeByPt: TmsShapeByPt)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;<span class="hljs-comment"><span class="hljs-comment">//TmsMakeShapeContext</span></span></code> </pre><br><br>  Add the interfaces that the controller will implement, and also add the class of the interface object.  In the future, we will implement our own reference counting in it. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TmsInterfacedNonRefcounted = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IID: TGUID; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Obj)</span></span></span><span class="hljs-function">:</span></span> HResult; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRef</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;<span class="hljs-comment"><span class="hljs-comment">//TmsInterfacedNonRefcounted TmsShape = class; ImsShapeByPt = interface function ShapeByPt(const aPoint: TPointF): TmsShape; end;//ImsShapeByPt ImsShapesController = interface procedure RemoveShape(aShape: TmsShape); end;//ImsShapeRemover</span></span></code> </pre><br><br>  Change the TmsMakeShapeContext slightly: <br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TmsMakeShapeContext = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> rStartPoint: TPointF; rShapesController: ImsShapesController; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aStartPoint: TPointF; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aShapesController: ImsShapesController)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TmsMakeShapeContext</span></span></code> </pre><br><br>  In more detail about interfaces and features of working with them in Delphi I recommend 2 interesting posts: <br><br>  <a href="http://18delphi.blogspot.com/2013/04/iunknown.html">18delphi.blogspot.com/2013/04/iunknown.html</a> <br>  <a href="http://habrahabr.ru/post/181107/">habrahabr.ru/post/181107</a> <br><br>  Let's make our controller (TmsDiagramm) inherited from TmsInterfacedNonRefcounted and interfaces and change one line in the BeginShape method. <br>  It was: <br><pre> <code class="delphi hljs"> FCurrentAddedShape := CurrentClass.Make(aStart, Self.ShapeByPt);</code> </pre><br>  It became: <br><pre> <code class="delphi hljs"> FCurrentAddedShape := CurrentClass.Make(TmsMakeShapeContext.Create(aStart, Self));</code> </pre><br><br>  In the case of a move, the EndTo method, which is called in a mover, will look like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsMover</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCtx: TmsEndShapeContext)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f_Moving &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> f_Moving.MoveTo(aCtx.rStartPoint); f_Moving := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; aCtx.rShapesController.RemoveShape(Self); <span class="hljs-comment"><span class="hljs-comment">// -     end;</span></span></code> </pre><br><br>  In the last post, I talked about how we hid ‚Äúunique settings‚Äù (fill color, thickness of lines, etc.) in virtual methods that each figure sets by itself.  For example: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsTriangle</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillColor</span></span></span><span class="hljs-function">:</span></span> TAlphaColor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TAlphaColorRec.Green; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  All figure settings are ‚Äúpackaged‚Äù in context: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TmsDrawOptionsContext = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> rFillColor: TAlphaColor; rStrokeDash: TStrokeDash; rStrokeColor: TAlphaColor; rStrokeThickness: Single; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCtx: TmsDrawContext)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;<span class="hljs-comment"><span class="hljs-comment">//TmsDrawOptionsContext</span></span></code> </pre><br><br>  In the TmsShape class, we do a virtual procedure by analogy with the previous example.  In the future, we will easily expand the number of settings unique to the shape: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsTriangle</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransformDrawOptionsContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> theCtx: TmsDrawOptionsContext)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; theCtx.rFillColor := TAlphaColorRec.Green; theCtx.rStrokeColor := TAlphaColorRec.Blue; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Thanks to the context, we remove the logic (do we draw mover?) From the drawing method and hide it in the record constructor: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsDrawOptionsContext</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCtx: TmsDrawContext)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rFillColor := TAlphaColorRec.Null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aCtx.rMoving <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rStrokeDash := TStrokeDash.sdDashDot; rStrokeColor := TAlphaColors.Darkmagenta; rStrokeThickness := <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">// aCtx.rMoving else begin rStrokeDash := TStrokeDash.sdSolid; rStrokeColor := TAlphaColorRec.Black; rStrokeThickness := 1; end; // aCtx.rMoving end;</span></span></code> </pre><br><br>  After that, our method for drawing will look like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsShape</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCtx: TmsDrawContext)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l_Ctx: TmsDrawOptionsContext; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> l_Ctx := DrawOptionsContext(aCtx); aCtx.rCanvas.Fill.Color := l_Ctx.rFillColor; aCtx.rCanvas.Stroke.Dash := l_Ctx.rStrokeDash; aCtx.rCanvas.Stroke.Color := l_Ctx.rStrokeColor; aCtx.rCanvas.Stroke.Thickness := l_Ctx.rStrokeThickness; DoDrawTo(aCtx); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsShape</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawOptionsContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCtx: TmsDrawContext)</span></span></span><span class="hljs-function">:</span></span> TmsDrawOptionsContext; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := TmsDrawOptionsContext.Create(aCtx); <span class="hljs-comment"><span class="hljs-comment">//       TransformDrawOptionsContext(Result); end;</span></span></code> </pre><br><br>  All that is left for us to move our objects is to write a ContainsPt method for each piece, which will check if a point has fallen into a shape.  Regular trigonometry, all the formulas are on the Internet. <br><br><br><br><br>  Slightly remake the registration of objects in the container.  Now each class "registers" itself.  We take out the registration in a separate module. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> msOurShapes; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> msLine, msRectangle, msCircle, msRoundedRectangle, msUseCaseLikeEllipse, msTriangle, msDashDotLine, msDashLine, msDotLine, msLineWithArrow, msTriangleDirectionRight, msMover, msRegisteredShapes ; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterOurShapes</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TmsRegisteredShapes.Instance.<span class="hljs-keyword"><span class="hljs-keyword">Register</span></span>([ TmsLine, TmsRectangle, TmsCircle, TmsRoundedRectangle, TmsUseCaseLikeEllipse, TmsTriangle, TmsDashDotLine, TmsDashLine, TmsDotLine, TmsLineWithArrow, TmsTriangleDirectionRight, TmsMover ]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">initialization</span></span> RegisterOurShapes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br><br>  In the container we will add the registration method: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsRegisteredShapes</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aShapes: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">array</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">of</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RmsShape)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l_Index: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l_Index := Low(aShapes) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> High(aShapes) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Self.<span class="hljs-keyword"><span class="hljs-keyword">Register</span></span>(aShapes[l_Index]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TmsRegisteredShapes</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aValue: RmsShape)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Assert(f_Registered.IndexOf(aValue) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>); f_Registered.Add(aValue); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><img src="http://3.bp.blogspot.com/-z1jXHdeAunk/U_7kbPk8NzI/AAAAAAAAIew/NQCm8KBQycw/s1600/UML.png"><br><br>  <a href="https://bitbucket.org/ingword/mindstream/branch/Developing">Link to the repository.</a> <br><br>  In this post, we tried to show how, through the use of contexts, interfaces and the factory method, make your life easier.  More details about the factory method can be found <a href="http://18delphi.blogspot.ru/2013/04/blog-post_7483.html">here</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B1%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">here</a> . <br><br>  In the next post we will tell about how we "screwed" DUnit to FireMonkey.  And we will write several tests, some of which will immediately cause an error. <br><br>  <a href="http://habrahabr.ru/post/241301/">Part 3</a> <br>  <a href="http://habrahabr.ru/post/241377/">Part 3.1</a> </div><p>Source: <a href="https://habr.com/ru/post/234801/">https://habr.com/ru/post/234801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234791/index.html">We are testing a new type of backup MySQL</a></li>
<li><a href="../234795/index.html">Seagate launches 8TB HDD</a></li>
<li><a href="../234797/index.html">What is worth remembering when choosing a cloud for backup</a></li>
<li><a href="../2348/index.html">The creators of South Park are allowed to download the cartoon from the Internet</a></li>
<li><a href="../23480/index.html">"Social startups" will be grown in incubators</a></li>
<li><a href="../234803/index.html">Your anonymous publications in Secret are not anonymous.</a></li>
<li><a href="../234807/index.html">The spacecraft "New Horizons" orbited Neptune: Pluto is getting closer</a></li>
<li><a href="../234809/index.html">Instagram "coming down from the clouds" Amazon to Facebook data centers</a></li>
<li><a href="../234813/index.html">Show Sound # 15 - Podcast about audio equipment, components, formats and technologies</a></li>
<li><a href="../234819/index.html">To wash or not to wash? Foursquare for clean drivers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>