<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Correct work with date and time in Ruby on Rails</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Andrey Novikov and recently I am working on a project to develop an application that is used in different parts of our country and a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Correct work with date and time in Ruby on Rails</h1><div class="post__text post__text-html js-mediator-article"> Hello!  My name is Andrey Novikov and recently I am working on a project to develop an application that is used in different parts of our country and automates the work of people.  In each specific time zone, our application needs to correctly receive, save and display time, both in the past and in the future - for example, calculate the beginning of a work shift and also display it correctly: count the time until the end of the shift, show how many people drove to the point of destination and determine whether they met the standard, as well as much, much more. <br><br> <a href="http://habrahabr.ru/company/at_consulting/blog/266681/"><img src="https://habrastorage.org/files/97c/873/5a4/97c8735a400a4e7bab8ca20e2ccb5a62.jpg"></a> <br><br>  Over the past few years I've been writing on Ruby on Rails, I have not had to face such problems - before that, all my applications worked in the same time zone.  And then suddenly I had to sweat a lot, catching the most different mistakes and trying to figure out how to work with the date and time so that they could be avoided in the future. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a result, today I have something to share with you.  If you regularly meet with the fact that the time is saved or displayed incorrectly with a characteristic spread of several hours (3 hours for Moscow), some night recordings migrate to neighboring days, and the time stubbornly displays not as users want, and you don‚Äôt you know what to do with all this - welcome under cat. <br><a name="habracut"></a><br>  So, the first and most important thing - what is the time with which we operate in everyday life and what does it consist of? <br>  In ordinary life, we operate with some <b>local time</b> , which operates where we live, however, it is difficult and dangerous to work with computer systems with it - due to the transfer of hours (summer time, the State Duma, etc.) it is uneven and ambiguous ( more on this later).  Therefore, it takes some <b>universal time</b> , which has uniformity and unambiguity (here a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D0%25BA%25D1%2583%25D0%25BD%25D0%25B4%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">leap second</a> bursts into the article and spoils everything, but we will not talk about it), one value of which reflects the same moment of time at any point on Earth (physics, be silent! ) - a single point of reference, its role is played by <a href="https://ru.wikipedia.org/wiki/UTC">UTC</a> - universal time coordinated.  And we also need <b>time zones</b> ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B0%25D1%2581%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25BE%25D0%25BD%25D0%25B0">time zones</a> in modern terminology) to convert local time to universal and vice versa. <br><br>  And what exactly is the time zone? <br><br>  First is the offset from UTC.  That is, how many hours and minutes our local time differs from UTC.  Note that this does not have to be an integer number of hours.  For example, India, Nepal, Iran, New Zealand, parts of Canada and Australia and many others live with distinction from UTC at X 30 minutes or X 45 hours.  Moreover, at some moments on the Earth, there are as many as three dates - yesterday, today and tomorrow, since the difference between the extreme time zones is 26 hours. <br><br>  Secondly, these are daylight saving time rules.  Among countries that have time zones with the same offset, some do not switch to summer time at all, some switch to some numbers, others to others.  Some in the summer, some in the winter (yes, we have the southern hemisphere).  Some countries (including Russia) switched to summer time earlier, but wisely abandoned this idea.  And to correctly display the date and time in the past, all this must be taken into account.  It is important to remember that when switching to summer time, it is the shift that was changing (it was in Moscow before +3 hours in winter, it became +4 in summer). <br><br>  In computers, information for working with this madness is stored in the corresponding databases, all good libraries for working with time are able to take into account all these terrible features. <br><br>  Windows seems to have some kind of base of its own, and in almost all of the open-world world, the de facto standard is the <b>IANA Time Zone Database</b> , better known as <a href="https://www.iana.org/time-zones">tzdata</a> .  It contains the history of all time zones since the beginning of the Unix era, that is, since January 1, 1970: what time zones appeared when, what when disappeared (and what they poured in), where and when they switched to summer time, how they lived on it and when it was canceled.  Each time zone is designated as a Region / Place, for example, the Moscow time zone is called Europe / Moscow.  Tzdata is used in GNU / Linux, Java, Ruby (tzinfo gems), PostgreSQL, MySQL and many more. <br><br>  In Ruby on Rails, the <code>ActiveSupport::TimeZone</code> class is <code>ActiveSupport::TimeZone</code> for working with time zones. It is supplied as part of the <code>ActiveSupport</code> library from the standard Ruby on Rails <code>ActiveSupport</code> .  It is a wrapper around the <a href="https://github.com/tzinfo/tzinfo">tzinfo gem</a> , which, in turn, provides a ruby ‚Äã‚Äãinterface to <a href="https://www.iana.org/time-zones">tzdata</a> .  It provides methods for working with time, and is also actively used in the ActiveSupport extended Time class from the standard Ruby library to fully work with time zones.  Well, in the class <code>ActiveSupport::TimeWithZone</code> from Ruby on Rails, which is stored in itself not only the time with the offset, but also the time zone itself.  Many methods at the time zone return <code>ActiveSupport::TimeWithZone</code> , but in most cases you will not even feel it.  What is the difference between these two classes is written in the <a href="http://api.rubyonrails.org/classes/ActiveSupport/TimeWithZone.html">documentation</a> , and this difference is useful to know. <br><br>  Among the shortcomings of <code>ActiveSupport::TimeZone</code> it can be noted that it uses its own ‚Äúhuman-readable‚Äù identifiers for time zones, which sometimes causes inconvenience, and also that these identifiers are not for all time zones available in tzdata, but also it's fixable. <br><br>  Every ‚Äúrailman‚Äù has already come across this class, setting the time zone in the <code>config/application.rb</code> file after creating a new application: <br><br><pre> <code class="ruby hljs">config.time_zone = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span></code> </pre> <br>  In the application, you can access this time zone using the <code>zone</code> method of the <code>Time</code> class. <br><br>  Here you can already see that the identifier <code>Moscow</code> instead of <code>Europe/Moscow</code> , but if you look at the output of the <code>inspect</code> method for a time zone object, we will see that inside there is a mapping to the <a href="https://www.iana.org/time-zones">tzdata</a> identifier: <br><br><pre> <code class="ruby hljs"> &gt; Time.zone =&gt; #&lt;ActiveSupport::TimeZone:0x007f95aaf01aa8 @name="Moscow", @tzinfo=#&lt;TZInfo::TimezoneProxy: Europe/Moscow&gt;&gt;</code> </pre> <br>  So, the most interesting methods for us are (all return objects of type <code>ActiveSupport::TimeWithZone</code> ): <br><br><ul><li>  The <code>now</code> method, which returns the current time in this time zone. <br><br><pre> <code class="ruby hljs">Time.zone.now <span class="hljs-comment"><span class="hljs-comment"># =&gt; Sun, 16 Aug 2015 22:47:28 MSK +03:00</span></span></code> </pre> <br></li><li>  The <code>parse</code> method, which, like the <code>parse</code> method of the <code>Time</code> class, parses a string with time into an object of the <code>Time</code> class, but at the same time immediately translates it into the time zone of this object.  If the line does not indicate an offset from UTC, then at the same time this method decides that the line indicates the local time of this time zone. <br><br><pre> <code class="ruby hljs">ActiveSupport::TimeZone[<span class="hljs-string"><span class="hljs-string">'Novosibirsk'</span></span>].parse(<span class="hljs-string"><span class="hljs-string">'2015-06-19T12:13:14'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Fri, 19 Jun 2015 12:13:14 NOVT +06:00</span></span></code> </pre> <br></li><li>  The <code>at</code> method converts the Unix timestamp (the number of seconds from January 1, 1970), which, as you know, is always in UTC, into an object of type <code>Time</code> in this time zone. <br><br><pre> <code class="ruby hljs">Time.zone.at(<span class="hljs-number"><span class="hljs-number">1234567890</span></span>) <span class="hljs-comment"><span class="hljs-comment">#=&gt; Sat, 14 Feb 2009 02:31:30 MSK +03:00</span></span></code> </pre> <br></li><li>  And the <code>local</code> method, which allows you to programmatically construct the time in the right time zone from individual components (year, month, day, hour, and so on). <br><br><pre> <code class="ruby hljs">ActiveSupport::TimeZone[<span class="hljs-string"><span class="hljs-string">'Yakutsk'</span></span>].local(<span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Fri, 19 Jun 2015 12:13:14 YAKT +09:00</span></span></code> </pre> <br></li></ul>  The <code>ActiveSupport::TimeZone</code> class is also actively used in operations with objects of the <code>Time</code> class and adds several useful methods to it, for example: <br><br><ul><li>  The class method <code>Time.zone</code> returns an object of class <code>ActiveSupport::TimeZone</code> , representing the time zone, which is currently valid for the entire application (and can be changed). <br><br></li><li>  And the class method <code>Time.zone_default</code> will return the time zone that you specified in the <code>config/application.rb</code> file. <br><br></li><li>  The <code>with_zone</code> method allows <code>with_zone</code> to temporarily change the current time zone for all code running in the block passed to it. <br><br></li><li>  Well, the method of the <code>Time#in_time_zone</code> object <code>Time#in_time_zone</code> allows <code>Time#in_time_zone</code> to change the time zone of an existing object (returns an object of type <code>ActiveSupport::TimeWithZone</code> ): <br><br><pre> <code class="ruby hljs">Time.parse(<span class="hljs-string"><span class="hljs-string">'2015-06-19T12:50:00'</span></span>).in_time_zone(<span class="hljs-string"><span class="hljs-string">'Asia/Tokyo'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Fri, 19 Jun 2015 18:50:00 JST +09:00</span></span></code> </pre> <br></li></ul>  <b>Important!</b>  There are two different sets of methods that return ‚Äúnow‚Äù - <code>Time.current</code> along with <code>Date.current</code> and <code>Time.now</code> along with <code>Date.today</code> .  The difference between them is that the first (those that are <code>current</code> ) return the time or date in the application's time zone as an object of type <code>ActiveSupport::TimeWithZone</code> , in the same zone that currently returns the <code>Time.zone</code> method and adds these Ruby methods on Rails, and the latter return time in the time zone, attention, server operating systems, and go to the standard Ruby library (they return, respectively, just <code>Time</code> ).  Be careful - there are strange bugs that are not reproducible locally, so always use <code>Time.current</code> and <code>Date.current</code> . <br><br>  So, knowing this all, we can already add support for time zones in any application: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># app/controllers/application_controller.rb class ApplicationController &lt; ActionController::Base around_action :with_time_zone, if: 'current_user.try(:time_zone)' protected def with_time_zone(&amp;block) time_zone = current_user.time_zone logger.debug "   : #{time_zone}" Time.use_zone(time_zone, &amp;block) end end</span></span></code> </pre> <br>  In this example, we have a <code>User</code> model with a certain <code>time_zone</code> method that returns an <code>ActiveSupport::TimeZone</code> object with the user's time zone. <br><br>  If this method returns non- <code>nil</code> , then using the around_action <code>around_action</code> we call the class method <code>Time.use_zone</code> and continue processing the request in the block passed to it.  Thus, all times in all views will be automatically displayed in the user's time zone.  Voila! <br><br>  In the database, we store the <code>tzdata</code> identifier, and to convert it to an object, this method is used in the file <code>app/models/user.rb</code> : <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#    +ActiveSupport::TimeZone+    #  ,      TZ database. def time_zone unless </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@time</span></span></span><span class="hljs-comment">_zone tz_id = read_attribute(:time_zone) as_name = ActiveSupport::TimeZone::MAPPING.select do |_,v| v == tz_id end.sort_by do |k,v| v.ends_with?(k) ? 0 : 1 end.first.try(:first) value = as_name || tz_id </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@time</span></span></span><span class="hljs-comment">_zone = value &amp;&amp; ActiveSupport::TimeZone[value] end </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@time</span></span></span><span class="hljs-comment">_zone end</span></span></code> </pre><br>  And this is a specially complicated method that converts the <code>Europe/Moscow</code> type tzdata identifier stored in the database into an <code>ActiveSupport::TimeZone</code> object, the identifier of which is simply <code>Moscow</code> .  The reason that I store the <code>tzdata</code> time zone <code>id</code> in the database, and not the rail one, lies in the interoperability - everyone understands the <code>id</code> from <code>tzdata</code> , and only Ruby on Rails understands the <code>id</code> time zone rails. <br><br>  And this is what the setter of the time zone paired to him looks like, which saves the tzdata identifier to the database.  It can accept as input an object of class ActiveSupport :: TimeZone, or any of identifiers. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#         TZ Database, #      ‚Äî  +ActiveSupport::TimeZone+ def time_zone=(value) tz_id = value.respond_to?(:tzinfo) &amp;&amp; value.tzinfo.name || nil tz_id ||= TZInfo.Timezone.get(ActiveSupport::TimeZone::MAPPING[value.to_s] || value.to_s).identifier rescue nil #   ‚Äî  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@time</span></span></span><span class="hljs-comment">_zone = tz_id &amp;&amp; ActiveSupport::TimeZone[ActiveSupport::TimeZone::MAPPING.key(tz_id) || tz_id] write_attribute(:time_zone, tz_id) end</span></span></code> </pre> <br>  The main reason why I prefer to save the <code>tzdata</code> identifier to the database is the PostgreSQL we use works well with time zones.  Having the <code>tzdata</code> identifier in the database, you can quite conveniently look at the local time in the user's time zone and debug various problems with time zones using queries like: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'2015-06-19T12:13:14Z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'Europe/Moscow'</span></span>;</code> </pre> <br>  One feature of PostgreSQL about which it is important to remember is that data types ending in with time zone do not store time zone information, but only convert the value inserted into them into UTC for storage and back into local time for display.  Ruby on Rails in migrations creates columns with the timestamp type without time zone, which store the time as you write them. <br><br>  Ruby on Rails defaults to UTC when connecting to a database.  That is, for any work with the base, all work with time is performed in UTC.  Values ‚Äã‚Äãin all columns are also written strictly in UTC, so, for example, when retrieving records for a certain day, you should always remember this and transfer to SQL queries not just dates that the DBMS converts at midnight on UTC, but time stamps that store midnight in the right time zone.  And then no records on your next date will not leave. <br><br>  The following request will not return records for the first three hours of the day for an application sharpened under Moscow time (UTC + 3, all cases): <br><br><pre> <code class="ruby hljs">News.where(<span class="hljs-string"><span class="hljs-string">'published_at &gt;= ? AND published_at &lt;= ?'</span></span>, Date.today, Date.tomorrow)</code> </pre> <br>  You must directly specify the time in the right time zone so that ActiveRecord converts it correctly: <br><br><pre> <code class="ruby hljs">News.where(<span class="hljs-string"><span class="hljs-string">'published_at &gt;= ? AND published_at &lt; ?'</span></span>, Time.current.beginning_of_day, Time.current.beginning_of_day + <span class="hljs-number"><span class="hljs-number">1</span></span>.day) <span class="hljs-comment"><span class="hljs-comment"># =&gt; News Load (0.8ms) SELECT "news".* FROM "news" WHERE (published_at &gt;= '2015-08-16 21:00:00.000000' AND published_at &lt; '2015-08-17 21:00:00.000000') ORDER BY "news"."published_at" DESC</span></span></code> </pre> <br><h2>  <font color="#00a9c0">Serialization and transfer of date and time</font> </h2><br>  In front of you are the ‚Äúrakes‚Äù that hurt my forehead not long ago.  In the application code, we had a place where time was generated on the client by constructing a new javascript Date object and implicitly casting it into a string.  In this form, it is transmitted to the server.  Thus, a bug was detected in the parse method of the Time class from the standard Ruby library, as a result of which the time in the Novosibirsk time zone was incorrectly parsed - the date was almost always in November: <br><br><pre> <code class="ruby hljs">Time.parse(<span class="hljs-string"><span class="hljs-string">'Mon May 18 2015 22:16:38 GMT+0600 (NOVT)'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; 2015-11-01 22:16:38 +0600</span></span></code> </pre> <br>  Most importantly, we could not detect this bug until the application was used by the first client, who had the Novosibirsk time zone in the OS settings.  By tradition, this client turned out to be a customer.  Developing in Moscow, you will never find this bug! <br><br>  Here comes the tip: set a different time zone on your CI server than the one used by the developers.  We discovered this property by accident, because our CI server was in UTC by default, and all developers are locally installed in Moscow.  Thus, we caught some previously not manifested bugs, because the browser on the CI server was launched with a time zone different from the default time zone of the rail application (and the time zone of test users). <br><br>  This example well shows the importance of using standardized machine-readable formats for the exchange of information between subsystems.  The previous bug would not exist if the developer immediately attended to the transfer of data in a machine-readable format. <br><br>  An example of such a machine-readable format is ISO 8601. For example, this is the recommended format for transmitting time and date when serialized to JSON according to the <a href="">Google JSON Style Guide</a> . <br><br>  The time from the example will look like this: <code>2015-05-18T22:16:38+06:00</code> . <br><br>  On the client, if you have a moment.js, then you need a method <code>toISOString()</code> .  And, for example, Angular.js serializes time in ISO 8601 by default (and does it right!). <br><br>  In my humble opinion, it is highly desirable to immediately expect time in such a format and try to <code>parse</code> it with the appropriate method of the <code>Time</code> class, and leave the <code>parse</code> method for backward compatibility.  Like this: <br><br><pre> <code class="ruby hljs">Time.iso8601(params[<span class="hljs-symbol"><span class="hljs-symbol">:till</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> Time.parse(params[<span class="hljs-symbol"><span class="hljs-symbol">:till</span></span>])</code> </pre> <br>  And if backward compatibility is not needed, then I would just catch the exception and return the error code 400 Bad Request with the message ‚Äúyou have a curve parameter and in general you are an evil Buratino‚Äù. <br><br>  However, the previous method is still error prone - if <code>params[:till]</code> is passed to time without offset from UTC, both methods (and <code>iso8601</code> and <code>parse</code> ) will <code>parse</code> it as if it were local time in the <b>server</b> time zone, and not applications.  Do you know what time zone your server is in?  I have in different.  A more bulletproof time parsing method will look like this (unfortunately <code>ActiveSupport::TimeZone</code> does not have the <code>iso8601</code> method, which is a pity): <br><br><pre> <code class="ruby hljs">Time.strptime(params[<span class="hljs-symbol"><span class="hljs-symbol">:till</span></span>], <span class="hljs-string"><span class="hljs-string">"%Y-%m-%dT%H:%M:%S%z"</span></span>).in_time_zone <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> Time.zone.parse(params[<span class="hljs-symbol"><span class="hljs-symbol">:till</span></span>])</code> </pre> <br>  But even here there is a place where everything can collapse - look at the code carefully and read on! <br><br>  When you transfer local time between systems (or store somewhere), be sure to transfer it along with the offset from UTC!  The fact is that local time itself (even with a time zone!) Is ambiguous in some situations.  For example, when changing the time from summer to winter, the same hour is repeated twice, once with one offset, another time with another.  Last fall in Moscow, the same hour of the night first passed with a shift of +4 hours, and then passed again, but with a shift of +3.  As you can see, each of these clocks correspond to different clocks in UTC.  With a reverse transfer one hour does not happen at all.  The local time with the specified offset from UTC is always unique.  In the event that you ‚Äúrun up‚Äù at such a point in time and you don‚Äôt have a displacement, <code>Time.parse</code> will simply return an earlier point in time to you, and <code>Time.zone.parse</code> throw a <code>TZInfo::AmbiguousTime</code> exception. <br><br>  Here are some illustrative examples: <br><br><pre> <code class="ruby hljs">Time.zone.parse(<span class="hljs-string"><span class="hljs-string">"2014-10-26T01:00:00"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># TZInfo::AmbiguousTime: 2014-10-26 01:00:00 is an ambiguous local time. Time.zone.parse("2014-10-26T01:00:00+04:00") # =&gt; Sun, 26 Oct 2014 01:00:00 MSK +04:00 Time.zone.parse("2014-10-26T01:00:00+03:00") # =&gt; Sun, 26 Oct 2014 01:00:00 MSK +03:00 Time.zone.parse("2014-10-26T01:00:00+04:00").utc # =&gt; 2014-10-25 21:00:00 UTC Time.zone.parse("2014-10-26T01:00:00+03:00").utc # =&gt; 2014-10-25 22:00:00 UTC</span></span></code> </pre> <br><h2>  <font color="#00a9c0">Various useful tricks</font> </h2><br>  If you add a little Monkey patch, you can teach <code>timezone_select</code> display Russian time zones first or even the only ones.  In the future, it will be possible to do without this - I sent the Pull Request to Ruby on Rails, but so far, unfortunately, it hangs without activity: <a href="https://github.com/rails/rails/pull/20625">https://github.com/rails/rails/pull/20625</a> <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># config/initializers/timezones.rb class ActiveSupport::TimeZone </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@country</span></span></span><span class="hljs-comment">_zones = ThreadSafe::Cache.new def self.country_zones(country_code) code = country_code.to_s.upcase </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@country</span></span></span><span class="hljs-comment">_zones[code] ||= TZInfo::Country.get(code).zone_identifiers.select do |tz_id| MAPPING.key(tz_id) end.map do |tz_id| self[MAPPING.key(tz_id)] end end end # -  app/views = f.input :time_zone, priority: ActiveSupport::TimeZone.country_zones(:ru)</span></span></code> </pre> <br>  It may well be that out of the box you may not have enough time zones.  For example, Russian time zones are far from being all, but at least there is one with each separate offset from UTC.  By simply inserting into the internal ActiveSupport hash and adding translations to the <a href="https://github.com/onomojo/i18n-timezones">i18n-timezones gem,</a> this can be achieved.  Do not try to send a pull request to Ruby on Rails - they will not accept it with the phrase ‚Äúwe are not an encyclopedia of time zones‚Äù ( <a href="https://github.com/rails/rails/pull/18489">I checked</a> ).  <a href="https://gist.github.com/Envek/cda8a367764dc2cacbc0">https://gist.github.com/Envek/cda8a367764dc2cacbc0</a> <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># config/initializers/timezones.rb ActiveSupport::TimeZone::MAPPING['Simferopol'] = 'Europe/Simferopol' ActiveSupport::TimeZone::MAPPING['Omsk'] = 'Asia/Omsk' ActiveSupport::TimeZone::MAPPING['Novokuznetsk'] = 'Asia/Novokuznetsk' ActiveSupport::TimeZone::MAPPING['Chita'] = 'Asia/Chita' ActiveSupport::TimeZone::MAPPING['Khandyga'] = 'Asia/Khandyga' ActiveSupport::TimeZone::MAPPING['Sakhalin'] = 'Asia/Sakhalin' ActiveSupport::TimeZone::MAPPING['Ust-Nera'] = 'Asia/Ust-Nera' ActiveSupport::TimeZone::MAPPING['Anadyr'] = 'Asia/Anadyr'</span></span></code> </pre><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># config/locales/ru.yml ru: timezones: Simferopol:     Omsk:  Novokuznetsk:  Chita:  Khandyga:  Sakhalin:  Ust-Nera: - Anadyr: </span></span></code> </pre> <br><h2>  <font color="#00a9c0">Javascript?</font> </h2><br>  What is a modern web application without a rich frontend?  Take it easy - not everything is so smooth!  In pure javascript, you can only get an offset from UTC, which is now operating in the user's OS - and that‚Äôs it.  Therefore, everyone is practically doomed to use the library of <a href="http://momentjs.com/">moment.js</a> along with its complementary library at the <a href="http://momentjs.com/timezone/">moment timezone</a> , which drags <code>tzdata</code> directly to the browser to the user (yes, users will again have to download extra kilobytes).  But, nevertheless, with it you can do everything.  Or almost everything. <br><br>  Examples of use that you absolutely definitely need: <br><br>  In case you already have a good and good time stamp in ISO8601 format, then just feed it to the <code>parseZone</code> method of the Moment itself: <br><br><pre> <code class="javascript hljs">moment.parseZone(ISO8601Timestamp)</code> </pre> <br>           ,  Moment Timezone  ,     ,    : <br><br><pre> <code class="javascript hljs">moment.tz(timestamp, formatString, timezoneIdentifier)</code> </pre> <br>          (  <code>new Date()</code> !),         ¬´ ¬ª        . <br><br>              . ,   <a href="https://github.com/urish/angular-moment">angular-moment</a> ,                        .     ‚Äî  . <br><br><h2> <font color="#00a9c0"></font> </h2><br>  ,   90% , : <br><br><ul><li>           (. . )   UTC. <br></li><li>       . ,   ,               UTC. <br></li><li>      :  ,   UTC    .      ,  -  ¬´¬ª    - . <br></li><li>           ,       . <br></li><li>    ,      ,    -   ,       ,    . <br></li><li>       ,    ‚Äî  ,  . <br></li><li>      ,      ‚Äî  ,     ,      UTC     . <br></li><li>   ,   ‚Äî       NTP      <code>tzdata</code> (,         <code>tzdata</code> ). <br></li></ul><br>  -   ,           Mail.ru ‚Äî              ,     : <a href="http://habrahabr.ru/company/mailru/blog/242645/">http://habrahabr.ru/company/mailru/blog/242645/</a> <br><br>        ,      ,          ,    ,  ,   : <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/-5wpm-gesOY%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhjuiM3B_rDVx7adwKlrgFkpU1tRaw" frameborder="0" allowfullscreen=""></iframe><br><br> ,   !  ‚Äî         ,      : <br><ul><li> <a href="http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html">http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html</a> <br></li><li> <a href="http://api.rubyonrails.org/classes/ActiveSupport/TimeWithZone.html">http://api.rubyonrails.org/classes/ActiveSupport/TimeWithZone.html</a> <br></li><li> <a href="http://api.rubyonrails.org/classes/Time.html">http://api.rubyonrails.org/classes/Time.html</a> <br></li></ul><br> <b>PS&gt;</b>         DevConf 2015.      <a href="http://www.slideshare.net/Envek/dev-conf-2015-rails"></a> ,    <a href="http://railsclub.ru/devconf2015.html"></a>    RailsClub. ,        RailsClub ‚Äî    ! </div><p>Source: <a href="https://habr.com/ru/post/266681/">https://habr.com/ru/post/266681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266669/index.html">Setting up Vim-like controls in GTK</a></li>
<li><a href="../266671/index.html">Downloading music from VK using VK api and Python3</a></li>
<li><a href="../266673/index.html">A small Java-RuleZ FAQ - or why Java is used in 1C: Programmers' Club to prepare for school computer science competitions</a></li>
<li><a href="../266675/index.html">Security Week 37: Bug-bugzilla, Karbanak from back, C & C on fishing</a></li>
<li><a href="../266677/index.html">A little ZPL guide</a></li>
<li><a href="../266683/index.html">React v0.14 release candidate overview</a></li>
<li><a href="../266685/index.html">Accelerate vectorization and memory accesses in DL_MESO: optimization examples with Vectorization Advisor on a large project</a></li>
<li><a href="../266687/index.html">Memory Profiling with Intel¬Æ VTune ‚Ñ¢ Amplifier XE</a></li>
<li><a href="../266689/index.html">Rating of data center operators in Russia by the degree of readiness to interact with foreign customers</a></li>
<li><a href="../266693/index.html">Under the hood rendering navigation data in MAPS.ME</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>