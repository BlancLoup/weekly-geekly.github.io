<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ES6 in detail: proxy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The ES6 In Depth series of Jason Orendorf‚Äôs publications is dedicated to ES6, which was added to the JavaScript programming language in 6 iterations o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ES6 in detail: proxy</h1><div class="post__text post__text-html js-mediator-article">  The ES6 In Depth series of Jason Orendorf‚Äôs publications is dedicated to ES6, which was added to the JavaScript programming language in 6 iterations of ECMAScript. <br><br>  Today we will do such things: <br><br><img src="https://habrastorage.org/files/e5a/1d7/2bf/e5a1d72bf5cb4bd28cdb618dab21d318.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A bit difficult for the first example.  I will explain in more detail later, for now let's see what kind of object we created. <br><a name="habracut"></a><br><pre><code class="javascript hljs">&gt; obj.count = <span class="hljs-number"><span class="hljs-number">1</span></span>; setting count! &gt; ++obj.count; getting count! setting count! <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><br>  <b>What's going on here?</b> <br><br>  We intercept access to the properties of this object. <br>  We overload the operator ‚Äú.‚Äù <br><br>  <b>How does this happen?</b> <br><br>  The coolest thing in computing is called virtualization.  This rather general purpose technique is used to do amazing things.  Here is how it works. <br><br>  1. Take any image. <br><br><img src="https://habrastorage.org/files/81b/ec1/1ed/81bec11eda3a45faab2a59e5d8b3cb83.jpg"><br>  Photo: <a href="https://www.flickr.com/photos/martini_dk/369891979">Martin Nikolaj Bech</a> <br><br>  2. We draw a line around this image. <br><br><img src="https://habrastorage.org/files/ff9/42c/fc9/ff942cfc96fd464695feff5a49b1c784.png"><br><br>  3. Now we replace everything inside this area or outside with something completely unexpected.  There is only one rule: the backward compatibility rule.  The substitution should be such that no one notices the change. <br><br><img src="https://habrastorage.org/files/20c/27d/d64/20c27dd647234399bebabbeb87342319.png"><br>  Photo: <a href="https://www.flickr.com/photos/bevgoodwin/8671334130/">Beverley Goodwin</a> <br><br>  You are probably already familiar with similar tricks from classic films about computer science such as The Truman Show or The Matrix, in which the character is inside a certain area and the surrounding world is replaced by the complex illusion of normality. <br><br>  Perhaps to meet the requirement of the backward compatibility rule, your substitution should be carefully considered.  But the main trick is to draw the correct line. <br><br>  By line is meant the boundary of the API - interface.  Interfaces describe the interaction of two parts of a code.  So, if the system already has the described interface, we can assume that the line is drawn.  You know that you can replace any part without affecting the other. <br><br>  When the interface does not exist, it must be invented.  The coolest hacks in programming have been to draw the boundary of the API where there is none, and embed this interface into the existing one, making great efforts. <br><br>  <a href="https://en.wikipedia.org/wiki/Hardware_virtualization">Virtualization</a> , <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual memory</a> , <a href="https://en.wikipedia.org/wiki/Docker_%2528software%2529">Docker</a> , <a href="http://valgrind.org/">Vagrind</a> , <a href="http://rr-project.org/">rr</a> - all of these projects, in varying degrees, are involved in launching and managing new and quite often unexpected interfaces in the existing system.  In some cases, it took years, new features of operating systems, and even hardware, so that all this could work as it should. <br><br>  The best tricks with virtualization bring a new understanding of what should be virtualized.  To write to any API, there must be an understanding.  Once you understand, you can do amazing things. <br><br>  ES6 provides virtualization support for its underlying object concept. <br><br>  <b>What is an object?</b> <br><br><img src="https://habrastorage.org/files/22a/d75/7a0/22ad757a0e034e919390ba2cc24d78d3.jpg"><br>  Photo: <a href="https://www.flickr.com/photos/mustangjoe/5966894496/">Joe deSousa</a> <br><br>  No, really.  Wait a minute.  Think it over.  Scroll further as you know the answer. <br>  For me, this is a very difficult question, and I have never heard an answer that could satisfy me sufficiently. <br><br>  Is amazing?  Defining fundamental things is always difficult.  Take a look at at least some of the first definitions in <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/bookI.html">Euclid's Elements.</a>  The ECMAScript language specification has fallen into a good company, so it can afford to define an object as ‚Äúa member of type Object‚Äù. <br><br>  Further in this specification it is said that "the object is a collection of properties".  Not so bad if you need a definition right now.  We will return to this question later. <br><br>  As I said before, <i>to write an API to something, there must be an understanding.</i>  I promise: when we deal with all this, we will better understand the objects and we can do incredible things with them. <br><br>  Let's follow in the footsteps of the ECMAScript standards committee and see what it would cost us to define an API for JavaScript objects.  What kind of methods do we need?  What can objects do? <br><br>  This is somewhat dependent on the object.  Objects of DOM elements can do one thing, AudioNode objects can do another.  But some fundamental abilities are common. <br><br>  ‚Ä¢ Objects have properties.  Property values ‚Äã‚Äãcan be received, set, deleted, etc. <br>  ‚Ä¢ Objects have prototypes.  This is how JavaScript inheritance works. <br>  ‚Ä¢ Some objects are functions or constructors and can be called. <br><br>  Almost everything that JavaScript programs do with objects happens by using properties, prototypes, and functions.  Even the special behavior of an Element or AudioNode object is achieved by simply invoking methods that are just inherited properties of a function. <br><br>  So, when the ECMAScript standards committee defined a set of 14 internal methods that represent a common interface for all objects, no one was surprised that they eventually decided to focus on these three fundamental things. <br><br>  A complete list can be found <a href="http://www.ecma-international.org/ecma-262/6.0/index.html">in Tables 5 and 6 of the ES6 standard</a> .  Here I will explain some of them.  Strange double brackets [[]] make it clear that this is an internal method that is hidden from regular JavaScript code.  You cannot call, delete or overwrite them in the same way as a normal method. <br><br>  ‚Ä¢ <b>obj. [[Get]] (key, receiver)</b> - get property value. <br><br>  Called when the JS code executes: obj.prop or obj [key]. <br><br>  Obj is the object in which the search is performed;  The receiver is the object from which the search for the value of this property was started.  Sometimes you have to look in several objects.  Obj can be an object or a chain of recevier prototypes. <br><br>  ‚Ä¢ <b>obj. [[Set]] (key, value, receiver)</b> - set the property of the object. <br><br>  Called when the JS code executes: obj.prop = value or obj [key] = value. <br>  In the assignment of the form obj.prop + = 2, the [[Get]] method is executed first, followed by the call to [[Set].  Same for ++ and -. <br><br>  ‚Ä¢ <b>obj. [[HasProperty]] (key)</b> - check for the existence of a property. <br><br>  Called when the JS code executes: key in obj. <br><br>  ‚Ä¢ <b>obj. [[Enumerate]] ()</b> is a list of obj. <br><br>  Called when the JS code executes: for (key in obj) ... <br>  Returns an iterator object.  So the for-in loop gets the names of the properties of the objects. <br><br>  ‚Ä¢ <b>obj. [[GetPrototypeOf]] (</b> ) - returns the obj prototype. <br><br>  Called when the JS code executes: obj.  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto">__proto__</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf (obj</a> ). <br><br>  ‚Ä¢ <b>functionObj. [[Call]] (thisValue, arguments)</b> - function call. <br><br>  Called when the JS code executes: functionObj () or x.method (). <br>  Optional.  Not every object is a function. <br><br>  ‚Ä¢ <b>constructorObj. [[Construct]] (arguments, newTarget)</b> - constructor call. <br><br>  Called when the JS code executes: new Date (2890, 6, 2), for example. <br>  Optional.  Not every object is a constructor. <br><br>  The argument is involved in the process of creating subclasses.  We will discuss this issue in the following articles. <br>  Perhaps you can guess what the other 7 are. <br>  In the entire ES6 standard, each line of syntax or built-in function that does something with objects is described in terms of 14 internal methods.  ES6 has a clear border around the "brains" of the object.  What a proxy allows you to do is replace the standard ‚Äúbrains‚Äù with an arbitrary code. <br><br>  Recall that when we talk about redefining these internal methods, we are talking about redefining the internal syntax of obj.prop, built-in functions like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys ()</a> and the like. <br><br>  <b>Proxy</b> <br><br>  ES6 defines a new global constructor, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> , which takes two arguments: a target object and a handler object.  A simple example looks something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = {}, handler = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(target, handler);</code> </pre><br><br>  For now, let's drop the handler object and focus on how the proxy and target objects relate. <br>  I can explain proxy behavior with one sentence.  All internal proxy methods are sent to the target.  That is, if something calls proxy. [[Enumerate]] (), the call will return target. [[Enumerate]] (). <br><br>  Let's try.  Do something that will call the proxy. [[Set]] () <br><br><pre> <code class="javascript hljs">proxy.color = <span class="hljs-string"><span class="hljs-string">"pink"</span></span>;</code> </pre><br><br>  OK, what happened?  proxy. [[Set]] () should have called target. [[Set]] (), and this call should have created a new property in target.  Is not it? <br><br><pre> <code class="javascript hljs">&gt; target.color <span class="hljs-string"><span class="hljs-string">"pink"</span></span></code> </pre><br><br>  The same happens for all internal methods.  This proxy will behave almost the same as its target. <br>  For the correctness of the created illusion, there are still limitations.  You may find that the proxy! == target.  And the proxy sometimes will not pass some type checks that the target will pass.  Even if the target of a given proxy, for example, a DOM element, the proxy is not an instance of Element, so some things like document.body.appendChild (proxy) will cause a TypeError error. <br><br>  <b>Proxy Handlers</b> <br><br>  Let's go back to the handler object.  This is what makes proxy useful.  The methods of the handler object can override any internal methods of the proxy object. <br>  For example, if you want to intercept all attempts to set the properties of an object, this can be accomplished by defining the handler.set () method. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = { <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, key, value, receiver</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Please don't set properties on this object."</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(target, handler); &gt; proxy.name = <span class="hljs-string"><span class="hljs-string">"angelina"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Please don<span class="hljs-string"><span class="hljs-string">'t set properties on this object.</span></span></code> </pre><br><br>  A complete list of handler methods can be found <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">on the Proxy page in MDN</a> .  There are 14 methods that repeat the 14 internal methods defined in the ES6 standard. <br>  All handler methods are optional.  If the internal method is not intercepted by the handler, it is sent to the target, as you can see above. <br><br>  <b>Example: ‚ÄúImpossible‚Äù Autocomplete Objects</b> <br><br>  Now we know enough about proxy to try to use them for something really strange, something that would be impossible without using it. <br><br>  Exercise first.  We describe the function Tree (): <br><br><pre> <code class="javascript hljs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tree = Tree(); &gt; tree { } &gt; tree.branch1.branch2.twig = <span class="hljs-string"><span class="hljs-string">"green"</span></span>; &gt; tree { <span class="hljs-attr"><span class="hljs-attr">branch1</span></span>: { <span class="hljs-attr"><span class="hljs-attr">branch2</span></span>: { <span class="hljs-attr"><span class="hljs-attr">twig</span></span>: <span class="hljs-string"><span class="hljs-string">"green"</span></span> } } } &gt; tree.branch1.branch3.twig = <span class="hljs-string"><span class="hljs-string">"yellow"</span></span>; { <span class="hljs-attr"><span class="hljs-attr">branch1</span></span>: { <span class="hljs-attr"><span class="hljs-attr">branch2</span></span>: { <span class="hljs-attr"><span class="hljs-attr">twig</span></span>: <span class="hljs-string"><span class="hljs-string">"green"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">branch3</span></span>: { <span class="hljs-attr"><span class="hljs-attr">twig</span></span>: <span class="hljs-string"><span class="hljs-string">"yellow"</span></span> }}}</code> </pre><br><br>  Notice how the intermediate objects branch1, branch2 and branch3 are magically created on their own when necessary.  Convenient, right?  How could this theoretically work? <br><br>  Until today, there was no way this could be achieved.  But with proxy, these are just a few lines of code.  You need to write them in tree. [[Get]] ().  If you want, you can try to implement it yourself before continuing reading. <br><br><img src="https://habrastorage.org/files/518/6a4/50b/5186a450b116478aacd31bcf085cb87a.jpg"><br>  Photo: <a href="https://www.flickr.com/photos/chiotsrun/5446345665/">Chiot's Run</a> <br><br>  Here is my solution: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>({}, handler); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, key, receiver</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> target)) { target[key] = Tree(); <span class="hljs-comment"><span class="hljs-comment">// auto-create a sub-Tree } return Reflect.get(target, key, receiver); } };</span></span></code> </pre><br><br>  Notice the call to Reflect.get () at the end.  It turns out that there is a very important and common need for everyone to say ‚Äúnow the default behavior is required, namely the delegation of target'y‚Äù in the handler proxy methods.  To do this, ES6 defines a new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect object</a> with 14 own methods that can be used just for this purpose. <br><br>  <b>Example: Read-only view</b> <br><br>  It seems I could have developed a false impression that the proxy was easy to use.  You need to perform another exercise to verify this statement. <br><br>  This time the task will be more complicated: you need to implement the function readOnlyView (object), which accepts the object, and returns the proxy of this object, which behaves in the same way, except for the possibility to modify it.  So, for example, he should behave something like this: <br><br><pre> <code class="javascript hljs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newMath = readOnlyView(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>); &gt; newMath.min(<span class="hljs-number"><span class="hljs-number">54</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-number"><span class="hljs-number">40</span></span> &gt; newMath.max = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min; <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: can<span class="hljs-string"><span class="hljs-string">'t modify read-only view &gt; delete newMath.sin; Error: can'</span></span>t modify read-only view</code> </pre><br><br>  How could this be implemented? <br>  First, it is necessary to intercept the call to all internal methods that would alter the target object when called.  Their 5, here they are: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NOPE</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"can't modify read-only view"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = { <span class="hljs-comment"><span class="hljs-comment">// Override all five mutating methods. set: NOPE, defineProperty: NOPE, deleteProperty: NOPE, preventExtensions: NOPE, setPrototypeOf: NOPE }; function readOnlyView(target) { return new Proxy(target, handler); }</span></span></code> </pre><br><br>  It works.  We warn installation, change and so on in the read-only view. <br>  What are the pitfalls in this scheme? <br>  The biggest problem is that the [[Get]] method, like the others, can still return objects that can be modified later.  So even if any object x is read-only, its x.prop property can be writable.  This is a big problem! <br><br>  To solve it, you need to describe the method handler.get () <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = { ... <span class="hljs-comment"><span class="hljs-comment">// Wrap other results in read-only views. get: function (target, key, receiver) { // Start by just doing the default behavior. var result = Reflect.get(target, key, receiver); // Make sure not to return a mutable object! if (Object(result) === result) { // result is an object. return readOnlyView(result); } // result is a primitive, so already immutable. return result; }, ... };</span></span></code> </pre><br><br>  But this is not enough.  The same code is needed for other methods, including <br>  getPrototypeOf and getOwnPropertyDescriptor. <br><br>  This raises additional problems.  When a getter or method is invoked using such a proxy, the value of this passed to this method or getter will be the proxy itself.  But, as we saw earlier, many different methods produce a type check that the proxy fails.  It would be better to replace the target object for the proxy in this place.  Do you know how to do this? <br>  From this exercise, we can take out that creating a proxy is easy, but creating a proxy with intuitive behavior is quite difficult. <br><br>  <b>Sundries</b> <br><br>  <b>‚Ä¢ What are proxy really good for?</b> <br><br>  They are certainly useful when you want to log calls to objects.  They are very convenient for debag.  Testing frameworks can use them to <a href="https://en.wikipedia.org/wiki/Mock_object">create mocks.</a> <br>  They will also be useful if you need behavior that is slightly different from what an ordinary object does.  For example, lazy filling objects. <br><br>  I really don‚Äôt like what I‚Äôm going to say now, but one of the best ways to see what happens in the proxy code is to ... wrap the handler proxy object into another proxy object that displays every call to the handler object to the console. <br>  Proxy can also be used if you want to restrict access to the object, as was done in the example with readOnlyView.  This type of use is rare in application code, but Firefox uses proxy in order to implement <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Script_security">security boundaries</a> between different domains.  They are a key part of our security model. <br><br>  <b>‚Ä¢ Proxies WeakMaps.</b>  In our readOnlyView example, we created a new proxy object every time an object was accessed.  You can save more memory if you cache each created proxy in WeakMap, so no matter how many times an object is passed to readOnlyView, only one proxy will be created for it. <br><br>  This is one of the cases that might encourage you to use WeakMap. <br><br>  <b>‚Ä¢ Recalled proxies.</b>  ES6 also defines another function: Proxy.revocable (target, handler), which creates a proxy, as well as a call to new Proxy (target, handler), except that the proxy can be recalled later.  (Proxy.revocable returns an object with the .proxy property and the .revoke method.) Once the proxy is revoked, it simply stops working, all its internal methods are reset. <br><br>  <b>‚Ä¢ Object invariants.</b>  In some situations, ES6 requires the handler proxy methods to report results related to the state of the target object.  This is done to ensure compliance with the rules of immutability in all objects, including the proxy.  For example, a proxy cannot claim to be non-extensible if its target really is. <br><br>  The immediate rules are too complex to be described in this article, but if you suddenly get an error message like the proxy, it is the cause.  The best tool here is to change what the proxy says about itself.  It is also possible to modify the target to reflect what the proxy reports. <br><br>  <b>So what is an object?</b> <br><br>  I think when we left this question, the answer was: ‚ÄúAn object is a collection of properties‚Äù. <br><br>  I don‚Äôt like this definition very much, even if I omit the challenge and the prototypes.  I find the word ‚Äúcollection‚Äù too generous, considering how poorly a proxy can be defined.  His handler's methods can do anything (they can return random results). <br>  The ECMAScript standards committee has expanded the scope of opportunities by defining what an object can do, standardizing its methods, and adding virtualization as a top-level feature that everyone can use. <br>  Now objects can be anything. <br>  Perhaps the most honest answer to the question ‚ÄúWhat is an object?‚Äù Is the 12 required internal methods as a definition.  An object in JavaScript is something that has the ability to perform [[Get]], [[Set]], and so on ... <br>  ________________________________________ <br><br>  Have we deepened our understanding of what an object is?  I'm not sure!  Have we done unbelievable things?  Definitely!  We did things that previously could not be done in JavaScript. <br><br>  Can I use proxy today? <br><br>  Not!  At least not on the Web!  Only Firefox and Microsoft Edge support proxy, and the polyphile is of course not. <br>  Using proxy in node.js or io.js requires the inclusion of the disabled (--harmony_proxies) and <a href="https://github.com/tvcutsem/harmony-reflect">harmony-reflect</a> polyphiles option, as V8 implements an older version of the Proxy specification.  (The previous version of this article contained errors on this score. Thanks to M√∂rre and Aaron Powell for correcting me in the comments.) <br><br>  So feel free to experiment with the proxy!  Create mirror rooms, where there will be thousands of copies of each object, all similar to each other to such an extent that it will be impossible to debug!  Right now.  So far, there is a small chance that a certain amount of your rash proxy code will end up in production. <br><br>  The proxy was first implemented in 2010 by Andreas Galem with code review Blake Kaplan.  Later they were completely reworked by the standards committee.  Eddie Bruel implemented the new specification in 2012. <br>  I implemented Reflect with Jeff Walden's code review.  These changes will be in Firefox Nightly from this weekend - all with the exception of Reflect.enumerate (), which is not yet implemented. <br><br>  Next time, let's talk about the most controversial feature in ES6 - classes, and who would have imagined it better than a person involved in its implementation in Firefox?  So, please, do not miss the following article from Mozilla engineer Eric Faust, in which he will talk in detail about classes in ES6. </div><p>Source: <a href="https://habr.com/ru/post/267165/">https://habr.com/ru/post/267165/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267155/index.html">Optimizing dynamic memory allocation performance in a multi-threaded library</a></li>
<li><a href="../267157/index.html">Configure SCST Target on CentOS 7 using FC QLogic adapter</a></li>
<li><a href="../267159/index.html">Features Backup Exec 15, which you did not guess</a></li>
<li><a href="../267161/index.html">What awaits the data center industry in the future</a></li>
<li><a href="../267163/index.html">Hacker, cryptographer or psychic. Ordinary magic</a></li>
<li><a href="../267167/index.html">New attack on Microsoft Exchange mail server allows you to steal passwords</a></li>
<li><a href="../267173/index.html">Algorithm for schoolchildren: from beginner to Olympic medalist</a></li>
<li><a href="../267175/index.html">As we did ABC analysis for retail, or ‚Äúwithout half a liter you will not understand‚Äù</a></li>
<li><a href="../267177/index.html">Secure login with PHPixie 3</a></li>
<li><a href="../267179/index.html">Game for Railways: complete story</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>