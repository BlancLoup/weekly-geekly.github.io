<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ 11 standard implementation implementation bugs in Visual Studio 2012 that were fixed in Visual Studio 2013</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will look at a number of bugs in the implementation of the C ++ 11 standard that were present in Visual Studio 2012 and were fixed in Vis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ 11 standard implementation implementation bugs in Visual Studio 2012 that were fixed in Visual Studio 2013</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/eb1/a85/2c4/eb1a852c47b5f7fc929f064de404314f.png"><br>  This article will look at a number of bugs in the implementation of the C ++ 11 standard that were present in Visual Studio 2012 and were fixed in Visual Studio 2013. Thus, we can now use C ++ 11 as the theory intends to use it.  If you had to write ‚Äúcrutches‚Äù to bypass VS2012 bugs, you can now remove them. <br><br>  Unfortunately, not all bugs were fixed, something migrated from VS2012 to VS2013, and new bugs appeared.  Under the cut you will find a detailed analysis of the current state of affairs. <br><a name="habracut"></a><br><h4>  There is no more limit on the number of types in the variadic templates </h4><br>  Visual Studio 2013 supports variadic templates in full, things like std :: function or make_shared no longer have a limit on the number of arguments they can take.  In Visual Studio 2012, this limit existed and was equal to 5 (five). <br><br><h4>  Fixed type inference bugs </h4><br><h5>  auto lost alignment specifier </h5>  If you used auto to declare a variable of the type defined by the expression __declspec (align (...)), the alignment was handled incorrectly in VS2012, which led to incorrect data placement in memory and random crashes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Decltype could not be used instead of type in all cases. </h5>  Despite the fact that the type defined via decltype should presumably be possible to use wherever conventional types can be used, VS2012 did not allow writing, for example, such code: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; a; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(a)::iterator iter = a.end(); <span class="hljs-comment"><span class="hljs-comment">//   VS2012</span></span></code> </pre> <br><br><h5>  declval caused compilation errors </h5>  Some code, correct according to the C ++ 11 standard, was not compiled in VS2012 due to incorrect interpretation of declval. <br>  Suppose you want to declare the is_comparable template: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = true_type&gt; struct is_comparable : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typenameT&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_comparable</span></span></span><span class="hljs-class">&lt;T, typename is_convertible&lt;decltype(declval&lt;T&gt;() &gt; declval&lt;T&gt;()), bool&gt;:</span></span>:type&gt; : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {};</code> </pre><br><br>  This will not work in VS2012, since declval will not understand what T is. <br><br><h4>  Fixed bugs in smart pointers </h4><br><h5>  Using the lambda function as a custom deleter broke the conversion to type bool </h5>  If you used lambda functions to determine what should happen when you delete a smart pointer, you could not use this pointer in the context of converting it to bool type: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stream_deleter = [](ofstream* os) { os-&gt;close(); }; <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;ofstream, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(stream_deleter)&gt; p_log(&amp;log_file, stream_deleter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p_log) <span class="hljs-comment"><span class="hljs-comment">// compile error cout &lt;&lt; "Couldn't open file" &lt;&lt; endl;</span></span></code> </pre><br><br><h5>  Calling unique_ptr :: reset could lead to double deletion </h5>  The order of operations in the reset method did not match the order described by the standard.  This could lead to double removal of the object.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelfReferential</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;SelfReferential&gt;&amp; _p_self; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SelfReferential(<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;SelfReferential&gt;&amp; p) : _p_self(p) {} ~SelfReferential() { _p_self.reset(); } }; <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;SelfReferential&gt; p; p = <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;SelfReferential&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelfReferential(p)); p.reset(); <span class="hljs-comment"><span class="hljs-comment">//    ~SelfReferential</span></span></code> </pre><br><br>  Calling the reset method starts the SelfReferential destructor, which again triggers the reset.  Double deletion occurs because the reset method resets the pointer to the object under control after it is deleted, and not before it. <br><br><h5>  shared_ptr, protected-destructor and nullptr </h5>  You could not create a shared_ptr for a class with a protected destructor by initializing it with nullptr: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ~Interface() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Implementation</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Interface { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }; shared_ptr&lt;Interface&gt; ptr1 = make_shared&lt;Implementation&gt;(); // OK shared_ptr&lt;Interface&gt; ptr2 = nullptr; // </span></span></code> </pre><br>  In Visual Studio 2013, this code is compiled, as expected by the standard. <br><br><h4>  Fixed bugs in type traits library </h4><br><h5>  Incorrect is_function </h5>  is_function returns an incorrect result if the function passed to it contains too many arguments: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; is_function&lt;f&gt;::value; <span class="hljs-comment"><span class="hljs-comment">// false,    true</span></span></code> </pre><br>  Also, the result is erroneous for functions with a calling convention other than the default <br><br>  Similarly, is_member_function_pointer fails to return the result correctly for methods with an explicitly defined convention. <br><br>  is_member_pointer, on the contrary, does not work correctly with the __cdecl method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl A::*ccall_proc)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; is_member_pointer&lt;ccall_proc&gt;::value; <span class="hljs-comment"><span class="hljs-comment">// false,    true</span></span></code> </pre><br><br>  The is_object was defined via is_function, so the above error with a large number of function arguments applies to it, leading to an incorrect definition of the object. <br><br><h5>  is_scalar did not recognize nullptr_t </h5>  is_scalar &lt;nullptr_t&gt; incorrectly returned false in VS2012 - the standard defines nullptr_t as a scalar type. <br><br><h5>  is_pod misunderstood void </h5>  is_pod mistakenly returned true in VS2012, although void is not a <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D1%258F_%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">POD type</a> <br><br><h5>  is_constructible returned incorrect results for links </h5>  is_constructible behaved incorrectly with reference types, returning false for things like: <br><br><pre> <code class="cpp hljs">is_constructible&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::value; is_constructible&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&amp;&gt;::value;</code> </pre><br><br><h5>  Bugs in alignment_of and aligned_union </h5>  alignment_of in VS2012 generates generatee a false warning about an inaccessible destructor if you use it on a private destructor type. <br>  Also, aligned_union worked incorrectly in VS2012: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> aligned_union&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::type StorageType; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 24 sizeof(StorageType); // 16,    24  </span></span></code> </pre><br><br>  The aligned_union must have a static alignment_value member containing alignment values ‚Äã‚Äãfor the template arguments T1, ..., Tn.  This, however, was not implemented in VS2012. <br><br><h5>  common_type erroneously returns void </h5>  Instead of a compilation error, as assumed by the standard, common_type returned void in VS2012: <br><br><pre> <code class="cpp hljs">common_type&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;::type; <span class="hljs-comment"><span class="hljs-comment">// void</span></span></code> </pre><br>  common_type also returns void incorrectly for user-defined types, when the * is * conversion is possible: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AWrapper</span></span></span><span class="hljs-class"> {</span></span> AWrapper() {} AWrapper(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A&amp;) {} }; common_type&lt;A, AWrapper&gt;::type; <span class="hljs-comment"><span class="hljs-comment">// void</span></span></code> </pre><br><br><h5>  result_of is not compiled in some cases. </h5>  If you decide to use the move-only argument with this template in VS2012, you will have trouble: <br><br><pre> <code class="cpp hljs">result_of&lt;Copyable(MoveOnly&amp;&amp;)&gt;::type; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br><br><h4>  Fixed bugs in STL containers and algorithms </h4><br><h5>  minmax_element did not work </h5>  The standard defines two versions of this algorithm: <br><br><pre> <code class="cpp hljs">pair&lt;Iter, Iter&gt; minmax_element(Iter first, Iter last) pair&lt;Iter, Iter&gt; minmax_element(Iter first, Iter last, Compare comp)</code> </pre><br>  They must return (first, last), where first indicates the smallest element, and last indicates the largest, or make_pair (first, first) if the range is empty.  In VS2012, however, instead, make_pair (min_element (first, last), max_element (first, last)) was returned. <br><br><h5>  Containers mistakenly demanded that the types of elements required the presence of move-constructors </h5>  All container move constructors mistakenly required the element type to have a move constructor. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> A() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: A(A&amp;&amp;); A(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A&amp;); }; <span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;A&gt; source; <span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;A&gt; target(move(source)); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br><br>  Similarly, access statements for the map and unordered_map elements required the presence of move constructors: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, A&gt; m; A&amp; elem = m[<span class="hljs-string"><span class="hljs-string">"abc"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br><br><h4>  Fixed errors related to parallelization and asynchrony </h4><br><br><h5>  shared_future created from future </h5>  Another bug in VS2012 was in the implementation of the future and shared_future for reference types and void.  This bug allowed the following code to be compiled (which is obviously wrong, since the future is a move-only type): <br><br><pre> <code class="cpp hljs">future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&gt; f_ref; shared_future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&gt; sf_ref(f_ref); <span class="hljs-comment"><span class="hljs-comment">// ,     future&lt;void&gt; f_void; shared_future&lt;void&gt; sf_void(f_void); // ,    </span></span></code> </pre><br><br><h5>  Memory leak in thread class </h5>  A bug that could lead to memory leaks at program completion.  This happened because the thread created, but never destroyed the at_thread_exit_mutex object, as well as some internal data structures. <br><br><h5>  Useless promise wait functions </h5>  Due to a bug in Visual Studio 2012, the wait_for and wait_until functions of such future objects returned future_status :: deferred instead of future_status :: timeout or future_status :: ready, making these methods useless. <br><br><h5>  Invalid messages in future_error exceptions </h5>  Bug inconsistencies error code and its description, because of what, for example, receiving the exception "broken promise", the message will contain the text "future already retrieved".  Only the error code was correct. <br><br><h5>  an atomic-template could not be defined for a type without a default constructor </h5>  You received an error message when you tried to use an atomic template for a type without a default constructor, although this is not true. <br><br><h5>  atomics worked slowly </h5>  In VS2012, atomic operations were sometimes overridden with integrity checks (made them where it was not necessary).  Although it does not violate the standard, the code worked more slowly than it could.  VS2013 has a completely new implementation of atomic operations, which runs much faster. <br><br><h4>  Fixed errors in generating random numbers </h4><br>  In debug mode, mersenne_twister_engine generated an erroneous assert if you tried to initialize it with zero. <br><br>  The stream operator for subtract_with_carry_engine contained an error leading to undefined behavior. <br><br>  independent_bits_engine and shuffle_order_engine did not initialize internal members in their displacement constructors, which sometimes resulted in endless loops. <br><br><h4>  Fixed bugs in the library of rational arithmetic </h4><br>  Several bugs were found in the library: <br><br>  You could not write the following code in VS2012 <br><br><pre> <code class="cpp hljs">ratio_add&lt;ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;&gt;::num; ratio_add&lt;ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;&gt;::den;</code> </pre><br><br>  Instead, you were forced to refer to the numerator and denominator through their type: <br><br><pre> <code class="cpp hljs">ratio_add&lt;ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;&gt;::type::den; ratio_add&lt;ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;&gt;::type::num;</code> </pre><br><br>  Another mistake was in the implementation of the comparison. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"2/60 &lt; -1/3: "</span></span> &lt;&lt; ratio_less&lt;r2_60, r1_3&gt;::value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// false cout &lt;&lt; "2/60 &lt; 1/-3: " &lt;&lt; ratio_less&lt;r2_60, ratio&lt;1, -3&gt;&gt;::value &lt;&lt; endl; // true    false</span></span></code> </pre><br><br>  Thus, in VS2012, you had to be sure that the denominator transferred to the template is always a positive number. <br><br>  Another bug was that ratio_equal correctly defined inequality, but not always correctly defined equality: <br><br><pre> <code class="cpp hljs">ratio_equal&lt;ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, ratio&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt;&gt;::value; <span class="hljs-comment"><span class="hljs-comment">// false    true</span></span></code> </pre><br><br>  And here's another bug.  When you have a ratio &lt;N, D&gt;, if D is zero or a number greater than intmax_t, your program is definitely invalid.  Visual Studio 2012, however, did not detect such errors: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ratio&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; r_error; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r_error::den &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,  </span></span></code> </pre><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ratio&lt;INTMAX_MIN, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; r_error2; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r_error2::num &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,  </span></span></code> </pre><br>  In the Visual Studio implementation, static_assert statements that should work in these situations are placed in the ratio constructor.  But the constructor works only when creating a class object, and in the examples above this does not happen. <br><br>  Similarly, some code is compiled, although it should not: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     -     ratio_multiply&lt;ratio&lt;1, INTMAX_MAX&gt;, ratio&lt;1, 2&gt;&gt;::type;</span></span></code> </pre><br><br><h4>  Other errors in Visual Studio 2013 </h4><br><h5>  Tuple_element does not check for overruns </h5>  tuple_element &lt;I, array &lt;T, N &gt;&gt; should verify that I &lt;N and not compile if it is not.  This did not happen until VS2013. <br><br><h5>  Invalid conversion to bool for std :: function </h5>  In some cases, the conversion could give an incorrect result in VS2012, since the object was not empty when, in theory, it should be: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// JetPlane   Plane function&lt;bool(JetPlane*)&gt; plane_ready_func = function&lt;bool(Plane*)&gt;(); if (plane_ready_func) //   false,   { plane_ready_func(nullptr); //    bad_function_call }</span></span></code> </pre><br><br><h5>  Assignment for rvalues </h5>  Visual Studio 2012 does not prohibit assignments for rvalues, as defined by the standard: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dummy</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; }; <span class="hljs-function"><span class="hljs-function">Dummy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_dummy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dummy d = { <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; } get_dummy()._x = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,    </span></span></code> </pre><br><br><h5>  align () incorrectly updating out-parameters </h5>  The function correctly calculates the returned address, but incorrectly updates the last two parameters: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   200     32  //      230  size_t space = 230; void* res = align(32, 200, (void*&amp;)p, space); // res  null  31    , //     30 space = 256; //     256 res = align(32, 200, (void*&amp;)p, space); // res  0x20 (    32) // p  0xE8 (200 + 32)    0x20 // space  25    225</span></span></code> </pre><br><br><h5>  time_put does not work with wchar_t </h5>  time_put does not generate output when wchar_t is initialized. <br><br><h4>  Conclusion </h4><br>  You can read the full list of changes in VS2013 (not only in C ++ 11) in <a href="http://blogs.msdn.com/b/vcblog/archive/2013/06/28/c-11-14-stl-features-fixes-and-breaking-changes-in-vs-2013.aspx">this post</a> written by Stephan Lavavej. <br><br>  In addition to implementing C ++ 11 features, Visual Studio 2013 fixed many bugs in existing compiler functionality and libraries, from incorrect compiler errors to memory leaks and poor performance.  This is definitely a positive dynamic. <br><br>  Unfortunately, VS2013 still contains a number of bugs inherited from VS2012 and adds some new ones.  I‚Äôm writing a book about all this, it‚Äôs not finished yet, but you can read something <a href="http://cpprocks.com/">now</a> . </div><p>Source: <a href="https://habr.com/ru/post/213863/">https://habr.com/ru/post/213863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213847/index.html">Knockout-popover: A Simple Binding of Twitter Bootstrap Popover for KnockoutJS</a></li>
<li><a href="../213849/index.html">ElasticSearch 1.0 - new analytics features</a></li>
<li><a href="../213851/index.html">Stephen Elop to head Microsoft gaming division</a></li>
<li><a href="../213859/index.html">Management tools: A set of furniture keys or how to come up with constructive arguments</a></li>
<li><a href="../213861/index.html">Review of the first tablet Nokia Lumia 2520</a></li>
<li><a href="../213865/index.html">The new version of the mobile application Payoneer</a></li>
<li><a href="../213867/index.html">Atlassian JIRA 6.2: Be better than yesterday</a></li>
<li><a href="../213873/index.html">What needs to be taught in the Master in Computer Science?</a></li>
<li><a href="../213875/index.html">Organizing code in django applications or thick models is great.</a></li>
<li><a href="../213881/index.html">Rocket SpaceX Falcon-9 will test folding support for a soft landing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>