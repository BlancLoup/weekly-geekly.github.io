<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Benefits of Common Lisp</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lisp is often advertised as a language with advantages over the rest because it has some unique, well-integrated and useful features. 

 The following...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Benefits of Common Lisp</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/058/497/397/058497397d77cc56a36c2f096996717b.png" align="right">  Lisp is often advertised as a language with advantages over the rest because it has some unique, well-integrated and useful features. <br><br>  The following is an attempt to highlight a set of features of standard Common Lisp, briefly and with examples. <br><br>  This article is likely to be most useful to those who have some programming experience, are interested in Lisp and want to better understand what makes it so attractive. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The text is largely based on a list of CL features and a CL review by Robert Strandh. <a name="habracut"></a><br><br><h4>  Rich and accurate arithmetic </h4><br>  Lisp provides a rich hierarchy of numeric types that are well integrated with the rest of the language. <br><br>  <b>Long numbers</b> (bignums) are created automatically as needed, which reduces the risk of overflows and ensures accuracy.  For example, we can quickly calculate the value 10 ‚Üë‚Üë 4: <br><br><pre><code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">expt</span></span> (<span class="hljs-name"><span class="hljs-name">expt</span></span> (<span class="hljs-name"><span class="hljs-name">expt</span></span> (<span class="hljs-name"><span class="hljs-name">expt</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">100000000000000000000000000000000000</span></span>[...]</code> </pre> <br>  <b>Rational numbers are</b> represented as fractions, so no rounding error occurs when using them.  Accurate rational arithmetic is integrated into the language: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">5/9</span></span> <span class="hljs-number"><span class="hljs-number">3/4</span></span>) <span class="hljs-number"><span class="hljs-number">47/36</span></span></code> </pre><br>  <b>Complex numbers</b> are also a built-in data type in a lisp.  They can be presented in the form of a short syntax: #c (10 5) means 10 + 5i.  Arithmetic operations can also work with complex values: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">#c(10 5)</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>)) <span class="hljs-number"><span class="hljs-number">#C(28 10)</span></span></code> </pre><br><br><h4>  Generalized links </h4><br>  <i>Forms</i> or <i>positions</i> can be used as if they were separate variable variables.  Using SETF and other similar constructions, you can change the values ‚Äã‚Äãthat are conceptually related to a given position. <br><br>  For example, you can use SETF as follows: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *colours* (<span class="hljs-name"><span class="hljs-name">list</span></span> 'red 'green 'blue)) *COLOURS* &gt; (<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">first</span></span> *colours*) 'yellow) YELLOW &gt; *colours* (<span class="hljs-name"><span class="hljs-name">YELLOW</span></span> BLUE GREEN)</code> </pre><br>  And PUSH - so: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">push</span></span> 'red (<span class="hljs-name"><span class="hljs-name">rest</span></span> *colours*)) (<span class="hljs-name"><span class="hljs-name">RED</span></span> BLUE GREEN) &gt; *colours* (<span class="hljs-name"><span class="hljs-name">YELLOW</span></span> RED BLUE GREEN)</code> </pre><br>  Generalized links work not only when applied to lists, but also to many other types of structures and objects.  For example, in object-oriented programs, one of the ways to change some field of an object is using SETF. <br><br><h4>  Plural values </h4><br>  Values ‚Äã‚Äãcan be combined without explicitly creating a structure, such as a list.  For example, (values ‚Äã‚Äã'foo' bar) returns two values ‚Äã‚Äã- 'foo and' bar.  Using this mechanism, functions can return several values ‚Äã‚Äãat once, which can simplify the program. <br><br>  For example, FLOOR is a standard function that returns two values: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">floor</span></span> pi) <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0.14159265358979312d0</span></span></code> </pre><br>  By convention, functions that return multiple values ‚Äã‚Äãare used by default as if only one value was returned ‚Äî the first. <br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">+</span></span> (<span class="hljs-name"><span class="hljs-name">floor</span></span> pi) <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  In this case, you can explicitly get and use the other values.  In the following example, we separate the integer and fractional parts of PI when rounding: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">multiple-value-bind</span></span> (<span class="hljs-name"><span class="hljs-name">integral</span></span> fractional) (<span class="hljs-name"><span class="hljs-name">floor</span></span> pi) (<span class="hljs-name"><span class="hljs-name">+</span></span> integral fractional)) <span class="hljs-number"><span class="hljs-number">3.141592653589793d0</span></span></code> </pre><br><br><h4>  Macros </h4><br>  A macro in a lisp is a kind of function that takes lisp forms or objects as arguments and, as a rule, generates code that will then be compiled and executed.  This happens before the program is executed, during a phase called <i>macro</i> expansion (macroexpansion).  Macros can perform some calculations during the sweep, using the full capabilities of the language. <br><br>  One of the uses of macros is to convert any source code into a representation that is correct in terms of already existing definitions.  In other words, macros allow you to add a new syntax to the language (this approach is known as <i>syntactic abstraction</i> ). <br><br>  This allows you to easily embed domain-specific languages ‚Äã‚Äã(DSL) in Lisp, since a special syntax can be added to the language before executing the program. <br><br>  The main benefit of using macros is that they extend the capabilities of the language, allowing the programmer to express his ideas more easily and with less code.  You can add new tools to the language as if they were embedded.  In addition, if macros are used for preliminary data calculation or initialization, they can help optimize performance. <br><br><h4>  LOOP macro </h4><br>  The LOOP macro is a powerful tool for representing loops.  In fact, it is a whole small embedded language for describing iterative processes.  LOOP provides all the necessary types of expressions for writing loops, from simple iterations to iterators to complex finite automata. <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *list* (<span class="hljs-name"><span class="hljs-name">loop</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:for</span></span> x <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> (<span class="hljs-name"><span class="hljs-name">random</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:repeat</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:collect</span></span> x)) *LIST* &gt; *list* (<span class="hljs-number"><span class="hljs-number">324</span></span> <span class="hljs-number"><span class="hljs-number">794</span></span> <span class="hljs-number"><span class="hljs-number">102</span></span> <span class="hljs-number"><span class="hljs-number">579</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span>)</code> </pre><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">loop</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:for</span></span> elt <span class="hljs-symbol"><span class="hljs-symbol">:in</span></span> *list* <span class="hljs-symbol"><span class="hljs-symbol">:when</span></span> (<span class="hljs-name"><span class="hljs-name">oddp</span></span> elt) <span class="hljs-symbol"><span class="hljs-symbol">:maximizing</span></span> elt) <span class="hljs-number"><span class="hljs-number">579</span></span></code> </pre><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">loop</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:for</span></span> elt <span class="hljs-symbol"><span class="hljs-symbol">:in</span></span> *list* <span class="hljs-symbol"><span class="hljs-symbol">:collect</span></span> (<span class="hljs-name"><span class="hljs-name">log</span></span> elt) <span class="hljs-symbol"><span class="hljs-symbol">:into</span></span> logs <span class="hljs-symbol"><span class="hljs-symbol">:finally</span></span> (<span class="hljs-name"><span class="hljs-name">return</span></span> (<span class="hljs-name"><span class="hljs-name">loop</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:for</span></span> l <span class="hljs-symbol"><span class="hljs-symbol">:in</span></span> logs <span class="hljs-symbol"><span class="hljs-symbol">:if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> l <span class="hljs-number"><span class="hljs-number">5.0</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:collect</span></span> l <span class="hljs-symbol"><span class="hljs-symbol">:into</span></span> ms <span class="hljs-symbol"><span class="hljs-symbol">:else</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:collect</span></span> l <span class="hljs-symbol"><span class="hljs-symbol">:into</span></span> ns <span class="hljs-symbol"><span class="hljs-symbol">:finally</span></span> (<span class="hljs-name"><span class="hljs-name">return</span></span> (<span class="hljs-name"><span class="hljs-name">values</span></span> ms ns))))) (<span class="hljs-number"><span class="hljs-number">5.7807436</span></span> <span class="hljs-number"><span class="hljs-number">6.6770835</span></span> <span class="hljs-number"><span class="hljs-number">6.3613024</span></span>) (<span class="hljs-number"><span class="hljs-number">4.624973</span></span> <span class="hljs-number"><span class="hljs-number">4.0073333</span></span>)</code> </pre><br><br><h4>  FORMAT function </h4><br>  The FORMAT function supports a built-in language for describing how data should be formatted.  In addition to simple textual substitution, FORMAT statements can express in a compact form various rules for generating text, such as conditions, cycles, and handling of boundary cases. <br><br>  We can format the name list with this function: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> format-names (<span class="hljs-name"><span class="hljs-name">list</span></span>) (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-string"><span class="hljs-string">"~{~:(~a~)~#[.~; and ~:;, ~]~}"</span></span> list))</code> </pre><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">format-names</span></span> '(doc grumpy happy sleepy bashful sneezy dopey)) <span class="hljs-string"><span class="hljs-string">"Doc, Grumpy, Happy, Sleepy, Bashful, Sneezy and Dopey."</span></span> &gt; (<span class="hljs-name"><span class="hljs-name">format-names</span></span> '(fry laurie)) <span class="hljs-string"><span class="hljs-string">"Fry and Laurie."</span></span> &gt; (<span class="hljs-name"><span class="hljs-name">format-names</span></span> '(bluebeard)) <span class="hljs-string"><span class="hljs-string">"Bluebeard."</span></span></code> </pre><br>  FORMAT transfers its result to the specified stream, be it standard output to the screen, a string, or any other stream. <br><br><h4>  Higher order functions </h4><br>  Functions in Lisp are real essential first class.  Functional objects can be dynamically created, transmitted as parameters, or returned as a result.  Thus, <b>higher-order</b> functions are supported, that is, such arguments and whose returned values ‚Äã‚Äãcan themselves be functions. <br><br>  Here you see the call to the SORT function, whose arguments are a list and another function (in this case # '&lt;): <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">sort</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) #'&lt;) (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br>  <b>Anonymous functions</b> , also called lambda expressions, can be used instead of the name of the function being passed.  They are especially useful when you want to create a function for one-time use, without clogging the program with an unnecessary name.  In general, they can be used to create lexical closures. <br><br>  In this example, we create an anonymous function to use it as the first argument of MAPCAR: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">+</span></span> x <span class="hljs-number"><span class="hljs-number">10</span></span>)) '(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>)) (<span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>)</code> </pre><br>  When creating a function, they capture the context, which allows us to use full-fledged lexical closures: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">counter</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>)) (<span class="hljs-name"><span class="hljs-name">defun</span></span> add-counter (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">prog1</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> counter x) (<span class="hljs-name"><span class="hljs-name">incf</span></span> counter))))</code> </pre><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> #'add-counter '(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span>) &gt; (<span class="hljs-name"><span class="hljs-name">add-counter</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>) <span class="hljs-number"><span class="hljs-number">64</span></span></code> </pre><br><br><h4>  Processing lists </h4><br>  Since lists are the fundamental built-in data type in Lisp, there is an extensive set of functions for manipulating lists.  Thanks to these functions and macros, lists can be used to quickly prototype other data structures. <br><br>  For example, we can work with a regular list like this: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *nums* (<span class="hljs-name"><span class="hljs-name">list</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>)) *NUMS* &gt; (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">fourth</span></span> *nums*) (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> *nums*)) (<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt; (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">last</span></span> *nums*) (<span class="hljs-name"><span class="hljs-name">butlast</span></span> *nums*)) ((<span class="hljs-number"><span class="hljs-number">12</span></span>) (<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>)) &gt; (<span class="hljs-name"><span class="hljs-name">remove-if-not</span></span> #'evenp *nums*) (<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>)</code> </pre><br>  And so - with an associative list <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *capital-cities* '((NZ . Wellington) (AU . Canberra) (CA . Ottawa))) *CAPITAL-CITIES* &gt; (<span class="hljs-name"><span class="hljs-name">cdr</span></span> (<span class="hljs-name"><span class="hljs-name">assoc</span></span> 'CA *capital-cities*)) OTTAWA &gt; (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> #'car *capital-cities*) (<span class="hljs-name"><span class="hljs-name">NZ</span></span> AU CA)</code> </pre><br><br><h4>  Lambda lists </h4><br>  The lambda list sets the parameters for functions, macros, binding forms and some other constructions.  Lambda lists define mandatory, optional, named, tail (rest) and optional parameters, as well as defaults and the like.  This allows you to define very flexible and expressive interfaces. <br><br>  <b>Optional parameters</b> do not require the caller to specify any value.  For them, a default value can be defined, otherwise, the called code can check whether a value has been provided and act on the situation. <br><br>  The following function accepts an optional delimiter parameter, the default for which is a whitespace character: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> explode (<span class="hljs-name"><span class="hljs-name">string</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">delimiter</span></span> #\Space)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">pos</span></span> (<span class="hljs-name"><span class="hljs-name">position</span></span> delimiter string))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> pos) (<span class="hljs-name"><span class="hljs-name">list</span></span> string) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> string <span class="hljs-number"><span class="hljs-number">0</span></span> pos) (<span class="hljs-name"><span class="hljs-name">explode</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> string (<span class="hljs-number"><span class="hljs-number">1</span></span>+ pos)) delimiter)))))</code> </pre><br>  When calling the EXPLODE function, we can either provide an optional parameter or omit it. <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">explode</span></span> <span class="hljs-string"><span class="hljs-string">"foo, bar, baz"</span></span> #\,) (<span class="hljs-string"><span class="hljs-string">"foo "</span></span> <span class="hljs-string"><span class="hljs-string">" bar "</span></span> <span class="hljs-string"><span class="hljs-string">" baz"</span></span>)</code> </pre><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">explode</span></span> <span class="hljs-string"><span class="hljs-string">"foo, bar, baz"</span></span>) (<span class="hljs-string"><span class="hljs-string">"foo,"</span></span> <span class="hljs-string"><span class="hljs-string">"bar,"</span></span> <span class="hljs-string"><span class="hljs-string">"baz"</span></span>)</code> </pre><br>  <b>Named parameters are</b> similar to optional parameters, but they can be passed in any order, since they are defined by names.  The use of names improves the readability of the code and serves as a kind of documentation when you make a call with several parameters. <br><br>  For example, compare these two function calls: <br><br><pre> <code class="lisp hljs">// In C: xf86InitValuatorAxisStruct(<span class="hljs-name"><span class="hljs-name">device</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;; In Lisp: (xf86-init-valuator-axis-struct :dev device :ax-num 0 :min-val 0 :max-val -1 :min-res 0 :max-res 1 :resolution 1)</span></span></code> </pre><br><br><h4>  Symbols as first-class entities </h4><br>  Symbols are unique objects completely defined by their names.  Let's say 'foo is a symbol whose name is ‚ÄúFOO‚Äù.  Symbols can be used as identifiers or as certain abstract names.  Comparison of characters occurs in a fixed time. <br><br>  Symbols, like functions, are first-class entities.  They can be dynamically created, quoted (quote, unevaluate), stored, passed as arguments, compared, converted into strings, exported and imported, they can be referenced. <br><br>  Here '* foo * is the variable identifier: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *foo* <span class="hljs-number"><span class="hljs-number">5</span></span>) *FOO* &gt; (<span class="hljs-name"><span class="hljs-name">symbol-value</span></span> '*foo*) <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br><br><h4>  Packages as first class entities </h4><br>  Packages that play the role of namespaces (namespaces) are also first class objects.  Since they can be created, stored, returned as a result at runtime, it is possible to dynamically switch the context or convert namespaces dynamically. <br><br>  In the following example, we use INTERN to include a symbol in some package: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">intern</span></span> <span class="hljs-string"><span class="hljs-string">"ARBITRARY"</span></span> (<span class="hljs-name"><span class="hljs-name">make-package</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:foo</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:use</span></span> '(<span class="hljs-symbol"><span class="hljs-symbol">:cl</span></span>))) FOO::ARBITRARY NIL</code> </pre><br>  There is a special variable * package * in the list that indicates the current package.  Let's say if the current packet is FOO, then you can run: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">in-package</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:foo</span></span>) #&lt;PACKAGE <span class="hljs-string"><span class="hljs-string">"FOO"</span></span>&gt; &gt; (<span class="hljs-name"><span class="hljs-name">package-name</span></span> *package*) <span class="hljs-string"><span class="hljs-string">"FOO"</span></span></code> </pre><br><br><h4>  Special variables </h4><br>  Lisp supports dynamic context variables in addition to lexical context.  Dynamic variables in some cases can be useful, so their support allows for maximum flexibility. <br><br>  For example, we can redirect the output of some code to a nonstandard stream, such as a file, by creating a dynamic link for the special variable * standard-output *: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">with-open-file</span></span> (<span class="hljs-name"><span class="hljs-name">file-stream</span></span> #p<span class="hljs-string"><span class="hljs-string">"somefile"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:direction</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:output</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">*standard-output*</span></span> file-stream)) (<span class="hljs-name"><span class="hljs-name">print</span></span> <span class="hljs-string"><span class="hljs-string">"This prints to the file, not stdout."</span></span>)) (<span class="hljs-name"><span class="hljs-name">print</span></span> <span class="hljs-string"><span class="hljs-string">"And this prints to stdout, not the file."</span></span>))</code> </pre><br>  In addition to * standard-output *, Lisp includes several special variables that store program state, including resources and parameters, such as * standard-input *, * package *, * readtable *, * print-readably *, * print-circle * etc. <br><br><h4>  Transfer of control </h4><br>  In Lisp, there are two ways to transfer control to a point higher in the call hierarchy.  In this case, the lexical or dynamic domain can be taken into account for local and non-local transitions, respectively. <br><br>  <b>Named blocks</b> allow a nested form to return control from any named parent form using BLOCK and RETURN-FROM. <br><br>  For example, here the nested loop returns a list from the early block to bypass the outer loop: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">block</span></span> early (<span class="hljs-name"><span class="hljs-name">loop</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:repeat</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:do</span></span> (<span class="hljs-name"><span class="hljs-name">loop</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:for</span></span> x <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:to</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:collect</span></span> x <span class="hljs-symbol"><span class="hljs-symbol">:into</span></span> xs <span class="hljs-symbol"><span class="hljs-symbol">:finally</span></span> (<span class="hljs-name"><span class="hljs-name">return-from</span></span> early xs)))) (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><br>  <b>Catch / throw</b> is something like a non-local goto.  THROW jumps to the last CATCH encountered and passes the value that was specified as a parameter. <br><br>  In the THROW-RANGE function, based on the previous example, we can apply THROW and CATCH using the dynamic state of the program. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> throw-range (<span class="hljs-name"><span class="hljs-name">ab</span></span>) (<span class="hljs-name"><span class="hljs-name">loop</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:for</span></span> x <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> a <span class="hljs-symbol"><span class="hljs-symbol">:to</span></span> b <span class="hljs-symbol"><span class="hljs-symbol">:collect</span></span> x <span class="hljs-symbol"><span class="hljs-symbol">:into</span></span> xs <span class="hljs-symbol"><span class="hljs-symbol">:finally</span></span> (<span class="hljs-name"><span class="hljs-name">throw</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:early</span></span> xs)))</code> </pre><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">catch</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:early</span></span> (<span class="hljs-name"><span class="hljs-name">loop</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:repeat</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:do</span></span> (<span class="hljs-name"><span class="hljs-name">throw-range</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>))) (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><br>  When it is enough to use the lexical scope and catch / throw, when it is necessary to take into account the dynamic state. <br><br><h4>  Conditions restart </h4><br>  A system of conditions in a Lisp is a mechanism for transmitting signals between parts of a program. <br><br>  One possible use is to throw exceptions and handle them, much like it does in Java or Python.  But, unlike other languages, during the signal transmission in the Lisp, the stack <i>does not unfold</i> , therefore all data is saved and the signal handler can restart the program from any point in the stack. <br><br>  This approach to the handling of exceptional situations allows to improve the separation of tasks and thus achieve greater structuring of the code.  But such a mechanism has a wider scope, as a system for transmitting arbitrary messages (and not just errors) between parts of a program. <br><br>  An example of using the condition system can be found in the <a href="http://chaitanyagupta.com/lisp/restarts.html">Common Lisp</a> article <a href="http://chaitanyagupta.com/lisp/restarts.html">: A Tutorial on Conditions and Restarts</a> . <br><br><h4>  Generic functions </h4><br>  The Common Lisp object system (Common Lisp Object System, CLOS) does not bind methods to classes, but allows the use of generic functions. <br><br>  Generic functions define signatures that can be satisfied by several different methods.  When calling, the method that best matches the arguments is selected. <br><br>  Here we define a generic function that handles keyboard events: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defgeneric</span></span> key-input (<span class="hljs-name"><span class="hljs-name">key-name</span></span>))</code> </pre><br>  Then we define several methods that satisfy different KEY-NAME values. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmethod</span></span> key-input (<span class="hljs-name"><span class="hljs-name">key-name</span></span>) <span class="hljs-comment"><span class="hljs-comment">;; Default case (format nil "No keybinding for ~a" key-name)) (defmethod key-input ((key-name (eql :escape))) (format nil "Escape key pressed")) (defmethod key-input ((key-name (eql :space))) (format nil "Space key pressed"))</span></span></code> </pre><br>  Let's look at the method call in action: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">key-input</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:space</span></span>) <span class="hljs-string"><span class="hljs-string">"Space key pressed"</span></span> &gt; (<span class="hljs-name"><span class="hljs-name">key-input</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:return</span></span>) <span class="hljs-string"><span class="hljs-string">"No keybinding for RETURN"</span></span> &gt; (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> key-input ((<span class="hljs-name"><span class="hljs-name">key-name</span></span> (<span class="hljs-name"><span class="hljs-name">eql</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:return</span></span>))) (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-string"><span class="hljs-string">"Return key pressed"</span></span>)) &gt; (<span class="hljs-name"><span class="hljs-name">key-input</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:return</span></span>) <span class="hljs-string"><span class="hljs-string">"Return key pressed"</span></span></code> </pre><br>  We did without constructions a la switch and explicit work with the table of methods.  Thus, we can add processing of new special cases independently, dynamically, as needed, and generally at any point of the program.  This, in particular, ensures the development of programs on the bottom-up Lisp. <br><br>  Generic functions define some common characteristics of a group of methods.  For example, methods of combining methods, specialization options, and other properties can be set by a generalized function. <br><br>  Lisp provides many useful standard generic functions;  an example is PRINT-OBJECT, which can be specialized for any class to set its textual representation. <br><br><h4>  Combinations of methods </h4><br>  Combinations of methods allow for calling a method to perform a whole <i>chain of</i> methods, either in a certain order or so that some functions process the results of others. <br><br>  There are built-in ways of combining methods that line up the methods in a given order.  Methods equipped with keywords: before,: after or: around are placed in the appropriate place in the call chain. <br><br>  For example, in the previous example, each of the KEY-INPUT methods repeats the output of the phrase "key pressed".  We can improve the code with a combination like: around <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmethod</span></span> key-input <span class="hljs-symbol"><span class="hljs-symbol">:around</span></span> (<span class="hljs-name"><span class="hljs-name">key-name</span></span>) (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-string"><span class="hljs-string">"~:(~a~) key pressed"</span></span> (<span class="hljs-name"><span class="hljs-name">call-next-method</span></span> key-name)))</code> </pre><br>  After that, we will redefine the KEY-INPUT methods, specifying only one line in each of them: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmethod</span></span> key-input ((<span class="hljs-name"><span class="hljs-name">key-name</span></span> (<span class="hljs-name"><span class="hljs-name">eql</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:escape</span></span>))) <span class="hljs-string"><span class="hljs-string">"escape"</span></span>)</code> </pre><br>  When KEY-INPUT is called, the following happens: <br><ul><li>  the method with a tag is called: around </li><li>  it calls the following method, that is, one of the specialized versions of KEY-INPUT, </li><li>  which returns a string, and this string formats the c: around method. </li></ul><br>  It should be noted that the default option can be processed in different ways.  We can simply use the THROW / CATCH pair (a more advanced implementation could use conditions): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmethod</span></span> key-input (<span class="hljs-name"><span class="hljs-name">key-name</span></span>) (<span class="hljs-name"><span class="hljs-name">throw</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:default</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-string"><span class="hljs-string">"No keybinding for ~a"</span></span> key-name))) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> key-input <span class="hljs-symbol"><span class="hljs-symbol">:around</span></span> (<span class="hljs-name"><span class="hljs-name">key-name</span></span>) (<span class="hljs-name"><span class="hljs-name">catch</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:default</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-string"><span class="hljs-string">"~:(~a~) key pressed"</span></span> (<span class="hljs-name"><span class="hljs-name">call-next-method</span></span> key-name))))</code> </pre><br>  As a result, the built-in method of combining methods allows us to generalize the processing of events from the keyboard into a modular, extensible, easily changeable mechanism.  This technique can be complemented with user-defined combination methods;  let's say you can add a combination method that will perform the summation or sorting of the results of the methods. <br><br><h4>  Multiple inheritance </h4><br>  Any class can have many ancestors, which allows you to create richer models and achieve more efficient code reuse.  The behavior of the child classes is determined in accordance with the order, which is based on the definitions of ancestor classes. <br><br>  With the help of combinations of methods, metaobject protocol and other features of CLOS, you can bypass the traditional problems of multiple inheritance (such as fork-join). <br><br><h4>  Meta-Object Protocol </h4><br>  Meta-object protocol (Meta-object protocol, MOP) is a software interface to CLOS, which itself is implemented using CLOS.  MOP allows programmers to explore, use and modify the internal structure of CLOS through CLOS itself. <br><br><h4>  Classes as first class entities </h4><br>  Classes themselves are also objects.  Using MOP, you can change the definition and behavior of classes. <br><br>  Let the class FOO be a descendant of the class BAR, then we can add, say, the class BAZ to the list of ancestors FOO using the ENSURE-CLASS function: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defclass</span></span> bar () ()) (<span class="hljs-name"><span class="hljs-name">defclass</span></span> foo (<span class="hljs-name"><span class="hljs-name">bar</span></span>) ()) (<span class="hljs-name"><span class="hljs-name">defclass</span></span> baz () ())</code> </pre><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">class-direct-superclasses</span></span> (<span class="hljs-name"><span class="hljs-name">find-class</span></span> 'foo)) (<span class="hljs-name"><span class="hljs-name">#&lt;STANDARD-CLASS</span></span> BAR&gt;) &gt; (<span class="hljs-name"><span class="hljs-name">ensure-class</span></span> 'foo <span class="hljs-symbol"><span class="hljs-symbol">:direct-superclasses</span></span> '(bar baz)) #&lt;STANDARD-CLASS FOO&gt; &gt; (<span class="hljs-name"><span class="hljs-name">class-direct-superclasses</span></span> (<span class="hljs-name"><span class="hljs-name">find-class</span></span> 'foo)) (<span class="hljs-name"><span class="hljs-name">#&lt;STANDARD-CLASS</span></span> BAR&gt; #&lt;STANDARD-CLASS BAZ&gt;)</code> </pre><br>  We used the CLASS-DIRECT-SUPERCLASSES function to get information about the ancestors of the class;  in this case, it takes as its argument a class in the form of an object obtained from FIND-CLASS. <br><br>  The above example illustrates the mechanism by which classes can be modified during program execution, which allows, among other things, to dynamically add impurities to the classes (mixins). <br><br><h4>  Dynamic overrides </h4><br>  Lisp is a very interactive and dynamic environment.  Functions, macros, classes, packages, parameters, and objects can be redefined at almost any time, and the result will be adequate and predictable. <br><br>  So, if you redefine a class during program execution, the changes will immediately be applied to all objects and subclasses of this class.  We can define a BALL class with the radius property and its subclass TENNIS-BALL: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defclass</span></span> ball () ((%radius <span class="hljs-symbol"><span class="hljs-symbol">:initform</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> radius))) #&lt;STANDARD-CLASS BALL&gt; &gt; (<span class="hljs-name"><span class="hljs-name">defclass</span></span> tennis-ball (<span class="hljs-name"><span class="hljs-name">ball</span></span>) ()) #&lt;STANDARD-CLASS TENNIS-BALL&gt;</code> </pre><br>  Here is an object of the TENNIS-BALL class, it has a slot for the radius property: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *my-ball* (<span class="hljs-name"><span class="hljs-name">make-instance</span></span> 'tennis-ball)) *MY-BALL* &gt; (<span class="hljs-name"><span class="hljs-name">radius</span></span> *my-ball*) <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  And now we can redefine the BALL class by adding another volume slot to it: <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defclass</span></span> ball () ((%radius <span class="hljs-symbol"><span class="hljs-symbol">:initform</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> radius) (%volume <span class="hljs-symbol"><span class="hljs-symbol">:initform</span></span> (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">4/3</span></span> pi <span class="hljs-number"><span class="hljs-number">1e3</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> volume))) #&lt;STANDARD-CLASS BALL&gt;</code> </pre><br>  And * MY-BALL * was automatically updated, having received a new slot, which was defined in the ancestor class. <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">volume</span></span> *my-ball*) <span class="hljs-number"><span class="hljs-number">4188.790204786391d0</span></span></code> </pre><br><br><h4>  Access to the compiler at runtime </h4><br>  Thanks to the COMPILE and COMPILE-FILE functions, the lisp compiler can be directly used from the executable program.  Thus, functions that are created or modified while the program is running can also be compiled. <br><br>  It turns out that programs can be compiled step by step, which makes development interactive, dynamic and fast.  Running programs can be changed, debugged and grow gradually. <br><br><h4>  Compilation macros </h4><br>  Compilation macros define alternative strategies for compiling a function or macro.  Unlike conventional macros, a compilation macro does not extend the syntax of the language and can only be applied at compile time.       ,         . <br><br><h4>   </h4><br>        ‚Äî       ‚Äî      . ,    ,    ,       . <br><br> ,         EXPLODE,  : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> explode (<span class="hljs-name"><span class="hljs-name">string</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">delimiter</span></span> #\Space)) (<span class="hljs-name"><span class="hljs-name">declare</span></span> (<span class="hljs-name"><span class="hljs-name">type</span></span> character delimiter) (<span class="hljs-name"><span class="hljs-name">type</span></span> string string)) ...)</code> </pre><br><br><h4>   </h4><br>       .          ,    S-.       . <br><br>      ,   READ, READ-CHAR, READ-LINE, READ-FROM-STRING  ..     ,      , ,  ,             . <br><br>       READ-FROM-STRING,    (400 500 600),   ,   "(400 500 600)". <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">read-from-string</span></span> <span class="hljs-string"><span class="hljs-string">"(400 500 600)"</span></span>) (<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">600</span></span>) <span class="hljs-number"><span class="hljs-number">13</span></span> &gt; (<span class="hljs-name"><span class="hljs-name">type-of</span></span> (<span class="hljs-name"><span class="hljs-name">read-from-string</span></span> <span class="hljs-string"><span class="hljs-string">"t"</span></span>)) BOOLEAN</code> </pre><br> <b> </b> (reader macros)       .   ,     .   ‚Äî        (  ,    ). <br><br>    : <br><ul><li> #'foo ‚Äî , </li><li> #\\ ‚Äî  (characters), </li><li> #c(4 3) ‚Äî  , </li><li> #p"/path/" ‚Äî   . </li></ul><br>     ,     ;  ,        .    ,    ,      (read-eval-print loop, REPL). <br><br>              : <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">read-from-string</span></span> <span class="hljs-string"><span class="hljs-string">"#xBB"</span></span>) <span class="hljs-number"><span class="hljs-number">187</span></span></code> </pre><br><br><h4>   </h4><br>          ,   -     . <br><br> PRINT-OBJECT ‚Äî    ,        ,          .   ,     ,   ,     FORMAT, PRINT   REPL. <br><br>   JOURNEY: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defclass</span></span> journey () ((%from <span class="hljs-symbol"><span class="hljs-symbol">:initarg</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> from) (%to <span class="hljs-symbol"><span class="hljs-symbol">:initarg</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:to</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> to) (%period <span class="hljs-symbol"><span class="hljs-symbol">:initarg</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:period</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> period) (%mode <span class="hljs-symbol"><span class="hljs-symbol">:initarg</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:mode</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> mode)))</code> </pre><br>       JOURNEY,    : <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *journey* (<span class="hljs-name"><span class="hljs-name">make-instance</span></span> 'journey <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> <span class="hljs-string"><span class="hljs-string">"Christchurch"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:to</span></span> <span class="hljs-string"><span class="hljs-string">"Dunedin"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:period</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:mode</span></span> <span class="hljs-string"><span class="hljs-string">"bicycle"</span></span>)) *JOURNEY* &gt; (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-string"><span class="hljs-string">"~a"</span></span> *journey*) <span class="hljs-string"><span class="hljs-string">"#&lt;JOURNEY {10044DCCA1}&gt;"</span></span></code> </pre><br>    PRINT-OBJECT   JOURNEY,      -   : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmethod</span></span> print-object ((<span class="hljs-name"><span class="hljs-name">j</span></span> journey) (<span class="hljs-name"><span class="hljs-name">s</span></span> stream)) (<span class="hljs-name"><span class="hljs-name">format</span></span> s <span class="hljs-string"><span class="hljs-string">"~A to ~A (~A hours) by ~A."</span></span> (<span class="hljs-name"><span class="hljs-name">from</span></span> j) (<span class="hljs-name"><span class="hljs-name">to</span></span> j) (<span class="hljs-name"><span class="hljs-name">period</span></span> j) (<span class="hljs-name"><span class="hljs-name">mode</span></span> j)))</code> </pre><br>        : <br><br><pre> <code class="lisp hljs">&gt; (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-string"><span class="hljs-string">"~a"</span></span> *journey*) <span class="hljs-string"><span class="hljs-string">"Christchurch to Dunedin (20 hours) by bicycle."</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/143490/">https://habr.com/ru/post/143490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143480/index.html">The second Habradestra in Almaty</a></li>
<li><a href="../143482/index.html">Errors of technology transfer No. 3 / ‚ÄúErrors of offshore‚Äù + APDATE</a></li>
<li><a href="../143483/index.html">We delve into include and extend</a></li>
<li><a href="../143486/index.html">Changing the Visual Studio interface in the incoming RC</a></li>
<li><a href="../143489/index.html">Inside Startup sauna</a></li>
<li><a href="../143492/index.html">Electronic library for PocketBook: automatic processing</a></li>
<li><a href="../143494/index.html">Features of the culture of teaching in universities on computer specialties</a></li>
<li><a href="../143496/index.html">Oh this web</a></li>
<li><a href="../143497/index.html">Implementing an Identity Map Template in the Yii Framework</a></li>
<li><a href="../143498/index.html">Zabbix, we monitor MongoDB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>