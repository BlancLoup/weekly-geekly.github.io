<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Returning to Unallocated Final Interpreters with Dotty</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unallocated Final Interpreters (Tagless Final interpreters - approx. Lane ) is an alternative approach to traditional Algebraic Data Types (and genera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Returning to Unallocated Final Interpreters with Dotty</h1><div class="post__text post__text-html js-mediator-article"><p>  Unallocated Final Interpreters (Tagless Final interpreters - <em>approx. Lane</em> ) is an alternative approach to traditional Algebraic Data Types (and generalized ADT), based on the implementation of the "interpreter" pattern.  This text represents the "unpartitioned final" approach in Scala, and demonstrates how Dotty with its recently added types of implicit functions makes this approach even more attractive.  All code examples are direct translations of their Haskell versions presented in <a href="http://okmij.org/ftp/tagless-final/course/lecture.pdf">Typed Tagless Final Interpreters: Lecture Notes</a> (section 2). </p><br><p> The "interpreter" pattern has recently attracted more and more attention in the Scala community.  Much effort has been expended in fighting the most glaring lack of ADT / GADT-based solutions: extensibility.  To begin with, you can look at the <a href="https://github.com/typelevel/cats/blob/master/free/src/main/scala/cats/free/Inject.scala"><code>typeclass Inject</code></a> from cats as a realization of the ideas of the <a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf"><em>Data Type √† la Carte</em></a> .  The <a href="https://github.com/ProjectSeptemberInc/freek">Freek</a> library provides tools for combining more than two algebras, using decorations using the type-level operations apparatus.  The solution proposed by <a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Freer Monads, More Extensible Effects,</a> also emphasizes extensibility, and is inspired by a set of small Scala libraries, such as <a href="https://github.com/atnos-org/eff">eff</a> , <a href="https://github.com/djspiewak/emm">emm,</a> and <a href="https://github.com/m50d/paperdoll">paperdoll</a> .  Unallocated final interpreters approach in some sense from the opposite side, using class types in their immediate basis instead of more traditional ADT / GADT.  They also come with a great advantage in out-of-box extensibility without any obvious hazards. </p><br><a name="habracut"></a><br><p>  <a href="http://okmij.org/ftp/tagless-final/course/lecture.pdf">Synopsis</a> goes into the details of the presentation and comparison of approaches using ADT / GADT and class types, designating the first as the <em>initial</em> and the second as the <em>final</em> .  For the sake of brevity, this text is devoted mainly to <em>final</em> interpreters. </p><br><h2 id="vvedenie">  Introduction </h2><br><p>  We will work with simple mathematical expressions similar to those used in calculators.  Our task is not only to compute such expressions, but also to serialize them, deserialize and simplify them.  From the point of view of a lazy engineer, it is perfectly reasonable to present the domain using the (embedded) domain-specific language: among other things, it saves us from having to track possibly incorrect representations of our domain ‚Äî the basic programming language take care of this for us.  Our domain will consist only of integer literals, addition and capture with the opposite sign.  The encoding that originated in your mind may look like this: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lit</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">i: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Neg</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">e: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">IExp</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">r: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">IExp</span></span></span></span><span class="hljs-class"><span class="hljs-params">, l: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">IExp</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IExp</span></span></span></span></code> </pre> <br><p>  The mathematical expression <code>8 - (1 + 2)</code> , for example, can be encoded as a value of type <code>IExp</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fe: <span class="hljs-type"><span class="hljs-type">IExp</span></span> = <span class="hljs-type"><span class="hljs-type">Add</span></span>(<span class="hljs-type"><span class="hljs-type">Lit</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-type"><span class="hljs-type">Neg</span></span>(<span class="hljs-type"><span class="hljs-type">Add</span></span>(<span class="hljs-type"><span class="hljs-type">Lit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">Lit</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>))))</code> </pre> <br><p>  So far, everything looks simple, right?  The interpretation of <code>fe</code> as an integer will use a recursive function with type <code>IExp =&gt; Int</code> , serialization occurs with the function <code>IExp =&gt; Json</code> , deserialization goes in the opposite direction with <code>Json =&gt; Option[IExp]</code> , and transformations occur through the functions <code>IExp =&gt; IExp</code> . </p><br><p>  In terms of the abstract, the <code>IExp</code> data <code>IExp</code> corresponds to the <em>initial</em> encoding of our subject area.  For now, you can forget about this, because instead we will use the <em>final</em> encoding: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exp</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lit</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neg</span></span></span></span>(t: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">T</span></span>, r: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> }</code> </pre> <br><p>  How do we represent <code>8 - (1 + 2)</code> using <code>Exp</code> ?  Somehow like: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tf0</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = e.add(e.lit(<span class="hljs-number"><span class="hljs-number">8</span></span>), e.neg(e.add(e.lit(<span class="hljs-number"><span class="hljs-number">1</span></span>), e.lit(<span class="hljs-number"><span class="hljs-number">2</span></span>))))</code> </pre> <br><p>  In Haskell (with the appropriate language extension), <code>tf0</code> can be a polymorphic value.  In Scala, we use a function with a type parameter <code>T</code> and a constraint <code>implicit Exp[T]</code> .  The syntax can be simplified (for example) by getting rid of <code>e.</code>  using auxiliary functions: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpSyntax</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lit</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](i: <span class="hljs-type"><span class="hljs-type">Int</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = e.lit(i) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neg</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](t: <span class="hljs-type"><span class="hljs-type">T</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = e.neg(t) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](l: <span class="hljs-type"><span class="hljs-type">T</span></span>, r: <span class="hljs-type"><span class="hljs-type">T</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = e.add(l, r) } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">ExpSyntax</span></span>._ <span class="hljs-comment"><span class="hljs-comment">//        def tf1[T: Exp]: T = add(lit(8), neg(add(lit(1), lit(2))))</span></span></code> </pre> <br><p>  At this moment, you are probably wondering, <em>"how do we write an interpreter for this <code>tf1</code> ?"</em>  .  The answer is simple: defining an implementation of <code>Exp</code> ! </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> evalExp: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lit</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = i <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neg</span></span></span></span>(t: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = -t <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">Int</span></span>, r: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = l + r }</code> </pre> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printExp: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lit</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = i.toString <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neg</span></span></span></span>(t: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"(-</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$t</span></span></span><span class="hljs-string">)"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">String</span></span>, r: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$l</span></span></span><span class="hljs-string"> + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$r</span></span></span><span class="hljs-string">)"</span></span> }</code> </pre> <br><p>  Interpretation is done through the definition of types.  Let's look at <code>tf1</code> as <code>Int</code> : </p><br><pre> <code class="scala hljs">scala&gt; tf1[<span class="hljs-type"><span class="hljs-type">Int</span></span>] res0: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><p>  What about <code>tf1</code> as a <code>String</code> ? </p><br><pre> <code class="scala hljs">scala&gt; tf1[<span class="hljs-type"><span class="hljs-type">String</span></span>] res1: <span class="hljs-type"><span class="hljs-type">String</span></span> = (<span class="hljs-number"><span class="hljs-number">8</span></span> + (-(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>)))</code> </pre> <br><h2 id="rasshiryaemost">  Extensibility </h2><br><p>  What if we decide to supplement our mathematical expressions with a product operation?  In the <em>initial</em> (ADT-based) encoding of <code>IExp</code> , we would face two burdensome alternatives: update the definitions of the <code>IExp</code> data type <code>IExp</code> with all the interpreters that we have written so far, or rely on putting <code>IExp</code> values ‚Äã‚Äãinto abstract sums of types (coproducts - <em>. lane</em> ) in <a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf"><em>Data Type √† la Carte</em></a> style.  And in this respect, where the <em>final unpartitioned</em> approach truly manifests itself, since  it can be expanded in a natural way without changing (or even recompiling) the written code.  We will introduce a new, completely independent class of types for the operation of the product: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">T</span></span>, r: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultSyntax</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](l: <span class="hljs-type"><span class="hljs-type">T</span></span>, r: <span class="hljs-type"><span class="hljs-type">T</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = e.mul(l, r) } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MultSyntax</span></span>._</code> </pre> <br><p>  Expressions that use the multiplication of numbers require additional constraints <code>Mult</code> (additional implicit (implicit - <em>lane</em> ) argument <code>Mult[T]</code> , that's all).  This is how we define <code>tfm1 = 7 - 1 * 2</code> and <code>tfm2 = 7 * (8 - (1 + 2))</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tfm1</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">Exp</span></span> : <span class="hljs-type"><span class="hljs-type">Mult</span></span>] = add(lit(<span class="hljs-number"><span class="hljs-number">7</span></span>), neg(mul(lit(<span class="hljs-number"><span class="hljs-number">1</span></span>), lit(<span class="hljs-number"><span class="hljs-number">2</span></span>)))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tfm2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">Exp</span></span> : <span class="hljs-type"><span class="hljs-type">Mult</span></span>] = mul(lit(<span class="hljs-number"><span class="hljs-number">7</span></span>), tf1)</code> </pre> <br><p>  If you are not satisfied with adding everywhere <code>: Exp : Mult</code> , looking ahead, I will say what we will see at the end of the article: in Dotty this can be rendered into the type of an implicit function ((implicit-function-type - <em>approx. Lane</em> ). </p><br><p>  To interpret these new expressions, we must provide the <code>Mult</code> implementations for <code>Int</code> and <code>String</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> evalMult: <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">Int</span></span>, r: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = l * r } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printMult: <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">String</span></span>, r: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$l</span></span></span><span class="hljs-string"> * </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$r</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  Without any additional binding, the <code>Exp</code> and <code>Mult</code> implementations are automatically combined during interpretation: </p><br><pre> <code class="scala hljs">scala&gt; tfm1[<span class="hljs-type"><span class="hljs-type">String</span></span>] res2: <span class="hljs-type"><span class="hljs-type">String</span></span> = (<span class="hljs-number"><span class="hljs-number">7</span></span> + (<span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>)) scala&gt; tfm1[<span class="hljs-type"><span class="hljs-type">Int</span></span>] res3: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span> scala&gt; tfm2[<span class="hljs-type"><span class="hljs-type">String</span></span>] res4: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> * (<span class="hljs-number"><span class="hljs-number">8</span></span> + (-(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>))) scala&gt; tfm2[<span class="hljs-type"><span class="hljs-type">Int</span></span>] res4: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">35</span></span></code> </pre> <br><h2 id="deserializaciya">  Deserialization </h2><br><p>  We now move on to the more difficult task of deserialization.  The target format is a Json-like tree structure, defined as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leaf</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">s: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">s: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, ts: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Tree</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tree</span></span></span></span></code> </pre> <br><p>  Transforming expressions into this Json-like format is as simple as serializing to <code>String</code> .  Depending on where the <code>Exp</code> and <code>Mult</code> implementations are defined, they can be grouped together: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> toTree: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">Tree</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">Tree</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">Tree</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">Tree</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lit</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Tree</span></span> = <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-string"><span class="hljs-string">"Lit"</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Leaf</span></span>(i.toString))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neg</span></span></span></span>(t: <span class="hljs-type"><span class="hljs-type">Tree</span></span>): <span class="hljs-type"><span class="hljs-type">Tree</span></span> = <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-string"><span class="hljs-string">"Neg"</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>(t)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">Tree</span></span>, r: <span class="hljs-type"><span class="hljs-type">Tree</span></span>): <span class="hljs-type"><span class="hljs-type">Tree</span></span> = <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-string"><span class="hljs-string">"Add"</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>(l , r)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">Tree</span></span>, r: <span class="hljs-type"><span class="hljs-type">Tree</span></span>): <span class="hljs-type"><span class="hljs-type">Tree</span></span> = <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-string"><span class="hljs-string">"Mult"</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>(l , r)) }</code> </pre> <br><pre> <code class="scala hljs">scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tf1Tree = tf1[<span class="hljs-type"><span class="hljs-type">Tree</span></span>] tf1Tree: <span class="hljs-type"><span class="hljs-type">Tree</span></span> = <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Add</span></span>,<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Lit</span></span>,<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Leaf</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>))), <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Neg</span></span>,<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Add</span></span>,<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Lit</span></span>,<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Leaf</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>))), <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-type"><span class="hljs-type">Lit</span></span>,<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Leaf</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)))))))))</code> </pre> <br><p>  To deserialize, we need to describe the <code>fromTree</code> function to convert a Json-like <code>Tree</code> to its <em>final</em> encoding.  Given this, our <em>course-</em> encoded values ‚Äã‚Äãare functions of the type <code>[T] =&gt; Exp[T] =&gt; T</code> (in Dotty, this is the syntax for lambda function types <code>({type L[T] = Exp[T] =&gt; T})#L</code> ), our first guess is the definition of <code>fromTree</code> as <code>def fromTree[T](t: Tree)(implicit e: Exp[T]): Either[ErrMsg, T]</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrMsg</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readInt</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">ErrMsg</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.util.{<span class="hljs-type"><span class="hljs-type">Try</span></span>, <span class="hljs-type"><span class="hljs-type">Success</span></span>, <span class="hljs-type"><span class="hljs-type">Failure</span></span>} <span class="hljs-type"><span class="hljs-type">Try</span></span>(s.toInt) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(i) =&gt; <span class="hljs-type"><span class="hljs-type">Right</span></span>(i) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span>(f) =&gt; <span class="hljs-type"><span class="hljs-type">Left</span></span>(f.toString) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromTree</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](t: <span class="hljs-type"><span class="hljs-type">Tree</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">ErrMsg</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] = t <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-string"><span class="hljs-string">"Lit"</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Leaf</span></span>(n))) =&gt; readInt(n).right.map(e.lit) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-string"><span class="hljs-string">"Neg"</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>(t)) =&gt; fromTree(t).right.map(e.neg) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-string"><span class="hljs-string">"Add"</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>(l , r)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(lt &lt;- fromTree(l).right; rt &lt;- fromTree(r).right) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> e.add(lt, rt) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-type"><span class="hljs-type">Left</span></span>(<span class="hljs-string"><span class="hljs-string">s"  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$t</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br><p>  This will work, but since <code>T</code> and <code>Exp[T]</code> must be fully defined when calling <code>fromTree</code> , polymorphism is lost and the result <code>fromTree</code> may have a single interpretation.  We circumvent this problem by wrapping the result using the following approach: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapped</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> }</code> </pre> <br><p>  The abstract further suggests rewriting <code>fromTree</code> using the new signature: <code>def fromTree(t: Tree): Either[ErrMsg, Wrapped]</code> , but I suppose they lost sight of the fact that we can get the same result by defining the implementation of <code>Exp[Wrapped]</code> and using our original code for <code>fromTree</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wrappingExp: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">Wrapped</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">Wrapped</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lit</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Wrapped</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = e.lit(i) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neg</span></span></span></span>(t: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Wrapped</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = e.neg(t.value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>, r: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Wrapped</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = e.add(l.value, r.value) } }</code> </pre> <br><p>  This is enough to get first class polymorphism. </p><br><pre> <code class="scala hljs">scala&gt; fromTree[<span class="hljs-type"><span class="hljs-type">Wrapped</span></span>](tf1Tree) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { | <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Left</span></span>(err) =&gt; | println(err) | | <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Right</span></span>(t) =&gt; | println(t.value[<span class="hljs-type"><span class="hljs-type">Int</span></span>]) | println(t.value[<span class="hljs-type"><span class="hljs-type">String</span></span>]) | println |} <span class="hljs-number"><span class="hljs-number">5</span></span> (<span class="hljs-number"><span class="hljs-number">8</span></span> + (-(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>)))</code> </pre> <br><p>  But we managed only half the task: our deserializer still lacks extensibility.  In order to allow adding post factum multiplication, <code>fromTree</code> must be rewritten in an open-recursive style.  This is another scary name for a very simple idea: we can rewrite all our recursive calls <code>fromTree</code> via the additional parameter <code>recur</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  `recur`  `fromTree _`  ! def fromTreeExt[T] (recur: =&gt; (Tree =&gt; Either[ErrMsg, T])) (implicit e: Exp[T]) : Tree =&gt; Either[ErrMsg, T] = { val e = implicitly[Exp[T]] tree =&gt; tree match { case Node("Lit", List(Leaf(n))) =&gt; readInt(n).right.map(e.lit) case Node("Neg", List(t)) =&gt; recur(t).right.map(e.neg) case Node("Add", List(l , r)) =&gt; for(lt &lt;- recur(l).right; rt &lt;- recur(r).right) yield e.add(lt, rt) case t =&gt; Left(s"  $t") } }</span></span></code> </pre> <br><p>  The recursion is then tightened using a fixed point operator (fix point operator - "approx. Lane"): </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fix</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](f: (=&gt; <span class="hljs-type"><span class="hljs-type">A</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">A</span></span> = f(fix(f))</code> </pre> <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromTree2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">Exp</span></span>](t: <span class="hljs-type"><span class="hljs-type">Tree</span></span>): <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">ErrMsg</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] = fix(fromTreeExt[<span class="hljs-type"><span class="hljs-type">T</span></span>] _)(t)</code> </pre> <br><p>  Thus, it becomes possible to determine the deserializer of the product statement independently, and "tighten the node" again: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromTreeExt2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (recur: =&gt; (<span class="hljs-type"><span class="hljs-type">Tree</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">ErrMsg</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>])) (<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], m: <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]) : <span class="hljs-type"><span class="hljs-type">Tree</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">ErrMsg</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(<span class="hljs-string"><span class="hljs-string">"Mult"</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>(l , r)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(lt &lt;- recur(l).right; rt &lt;- recur(r).right) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> m.mul(lt, rt) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t =&gt; fromTreeExt(recur).apply(t) }</code> </pre> <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromTree3</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">Exp</span></span> : <span class="hljs-type"><span class="hljs-type">Mult</span></span>](t: <span class="hljs-type"><span class="hljs-type">Tree</span></span>): <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">ErrMsg</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] = fix(fromTreeExt2[<span class="hljs-type"><span class="hljs-type">T</span></span>] _)(t)</code> </pre> <br><p>  Now we can test our serialization and deserialization for any <code>e</code> , for example, using: </p><br><pre> <code class="scala hljs">assert(fromTreeN[<span class="hljs-type"><span class="hljs-type">String</span></span>](e[<span class="hljs-type"><span class="hljs-type">Tree</span></span>]) == <span class="hljs-type"><span class="hljs-type">Right</span></span>(e[<span class="hljs-type"><span class="hljs-type">String</span></span>]))</code> </pre> <br><p>  Notice that in Scala this implementation is stack unsafe.  We need to add trampolining to use this recursion trick for large data structures. </p><br><h2 id="preobrazovanie">  Transformation </h2><br><p>  We saw how to transform our mathematical expressions into various other representations, i.e.  interpretation;  how to build our mathematical expressions from another representation: deserialization;  but what about converting a mathematical expression to another mathematical expression? </p><br><p>  Consider a transformation that will lower the unary minus to the bottom, to the literals, so that <code>8 - (1 + 2)</code> becomes <code>8 + ((-1) + (-2))</code> .  The task sounds just for the <em>initial</em> (ADT-based) encoding, a simple function <code>IExp =&gt; IExp</code> </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushNeg</span></span></span></span>(e: <span class="hljs-type"><span class="hljs-type">IExp</span></span>): <span class="hljs-type"><span class="hljs-type">IExp</span></span> = e <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Lit</span></span>(_) =&gt; e <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Neg</span></span>(<span class="hljs-type"><span class="hljs-type">Lit</span></span>(_)) =&gt; e <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Neg</span></span>(<span class="hljs-type"><span class="hljs-type">Neg</span></span>(n)) =&gt; n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Neg</span></span>(<span class="hljs-type"><span class="hljs-type">Add</span></span>(l, r)) =&gt; <span class="hljs-type"><span class="hljs-type">Add</span></span>(pushNeg(<span class="hljs-type"><span class="hljs-type">Neg</span></span>(l)), pushNeg(<span class="hljs-type"><span class="hljs-type">Neg</span></span>(r))) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Add</span></span>(l, r) =&gt; <span class="hljs-type"><span class="hljs-type">Add</span></span>(pushNeg(l), pushNeg(r)) }</code> </pre> <br><p>  It looks impossible in the <em>final</em> encoding.  Pattern matching (pattern matching) is very convenient for conversions in a specific context, how do we achieve the same convenience inside the <code>Exp</code> implementation?  The trick is that instead of handling <code>Exp[T]</code> as we did before, working with <code>Exp[Ctx =&gt; T]</code> in the appropriate context.  In this case, the context is quite simple: all we need to know is whether or not to change the sign of the current node: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCtx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PosCtx</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCtx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NegCtx</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCtx</span></span></span></span></code> </pre> <br><p>  The conversion is expressed as <code>Exp[NCtx =&gt; T]</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">negDownExp</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lit</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PosCtx</span></span> =&gt; e.lit(i) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NegCtx</span></span> =&gt; e.neg(e.lit(i)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neg</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PosCtx</span></span> =&gt; x(<span class="hljs-type"><span class="hljs-type">NegCtx</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NegCtx</span></span> =&gt; x(<span class="hljs-type"><span class="hljs-type">PosCtx</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>, r: <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = c =&gt; e.add(l(c), r(c)) }</code> </pre> <br><p>  To apply a transformation, you first need to convert the expression to NCtx <code>NCtx =&gt; T</code> , and then call it with the initial context: </p><br><pre> <code class="scala hljs">scala&gt; tf1[<span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>].apply(<span class="hljs-type"><span class="hljs-type">PosCtx</span></span>) (<span class="hljs-number"><span class="hljs-number">8</span></span> + ((<span class="hljs-number"><span class="hljs-number">-1</span></span>) + (<span class="hljs-number"><span class="hljs-number">-2</span></span>)))</code> </pre> <br><p>  The initial context can also be rendered in function: </p><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushNeg</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](e: <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = e(<span class="hljs-type"><span class="hljs-type">PosCtx</span></span>) pushNeg: [<span class="hljs-type"><span class="hljs-type">T</span></span>](e: <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)<span class="hljs-type"><span class="hljs-type">T</span></span> scala&gt; pushNeg(tf1[<span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>]) (<span class="hljs-number"><span class="hljs-number">8</span></span> + ((<span class="hljs-number"><span class="hljs-number">-1</span></span>) + (<span class="hljs-number"><span class="hljs-number">-2</span></span>)))</code> </pre> <br><p>  Unfortunately, the <code>scalac</code> type inference mechanism in this case requires explicitly defining an internal type parameter, which can look rather ugly when composing several transformations: <code>pushNeg(pushNeg(pushNeg(tf1[NCtx =&gt; NCtx =&gt; NCtx =&gt; String])))</code> .  Improvements in the type inference mechanism in Dotty make it possible to write just <code>pushNeg(pushNeg(pushNeg(tf1))): String</code> , just like you would write in Haskell.  See <a href="https://www.youtube.com/watch%3Fv%3DYIQjfCKDR5A">Dotty and types for the story so far</a> for an introduction to the Dotty type inference engine. </p><br><p>  This transformation can be naturally extended for a product operation using the definition of the additional implementation <code>Mult[NCtx =&gt; T]</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">negDownMult</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> e: <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(l: <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>, r: <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PosCtx</span></span> =&gt; e.mul(l(<span class="hljs-type"><span class="hljs-type">PosCtx</span></span>), r(<span class="hljs-type"><span class="hljs-type">PosCtx</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">NegCtx</span></span> =&gt; e.mul(l(<span class="hljs-type"><span class="hljs-type">PosCtx</span></span>), r(<span class="hljs-type"><span class="hljs-type">NegCtx</span></span>)) } }</code> </pre> <br><pre> <code class="scala hljs">scala&gt; pushNeg(tfm1[<span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>]) (<span class="hljs-number"><span class="hljs-number">7</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> * (<span class="hljs-number"><span class="hljs-number">-2</span></span>)) scala&gt; pushNeg(tfm2[<span class="hljs-type"><span class="hljs-type">NCtx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>]) <span class="hljs-number"><span class="hljs-number">7</span></span> * (<span class="hljs-number"><span class="hljs-number">8</span></span> + ((<span class="hljs-number"><span class="hljs-number">-1</span></span>) + (<span class="hljs-number"><span class="hljs-number">-2</span></span>)))</code> </pre> <br><p>  This lecture continues with another example of conversion using a similar context introduction trick.  The transformations that we have seen so far have been quite inventive, and you may ask yourself: whether everything that can be written using the <em>final</em> encoding can also be expressed in the <em>initial</em> encoding, and vice versa.  These two representations are actually equivalent, which can be demonstrated by the existence of a bijection: </p><br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//       ADT implicit def initialize: Exp[IExp] = new Exp[IExp] { def lit(i: Int): IExp = Lit(i) def neg(t: IExp): IExp = Neg(t) def add(l: IExp, r: IExp): IExp = Add(l, r) } //   ADT     def finalize[T](i: IExp)(implicit e: Exp[T]): T = i match { case Lit(l) =&gt; e.lit(l) case Neg(n) =&gt; e.neg(finalize[T](n)) case Add(l, r) =&gt; e.add(finalize[T](l), finalize[T](r)) }</span></span></code> </pre> <br><h2 id="obedinenie-ogranicheniy-na-klassy-tipov-s-pomoschyu-tipov-neyavnyh-funkciy">  Combining restrictions on type classes using implicit function types </h2><br><p>  Implicit functions are a recent addition to the Dotty compiler.  The idea is to extend the syntax currently available with support for functions with implicit arguments.  As you probably know, functions in Scala are defined as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function1</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">B</span></span> }</code> </pre> <br><p>  The compiler implements syntactic sugar, which converts the types <code>A =&gt; B</code> to <code>Function1[A, B]</code> and allows users to concisely define function values.  Implicit functions are similar: <code>implicit A =&gt; B</code> becomes the correct type, which appears in <code>ImplicitFunction1[A, B]</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplicitFunction1</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> a: <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">B</span></span> }</code> </pre> <br><p>  The definition of a function that returns the type of an implicit function receives an additional advantage in the additional expansion, which automatically places implicit parameters in scope: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>: <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-type"><span class="hljs-type">Ctx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Unit</span></span> = ???</code> </pre> <br><p>  Expands to: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>: <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-type"><span class="hljs-type">Ctx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> $e1: <span class="hljs-type"><span class="hljs-type">Ctx</span></span> =&gt; ???: <span class="hljs-type"><span class="hljs-type">Unit</span></span> }</code> </pre> <br><p>  Syntactic sugar may not look very useful in this simple example, but with such a synonym, the type is becoming more interesting: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contextualized</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-type"><span class="hljs-type">Ctx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Contextualized</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = ???</code> </pre> <br><p>  If more than one implicit parameter is involved, the type of implicit function allows you to do something that was not quite possible earlier: to abstract from implicit parameters. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Constrained</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> (<span class="hljs-type"><span class="hljs-type">TC1</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], <span class="hljs-type"><span class="hljs-type">TC2</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], <span class="hljs-type"><span class="hljs-type">TC3</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]) =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Constrained</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = ???</code> </pre> <br><p>  Expands to: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Constrained</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = { ($e1: <span class="hljs-type"><span class="hljs-type">TC1</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>], $e2: <span class="hljs-type"><span class="hljs-type">TC2</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>], $e3: <span class="hljs-type"><span class="hljs-type">TC3</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> $e4: <span class="hljs-type"><span class="hljs-type">TC1</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = $e1 <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> $e5: <span class="hljs-type"><span class="hljs-type">TC1</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = $e2 <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> $e6: <span class="hljs-type"><span class="hljs-type">TC1</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = $e3 ???: <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre> <br><p>  Returning to our <em>final</em> coding of mathematical expressions, the implicit types of functions in Dotty make it possible to extend the encoding with a minimal syntactic overhead: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ring</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> (<span class="hljs-type"><span class="hljs-type">Exp</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], <span class="hljs-type"><span class="hljs-type">Mult</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]) =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tfm1</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]: <span class="hljs-type"><span class="hljs-type">Ring</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = add(lit(<span class="hljs-number"><span class="hljs-number">7</span></span>), neg(mul(lit(<span class="hljs-number"><span class="hljs-number">1</span></span>), lit(<span class="hljs-number"><span class="hljs-number">2</span></span>)))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tfm2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]: <span class="hljs-type"><span class="hljs-type">Ring</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = mul(lit(<span class="hljs-number"><span class="hljs-number">7</span></span>), tf1)</code> </pre> <br><p>  This is the end of our return to the Unselected Final Interpreters (see <a href="https://gist.github.com/OlivierBlanvillain/ab0d28c4480f62b0ff470934f0deac9a">here</a> all (Scala 2.11) code snippets from this article)! </p><br><p>  If you want to learn more about the Uninterpreted Finite Interpreters, I strongly recommend that you continue to study sections 3 and 4 of the <a href="http://okmij.org/ftp/tagless-final/course/lecture.pdf">abstract</a> for coding simply typed lambda calculus. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325874/">https://habr.com/ru/post/325874/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325862/index.html">Wall Street Server: VPS for Traders</a></li>
<li><a href="../325864/index.html">What "kills" the seller</a></li>
<li><a href="../325866/index.html">101 free services for the designer</a></li>
<li><a href="../325868/index.html">Starting your blog on Ghost using docker-compose</a></li>
<li><a href="../325872/index.html">ASP.NET Core: Creating ASP.NET Web API Reference Pages with Swagger</a></li>
<li><a href="../325876/index.html">Using Zabbix API. When there is not enough standard statistics</a></li>
<li><a href="../325880/index.html">The test of knowledge of the C language, found in April Fool's joke</a></li>
<li><a href="../325882/index.html">Vulnerability of the Xen hypervisor allows access to host memory from a virtual machine</a></li>
<li><a href="../325884/index.html">7 bad tips to the REST API designer</a></li>
<li><a href="../325888/index.html">ThinkPHP # 14 Mitap in Kharkov. 5 years together</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>