<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study the debugger, part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article , some nuances of working with the integrated Delphi debugger were considered - not all of course, but the most neces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study the debugger, part two</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/178007/">first part of the article</a> , some nuances of working with the integrated Delphi debugger were considered - not all of course, but the most necessary for the developer.  Now the task looks a little different: let's consider its work from the inside using the example of its source code.  In order not to bore you with the description of the API functions and not to chew all the stages of debugging, I will describe its work using the example of the TFWDebugerCore class.  I will omit some not particularly important moments, if you wish, you can clarify them by looking at the code of this class. <br><br>  If you are already familiar with the work of the debugger - do not worry, it is likely that some aspects of his work, mentioned in the article, will be of interest to you. <br><br>  If you have never come across a self-implementation of the debugger, but are interested in it, then at least you should start with this link: <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee663265(v%3Dvs.85).aspx">Debugging and Error Handling</a> <br>  Through it you can learn about the main aspects of debugging, such as structural exception handling, work with debug information, minidumps.  Working with the image of the executable file, headers, sections, process memory card, what is RVA and VA, and so on. <br>  But this is only if you want to understand all this kitchen. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will try to describe only part of it in a simpler language, so that you have a point from which you could push off if you are suddenly interested, and of course, if you implement application protection, you need to understand the subtleties of the debugger at least (and how else differently?). <br><br>  There will be a lot of code in the text of the article, but I will not consider all the parameters of each of the structures when debugging events occur, for this is MSDN.  I‚Äôll dwell only on the necessary debugging tools for work and try to reveal some nuances that you will most likely encounter when implementing the debugging engine yourself. <br><br>  From you, however, it is desirable to have at least minimal assembly knowledge, because  Alas, in this article, alas, can not do. <br><br><a name="habracut"></a><br><br><h4>  Let's start by attaching a debugger to the process: </h4><br>  Before connecting to the process, the very first step is to get debugging privileges.  This is done with this simple code: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDebugPriv</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Token: THandle; tkp: TTokenPrivileges; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := false; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OpenProcessToken(GetCurrentProcess, TOKEN_ADJUST_PRIVILEGES <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> TOKEN_QUERY, Token) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> LookupPrivilegeValue(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, PChar(<span class="hljs-string"><span class="hljs-string">'SeDebugPrivilege'</span></span>), tkp.Privileges[<span class="hljs-number"><span class="hljs-number">0</span></span>].Luid) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> tkp.PrivilegeCount := <span class="hljs-number"><span class="hljs-number">1</span></span>; tkp.Privileges[<span class="hljs-number"><span class="hljs-number">0</span></span>].Attributes := SE_PRIVILEGE_ENABLED; Result := AdjustTokenPrivileges(Token, False, tkp, <span class="hljs-number"><span class="hljs-number">0</span></span>, PTokenPrivileges(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>)^, PDWord(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>)^); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><br>  The next step is to determine whether we will join the already running process, or we will launch a new process from scratch. <br><br>  If the process is already running and we want to join it, all we need is to find out only the PID of the process and execute such code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttachToProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessID: DWORD; SentEntryPointBreakPoint: Boolean)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FProcessInfo.ProcessID &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; FSetEntryPointBreakPoint := SentEntryPointBreakPoint; FProcessInfo.ProcessID := ProcessID; Result := DebugActiveProcess(ProcessID); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  True, this code is not always successful for at least two reasons. <br><br>  The fact is that in Windows it is impossible to connect to the process with two debuggers at the same time, and if a debugger is already attached to the process we need, the call to the DebugActiveProcess function will not succeed, and GetLastError will return us the error code: ERROR_INVALID_PARAMETER. <br><br>  The second reason may be that the process we need is launched with higher privileges than the debugger.  In this case, the call to the DebugActiveProcess function will also not be successful, and GetLastError will return us the error code: ERROR_ACCESS_DENIED. <br><br>  In the second case, you can bypass this error by running the debugger with the required privileges. <br><br>  The second option is to attach the debugger to the process, by starting the process with the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugNewProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FilePath: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; SentEntryPointBreakPoint: Boolean)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> PI: TProcessInformation; SI: TStartupInfo; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FProcessInfo.ProcessID &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; FSetEntryPointBreakPoint := SentEntryPointBreakPoint; ZeroMemory(@SI, SizeOf(TStartupInfo)); SI.cb := SizeOf(TStartupInfo); Result := CreateProcess(PChar(FilePath), <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, False, DEBUG_PROCESS <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> DEBUG_ONLY_THIS_PROCESS, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, SI, PI); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Result <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FProcessInfo.ProcessID := PI.dwProcessId; FProcessInfo.CreatedProcessHandle := PI.hProcess; FProcessInfo.CreatedThreadHandle := PI.hThread; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Everything is simple here, in the above code we started the process with the DEBUG_PROCESS flag and additionally indicated the DEBUG_ONLY_THIS_PROCESS flag, indicating that we will not debug the processes created by the debugger. <br>  After starting the process, remember its parameters (useful). <br><br>  As soon as we have joined the process as a debugger, this process stops working independently and will wait for our team for each its own movement - what to do next.  To do this, it will generate debug events and wait until we react to them. <br><br>  We can get a debugging event from the process being debugged by calling the WaitForDebugEvent function, after which we can perform any necessary actions and return control to it by calling the ContinueDebugEvent function, after which again we have to wait for the next event. <br>  Those.  roughly we have to implement the debug event loop loop. <br><br>  MSND recommends the following implementation of the Debug Event Loop. <br><br>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681675(v%3Dvs.85).aspx">Writing the Debugger's Main Loop</a> <br><br>  We are about the same in our debugger. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunMainLoop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DebugEvent: TDebugEvent; CallNextLoopIteration: Boolean; ThreadIndex: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CallNextLoopIteration := False; <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> ContinueStatus := DBG_CONTINUE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> WaitForDebugEvent(DebugEvent, MainLoopWaitPeriod) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GetLastError = ERROR_SEM_TIMEOUT <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> DoIdle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FProcessInfo.ProcessID = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; CallNextLoopIteration := True; <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> DoMainLoopFailed; <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DebugEvent.dwDebugEventCode <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> CREATE_THREAD_DEBUG_EVENT: DoCreateThread(DebugEvent); CREATE_PROCESS_DEBUG_EVENT: DoCreateProcess(DebugEvent); EXIT_THREAD_DEBUG_EVENT: DoExitThread(DebugEvent); EXIT_PROCESS_DEBUG_EVENT: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> DoExitProcess(DebugEvent); <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; LOAD_DLL_DEBUG_EVENT: DoLoadDll(DebugEvent); UNLOAD_DLL_DEBUG_EVENT: DoUnLoadDll(DebugEvent); OUTPUT_DEBUG_STRING_EVENT: DoDebugString(DebugEvent); RIP_EVENT: DoRip(DebugEvent); EXCEPTION_DEBUG_EVENT: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ThreadIndex := GetThreadIndex(DebugEvent.dwThreadId); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DebugEvent.Exception.ExceptionRecord.ExceptionCode <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EXCEPTION_BREAKPOINT: ProcessExceptionBreakPoint(ThreadIndex, DebugEvent); EXCEPTION_SINGLE_STEP: ProcessExceptionSingleStep(ThreadIndex, DebugEvent); EXCEPTION_GUARD_PAGE: ProcessExceptionGuardPage(ThreadIndex, DebugEvent); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CallUnhandledExceptionEvents(ThreadIndex, CodeDataToExceptionCode( DebugEvent.Exception.ExceptionRecord.ExceptionCode), DebugEvent); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; CallNextLoopIteration := ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, ContinueStatus); <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> CallNextLoopIteration; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  In the process of debugging, we will constantly be inside this cycle and process known events.  The WaitForDebugEvent function on each iteration of the debug loop returns a DEBUG_EVENT structure.  Based on the dwDebugEventCode parameter of this structure, we can identify the type of event received, the process ID and thread in which the event occurred, as well as the parameters of each event, represented as a union by the last field of this structure: <br><br><pre> <code class="delphi hljs">PDebugEvent = ^TDebugEvent; _DEBUG_EVENT = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> dwDebugEventCode: DWORD; dwProcessId: DWORD; dwThreadId: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Integer <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: (Exception: TExceptionDebugInfo); <span class="hljs-number"><span class="hljs-number">1</span></span>: (CreateThread: TCreateThreadDebugInfo); <span class="hljs-number"><span class="hljs-number">2</span></span>: (CreateProcessInfo: TCreateProcessDebugInfo); <span class="hljs-number"><span class="hljs-number">3</span></span>: (ExitThread: TExitThreadDebugInfo); <span class="hljs-number"><span class="hljs-number">4</span></span>: (ExitProcess: TExitProcessDebugInfo); <span class="hljs-number"><span class="hljs-number">5</span></span>: (LoadDll: TLoadDLLDebugInfo); <span class="hljs-number"><span class="hljs-number">6</span></span>: (UnloadDll: TUnloadDLLDebugInfo); <span class="hljs-number"><span class="hljs-number">7</span></span>: (DebugString: TOutputDebugStringInfo); <span class="hljs-number"><span class="hljs-number">8</span></span>: (RipInfo: TRIPInfo); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-meta"><span class="hljs-meta">{$EXTERNALSYM _DEBUG_EVENT}</span></span> TDebugEvent = _DEBUG_EVENT; DEBUG_EVENT = _DEBUG_EVENT; <span class="hljs-meta"><span class="hljs-meta">{$EXTERNALSYM DEBUG_EVENT}</span></span></code> </pre><br><br>  Each event has its own set of parameters, but we will dwell on them a little later. <br><br>  If any of the events is not handled by our code, simply continue the execution of the process being debugged by calling the ContinueDebugEvent function by setting the ContinueStatus parameter to DBG_CONTINUE. <br><br>  Nuance: in case WaitForDebugEvent returned an error (for example, by timeout), it is not necessary to call ContinueDebugEvent, it will also return an error.  At this point, very often they stumble, do not forget to take it into account in your own implementation of the debugger. <br><br>  So far, everything is quite simple, now let's see what events give us. <br><br><h4>  CREATE_PROCESS_DEBUG_EVENT: </h4><br>  The very first event that the debugger will receive at the start of debugging.  It does not matter whether we started the process ourselves, or joined it through a call to the DebugActiveProcess, we will begin the work with it.  The parameters of this event are stored in the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679286(v%3Dvs.85).aspx">DebugEvent.CreateProcessInfo</a> structure <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679286(v%3Dvs.85).aspx">(CREATE_PROCESS_DEBUG_INFO structure).</a> <br><br>  In general, the event handler looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoCreateProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DebugEvent: TDebugEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     FProcessInfo.AttachedFileHandle := DebugEvent.CreateProcessInfo.hFile; FProcessInfo.AttachedProcessHandle := DebugEvent.CreateProcessInfo.hProcess; FProcessInfo.AttachedThreadHandle := DebugEvent.CreateProcessInfo.hThread; FProcessInfo.EntryPoint := DWORD(DebugEvent.CreateProcessInfo.lpStartAddress); AddThread(DebugEvent.dwThreadId, FProcessInfo.AttachedThreadHandle); //  BreakPoint     if FSetEntryPointBreakPoint then SetBreakpoint(FProcessInfo.EntryPoint, 'Process Entry Point Breakpoint'); if Assigned(FCreateProcess) then begin FCreateProcess(Self, GetThreadIndex(DebugEvent.dwThreadId), DebugEvent.CreateProcessInfo); DoResumeAction(GetThreadIndex(DebugEvent.dwThreadId)); end; end;</span></span></code> </pre><br><br>  In it, we simply remember the process parameters, as well as add the ID and handle of the main thread of the process to the internal list.  These data will be useful to us later. <br><br>  Here we can also define the process entry point (Entry Point), its value is recorded in the DebugEvent.CreateProcessInfo.lpStartAddres parameter and, if desired, set a breakpoint (hereinafter BP) to its address and start the process for execution.  If you harden a little bit, then by performing this action we simulate the behavior of the Delphi debugger when you press the F7 button. <br><br>  What is the entry point: when the loader creates a process, until the moment when it starts, a lot of preparatory actions are performed.  Creating the main thread of the application, setting up stacks, process environment blocks / threads, loading libraries, executing their TLS callbacks, etc.  Only after all this is done, the loader transfers control directly to the entry point, from where the code implemented by the programmer is already beginning to run.  The address of this point is stored directly in the header of the PE file, from where it can be obtained by any application displaying the structure of the PE file, for example PEiD or PeExplorer, or read this value yourself by reading the TImageDosHeader structure located at the very beginning of the file, in its _lfanew field will be offset to start TImageNtHeaders, then read the structure TImageNtHeaders itself and see the value of its field TImageNtHeaders.OptionalHeader.AddressOfEntryPoint. <br><br>  Try to compile an empty project, and click F7 in it, after which go to the CPU-View tab, you should get something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/670/b74/a78/670b74a78d69e3fab94a32dafe5a40d4.png" alt="image"><br><br>  The address of the entry point is: 0x0043E2D4.  Now let's see what PEiD will tell us about the resulting application: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/539/5bf/685/5395bf685de89a8b8c59b0ac8a67591f.png" alt="image"><br><br>  He says the entry point value is 0x0003E2D4. <br><br>  Although it does not coincide with the number that we saw in the debugger, nevertheless, everything is correct here, since the value stored in the AddressOfEntryPoint parameter is represented as RVA (Relative Virtual Address).  The peculiarity of this addressing is that it does not take into account the load address of our module (hInstance).  In order to get a VA (Virtual Address) from an RVA address, you must add the hInstance module to it. <br><br>  There is a nuance: this is true only for applications, for libraries it works a little differently.  For them it is necessary to focus on the addresses of the sections.  More details can be found in this demo example: <a href="http://rouse.drkb.ru/winapi.php">"Implementation of the file properties tab"</a> . <br>  In it, in the DebugHlp.pas module, there is an implementation of the ImageRvaToVa () function, by which you can visually study the rules for addressing. <br><br>  Well, for the application, the base download address is always equal to the value specified by us in the linker settings in the Image Base parameter, which by default is 0x00400000.  Adding these two numbers, we just get the required 0x0043E2D4. <br><br><h4>  LOAD_DLL_DEBUG_EVENT: </h4><br>  Right after CREATE_PROCESS_DEBUG_EVENT, we will begin to receive library loading events with parameters in the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms680351(v%3Dvs.85).aspx">DebugEvent.LoadDll</a> structure <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms680351(v%3Dvs.85).aspx">(LOAD_DLL_DEBUG_INFO structure).</a> <br><br>  In the general case, we can observe the loading of libraries in the Delphi debugger, which displays notifications about loading in the event log: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/931/80d/23b/93180d23b283df94f4196ce00485dcde.png" alt="image"><br><br>  When a Delphi event is received, the debugger, if a BP is installed on the module load, is interrupted immediately after it is loaded. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d64/c3f/38c/d64c3f38c1bb8ae4fdb298eb807b9076.png" alt="image"><br><br>  We can also notify the user about loading the module with this code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoLoadDll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DebugEvent: TDebugEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FLoadDll) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FLoadDll(Self, GetThreadIndex(DebugEvent.dwThreadId), DebugEvent.LoadDll); DoResumeAction; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; CloseHandle(DebugEvent.LoadDll.hFile); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  In which, in addition to raising the event, we immediately close the handle of the loaded library, we will no longer need it (in this version of the debugger implementation). <br><br>  The nuance is as follows: the address with the path to the loaded library stored in the DebugEvent.LoadDll.lpImageName parameter is not located in our address space, so we will have to read it through ReadProcessMemory. <br>  The second nuance: this value is also a pointer to the buffer along which the path data is located, i.e.  will have to read at least twice. <br>  The third nuance: the path can be either in Ansii or in Unicode encoding. <br>  Well, for a snack, the fourth thing: we can not read the data :) <br><br>  To get a valid path to the loadable library, the TFWDebugerCore class provides the GetDllName method that takes all these points into account. <br><br>  Consider the implementation. <br>  The TFWDebugerCore class will notify us when the library is loaded by calling an external OnLoadDll event, where we will write the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLoadDll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; Data: TLoadDLLDebugInfo)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FormatStrKnownDLL = <span class="hljs-string"><span class="hljs-string">'Load Dll at instance %p handle %d "%s"'</span></span>; FormatStrUnknownDLL = <span class="hljs-string"><span class="hljs-string">'Load unknown Dll at instance %p handle %d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DllName: AnsiString; IsUnicodeData: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCore.ContinueStatus := DBG_EXCEPTION_NOT_HANDLED; IsUnicodeData := Data.fUnicode = <span class="hljs-number"><span class="hljs-number">1</span></span>; DllName := FCore.GetDllName(Data.lpImageName, Data.lpBaseOfDll, IsUnicodeData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> DllName &lt;&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsUnicodeData <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Writeln(Format(FormatStrKnownDLL, [Data.lpBaseOfDll, Data.hFile, PWideChar(@DllName[<span class="hljs-number"><span class="hljs-number">1</span></span>])])) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Writeln(Format(FormatStrKnownDLL, [Data.lpBaseOfDll, Data.hFile, PAnsiChar(@DllName[<span class="hljs-number"><span class="hljs-number">1</span></span>])])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Writeln(Format(FormatStrUnknownDLL, [Data.lpBaseOfDll, Data.hFile])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Here, we call the TFWDebugerCore.GetDllName () method and (focusing on the fUnicode parameter), we output the data to the console. <br><br>  The implementation of the GetDllName method looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AddrPrt, ResultPtr: Pointer; DataSize: Integer)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Dummy: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := ReadProcessMemory(FProcessInfo.AttachedProcessHandle, AddrPrt, ResultPtr, DataSize, Dummy) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Integer(Dummy) = DataSize); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadStringA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AddrPrt: Pointer; DataSize: Integer)</span></span></span><span class="hljs-function">:</span></span> AnsiString; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(Result, DataSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ReadData(AddrPrt, @Result[<span class="hljs-number"><span class="hljs-number">1</span></span>], DataSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMappedFileNameA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hProcess: THandle; lpv: Pointer; lpFilename: LPSTR; nSize: DWORD)</span></span></span><span class="hljs-function">:</span></span> DWORD; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> <span class="hljs-string"><span class="hljs-string">'psapi.dll'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDllName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lpImageName, lpBaseOfDll: Pointer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Unicode: Boolean)</span></span></span><span class="hljs-function">:</span></span> AnsiString; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DllNameAddr: Pointer; MappedName: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..MAX_PATH - <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AnsiChar; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ReadData(lpImageName, @DllNameAddr, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := ReadStringA(DllNameAddr, MAX_PATH); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Result = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GetMappedFileNameA(FProcessInfo.AttachedProcessHandle, lpBaseOfDll, @MappedName[<span class="hljs-number"><span class="hljs-number">0</span></span>], MAX_PATH) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := PAnsiChar(@MappedName[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Unicode := False; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  That is, first we try to get the path to the library by reading data from the address space of the process being debugged (ReadData + ReadStringA), and if it did not work out, we take this data by calling the GetMappedFileNameA function.  It returns data using symbolic links, so the result for good needs to also lead to a normal path, but in this case I did not do this in order not to over-complicate the code. <br><br><h4>  CREATE_THREAD_DEBUG_EVENT </h4><br>  We will receive this event at the moment when a new thread is created in the application being debugged.  The parameters of this event are stored in the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679287(v%3Dvs.85).aspx">DebugEvent.CreateThread</a> structure <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679287(v%3Dvs.85).aspx">(CREATE_THREAD_DEBUG_INFO structure).</a> <br><br>  Of all the parameters, we are most interested in DebugEvent.CreateThread.hThread, which is desirable to save in the internal list. <br><br>  The caveat is that most events only contain data about the thread ID, and when we want to work with it (for example, to install the Hardware Breakpoint), we will have to make an OpenThread call on the transferred ID.  In order not to bother yourself with these actions, we will keep ThreadID = ThreadHandle pairs in our own cache. <br><br>  The event handler code for this event is as follows: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoCreateThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DebugEvent: TDebugEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> AddThread(DebugEvent.dwThreadId, DebugEvent.CreateThread.hThread); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FCreateThread) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCreateThread(Self, GetThreadIndex(DebugEvent.dwThreadId), DebugEvent.CreateThread); DoResumeAction; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  In addition to saving the thread parameters and calling the external handler, there is nothing in it. <br><br><h4>  OUTPUT_DEBUG_STRING_EVENT: </h4><br>  The event is generated at the moment when the debugged application tries to inform something on the calls to the OutputDebugString function.  The parameters of this event are stored in the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms680545(v%3Dvs.85).aspx">DebugEvent.DebugString</a> structure <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms680545(v%3Dvs.85).aspx">(OUTPUT_DEBUG_STRING_INFO structure).</a> <br><br>  The event handler is simple: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoDebugString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DebugEvent: TDebugEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FDebugString) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FDebugString(Self, GetThreadIndex(DebugEvent.dwThreadId), DebugEvent.DebugString); DoResumeAction; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  those.  just call the external handler where you need to read the passed string by the same principle as we read the path to the loadable library. <br><br>  For example, like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDebugString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; Data: TOutputDebugStringInfo)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Data.fUnicode = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'DebugString: '</span></span> + PWideChar(FCore.ReadStringW(Data.lpDebugStringData, Data.nDebugStringLength))) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'DebugString: '</span></span> + PAnsiChar(FCore.ReadStringA(Data.lpDebugStringData, Data.nDebugStringLength))); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  In the handler, we look in what encoding the buffer is passed to us, focusing on the Data.fUnicode parameter and call the corresponding debugger kernel function ReadStringX (). <br><br><h4>  UNLOAD_DLL_DEBUG_EVENT, EXIT_THREAD_DEBUG_EVENT, EXIT_PROCESS_DEBUG_EVENT, RIP_EVENT: </h4><br>  Unloading the library, closing the thread, terminating the process and an error in the debugger kernel. <br>  I‚Äôll skip these four events.  There is nothing extraordinary in them.  When each one is received, external handlers are invoked and internal lists stored by the debugger are cleaned. <br>  Nuances when working with them are missing. <br><br><h4>  EXCEPTION_DEBUG_EVENT: </h4><br>  All eight of the above events are, in principle, secondary.  The main work begins only after the arrival of the EXCEPTION_DEBUG_EVENT event. <br>  Its parameters are in the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679326(v%3Dvs.85).aspx">DebugEvent.Exception</a> structure <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679326(v%3Dvs.85).aspx">(EXCEPTION_DEBUG_INFO structure)</a> . <br><br>  Generating this event means that an application encountered some kind of exception, the type of which can be found in the DebugEvent.Exception.ExceptionRecord.ExceptionCode parameter.  Remember, in the first part of the article I mentioned that debugging is done through the structural error handling mechanism (SEH)?  Now we will look at it in more detail. <br><br>  Most of the exceptions in the debugging process are imposed.  That is, getting an exception does not mean that an error occurred in the program itself.  Most likely the exception occurred due to the intervention of the debugger in the application, for example, by installing BP. <br><br>  Nuance: If an error occurs in the application itself, we will also receive it as a debugging exception and we will need to implement the debugger code so that we can distinguish our induced errors from user errors. <br><br>  Usually, the debugger provides three mechanisms for working with BP (well, if you do not take into account BP to load the module, because in fact this feature is not a classic BP). <br><br><ol><li>  Standard BP per line of code. </li><li>  BP to memory address (Memory Breakpoint or truncated Data Preakpoint in Delphi). </li><li>  Hardware BP (not in Delphi). </li></ol><br><br>  To work with them, it suffices to handle three types of exceptions: <br><br><pre> <code class="delphi hljs">EXCEPTION_DEBUG_EVENT: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ThreadIndex := GetThreadIndex(DebugEvent.dwThreadId); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DebugEvent.Exception.ExceptionRecord.ExceptionCode <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EXCEPTION_BREAKPOINT: ProcessExceptionBreakPoint(ThreadIndex, DebugEvent); EXCEPTION_SINGLE_STEP: ProcessExceptionSingleStep(ThreadIndex, DebugEvent); EXCEPTION_GUARD_PAGE: ProcessExceptionGuardPage(ThreadIndex, DebugEvent); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CallUnhandledExceptionEvents(ThreadIndex, CodeDataToExceptionCode( DebugEvent.Exception.ExceptionRecord.ExceptionCode), DebugEvent); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  In order to make it clearer why these three exceptions are enough, you first need to consider the mechanism for setting each type of BP before proceeding to the analysis of the logic for handling the EXCEPTION_DEBUG_EVENT event. <br><br>  <b>Implementing a breakpoint on a line of code:</b> <br><br>  Installing BP on a line of code is done by modifying the code of the application being debugged.  Classically, this is done by recording the opcode 0xCC at the address set by BP, meaning the instruction "INT3". <br><br>  There are other options, such as opcode 0xCD03, which is also the instruction "INT3".  The second option is used more with anti-debugging and is installed in most cases by the application itself, trying to catch the presence of a debugger on the fact that the nuclear _KiTrap03 () can work only with a single-byte opcode and slightly incorrectly processes the two-byte one. <br><br>  But, all this lyrics, we are interested in exactly the first opcode. <br><br>  The TFWDebugerCore class uses the following structures to store the list of installed BPs: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      ( ) TBreakpointType = ( btBreakpoint, // WriteProcessMemoryEx + 0xCC btMemoryBreakpoint // VirtualProtectEx + PAGE_GUARD ); //         TInt3Breakpoint = record Address: Pointer; ByteCode: Byte; end; TMemotyBreakPoint = record Address: Pointer; Size: DWORD; BreakOnWrite: Boolean; RegionStart: Pointer; RegionSize: DWORD; PreviosRegionProtect: DWORD; end; TBreakpoint = packed record bpType: TBreakpointType; Description: ShortString; Active: Boolean; case Integer of 0: (Int3: TInt3Breakpoint;); 1: (Memory: TMemotyBreakPoint); end; TBreakpointList = array of TBreakpoint;</span></span></code> </pre><br><br>  Before adding a new BP, he initializes the TBreakpoint entry, filling it with the necessary parameters, and then adds it to the general list of breakpoints. <br><br>  For BP per line of code, we need to store only two values, the address of the BP and the value of the byte stored at this address before we fill it with the opcode 0xCC. <br><br>  Installing BP in the application being debugged looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Address: DWORD; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Description: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Breakpoint: TBreakpoint; OldProtect: DWORD; Dummy: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ZeroMemory(@Breakpoint, SizeOf(TBreakpoint)); Breakpoint.bpType := btBreakpoint; Breakpoint.Int3.Address := Pointer(Address); Breakpoint.Description := Description; Check(VirtualProtectEx(FProcessInfo.AttachedProcessHandle, Pointer(Address), <span class="hljs-number"><span class="hljs-number">1</span></span>, PAGE_READWRITE, OldProtect)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> Check(ReadProcessMemory(FProcessInfo.AttachedProcessHandle, Pointer(Address), @Breakpoint.Int3.ByteCode, <span class="hljs-number"><span class="hljs-number">1</span></span>, Dummy)); Check(WriteProcessMemory(FProcessInfo.AttachedProcessHandle, Pointer(Address), @BPOpcode, <span class="hljs-number"><span class="hljs-number">1</span></span>, Dummy)); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> Check(VirtualProtectEx(FProcessInfo.AttachedProcessHandle, Pointer(Address), <span class="hljs-number"><span class="hljs-number">1</span></span>, OldProtect, OldProtect)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := AddNewBreakPoint(Breakpoint); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    ,   ,    .       ,       ,   ,   ,    ,   0xCC   BPOpcode        VirtualProtectEx().   ,    ,         . <br><br>      : <br><br>         ,         ¬´INT3¬ª.       EXCEPTION_DEBUG_EVENT    EXCEPTION_BREAKPOINT. <br><br>         <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms679326(v%3Dvs.85).aspx">DebugEvent.Exception.ExceptionRecord (EXCEPTION_DEBUG_INFO structure).</a> <br><br>     ,        ,       ,    ? <br><br>         .            DebugEvent.Exception.ExceptionRecord.ExceptionAddress   Address     btBreakpoint,   ,          -  . <br><br>       ,     (        ,   )         . <br><br> <b>  :</b> <br><br>       . <br><br>      : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c48/30a/0c0/c4830a0c0552745975d6b2d7dabe8bc7.png" alt="image"><br><br>        : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3dc/6e7/f0f/3dc6e7f0fe617284fcf37e31c4cb1354.png" alt="image"><br><br>        . <br><br>      ,   TBreakpoint   Active,     .      TFWDebugerCore    ,        ToggleInt3Breakpoint,               . <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleInt3Breakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Integer; Active: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> OldProtect: DWORD; Dummy: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckBreakpointIndex(<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].bpType &lt;&gt; btBreakpoint <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Active = Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Check(VirtualProtectEx(FProcessInfo.AttachedProcessHandle, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Int3.Address, <span class="hljs-number"><span class="hljs-number">1</span></span>, PAGE_READWRITE, OldProtect)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Check(WriteProcessMemory(FProcessInfo.AttachedProcessHandle, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Int3.Address, @BPOpcode, <span class="hljs-number"><span class="hljs-number">1</span></span>, Dummy)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Check(WriteProcessMemory(FProcessInfo.AttachedProcessHandle, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Int3.Address, @FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Int3.ByteCode, <span class="hljs-number"><span class="hljs-number">1</span></span>, Dummy)); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> Check(VirtualProtectEx(FProcessInfo.AttachedProcessHandle, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Int3.Address, <span class="hljs-number"><span class="hljs-number">1</span></span>, OldProtect, OldProtect)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Active := Active; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>           ,            (..    ). <br><br>  :         ,   .      ¬´INT3¬ª  ,             0x452220,       0x452221,    ¬´mov ebp, esp¬ª,          . <br><br>  :      : ¬´  ‚Äî   ‚Äûpush ebp‚Äú,   ,        ‚Äî       ¬©¬ª. -    ,    . <br><br> ,      ,  ,           ,    ,      (    ,     )     . <br><br> <b>  :</b> <br><br>              ,         . <br><br>  ,         ¬´ NOP¬ª.  ,  -        ,     NOP (     )      0x90.  ,       .     ‚Äî         . <br><br>       ,      : <br><br>    NOP ( $0F, $1F, $00)    : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> db $<span class="hljs-number"><span class="hljs-number">0</span></span>F, $<span class="hljs-number"><span class="hljs-number">1</span></span>F, $<span class="hljs-number"><span class="hljs-number">00</span></span> xor eax, eax inc eax neg eax <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>       : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b2/308/897/7b2308897aac6cf799ff2e642e69de41.png" alt="image"><br><br>        ,           . <br><br>    ,     .     ,         ,      ¬´jmp +1¬ª            .     ‚Äî       . <br><br>  ,   : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> db $EB, $<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-comment"><span class="hljs-comment">// jmp +1 (  xor  " ") db $B8 //   ""  xor eax, eax //   inc eax neg eax not eax sub edx, eax imul eax, edx nop nop end;</span></span></code> </pre><br><br>       : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71b/9f7/800/71b9f780019b545b86baf20ba20086dc.png" alt="image"><br><br>  ,   . <br><br>  ,      :              0x452220,     ,      ¬´push $00452245¬ª. <br><br>  ,     ¬´push epb¬ª     .         ,     ,       ,    ,      ,   ,           : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/acf/e8e/f30/acfe8ef300524c1d8476143e0df1af67.png" alt="image"><br><br>  Those.   ¬´push $00452245¬ª    ¬´inc epb¬ª  ¬´and al, [ebp+$00]¬ª,      .   -    ,    ‚Äî . <br><br>        ,          .  ,       ,   EIP (Extended Instruction Pointer).          ,    .     EIP      GetThreadContext,     Context.Eip,        SetThreadContext. <br><br>  :    EXCEPTION_DEBUG_EVENT    ID    DebugEvent.dwThreadId,   GetThreadContext()  SetThreadContext()      , ID   .        OpenThread,         ,        ,    ThreadID = ThreadHandle. <br><br>       ,   ,           ,     .       ,        0xCC        ,        ?        ,          ,       ,           . <br><br>   ,  -           ,       .     ,         . <br><br>   ,               ,       ,  ,            ..       . <br><br>            . <br>      TF  .    ,        ¬´INT1¬ª,             EXCEPTION_DEBUG_EVENT    EXCEPTION_SINGLE_STEP. <br><br>         ,       EIP.      Context.EFlags.  TF      .  Those.         : <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EFLAGS_TF = $<span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 8-  ... Context.EFlags := Context.EFlags or EFLAGS_TF;</span></span></code> </pre><br><br>  :   ¬´INT1¬ª      TF .  Those.          ,     ,       TF    .         ,   ,    EXCEPTION_SINGLE_STEP   TF .    . <br><br>   ,           : <br><br><ul><li>    ,          . </li><li>   0xCC        . </li><li>   EXCEPTION_BREAKPOINT,       </li><li>    EIP         TF </li><li>   EXCEPTION_SINGLE_STEP </li><li>   0xCC  . </li></ul><br><br>                F7   Delphi :) <br><br>         TFWDebugerCore. <br><br>   EXCEPTION_BREAKPOINT: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessExceptionBreakPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer; DebugEvent: TDebugEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ReleaseBP: Boolean; BreakPointIndex: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ReleaseBP := False; BreakPointIndex := GetBPIndex( DWORD(DebugEvent.Exception.ExceptionRecord.ExceptionAddress)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> BreakPointIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FBreakPoint) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FBreakPoint(Self, ThreadIndex, DebugEvent.Exception.ExceptionRecord, BreakPointIndex, ReleaseBP) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CallUnhandledExceptionEvents(ThreadIndex, ecBreakpoint, DebugEvent); ToggleInt3Breakpoint(BreakPointIndex, False); SetSingleStepMode(ThreadIndex, True); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ReleaseBP <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RemoveBreakpoint(BreakPointIndex) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> FRestoreBPIndex := BreakPointIndex; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CallUnhandledExceptionEvents(ThreadIndex, ecBreakpoint, DebugEvent); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>            ExceptionAddress. <br>   . <br>     ToggleInt3Breakpoint. <br>  EIP      SetSingleStepMode. <br>             ‚Äî    RemoveBreakpoint. <br>       ,        EXCEPTION_SINGLE_STEP,           . <br><br>   SetSingleStepMode   : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetSingleStepMode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer; RestoreEIPAfterBP: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Context: TContext; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ZeroMemory(@Context, SizeOf(TContext)); Context.ContextFlags := CONTEXT_FULL; Check(GetThreadContext(FThreadList[ThreadIndex].ThreadHandle, Context)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> RestoreEIPAfterBP <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Dec(Context.Eip); Context.EFlags := Context.EFlags <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> EFLAGS_TF; Check(SetThreadContext(FThreadList[ThreadIndex].ThreadHandle, Context)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    ,    ,   CONTEXT_FULL. <br>     EIP <br>  TF . <br>    . <br><br>  RemoveBreakpoint  : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Len: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ToggleBreakpoint(<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>, False); Len := BreakpointCount; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Len = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> SetLength(FBreakpointList, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>] := FBreakpointList[Len - <span class="hljs-number"><span class="hljs-number">1</span></span>]; SetLength(FBreakpointList, Len - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>             . <br><br>    EXCEPTION_SINGLE_STEP     , ..       .      ,     . <br><br><h4>     : </h4><br>            .    Memory Breakpoint ( MBP). <br><br>    :        ,       . (. -: <a href="http://rouse.drkb.ru/winapi.php">  </a> ).     MBP         ,          PAGE_GUARD   VirtualProtectEx. <br><br> :       ,    VirtualProtectEx   ,      ,            .       .          ,             . <br><br>  :          MBP     .       :   MBP      Protect ,      ,     MBP.         MBP    .       TFWDebugerCore   .    MBP  ,     MBP   .   ,      PreviosRegionProtect,    ,      VirtualProtectEx. <br><br>     : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMemoryBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Address: Pointer; Size: DWORD; BreakOnWrite: Boolean; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Description: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Breakpoint: TBreakpoint; MBI: TMemoryBasicInformation; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := GetMBPIndex(DWORD(Address)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].bpType = btMemoryBreakpoint) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MBI.BaseAddress := FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.RegionStart; MBI.RegionSize := FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.RegionSize; MBI.Protect := FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.PreviosRegionProtect; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Check(VirtualQueryEx(DebugProcessData.AttachedProcessHandle, Address, MBI, SizeOf(TMemoryBasicInformation)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); ZeroMemory(@Breakpoint, SizeOf(TBreakpoint)); Breakpoint.bpType := btMemoryBreakpoint; Breakpoint.Description := ShortString(Description); Breakpoint.Memory.Address := Address; Breakpoint.Memory.Size := Size; Breakpoint.Memory.BreakOnWrite := BreakOnWrite; Breakpoint.Memory.RegionStart := MBI.BaseAddress; Breakpoint.Memory.RegionSize := MBI.RegionSize; Check(VirtualProtectEx(FProcessInfo.AttachedProcessHandle, Address, Size, MBI.Protect <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> PAGE_GUARD, Breakpoint.Memory.PreviosRegionProtect)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Breakpoint.Memory.PreviosRegionProtect := MBI.Protect; Result := AddNewBreakPoint(Breakpoint); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  MBP     ,    .       ,      ‚Äî BreakOnWrite,       (          ).         . <br><br>        .            EXCEPTION_DEBUG_EVENT    EXCEPTION_GUARD_PAGE. <br><br>  -  .     PAGE_GUARD ,           .             .    .     ,  EXCEPTION_GUARD_PAGE      ,    ,    ,       PAGE_GUARD      . <br><br>    : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessExceptionGuardPage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer; DebugEvent: TDebugEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CurrentMBPIndex: Integer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckWriteMode</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FBreakpointList[CurrentMBPIndex].Memory.BreakOnWrite; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Result <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := DebugEvent.Exception.ExceptionRecord.ExceptionInformation[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MBPIndex: Integer; ReleaseMBP: Boolean; dwGuardedAddr: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ReleaseMBP := False; dwGuardedAddr := DebugEvent.Exception.ExceptionRecord.ExceptionInformation[<span class="hljs-number"><span class="hljs-number">1</span></span>]; MBPIndex := GetMBPIndex(dwGuardedAddr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MBPIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CurrentMBPIndex := MBPIndex; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> CheckIsAddrInRealMemoryBPRegion(CurrentMBPIndex, dwGuardedAddr) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CurrentMBPIndex := GetMBPIndex(dwGuardedAddr, CurrentMBPIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurrentMBPIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurrentMBPIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MBPIndex := CurrentMBPIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FBreakPoint) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> CheckWriteMode <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FBreakPoint(Self, ThreadIndex, DebugEvent.Exception.ExceptionRecord, MBPIndex, ReleaseMBP) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CallUnhandledExceptionEvents(ThreadIndex, ecGuard, DebugEvent); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CallUnhandledExceptionEvents(ThreadIndex, ecGuard, DebugEvent); FBreakpointList[MBPIndex].Active := False; SetSingleStepMode(ThreadIndex, False); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ReleaseMBP <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RemoveBreakpoint(MBPIndex) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> FRestoreMBPIndex := MBPIndex; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> CallUnhandledExceptionEvents(ThreadIndex, ecGuard, DebugEvent); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>         -   .      ExceptionRecord.ExceptionInformation  ,        .      ,  ‚Äî    . <br>        CheckIsAddrInRealMemoryBPRegion         . <br><br>   ,   BreakOnWrite. <br>         ExceptionInformation.  BreakOnWrite ,           ExceptionInformation  ,   ,  BreakOnWrite ,    . <br><br>          ,       ,           EIP.     SetSingleStepMode    False. <br><br>         EXCEPTION_SINGLE_STEP    FRestoreMBPIndex. <br><br>       : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleMemoryBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Integer; Active: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Dummy: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckBreakpointIndex(<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].bpType &lt;&gt; btMemoryBreakpoint <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Active = Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Check(VirtualProtectEx(FProcessInfo.AttachedProcessHandle, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.Address, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.Size, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.PreviosRegionProtect <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> PAGE_GUARD, Dummy)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Check(VirtualProtectEx(FProcessInfo.AttachedProcessHandle, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.Address, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.Size, FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Memory.PreviosRegionProtect, Dummy)); FBreakpointList[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Active := Active; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    -    . <br><br>   -   ,    ,     .       . <br><br> ,      .                      EIP   .   ,     Delphi . <br><br>        .          . <br><br><h4>    : </h4><br>   Hardware BreakPoint ( HBP).    .                .   ,    ,       . <br><br>             . <br><br> : <br>  ‚Äî       (  ) <br>  ‚Äî        /. <br>  ‚Äî     ,    , /, IO  (   /)   . <br><br>  Those.       (  )    (   ‚Äî /).             , ..        1, 2  4 . <br><br>       ,    DR ,        CONTEXT_DEBUG_REGISTERS. <br>   . Dr0..Dr3, Dr6, Dr7. (Dr4  Dr5 ). <br>  4        .  Dr7        .  Dr6          . <br><br>  TFWDebugerCore        : <br><br><pre> <code class="delphi hljs">THWBPIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>; THWBPSize = (hsByte, hdWord, hsDWord); THWBPMode = (hmExecute, hmWrite, hmIO, hmReadWrite); THardwareBreakpoint = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Address: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [THWBPIndex] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Pointer; Size: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [THWBPIndex] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> THWBPSize; Mode: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [THWBPIndex] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> THWBPMode; Description: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [THWBPIndex] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ShortString; Active: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [THWBPIndex] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    4      ,        . <br>                    ID = hThreadHandle.        : <br><br><pre> <code class="delphi hljs">TThreadData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> ThreadID: DWORD; ThreadHandle: THandle; Breakpoint: THardwareBreakpoint; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TThreadList = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TThreadData;</code> </pre><br><br>  Those.          ,     . <br><br>   ,        . <br><br>   : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetHardwareBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer; Address: Pointer; Size: THWBPSize; Mode: THWBPMode; HWIndex: THWBPIndex; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Description: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ThreadIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; FThreadList[ThreadIndex].Breakpoint.Address[HWIndex] := Address; FThreadList[ThreadIndex].Breakpoint.Size[HWIndex] := Size; FThreadList[ThreadIndex].Breakpoint.Mode[HWIndex] := Mode; FThreadList[ThreadIndex].Breakpoint.Description[HWIndex] := ShortString(Description); FThreadList[ThreadIndex].Breakpoint.Active[HWIndex] := True; UpdateHardwareBreakpoints(ThreadIndex); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>       UpdateHardwareBreakpoints. <br><br>     : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleHardwareBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: THWBPIndex; Active: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ThreadIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FThreadList[ThreadIndex].Breakpoint.Active[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>] = Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; FThreadList[ThreadIndex].Breakpoint.Active[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>] := Active; UpdateHardwareBreakpoints(ThreadIndex); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    Active     UpdateHardwareBreakpoints. <br><br>   : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DropHardwareBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: THWBPIndex)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ThreadIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FThreadList[ThreadIndex].Breakpoint.Address[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; FThreadList[ThreadIndex].Breakpoint.Address[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>] := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; UpdateHardwareBreakpoints(ThreadIndex); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>       UpdateHardwareBreakpoints. <br><br>       UpdateHardwareBreakpoints. <br>      Dr0-Dr3         Dr7. <br><br>   -  . <br><br>        ,           : <br><br>   4  (31-28)    Dr3. <br>  It looks like this: <br><br>  2  (LENi)        . <br> 00 ‚Äî 1  <br> 01 ‚Äî 2  <br> 10 ‚Äî     . <br> 11 ‚Äî 4  <br><br>  2  (RWi)  4       <br> 00 ‚Äî Execute <br> 01 ‚Äî Write <br> 10 ‚Äî IO Read/Write <br> 11 ‚Äî Read/Write <br><br>  ,        Dr3      4    ,   Dr3,  4   Dr7    1101. <br><br>  4  (27-24)      Dr2 <br>  23-20   Dr1 ,  ,  19-16   Dr0. <br><br>  13  Dr7 (GD ‚Äî Global Debug Register Access Detect) ‚Äî       .            ,     . <br><br>  9  Dr7 (GE ‚Äî Global Exact data breakpoint match) ‚Äî     . <br>  8  Dr7 (LE ‚Äî Local Exact data breakpoint match) ‚Äî     . <br><br> LE     ,       . <br><br>  8  (7-0)      Gi  Li      HBP     . <br><br>  7 (Gi ‚Äî Global breakpoint enable) ‚Äî     Dr3 <br>  6 (Li ‚Äî Local breakpoint enable) ‚Äî     Dr3 <br> 5- 4    Dr2 <br> 3- 2  Dr1  1-0  Dr0 <br><br> ? <br><br>    : <br><br><img src="http://4.bp.blogspot.com/-M9HKvLxS3FU/UKptR0WtY_I/AAAAAAAAAI8/FYMAdzhXv08/s1600/image002.gif" alt="image"><br><br>        . <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateHardwareBreakpoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DR7_SET_LOC_DR0 = $<span class="hljs-number"><span class="hljs-number">01</span></span>; DR7_SET_GLB_DR0 = $<span class="hljs-number"><span class="hljs-number">02</span></span>; DR7_SET_LOC_DR1 = $<span class="hljs-number"><span class="hljs-number">04</span></span>; DR7_SET_GLB_DR1 = $<span class="hljs-number"><span class="hljs-number">08</span></span>; DR7_SET_LOC_DR2 = $<span class="hljs-number"><span class="hljs-number">10</span></span>; DR7_SET_GLB_DR2 = $<span class="hljs-number"><span class="hljs-number">20</span></span>; DR7_SET_LOC_DR3 = $<span class="hljs-number"><span class="hljs-number">40</span></span>; DR7_SET_GLB_DR3 = $<span class="hljs-number"><span class="hljs-number">80</span></span>; DR7_SET_LOC_ON = $<span class="hljs-number"><span class="hljs-number">100</span></span>; DR7_SET_GLB_ON = $<span class="hljs-number"><span class="hljs-number">200</span></span>; DR7_PROTECT = $<span class="hljs-number"><span class="hljs-number">2000</span></span>; DR_SIZE_BYTE = <span class="hljs-number"><span class="hljs-number">0</span></span>; DR_SIZE_WORD = <span class="hljs-number"><span class="hljs-number">1</span></span>; DR_SIZE_DWORD = <span class="hljs-number"><span class="hljs-number">3</span></span>; DR_MODE_E = <span class="hljs-number"><span class="hljs-number">0</span></span>; DR_MODE_W = <span class="hljs-number"><span class="hljs-number">1</span></span>; DR_MODE_I = <span class="hljs-number"><span class="hljs-number">2</span></span>; DR_MODE_R = <span class="hljs-number"><span class="hljs-number">3</span></span>; DR7_MODE_DR0_E = DR_MODE_E <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>; DR7_MODE_DR0_W = DR_MODE_W <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>; DR7_MODE_DR0_I = DR_MODE_I <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>; DR7_MODE_DR0_R = DR_MODE_R <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>; DR7_SIZE_DR0_B = DR_SIZE_BYTE <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>; DR7_SIZE_DR0_W = DR_SIZE_WORD <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>; DR7_SIZE_DR0_D = DR_SIZE_DWORD <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>; DR7_MODE_DR1_E = DR_MODE_E <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>; DR7_MODE_DR1_W = DR_MODE_W <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>; DR7_MODE_DR1_I = DR_MODE_I <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>; DR7_MODE_DR1_R = DR_MODE_R <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>; DR7_SIZE_DR1_B = DR_SIZE_BYTE <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span>; DR7_SIZE_DR1_W = DR_SIZE_WORD <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span>; DR7_SIZE_DR1_D = DR_SIZE_DWORD <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span>; DR7_MODE_DR2_E = DR_MODE_E <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; DR7_MODE_DR2_W = DR_MODE_W <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; DR7_MODE_DR2_I = DR_MODE_I <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; DR7_MODE_DR2_R = DR_MODE_R <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; DR7_SIZE_DR2_B = DR_SIZE_BYTE <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span>; DR7_SIZE_DR2_W = DR_SIZE_WORD <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span>; DR7_SIZE_DR2_D = DR_SIZE_DWORD <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span>; DR7_MODE_DR3_E = DR_MODE_E <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span>; DR7_MODE_DR3_W = DR_MODE_W <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span>; DR7_MODE_DR3_I = DR_MODE_I <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span>; DR7_MODE_DR3_R = DR_MODE_R <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span>; DR7_SIZE_DR3_B = DR_SIZE_BYTE <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>; DR7_SIZE_DR3_W = DR_SIZE_WORD <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>; DR7_SIZE_DR3_D = $C0000000; <span class="hljs-comment"><span class="hljs-comment">//DR_SIZE_DWORD shl 30; DR_On: array [THWBPIndex] of DWORD = ( DR7_SET_LOC_DR0, DR7_SET_LOC_DR1, DR7_SET_LOC_DR2, DR7_SET_LOC_DR3 ); DR_Mode: array [THWBPIndex] of array [THWBPMode] of DWORD = ( (DR7_MODE_DR0_E, DR7_MODE_DR0_W, DR7_MODE_DR0_I, DR7_MODE_DR0_R), (DR7_MODE_DR1_E, DR7_MODE_DR1_W, DR7_MODE_DR1_I, DR7_MODE_DR1_R), (DR7_MODE_DR2_E, DR7_MODE_DR2_W, DR7_MODE_DR2_I, DR7_MODE_DR2_R), (DR7_MODE_DR3_E, DR7_MODE_DR3_W, DR7_MODE_DR3_I, DR7_MODE_DR3_R) ); DR_Size: array [THWBPIndex] of array [THWBPSize] of DWORD = ( (DR7_SIZE_DR0_B, DR7_SIZE_DR0_W, DR7_SIZE_DR0_D), (DR7_SIZE_DR1_B, DR7_SIZE_DR1_W, DR7_SIZE_DR1_D), (DR7_SIZE_DR2_B, DR7_SIZE_DR2_W, DR7_SIZE_DR2_D), (DR7_SIZE_DR3_B, DR7_SIZE_DR3_W, DR7_SIZE_DR3_D) ); var Context: TContext; I: THWBPIndex; begin if ThreadIndex &lt; 0 then Exit; ZeroMemory(@Context, SizeOf(TContext)); Context.ContextFlags := CONTEXT_DEBUG_REGISTERS; for I := 0 to 3 do begin if not FThreadList[ThreadIndex].Breakpoint.Active[I] then Continue; if FThreadList[ThreadIndex].Breakpoint.Address[I] &lt;&gt; nil then begin Context.Dr7 := Context.Dr7 or DR7_SET_LOC_ON; case I of 0: Context.Dr0 := DWORD(FThreadList[ThreadIndex].Breakpoint.Address[I]); 1: Context.Dr1 := DWORD(FThreadList[ThreadIndex].Breakpoint.Address[I]); 2: Context.Dr2 := DWORD(FThreadList[ThreadIndex].Breakpoint.Address[I]); 3: Context.Dr3 := DWORD(FThreadList[ThreadIndex].Breakpoint.Address[I]); end; Context.Dr7 := Context.Dr7 or DR_On[I]; Context.Dr7 := Context.Dr7 or DR_Mode[I, FThreadList[ThreadIndex].Breakpoint.Mode[I]]; Context.Dr7 := Context.Dr7 or DR_Size[I, FThreadList[ThreadIndex].Breakpoint.Size[I]]; end; end; Check(SetThreadContext(FThreadList[ThreadIndex].ThreadHandle, Context)); end;</span></span></code> </pre><br><br>       ,  ,    Dr7     . <br><br><pre> <code class="delphi hljs">Context.Dr7 := Context.Dr7 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> DR_On[I]; Context.Dr7 := Context.Dr7 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> DR_Mode[I, FThreadList[ThreadIndex].Breakpoint.Mode[I]]; Context.Dr7 := Context.Dr7 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> DR_Size[I, FThreadList[ThreadIndex].Breakpoint.Size[I]];</code> </pre><br><br>      LE   DR7_SET_LOC_ON. <br><br>     . <br><br>       EXCEPTION_BREAKPOINT. <br>      EXCEPTION_GUARD_PAGE. <br>          EXCEPTION_DEBUG_EVENT   EXCEPTION_SINGLE_STEP,           (          ). <br><br>   EXCEPTION_SINGLE_STEP        : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessHardwareBreakpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer; DebugEvent: TDebugEvent)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Integer; Context: TContext; ReleaseBP: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ZeroMemory(@Context, SizeOf(TContext)); Context.ContextFlags := CONTEXT_DEBUG_REGISTERS; Check(GetThreadContext(FThreadList[ThreadIndex].ThreadHandle, Context)); Result := Context.Dr6 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $F &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Result <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Context.Dr6 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Context.Dr6 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Context.Dr6 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Context.Dr6 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ReleaseBP := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FHardwareBreakpoint) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FHardwareBreakpoint(Self, ThreadIndex, DebugEvent.Exception.ExceptionRecord, <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>, ReleaseBP); ToggleHardwareBreakpoint(ThreadIndex, <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>, False); SetSingleStepMode(ThreadIndex, False); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ReleaseBP <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> DropHardwareBreakpoint(ThreadIndex, <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   HWBP    , //  ..     //  ProcessExceptionSingleStep,   HWBP   //        HWBP if (FRestoredThread &gt;= 0) and (FRestoredHWBPIndex &gt;= 0) then ToggleHardwareBreakpoint(FRestoredThread, FRestoredHWBPIndex, True); FRestoredHWBPIndex := Index; FRestoredThread := ThreadIndex; end; end;</span></span></code> </pre><br><br>        ,                 . <br><br>         Dr6   . <br>  4          1   ,     DrX . <br><br>   ,       ,  ,      (  EIP)     ,       ,     EXCEPTION_SINGLE_STEP   . <br><br>   ,        . <br>       EXCEPTION_SINGLE_STEP. <br><br>    : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TFWDebugerCore</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessExceptionSingleStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ThreadIndex: Integer; DebugEvent: TDebugEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Handled: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  HWBP Handled := ProcessHardwareBreakpoint(ThreadIndex, DebugEvent); //    - HWPB   HWBP if not Handled and (FRestoredThread &gt;= 0) and (FRestoredHWBPIndex &gt;= 0) then begin ToggleHardwareBreakpoint(FRestoredThread, FRestoredHWBPIndex, True); FRestoredThread := -1; FRestoredHWBPIndex := -1; end; //   if FRestoreBPIndex &gt;= 0 then begin CheckBreakpointIndex(FRestoreBPIndex); if FBreakpointList[FRestoreBPIndex].bpType = btBreakpoint then ToggleInt3Breakpoint(FRestoreBPIndex, True); FRestoreBPIndex := -1; end; //  M if FRestoreMBPIndex &gt;= 0 then begin CheckBreakpointIndex(FRestoreMBPIndex); if FBreakpointList[FRestoreMBPIndex].bpType = btMemoryBreakpoint then ToggleMemoryBreakpoint(FRestoreMBPIndex, True); FRestoreMBPIndex := -1; end; //         //     if ResumeAction &lt;&gt; raRun then begin CallUnhandledExceptionEvents(ThreadIndex, ecSingleStep, DebugEvent); //          DoResumeAction(ThreadIndex); end; end;</span></span></code> </pre><br><br>      ,         .    ,   ToggleHardwareBreakpoint    . <br>               ,  FRestoreBPIndex  FRestoreMBPIndex      ,     . <br>         ToggleInt3Breakpoint  ToggleMemoryBreakpoint. <br><br><h4> : </h4><br>        ,    ‚Äî    ,      . <br>       : ¬´         ¬ª :) <br><br>       . <br><br>  ‚Äî     .   VCL ,     ¬´test_app¬ª,    . <br><br>    ‚Äî .      ,   (      )  TMemo  TRichEdit,     . <br><br>  We write: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-title"><span class="hljs-title">TdlgDebuger</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TForm) Panel1: TPanel; btnStart: TButton; btnStop: TButton; edLog: TRichEdit; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnStartClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnStopClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FCore: TFWDebugerCore; FNeedStop: Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Writeln</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnStartClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Path: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FNeedStop := False; <span class="hljs-comment"><span class="hljs-comment">//        Path := ExtractFilePath(ParamStr(0)) + '..\test_app\test_app.exe'; FCore := TFWDebugerCore.Create(50); try btnStart.Enabled := False; btnStop.Enabled := True; if not FCore.DebugNewProcess(Path, True) then RaiseLastOSError; FCore.RunMainLoop; finally FCore.Free; btnStart.Enabled := True; btnStop.Enabled := False; end; Writeln; Writeln('Debug stop'); end; procedure TdlgDebuger.Writeln(const Value: string); begin edLog.Lines.Add(Value); end; procedure TdlgDebuger.btnStopClick(Sender: TObject); begin FNeedStop := True; end;</span></span></code> </pre><br>   -  : <br><br><img src="http://1.bp.blogspot.com/-oxIaWh8SIP0/UKptZVOISLI/AAAAAAAAAJE/xr9hwmwrkJ0/s1600/dbg1.png" alt="image"><br><br>   ¬´Start¬ª,       . <br><br>            . <br><br>   ,         TFWDebugerCore.RunMainLoop,        . <br><br>   ,             . <br><br>  ,       (    ‚Äî     )               OnIdle  TFWDebugerCore,     : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnIdle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FNeedStop <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FCore.StopDebug <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Application.ProcessMessages; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Application.ProcessMessages        . <br><br>           ,      Delphi.     OnCreateProcess  OnLoadDll. <br><br>    : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCreateProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; Data: TCreateProcessDebugInfo)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> T: TThreadData; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> T := FCore.GetThreadData(ThreadIndex); Writeln(Format(<span class="hljs-string"><span class="hljs-string">'CreateThread ID: %d'</span></span>, [T.ThreadID])); Writeln(Format(<span class="hljs-string"><span class="hljs-string">'ProcessStart ID: %d'</span></span>, [FCore.DebugProcessData.ProcessID])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLoadDll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; Data: TLoadDLLDebugInfo)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FormatStrKnownDLL = <span class="hljs-string"><span class="hljs-string">'Load Dll at instance %p handle %d "%s"'</span></span>; FormatStrUnknownDLL = <span class="hljs-string"><span class="hljs-string">'Load unknown Dll at instance %p handle %d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DllName: AnsiString; IsUnicodeData: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCore.ContinueStatus := DBG_EXCEPTION_NOT_HANDLED; IsUnicodeData := Data.fUnicode = <span class="hljs-number"><span class="hljs-number">1</span></span>; DllName := FCore.GetDllName(Data.lpImageName, Data.lpBaseOfDll, IsUnicodeData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> DllName &lt;&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> IsUnicodeData <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Writeln(Format(FormatStrKnownDLL, [Data.lpBaseOfDll, Data.hFile, PWideChar(@DllName[<span class="hljs-number"><span class="hljs-number">1</span></span>])])) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Writeln(Format(FormatStrKnownDLL, [Data.lpBaseOfDll, Data.hFile, PAnsiChar(@DllName[<span class="hljs-number"><span class="hljs-number">1</span></span>])])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Writeln(Format(FormatStrUnknownDLL, [Data.lpBaseOfDll, Data.hFile])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>          ¬´Start¬ª <br><br>   : <br><br><img src="http://1.bp.blogspot.com/-IVcct2LHvr0/UKpthMeYvyI/AAAAAAAAAJM/4zFbtbv8rfE/s1600/dbg2.png" alt="image"><br><br>   ‚Äî . <br><br><h4>  : </h4><br>     .      ,   TF ,   MBP.    40     .      : <br><br><img src="http://2.bp.blogspot.com/-QRQd2W8UtzQ/UKptqJL5HXI/AAAAAAAAAJU/o4bLPlD7dfg/s1600/trace.png" alt="image"><br><br>           ,      /  .           .       DebugNewProcess.       True,      .     OnBreakPoint     . <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnBreakPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord; BreakPointIndex: Integer; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ReleaseBreakpoint: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      Writeln(Format('!!! --&gt; Breakpoint "%s"', [FCore.BreakpointItem(BreakPointIndex).Description])); //   (    ) ReleaseBreakpoint := True; //    FCore.ResumeAction := raTraceInto; //     FStepCount := 0; end;</span></span></code> </pre><br><br>        OnSingleStep,   : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSingleStep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      Inc(FStepCount); Writeln(Format('!!! --&gt; trace step ‚Ññ%d at addr 0x%p', [FStepCount, ExceptionRecord.ExceptionAddress])); //        if FStepCount &gt; 10 then FCore.ResumeAction := raRun else FCore.ResumeAction := raTraceInto; end;</span></span></code> </pre><br><br>    : <br><br><img src="http://3.bp.blogspot.com/-6kq5n_VU4oQ/UKptwFjty4I/AAAAAAAAAJc/ip8VxS85qxw/s1600/trace1.png" alt="image"><br><br>    StepIn,        ,     0x00409FF4,    _InitExe(),      0x00409C53.      ,      _InitExe(),   ,     . <br><br>    ‚Äî  . <br>     ,    OnPageGuard     ,   SetMemoryBreakpoint      .          ,   OnBreakPoint      .        ,   ,          RemoveBreakpoint ( ),   //        ,  ReleaseBreakpoint    ,   RemoveCurrentBreakpoint     .      TFWDebugerCore    ,         . <br><br> ,   ,              ,       . <br><br> <b>  :</b> <br><br>       ,        OutputDebugString.               : <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// //    // ============================================================================= procedure TForm1.btnDebugStringClick(Sender: TObject); begin OutputDebugString('Test debug string'); end;</span></span></code> </pre><br><br>       OnDebugString,     : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDebugString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; Data: TOutputDebugStringInfo)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Data.fUnicode = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'DebugString: '</span></span> + PWideChar(FCore.ReadStringW(Data.lpDebugStringData, Data.nDebugStringLength))) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'DebugString: '</span></span> + PAnsiChar(FCore.ReadStringA(Data.lpDebugStringData, Data.nDebugStringLength))); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  ,        .  ¬´Test debug string¬ª   ?  ,      :) <br><br> <b> :</b> <br><br>           ?     - .             : <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// //       // ============================================================================= procedure TForm1.btnExceptClick(Sender: TObject); begin try asm int 3 end; ShowMessage('Debugger detected.'); except ShowMessage('Debugger not found.'); end; end;</span></span></code> </pre><br><br>      ,             . <br><br>     :        ,       ContinueStatus,     ContinueDebugEvent,   DBG_CONTINUE.  What does this mean?                . <br><br>          :   ¬´INT3¬ª   .        ,         exception..end,       .     ,           . <br><br>  ,        ,    ‚Äî   . <br><br>       ,    OnUnknownBreakPoint (int3 ‚Äî   ,    ,        ).      : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUnknownBreakPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ApplicationBP: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ApplicationBP := (DWORD(ExceptionRecord.ExceptionAddress) &gt; FCore.DebugProcessData.EntryPoint) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (DWORD(ExceptionRecord.ExceptionAddress) &lt; $<span class="hljs-number"><span class="hljs-number">500000</span></span>); Writeln; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ApplicationBP <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln(Format(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Unknown application breakpoint at addr 0X%p'</span></span>, [ExceptionRecord.ExceptionAddress])); Writeln(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Exception not handled.'</span></span>); FCore.ContinueStatus := DBG_EXCEPTION_NOT_HANDLED; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln(Format(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Unknown breakpoint at addr 0X%p'</span></span>, [ExceptionRecord.ExceptionAddress])); Writeln(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Exception handled.'</span></span>); FCore.ContinueStatus := DBG_CONTINUE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Writeln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    ,          ,      (        $500000).       ‚Äî   - .  ,        ,   DBG_EXCEPTION_NOT_HANDLED,          ,  -     . <br><br>     ,   ,        ,     :) <br><br> <b>    :</b> <br><br>        ,  ,       .        ,    : <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// //      // ============================================================================= procedure TForm1.btnKillStackClick(Sender: TObject); procedure T; var HugeBuff: array [0..10000] of DWORD; begin if HugeBuff[0] &lt;&gt; HugeBuff[10000] then Inc(HugeBuff[0]); T; end; begin try T; except T; end; end;</span></span></code> </pre><br><br>         .     ,      ‚Äî    .     ?      , ,       ,   PAGE_GUARD.  ,  - ,       ,         .       EXCEPTION_STACK_OVERFLOW.       ¬´ ¬ª    ,          .  ,    PAGE_GUARD  ,      ,   - .           ,  EXCEPTION_ACCESS_VIOLATION   -   ¬´¬ª,      ,    DBG_CONTROL_C    (            AV). <br><br>      OnUnknownException, .. TFWDebugerCore         .    : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgDebuger</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUnknownException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; ThreadIndex: Integer; ExceptionRecord: Windows.TExceptionRecord)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cause: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ExceptionRecord.ExceptionCode <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EXCEPTION_STACK_OVERFLOW: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Writeln(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Stack overflow detected. Probe to continue.'</span></span>); FCore.ContinueStatus := DBG_CONTINUE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; EXCEPTION_ACCESS_VIOLATION: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">{ The first element of the array contains a read-write flag that indicates the type of operation that caused the access violation. If this value is zero, the thread attempted to read the inaccessible data. If this value is 1, the thread attempted to write to an inaccessible address. If this value is 8, the thread causes a user-mode data execution prevention (DEP) violation. The second array element specifies the virtual address of the inaccessible data. }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ExceptionRecord.ExceptionInformation[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: Cause := <span class="hljs-string"><span class="hljs-string">'read'</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>: Cause := <span class="hljs-string"><span class="hljs-string">'write'</span></span>; <span class="hljs-number"><span class="hljs-number">8</span></span>: Cause := <span class="hljs-string"><span class="hljs-string">'DEP violation'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Cause := <span class="hljs-string"><span class="hljs-string">'unknown cause'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Writeln(Format(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Access violation at addr 0x%p %s of address 0x%p'</span></span>, [ ExceptionRecord.ExceptionAddress, Cause, Pointer(PDWORD(@ExceptionRecord.ExceptionInformation[<span class="hljs-number"><span class="hljs-number">1</span></span>])^) ])); Writeln(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Process Stopped.'</span></span>); FCore.ContinueStatus := DBG_CONTROL_C; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Writeln(Format(<span class="hljs-string"><span class="hljs-string">'!!! --&gt; Unknown exception code %p at addr 0x%p'</span></span>, [ Pointer(ExceptionRecord.ExceptionCode), ExceptionRecord.ExceptionAddress ])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Writeln; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>    : <br><br><img src="http://2.bp.blogspot.com/-RrAXLZ-idm0/UKpt3vQCVxI/AAAAAAAAAJk/7t05pB8HYik/s1600/done.png" alt="image"><br><br><h4>  Summarizing: </h4><br>           .     ,      . <br>      ,         , ,  .         ,       ,      . <br>   ,     :) <br><br>         : <a href="">http://rouse.drkb.ru/blog/dbg_part2.zip</a> <br><br> <a href="http://habrahabr.ru/post/178183/">     </a>       ,        :) <br><br>       . <br><br> ¬©  (Rouse_)  <br> ,  2012 </div><p>Source: <a href="https://habr.com/ru/post/178159/">https://habr.com/ru/post/178159/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178147/index.html">Photos of insects in flight, obtained using the old HDD</a></li>
<li><a href="../178149/index.html">Orange dude distributes servers for free</a></li>
<li><a href="../178153/index.html">What does a ddos ‚Äã‚Äãattack look like</a></li>
<li><a href="../178155/index.html">Mysterious stationery. Quickness test</a></li>
<li><a href="../178157/index.html">Effective interview option</a></li>
<li><a href="../178161/index.html">Install 3 systems on 1 disk with shared loader</a></li>
<li><a href="../178163/index.html">Craftsmen already got root access to Google Glass software</a></li>
<li><a href="../178165/index.html">The digest of interesting news and materials from the world of ayti for the last week No. 54 (April 20 - 26, 2013)</a></li>
<li><a href="../178171/index.html">What do I expect from Windows Phone on the example of Lumia 920</a></li>
<li><a href="../178173/index.html">On the Internet earned Gospoisk. Senseless and merciless</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>