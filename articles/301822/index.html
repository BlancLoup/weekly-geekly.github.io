<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Websocket in production</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="10 months ago I started making a browser toy. The choice fell on cocos js as graphics and websocket as communication with the server. I really liked t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Websocket in production</h1><div class="post__text post__text-html js-mediator-article">  10 months ago I started making a browser toy.  The choice fell on cocos js as graphics and websocket as communication with the server.  I really liked the technology and on it I organized all the communication between the game and the server.  Used for <a href="https://habrahabr.ru/post/209864/">this article</a> .  But, unfortunately, the code shown in that article cannot be used in production.  As it turned out, the level of the problem is not even critical, but blocking.  Everything is so bad that I had to rewrite all communication with the server from the websockets to longpooling.  In the end, I left the option "if we do not have a safari browser, then use websocket, otherwise longpolling" and a little more branching on this topic. <br><br>  So, the experience of using a website in the production has accumulated decent.  And just recently an event happened that prompted me to write the first article on Habr√©. <br><a name="habracut"></a><br>  After the toy was published on the social network, I corrected all the found critical / blocking bugs and began to put everything in order in a quiet mode.  I want to draw attention to the fact that <a href="https://habrahabr.ru/post/209864/">this is an example</a> - it is generally the only online guide that contains server code that you can insert into your code and use it.  Well, type in the search engine "php websocket server" - try to find something that you can put yourself. <br><br>  Suddenly, I reread the above <a href="https://habrahabr.ru/post/209864/">article</a> and at the very beginning I find links to phpdaemon and ratchet.  Well, I think, let's look at the code there in a quiet mode.  In PhpDeamon, in the depths of processing a WebSocket connection, there is a small, but insanely important, branch to the WebSocket protocols.  And there it is directly written for one case "Safari5 and many non-browser clients".  To say that I am ofigel is to say nothing.  Several hundred hours swept before my eyes, tons of hassle and suffering, which called into question the project at all.  I did not believe, I decided to check. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Within ~ 15 hours I pulled out the minimum code associated with WebSocket from PhpDeamon (which works in all browsers of the latest version, and the server code itself can work under high load) and will try to publish it with explanations.  So that other people would not experience the torment that I had to go through.  Yes, a piece of code turned out not small, but I'm sorry: WebSocket is very simple on the client side, and on the server side everything is quite voluminous (let's say a special ‚Äúthank you‚Äù to Safari developers).  Also, due to the fact that the scope of WebSocket is primarily a game, the issue of non-blocking use of a server socket is important - this is a bonus complexity that is not considered <a href="https://habrahabr.ru/post/209864/">here</a> , although it is very important. <br><br>  I wanted to write a test application without objects to make it clearer.  But, unfortunately, such an approach in this example will produce a lot of repeating code, so I had to add 1 class and 3 of his successor.  The rest is all without objects. <br><br><div class="spoiler">  <b class="spoiler_title">To start the client part</b> <div class="spoiler_text"><pre><code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/1999/xhtml"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http-equiv</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Content-Type"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/html; charset=utf-8"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>WebSocket test page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"create();"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="actionscript"><span class="hljs-function"><span class="hljs-title">create</span></span></span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ </span><span class="hljs-comment"><span class="actionscript"><span class="hljs-comment">// Example ws = new WebSocket('ws://'+document.domain+':8081/'); ws.onopen = function () {document.getElementById('log').innerHTML += 'WebSocket opened &lt;br/&gt;';} ws.onmessage = function (e) {document.getElementById('log').innerHTML += 'WebSocket message: '+e.data+' &lt;br/&gt;';} ws.onclose = function () {document.getElementById('log').innerHTML += 'WebSocket closed &lt;br/&gt;';} } </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onclick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"create();"</span></span></span><span class="hljs-tag">&gt;</span></span>Create WebSocket<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onclick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ws.send('ping');"</span></span></span><span class="hljs-tag">&gt;</span></span>Send ping<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onclick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ws.close();"</span></span></span><span class="hljs-tag">&gt;</span></span>Close WebSocket<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"log"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"width:300px; height: 300px; border: 1px solid #999999; overflow:auto;"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br></div></div><br>  In my game I had to use 3 server sockets.  For websocket, for workers and for longpooling.  There is a lot of math in the game, so you had to do the turners and give them tasks for calculations.  So this is what it is for.  That stream_select should be common for all of them, otherwise there will be lags or insane processor usage.  This knowledge was also obtained in return for a heap of expended nerves. <br><br><div class="spoiler">  <b class="spoiler_title">Main service cycle</b> <div class="spoiler_text"><pre> <code class="php hljs">$master = stream_socket_server(<span class="hljs-string"><span class="hljs-string">"tcp://127.0.0.1:8081"</span></span>, $errno, $errstr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$master) <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"$errstr ($errno)\n"</span></span>); $sockets = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($master); stream_set_blocking($master, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      ,         ,     "stream_socket_accept". ,         - ,      -  . while (true) { $read = $sockets; $write = $except = array(); if (($num_changed_streams = stream_select($read, $write, $except, 0, 1000000)) === false) { var_dump('stream_select error'); break; //    ,   "die",                "/etc/init.d/game restart"  100%   case,     "pcntl"       . } foreach ($read as $socket) { $index_socket = array_search($socket, $sockets); if ($index_socket == 0) { //   continue; } //      } }</span></span></code> </pre><br></div></div><br>  Connecting with new clients is quite a standard code, but due to the fact that our sockets are in non-blocking mode, you need to write a bunch of code that will collect all the incoming data in pieces and, when there is enough data, process them, understand what protocol is needed use and switch to using this protocol.  This task alone is already a mountain of code, and in PhpDeamon they have built up a lot of code, which has nothing to do with the WebSocket (they are able to raise 8 different servers there).  We managed to cut off a lot and simplify this topic.  Left only that relates to WebSocket. <br><br><div class="spoiler">  <b class="spoiler_title">File truncated &lt;ws.php&gt;</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ws</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_BUFFER_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $socket; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array _SERVER */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $server = []; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $headers = []; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $closed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $unparsed_data = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $current_header; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $unread_lines = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $extensions = []; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $extensionsCleanRegex = <span class="hljs-string"><span class="hljs-string">'/(?:^|\W)x-webkit-/iS'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> integer Current state */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// stream state of the connection (application protocol level) /** * Alias of STATE_STANDBY */ const STATE_ROOT = 0; /** * Standby state (default state) */ const STATE_STANDBY = 0; /** * State: first line */ const STATE_FIRSTLINE = 1; /** * State: headers */ const STATE_HEADERS = 2; /** * State: content */ const STATE_CONTENT = 3; /** * State: prehandshake */ const STATE_PREHANDSHAKE = 5; /** * State: handshaked */ const STATE_HANDSHAKED = 6; public function get_state() { return $this-&gt;state; } public function closed() { return $this-&gt;closed; } protected function close() { if ($this-&gt;closed) return; var_dump('self close'); fclose($this-&gt;socket); $this-&gt;closed = true; } public function __construct($socket) { stream_set_blocking($socket, false); $this-&gt;socket = $socket; } private function read_line() { $lines = explode(PHP_EOL, $this-&gt;unparsed_data); $last_line = $lines[count($lines)-1]; unset($lines[count($lines) - 1]); foreach ($lines as $line) { $this-&gt;unread_lines[] = $line; } $this-&gt;unparsed_data = $last_line; if (count($this-&gt;unread_lines) != 0) { return array_shift($this-&gt;unread_lines); } else { return null; } } public function on_receive_data() { if ($this-&gt;closed) return; $data = stream_socket_recvfrom($this-&gt;socket, MAX_BUFFER_SIZE); if (is_string($data)) { $this-&gt;unparsed_data .= $data; } } /** * Called when new data received. * @return void */ public function on_read() { if ($this-&gt;closed) return; if ($this-&gt;state === self::STATE_STANDBY) { $this-&gt;state = self::STATE_FIRSTLINE; } if ($this-&gt;state === self::STATE_FIRSTLINE) { if (!$this-&gt;http_read_first_line()) { return; } $this-&gt;state = self::STATE_HEADERS; } if ($this-&gt;state === self::STATE_HEADERS) { if (!$this-&gt;http_read_headers()) { return; } if (!$this-&gt;http_process_headers()) { $this-&gt;close(); return; } $this-&gt;state = self::STATE_CONTENT; } if ($this-&gt;state === self::STATE_CONTENT) { $this-&gt;state = self::STATE_PREHANDSHAKE; } } /** * Read first line of HTTP request * @return boolean|null Success */ protected function http_read_first_line() { if (($l = $this-&gt;read_line()) === null) { return null; } $e = explode(' ', $l); $u = isset($e[1]) ? parse_url($e[1]) : false; if ($u === false) { $this-&gt;bad_request(); return false; } if (!isset($u['path'])) { $u['path'] = null; } if (isset($u['host'])) { $this-&gt;server['HTTP_HOST'] = $u['host']; } $srv = &amp; $this-&gt;server; $srv['REQUEST_METHOD'] = $e[0]; $srv['REQUEST_TIME'] = time(); $srv['REQUEST_TIME_FLOAT'] = microtime(true); $srv['REQUEST_URI'] = $u['path'] . (isset($u['query']) ? '?' . $u['query'] : ''); $srv['DOCUMENT_URI'] = $u['path']; $srv['PHP_SELF'] = $u['path']; $srv['QUERY_STRING'] = isset($u['query']) ? $u['query'] : null; $srv['SCRIPT_NAME'] = $srv['DOCUMENT_URI'] = isset($u['path']) ? $u['path'] : '/'; $srv['SERVER_PROTOCOL'] = isset($e[2]) ? $e[2] : 'HTTP/1.1'; $srv['REMOTE_ADDR'] = null; $srv['REMOTE_PORT'] = null; return true; } /** * Read headers line-by-line * @return boolean|null Success */ protected function http_read_headers() { while (($l = $this-&gt;read_line()) !== null) { if ($l === '') { return true; } $e = explode(': ', $l); if (isset($e[1])) { $this-&gt;current_header = 'HTTP_' . strtoupper(strtr($e[0], ['-' =&gt; '_'])); $this-&gt;server[$this-&gt;current_header] = $e[1]; } elseif (($e[0][0] === "\t" || $e[0][0] === "\x20") &amp;&amp; $this-&gt;current_header) { // multiline header continued $this-&gt;server[$this-&gt;current_header] .= $e[0]; } else { // whatever client speaks is not HTTP anymore $this-&gt;bad_request(); return false; } } } /** * Process headers * @return bool */ protected function http_process_headers() { $this-&gt;state = self::STATE_PREHANDSHAKE; if (isset($this-&gt;server['HTTP_SEC_WEBSOCKET_EXTENSIONS'])) { $str = strtolower($this-&gt;server['HTTP_SEC_WEBSOCKET_EXTENSIONS']); $str = preg_replace($this-&gt;extensionsCleanRegex, '', $str); $this-&gt;extensions = explode(', ', $str); } if (!isset($this-&gt;server['HTTP_CONNECTION']) || (!preg_match('~(?:^|\W)Upgrade(?:\W|$)~i', $this-&gt;server['HTTP_CONNECTION'])) // "Upgrade" is not always alone (ie. "Connection: Keep-alive, Upgrade") || !isset($this-&gt;server['HTTP_UPGRADE']) || (strtolower($this-&gt;server['HTTP_UPGRADE']) !== 'websocket') // Lowercase comparison iss important ) { $this-&gt;close(); return false; } if (isset($this-&gt;server['HTTP_COOKIE'])) { self::parse_str(strtr($this-&gt;server['HTTP_COOKIE'], self::$hvaltr), $this-&gt;cookie); } if (isset($this-&gt;server['QUERY_STRING'])) { self::parse_str($this-&gt;server['QUERY_STRING'], $this-&gt;get); } // ---------------------------------------------------------- // Protocol discovery, based on HTTP headers... // ---------------------------------------------------------- if (isset($this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'])) { // HYBI if ($this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'] === '8') { // Version 8 (FF7, Chrome14) $this-&gt;switch_to_protocol('v13'); } elseif ($this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'] === '13') { // newest protocol $this-&gt;switch_to_protocol('v13'); } else { error_log(get_class($this) . '::' . __METHOD__ . " : Websocket protocol version " . $this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'] . ' is not yet supported for client "addr"'); // $this-&gt;addr $this-&gt;close(); return false; } } elseif (!isset($this-&gt;server['HTTP_SEC_WEBSOCKET_KEY1']) || !isset($this-&gt;server['HTTP_SEC_WEBSOCKET_KEY2'])) { $this-&gt;switch_to_protocol('ve'); } else { // Defaulting to HIXIE (Safari5 and many non-browser clients...) $this-&gt;switch_to_protocol('v0'); } // ---------------------------------------------------------- // End of protocol discovery // ---------------------------------------------------------- return true; } private function switch_to_protocol($protocol) { $class = 'ws_'.$protocol; $this-&gt;new_instance = new $class($this-&gt;socket); $this-&gt;new_instance-&gt;state = $this-&gt;state; $this-&gt;new_instance-&gt;unparsed_data = $this-&gt;unparsed_data; $this-&gt;new_instance-&gt;server = $this-&gt;server; } /** * Send Bad request * @return void */ public function bad_request() { $this-&gt;write("400 Bad Request\r\n\r\n&lt;html&gt;&lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"white\"&gt;&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;"); $this-&gt;close(); } /** * Replacement for default parse_str(), it supoorts UCS-2 like this: %uXXXX * @param string $s String to parse * @param array &amp;$var Reference to the resulting array * @param boolean $header Header-style string * @return void */ public static function parse_str($s, &amp;$var, $header = false) { static $cb; if ($cb === null) { $cb = function ($m) { return urlencode(html_entity_decode('&amp;#' . hexdec($m[1]) . ';', ENT_NOQUOTES, 'utf-8')); }; } if ($header) { $s = strtr($s, self::$hvaltr); } if ( (stripos($s, '%u') !== false) &amp;&amp; preg_match('~(%u[af\d]{4}|%[cf][af\d](?!%[89a-f][af\d]))~is', $s, $m) ) { $s = preg_replace_callback('~%(u[af\d]{4}|[af\d]{2})~i', $cb, $s); } parse_str($s, $var); } /** * Send data to the connection. Note that it just writes to buffer that flushes at every baseloop * @param string $data Data to send * @return boolean Success */ public function write($data) { if ($this-&gt;closed) return false; return stream_socket_sendto($this-&gt;socket, $data) == 0; } }</span></span></code> </pre><br></div></div><br>  The meaning of this class in such an abridged form is to set the non-blocking mode in the designer to connect with the client.  Then, in the main loop, every time data arrives, immediately read and put it (add) to the "unparsed_data" variable (this is the <b>on_receive_data</b> method).  It is important to understand that if we go beyond the dimensions of MAX_BUFFER_SIZE, then nothing terrible will happen at all.  It is possible in the final example, what will happen here, put its value, say, "5" and make sure that everything is still working.  Simply, the data from the buffer will be ignored at the first step - they will be incomplete, and from the second or fifth or hundredth approach they will be collected, finally, all received data will be processed.  In this case, the stream_select in the main loop will not even wait microseconds until all data has been retrieved.  The constant must be chosen such that 95% of the expected data is read entirely. <br>  Then in the main loop (after receiving the next piece of data) we try to process the accumulated data (this is the <b>on_read</b> method).  In the ws class, the on_read method consists essentially of three steps: ‚Äúread the first line and prepare environment variables‚Äù, ‚Äúread all the headers‚Äù, ‚Äúprocess all the headers‚Äù.  The first 2 do not need to be explained, but they are written quite volumetrically because we are in non-blocking mode and we must be prepared for the data to be broken in any place.  Header processing first checks whether the request is valid or not, and then defines the protocol by which it will communicate with the client.  As a result, they should pull the <b>switch_to_protocol</b> method.  This method inside itself will form an instance of the class ‚Äúws_ &lt;protocol&gt;‚Äù and prepare it for return to the main loop. <br><br>  In the main loop, then you need to actually check: is it not necessary to replace the object (if someone can offer the implementation of this place better, you are welcome). <br><br>  Next, in the main loop, you need to put a check: is the socket closed?  If it is closed, then clear the memory (about this far in the next block). <br><br><div class="spoiler">  <b class="spoiler_title">Now the full version of the file &lt;deamon.php&gt;</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws_v0.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws_v13.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws_ve.php'</span></span>); $master = stream_socket_server(<span class="hljs-string"><span class="hljs-string">"tcp://127.0.0.1:8081"</span></span>, $errno, $errstr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$master) <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"$errstr ($errno)\n"</span></span>); $sockets = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>($master); <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> ws[] $connections */</span></span> $connections = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); stream_set_blocking($master, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> ws $connection * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> $data * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> $type */</span></span> $my_callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($connection, $data, $type)</span></span></span><span class="hljs-function"> </span></span>{ var_dump(<span class="hljs-string"><span class="hljs-string">'my ws data: ['</span></span>.$data.<span class="hljs-string"><span class="hljs-string">'/'</span></span>.$type.<span class="hljs-string"><span class="hljs-string">']'</span></span>); $connection-&gt;send_frame(<span class="hljs-string"><span class="hljs-string">'test '</span></span>.time()); }; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { $read = $sockets; $write = $except = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (($num_changed_streams = stream_select($read, $write, $except, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>)) === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { var_dump(<span class="hljs-string"><span class="hljs-string">'stream_select error'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($read <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $socket) { $index_socket = array_search($socket, $sockets); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($index_socket == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   if ($socket_new = stream_socket_accept($master, -1)) { $connection = new ws($socket_new, $my_callback); $sockets[] = $socket_new; $index_new_socket = array_search($socket_new, $sockets); $connections[$index_new_socket] = &amp;$connection; $index_socket = $index_new_socket; } else { //            error_log('stream_socket_accept'); var_dump('error stream_socket_accept'); continue; } } $connection = &amp;$connections[$index_socket]; $connection-&gt;on_receive_data(); $connection-&gt;on_read(); if ($connection-&gt;get_state() == ws::STATE_PREHANDSHAKE) { $connection = $connection-&gt;get_new_instance(); $connections[$index_socket] = &amp;$connection; $connection-&gt;on_read(); } if ($connection-&gt;closed()) { unset($sockets[$index_socket]); unset($connections[$index_socket]); unset($connection); var_dump('close '.$index_socket); } } }</span></span></code> </pre><br></div></div><br>  Here "$ my_callback" is added - this is our custom message handler from the client.  Of course, in production, you can wrap it all in all sorts of objects, and here to make it clearer just a variable-function.  More about her later. <br><br>  The processing of the new connection is implemented and the main body of the cycle, about which I wrote above, is implemented. <br><br>  I want to draw attention to the server code <a href="https://habrahabr.ru/post/209864/">here</a> .  That if the read data from the socket is an empty string (yes, of course, I saw an update check for an empty string there), then the socket must be closed.  Oh, I do not even know how much this momet drank to me and how many users I lost.  Suddenly, Safari sends an empty string and considers it the norm, and this code takes and closes the connection to the user.  Yandex browser sometimes behaves the same way.  I don‚Äôt know why, but in this case, the WebSocket for Safari remains frozen, that is, it does not close, does not open - it just hangs and that‚Äôs it.  Have you already noticed that I am not indifferent to this magic browser?  I remember how I installed it under IE6 - about the same feelings. <br><br>  Now, about why I use <b>array_search</b> and synchronize the $ sockets array and the $ connections array.  The fact is that stream_select is vital for a clean array of $ sockets and nothing else.  But somehow it‚Äôs necessary to bind a specific socket from the $ sockets array to the ‚Äúws‚Äù object.  I tried a bunch of options - in the end I stopped at such an option that there are 2 arrays that are constantly synchronized by keys.  In one array, there are required clean sockets for stream_select, and in the second, instances of the class ‚Äúws‚Äù or its heirs  If someone can offer this place better - offer. <br><br>  We should also separately note the case when <b>stream_socket_accept is</b> filed.  As I understand it, theoretically, this can be only if the master socket is in non-blocking mode, and not enough data has arrived to connect the client.  Therefore, we simply do nothing. <br><br><div class="spoiler">  <b class="spoiler_title">Full version of the file &lt;ws.php&gt;</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ws</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $hvaltr = [<span class="hljs-string"><span class="hljs-string">'; '</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'%20'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> maxAllowedPacket = <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_BUFFER_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $socket; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array _SERVER */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $server = []; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $on_frame_user = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $handshaked = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $headers = []; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $headers_sent = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $closed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $unparsed_data = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $current_header; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $unread_lines = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> ws|null */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $new_instance = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $extensions = []; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $extensionsCleanRegex = <span class="hljs-string"><span class="hljs-string">'/(?:^|\W)x-webkit-/iS'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> integer Current state */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// stream state of the connection (application protocol level) /** * Alias of STATE_STANDBY */ const STATE_ROOT = 0; /** * Standby state (default state) */ const STATE_STANDBY = 0; /** * State: first line */ const STATE_FIRSTLINE = 1; /** * State: headers */ const STATE_HEADERS = 2; /** * State: content */ const STATE_CONTENT = 3; /** * State: prehandshake */ const STATE_PREHANDSHAKE = 5; /** * State: handshaked */ const STATE_HANDSHAKED = 6; public function get_state() { return $this-&gt;state; } public function get_new_instance() { return $this-&gt;new_instance; } public function closed() { return $this-&gt;closed; } protected function close() { if ($this-&gt;closed) return; var_dump('self close'); fclose($this-&gt;socket); $this-&gt;closed = true; } public function __construct($socket, $on_frame_user = null) { stream_set_blocking($socket, false); $this-&gt;socket = $socket; $this-&gt;on_frame_user = $on_frame_user; } private function read_line() { $lines = explode(PHP_EOL, $this-&gt;unparsed_data); $last_line = $lines[count($lines)-1]; unset($lines[count($lines) - 1]); foreach ($lines as $line) { $this-&gt;unread_lines[] = $line; } $this-&gt;unparsed_data = $last_line; if (count($this-&gt;unread_lines) != 0) { return array_shift($this-&gt;unread_lines); } else { return null; } } public function on_receive_data() { if ($this-&gt;closed) return; $data = stream_socket_recvfrom($this-&gt;socket, self::MAX_BUFFER_SIZE); if (is_string($data)) { $this-&gt;unparsed_data .= $data; } } /** * Called when new data received. * @return void */ public function on_read() { if ($this-&gt;closed) return; if ($this-&gt;state === self::STATE_STANDBY) { $this-&gt;state = self::STATE_FIRSTLINE; } if ($this-&gt;state === self::STATE_FIRSTLINE) { if (!$this-&gt;http_read_first_line()) { return; } $this-&gt;state = self::STATE_HEADERS; } if ($this-&gt;state === self::STATE_HEADERS) { if (!$this-&gt;http_read_headers()) { return; } if (!$this-&gt;http_process_headers()) { $this-&gt;close(); return; } $this-&gt;state = self::STATE_CONTENT; } if ($this-&gt;state === self::STATE_CONTENT) { $this-&gt;state = self::STATE_PREHANDSHAKE; } } /** * Read first line of HTTP request * @return boolean|null Success */ protected function http_read_first_line() { if (($l = $this-&gt;read_line()) === null) { return null; } $e = explode(' ', $l); $u = isset($e[1]) ? parse_url($e[1]) : false; if ($u === false) { $this-&gt;bad_request(); return false; } if (!isset($u['path'])) { $u['path'] = null; } if (isset($u['host'])) { $this-&gt;server['HTTP_HOST'] = $u['host']; } $address = explode(':', stream_socket_get_name($this-&gt;socket, true)); //   $srv = &amp; $this-&gt;server; $srv['REQUEST_METHOD'] = $e[0]; $srv['REQUEST_TIME'] = time(); $srv['REQUEST_TIME_FLOAT'] = microtime(true); $srv['REQUEST_URI'] = $u['path'] . (isset($u['query']) ? '?' . $u['query'] : ''); $srv['DOCUMENT_URI'] = $u['path']; $srv['PHP_SELF'] = $u['path']; $srv['QUERY_STRING'] = isset($u['query']) ? $u['query'] : null; $srv['SCRIPT_NAME'] = $srv['DOCUMENT_URI'] = isset($u['path']) ? $u['path'] : '/'; $srv['SERVER_PROTOCOL'] = isset($e[2]) ? $e[2] : 'HTTP/1.1'; $srv['REMOTE_ADDR'] = $address[0]; $srv['REMOTE_PORT'] = $address[1]; return true; } /** * Read headers line-by-line * @return boolean|null Success */ protected function http_read_headers() { while (($l = $this-&gt;read_line()) !== null) { if ($l === '') { return true; } $e = explode(': ', $l); if (isset($e[1])) { $this-&gt;current_header = 'HTTP_' . strtoupper(strtr($e[0], ['-' =&gt; '_'])); $this-&gt;server[$this-&gt;current_header] = $e[1]; } elseif (($e[0][0] === "\t" || $e[0][0] === "\x20") &amp;&amp; $this-&gt;current_header) { // multiline header continued $this-&gt;server[$this-&gt;current_header] .= $e[0]; } else { // whatever client speaks is not HTTP anymore $this-&gt;bad_request(); return false; } } } /** * Process headers * @return bool */ protected function http_process_headers() { $this-&gt;state = self::STATE_PREHANDSHAKE; if (isset($this-&gt;server['HTTP_SEC_WEBSOCKET_EXTENSIONS'])) { $str = strtolower($this-&gt;server['HTTP_SEC_WEBSOCKET_EXTENSIONS']); $str = preg_replace($this-&gt;extensionsCleanRegex, '', $str); $this-&gt;extensions = explode(', ', $str); } if (!isset($this-&gt;server['HTTP_CONNECTION']) || (!preg_match('~(?:^|\W)Upgrade(?:\W|$)~i', $this-&gt;server['HTTP_CONNECTION'])) // "Upgrade" is not always alone (ie. "Connection: Keep-alive, Upgrade") || !isset($this-&gt;server['HTTP_UPGRADE']) || (strtolower($this-&gt;server['HTTP_UPGRADE']) !== 'websocket') // Lowercase comparison iss important ) { $this-&gt;close(); return false; } /* if (isset($this-&gt;server['HTTP_COOKIE'])) { self::parse_str(strtr($this-&gt;server['HTTP_COOKIE'], self::$hvaltr), $this-&gt;cookie); } if (isset($this-&gt;server['QUERY_STRING'])) { self::parse_str($this-&gt;server['QUERY_STRING'], $this-&gt;get); } */ // ---------------------------------------------------------- // Protocol discovery, based on HTTP headers... // ---------------------------------------------------------- if (isset($this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'])) { // HYBI if ($this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'] === '8') { // Version 8 (FF7, Chrome14) $this-&gt;switch_to_protocol('v13'); } elseif ($this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'] === '13') { // newest protocol $this-&gt;switch_to_protocol('v13'); } else { error_log(get_class($this) . '::' . __METHOD__ . " : Websocket protocol version " . $this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'] . ' is not yet supported for client "addr"'); // $this-&gt;addr $this-&gt;close(); return false; } } elseif (!isset($this-&gt;server['HTTP_SEC_WEBSOCKET_KEY1']) || !isset($this-&gt;server['HTTP_SEC_WEBSOCKET_KEY2'])) { $this-&gt;switch_to_protocol('ve'); } else { // Defaulting to HIXIE (Safari5 and many non-browser clients...) $this-&gt;switch_to_protocol('v0'); } // ---------------------------------------------------------- // End of protocol discovery // ---------------------------------------------------------- return true; } private function switch_to_protocol($protocol) { $class = 'ws_'.$protocol; $this-&gt;new_instance = new $class($this-&gt;socket); $this-&gt;new_instance-&gt;state = $this-&gt;state; $this-&gt;new_instance-&gt;unparsed_data = $this-&gt;unparsed_data; $this-&gt;new_instance-&gt;server = $this-&gt;server; $this-&gt;new_instance-&gt;on_frame_user = $this-&gt;on_frame_user; } /** * Send Bad request * @return void */ public function bad_request() { $this-&gt;write("400 Bad Request\r\n\r\n&lt;html&gt;&lt;head&gt;&lt;title&gt;400 Bad Request&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"white\"&gt;&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;"); $this-&gt;close(); } /** * Replacement for default parse_str(), it supoorts UCS-2 like this: %uXXXX * @param string $s String to parse * @param array &amp;$var Reference to the resulting array * @param boolean $header Header-style string * @return void */ public static function parse_str($s, &amp;$var, $header = false) { static $cb; if ($cb === null) { $cb = function ($m) { return urlencode(html_entity_decode('&amp;#' . hexdec($m[1]) . ';', ENT_NOQUOTES, 'utf-8')); }; } if ($header) { $s = strtr($s, self::$hvaltr); } if ( (stripos($s, '%u') !== false) &amp;&amp; preg_match('~(%u[af\d]{4}|%[cf][af\d](?!%[89a-f][af\d]))~is', $s, $m) ) { $s = preg_replace_callback('~%(u[af\d]{4}|[af\d]{2})~i', $cb, $s); } parse_str($s, $var); } /** * Send data to the connection. Note that it just writes to buffer that flushes at every baseloop * @param string $data Data to send * @return boolean Success */ public function write($data) { if ($this-&gt;closed) return false; return stream_socket_sendto($this-&gt;socket, $data) == 0; } /** *         * @return bool */ protected function send_handshake_reply() { return false; } /** * Called when we're going to handshake. * @return boolean Handshake status */ public function handshake() { $extra_headers = ''; foreach ($this-&gt;headers as $k =&gt; $line) { if ($k !== 'STATUS') { $extra_headers .= $line . "\r\n"; } } if (!$this-&gt;send_handshake_reply($extra_headers)) { error_log(get_class($this) . '::' . __METHOD__ . ' : Handshake protocol failure for client ""'); // $this-&gt;addr $this-&gt;close(); return false; } $this-&gt;handshaked = true; $this-&gt;headers_sent = true; $this-&gt;state = static::STATE_HANDSHAKED; return true; } /** * Read from buffer without draining * @param integer $n Number of bytes to read * @param integer $o Offset * @return string|false */ public function look($n, $o = 0) { if (strlen($this-&gt;unparsed_data) &lt;= $o) { return ''; } return substr($this-&gt;unparsed_data, $o, $n); } /** * Convert bytes into integer * @param string $str Bytes * @param boolean $l Little endian? Default is false * @return integer */ public static function bytes2int($str, $l = false) { if ($l) { $str = strrev($str); } $dec = 0; $len = strlen($str); for ($i = 0; $i &lt; $len; ++$i) { $dec += ord(substr($str, $i, 1)) * pow(0x100, $len - $i - 1); } return $dec; } /** * Drains buffer * @param integer $n Numbers of bytes to drain * @return boolean Success */ public function drain($n) { $ret = substr($this-&gt;unparsed_data, 0, $n); $this-&gt;unparsed_data = substr($this-&gt;unparsed_data, $n); return $ret; } /** * Read data from the connection's buffer * @param integer $n Max. number of bytes to read * @return string|false Readed data */ public function read($n) { if ($n &lt;= 0) { return ''; } $read = $this-&gt;drain($n); if ($read === '') { return false; } return $read; } /** * Reads all data from the connection's buffer * @return string Readed data */ public function read_unlimited() { $ret = $this-&gt;unparsed_data; $this-&gt;unparsed_data = ''; return $ret; } /** * Searches first occurence of the string in input buffer * @param string $what Needle * @param integer $start Offset start * @param integer $end Offset end * @return integer Position */ public function search($what, $start = 0, $end = -1) { return strpos($this-&gt;unparsed_data, $what, $start); } /** * Called when new frame received. * @param string $data Frame's data. * @param string $type Frame's type ("STRING" OR "BINARY"). * @return boolean Success. */ public function on_frame($data, $type) { if (is_callable($this-&gt;on_frame_user)) { call_user_func($this-&gt;on_frame_user, $this, $data, $type); } return true; } public function send_frame($data, $type = null, $cb = null) { return false; } /** * Get real frame type identificator * @param $type * @return integer */ public function get_frame_type($type) { if (is_int($type)) { return $type; } if ($type === null) { $type = 'STRING'; } $frametype = @constant(get_class($this) . '::' . $type); if ($frametype === null) { error_log(__METHOD__ . ' : Undefined frametype "' . $type . '"'); } return $frametype; } }</span></span></code> </pre><br></div></div><br>  In fact, there are 3 things added: ‚Äúconnection with the client at the web socket level‚Äù, ‚Äúreceiving a message from the client‚Äù, ‚Äúsending a message to the client‚Äù. <br><br>  First, a little theory and terminology.  ‚ÄúHandshake‚Äù is, from the web sockets point of view, a connection establishment procedure over http.  You have to solve a lot of questions: how to break through the thick of the proxy and cache, how to protect yourself from evil hackers.  And the term "frame" is a piece of data in decrypted form, this is a message from a client or a message to a client.  Perhaps it was worth writing about this at the beginning of the article, but because of these ‚Äúframes‚Äù, it‚Äôs pointless to make a socket server in blocking sockets mode.  The way this moment <a href="https://habrahabr.ru/post/209864/">is made right here</a> - it deprived me of sleep for more than one night.  The article does not consider the option that the frame did not arrive completely or two arrived at once.  And this and that, by the way, is quite a typical situation, as the logs of the game showed. <br><br>  Now to the details. <br><br> <b>      </b> ‚Äî ,   (, ws_v0)   ¬´on_read¬ª     ¬´handshake¬ª,    .   ¬´handshake¬ª  .    ¬´send_handshake_reply¬ª,      .   ¬´send_handshake_reply¬ª    ,   ,  ¬´ ¬ª,   ‚Äî  ,    ‚Äî  . <br><br> <b>   </b> .  ,       ,    ,      .      ¬´unparsed_data¬ª .     ¬´on_read¬ª     frame, ,  frame  ,   frame   .       -    (   ,  frame   ,       frame).   ¬´on_read¬ª,           (-   ),   ¬´on_frame¬ª,    ¬´ws¬ª, ,   ,  custom callback ( $my_callback,    ).    $my_callback    . <br><br> <b>  </b> .    ¬´send_frame¬ª,      .       .    -. <br><br>   3  ¬´v13¬ª, ¬´v0¬ª, ¬´ve¬ª: <br><br><div class="spoiler"> <b class="spoiler_title"> &lt;ws_v13.php&gt;</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ws_v13</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ws</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONTINUATION = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> STRING = <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BINARY = <span class="hljs-number"><span class="hljs-number">0x2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONNCLOSE = <span class="hljs-number"><span class="hljs-number">0x8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PING = <span class="hljs-number"><span class="hljs-number">0x9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PONG = <span class="hljs-number"><span class="hljs-number">0xA</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $opcodes = [ <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'CONTINUATION'</span></span>, <span class="hljs-number"><span class="hljs-number">0x1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'STRING'</span></span>, <span class="hljs-number"><span class="hljs-number">0x2</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'BINARY'</span></span>, <span class="hljs-number"><span class="hljs-number">0x8</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'CONNCLOSE'</span></span>, <span class="hljs-number"><span class="hljs-number">0x9</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'PING'</span></span>, <span class="hljs-number"><span class="hljs-number">0xA</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'PONG'</span></span>, ]; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $outgoingCompression = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $framebuf = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Apply mask * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> $data * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string|false $mask * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> mixed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($data, $mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>, $l = strlen($data), $ml = strlen($mask); $i &lt; $l; $i++) { $data[$i] = $data[$i] ^ $mask[$i % $ml]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $data; } <span class="hljs-comment"><span class="hljs-comment">/** * Sends a frame. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $data Frame's data. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $type Frame's type. ("STRING" OR "BINARY") * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> callable $cb Optional. Callback called when the frame is received by client. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@callback</span></span></span><span class="hljs-comment"> $cb ( ) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> boolean Success. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($data, $type = null, $cb = null)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handshaked) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;closed &amp;&amp; $type !== <span class="hljs-string"><span class="hljs-string">'CONNCLOSE'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*if (in_array($type, ['STRING', 'BINARY']) &amp;&amp; ($this-&gt;outgoingCompression &gt; 0) &amp;&amp; in_array('deflate-frame', $this-&gt;extensions)) { //$data = gzcompress($data, $this-&gt;outgoingCompression); //$rsv1 = 1; }*/</span></span> $fin = <span class="hljs-number"><span class="hljs-number">1</span></span>; $rsv1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; $rsv2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; $rsv3 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write(chr(bindec($fin . $rsv1 . $rsv2 . $rsv3 . str_pad(decbin(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;get_frame_type($type)), <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>, STR_PAD_LEFT)))); $dataLength = strlen($data); $isMasked = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $isMaskedInt = $isMasked ? <span class="hljs-number"><span class="hljs-number">128</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($dataLength &lt;= <span class="hljs-number"><span class="hljs-number">125</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write(chr($dataLength + $isMaskedInt)); } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> ($dataLength &lt;= <span class="hljs-number"><span class="hljs-number">65535</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write(chr(<span class="hljs-number"><span class="hljs-number">126</span></span> + $isMaskedInt) . <span class="hljs-comment"><span class="hljs-comment">// 126 + 128 chr($dataLength &gt;&gt; 8) . chr($dataLength &amp; 0xFF)); } else { $this-&gt;write(chr(127 + $isMaskedInt) . // 127 + 128 chr($dataLength &gt;&gt; 56) . chr($dataLength &gt;&gt; 48) . chr($dataLength &gt;&gt; 40) . chr($dataLength &gt;&gt; 32) . chr($dataLength &gt;&gt; 24) . chr($dataLength &gt;&gt; 16) . chr($dataLength &gt;&gt; 8) . chr($dataLength &amp; 0xFF)); } if ($isMasked) { $mask = chr(mt_rand(0, 0xFF)) . chr(mt_rand(0, 0xFF)) . chr(mt_rand(0, 0xFF)) . chr(mt_rand(0, 0xFF)); $this-&gt;write($mask . $this-&gt;mask($data, $mask)); } else { $this-&gt;write($data); } if ($cb !== null) { $cb(); } return true; } /** * Sends a handshake message reply * @param string Received data (no use in this class) * @return boolean OK? */ public function send_handshake_reply($extraHeaders = '') { if (!isset($this-&gt;server['HTTP_SEC_WEBSOCKET_KEY']) || !isset($this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'])) { return false; } if ($this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'] !== '13' &amp;&amp; $this-&gt;server['HTTP_SEC_WEBSOCKET_VERSION'] !== '8') { return false; } if (isset($this-&gt;server['HTTP_ORIGIN'])) { $this-&gt;server['HTTP_SEC_WEBSOCKET_ORIGIN'] = $this-&gt;server['HTTP_ORIGIN']; } if (!isset($this-&gt;server['HTTP_SEC_WEBSOCKET_ORIGIN'])) { $this-&gt;server['HTTP_SEC_WEBSOCKET_ORIGIN'] = ''; } $this-&gt;write("HTTP/1.1 101 Switching Protocols\r\n" . "Upgrade: WebSocket\r\n" . "Connection: Upgrade\r\n" . "Date: " . date('r') . "\r\n" . "Sec-WebSocket-Origin: " . $this-&gt;server['HTTP_SEC_WEBSOCKET_ORIGIN'] . "\r\n" . "Sec-WebSocket-Location: ws://" . $this-&gt;server['HTTP_HOST'] . $this-&gt;server['REQUEST_URI'] . "\r\n" . "Sec-WebSocket-Accept: " . base64_encode(sha1(trim($this-&gt;server['HTTP_SEC_WEBSOCKET_KEY']) . "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", true)) . "\r\n" ); if (isset($this-&gt;server['HTTP_SEC_WEBSOCKET_PROTOCOL'])) { $this-&gt;write("Sec-WebSocket-Protocol: " . $this-&gt;server['HTTP_SEC_WEBSOCKET_PROTOCOL']."\r\n"); } $this-&gt;write($extraHeaders."\r\n"); return true; } /** * Called when new data received * @see http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10#page-16 * @return void */ public function on_read() { if ($this-&gt;closed) return; if ($this-&gt;state === self::STATE_PREHANDSHAKE) { if (!$this-&gt;handshake()) { return; } } if ($this-&gt;state === self::STATE_HANDSHAKED) { while (($buflen = strlen($this-&gt;unparsed_data)) &gt;= 2) { $first = ord($this-&gt;look(1)); // first byte integer (fin, opcode) $firstBits = decbin($first); $opcode = (int)bindec(substr($firstBits, 4, 4)); if ($opcode === 0x8) { // CLOSE $this-&gt;close(); return; } $opcodeName = isset(static::$opcodes[$opcode]) ? static::$opcodes[$opcode] : false; if (!$opcodeName) { error_log(get_class($this) . ': Undefined opcode ' . $opcode); $this-&gt;close(); return; } $second = ord($this-&gt;look(1, 1)); // second byte integer (masked, payload length) $fin = (bool)($first &gt;&gt; 7); $isMasked = (bool)($second &gt;&gt; 7); $dataLength = $second &amp; 0x7f; $p = 2; if ($dataLength === 0x7e) { // 2 bytes-length if ($buflen &lt; $p + 2) { return; // not enough data yet } $dataLength = self::bytes2int($this-&gt;look(2, $p), false); $p += 2; } elseif ($dataLength === 0x7f) { // 8 bytes-length if ($buflen &lt; $p + 8) { return; // not enough data yet } $dataLength = self::bytes2int($this-&gt;look(8, $p)); $p += 8; } if (self::maxAllowedPacket &lt;= $dataLength) { // Too big packet $this-&gt;close(); return; } if ($isMasked) { if ($buflen &lt; $p + 4) { return; // not enough data yet } $mask = $this-&gt;look(4, $p); $p += 4; } if ($buflen &lt; $p + $dataLength) { return; // not enough data yet } $this-&gt;drain($p); $data = $this-&gt;read($dataLength); if ($isMasked) { $data = $this-&gt;mask($data, $mask); } //Daemon::log(De</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">bug:</span></span></span><span class="hljs-comment">:dump(array('ext' =&gt; $this-&gt;extensions, 'rsv1' =&gt; $firstBits[1], 'data' =&gt; De</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">bug:</span></span></span><span class="hljs-comment">:exportBytes($data)))); /*if ($firstBits[1] &amp;&amp; in_array('deflate-frame', $this-&gt;extensions)) { // deflate frame $data = gzuncompress($data, $this-&gt;pool-&gt;maxAllowedPacket); }*/ if (!$fin) { $this-&gt;framebuf .= $data; } else { $this-&gt;on_frame($this-&gt;framebuf . $data, $opcodeName); $this-&gt;framebuf = ''; } } } } }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"> &lt;ws_v0.php&gt;</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ws_v0</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ws</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> STRING = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BINARY = <span class="hljs-number"><span class="hljs-number">0x80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $key; <span class="hljs-comment"><span class="hljs-comment">/** * Sends a handshake message reply * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string Received data (no use in this class) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> boolean OK? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_handshake_reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($extraHeaders = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_KEY1'</span></span>]) || !<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_KEY2'</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } $final_key = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_computeFinalKey(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_KEY1'</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_KEY2'</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;key); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;key = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$final_key) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_ORIGIN'</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_ORIGIN'</span></span>] = <span class="hljs-string"><span class="hljs-string">''</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write(<span class="hljs-string"><span class="hljs-string">"HTTP/1.1 101 Web Socket Protocol Handshake\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Upgrade: WebSocket\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Connection: Upgrade\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Sec-WebSocket-Origin: "</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_ORIGIN'</span></span>] . <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Sec-WebSocket-Location: ws://"</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span>] . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'REQUEST_URI'</span></span>] . <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_PROTOCOL'</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write(<span class="hljs-string"><span class="hljs-string">"Sec-WebSocket-Protocol: "</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_PROTOCOL'</span></span>].<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write($extraHeaders . <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span> . $final_key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * Computes final key for Sec-WebSocket. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string Key1 * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string Key2 * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string Data * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string Result */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_computeFinalKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key1, $key2, $data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strlen($data) &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) { error_log(get_class(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>) . <span class="hljs-string"><span class="hljs-string">'::'</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">__METHOD__</span></span> . <span class="hljs-string"><span class="hljs-string">' : Invalid handshake data for client ""'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $this-&gt;addr return false; } return md5($this-&gt;_computeKey($key1) . $this-&gt;_computeKey($key2) . substr($data, 0, 8), true); } /** * Computes key for Sec-WebSocket. * @param string Key * @return string Result */ protected function _computeKey($key) { $spaces = 0; $digits = ''; for ($i = 0, $s = strlen($key); $i &lt; $s; ++$i) { $c = substr($key, $i, 1); if ($c === "\x20") { ++$spaces; } elseif (ctype_digit($c)) { $digits .= $c; } } if ($spaces &gt; 0) { $result = (float)floor($digits / $spaces); } else { $result = (float)$digits; } return pack('N', $result); } /** * Sends a frame. * @param string $data Frame's data. * @param string $type Frame's type. ("STRING" OR "BINARY") * @param callable $cb Optional. Callback called when the frame is received by client. * @callback $cb ( ) * @return boolean Success. */ public function send_frame($data, $type = null, $cb = null) { if (!$this-&gt;handshaked) { return false; } if ($this-&gt;closed &amp;&amp; $type !== 'CONNCLOSE') { return false; } if ($type === 'CONNCLOSE') { if ($cb !== null) { $cb($this); return true; } } $type = $this-&gt;get_frame_type($type); // Binary if (($type &amp; self::BINARY) === self::BINARY) { $n = strlen($data); $len = ''; $pos = 0; char: ++$pos; $c = $n &gt;&gt; 0 &amp; 0x7F; $n &gt;&gt;= 7; if ($pos !== 1) { $c += 0x80; } if ($c !== 0x80) { $len = chr($c) . $len; goto char; }; $this-&gt;write(chr(self::BINARY) . $len . $data); } // String else { $this-&gt;write(chr(self::STRING) . $data . "\xFF"); } if ($cb !== null) { $cb(); } return true; } /** * Called when new data received * @return void */ public function on_read() { if ($this-&gt;state === self::STATE_PREHANDSHAKE) { if (strlen($this-&gt;unparsed_data) &lt; 8) { return; } $this-&gt;key = $this-&gt;read_unlimited(); $this-&gt;handshake(); } if ($this-&gt;state === self::STATE_HANDSHAKED) { while (($buflen = strlen($this-&gt;unparsed_data)) &gt;= 2) { $hdr = $this-&gt;look(10); $frametype = ord(substr($hdr, 0, 1)); if (($frametype &amp; 0x80) === 0x80) { $len = 0; $i = 0; do { if ($buflen &lt; $i + 1) { // not enough data yet return; } $b = ord(substr($hdr, ++$i, 1)); $n = $b &amp; 0x7F; $len *= 0x80; $len += $n; } while ($b &gt; 0x80); if (self::maxAllowedPacket &lt;= $len) { // Too big packet $this-&gt;close(); return; } if ($buflen &lt; $len + $i + 1) { // not enough data yet return; } $this-&gt;drain($i + 1); $this-&gt;on_frame($this-&gt;read($len), 'BINARY'); } else { if (($p = $this-&gt;search("\xFF")) !== false) { if (self::maxAllowedPacket &lt;= $p - 1) { // Too big packet $this-&gt;close(); return; } $this-&gt;drain(1); $data = $this-&gt;read($p); $this-&gt;drain(1); $this-&gt;on_frame($data, 'STRING'); } else { if (self::maxAllowedPacket &lt; $buflen - 1) { // Too big packet $this-&gt;close(); return; } // not enough data yet return; } } } } } }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"> &lt;ws_ve.php&gt;</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ws_ve</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ws</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> STRING = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BINARY = <span class="hljs-number"><span class="hljs-number">0x80</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Sends a handshake message reply * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string Received data (no use in this class) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> boolean OK? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_handshake_reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($extraHeaders = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_ORIGIN'</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_ORIGIN'</span></span>] = <span class="hljs-string"><span class="hljs-string">''</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write(<span class="hljs-string"><span class="hljs-string">"HTTP/1.1 101 Web Socket Protocol Handshake\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Upgrade: WebSocket\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Connection: Upgrade\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Sec-WebSocket-Origin: "</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_ORIGIN'</span></span>] . <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span> . <span class="hljs-string"><span class="hljs-string">"Sec-WebSocket-Location: ws://"</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_HOST'</span></span>] . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'REQUEST_URI'</span></span>] . <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_PROTOCOL'</span></span>])) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write(<span class="hljs-string"><span class="hljs-string">"Sec-WebSocket-Protocol: "</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;server[<span class="hljs-string"><span class="hljs-string">'HTTP_SEC_WEBSOCKET_PROTOCOL'</span></span>].<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;write($extraHeaders.<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * Computes key for Sec-WebSocket. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string Key * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string Result */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_computeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($key)</span></span></span><span class="hljs-function"> </span></span>{ $spaces = <span class="hljs-number"><span class="hljs-number">0</span></span>; $digits = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>, $s = strlen($key); $i &lt; $s; ++$i) { $c = substr($key, $i, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($c === <span class="hljs-string"><span class="hljs-string">"\x20"</span></span>) { ++$spaces; } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> (ctype_digit($c)) { $digits .= $c; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($spaces &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = (float)floor($digits / $spaces); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = (float)$digits; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'N'</span></span>, $result); } <span class="hljs-comment"><span class="hljs-comment">/** * Sends a frame. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $data Frame's data. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $type Frame's type. ("STRING" OR "BINARY") * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> callable $cb Optional. Callback called when the frame is received by client. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@callback</span></span></span><span class="hljs-comment"> $cb ( ) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> boolean Success. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($data, $type = null, $cb = null)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handshaked) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;closed &amp;&amp; $type !== <span class="hljs-string"><span class="hljs-string">'CONNCLOSE'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($type === <span class="hljs-string"><span class="hljs-string">'CONNCLOSE'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($cb !== <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { $cb(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// Binary $type = $this-&gt;get_frame_type($type); if (($type &amp; self::BINARY) === self::BINARY) { $n = strlen($data); $len = ''; $pos = 0; char: ++$pos; $c = $n &gt;&gt; 0 &amp; 0x7F; $n &gt;&gt;= 7; if ($pos !== 1) { $c += 0x80; } if ($c !== 0x80) { $len = chr($c) . $len; goto char; }; $this-&gt;write(chr(self::BINARY) . $len . $data); } // String else { $this-&gt;write(chr(self::STRING) . $data . "\xFF"); } if ($cb !== null) { $cb(); } return true; } /** * Called when new data received * @return void */ public function on_read() { while (($buflen = strlen($this-&gt;unparsed_data)) &gt;= 2) { $hdr = $this-&gt;look(10); $frametype = ord(substr($hdr, 0, 1)); if (($frametype &amp; 0x80) === 0x80) { $len = 0; $i = 0; do { if ($buflen &lt; $i + 1) { return; } $b = ord(substr($hdr, ++$i, 1)); $n = $b &amp; 0x7F; $len *= 0x80; $len += $n; } while ($b &gt; 0x80); if (self::maxAllowedPacket &lt;= $len) { // Too big packet $this-&gt;close(); return; } if ($buflen &lt; $len + $i + 1) { // not enough data yet return; } $this-&gt;drain($i + 1); $this-&gt;on_frame($this-&gt;read($len), $frametype); } else { if (($p = $this-&gt;search("\xFF")) !== false) { if (self::maxAllowedPacket &lt;= $p - 1) { // Too big packet $this-&gt;close(); return; } $this-&gt;drain(1); $data = $this-&gt;read($p); $this-&gt;drain(1); $this-&gt;on_frame($data, 'STRING'); } else { if (self::maxAllowedPacket &lt; $buflen - 1) { // Too big packet $this-&gt;close(); return; } } } } } }</span></span></code> </pre><br></div></div><br>   ,   VE   ‚Äî      .        PhpDeamon. <br><br>  V13     (FireFox, Opera, Chrome, ).  IE   (,  IE6 ‚Äî   IE    ¬´¬ª,    IE ,   ¬´ ,   ¬ª).  V0   ¬´¬ª. <br><br><h4>  Instead of conclusion </h4><br>   ,        (,       ,      .  callback     frame   -).      ,   -   ¬´ Anlide  PhpDeamon¬ª.    ,  ,     .           . <br><br> <b></b> : <br><ul><li>   ,       : <a href="https://habrahabr.ru/post/301822/">habrahabr.ru/post/301822/#comment_9634636</a> </li><li>  read_lint()   ‚Äî      http ,      . </li><li>     ‚Äî       . </li><li>       gitbub <a href="https://github.com/anlide/websocket">github.com/anlide/websocket</a>      ping-pong ,         select  - ‚Äî         websocket. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/301822/">https://habr.com/ru/post/301822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301810/index.html">Squeezing gigabits: or undocumented ViPNet Client / Coordinator feature</a></li>
<li><a href="../301812/index.html">We test the project on SaltStack using KitchenCI</a></li>
<li><a href="../301814/index.html">How to choose ITshnika in Russia: myth number 2, number 3</a></li>
<li><a href="../301816/index.html">Are the "top" sites safe: exploring Alexa ranking</a></li>
<li><a href="../301820/index.html">Postgres in Chinese or setting Full Text Search in Postgres for Chinese</a></li>
<li><a href="../301826/index.html">Dropbox explained why it is embedded in the operating system kernel</a></li>
<li><a href="../301828/index.html">DevConf :: Hackathon by Yii at TASS June 18-19, 2016</a></li>
<li><a href="../301830/index.html">Using the ceiling clock as an information board</a></li>
<li><a href="../301834/index.html">Semantic gap "The Semantic Gap"</a></li>
<li><a href="../301836/index.html">A piece of space in your pocket: the results of the experiment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>