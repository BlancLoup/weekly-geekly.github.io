<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating audio plugin, part 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All posts series: 
 Part 1. Introduction and setup 
 Part 2. Learning Code 
 Part 3. VST and AU 
 Part 4. Digital Distortion 
 Part 5. Presets and GUI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating audio plugin, part 7</h1><div class="post__text post__text-html js-mediator-article">  All posts series: <br>  <a href="http://habrahabr.ru/post/224911/">Part 1. Introduction and setup</a> <br>  <a href="http://habrahabr.ru/post/225019/">Part 2. Learning Code</a> <br>  <a href="http://habrahabr.ru/post/225457/">Part 3. VST and AU</a> <br>  <a href="http://habrahabr.ru/post/225751/">Part 4. Digital Distortion</a> <br>  <a href="http://habrahabr.ru/post/225755/">Part 5. Presets and GUI</a> <br>  <a href="http://habrahabr.ru/post/226439/">Part 6. Signal synthesis</a> <br>  <a href="http://habrahabr.ru/post/226573/">Part 7. Receive MIDI Messages</a> <br>  <a href="http://habrahabr.ru/post/226823/">Part 8. Virtual Keyboard</a> <br>  <a href="http://habrahabr.ru/post/227475/">Part 9. Envelopes</a> <br>  <a href="http://habrahabr.ru/post/227601/">Part 10. Refinement GUI</a> <br>  <a href="http://habrahabr.ru/post/227791/">Part 11. Filter</a> <br>  <a href="http://habrahabr.ru/post/227827/">Part 12. Low-frequency oscillator</a> <br>  <a href="http://habrahabr.ru/post/228267/">Part 13. Redesign</a> <br>  <a href="http://habrahabr.ru/post/231513/">Part 14. Polyphony 1</a> <br>  <a href="http://habrahabr.ru/post/231923/">Part 15. Polyphony 2</a> <br>  <a href="http://habrahabr.ru/post/232153/">Part 16. Antialiasing</a> <br><hr><br><br>  So far, we have generated only a constant sound wave, which simply sounded at a given frequency.  Let's take a look at how you can respond to MIDI messages, turn the wave generation on and off at the desired frequency, depending on the note being received. <br><a name="habracut"></a><br><h2>  Receive MIDI messages </h2><br><br><h3>  MIDI Processing Basics </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When a plugin is loaded into a host, it receives all MIDI messages from the track to which it is hooked.  When a note starts and ends, the <code>ProcessMidiMsg</code> function is called in the plugin.  In addition to the note in MIDI messages, information about portamento (Pitch Bend) and control commands ( <a href="http://en.wikipedia.org/wiki/General_MIDI">Control Changes</a> , abbreviated CC) can be transmitted, which can be used to automate plug-in parameters.  The <code>ProcessMidiMsg</code> function is passed an <code>IMidiMsg</code> message that describes the MIDI event in its format-independent form.  This description contains the parameters <code>NoteNumber</code> and <code>Velocity</code> , which contain information about the pitch of the sound of our oscillator. <br><br>  Each time a MIDI message arrives, the system already plays the audio buffer that was previously filled.  There is no way to cram new audio at the exact moment a MIDI message is received.  These events must be memorized until the next call to the <code>ProcessDoubleReplacing</code> function.  You also need to remember the time of receipt of the message, so we will leave this information intact for the next filling of the buffer. <br><br>  <a href="">IMidiQueue</a> will serve as a tool for these tasks. <br><br><h3>  MIDI receiver </h3><br><br>  We will use our project <i>Synthesis</i> .  If you are using a version control system, it's time to commit the project.  Create a new <i>MIDIReceiver</i> class and check that <i>.cpp</i> compiles in each target.  In <i>MIDIReceiver.h,</i> insert the interface between <code>#define</code> and <code>#endif</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> clang diagnostic push #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> clang diagnostic ignored </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"-Wextra-tokens"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IPlug_include_in_plug_hdr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> clang diagnostic pop #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IMidiQueue.h"</span></span></span><span class="hljs-meta"> class MIDIReceiver { private: IMidiQueue mMidiQueue; static const int keyCount = 128; int mNumKeys; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// how many keys are being played at the moment (via midi) bool mKeyStatus[keyCount]; // array of on/off for each key (index is note number) int mLastNoteNumber; double mLastFrequency; int mLastVelocity; int mOffset; inline double noteNumberToFrequency(int noteNumber) { return 440.0 * pow(2.0, (noteNumber - 69.0) / 12.0); } public: MIDIReceiver() : mNumKeys(0), mLastNoteNumber(-1), mLastFrequency(-1.0), mLastVelocity(0), mOffset(0) { for (int i = 0; i &lt; keyCount; i++) { mKeyStatus[i] = false; } }; // Returns true if the key with a given index is currently pressed inline bool getKeyStatus(int keyIndex) const { return mKeyStatus[keyIndex]; } // Returns the number of keys currently pressed inline int getNumKeys() const { return mNumKeys; } // Returns the last pressed note number inline int getLastNoteNumber() const { return mLastNoteNumber; } inline double getLastFrequency() const { return mLastFrequency; } inline int getLastVelocity() const { return mLastVelocity; } void advance(); void onMessageReceived(IMidiMsg* midiMessage); inline void Flush(int nFrames) { mMidiQueue.Flush(nFrames); mOffset = 0; } inline void Resize(int blockSize) { mMidiQueue.Resize(blockSize); } };</span></span></span></span></code> </pre><br><br>  Here we need to enable <i>IPlug_include_in_plug_hdr.h</i> , because otherwise <i>IMidiQueue.h</i> will create errors. <br>  As you can see, we have a <code>private</code> <code>IMidiQueue</code> object for storing a queue of MIDI messages.  We also store information about what notes are being played and how many of them are being played.  Three parameters <code>mLast...</code> are needed, <code>mLast...</code> our plugin will be monophonic: each next note will drown out the previous ones (the so-called <a href="http://www.soundonsound.com/sos/oct00/articles/synthsec.htm">priority of the last note</a> ).  The <code>noteNumberToFrequency</code> function converts a MIDI note number to a frequency in Hertz.  We use it because the <code>Oscillator</code> class works with a frequency, not a note number. <br>  The <code>public</code> section contains a number of <code>inline</code> getters and sends <code>Flush</code> and <code>Resize</code> to the <code>mMidiQueue</code> . <br>  In the <code>Flush</code> body, we set <code>mOffset</code> to zero.  Calling <code>mMidiQueue.Flush(nFrames)</code> means that we remove its part from the <code>nFrames</code> of the queue with the size of <code>nFrames</code> , since we have already processed the events of this part in the previous call to the <code>advance</code> function.  Resetting <code>mOffset</code> ensures that the next time during the <code>advance</code> we will also process the beginning of the queue.  The words <code>const</code> , after parentheses, mean that the function <a href="http://stackoverflow.com/a/5598730/966567">will not change the immutable members of its class</a> . <br><br>  Let's add the implementation of <code>onMessageReceived</code> in <i>MIDIReceiver.cpp</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MIDIReceiver::onMessageReceived(IMidiMsg* midiMessage) { IMidiMsg::EStatusMsg status = midiMessage-&gt;StatusMsg(); <span class="hljs-comment"><span class="hljs-comment">// We're only interested in Note On/Off messages (not CC, pitch, etc.) if(status == IMidiMsg::kNoteOn || status == IMidiMsg::kNoteOff) { mMidiQueue.Add(midiMessage); } }</span></span></code> </pre><br><br>  This function is called each time a MIDI message is received.  We are currently only interested in <i>note on</i> and <i>note off</i> messages (start / stop playing a note), and we add them to the <code>mMidiQueue</code> . <br>  The next interesting feature is <code>advance</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MIDIReceiver::advance() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!mMidiQueue.Empty()) { IMidiMsg* midiMessage = mMidiQueue.Peek(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (midiMessage-&gt;mOffset &gt; mOffset) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; IMidiMsg::EStatusMsg status = midiMessage-&gt;StatusMsg(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> noteNumber = midiMessage-&gt;NoteNumber(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> velocity = midiMessage-&gt;Velocity(); <span class="hljs-comment"><span class="hljs-comment">// There are only note on/off messages in the queue, see ::OnMessageReceived if (status == IMidiMsg::kNoteOn &amp;&amp; velocity) { if(mKeyStatus[noteNumber] == false) { mKeyStatus[noteNumber] = true; mNumKeys += 1; } // A key pressed later overrides any previously pressed key: if (noteNumber != mLastNoteNumber) { mLastNoteNumber = noteNumber; mLastFrequency = noteNumberToFrequency(mLastNoteNumber); mLastVelocity = velocity; } } else { if(mKeyStatus[noteNumber] == true) { mKeyStatus[noteNumber] = false; mNumKeys -= 1; } // If the last note was released, nothing should play: if (noteNumber == mLastNoteNumber) { mLastNoteNumber = -1; mLastFrequency = -1; mLastVelocity = 0; } } mMidiQueue.Remove(); } mOffset++; }</span></span></code> </pre><br><br>  This function is called <i>every sample</i> until the audio buffer is filled.  While there are messages in the queue, we process them and remove them from the beginning (using <code>Peek</code> and <code>Remove</code> ).  But we do this only for those MIDI messages whose offset ( <code>mOffset</code> ) is no larger than the buffer offset.  This means that we process each message in the corresponding sample, leaving relative time shifts intact. <br>  After reading the <code>noteNumber</code> and <code>Velocity</code> values, the conditional <code>if</code> separates the <i>note on</i> and <i>note off</i> messages (the absence of a velocity value is interpreted as <i>note off</i> ).  In both cases, we keep track of which notes are played and how many of them are at the moment.  The values ‚Äã‚Äãfor <code>mLast...</code> are also updated <code>mLast...</code> to fulfill the priority of the last note.  Further, it is logical that the frequency of the sound should be updated here, which is what we are doing.  At the very end, <code>mOffset</code> updated so that the recipient knows how far this message is in the buffer at the moment.  This can be reported to the recipient in another way - by passing the offset as an argument. <br>  So, we have a class that receives all incoming MIDI messages note on / off.  It keeps track of which notes are being played, which is the last note and what is its frequency.  Let's use it. <br><br><h3>  Using a MIDI receiver </h3><br><br>  First, make these changes to <i>resource.h</i> carefully: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// #define PLUG_CHANNEL_IO "1-1 2-2" #if (defined(AAX_API) || defined(RTAS_API)) #define PLUG_CHANNEL_IO "1-1 2-2" #else // no audio input. mono or stereo output #define PLUG_CHANNEL_IO "0-1 0-2" #endif // ... #define PLUG_IS_INST 1 // ... #define EFFECT_TYPE_VST3 "Instrument|Synth" // ... #define PLUG_DOES_MIDI 1</span></span></code> </pre><br><br>  These lines inform the host that our plugin ‚Äúcan midi‚Äù.  <code>0-1</code> and <code>0-2</code> indicate that the plug-in has no audio input and there is one output, i.e.  mono ( <code>0-1</code> ), or it has no audio inputs and there is a stereo output ( <code>0-2</code> ). <br>  Now add <code>#include "MIDIReceiver.h"</code> after <code>Oscillator.h</code> to <i>Synthesis.h</i> .  In the same section, in the <code>public</code> section, add a member function declaration: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// to receive MIDI messages: void ProcessMidiMsg(IMidiMsg* pMsg);</span></span></code> </pre><br><br>  Add a <code>MIDIReceiver</code> object in the <code>private</code> section: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... MIDIReceiver mMIDIReceiver;</span></span></code> </pre><br><br>  In <i>Synthesis.cpp,</i> write this simple function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Synthesis::ProcessMidiMsg(IMidiMsg* pMsg) { mMIDIReceiver.onMessageReceived(pMsg); }</code> </pre><br><br>  It is called each time a MIDI message is received, and we transmit the message to our receiver. <br>  Let's put things in order now a little.  Edit both <code>enums</code> at the top: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EParams { kNumParams }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELayout { kWidth = GUI_WIDTH, kHeight = GUI_HEIGHT };</code> </pre><br><br>  And create only one default preset: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Synthesis::CreatePresets() { MakeDefaultPreset((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) <span class="hljs-string"><span class="hljs-string">"-"</span></span>, kNumPrograms); }</code> </pre><br><br>  If you change the parameters of the plugin, do nothing <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Synthesis::OnParamChange(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> paramIdx) { <span class="hljs-function"><span class="hljs-function">IMutexLock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }</code> </pre><br><br>  The handle in the interface is no longer useful to us.  Let's reduce the constructor to the minimum necessary: <br><br><pre> <code class="cpp hljs">Synthesis::Synthesis(IPlugInstanceInfo instanceInfo) : IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo) { TRACE; IGraphics* pGraphics = MakeGraphics(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, kWidth, kHeight); pGraphics-&gt;AttachPanelBackground(&amp;COLOR_RED); AttachGraphics(pGraphics); CreatePresets(); }</code> </pre><br><br>  When the sound settings in the system change, we need to tell the oscillator a new sampling frequency: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Synthesis::Reset() { TRACE; <span class="hljs-function"><span class="hljs-function">IMutexLock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; mOscillator.setSampleRate(GetSampleRate()); }</code> </pre><br><br>  We still have the <code>ProcessDoubleReplacing</code> function.  Consider: <code>mMIDIReceiver.advance()</code> each sample needs to be executed.  After that, we will know the frequency and volume with <code>getLastVelocity</code> and <code>getLastFrequency</code> from the MIDI receiver.  Then we call <code>mOscillator.setFrequency()</code> and <code>mOscillator.generate()</code> to fill the audio buffer with the sound of the desired frequency. <br>  The <code>generate</code> function was created to handle the entire buffer;  The MIDI receiver works at the level of an individual sample: messages can have any offset within the buffer, which means <code>mLastFrequency</code> can change on any sample.  We'll have to refine the <code>Oscillator</code> class so that it also works at the sample level. <br><br>  First, we <code>twoPI</code> out <code>twoPI</code> from <code>generate</code> and move the <i>Oscillator.h</i> section to <code>private</code> .  While we are here, let's immediately add the linden <code>bool</code> variable to indicate whether the oscillator is muted (that is, not a single note is played): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> twoPI; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isMuted;</code> </pre><br><br>  We initialize them by adding a constructor to the initialization list.  So it looks like: <br><br><pre> <code class="cpp hljs">Oscillator() : mOscillatorMode(OSCILLATOR_MODE_SINE), mPI(<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">acos</span></span>(<span class="hljs-number"><span class="hljs-number">0.0</span></span>)), twoPI(<span class="hljs-number"><span class="hljs-number">2</span></span> * mPI), <span class="hljs-comment"><span class="hljs-comment">// This line is new isMuted(true), // And this line mFrequency(440.0), mPhase(0.0), mSampleRate(44100.0) { updateIncrement(); };</span></span></code> </pre><br><br>  Add the inline setter to the public section: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMuted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> muted)</span></span></span><span class="hljs-function"> </span></span>{ isMuted = muted; }</code> </pre><br><br>  And immediately below this paste the following line: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextSample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br><br>  We will call this function each sample and receive audio data from the oscillator. <br>  Add the following code to <i>Oscilator.cpp</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Oscillator::nextSample() { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isMuted) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (mOscillatorMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OSCILLATOR_MODE_SINE: value = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(mPhase); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OSCILLATOR_MODE_SAW: value = <span class="hljs-number"><span class="hljs-number">1.0</span></span> - (<span class="hljs-number"><span class="hljs-number">2.0</span></span> * mPhase / twoPI); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OSCILLATOR_MODE_SQUARE: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPhase &lt;= mPI) { value = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value = <span class="hljs-number"><span class="hljs-number">-1.0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OSCILLATOR_MODE_TRIANGLE: value = <span class="hljs-number"><span class="hljs-number">-1.0</span></span> + (<span class="hljs-number"><span class="hljs-number">2.0</span></span> * mPhase / twoPI); value = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * (<span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(value) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } mPhase += mPhaseIncrement; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (mPhase &gt;= twoPI) { mPhase -= twoPI; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre><br><br>  As you can see, <code>twoPI</code> used <code>twoPI</code> .  It would be redundant to calculate this value for each sample, so we added two pi as a constant to the class. <br>  When the oscillator does not generate anything, we return zero.  The <code>switch</code> construction is already familiar to you, even though we don‚Äôt use a <code>for</code> loop.  Here we simply generate one value for the buffer, instead of filling it in its entirety.  Also, this structure allows us to move the phase increment to the end, avoiding repetition. <br>  This was a good example of refactoring, caused by insufficient code flexibility.  Of course, we could think for an hour or two before starting to write the <code>generate</code> function with a ‚Äúbuffer‚Äù approach.  But this implementation took us less than an hour entirely.  In simple applications (like this) it is sometimes more efficient to implement an approach and see how the code handles the task in practice.  Most often, as we just saw, it turns out that the whole idea was correct (the principle of calculating different sound waves), but some aspect of the problem was missed.  On the other hand, if you are developing a public API, then changing something later is, to put it mildly, inconvenient, so here you have to think about everything in advance.  In general, it depends on the situation. <br><br>  The <code>setFrequency</code> function <code>setFrequency</code> also be called every sample.  So <code>updateIncrement</code> will also be called very often.  But it is not yet optimized: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Oscillator::updateIncrement() { mPhaseIncrement = mFrequency * <span class="hljs-number"><span class="hljs-number">2</span></span> * mPI / mSampleRate; }</code> </pre><br><br>  <code>2 * mPI * mSampleRate</code> changes only when the sample rate changes.  So the result of this calculation is better to remember and recalculate it only inside <code>Oscillator::setSampleRate</code> .  It is worth remembering that exorbitant optimization can make the code unreadable and even ugly.  In the specific case, we will not have performance problems, since we are writing an elementary monophonic synth.  When we get to polyphony, it will be another matter, and then we will definitely optimize. <br>  Now we can rewrite <code>ProcessDoubleReplacing</code> in <i>Synthesis.cpp</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Synthesis::ProcessDoubleReplacing( <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>** inputs, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>** outputs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nFrames) { <span class="hljs-comment"><span class="hljs-comment">// Mutex is already locked for us. double *leftOutput = outputs[0]; double *rightOutput = outputs[1]; for (int i = 0; i &lt; nFrames; ++i) { mMIDIReceiver.advance(); int velocity = mMIDIReceiver.getLastVelocity(); if (velocity &gt; 0) { mOscillator.setFrequency(mMIDIReceiver.getLastFrequency()); mOscillator.setMuted(false); } else { mOscillator.setMuted(true); } leftOutput[i] = rightOutput[i] = mOscillator.nextSample() * velocity / 127.0; } mMIDIReceiver.Flush(nFrames); }</span></span></code> </pre><br><br>  In the for loop, the MIDI receiver first updates the values ‚Äã‚Äã(called <code>advance</code> ).  If a note sounds ( <code>velocity &gt; 0</code> ), we update the oscillator frequency and let it sound.  Otherwise we drown it (then <code>nextSample</code> will return zeros). <br>  Then it all comes down simply to calling <code>nextSample</code> to get the value, change the volume ( <code>velocity</code> is an integer between <code>0</code> and <code>127</code> ) and write the result to the output buffers.  At the end, <code>Flush</code> is called to remove the start of the queue. <br><br><h3>  Tests </h3><br><br>  Run VST or AU.  If the AU does not appear in the host, then you may have to change the <code>PLUG_UNIQUE_ID</code> in <i>resource.h</i> .  If two plugins have the same ID, the host will ignore everything except one. <br>  The plugin must submit some MIDI data to the input.  The easiest way is to use the REAPER virtual keyboard ( <i>View ‚Üí Virtual MIDI Keyboard</i> menu).  On the track with the plugin on the left there is a round red button.  Go to the MIDI configuration by right-clicking on it and select to receive messages from the virtual keyboard: <br><br><br><br>  In the same menu, turn on the <i>Monitor Input</i> .  Now that the <i>focus is on the virtual keyboard window</i> , you can play the synthesizer with a regular keyboard.  Type your name or password from the password manager and listen to how it sounds. <br>  If you have a MIDI keyboard, then by connecting it, you can also test an independent application.  The main thing is to choose the right MIDI input.  If no sound is heard, try removing <i>~ / Library / Application Support / Synthesis / settings.ini</i> . <br><br>  The whole project at this stage can be downloaded <a href="">from here</a> . <br><br>  Next time we will add a nice keyboard to the interface :) <br><br>  Original article: <br>  <a href="http://martin-finke.de/blog/articles/audio-plugins-009-receiving-midi/">martin-finke.de/blog/articles/audio-plugins-009-receiving-midi</a> </div><p>Source: <a href="https://habr.com/ru/post/226573/">https://habr.com/ru/post/226573/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226559/index.html">Java Multi-Threading Labs: Parallel Copy</a></li>
<li><a href="../226561/index.html">Everyone is equal, but some are more equal or is it possible to spam on Google Play</a></li>
<li><a href="../226563/index.html">MultiCAD.NET API: Saving non-graphic information in .dwg-drawings</a></li>
<li><a href="../226565/index.html">Textbook on programming language D. Part 2</a></li>
<li><a href="../226571/index.html">The story of creating a world map for the game ‚ÄúC & C Tiberium Alliances‚Äù. Postmortem</a></li>
<li><a href="../226575/index.html">Siemens SGold: I / O sniffer</a></li>
<li><a href="../226581/index.html">‚ÄúIt still works!‚Äù: As two friends accidentally made a 3d revolution, inventing a doodler</a></li>
<li><a href="../226585/index.html">Posting a group of pictures with text using Vkontakte API</a></li>
<li><a href="../226591/index.html">Filmstrips on the barrel organ: rakes, cones and pitfalls</a></li>
<li><a href="../226593/index.html">OpenSSL CCS Vulnerability</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>