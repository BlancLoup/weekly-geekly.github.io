<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Almost everything you wanted to know about the floating point in ARM, but were afraid to ask</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! In this article I want to tell you about the work with a floating point for processors with ARM architecture. I think this article will be u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Almost everything you wanted to know about the floating point in ARM, but were afraid to ask</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/uz/l3/0w/uzl30wgy6ecwi5eg7gmrtrdbzd4.jpeg" align="right" width="320">  Hi, Habr!  In this article I want to tell you about the work with a floating point for processors with ARM architecture.  I think this article will be useful primarily for those who are porting their OS to the ARM architecture and at the same time they need hardware floating point support (which we did for <a href="https://github.com/embox/embox">Embox</a> , which previously used the software implementation of floating point operations). <br><br>  So let's get started. <br><a name="habracut"></a><br><h2>  Compiler flags </h2><br>  To support floating point, you must pass the correct flags to the compiler.  A quick <a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html">googling</a> leads us to believe that two options are especially important: -mfloat-abi and -mfpu.  The -mfloat-abi option sets the floating point <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D1%2584%25D0%25B5%25D0%25B9%25D1%2581_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">ABI</a> and can be one of three values: 'soft', 'softfp' and 'hard'.  The 'soft' option, as the name implies, tells the compiler to use the built-in function calls for floating-point software (this option was used before).  The remaining two 'softfp' and 'hard' will be discussed a little later, after considering the option -mfpu. <br><br><h2>  -Mfpu flag and VFP version </h2><br>  The -mfpu option, as written in the <a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html">gcc online documentation</a> , allows you to specify the type of hardware and can accept the following options: <br><blockquote>  'auto', 'vfpv2', 'vfpv3', 'vfpv3-fp16', 'vfpv3-d16', 'vfpv3-d16-fp16', 'vfpv3xd', 'vfpv3xd-fp16', 'neon-vfpv3', 'neon -fp16 ',' vfpv4 ',' vfpv4-d16 ',' fpv4-sp-d16 ',' neon-vfpv4 ',' fpv5-d16 ',' fpv5-sp-d16 ',' fp-armv8 ',' neon -fp-armv8 'and' crypto-neon-fp-armv8 '.  Moreover, 'neon' is the same as 'neon-vfpv3', and 'vfp' is 'vfpv2'. </blockquote>  My compiler (arm-none-eabi-gcc (15: 5.4.1 + svn241155-1) 5.4.1 20160919) produces a slightly different list, but this does not change the essence of the matter.  In any case, we need to understand how this or that flag affects the compiler, and of course, which flag should be used. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I started to figure out the imx6 processor-based platform, but let us postpone it for a short time, since the neon co-processor has features that I will discuss later, and start with a simpler case - with the <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0159b/Cegeadbj.html">integrator / cp</a> platform, <br>  I do not have the board itself, so debugging was done on the qemu emulator.  In qemu, the Interator / cp platform is based on the <a href="https://wiki.qemu.org/Documentation/Platforms/ARM">ARM926EJ-S</a> processor, which in turn supports the <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0287b/i1019986.html">VFP9-S</a> co <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0287b/i1019986.html">-</a> processor.  This coprocessor complies with the Vector Floating-point Architecture version 2 (VFPv2) standard.  Accordingly, you need to put -mfpu = vfpv2, but in the list of options of my compiler, there was no such option.  On the <a href="https://www.linuxquestions.org/questions/linux-embedded-and-single-board-computer-78/compiling-hello-world-c-program-for-arm-arm926ej-s-rev-5-v5l-with-arm-linux-gnueabi-4175457470/">Internet,</a> I met the version of the compilation with the flags -mcpu = arm926ej-s -mfpu = vfpv3-d16, set, and I compiled everything.  At startup, I received an <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0222b/ch02s09s09.html">exception undefined instruction</a> , which was predictable, because the coprocessor was <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0240b/ch05s11s04.html">turned off</a> . <br><br>  In order to enable the coprocessor to work, you need to set the EN bit [30] in the <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0238c/CCDHCFGA.html">FPEXC</a> register.  This is done using the VMSR command. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Enable FPU extensions */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"VMSR FPEXC, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">);</span></span></span></span></code> </pre> <br>  In general, the VMSR command is processed by the coprocessor and raises an exception if the coprocessor is not turned on, but accessing this register <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0238c/CCDHCFGA.html">does not cause it</a> .  True, unlike the others, access to this register is possible only in <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0068b/BCFHHBDD.html">privileged mode</a> . <br><br>  After the coprocessor was enabled, our tests for mathematical functions began to pass.  But when I turned on optimization (-O2), the previously mentioned exception undefined instruction began to occur.  Moreover, it appeared on the <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0489c/CJAEFGHE.html">vmov</a> instruction that was called in the code earlier, but was executed successfully (without an exception).  Finally, I found the phrase ‚ÄúThe instructions for copying constants are available in VFPv3‚Äù at the bottom of this page (i.e., operations with constants are supported starting from VFPv3).  And I decided to check which version was released in my emulator.  The version is recorded in the <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0238c/CHDCGIBE.html">FPSID</a> register.  From the documentation it follows that the register value should be 0x41011090.  This corresponds to 1 in the architecture [19..16] field, that is, VFPv2.  Actually, having made a printout at the start, I got it <br><br><pre> <code class="hljs pgsql"> unit: initializing embox.arch.arm.fpu.vfp9_s: VPF <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: Hardware FP support Implementer = <span class="hljs-number"><span class="hljs-number">0x41</span></span> (ARM) Subarch: VFPv2 Part number = <span class="hljs-number"><span class="hljs-number">0x10</span></span> Variant = <span class="hljs-number"><span class="hljs-number">0x09</span></span> Revision = <span class="hljs-number"><span class="hljs-number">0x00</span></span></code> </pre> <br>  After reading carefully that 'vfp' is alias 'vfpv2', I set the correct flag, it all worked.  Returning to the <a href="https://www.linuxquestions.org/questions/linux-embedded-and-single-board-computer-78/compiling-hello-world-c-program-for-arm-arm926ej-s-rev-5-v5l-with-arm-linux-gnueabi-4175457470/">page</a> where I saw the combination of flags -mcpu = arm926ej-s -mfpu = vfpv3-d16, I note that I was not attentive enough, because the list of flags contains -mfloat-abi = soft.  That is, there is no hardware support in this case.  More precisely, -mfpu matters only if a value other than 'soft' is set for -mfloat-abi. <br><br><h2>  Assembler </h2><br>  It's time to talk about assembler.  After all, I had to do runtime support as well, for example, the compiler, of course, does not know about context switching. <br><br><h3>  Registers </h3><br>  Let's start with a description of the registers.  VFP allows you to perform operations with 32-bit (s0..s31) and 64-bit (d0..d15) floating-point numbers. The correspondence between these registers is shown in the picture below. <br><br><img src="https://habrastorage.org/webt/jr/lo/w0/jrlow0oljuvwjd0y5bb-qkxlyh4.png"><br><br>  Q0-Q15 are 128-bit registers from older versions for working with SIMD, about them a bit later. <br><br><h3>  Command system </h3><br>  Of course, most of the time working with VFP registers should be given to the compiler, but at least you have to write the context switch manually.  If you already have a rough understanding of the syntax of assembler commands for working with general-purpose registers, dealing with new commands should be easy.  Most often, the prefix ‚Äúv‚Äù is simply added. <br><br><pre> <code class="hljs erlang-repl">vmov d0, r0, r1 /*  r0  r1, ..  d0 <span class="hljs-number"><span class="hljs-number">64</span></span> ,   r0-<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">32</span></span> */ vmov r0, r1, d0 vadd d0, d1, d2 vldr d0, r0 vstm r0!, {d0-d15} vldm r0!, {d0-d15}</code> </pre> <br>  And so on.  A complete list of commands can be found on <a href="http://infocenter.arm.com/help/topic/com.arm.doc.qrc0007e/QRC0007_VFP.pdf">the ARM website</a> . <br><br>  And of course you should not forget about the version of VFP, so that situations like the one described above do not arise. <br><br><h2>  -Mfloat-abi flag 'softfp' and 'hard' </h2><br>  Let's go back to -mfloat-abi.  If you read the <a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html">documentation</a> , we will see: <br><blockquote>  The softfp allows you to use soft-float calling conventions.  'hard' allows for a generation of specific calling conventions. </blockquote>  That is, we are talking about passing arguments to a function.  But at least I was not very clear about the difference between ‚Äúsoft-float‚Äù and ‚ÄúFPU-specific‚Äù calling conventions.  Assuming that the hard case uses floating point registers, and the softfp case uses integer registers, I found confirmation of this on the <a href="https://wiki.debian.org/ArmHardFloatPort/VfpComparison">debian wiki</a> .  And although this is for the NEON coprocessors, it does not matter.  Another interesting point is that with the softfp option, the compiler can, but does not have to use hardware support: <br><blockquote>  ‚ÄúCompiler emulated or real FPUs can be defined according to FPU type (-mfpu =)‚Äú </blockquote>  For better clarity, I decided to experiment, and I was very surprised, because with the -O0 optimization turned off, the difference was very small and did not apply to those places where the floating point was actually used.  Having guessed that the compiler simply puts everything on the stack, and does not use registers, I turned on the -O2 optimization and was again surprised, because with the optimization the compiler started using floating-point hardware registers, both for hard and sotffp, and the difference is and in the case of -O0, it was very small.  As a result, for myself, I explained this to the fact that the compiler solves the <a href="https://wiki.debian.org/ArmHardFloatPort/VfpComparison">problem</a> related to the fact that if you copy data between floating point and integer registers, performance drops significantly.  And when optimizing, the compiler starts using all the resources at its disposal. <br><br>  When asked what flag to use 'softfp' or 'hard', I answered for myself as follows: everywhere where there are no parts already compiled with the 'softfp' flag, you should use 'hard'.  If there are such, it is necessary to use 'softfp'. <br><br><h2>  Context switch </h2><br>  Since Embox supports preemptive multitasking, to work correctly in runtime, of course, it was necessary to implement context switching.  To do this, save the registers of the coprocessor.  There are a couple of nuances.  First: it turned out that <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.dui0283b/Bcfchhif.html">the stack operation commands for floating points (vstm / vldm) do not support all modes</a> .  Second, these operations do not support work with more than sixteen 64-bit registers.  If you need to load / save more registers at a time, you need to use two instructions. <br><br>  I will also give you one small optimization.  In fact, saving and restoring 256 bytes of VFP registers is not necessary at all (general registers occupy only 64 bytes, so the difference is significant).  Obvious optimization will perform these operations only if the process uses these registers in principle. <br><br>  As I already mentioned, when the VFP coprocessor is turned off, an attempt to execute the corresponding instruction will result in the ‚ÄúUndefined Instruction‚Äù exception.  In the handler for this exception, you need to check what the exception is caused by, and if it is a matter of using a VPF coprocessor, the process is marked as using a VFP coprocessor. <br><br>  As a result, already written save / restore context was added with macros <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmrs tmp, FPEXC ; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>stmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_save_inc: #define ARM_FPU_CONTEXT_LOAD_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmsr FPEXC, tmp; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_load_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vldmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_load_inc:</code> </pre> <br>  To check the correctness of the context switching operation under floating point conditions, we wrote a test in which we do multiplication in one thread and then divide in another thread, then compare the results. <br><br><pre> <code class="cpp hljs">EMBOX_TEST_SUITE(<span class="hljs-string"><span class="hljs-string">"FPU context consistency test. Must be compiled with -02"</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_COUNT 10 static float res_out[2][TICK_COUNT]; static void *fpu_context_thr1_hnd(void *arg) { float res = 1.0f; int i; for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; TICK_COUNT; ) { res_out[0][i] = res; if (i == 0 || res_out[1][i - 1] &gt; 0) { i++; } if (res &gt; 0.000001f) { res /= 1.01f; } sleep(0); } return NULL; } static void *fpu_context_thr2_hnd(void *arg) { float res = 1.0f; int i = 0; for (i = 0; i &lt; TICK_COUNT; ) { res_out[1][i] = res; if (res_out[0][i] != 0) { i++; } if (res &lt; 1000000.f) { res *= 1.01f; } sleep(0); } return NULL; } TEST_CASE("Test FPU context consistency") { pthread_t threads[2]; pthread_t tid = 0; int status; status = pthread_create(&amp;threads[0], NULL, fpu_context_thr1_hnd, &amp;tid); if (status != 0) { test_assert(0); } status = pthread_create(&amp;threads[1], NULL, fpu_context_thr2_hnd, &amp;tid); if (status != 0) { test_assert(0); } pthread_join(threads[0], (void**)&amp;status); pthread_join(threads[1], (void**)&amp;status); test_assert(res_out[0][0] != 0 &amp;&amp; res_out[1][0] != 0); for (int i = 1; i &lt; TICK_COUNT; i++) { test_assert(res_out[0][i] &lt; res_out[0][i - 1]); test_assert(res_out[1][i] &gt; res_out[1][i - 1]); } }</span></span></span></span></code> </pre> <br>  The test was successful when the optimization was turned off, which is why we indicated in the test description that it should be compiled with optimization, EMBOX_TEST_SUITE (‚ÄúFPU context consistency test. Must be compiled with -02‚Äù);  although we know that tests should not rely on it. <br><br><h2>  NEON and SIMD coprocessor </h2><br>  It's time to tell why I postponed the story about imx6.  The fact is that it is based on the Cortex-A9 core and contains the more advanced NEON coprocessor (https://developer.arm.com/technologies/neon).  NEON is not only a VFPv3, but it is also a SIMD co-processor.  VFP and NEON use the same registers.  VFP uses 32-bit and 64-bit registers for operation, and NEON uses 64-bit and 128-bit registers, the latter just were designated Q0-Q16.  In addition to integer values ‚Äã‚Äãand floating point numbers, NEON can also work with a polynomial ring of 16th or 8th degree modulo 2. <br><br>  NEON's vfp mode is almost indistinguishable from a disassembled vfp9-s coprocessor.  Of course, it is better to specify for -mfpu the options vfpv3 or vfpv3-d32 for better optimization, since it has 32 64-bit registers.  And to enable the coprocessor, you must give access to the c10 and c11 coprocessors.  this is done using commands <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Allow access to c10 &amp; c11 coprocessors */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrc p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val) :)</span></span></span></span>; val |= <span class="hljs-number"><span class="hljs-number">0xf</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mcr p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val))</span></span></span></span>;</code> </pre> <br>  but there are no other fundamental differences. <br><br>  Another thing is if you specify -mfpu = neon, in this case, the compiler can use SIMD instructions. <br><br><h2>  Using SIMD in C </h2><br>  In order to ‚Äúbreak through‚Äù the values ‚Äã‚Äãin registers manually, you can enable ‚Äúarm_neon.h‚Äù and use the corresponding data types: <br>  float32x4_t for four 32-bit floats in one register, uint8x8_t for eight 8-bit integers, and so on.  To refer to a single value, we refer to as an array, addition, multiplication, assignment, etc.  as for ordinary variables, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> a = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, b = {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> c = a * b; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(‚ÄúResult=[%d, %d, %d, %d]\n‚Äù, c[<span class="hljs-number"><span class="hljs-number">0</span></span>], c[<span class="hljs-number"><span class="hljs-number">1</span></span>], c[<span class="hljs-number"><span class="hljs-number">2</span></span>], c[<span class="hljs-number"><span class="hljs-number">3</span></span>]);</code> </pre> <br>  Of course, using automatic vectorization is easier.  For automatic vectorization, add the -ftree-vectorize flag to GCC. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simd_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[LEN], b[LEN], c[LEN]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { a[i] = i; b[i] = LEN - i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { c[i] = a[i] + b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"c[i] = %d\n"</span></span>, c[i]); } }</code> </pre> <br>  The cycle with additions generates the following code: <br><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">600059</span></span>a0: f4610adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d16-d17}</span></span>, [r1 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>a4: e2833010 add r3, r3, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>a8: e28d0a03 add r0, sp, <span class="hljs-string"><span class="hljs-string">#12288</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3000 <span class="hljs-number"><span class="hljs-number">600059</span></span>ac: e2811010 add r1, r1, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b0: f4622adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d18-d19}</span></span>, [r2 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>b4: e2822010 add r2, r2, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b8: f26008e2 vadd.i32 q8, q8, q9 <span class="hljs-number"><span class="hljs-number">600059</span></span>bc: ed430b04 vstr d16, [r3, #-<span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c0: ed431b02 vstr d17, [r3, #-<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c4: e1530000 cmp r3, r0 <span class="hljs-number"><span class="hljs-number">600059</span></span>c8: <span class="hljs-number"><span class="hljs-number">1</span></span>afffff4 bne <span class="hljs-number"><span class="hljs-number">600059</span></span>a0 &lt;foo+<span class="hljs-number"><span class="hljs-number">0</span></span>x58&gt; <span class="hljs-number"><span class="hljs-number">600059</span></span>cc: e28d5dbf add r5, sp, <span class="hljs-string"><span class="hljs-string">#12224</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x2fc0 <span class="hljs-number"><span class="hljs-number">600059</span></span>d0: e2444004 sub r4, r4, <span class="hljs-string"><span class="hljs-string">#4</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>d4: e285503c add r5, r5, <span class="hljs-string"><span class="hljs-string">#60</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3c</code> </pre> <br>  Having carried out tests for parallelized code, we got that simple addition in a cycle, provided the variables are independent, gives acceleration as much as 7 times.  In addition, we decided to see how parallelization affects real tasks, took MESA3d with its software emulation and measured the number of fps with different flags, it turned out to be a gain of 2 frames per second (15 vs. 13), that is, acceleration is about 15-20% . <br><br>  I will <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.faqs/ka13544.html">give</a> one more <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.faqs/ka13544.html">example of acceleration with the help of NEON commands</a> , not ours, but from ARM. <br><br>  Memory copying is accelerated by almost 50 percent compared to normal.  True examples are in assembler. <br><br>  Normal copy cycle: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LDR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r1]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">STR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r0]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SUBS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BGE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span></code> </pre> <br>  loop with neon commands and registers: <br><br><pre> <code class="hljs erlang-repl">NEONCopyPLD PLD [r1, #<span class="hljs-number"><span class="hljs-number">0</span></span>xC0] VLDM r1!,{d0-d7} VSTM r0!,{d0-d7} SUBS r2,r2,#<span class="hljs-number"><span class="hljs-number">0</span></span>x40 BGE NEONCopyPLD</code> </pre> <br>  It is clear that copying 64 bytes faster than 4, and such copying will increase by 10%, but the remaining 40% seems to be the work of the coprocessor. <br><br><h2>  Cortex-m </h2><br>  Working with FPU in Cortex-M is not much different from that described above.  For example, this is what the above macro looks like to save the fpu context <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, =CPACR; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, [tmp]; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>tst tmp, #0xF00000; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {s0-s31}; fpu_out_save_inc:</code> </pre> <br>  Also, the vstmia command uses only the registers s0-s31 and in a different way it is accessing the control registers.  Therefore, I will not go into much detail, I will explain only diff.  So, we made support for STM32F7discovery with <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.ddi0489b/Chdefdgf.html">cortex-m7</a> for it, respectively, you need to set the flag -mfpu = fpv5-sp-d16.  Please note that in the mobile versions, you need to look at the version of the coprocessor even more closely, since there may be different versions of the same cortex-m.  So, if you have a variant not with double precision, but with a single one, then there may be no D0-D16 registers, as we have in <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.100166_0001_00_en/ric1417175936874.html">stm32f4discovery</a> , which is why the S0-S31 variant is used.  For this controller, we use -mfpu = fpv4-sp-d16. <br><br>  The main difference is the access to the control registers of the controller, they are located directly in the address space of the main core, and for different types they are different <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.100166_0001_00_en/ric1417779386775.html">cortex-m4</a> for <a href="http://infocenter.arm.com/help/index.jsp%3Ftopic%3D/com.arm.doc.100166_0001_00_en/ric1417779386775.html">cortex-m7</a> . <br><br><h2>  Conclusion </h2><br>  At this point I will finish my short story about the floating point for ARM.  I note that modern microcontrollers are very powerful and are suitable not only for control, but also for processing signals or various kinds of multimedia information.  In order to effectively use all this power, you need to understand how it works.  I hope this article helped in this a little better understand. </div><p>Source: <a href="https://habr.com/ru/post/418295/">https://habr.com/ru/post/418295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418285/index.html">Climatologists have shown how humanity influences seasonal variations in atmospheric temperature.</a></li>
<li><a href="../418287/index.html">Mandatory checklist for the development of mobile application UX-design</a></li>
<li><a href="../418289/index.html">How IT solutions help organize dynamic pricing in the store</a></li>
<li><a href="../418291/index.html">Conference DEFCON 19. "Steal everything, kill everyone, cause a complete financial collapse!" Jason I. Street</a></li>
<li><a href="../418293/index.html">Automatic testing of web interfaces in Virto Commerce</a></li>
<li><a href="../418297/index.html">Neffos N1 smartphone review</a></li>
<li><a href="../418301/index.html">The great opposition of Mars in 2018: how to observe and what to expect</a></li>
<li><a href="../418303/index.html">Vanessa-Automation is a tool for testing application solutions on the 1C: Enterprise platform.</a></li>
<li><a href="../418305/index.html">How many objects does Python allocate when executing scripts?</a></li>
<li><a href="../418307/index.html">Apple Machine Learning Tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>