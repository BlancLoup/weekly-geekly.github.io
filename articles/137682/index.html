<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript Prefix Trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As it was written 
 One long winter evening, my wife played Bookworm adventures , and periodically kicked me about writing words that were longer than...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript Prefix Trees</h1><div class="post__text post__text-html js-mediator-article"><h5>  As it was written </h5><br>  One long winter evening, my wife played <a href="http://store.steampowered.com/app/3470">Bookworm adventures</a> , and periodically kicked me about writing words that were longer than the available letters.  A quick search on the Internet for pages that allow to make words from a set of letters gave a bunch of sites that are trying to do it on the server side, and one that does it on a client-side java applet.  Those that make up the words of server capacity either have a limit on the size of a set of letters (usually, for some reason at 8), or are deeply thoughtful if they are sent a set of ‚Äúabcdefghijklmnopqrstuvwxyz‚Äù.  The Java applet, on the other hand, had a 12-letter limit, worked smartly and almost fit (16 letters are offered in the game for making words). <br><a name="habracut"></a><br>  Next to the java applet, lay a <a href="http://www.becomeawordgameexpert.com/wordlists.htm">dictionary</a> of 170 thousand English words.  Shortly before that, I interviewed and I was assigned a task that was supposed to be solved using prefix trees, then, to my shame, of all the knowledge about prefix trees, only the name remained in my head, and there was no experience with it.  Therefore, it was decided to fill this gap. <br><br>  I make money programming in <nobr>C ++</nobr> , so the original version was written as a console application in <nobr>C ++</nobr> .  It worked quickly and correctly, but I didn‚Äôt want to scare my wife with a black text box, so it was decided to rewrite it in Javascript.  I didn‚Äôt want to write the construction of the prefix tree in Javascript, so I added the unloading of the tree in JSON to the existing <nobr>C ++</nobr> program.  The output turned out to be a file of 40 megabytes (from the source dictionary of 2 megabytes), maybe at that moment it was worthwhile to score and write the tree construction from the dictionary, but decided to write the search first, since there is a dictionary.  Everything worked fine, but loading the page took seconds 5-10 from the hard drive.  The construction of the tree was rewritten in Javascript, and the result was somewhat surprising: loading did indeed noticeably faster (this was expected), the surprise was that the browser's memory consumption in this case was three times less.  The chromium tab in which the finished prefix tree was loaded ate 150 megabytes of memory, and the one in which the same tree was built from the dictionary only ate 50. As a result, in the final version both boot options are left for comparison.  Sources are available on <a href="https://bitbucket.org/n0rd/jstrie/">BitBucket</a> . <br><br><h5>  How it all works </h5><br>  The task is as follows: the user enters a string consisting of letters, it is necessary to find in the dictionary all the words consisting of the letters entered by the user and using each letter no more than once.  The user is not forbidden to specify a letter more than once if he wants to find words in which this letter occurs the appropriate number of times. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">Wikipedia</a> says ( <a href="http://en.wikipedia.org/wiki/Trie">English is</a> more verbose), a prefix tree is a tree that stores prefixes (that is, the first few letters) of words from the dictionary.  The tree structure is such that each subsequent tree level after the root stores the next letter of the prefix relative to the previous level.  At the root of the tree is stored an empty prefix that does not contain any letters.  If we walk along the path from the root of the tree to any leaf vertex, and write the letters from the visited vertices from left to right, then at the end of the path we will have a word from the dictionary.  However, it is worth noting that words do not necessarily end in leaf vertices, for example, a dictionary from the words BAD, CAB, CAD, DAB, AB, AD, BA is represented by the following tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/c7b/76d/59f/c7b76d59f8957a356bc2ad2551afbc6c.png"></div><br><br>  asterisks denote nodes where words end. <br><br>  So, in the program, the tree is represented by a link to the root node, each node is a Javascript object with <code>data</code> fields, in which the letter corresponding to the node is stored;  <code>terminator</code> if this node ends a word;  and a number of fields with the name of a single letter with links to the child nodes that store subtrees for the corresponding letter.  Those.  node <code>A</code> first level of the tree in the picture in the form of JSON looks like this: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"data"</span></span> : <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"terminator"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span> : { <span class="hljs-string"><span class="hljs-string">"data"</span></span> : <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"terminator"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"D"</span></span> : { <span class="hljs-string"><span class="hljs-string">"data"</span></span> : <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"terminator"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre><br><br>  The dictionary is represented as an array of strings.  To build a tree, let's start with an empty root node, choose sequentially the words from the dictionary, break into letters and create nodes as necessary: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trieRoot; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildTrie</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wordList</span></span></span><span class="hljs-function">) </span></span>{ trieRoot = { <span class="hljs-string"><span class="hljs-string">"data"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"terminator"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; wordList.length; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> word = wordList[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> letters = word.split(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> curNode = trieRoot; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; letters.length; ++j ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( curNode[letters[j]] == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ) { curNode[letters[j]] = { <span class="hljs-string"><span class="hljs-string">"data"</span></span> : letters[j], <span class="hljs-string"><span class="hljs-string">"terminator"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; } curNode = curNode[letters[j]]; } curNode.terminator = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre><br><br>  To compose words from a set of letters, it is necessary to generate all <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D0%25BC%25D0%25B5%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">placements of</a> length from 1 to the number of letters from the list specified by the user.  If in the process of constructing the next placement an already constructed prefix is ‚Äã‚Äãabsent in the dictionary, then further construction of the placement can be stopped.  The allocations are generated by a simple recursive function, and at the same time the presence of the current prefix is ‚Äã‚Äãchecked in it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> letters = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> used = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> words = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWords</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node, depth</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( depth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { result[depth - <span class="hljs-number"><span class="hljs-number">1</span></span>] = node.data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( node.terminator ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> word = result.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, depth).join(<span class="hljs-string"><span class="hljs-string">""</span></span>); words[word] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; letters.length; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !used[i] &amp;&amp; (child = node[letters[i]]) != <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ) { used[i] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; findWords(child, depth + <span class="hljs-number"><span class="hljs-number">1</span></span>); used[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre><br><br>  In the <code>letters</code> array there is a list of letters entered by the user, the <code>used</code> array stores flags for using the appropriate letter of letters from the <code>letters</code> array in the current location.  In <code>result</code> the current location is stored, in <code>words</code> - the words found are stored in the object used as an associative array to avoid duplications in the case when the user specifies several repetitions of one letter ("AAABBBCCCDDD"). <br><br>  The rest of the code is dedicated to handling input and output, and has little to do with the relation trees themselves. <br><br><h5>  Why do you need it </h5><br>  As for me, I can now honestly say that I know what a prefix tree is and faced its practical implementation.  In general, practically such a tree can be applied, for example, to store and quickly search for information on the first characters entered (such as search suggestions), the search is very fast, the search time depends only on the prefix length and the size of the alphabet, and if you donate memory, you can get rid of depending on the size of the alphabet. </div><p>Source: <a href="https://habr.com/ru/post/137682/">https://habr.com/ru/post/137682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137674/index.html">7app chart # 10</a></li>
<li><a href="../137677/index.html">Python sqlite3: Finding slow queries</a></li>
<li><a href="../137679/index.html">Windows v Enikey</a></li>
<li><a href="../137680/index.html">Comparing Objects in C # .NET</a></li>
<li><a href="../137681/index.html">Hello world on ESB Toolkit</a></li>
<li><a href="../137684/index.html">D-Link PowerLine: DHP-306AV Review</a></li>
<li><a href="../137685/index.html">The potential of the subscription base for the Internet entrepreneur and common mistakes when working to increase the subscription base</a></li>
<li><a href="../137686/index.html">Why online consultant does not make money, but only spoils my site</a></li>
<li><a href="../137687/index.html">Summer internship at InterSystems</a></li>
<li><a href="../137690/index.html">Using Chrome without a Mouse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>