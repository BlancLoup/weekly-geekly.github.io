<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplify unit tests with the AutoFixture bundle and xUnit</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all know that unit tests are great, that only code that is somehow covered with tests can be trusted and that if some inexperienced senior develope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplify unit tests with the AutoFixture bundle and xUnit</h1><div class="post__text post__text-html js-mediator-article">  We all know that unit tests are great, that only code that is somehow covered with tests can be trusted and that if some inexperienced <s>senior developer</s> senior programmer breaks something, the tests will immediately show it. <br><br>  However, writing tests is hardly an exciting process.  Initialization of test data, initialization of mocks, creation of a test object ... Until you get to the method call, which you actually wanted to test, test, and you don‚Äôt want anything.  Of course, I'm exaggerating, by its nature a unit test should not take on too much and contain a couple of dozen initialization lines (although this happens), but writing the same code quickly gets boring.  And now there are factories of test objects, a hierarchy of base classes for tests and other OOP gadgets, designed to "simplify" the creation of the test.  As a rule, this leads to the fact that there is practically no chance to quickly understand what a test does without traveling around these very objects. <br><br>  Actually, the tool that I want to talk about is precisely designed to simplify, and in some cases completely remove, the initialization phase or the <i>Arrange</i> test phase. <br><a name="habracut"></a><br>  Consider this simple test: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanSaveEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Arrange var validEntity = new Entity() { Name = "Some Name", Type = Type.Simple, Group = new EntityGroup() { Name = "12345" } }; var validationServiceMock = new Mock&lt;IValidationService&gt;(); { validationServiceMock.Setup(svc =&gt; svc.IsValid(validEntity)).Returns(true); } var repositoryMock = new Mock&lt;IRepository&lt;Entity&gt;&gt;(); var loggingServiceMock = new Mock&lt;ILoggingService&gt;(); var sut = new ApplicationService(repositoryMock.Object, validationServiceMock.Object, loggingServiceMock.Object); // Act sut.SaveEntity(validEntity); // Assert repositoryMock.Verify(r =&gt; r.Add(validEntity), Times.Once); }</span></span></code> </pre> <br>  Even in such a simple test, we have 6 lines of initialization.  Uncover AutoFixture and voila: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Theory, AutoMoqData</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanSaveEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Entity validEntity, [Frozen]Mock&lt;IValidationService&gt; validationServiceMock, [Frozen]Mock&lt;IRepository&lt;Entity&gt;&gt; repositoryMock, ApplicationService sut</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Arrange validationServiceMock.Setup(svc =&gt; svc.IsValid(validEntity)).Returns(true); // Act sut.SaveEntity(validEntity); // Assert repositoryMock.Verify(r =&gt; r.Add(validEntity), Times.Once); }</span></span></code> </pre><br>  The size of the Arrange phase has decreased by 6 times, it remains only to understand what is happening here. <br><br><h4>  Tool number 1 AutoFixture </h4><br>  In a nutshell, AutoFixture can create instances of different, generally arbitrarily complex types.  Primitive types are created using built-in generators (for example, the string is a <i>Guid.NewGuid</i> prefixed).  For user types, a constructor with a minimum number of parameters is selected, the value for each parameter is recursively generated by the same AutoFixture.  In addition to this, AutoFixture will by default call all public setters of class properties, passing values ‚Äã‚Äãof self-generated objects as values.  Thus, at the output we get an object filled with some random values.  It looks suspicious: however, in most cases, some random values ‚Äã‚Äãlike ‚ÄúTestName‚Äù and 42 are used as test data. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Old school var validEntity = new Entity() { Name = "Some Name", Type = Type.Simple, Group = new EntityGroup() { Name = "42" } }; // AutoFixture var someEntity = new Fixture().Create&lt;Entity&gt;(); }</span></span></code> </pre><br>  Of course, some properties that are important for the test and must have strictly defined values ‚Äã‚Äãcan be set explicitly either after the creation of the object (if this can be done through a property or method), or when creating an object you can specify one or more rules to fill in specific properties: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Customize build var someEntity = new Fixture().Build&lt;Entity&gt;().With(e =&gt; e.Name, "Important For Test").Without(e =&gt; e.Group).Create(); }</span></span></code> </pre><br>  Another important advantage of this approach is the stability of tests to object changes.  For example, if we add a couple of parameters to the constructor of the Entity object, then without AutoFixture we will need to run through a hundred or more tests, adjusting the constructor in each of them (well, or use Resharper).  If we use AutoFixture, then we can do nothing at all (of course, if the values ‚Äã‚Äãof these parameters are not important for all these tests). <br><br>  AutoFixture has quite powerful tuning capabilities that allow you to customize the generation of objects in cases where the default settings do not work, for example, in the case of tricky checks in constructors or setters. <br><br>  It all looks very cool, but still quite verbose.  For simple objects, the constructor call will be shorter than the AutoFixture construction.  This is where xUnit data theories comes to our rescue. <br><br><h4>  Tool # 2 xUnit data theories </h4><br>  Again, in a nutshell, theories in xUnit are different from the facts in that the test method can be parameterized, and through the test attribute one way or another to tell with what parameters the test will be called.  In the simple case, you can simply pass the values ‚Äã‚Äãexplicitly, for example: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Theory</span></span>] [InlineData(<span class="hljs-number"><span class="hljs-number">42</span></span>)] [InlineData(<span class="hljs-number"><span class="hljs-number">3300</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inline</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { Assert.True(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  But in combination with AutoFixture, which, as we already know, can generate anything, theories become even more powerful, allowing us to simply specify the list of incoming data in test parameters instead of creating them in the Arrange phase: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Theory, AutoData</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Entity testEntity</span></span></span><span class="hljs-function">)</span></span> { Assert.NotNull(testEntity); }</code> </pre><br>  Again, if the autogeneration of the entire object is not suitable for one reason or another, you can either redefine a part of the properties already generated in the test itself, or use the configuration mechanism both at the level of the entire attribute AutoMoqData and at the level of an individual parameter again using attributes.  In AutoFixture, there are already several attributes that set up generation rules, however, you can easily write your own attributes that describe exactly your object generation logic. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Theory, AutoData</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestEntityWithoutProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[NoAutoProperties]Entity testEntity</span></span></span><span class="hljs-function">)</span></span> { Assert.Null(testEntity.Group); }</code> </pre><br>  For example, using the <i>NoAutoProperties</i> attribute, <i>you</i> can disable the initialization of properties for testEntity. <br>  Fine!  Arrange phase is less and less time to deal with the cumbersome code creating mocks.  And here AutoFixture has a solution. <br><br><h4>  Tool number 3 AutoFixture + AutoMoqCustomization </h4><br>  I have already mentioned that AutoFixture allows you to customize yourself in every possible way.  <i>AutoMoqCustomization</i> is one of the settings that ‚Äúteaches‚Äù AutoFixture to do a simple thing: if none of the methods could create the required instance and the object type is either an interface or an abstract class, then AutoFixture creates moc using Moq.  It sounds cool, we create a service through AutoFixture and all its dependencies are already initialized.  One problem, sometimes moki need to configure and check what was caused there.  Where can I get a copy of the moka?  Here comes another AutoFixture mechanism called <i>Freeze</i> .  Its essence is to memorize some specific value for the type of object and return it exactly (instead of generating a new one) every time it is needed when generating other objects. <br>  For example, in this test: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Freeze</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fixture(); fixture.Freeze&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = fixture.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); Assert.Equal(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); }</code> </pre><br>  We say that if AutoFixture needs an <i>int</i> to create an object, you need to use 42 each time. <br>  In the case of mocks, we use <i>Freeze</i> on a mock, and then when creating objects, this mock will be used whenever it is needed: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FreezeMock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Arrange var fixture = new Fixture().Customize(new AutoMoqCustomization()); var validEntity = fixture.Create&lt;Entity&gt;(); var repositoryMock = fixture.Freeze&lt;Mock&lt;IRepository&lt;Entity&gt;&gt;&gt;(); var validationServiceMock = fixture.Freeze&lt;Mock&lt;IValidationService&gt;&gt;(); { validationServiceMock.Setup(svc =&gt; svc.IsValid(validEntity)).Returns(true); } var sut = fixture.Create&lt;ApplicationService&gt;(); // Act sut.SaveEntity(validEntity); // Assert repositoryMock.Verify(r =&gt; r.Add(validEntity), Times.Once); }</span></span></code> </pre><br>  Again, I note that with this approach, adding a new dependency to the class constructor does not lead to changing all the tests where this object was created. <br><br>  However, the code itself looks more verbose and even worse than the original test, where moki and service were created directly. <br>  But we also have theories from xUnit. <br><br><h4>  Full arsenal: AutoFixture + Moq + xUnit + data theories </h4><br>  Here it is a test from the very beginning of the article, I hope, now it is more or less clear what is happening here: <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Theory, AutoMoqData</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanSaveEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Entity validEntity, [Frozen]Mock&lt;IValidationService&gt; validationServiceMock, [Frozen]Mock&lt;IRepository&lt;Entity&gt;&gt; repositoryMock, ApplicationService sut</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Arrange validationServiceMock.Setup(svc =&gt; svc.IsValid(validEntity)).Returns(true); // Act sut.SaveEntity(validEntity); // Assert repositoryMock.Verify(r =&gt; r.Add(validEntity), Times.Once); }</span></span></code> </pre><br>  A couple of nuances <br>  <i>AutoMoqData</i> is a descendant of the standard attribute from AutoFixture <i>AutoData</i> , in which <i>AutoMoqCustomization is</i> applied. <br><br>  <i>Frozen</i> is a standard attribute that, as you might guess, simply calls Freeze on the created object for the parameter. <br><br>  In the end, it all works as a simple DI container, which also can create dependencies that no one has declared, by default. <br><br>  I tried not to overload the text with details, the task of the article is to interest those who have not heard about AutoFixture before.  In fact, AutoFixture is well documented, there are links to the documentation in Google and at the end of the article. <br><br><h4>  PS </h4><br>  A little about personal experience: I myself stumbled upon AutoFixture relatively recently, scrolling through the list of new courses PluralSite.  Interested interested colleagues.  At first I tried without xUnit, then I translated all the tests in the project from MSUnit to xUnit, in order to try with xUnit, and now I can hardly imagine how I used to write tests without it.  It's like ReSharper, only AutoFixture - it's worth trying and soon you have little idea how you used to live without it. <br><br><h4>  Links </h4><br>  <a href="https://github.com/AutoFixture/AutoFixture/wiki/Cheat-Sheet">Auto-Fixture cheet-sheet</a> <br>  <a href="http://blog.ploeh.dk/tags.html">Mark Siman blog with a series of articles on AutoFixture</a> </div><p>Source: <a href="https://habr.com/ru/post/262435/">https://habr.com/ru/post/262435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262423/index.html">Simulation and analysis of computational processes</a></li>
<li><a href="../262427/index.html">Truly responsive letters. Part ... first again</a></li>
<li><a href="../262429/index.html">Condition as a compromise</a></li>
<li><a href="../262431/index.html">Real-time data processing in AWS Cloud. Part 2</a></li>
<li><a href="../262433/index.html">IDA Pro Upgrade. Debugger plugin. Part I. Theory</a></li>
<li><a href="../262437/index.html">Automatic regulator of temperature of a geyser</a></li>
<li><a href="../262439/index.html">Optimizing Asterisk Dialplan Listing with MySQL</a></li>
<li><a href="../262443/index.html">A simple replacement for Boost :: Optional for using nullable types in C ++ projects</a></li>
<li><a href="../262445/index.html">Facebook World Data Analysis</a></li>
<li><a href="../262447/index.html">Event for university teachers in St. Petersburg on programming training</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>