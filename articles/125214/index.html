<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bluetooth module HC-04 on CSR chip BC417143B</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CSR (Cambridge Silicon Radio) produces special chips for BlueTooth devices. The chips appear to be fairly inexpensive, because the Chinese gentlemen o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bluetooth module HC-04 on CSR chip BC417143B</h1><div class="post__text post__text-html js-mediator-article">  <b>CSR</b> (Cambridge Silicon Radio) produces special chips for <b>BlueTooth</b> devices.  The chips appear to be fairly inexpensive, because the Chinese gentlemen offer miniature (somewhat larger than a sim card) Bluetooth <b>HC-04</b> handkerchiefs based on the <b>BC417143B</b> chip ( <b>BlueCore4</b> family, see [1]), which in Russia can be bought for only 6.6 dollars ( through dealextreme.com, see [2] and [3]). <br><br><img src="http://imglink.ru/pictures/29-07-11/7ed8648fc2b9aac565b45ec0e39c5880.jpg" alt="image"><br><br>  By default, the FLASH memory of HC-04 contains software that allows you to connect any handheld (or phone, laptop, etc.) with a built-in microcontroller-based system (robot, Arduino board, any device on the microcontroller that has a TTL). port UART RS-232).  Using the <b>CSR CASIRA BLUELAB SDK</b> package (which contains working examples of Bluetooth programs), you can reprogram the HC-04 module yourself and create your own Bluetooth devices.  The programmer and full-fledged hardware debugger for the module can be easily made by yourself; it is connected to the computer via the LPT port (see [4]).  This article presents a brief description of the development tools for the CSR BlueCore chip family, which can be used to quickly begin writing your own programs for the HC-04 module. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will not describe in detail the technical characteristics of the HC-04 module, since everything can be found out at the links from the dealextreme website [2].  I will write only about the most interesting.  On board, the module has a 1 megabyte memory chip.  It contains the control firmware and all settings (more on).  The external 34 module contacts are displayed: <br>  - hardware <b>UART</b> , TXD, RXD, CTS and RTS signals. <br>  - <b>PCM</b> serial port (for digital audio input / output). <br>  - two analog inputs / outputs <b>AIO</b> . <br>  - <b>RESET</b> reset leg (it can not be connected anywhere). <br>  - input voltage supply +3.3 volts, current consumption maximum 35 mA. <br>  - <b>USB</b> interface. <br>  - <b>SPI</b> interface, through which firmware is flashed and debugging takes place. <br>  - 12 <b>PIO</b> digital input / output ports. <br><br>  After powering the module (3.3 volts, maximum 35 mA), it can be detected as a wireless Bluetooth device with a serial COM port profile.  That is, a serial port will appear on your PDA (phone, laptop, etc.) through which you can directly exchange data via TTL signals TX and RX of the standard <b>RS-232 port</b> .  Firmware HC-04 allows AT commands to change the data transfer rate over a wide range (from <b>1200</b> to <b>1382400</b> baud), and the speed setting changes are non-volatile, and are saved between power off.  Thus, due to its small size and low price (in Russia you can buy for $ 6.6), the HC-04 module is already interesting as a convenient ready-made device for wireless communication. <br><br>  However, as it turned out, for the HC-04 module, you can write programs yourself and write them to the chip‚Äôs memory.  The review of these features is devoted to the main part of the article. <br><br><h4>  Development Toolkit </h4><br>  The programmer will have to do it yourself, because in Russia it is impossible to buy it, no one sells it.  Glad that the scheme is quite simple, no problem to assemble yourself.  The programmer is the simplest <b>LPT SPI interface</b> . <br><br><img src="http://imglink.ru/pictures/29-07-11/c9b2fae78fd69bf32e62428cd2378437.jpg" alt="image"><br><br>  Through this simple programmer, you can merge all the FLASH memory of the HC-04 module into binary files (using the <b>BlueFlash</b> utility), view and edit the module and program settings (using the <b>PSTool</b> utility).  You can write firmware and debug programs (using the same LPT SPI) in the <b>xIDE</b> development <b>environment</b> .  There are numerous examples of the source code of various Bluetooth devices, the necessary documentation in English.  All these features are opened on the Windows operating system, if you install the CSR CASIRA BLUELAB SDK (the installation package takes about 55 megabytes, after installation it takes 310 megabytes). <br><br>  The examples allow you to create Bluetooth devices of role A (something like Bluetooth wizards who themselves find Bluetooth devices and connect to them. It is impossible to find the role of role A by searching for wireless devices) and the role of B (Bluetooth device that can be found by searching for wireless devices).  Using examples from the CSR CASIRA BLUELAB SDK, it is possible to organize data exchange between two HC-04 modules, in this case, one must realize the role A, and the other role B (the standard firmware that is recorded in the HC-04 at the factory, does not allow only role B is implemented in it. <br><br><h4>  Settings Store, Persistent Store </h4><br>  The memory of the HC-04 module, along with the firmware, contains many different parameters (such as the Bluetooth address, device name, transmitter output power, etc.), the so-called keys.  This is not just a feature of the HC-04 module, as is the custom in the BlueCore architecture when programming applications.  All keys can be viewed with the PSTool utility, modified if necessary (if you, of course, understand what you are doing) and saved to a <b>* .psr</b> file that has a convenient text format.  The key dump is done for quite a long time (my process took about 2 minutes), while the firmware does not stop working.  All keys stored in the chip are divided by storage level.  The levels are tied to the location of the settings (FLASH, RAM, ROM), as well as the time of creation (Implementation, Factory).  The keys of which levels to display, choose in the menu Store (All (TIFR), Implementation Only (I), ROM Only ¬Æ, RAM Only (T), Factory Only (F), Not RAM (IFR)).  If the same key is simultaneously defined at different levels and with different values, and it is selected to show all levels (All (TIFR)), then the value of the key stored at the highest level will be shown.  Default key values ‚Äã‚Äãare stored in ROM, the lowest level.  Runtime keys are kept at the highest level, Transient (RAM).  Several levels are immediately indicated by the abbreviations of the first letters of the levels, for example, IFR, TIFR.  Read more about the levels of the Persistent Store in the document <i><b>blab-ug-008Pb_PSTool_User_Guide.pdf</b></i> . <br><br><h4>  CSR BlueCore and SDK Libraries </h4><br>  In projects of examples xIDE, all subtleties are hidden far from the user's eyes in libraries.  Libraries are divided into 3 classes: <br><ul><li>  Foundation Libraries </li><li>  Support Libraries </li><li>  Profile Libraries </li></ul>  <b>Foundation Libraries</b> - the main functionality, low-level work with equipment.  Supplied in binary form only, without source code.  The header file for using the Foundation functions of the library is csr.h. <br><br>  <b>Support Libraries</b> - provide connectivity support (RFCOMM, L2CAP and SCO).  Header files and source code files are located in the folder <i><b>C: \ BlueLab \ src \ lib</b></i> . <br><br>  <b>Profile Libraries</b> - refer to BlueTooth profiles.  Profiles are something like the purpose of a Bluetooth device (for example, a serial port, an audio device, a source and receiver of files, a USB interface, etc.).  Header files and source code files are located in the folder C: \ BlueLab \ src \ lib. <br><br>  The BlueCore chip has many different interfaces, data sources and receivers (Kalimba, PCM, SCO, RFCOMM, L2CAP, UART, Host, USB, HID, Region, File, Audio Notes), which with the help of libraries can be simply connected to each other and exchange data through streams.  Some data sources and sinks (Kalimba) are related to BlueCore cores that have DSP on board.  The BC417143B chip, mounted on the HC-04, belongs to the BlueCore4 family and has no DSP.  See <i><b>CS-110275-UGP1_Implementing_Streams_in_BlueLab.pdf for details</b></i> . <br><br>  To start using the library, you need to include the necessary .h file with the #include directive and add the name of the required library to the project settings Project Properties -&gt; Configuration Properties -&gt; Build System -&gt; Libraries - the names of the required libraries are specified in the input field, separated by a comma (without file extensions).  Libraries can be rebuilt (the process is rather long!) By launching the BlueLab 41 shortcuts -&gt; Rebuild -&gt; VM libraries and DSP libraries. <br><br><h4>  Brief description of xIDE and the simplest application </h4><br>  BlueTooth device projects that a host can find through a search have _b suffix (for example, spp_dev_b).  Projects that themselves work as a host, that is, they can connect other BlueTooth devices to themselves, have the suffix _a (for example, spp_dev_a).  Devices with the suffix _a cannot be found by a host through a BlueTooth search for devices. <br><br>  To run the project through xIDE, you need to go to the project folder (all the projects of the demo examples are in the <i><b>C: \ BlueLab41 \ apps \ examples</b></i> folder) and double-click on the <b>* .xiw</b> file (the Workspace settings are stored here, the project settings are stored in the <b>* .xip</b> file ).  The xIDE development environment will automatically start, where you can view the source code of the project and run the code for compilation and debugging.  When you start debugging via LPT SPI, the chip type is automatically read, and the project is compiled for it.  After compilation, the program is automatically poured into an external FLASH memory connected to the CSR processor (recall that for BlueTooth HC-04 modules, this is the BC417143B-IQN-E4 processor (BlueCore4-External device)), and the program is launched for execution.  After stopping debugging, if you turn off and turn on the power again, the chip will be overwritten by a new compiled program that starts and starts working.  The normal project is loaded, and the chip's memory is about a minute (and what did you want from the LPT port?). <br><br>  You can write from scratch for HC-04 the simplest application, flashing LED.  To do this, run xIDE, select Project -&gt; New ..., specify the project type Bluelab -&gt; Blank VM Project, enter any project name (for example, MyFirstBluelab), select the folder for the project location (everything is done by analogy, as in Visual Studio) and click OK.  Then you need to create the main.c module file, and enter the text there: <br><br><blockquote> <code><code><font color="black">#include &lt;message.h&gt;&lt;br&gt;#include &lt;pio.h&gt;&lt;br&gt;&lt;br&gt; <font color="#0000ff">#define</font> LED_1 (1&lt;&lt;1)&lt;br&gt;&lt;br&gt;typedef <font color="#0000ff">struct</font> &lt;br&gt;{&lt;br&gt;    TaskData task;&lt;br&gt;    uint16 change;&lt;br&gt;} ToggleTask;&lt;br&gt;&lt;br&gt; <font color="#0000ff">static</font> <font color="#0000ff">void</font> MyHandler (Task t, MessageId id, Message payload)&lt;br&gt;{&lt;br&gt;    uint16 change = ((ToggleTask *) t)-&gt; change;&lt;br&gt;    PioSet(change, PioGet() ^ change);&lt;br&gt;    MessageSendLater (t, 0, 0, 500);&lt;br&gt;}&lt;br&gt;&lt;br&gt; <font color="#0000ff">static</font> ToggleTask toggle = { { MyHandler }, LED_1 };&lt;br&gt;&lt;br&gt; <font color="#0000ff">int</font> main ( <font color="#0000ff">void</font> )&lt;br&gt;{&lt;br&gt;    PioSetDir (LED_1, ~0);&lt;br&gt;    MessageSend(&amp;toggle.task, 0, 0);&lt;br&gt;    MessageLoop();&lt;br&gt; <font color="#0000ff">return</font> 0;&lt;br&gt;}</font></code></code> </blockquote>  A brief description of the listing (see <i><b>CS-110344-UGP2_WritingBlueCoreApplication.pdf for details</b></i> ): <br>  - in the include block headers are included to support messages and I / O ports. <br>  - the define operator sets the LED foot to be controlled. <br>  - The ToggleTask structure sets the type for the toggle application task data store. <br>  - subroutine MyHandler is a message handler that performs control of the LED.  The algorithm is very simple.  From the transferred structure of the task t, the value of the change parameter is read.  There is the LED_1 LED mask, and the change parameter is used here simply as a demonstration of the storage and transmission of the running task.  Calls to the PioSet and PioGet procedures ensure that the LED is set in the opposite state (if it was turned off, it turns on, and vice versa), the value of the change variable is used as a mask.  The MessageSendLater procedure sends a new message to the task t after 500 ms. <br>  - the declaration of a static variable toggle allocates memory for a variable of the ToggleTask structure and assigns values ‚Äã‚Äãto its task and change fields. <br>  - in the procedure code main PioSetDir configures PIO1 (LED_1) as an output. <br>  - MessageSend sends the original message that the MyHandler handler receives. <br>  - call procedure MessageLoop starts the delivery of messages between tasks.  In MessageLoop, execution loops, and control never reaches operator Return 0. <br><br>  Now, if you press <b>F7</b> , the project will compile.  If you press <b>F5</b> , the program will automatically fill in the chip's memory and start execution (provided that you have the LPT SPI module connected and the HC-04 module is connected to it), and the LED on the PIO1 pin flashes at 1 Hz.  At the same time, full-fledged debugging is available - in steps, with breakpoints, with viewing of variables, memory and processor registers.  Breakpoints are set in the code as usual, by clicking the mouse to the left of the code text (a brown circle appears opposite the line where the breakpoint is set) - just like in Visual Studio.  Read more about debugging in <i><b>CS-101500-UGP5_BlueLab xIDEuser guide.pdf</b></i> . <br><br><img src="http://imglink.ru/pictures/29-07-11/ea1229a6036f4d850d11181f19d979ec.jpg" alt="image"><br><br><h4>  The overall structure of the BlueLab application </h4><br>  The firmware application is based on tasks.  Each task performs a specific function assigned to it.  All tasks are performed as separate logical streams that do not block each other.  The task scheduler is not preemptive, so it is important that all message handlers are executed to completion and not looped forever, otherwise the work of other tasks will be disrupted.  Tasks exchange information with each other through messages.  All tasks that an application creates are also included in a special top-level task, the so-called <b>application task</b> ( <b>application task</b> ).  This task responds to messages and controls the overall behavior of the application.  Complex applications may contain several application tasks. <br><br>  Messages (messages) are created and transmitted in the following form: <br>  Task t, MessageId id, Message payload <br><br>  <b>Task t</b> points to the recipient of the message; it is a pointer to the receiving task, for example &amp; AppTask. <br>  <b>MessageId id</b> identifies the message.  The following message numbering system was adopted: <br>  - the message that the task sends to itself begins with 0x00. <br>  - System messages start at 0x8000. <br>  - Messages sent to the task by a separate profile library begin with the base 0x7000, and the SPP library messages begin with 0x6f00. <br><br>  <b>Message payload</b> - payload (data) transmitted in the message.  Sometimes there is no payload in the message when only the message identifier is sufficient.  In this case, the Message payload is NULL. <br><br>  There is a set of functions to simplify the sending of messages, see <i><b>message.h</b></i> and the corresponding documentation.  The message handler for each task must process all messages addressed to it.  The usual developer practice is to develop a code for handling messages that an application task accepts (application task).  No need to write handlers for profile tasks and support tasks initialized from BlueLab or SDK libraries.  Handlers for these tasks are already built into libraries and are selected after calling the appropriate Init function.  The application task application must process messages from the libraries it initializes.  The system message table is listed in file <i><b>CS-110344-UGP2_WritingBlueCoreApplication.pdf</b></i> , <i>Appendix A System Messages</i> .  The database table (the first byte of the message ID value) of the library messages is given in the same file, <i>Appendix B Library Message Bases</i> .  During debugging via debugger (LPT SPI or USB SPI) messages appear in the Output window, the Messages tab. <br><br>  Tasks and messages allow the application developer to break all the necessary functionality into separate modules that work as different tasks, while you need to ensure the exchange of messages between tasks.  All messages are queued and processed (transmitted) in the order received.  The scheduler looks at the first message in the queue and, if necessary, sends this message as parameters to the corresponding task handler.  After the message is passed to the handler, the MessageLoop function releases the payload of the transmitted message and proceeds to process the next message in the queue, or wait for a new message to appear in the queue. <br><br>  You can display debug messages from the program code with the <b>printf</b> statement.  In this case, the Print Channel 0 tab opens in the Output window, and the printf output is printed there.  The printf output works in real time while the firmware is running via a debugger on LPT SPI.  In a real application, all printf statements must be removed, otherwise the application without a debugger will hang and not work (due to stack overflow).  To remove the debug output, use the special DEBUG_PRINT_ENABLED compile time token and the #ifdef conditional compilation statements. <br>  #define DEBUG_PRINT_ENABLED 1 // output resolution printf <br><br>  DEBUG_PRINT_ENABLED can also be defined in the project properties, Build System -&gt; Define symbols.  An example of using DEBUG_PRINT_ENABLED is found in the sample application projects C: \ BlueLab41 \ apps \ examples \. <br><br>  There are several problems encountered when experimenting with xIDE.  If the program is flushed to the chip, but does not want to start debugging with the error ‚ÄúThe app reads from disk appears to be invalid.‚Äù, Then this can happen when the project folder has a complex path that includes spaces and / or Russian letters.  For example, your project is located in the <i><b>c: \ Documents and Settings \ User \ Admin \ My Documents \ LEDFlashing \ folder</b></i> .  Change the placement of the project to a simpler one, for example <i><b>c: \ temp \ LEDFlashing</b></i> , and the debugger will start normally.  With russification, xIDE has certain problems - the text stored in the code in Russian, when re-opened is displayed with krakozyabrami, so write comments in Russian in the code will not work.  Sometimes it is strongly hampered by the compilation of Kaspersky anti-virus (the process is very slow).  It is advisable to configure an exception scan of objects on the path <i>C: \ BlueLab41 \ tools \ *. Exe</i> .  The settings will take effect for some reason only after restarting Windows. <br><br><img src="http://imglink.ru/pictures/29-07-11/9c9dc40bb1395db62600cfe9f1765b03.jpg" alt="image"><br><br><h4>  Dictionary </h4><br>  <b>HCI</b> Host Controller Interface <br>  <b>LC</b> Link Controller <br>  <b>xIDE</b> programming environment for BlueCore CSR processors <br>  <b>VM</b> Virtual Machine - as I understand it, it is the execution of the functions of a host processor on an embedded RISC microprocessor.  There are Classic VMs, and there are Native VMs that differ in architecture and execution speed.  See <i><b>CS-122636-AN-1classicvsNative.pdf</b></i> . <br>  <b>VM API</b> is a non-DSP application programming interface. <br>  <b>BlueCore is the</b> name of the CSR Bluetooth chip line.  The HC-04 uses a BlueCore4 chip. <br>  <b>payload</b> payload.  In the context of message passing, the data transmitted in the message. <br>  <b>application task application task</b> - a required element of any BlueCore firmware program. <br>  <b>preemptive</b> , <b>pre-emptive</b> in this context, crowding out multitasking.  For each task, a limited time interval of execution is allocated, which guarantees that it is impossible to block the execution of all tasks if one of the tasks is blocked (for example, it enters an infinite loop). <br>  <b>not preemptive</b> in this context means multi-tasking, when tasks are performed one after another, and each task is performed in order from beginning to end.  In this case, locking in one task can stop the execution of all tasks.  This is exactly the scenario for performing tasks that is used in the CSR BlueCore and SDK libraries. <br>  <b>L2CAP</b> Logical Link Control and Adaptation Protocol <br>  <b>Persistent Store</b> data storage of installations in the form of records (keys) <br>  <b>TIFR</b> Transient (RAM), Implementation, Factory, ROM - Persistent Store locations, meaning all possible placement options.  The keys installed during the production of the product are located in the Factory and Implementation areas, the keys that are formed during the operation of the product are placed in Transient (RAM). <br>  <b>IFR</b> Implementation, Factory, ROM - Persistent Store locations that do not use RAM. <br>  <b>BCSP</b> BlueCore Serial Protocol is a protocol through which all debugging tools communicate with the BlueCore chip (at the physical level this happens via the BlueCore SPI interface). <br>  <b>Kalimba DSP</b> - Some BlueCore chips (BlueCore3 and BlueCore5) have DSP.  Unfortunately, there is no DSP in the BC417143B processor of the HC-04 module.  There is a special API and corresponding library for working with Kalimba DSP. <br><br><h4>  Links </h4><br>  <b>1</b> .  <a href="http://www.csr.com/products/29/bluecore4-ext">General description of the BlueCore4-External device chip on the CSR company website</a> . <br>  <b>2</b>  <a href="http://www.dealextreme.com/p/wireless-bluetooth-rs232-ttl-transceiver-module-80711">Bluetooth module HC-04 on the Dealextreme website</a> . <br>  <b>3</b>  <a href="http://www.dealextreme.spb.ru/dx">How to buy at dealextreme</a> . <br>  <b>4</b>  <a href="http://microsin.ru/content/view/1284/44/">Description of LPT SPI programmer and debugger, documentation links, CSR CASIRA BLUELAB SDK, firmware of the module HC-04</a> . <br>  <b>5</b>  <a href="http://depositfiles.com/files/5aufuq2mn">The source code of the project xIDE for the module HC-04, flashing LED on the port PIO1</a> . </div><p>Source: <a href="https://habr.com/ru/post/125214/">https://habr.com/ru/post/125214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125206/index.html">Overview of free tools for auditing web-resources and not only</a></li>
<li><a href="../125207/index.html">Special 4 Habrahabr: QIWI Wallet Company Development Report in Q2 2011</a></li>
<li><a href="../125208/index.html">House of Talents goes to the CIS</a></li>
<li><a href="../125210/index.html">Working with Java on the command line</a></li>
<li><a href="../125212/index.html">Isostick: a flash drive that impersonates an optical drive</a></li>
<li><a href="../125216/index.html">Create a video surveillance system using motion</a></li>
<li><a href="../125217/index.html">IT Operations: the beginning</a></li>
<li><a href="../125218/index.html">Development of its first USB device. A small step forward</a></li>
<li><a href="../125219/index.html">Apple's financial reserves exceeded US government operating reserves</a></li>
<li><a href="../125220/index.html">Startup Poster Updated</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>