<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Async / await and the implementation mechanism in C # 5.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Details on the conversion of asynchronous code by the compiler. 
 The async mechanism is implemented in the C # compiler with support from the .NET ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Async / await and the implementation mechanism in C # 5.0</h1><div class="post__text post__text-html js-mediator-article"><h1>  Details on the conversion of asynchronous code by the compiler. </h1><br>  The async mechanism is implemented in the C # compiler with support from the .NET base class libraries.  There was no need to make any changes to the performing environment itself.  This means that the await keyword is implemented by converting to a view that we could have written ourselves in previous versions of C #.  To study the generated code, you can use the .NET Reflector or ILSpy decompiler.  This is not only interesting, but also useful for debugging, performance analysis and other types of asynchronous code diagnostics. <br><a name="habracut"></a><br><h3>  Stub method </h3><br>  Consider first a simple example of an asynchronous method: <br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Int32&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodTaskAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Int32 one = <span class="hljs-number"><span class="hljs-number">33</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> one; }</code> </pre> <br>  This example is quite simple, but practical enough and convenient for explaining the basic principle of implementing async / await.  Run ILSpy and examine the code that the C # compiler automatically generates: <br><pre> <code class="hljs django"><span class="xml"><span class="xml"> [AsyncStateMachine(typeof(Program.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__0))] public Task</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> MethodTaskAsync() { Program.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__0 </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__ = new Program.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__0(); </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml">4__this = this; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml">t__builder = AsyncTaskMethodBuilder</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">.Create(); </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTask</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml">1__state = -1; AsyncTaskMethodBuilder</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml">t__builder = </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml">t__builder; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml">t__builder.Start</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Program.</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__0&gt;(ref </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__); return </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MethodTaskAsync</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">d__.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml">t__builder.Task; }</span></span></code> </pre><br>  Interesting, isn't it?  The async keyword has no effect on how the method is used externally.  This is evident by the fact that the signature of the method generated by the compiler corresponds to the original method with the exception of the word async.  To some extent, the async specifier is not considered part of the method signature, for example, when it comes to redefining virtual methods, implementing an interface, or calling. <br><br>  The only purpose of the async keyword is to change the method of compiling the corresponding method; it has no effect on interaction with the environment.  Also note that in the "new" method there are no traces of the original code. <br><br><h3>  Structure of the state machine </h3><br>  In the example above, the compiler automatically applied the AsyncStateMachine attribute to the method.  When a method (MethodTaskAsync) has an async modifier, the compiler generates an IL including the state machine structure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This structure contains the code in the method.  The IL code also contains a stub method (MethodTaskAsync) called in a state machine.  The compiler adds the AsyncStateMachine attribute to the stub method so that the corresponding state machine can be identified.  This is necessary in order to make an object capable of maintaining the state of the method at the moment when the program reaches await.  After all, as you know, the code up to this keyword is executed in the calling thread, and then when it is reached, information is stored on where in the method the program was located so that when it resumes, the program can continue execution. <br><br>  The compiler could do it differently: just save all the variables of the method.  But in this case, you would have to generate a lot of code.  However, you can do otherwise, namely, just create an instance of some type and save all the method data as members of this object.  Then when saving this object all local variables of the method will be automatically saved.  For this purpose, the intended structure, called the finite state machine (Finite State Machine), is intended. <br><br>  In short, a finite state machine is an abstract automaton, the number of possible internal states of which is finite.  To put it bluntly, a finite-state machine through the eyes of a user is a black box into which you can transfer something and get something from there.  This is a very convenient abstraction, which allows you to hide a complex algorithm, in addition, finite automata are very effective.  At the same time there is a finite set of input symbols from which the output words are formed.  You should also take into account the fact that each input symbol transfers the automaton to a new state.  In our case, the input characters will be the state of the asynchronous operation and, based on this value, the state machine will form some state and, accordingly, the response to the task execution (output word).  This approach simplifies the formation and management of asynchronous tasks. More details about state machines can be found on the Internet with a bunch of detailed articles. <br><br>  A state machine is formed as a class and contains the following member variables: <br><pre> <code class="hljs vala"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;&gt;1__state'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;one&gt;5__1'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Mechanism_async.Program <span class="hljs-string"><span class="hljs-string">'&lt;&gt;4__this'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> System.Runtime.CompilerServices.AsyncTaskMethodBuilder`<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>&gt; <span class="hljs-string"><span class="hljs-string">'&lt;&gt;t__builder'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> System.Runtime.CompilerServices.TaskAwaiter <span class="hljs-string"><span class="hljs-string">'&lt;&gt;u__awaiter'</span></span>;</code> </pre><br>  <i>The names of all variables contain angle brackets, indicating that the names are generated by the compiler.</i>  <i>This is necessary so that the generated code does not conflict with the user code, because in the correct C # program the variable names cannot contain angle brackets.</i> <br><br><ul><li>  The first variable <i>&lt;&gt; 1_state</i> stores the number of the await statement reached.  No await has been encountered yet, the value of this variable is -1.  All await statements in the original method are numbered, and at the moment of suspension, the state number is entered into the await number, after which it will be necessary to resume execution. </li><li>  The following variable <i>&lt;one&gt; 5_1</i> is used to store the original variable one.  In the code generated by the compiler, all references to this variable are replaced with references to this member variable. </li><li>  Next comes the variable <i>&lt;&gt; 4_this</i> .  It is found only in state machines for non-static asynchronous methods and contains the object on whose behalf it was called.  In a sense, this is just another local method variable, only it is used to access other variable members of the same object.  In the process of converting the async method, it must be saved and used explicitly, because the code of the original object is transferred to the structure of the state machine. </li><li>  <i>AsyncTaskMethodBuilder (&lt;&gt; t__builder)</i> - represents the builder for asynchronous methods that return a task.  This auxiliary type and its members are intended for use by the compiler.  Here logic is encapsulated, common to all state machines.  It is this type that creates the Task object returned by the stub.  In fact, this type is very similar to the TaskCompletionSource class in the sense that it creates a puppet task that can be completed later.  The difference from TaskCompletionSource is that AsyncTaskMethodBuilder is optimized for async methods and for the sake of performance improvement is a structure, not a class. </li><li>  <i>TaskAwaiter (&lt;&gt; u_awaiter)</i> - a temporary object is stored here that waits for the completion of an asynchronous task.  It is also presented as a structure and helps the await operator to subscribe to the Task completion notification. </li></ul><br>  For a more detailed study of what actually happens under the hood of the compiler, consider the IL code generated by the compiler for &lt;MethodTaskAsync&gt; d__0: <br><div class="spoiler">  <b class="spoiler_title">IL code</b> <div class="spoiler_text"><pre> <code class="tex hljs">.class nested private auto ansi sealed beforefieldinit '&lt;MethodTaskAsync&gt;d__0' extends [mscorlib]System.Object implements [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine { .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) // Fields .field public int32 '&lt;&gt;1__state' .field public valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt; '&lt;&gt;t__builder' .field public class Asynchronous.Program '&lt;&gt;4__this' .field private int32 '&lt;one&gt;5__1' .field private valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter '&lt;&gt;u__1' // Methods .method public hidebysig specialname rtspecialname instance void .ctor () cil managed { // Method begins at RVA 0x20ef // Code size 8 (0x8) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [mscorlib]System.Object::.ctor() IL_0006: nop IL_0007: ret } // end of method '&lt;MethodTaskAsync&gt;d__0'::.ctor .method private final hidebysig newslot virtual instance void MoveNext () cil managed { .override method instance void [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine::MoveNext() // Method begins at RVA 0x20f8 // Code size 185 (0xb9) .maxstack 3 .locals init ( [0] int32, [1] int32, [2] valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter, [3] class Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0', [4] class [mscorlib]System.Exception ) IL_0000: ldarg.0 IL_0001: ldfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_0006: stloc.0 .try { IL_0007: ldloc.0 IL_0008: brfalse.s IL_000c IL_000a: br.s IL_000e IL_000c: br.s IL_0054 IL_000e: nop IL_000f: ldarg.0 IL_0010: ldc.i4.s 33 IL_0012: stfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;one&gt;5__1' IL_0017: ldc.i4 1000 IL_001c: call class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.Task::Delay(int32) IL_0021: callvirt instance valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter [mscorlib]System.Threading.Tasks.Task::GetAwaiter() IL_0026: stloc.2 IL_0027: ldloca.s 2 IL_0029: call instance bool [mscorlib]System.Runtime.CompilerServices.TaskAwaiter::get_IsCompleted() IL_002e: brtrue.s IL_0070 IL_0030: ldarg.0 IL_0031: ldc.i4.0 IL_0032: dup IL_0033: stloc.0 IL_0034: stfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_0039: ldarg.0 IL_003a: ldloc.2 IL_003b: stfld valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;u__1' IL_0040: ldarg.0 IL_0041: stloc.3 IL_0042: ldarg.0 IL_0043: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt; Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;t__builder' IL_0048: ldloca.s 2 IL_004a: ldloca.s 3 IL_004c: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt;::AwaitUnsafeOnCompleted&lt;valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter, class Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'&gt;(!!0&amp;, !!1&amp;) IL_0051: nop IL_0052: leave.s IL_00b8 IL_0054: ldarg.0 IL_0055: ldfld valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;u__1' IL_005a: stloc.2 IL_005b: ldarg.0 IL_005c: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;u__1' IL_0061: initobj [mscorlib]System.Runtime.CompilerServices.TaskAwaiter IL_0067: ldarg.0 IL_0068: ldc.i4.m1 IL_0069: dup IL_006a: stloc.0 IL_006b: stfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_0070: ldloca.s 2 IL_0072: call instance void [mscorlib]System.Runtime.CompilerServices.TaskAwaiter::GetResult() IL_0077: nop IL_0078: ldloca.s 2 IL_007a: initobj [mscorlib]System.Runtime.CompilerServices.TaskAwaiter IL_0080: ldarg.0 IL_0081: ldfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;one&gt;5__1' IL_0086: stloc.1 IL_0087: leave.s IL_00a3 } // end .try catch [mscorlib]System.Exception { IL_0089: stloc.s 4 IL_008b: ldarg.0 IL_008c: ldc.i4.s -2 IL_008e: stfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_0093: ldarg.0 IL_0094: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt; Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;t__builder' IL_0099: ldloc.s 4 IL_009b: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt;::SetException(class [mscorlib]System.Exception) IL_00a0: nop IL_00a1: leave.s IL_00b8 } // end handler IL_00a3: ldarg.0 IL_00a4: ldc.i4.s -2 IL_00a6: stfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_00ab: ldarg.0 IL_00ac: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt; Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;t__builder' IL_00b1: ldloc.1 IL_00b2: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt;::SetResult(!0) IL_00b7: nop IL_00b8: ret } // end of method '&lt;MethodTaskAsync&gt;d__0'::MoveNext .method private final hidebysig newslot virtual instance void SetStateMachine ( class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine stateMachine ) cil managed { .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) .override method instance void [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine::SetStateMachine(class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine) // Method begins at RVA 0x21d0 // Code size 1 (0x1) .maxstack 8 IL_0000: ret } // end of method '&lt;MethodTaskAsync&gt;d__0'::SetStateMachine } // end of class &lt;MethodTaskAsync&gt;d__0</code> </pre> <br></div></div><br><h3>  MoveNext method </h3><br>  The class that was created for the MethodTask type implements the IAsyncStateMachine interface, which represents state machines created for asynchronous methods.  This type is intended only for use by the compiler.  This interface contains the following members: MoveNext and SetStateMachine.  The MoveNext method moves the state machine to its next state.  This method contains the original code and is called both when the method is first entered and after await.  It is believed that any state machine starts its work in some initial state.  Even in the case of the simplest async method, the MoveNext code is surprisingly complex, so I will try to describe it and present it as precisely as possible in C # equivalent. <br><br>  <i>The MoveNext method is named this way because of its similarity to the MoveNext methods that were generated by iterator blocks in previous versions of C #.</i>  <i>These blocks allow you to implement an IEnumerable interface in a single method using the yield return keyword.</i>  <i>The state machine used for this purpose is in many ways reminiscent of an asynchronous machine, only simpler.</i> <br><br>  Consider the intermediate code and analyze what happens in it (I want to note that below I decided to fully describe the CIL language for a more complete review of what the compiler generates, and also described all the instructions, so that you are not interested in technical details): <br><pre> <code class="tex hljs">.locals init ( [0] int32, [1] int32, [2] valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter, [3] class Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0', [4] class [mscorlib]System.Exception )</code> </pre><br><ul><li>  <i>localsinit</i> is a flag that is set for a method and is used to initialize local instances of value types.  It is defined in the method header and means that the variables must be initialized in CIL.  All instances that will be used in this method are defined here, and they are defined as an array and are set by default, as is customary: NULL value for object types and for value type fields containing objects, 0 for integer types, and 0.0 for types with floating point. <br><br>  Thus, upon entering the method, we already have ready local variables for their use in the method. </li><li>  <i>valuetype</i> - means that it is a significant type, i.e.  structure </li></ul><br><br><pre> <code class="tex hljs"> IL_0000: ldarg.0 IL_0001: ldfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_0006: stloc.0</code> </pre> <br><ul><li>  <i>ldarg.0</i> - loads argument 0 to the stack.  An argument with index 0 is loaded onto the calculation stack (the intermediate .NET language is a stack) copied from the input argument.  But we have no arguments in the method!  The fact is that by default in non-static methods, the argument with index 0 is always a pointer to an instance of the class ‚Äî this.  If you have arguments, they will already have an index of 1, 2, etc.  In a static method, your arguments will start counting from 0. </li><li>  <i>ldfld</i> - searches for the value of a field in an object referenced in the stack.  And the link itself was loaded higher with ldarg.0, while the value that was stored in this field, respectively, was loaded onto the stack. </li><li>  <i>stloc.0</i> - retrieves the top value in the stack (this is the value of the field of the MethodTaskAsync.state object) and stores it in the list of local variables with index 0. And the list of local variables was also declared in localsinit.  Convenient, isn't it? </li></ul><br><br><pre> <code class="tex hljs"> IL_0007: ldloc.0 IL_0008: brfalse.s IL_000c IL_000a: br.s IL_000e IL_000c: br.s IL_0054 IL_000e: nop IL_000f: ldarg.0 IL_0010: ldc.i4.s 33 IL_0012: stfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;one&gt;5__1' IL_0017: ldc.i4 1000 IL_001c: call class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.Task::Delay(int32) IL_0021: callvirt instance valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter [mscorlib]System.Threading.Tasks.Task::GetAwaiter() IL_0026: stloc.2 IL_0027: ldloca.s 2 IL_0029: call instance bool [mscorlib]System.Runtime.CompilerServices.TaskAwaiter::get_IsCompleted() IL_002e: brtrue.s IL_0070</code> </pre><br><ul><li>  <i>ldloc.0 and brfalse.s</i> - loads a local variable with index 0 <i>onto</i> the calculation stack.  Here, the state value just saved is loaded onto the stack, and the brfalse.s command transfers control to the final instruction if the state value is false, i.e.  0. When you first enter the method, the value is -1, which means that the flow of instructions goes on. </li><li>  <i>br.s IL_000e</i> - unconditional transmission of the final instruction.  This will jump to another part of the code that needs to be executed.  In this case, the next command will be executed on the IL_000e line. </li><li>  <i>br.s IL_0054</i> is also an unconditional jump, only this command will be executed if the brfalse.s command is executed </li><li>  <i>nop</i> - Fills the space if the opcodes contain corrections.  No significant operations are performed, although the processing cycle can be completed. </li><li>  <i>ldarg.0 and ldc.i4.s 33</i> - here the this pointer is loaded, and the number 33 is loaded onto the stack, where ldc.i4.s - pushes the value with the Int8 type onto the calculation stack as Int32 (short form). </li><li>  <i>stfld</i> - replaces the value in the field of the object, by reference to the object with a new value.  Using the loaded pointer and the number 33 on the stack, the member variable &lt;one&gt; 5_1 (initialized by default 0) loads and stores the new value - 33. As we can see, this is the first line of our original method.  It is in this block that the code of the original method is executed. </li><li>  <i>ldc.i4 1000</i> - load a variable with Int32 type as Int32 into the stack. </li><li>  <em>call class [mscorlib] System.Threading.Tasks.Task [mscorlib] System.Threading.Tasks.Task :: Delay (int32)</em> - the method is called here.  A feature of this instruction (as compared to the callvirt instruction) is that the address of the called method is calculated statically, that is, even during JIT compilation.  In this case, the Delay method is static.  In this case, the parameters of the called method must be located in the stack from left to right, that is, first the first parameter must be loaded onto the stack, then the second, and so on. </li><li>  <i>callvirt instance valuetype [mscorlib] System.Runtime.CompilerServices.TaskAwaiter [mscorlib] System.Threading.Tasks.Task :: GetAwaiter ()</i> - this instruction differs from call mainly because the address of the called method is determined during program execution by analyzing the type the object for which the method is being called.  This implements the idea of ‚Äã‚Äãlate binding, necessary to support polymorphism.  In this case, the return value (in this case TaskAwaiter) is pushed onto the stack, where TaskAwaiter represents an object that is waiting for the asynchronous task to complete. </li><li>  <i>stloc.2</i> - retrieves the top value in the stack and stores it in the list of local variables with index 2. It should be noted that the top value on the stack is the result of the <i>GetAwaiter ()</i> operation and, accordingly, this value is stored in a local variable with index 2 </li><li>  <i>ldloca.s 2</i> - loads a local value with index 2 <i>onto the</i> stack - newly saved value </li><li>  <i>call instance bool [mscorlib] System.Runtime.CompilerServices.TaskAwaiter :: get_IsCompleted ()</i> - a load on the stack of a value indicating whether the task was completed at the time the property was called: true or false </li><li>  <i>brtrue.s IL_0070</i> - if the task is completed, go to the execution of another part of the code, if not, go ahead. </li></ul><br>  Thus, you can submit a code similar to the following: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.one = <span class="hljs-number"><span class="hljs-number">33</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> awaiter = task.GetAwaiter(); <span class="hljs-comment"><span class="hljs-comment">//  ,     ,     (  IL-) if(!awaiter.IsCompleted) { ... return; } } ... //  }</span></span></code> </pre><br>  The code presented above is responsible for the initial state of the state machine and checks the completeness of the asynchronous task and goes to the right place of the method.  In this case, a transition occurs to one of several states of the automaton: the method is suspended at the await meeting point or synchronous completion. <br><br><h4>  Method suspension </h4><br>  Consider the IL-code in place of the suspension method: <br><pre> <code class="tex hljs"> IL_0030: ldarg.0 IL_0031: ldc.i4.0 IL_0032: dup IL_0033: stloc.0 IL_0034: stfld int32 Asynchronous.Program/'&lt;MethosTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_0039: ldarg.0 IL_003a: ldloc.2 IL_003b: stfld valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter Asynchronous.Program/'&lt;MethosTaskAsync&gt;d__0'::'&lt;&gt;u__1' IL_0040: ldarg.0 IL_0041: stloc.3 IL_0042: ldarg.0 IL_0043: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt; Asynchronous.Program/'&lt;MethosTaskAsync&gt;d__0'::'&lt;&gt;t__builder' IL_0048: ldloca.s 2 IL_004a: ldloca.s 3 IL_004c: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt;::AwaitUnsafeOnCompleted&lt;valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter, class Asynchronous.Program/'&lt;MethosTaskAsync&gt;d__0'&gt;(!!0&amp;, !!1&amp;) IL_0051: nop IL_0052: leave.s IL_00b8</code> </pre><br>  Describe each operation is not worth it, since everything is already described above. <br><ul><li>  This piece of code is responsible for changing the state variable to 0, where the <i>stfld int32 Asynchronous.Program / 'd__0' :: '&lt;&gt; 1__state' command will</i> <s>repeat</s> means changing the field value to a new value.  And to resume from the right place, you need to change the state variable. <br></li><li>  Then, the <i>TaskAwaiter</i> object is <i>used</i> to subscribe to the <i>Task</i> completion notification.  This happens when a local variable with index 2 is <i>loaded onto the stack</i> and the field value is changed to the value of this local variable ( <i>ldloc.2</i> and <i>stfld valuetype [mscorlib] System.Runtime.CompilerServices.TaskAwaiter Asynchronous.Program / 'd__0' :: '&lt;&gt; command u__1 '</i> ).         ,      . <br></li><li>         <i>AwaitUnsafeOnCompleted</i> .      await,      ,      .                 awaiter.   : <i>AsyncTaskMethodBuilder.AwaitOnCompleted(ref TAwaiter awaiter, ref TStateMachine stateMachine)</i> .               2  3,  2 ‚Äî <i>valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter, 3 ‚Äî class Asynchronous.Program/'d__0'</i> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's take a closer look at the AsyncTaskMethodBuilder structure (I will not dig deeply here, because in my opinion, the study of this structure and everything connected with it can be described, as it were, not for a few articles): </font></font><br><pre> <code class="hljs pgsql"> /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(TResult).&lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-type"><span class="hljs-type">internal</span></span> readonly static Task&lt;TResult&gt; s_defaultResultTask = AsyncTaskCache.CreateCacheableTask(<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(TResult)); /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;,   IAsyncStateMachine.&lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; private AsyncMethodBuilderCore m_coreState; // mutable struct: must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> be readonly /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;  &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; private Task&lt;TResult&gt; m_task; // lazily-initialized: must <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> be readonly /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///       ,  awaiter  /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;typeparam <span class="hljs-type"><span class="hljs-type">name</span></span>="TAwaiter"&gt;  awaiter.&lt;/typeparam&gt; /// &lt;typeparam <span class="hljs-type"><span class="hljs-type">name</span></span>="TStateMachine"&gt;   .&lt;/typeparam&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="awaiter"&gt;The awaiter.&lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="stateMachine"&gt; .&lt;/param&gt; [SecuritySafeCritical] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : ICriticalNotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine { try { AsyncMethodBuilderCore.MoveNextRunner runnerToInitialize = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; var continuation = m_coreState.GetCompletionAction(AsyncCausalityTracer.LoggingOn ? this.Task : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> runnerToInitialize); //    await,            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_coreState.m_stateMachine == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { //         var builtTask = this.Task; //      <span class="hljs-type"><span class="hljs-type">internal</span></span>-, //      . m_coreState.PostBoxInitialization(stateMachine, runnerToInitialize, builtTask); } awaiter.UnsafeOnCompleted(continuation); } catch (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> e) { AsyncMethodBuilderCore.ThrowAsync(e, targetContext: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider briefly what is inside this structure: </font></font><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s_defaultResultTask = AsyncTaskCache.CreateCacheableTask (default (TResult))</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a task is created here without implementing Dispose with the special flag </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DoNotDispose</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This approach is used when creating tasks for caching or reuse.</font></font></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AsyncMethodBuilderCore m_coreState</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - represents the state associated with the execution of IAsyncStateMachine. </font><font style="vertical-align: inherit;">This is a structure.</font></font></li><li> <i>AsyncMethodBuilderCore.MoveNextRunner runnerToInitialize</i> ‚Äî       MoveNext     .  ,    ,        MoveNext. </li><li> <i>m_coreState.GetCompletionAction(AsyncCausalityTracer.LoggingOn? this.Task: null, ref runnerToInitialize)</i> ‚Äî  Action    UnsafeOnCompleted      .         . </li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaiter.UnsafeOnCompleted (continuation)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - plans to continue the actions that will be called when the instance completes execution. </font><font style="vertical-align: inherit;">In this case, depending on whether we need to restore the context or not, the MoveNext method will be called, respectively, with the context and method suspension, or execution will continue in the context of the thread in which the task was executed.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We get a slightly different source code: </font></font><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.one = <span class="hljs-number"><span class="hljs-number">33</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> awaiter = task.GetAwaiter(); <span class="hljs-comment"><span class="hljs-comment">//  ,     ,     (  IL-) if(!awaiter.IsCompleted) { this.1_state = 0; this.u__awaiter = awaiter; //u__awaiter   TaskAwaiter t_builder.AwaitUnsafeOnCompleted(ref this.u_awaiter, ref &lt;MethodTaskAsync&gt;d__0); return; } } ... //  }</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Method renewal </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After executing this piece of code, the calling thread leaves to go about its business, and in the meantime we are waiting for the task to complete. </font><font style="vertical-align: inherit;">Once the task has been completed, the method is called again </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (with the method call </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> done everything necessary for work). </font><font style="vertical-align: inherit;">Consider the IL code that is invoked during the continuation:</font></font><br><pre> <code class="tex hljs"> IL_0054: ldarg.0 IL_0055: ldfld valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;u__1' IL_005a: stloc.2 IL_005b: ldarg.0 IL_005c: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.TaskAwaiter Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;u__1' IL_0061: initobj [mscorlib]System.Runtime.CompilerServices.TaskAwaiter IL_0067: ldarg.0 IL_0068: ldc.i4.m1 IL_0069: dup IL_006a: stloc.0 IL_006b: stfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_0070: ldloca.s 2 IL_0072: call instance void [mscorlib]System.Runtime.CompilerServices.TaskAwaiter::GetResult() IL_0077: nop IL_0078: ldloca.s 2 IL_007a: initobj [mscorlib]System.Runtime.CompilerServices.TaskAwaiter IL_0080: ldarg.0 IL_0081: ldfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;one&gt;5__1' IL_0086: stloc.1 IL_0087: leave.s IL_00a3 IL_00a3: ldarg.0 IL_00a4: ldc.i4.s -2 IL_00a6: stfld int32 Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;1__state' IL_00ab: ldarg.0 IL_00ac: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt; Asynchronous.Program/'&lt;MethodTaskAsync&gt;d__0'::'&lt;&gt;t__builder' IL_00b1: ldloc.1 IL_00b2: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1&lt;int32&gt;::SetResult(!0) IL_00b7: nop</code> </pre><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first part, the argument with the index 0 is loaded - this is this, then the search for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskAwaiter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;&gt; u__1 variable is stored, its value is stored in a local variable with the index 2, and then reinitialized. </font><font style="vertical-align: inherit;">After this, the value -1 is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loaded onto the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stack and the value is stored in the </font><i><font style="vertical-align: inherit;">1__state</font></i><font style="vertical-align: inherit;"> variable </font><font style="vertical-align: inherit;">. The task state is reset in this way.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the second part, the local variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaiter is loaded onto the stack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetResult () is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called. </font><font style="vertical-align: inherit;">Then a new load on the stack of a local variable and its new initialization. </font><font style="vertical-align: inherit;">Then the variable is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loaded onto the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stack </font><i><font style="vertical-align: inherit;">5__1</font></i><font style="vertical-align: inherit;"> and stored in a local variable with index 1 and the transition to another command.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the third part, loading the stack with the value -2 and saving it in the variable 1_state. </font><font style="vertical-align: inherit;">Then load the t_builder variable onto the stack and call the SetResult (one) method.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a result, the approximate source code: </font></font><br><pre> <code class="hljs coffeescript">public void MoveNext() { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_state) { case <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.one = <span class="hljs-number"><span class="hljs-number">33</span></span>; var task = Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); var awaiter = task.GetAwaiter(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     ,     (  IL-) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!awaiter.IsCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.u__awaiter = awaiter; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>u__awaiter   TaskAwaiter t_builder.AwaitUnsafeOnCompleted(ref <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.u_awaiter, ref &lt;MethodTaskAsync&gt;d__0); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } case <span class="hljs-number"><span class="hljs-number">0</span></span>: var awaiter = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.u_awaiter; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.u_awaiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Runtime.CompilerServices.TaskAwaiter(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; awaiter.GetResult(); awaiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Runtime.CompilerServices.TaskAwaiter(); var one = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.&lt;one&gt;<span class="hljs-number"><span class="hljs-number">5</span></span>_1; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_state = <span class="hljs-number"><span class="hljs-number">-2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.t_builder.SetResult(one); } }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Synchronous completion </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of synchronous completion, do not stop and resume the method. </font><font style="vertical-align: inherit;">In this case, you just need to check the execution of the method and go to the right place with the help of the goto case operator:</font></font><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.one = <span class="hljs-number"><span class="hljs-number">33</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> awaiter = task.GetAwaiter(); <span class="hljs-comment"><span class="hljs-comment">//  ,     ,     (  IL-) if(awaiter.IsCompleted) { goto case 0; } case 0: this.1_state = 0; ... } }</span></span></code> </pre><br> <i>    ,      ,   goto    .</i> <br><br><h3>  And finally ... </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, I relied on one of my favorite books on asynchronous programming in C # 5.0 by Alex Davis. In general, I advise everyone to read it, because it is small (if you wish, you can read it in one day) and very interestingly and fairly describes in detail the async / await mechanism as a whole. In this case, you can read and beginners, everything is very simply written (examples from life and the like). While reading it and studying the IL-code in parallel, I found a slight discrepancy with what is written in the book and there really is. But I think that the most likely thing is that most likely since then a little bit has changed the compiler and it began to produce slightly different results. But it is not so critical to get hung up on it. At the same time as the source code (to describe AsyncTaskMethodBuilder used this resource:</font></font><a href="http://referencesource.microsoft.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is if anyone would be interested to dig even deeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></div><p>Source: <a href="https://habr.com/ru/post/260217/">https://habr.com/ru/post/260217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260193/index.html">Fun starts 2: for_each vs accumulate</a></li>
<li><a href="../260197/index.html">Elvish programming language</a></li>
<li><a href="../260201/index.html">Upgrade to Middle PHP developer in 3 months</a></li>
<li><a href="../260213/index.html">Introducing OsmocomBB: 0x03 Software</a></li>
<li><a href="../260215/index.html">ReactOS has significantly improved support for themes.</a></li>
<li><a href="../260219/index.html">Semishagovy test logo Paul Rand</a></li>
<li><a href="../260221/index.html">A bit about unit testing and external APIs in PHP</a></li>
<li><a href="../260223/index.html">Why Go is doomed to success (updated)</a></li>
<li><a href="../260225/index.html">Vulnerability in Mail in iOS 8.3</a></li>
<li><a href="../260227/index.html">9 anti-patterns every programmer should know about</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>