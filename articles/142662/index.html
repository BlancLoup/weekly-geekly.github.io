<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dot the C / C ++ structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I got acquainted with C / C ++ - struct structures. Lord, yes, "what to get acquainted with them," you say? Thus, you will make two mistakes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dot the C / C ++ structures</h1><div class="post__text post__text-html js-mediator-article">  Recently I got acquainted with C / C ++ - struct structures.  Lord, yes, "what to get acquainted with them," you say?  Thus, you will make two mistakes <s>at</s> once: <s>first, I am not Lord</s> , and secondly, I also thought that structures are structures in Africa.  But as it turned out and - no.  I will talk about a few vital details that will relieve any of the readers of hourly debugging ... <br><br><img src="https://habrastorage.org/storage2/661/34a/dd9/66134add996734e82d2efd38d6655056.png"><br><a name="habracut"></a><br><br><h3>  Field alignment in memory </h3><br>  Pay attention to the structure: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; };</code> </pre> <br>  Well, firstly, what is the size of this structure in memory?  <code>sizeof(Foo)</code> ? <br>  The size of this structure in memory depends on the compiler settings and on the directives in your code ... <br><br>  In general, the fields in memory are aligned at the boundary with a multiple of its size.  That is, 1-byte fields are not aligned, 2-byte fields are aligned to even positions, 4-byte fields are multiples of four, and so on.  In most cases (or just assume that this is the case today), the alignment of the size of the structure in memory is 4 bytes.  Thus, <code>sizeof(Foo) == 8</code> .  Where and how will stick extra 3 bytes?  If you do not know - you will never guess ... <br><br><ul><li>  1 byte: ch </li><li>  2 bytes: <u>empty</u> </li><li>  3 bytes: <u>empty</u> </li><li>  4 bytes: <u>empty</u> </li><li>  5 bytes: value [0] </li><li>  6 bytes: value [1] </li><li>  7 bytes: value [2] </li><li>  8 bytes: value [3] </li></ul><br>  Let us now see the placement in memory of the following structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; };</code> </pre> <br>  It looks like this: <br><br><ul><li>  1 byte: ch </li><li>  2 bytes: <u>empty</u> </li><li>  3 bytes: id [0] </li><li>  4 bytes: id [1] </li><li>  5 bytes: value [0] </li><li>  6 bytes: value [1] </li><li>  7 bytes: value [2] </li><li>  8 bytes: value [3] </li></ul><br>  That is, the fact that you can shove up to 4 byte alignment is crammed with a bang (without increasing the size of the structure in memory), add another field: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> opt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; };</code> </pre> <br>  Let's look at the placement of fields in memory: <br><br><ul><li>  1 byte: ch </li><li>  2 bytes: <u>empty</u> </li><li>  3 bytes: id [0] </li><li>  4 bytes: id [1] </li><li>  5 bytes: opt [0] </li><li>  6 bytes: opt [1] </li><li>  7 bytes: <u>empty</u> </li><li>  8 bytes: <u>empty</u> </li><li>  9 bytes: value [0] </li><li>  10 bytes: value [1] </li><li>  11 bytes: value [2] </li><li>  12 bytes: value [3] </li></ul><br>  All this is oh so sad, but there is a way to deal with it right from the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) struct Foo { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... }; #pragma pack(pop)</span></span></span></span></code> </pre> <br>  We set the alignment size to 1 byte, described the structure, and returned the previous setting.  Return the previous setting - strongly recommend.  Otherwise, everything can end very badly.  I once had this - Qt fell.  Somewhere I stumbled their .h-nick below his .h-nick ... <br><br><h3>  Bit fields </h3><br>  <i>In the comments, they pointed out to me that the bit fields in the structures according to the standard are <b>‚Äúimplementation defined‚Äù</b> - therefore, it is better to avoid using them, but for me the temptation is too great ...</i> <br><br>  I‚Äôm getting not so much restlessness in my heart, but generally it‚Äôs getting bad, when I see in the code the filling of bit fields with the help of masks and shifts, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> field = <span class="hljs-number"><span class="hljs-number">0x00530000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... field &amp;= 0xFFFF00FF; field |= (id) &lt;&lt; 8; // ... field &amp;= 0xFFFFFF83; field |= (proto) &lt;&lt; 2;</span></span></code> </pre> <br>  All this smells of such sadness and such errors and their debugging, that I immediately start a migraine!  And here from behind the scenes they come out - Bit Fields.  What is most surprising is that they were still in C, but whoever I ask, everyone hears about them for the first time.  This chaos must be corrected.  Now I will give them all a link, or at least a link to this article. <br><br>  How do you like this piece of code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push,1) struct IpHeader { uint8_t header_length:4; uint8_t version:4; uint8_t type_of_service; uint16_t total_length; uint16_t identificator; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Flags uint8_t _reserved:1; uint8_t dont_fragment:1; uint8_t more_fragments:1; uint8_t fragment_offset_part1:5; uint8_t fragment_offset_part2; uint8_t time_to_live; uint8_t protocol; uint16_t checksum; // ... }; #pragma pack(pop)</span></span></span></span></code> </pre> <br>  And further in the code we can work with fields as we always work with fields in C / C ++.  All work on shifts, etc.  compiler takes over.  Of course there are some limitations ... When you list several bit fields in a row that belong to the same physical field (I mean the type that is to the left of the bit field name), specify the names for all bits to the end of the field, otherwise you will not have access to these bits will be, <s>in other words</s> code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push,1) stuct MyBitStruct { uint16_t a:4; uint16_t b:4; uint16_t c; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(pop)</span></span></code> </pre> <br>  The structure turned out to be 4 bytes!  The two halves of the first byte are the fields <code>a</code> and <code>b</code> .  The second byte is not available by name and the last 2 bytes are available by name <code>c</code> .  This is a very dangerous moment.  After you have described the structure with bit fields, be sure to check its <code>sizeof</code> ! <br><br>  Also, the order of placement of bit pains in a byte depends on the byte order.  When the order is LITTLE_ENDIAN, the bit fields are distributed starting from the first bytes, with BIG_ENDIAN - on the contrary ... <br><br><h3>  Byte order </h3><br>  I am also saddened in the code by the calls of the functions <code>htons()</code> , <code>ntohs()</code> , <code>htonl()</code> , <code>nthol()</code> in the code in C ++.  In C, this is still valid, but not in C ++.  I will never accept this!  Attention all of the following applies to C ++! <br><br>  Well, here I will be brief.  I have already written in <a href="http://habrahabr.ru/post/121811/">one of my previous articles</a> what to do with byte orders.  It is possible to describe structures that externally work as numbers, and inside they themselves determine the storage order in bytes.  So our IP header structure will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push,1) struct IpHeader { uint8_t header_length:4; uint8_t version:4; uint8_t type_of_service; u16be total_length; u16be identificator; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Flags uint8_t _reserved:1; uint8_t dont_fragment:1; uint8_t more_fragments:1; uint8_t fragment_offset_part1:5; uint8_t fragment_offset_part2; uint8_t time_to_live; uint8_t protocol; u16be checksum; // ... }; #pragma pack(pop)</span></span></span></span></code> </pre> <br>  Attention is <a href="http://habrahabr.ru/post/121811/"><code>u16be</code></a> to the types of 2-byte fields - <a href="http://habrahabr.ru/post/121811/"><code>u16be</code></a> .  Now the structure fields do not need any byte conversion.  There are problems with <code>fragment_offset</code> , but whoever does not have them, there are problems.  Nevertheless, you can also create a template that hides this disgrace, test it once and boldly use it in all of your code. <br><br>  <i>"The C ++ language is complicated enough to allow us to write on it simply"</i> ¬© Oddly enough - I <br><br>  <b>ZY</b>  I plan in one of the following articles to lay out the ideal, from my point of view, structures for working with the TCP / IP stack protocol headers.  Speak - it's not too late! </div><p>Source: <a href="https://habr.com/ru/post/142662/">https://habr.com/ru/post/142662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142652/index.html">Data collection from recording devices</a></li>
<li><a href="../142657/index.html">The interior of the boolinq for adults</a></li>
<li><a href="../142658/index.html">UEFA shows how not to make a survey form on the site</a></li>
<li><a href="../142659/index.html">SkyDrive cloud storage received a big update</a></li>
<li><a href="../142661/index.html">New Galaxy</a></li>
<li><a href="../142663/index.html">Oh, an! - You've got an App</a></li>
<li><a href="../142664/index.html">Top 100 ZX Spectrum Games for iOS</a></li>
<li><a href="../142665/index.html">Webmoney Mini for Linux</a></li>
<li><a href="../142667/index.html">Cheat Sheet on Perl Mock Objects</a></li>
<li><a href="../142668/index.html">Real Unfair Competitive Advantage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>