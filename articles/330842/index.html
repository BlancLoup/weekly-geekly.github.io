<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hacking Age of Mythology: Turning off the Fog of War</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Age of Mythology is a real-time strategy game in which the player seeks to build his civilization and defeat all enemies. In standard m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hacking Age of Mythology: Turning off the Fog of War</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  <a href="https://ru.wikipedia.org/wiki/Age_of_Mythology">Age of Mythology</a> is a real-time strategy game in which the player seeks to build his civilization and defeat all enemies.  In standard mode, the player starts the game on a map completely blacked out, which means unknown and unexplored territory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35e/91f/3d4/35e91f3d40cc9ce1579d0cf328674d86.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdb/b81/e63/fdbb81e639a960f2f17099f162a8d064.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      During the game, the user explores the map, and terrain designations, resources, enemy structures appear on the studied areas, which are superimposed with a "fog of war", denoting the investigated territory that the player does not see. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/43b/968/571/43b96857161b2ed044a8294a8d5af9bd.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b5/dd8/491/4b5dd8491594c77a0c5b4eacdf4f5d31.png"><br><br>  The goal of this post will be to create the hack that opens the entire map, giving the player a significant advantage.  He will allow the player to see what opponents are doing on the map and choose the best time and place to attack.  This hack will be developed for the original version of the game, but later I will show how to apply it to the new, expanded version, which is now being distributed to <a href="http://store.steampowered.com/app/266840/">Steam</a> . <br><br>  Here are the hashes for the main executable file, which will be parsed by reverse engineering in this article: <br><br>  <font color="#ff6600"><strong>CRC32</strong></font> : 7F1AF498 <br>  <font color="#ff6600"><strong>MD5</strong></font> : 09876F130D02AE760A6B06CE6A9C92DB <br>  <font color="#ff6600"><strong>SHA-1</strong></font> : AAAC9CD38B51BEB3D29930D13A87C191ABF9CAD4 <br><br><h2>  Part one: the hard way </h2><br><h3>  Getting started </h3><br>  Our goal is to develop what will open the player all the card data, giving the player complete information about what is happening in the game.  The good news: the disclosure and concealment of the card is the built-in functionality of the game.  The game supports playback of recorded games, and the option of disclosing-hiding the card is part of the UI of this function. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/047/23b/003/04723b003f4051c62af1f907008c7746.png"><br><br>  The ‚ÄúFog of War‚Äù button controls the disclosure of the map and the return to the normal state in which the player sees only what he has investigated.  The plan is to find the handler for this button and trace the location of the disclosure logic.  Having found it, we simply execute the injection DLL in the game process to call the map disclosure function.  For this job, a tool like <a href="http://www.cheatengine.org/">Cheat Engine</a> is useful, which is useful for examining and modifying memory, debugging, disassembling, and other operations in the context of hacking games.  In this article I will not describe the work with this tool, for this there are many other resources. <br><br>  After starting and connecting the Cheat Engine, the question is where the code interacts with the button.  The easiest way to find out is to use standard programming practices.  In particular, the active button will have a value of 1 somewhere in memory, and an inactive one will have a value of 0. Therefore, it becomes a matter of testing and patience.  A search in the process memory of the value ‚Äú1‚Äù (when the button is active) returned 337,597 results.  If you try to do the same, do not expect the values ‚Äã‚Äãto be the same. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e5/cdf/ce4/6e5cdfce49a497a3e2182cc02ebae00c.png"><br><br>  This is too much to check.  Press the button again to make it inactive, and search for the value "0".  The program will return 376 - still too much. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/555/e3b/a2b/555e3ba2b4a35a01d649bde1c1a35800.png"><br><br>  Repeating this process several times reduced the search area to the already quite convenient 21 addresses. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b5/0ee/816/5b50ee8160565b5a23173c554d163deb.png"><br><br>  20 of these 21 were very close to each other.  <em>0x08FC71A4</em> seemed to be an exception in this series.  After studying it more carefully and changing the value "0", it was possible to switch the button to an inactive state.  So, we found the right address, and the rest 20 can be safely discarded.  The next step is to find out what is recording it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0c/91c/130/a0c91c130800b5122cd8b2986b80c78b.png"><br><br>  At this stage, the Cheat Engine <em>turns on the</em> debugger and tracks all write operations at <em>0x08FC71A4</em> .  After several button presses, the following commands were revealed.  These commands recorded at <em>0x08FC71A4</em> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1af/967/d0d/1af967d0d2eccad7013f7ba0865724e0.png"><br><br>  Next, you need to examine them and begin to set control points in order to better understand what is happening next to these write operations.  Checkpoint setting on write commands <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f73/2bf/7b2/f732bf7b250ba90029a4a4949e7aa431.png"><br><br>  and scuffling with the game allowed to find out that this function is called for each button.  Here <em>ECX</em> is a pointer to the button, and + <em>0x1A4</em> probably contains the <em>IsToggled</em> property, which assigns the corresponding button state.  This assignment is performed in the second write command, where <em>EDX</em> can be ‚Äú0‚Äù (inactive) or ‚Äú1‚Äù (active).  The code may seem a bit complicated, but it just checks that the enabled state is correct, and then sets the <em>IsToggled</em> property before calling the function and returning it. <br><br>  The recipient's address <em>+ 0x14B670</em> is also a code that applies to all buttons.  Here we need to slowly go around everything and find areas of code that can relate to the ‚ÄúFog of War‚Äù button.  You can apply different approaches, but I usually use the following: <br><br><ul><li>  Call addresses calculated by register.  This may mean an event handling mechanism, executed after a button's state changes, something like <em>OnChanged / OnEnabled / OnDisabled</em> or a similar function. </li><li>  Function parameters that are function pointers. </li><li>  Calls to functions that receive arguments 1 or 0. </li></ul><br>  A step at <em>+ 0x14B670</em> gives us the following (partial) assembler code presented below.  In the assembly code, absolute addresses are indicated, and not the address of the <em>beginning of the module in the memory + offset</em> , because they are much easier to copy from IDA than from the Cheat Engine. <br><br> <code>.text:0054B670 mov eax, large fs:0 <br> .text:0054B676 push 0FFFFFFFFh <br> .text:0054B678 push offset SEH_54B670 <br> .text:0054B67D push eax <br> .text:0054B67E mov large fs:0, esp <br> .text:0054B685 sub esp, 8 <br> .text:0054B688 push esi <br> .text:0054B689 mov esi, ecx <br> .text:0054B68B mov eax, [esi+148h] <br> .text:0054B691 push edi <br> .text:0054B692 mov edi, [esi] <br> .text:0054B694 push eax <br> .text:0054B695 push esi <br> .text:0054B696 lea ecx, [esp+24h+var_10] <br> <strong><font color="#ff0000">.text:0054B69A</font></strong> <font color="#ff0000"><strong>call sub_4D7470</strong></font> <br> .text:0054B69F mov ecx, [eax] <br> .text:0054B6A1 push ecx <br> .text:0054B6A2 push 1 <br> .text:0054B6A4 mov ecx, esi <br> <strong><font color="#0000ff">.text:0054B6A6</font></strong> <font color="#0000ff"><strong>call dword ptr [edi+54h]</strong></font> <br> .text:0054B6A9 cmp [esp+1Ch+arg_0], 0Dh <br> .text:0054B6AE jnz loc_54B769 <br> .text:0054B6B4 lea edi, [esi+154h] <br> ...</code> <br> <br>  It <em>turned</em> out that the call with a call at <em>0x004D7470</em> ( <font color="#ff0000">red</font> ) returns fairly quickly, so it will not be shown here.  The next call ( <font color="#0000ff">blue</font> ) in <em>+ 0x14B6A6</em> makes the call through the register.  This is a good candidate for careful study.  This function can call two possible addresses: <br><br> <code>... <br> .text:0054BF98 push 0Ch <br> <font color="#ff0000"><strong>.text:0054BF9A</strong></font> <font color="#ff0000"><strong>call dword ptr [eax+0CCh]</strong></font> <br> .text:0054BFA0 <br> .text:0054BFA0 loc_54BFA0: ; CODE XREF: sub_54BF80+Fj <br> .text:0054BFA0 ; sub_54BF80+14j <br> .text:0054BFA0 mov ecx, [esp+0Ch+arg_8] <br> .text:0054BFA4 push ecx <br> .text:0054BFA5 push edi <br> .text:0054BFA6 push ebx <br> .text:0054BFA7 mov ecx, esi <br> <strong><font color="#0000ff">.text:0054BFA9</font></strong> <font color="#0000ff"><strong>call sub_4D4EF0</strong></font> <br> .text:0054BFAE pop edi <br> ...</code> <br> <br>  The command at <em>+ 0x14BF9A</em> ( <font color="#ff0000">red</font> ) is never called when debugging and passing, so there is no point in studying it.  For research, only the next call to <em>+ 0x14BFA9</em> ( <font color="#0000ff">blue</font> ) remains.  This feature has proven to be very large in size and has a wide branch with many possible call points.  With debugging, you can skip most of this logic.  By tracing the code that is executed only when the ‚ÄúFog of War‚Äù button is active, we allocate only three call sites. <br><br> <code>... <br> .text:004D504C cmp esi, dword_A9D068 <br> .text:004D5052 jz short loc_4D5087 <br> .text:004D5054 push esi <br> <strong><font color="#ff0000">.text:004D5055 call sub_424750</font></strong> <br> .text:004D505A mov edi, eax <br> .text:004D505C add esp, 4 <br> .text:004D505F test edi, edi <br> .text:004D5061 jz short loc_4D5070 <br> .text:004D5063 push esi <br> <font color="#ff9900"><strong>.text:004D5064 call sub_4D58B0</strong></font> <br> .text:004D5069 add esp, 4 <br> .text:004D506C test edi, edi <br> .text:004D506E jnz short loc_4D5079 <br> .text:004D5070 <br> .text:004D5070 loc_4D5070: ; CODE XREF: sub_4D4EF0+171j <br> .text:004D5070 pop edi <br> .text:004D5071 pop esi <br> .text:004D5072 pop ebp <br> .text:004D5073 xor al, al <br> .text:004D5075 pop ebx <br> .text:004D5076 retn 0Ch <br> .text:004D5079 ; --------------------------------------------------------------------------- <br> .text:004D5079 <br> .text:004D5079 loc_4D5079: ; CODE XREF: sub_4D4EF0+17Ej <br> .text:004D5079 mov eax, [esp+10h+arg_4] <br> .text:004D507D mov edx, [edi] <br> .text:004D507F push ebp <br> .text:004D5080 push eax <br> .text:004D5081 push ebx <br> .text:004D5082 mov ecx, edi <br> <font color="#0000ff"><strong>.text:004D5084 call dword ptr [edx+54h]</strong></font> <br> .text:004D5087 <br> .text:004D5087 loc_4D5087: ; CODE XREF: sub_4D4EF0+157j <br> .text:004D5087 ; sub_4D4EF0+162j <br> .text:004D5087 pop edi <br> ...</code> <br> <br>  A call to <em>+ 0xD5055</em> ( <font color="ff0000">red</font> ) after tracing leads to a dead end.  The same applies to <em>+ 0xD5064</em> ( <font color="#ff9900">orange</font> ).  If you enter them using the debugger and start tracing the code execution path, it turns out that these two functions have very similar behavior.  However, nothing says that they have something in common with the operation of the Fog of War button in relation to the interaction with the map.  Setting a checkpoint on these two commands indicates that they are constantly being called from somewhere and only executes the logic of the caller.  At this stage, we are still in the general code relating to the UI and pressing the buttons, so it‚Äôs safe enough to calculate that these two functions have nothing to do with the disclosure of the map. <br><br>  The last place to call is <em>+ 0xD5084</em> ( <font color="#0000ff">blue</font> ).  Entry into it leads to <em>+ 0xD4EF0</em> , which is another big feature. <br><br> <code>.text:004D4EF0 push ebx <br> .text:004D4EF1 mov ebx, [esp+4+arg_0] <br> .text:004D4EF5 push ebp <br> .text:004D4EF6 mov ebp, [esp+8+arg_8] <br> .text:004D4EFA push esi <br> .text:004D4EFB mov esi, ecx <br> .text:004D4EFD mov ecx, [esi+0B8h] <br> ...</code> <br> <br>  If you put a control point in it, then it works all the time, that is, it is also a standard processing code.  If you go further, you can see that it returns to the code presented in the previous listing.  The same two calls to <strong><font color="#ff0000">0x00424750</font></strong> and <font color="#ff9900"><strong>0x004D58B0</strong></font> will be made.  Then the call is made to <font color="#0000ff"><strong>[EDX + 0x54]</strong></font> , but this time the <em>EDX</em> will have a different meaning.  In this second call, this leads to the following function at <em>+ 0xD0C70</em> : <br><br> <code>.text:004D0C70 mov ecx, [ecx+14Ch] <br> .text:004D0C76 test ecx, ecx <br> .text:004D0C78 jz short loc_4D0C91 <br> .text:004D0C7A mov edx, [esp+arg_8] <br> .text:004D0C7E mov eax, [ecx] <br> .text:004D0C80 push edx <br> .text:004D0C81 mov edx, [esp+4+arg_4] <br> .text:004D0C85 push edx <br> .text:004D0C86 mov edx, [esp+8+arg_0] <br> .text:004D0C8A push edx <br> <strong><font color="#0000ff">.text:004D0C8B call dword ptr [eax+30h]</font></strong> <br> .text:004D0C8E retn 0Ch <br> .text:004D0C91 ; --------------------------------------------------------------------------- <br> .text:004D0C91 <br> .text:004D0C91 loc_4D0C91: ; CODE XREF: sub_4D0C70+8j <br> .text:004D0C91 xor al, al <br> .text:004D0C93 retn 0Ch <br> .text:004D0C93 sub_4D0C70 endp</code> <br> <br>  There is only one real place to call, so this function is quite simple to analyze.  Setting a checkpoint indicates that it is being called from everywhere, that is, it is a common code.  Calling <font color="#0000ff"><strong>[EAX + 0x30]</strong></font> leads to <em>+ 0x680D0</em> .  Repeating the process with checkpoints shows that it is still called from everywhere, so there is nothing useful here. <br><br> <code>.text:004680D0 push 0FFFFFFFFh <br> .text:004680D2 push offset SEH_4680D0 <br> .text:004680D7 mov eax, large fs:0 <br> .text:004680DD push eax <br> .text:004680DE mov large fs:0, esp <br> .text:004680E5 sub esp, 0F8h <br> .text:004680EB mov eax, [esp+104h+arg_8] <br> .text:004680F2 push ebx <br> .text:004680F3 push ebp <br> .text:004680F4 push esi <br> .text:004680F5 mov esi, [esp+110h+arg_0] <br> .text:004680FC push edi <br> .text:004680FD mov ebp, ecx <br> .text:004680FF mov ecx, [esp+114h+arg_4] <br> .text:00468106 push eax <br> .text:00468107 push ecx <br> .text:00468108 push esi <br> .text:00468109 mov ecx, ebp <br> .text:0046810B mov [esp+120h+var_F0], ebp <br> <font color="#0000ff"><strong>.text:0046810F call sub_4718B0</strong></font> <br> .text:00468114 test al, al <br> ...</code> <br> <br><h3>  Search for a specific code </h3><br>  A step into the first place of a call at <em>+ 0x6810F</em> takes us to a function that contains a huge transition table (in the screenshot below).  This may be a promising indication that we have found an area managing events or executing event handling mechanisms. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/266/e88/37f/266e8837f6ceb98fc749eff96c717abf.png"><br><br>  Step-by-step code execution leads us to the following case: <br><br> <code>.text:00471DB4 loc_471DB4: ; CODE XREF: sub_4718B0+4FDj <br> .text:00471DB4 ; DATA XREF: .text:off_471FA0o <br> <font color="#ff99cc"><strong>.text:00471DB4 push edi ; jumptable 00471DAD case 4</strong></font> <br> <font color="#ff0000"><strong>.text:00471DB5 call sub_54E7D0</strong></font> <br> .text:00471DBA mov esi, eax <br> .text:00471DBC add esp, 4 <br> .text:00471DBF test esi, esi <br> .text:00471DC1 jz loc_471F5F ; jumptable 00471DAD case 3 <br> .text:00471DC7 push edi <br> <font color="#ff9900"><strong>.text:00471DC8 call sub_4D58B0</strong></font> <br> .text:00471DCD add esp, 4 <br> .text:00471DD0 test esi, esi <br> .text:00471DD2 jz loc_471F5F ; jumptable 00471DAD case 3 <br> <strong><font color="#00ccff">.text:00471DD8 mov edx, [esi+1A4h] <br> .text:00471DDE mov ecx, [esp+50h+var_40] <br> .text:00471DE2 cmp edx, ebx <br> .text:00471DE4 setz al <br> .text:00471DE7 push eax</font></strong> <br> <font color="#0000ff"><strong>.text:00471DE8 call sub_58EA10</strong></font> <br> .text:00471DED mov al, 1 <br> .text:00471DEF jmp loc_471F65 <br> ...</code> <br> <br>  By setting the control point to <em>+ 0x71DB4</em> ( <font color="#ff99cc">pink</font> ) and continuing, we found out that nothing more constantly gets here.  When you click on the button "Fog of War" we see that it is running <em>+ 0x71DB4</em> .  And finally, after a long trace, we get evidence that we are inside the code related to the ‚ÄúFog of War‚Äù button.  The first call command is at <em>+ 0x71DB5</em> ( <font color="#ff0000">red</font> ).  This function receives one parameter via <em>EDI</em> , and it is always a constant value.  By following the code step by step and carefully observing the values ‚Äã‚Äãof all parameters or address / load addresses, we do not find anything that indicates the value of the switch button.  In particular, by pressing the map-disclosing-hiding button and tracing the function, we did not find anything changing, so we excluded it.  The command at <em>+ 0x71DC8</em> ( <font color="#ff9900">orange</font> ) calls the address <em>0x004D58B0</em> , which we have already investigated above.  The same thing happens with the function.  It always gets the same value as the previous function and says nothing about whether it writes the switch value or controls the code based on this value. <br><br>  The next call is at <em>+ 0x71DE8</em> .  This function also receives one parameter and this is also the last function called before exiting the transition table processing function.  In the <font color="#00ccff">turquoise</font> block there is a very interesting code.  The value is loaded from <em>[ESI + 0x1A4]</em> , then compared to <em>EBX</em> .  The result of this comparison assigns the <em>AL</em> byte a value of 0 or 1. <em>EAX</em> , which will be 0 or 1, then passed as a function argument to the address <em>0x0058EA10</em> .  Pressing a button in the game and step through shows that <em>EBX</em> always contains the value 1, and <em>EDX</em> contains 0 or 1, depending on whether the map is hidden or uncovered.  It can be assumed that this is the function that is used to reveal and hide the map.  The assembly listing for <em>0x0058EA10 is</em> shown below: <br><br> <code>.text:0058EA10 sub_58EA10 proc near ; CODE XREF: sub_4718B0+538p <br> .text:0058EA10 ; sub_58DF30+919p ... <br> .text:0058EA10 <br> .text:0058EA10 arg_0 = dword ptr 4 <br> .text:0058EA10 <br> .text:0058EA10 push ebx <br> <font color="#339966"><strong>.text:0058EA11 mov ebx, [esp+4+arg_0]</strong></font> <br> .text:0058EA15 mov [ecx+53h], bl <br> .text:0058EA18 mov eax, dword_A9D244 <br> .text:0058EA1D mov ecx, [eax+140h] <br> .text:0058EA23 test ecx, ecx <br> .text:0058EA25 jz short loc_58EA43 <br> <strong><font color="#339966">.text:0058EA27 push 1 <br> .text:0058EA29 push ebx <br> .text:0058EA2A call sub_5316B0</font></strong> <br> .text:0058EA2F mov ecx, dword_A9D244 <br> .text:0058EA35 mov ecx, [ecx+140h] <br> <font color="#339966"><strong>.text:0058EA3B push 1 <br> .text:0058EA3D push ebx <br> .text:0058EA3E call sub_5316D0</strong></font> <br> .text:0058EA43 <br> .text:0058EA43 loc_58EA43: ; CODE XREF: sub_58EA10+15j <br> .text:0058EA43 pop ebx <br> .text:0058EA44 retn 4 <br> .text:0058EA44 sub_58EA10 endp <br></code> <br>  It passes the value 0 or 1 to two more functions, each of which takes two parameters.  The first parameter is the switching value 0 or 1, and the second is always a hard-coded value of 1. Looking at these two functions, you can see that they write a value of 0 or 1 to the object, and then call the function <br><br> <code>.text:005316B0 ; =============== SUBROUTINE ======================================= <br> .text:005316B0 <br> .text:005316B0 <br> .text:005316B0 public sub_5316B0 <br> .text:005316B0 sub_5316B0 proc near ; CODE XREF: sub_442070+1684p <br> .text:005316B0 ; sub_4C91E0+14Cp ... <br> .text:005316B0 <br> .text:005316B0 arg_0 = byte ptr 4 <br> .text:005316B0 arg_4 = dword ptr 8 <br> .text:005316B0 <br> .text:005316B0 mov edx, [esp+arg_4] <br> <font color="#ff9900"><strong>.text:005316B4 mov al, [esp+arg_0]</strong></font> <br> .text:005316B8 push edx <br> .text:005316B9 push 1 <br> <font color="#ff9900"><strong>.text:005316BB mov [ecx+40Eh], al</strong></font> <br> .text:005316C1 call sub_5316F0 <br> .text:005316C6 retn 8 <br> .text:005316C6 sub_5316B0 endp <br> .text:005316C6 <br> .text:005316C6 ; --------------------------------------------------------------------------- <br> .text:005316C9 align 10h <br> .text:005316D0 <br> .text:005316D0 ; =============== SUBROUTINE ======================================= <br> .text:005316D0 <br> .text:005316D0 <br> .text:005316D0 sub_5316D0 proc near ; CODE XREF: sub_442070+1698p <br> .text:005316D0 ; sub_4C91E0+137p ... <br> .text:005316D0 <br> .text:005316D0 arg_0 = byte ptr 4 <br> .text:005316D0 arg_4 = dword ptr 8 <br> .text:005316D0 <br> .text:005316D0 mov edx, [esp+arg_4] <br> <font color="#ff9900"><strong>.text:005316D4 mov al, [esp+arg_0]</strong></font> <br> .text:005316D8 push edx <br> .text:005316D9 push 1 <br> <font color="#ff9900"><strong>.text:005316DB mov [ecx+40Fh], al</strong></font> <br> .text:005316E1 call sub_5316F0 <br> .text:005316E6 retn 8 <br> .text:005316E6 sub_5316D0 endp</code> <br> <br>  Replacement patch <br>  <font color="#ff9900">mov al, [esp + arg_0]</font> <br>  on <br>  <font color="#ff9900">mov al, 0</font> <font color="#ff9900"><br></font>  <font color="#ff9900">nop</font> <font color="#ff9900"><br></font>  <font color="#ff9900">nop</font> <br>  leads to the fact that the mini-map is constantly open, regardless of the state of the ‚ÄúFog of War‚Äù button.  We found the code responsible for disclosing and hiding the card. <br><br><h3>  Hack development </h3><br>  At this stage, you can create a hack, it will be just a matter of calling <em>0x0058EA10</em> with a value of true / false, depending on the state of the map we need.  However, there is a small problem: there is a write command in <em>[ECX + 0x53]</em> at <em>0x0058EA15</em> .  This means that we will need to transfer to the address <em>+ 0x53</em> an object with a recordable field that will serve as the " <em>this</em> " parameter, usually transmitted via <em>ECX</em> using <em>__thiscall</em> .  <em>ECX is then</em> overwritten after loading from a fixed address, so this seems like a safe approach.  The dirty code for this task is below: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; struct DummyObj { char Junk[0x53]; }; DummyObj dummy = { 0 }; using pToggleMapFnc = void (__thiscall *)(void *pDummyObj, bool bHideAll); int APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) { switch (dwReason) { case DLL_PROCESS_ATTACH: { (void)DisableThreadLibraryCalls(hModule); pToggleMapFnc ToggleMap = (pToggleMapFnc)0x0058EA10; while (!GetAsyncKeyState('0')) { if (GetAsyncKeyState('7')) { ToggleMap(&amp;dummy, true); } else if (GetAsyncKeyState('8')) { ToggleMap(&amp;dummy, false); } Sleep(10); } break; } case DLL_PROCESS_DETACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: break; } return TRUE; }</span></span></span></span></code> </pre> <br>  After injection of the DLL into the game process, you can switch the card to a fully open or closed view using the ‚Äú7‚Äù and ‚Äú8‚Äù keys. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/413/9ef/328/4139ef3288ab661b58b60631ceebe2f1.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/eeb/a43/cac/eeba43cacbd5e14b0df5961b67196db3.png"><br><br><h3>  Conclusion </h3><br>  This concludes the development of a hack card for the game.  This approach was very complicated and complicated, and in the next part of the article I will show you how to simplify everything a lot by using the useful information left by the developers in the executable file.  Reading the article, you can decide that the work from the beginning to the end was quite linear, but in fact, for the sake of brevity, many paths in the code were missed, which led me to a dead end.  If they had remained, then they themselves and their explanation could pull on the volume of the dissertation.  During the initial development of the hack, I went through various ways of executing code many times, making notes on what might be necessary.  As a result, this article contains only useful information, arranged in a coherent and almost linear guide. <br><br><h2>  Part two: easy way </h2><br>  In the previous part, I talked about how to create a hack card using the built-in functions of the game.  This technique used the ability to switch the hidden / open state.  I consistently applied these built-in functions to search by assembly code.  As a result, this led me to the logic of hiding and revealing a card in which it was possible to write a hack, causing these possibilities.  In this part, a much simpler technique will be considered, and it was only possible due to the useful strings found in the binary file. <br><br>  In this part, I will use <a href="http://x64dbg.com/">x64dbg</a> , an excellent debugger and disassembler, which I consider to be the successor of the outdated <a href="http://www.ollydbg.de/">OllyDbg</a> .  Unfortunately, in this part I did not often use it, because I almost did not need analysis in the process of executing the code (after all, this part is called the ‚Äúsimple method‚Äù).  Assembler fragments are inserted from <a href="https://www.hex-rays.com/products/ida/">IDA Pro</a> , because I find its copy-paste format to be the most readable. <br><br>  Starting from connecting to the process and dumping the strings (right mouse button -&gt; Search for -&gt; Current Module -&gt; String references) of the main executable file, we received 25817 strings - a rather large area for searching. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b45/7fc/05f/b457fc05f286f784d9a34e1265e78836.png"><br><br>  The filter on the line "map" gives us a more convenient set.  After reviewing it, I found several lines that may lead to something interesting: <br><br>  <font color="#ff9900"><strong>"TrSetFogAndBlackmap (&lt;true / false&gt; &lt;true / false&gt;): fog and black map on / off."</strong></font> <br>  ¬´TrRevealEntireMap - shows a whole map of the revealed mode works¬ª <br>  "TrPlayerResetBlackMap (: Resets the black map for a given HUMAN player." <br>  "Map visibility" <br>  <font color="#ff9900"><strong>"Blackmap ([integerState]): toggles or sets unexplored black map rendering."</strong></font> <font color="#ff9900"><strong><br></strong></font> <br><br>  The two most promising lines are highlighted in <font color="#ff9900">orange</font> .  The strings give a clear idea of ‚Äã‚Äãwhat the function is doing, and even provide arguments to the parameters.  It seems that the "trX" functions are associated with the <a href="http://aom.heavengames.com/scendesign/advanced/trig1">trigger</a> system in the game, which allows map creators to add effects and conditions.  Examining the links in the first line leads to the following: <br><br> <code>... <br> .text:008B2B76 loc_8B2B76: ; CODE XREF: sub_8AE4A0+46CDj <br> .text:008B2B76 mov ecx, esi <br> .text:008B2B78 call sub_59C270 <br> <font color="#33cccc">.text:008B2B7D push 1 <br> .text:008B2B7F push offset loc_8AAEE0 <br> .text:008B2B84 push offset aTrsetfogandbla ; "trSetFogAndBlackmap"</font> <br> <font color="#33cccc">.text:008B2B89 mov ecx, esi <br> .text:008B2B8B call sub_59BE80</font> <br> <font color="#0000ff">.text:008B2B90 test al, al <br> .text:008B2B92 jnz short loc_8B2BAE <br> .text:008B2B94 push offset aTrsetfogandbla ; "trSetFogAndBlackmap" <br> .text:008B2B99 push offset aSyscallConfigE ; "Syscall config error - Unable to add th"... <br> .text:008B2B9E push esi ; int <br> .text:008B2B9F call sub_59DBC0</font> <br> ...</code> <br> <br>  The code here begins with passing a string, a pointer to a function, and constants (1) as arguments to another function ( <font color="#33cccc">cyan</font> ).  The return value of this call is checked for equality 0, which is an error state ( <font color="#0000ff">blue</font> ).  Looking at what happens in the disassembler, you will notice that this template is used everywhere.  This code and the code surrounding it tries to register the triggers and reports the name of the trigger, the event handling mechanism to the place where the trigger code is located, and the unknown constant 1 so far. Considering this, you should continue the search in the event handling mechanism. <br><br>  The transition to the event handling mechanism leads us to the following code fragment: <br><br> <code>.text:008AAEE0 loc_8AAEE0: ; DATA XREF: sub_8AE4A0+46DFo <br> <strong><font color="#ff0000">.text:008AAEE0 mov eax, dword_A9D244 <br> .text:008AAEE5 mov ecx, [eax+140h]</font></strong> <br> .text:008AAEEB test ecx, ecx <br> .text:008AAEED jz short locret_8AAF13 <br> .text:008AAEEF mov edx, [esp+4] <br> <strong><font color="#ff0000">.text:008AAEF3 push 0 <br> .text:008AAEF5 push edx <br> <font color="#008000">.text:008AAEF6 call sub_5316B0</font></font></strong> <br> .text:008AAEFB mov eax, [esp+8] <br> .text:008AAEFF mov ecx, dword_A9D244 <br> .text:008AAF05 mov ecx, [ecx+140h] <br> <strong><font color="#ff0000">.text:008AAF0B push 0 <br> .text:008AAF0D push eax <br> <font color="#008000">.text:008AAF0E call sub_5316D0</font></font></strong> <br> .text:008AAF13 <br> .text:008AAF13 locret_8AAF13: ; CODE XREF: .text:008AAEEDj <br> .text:008AAF13 retn</code> <br> <br>  Two calls here ( <font color="#008000">green</font> ) should be familiar to you if you carefully read the first part of the article.  These are two functions that, as we discovered, control the disclosure and concealment of the map.  Each function receives a " <em>this</em> " pointer, which, as we see here, is loaded from a permanent address and most likely is a class for the main player, with a value of true / false describing what happens to the map.  There is a third immutable parameter 0, which is different from the immutable parameter 1 in another place of the call from the previous part of the article.  Perhaps he indicates that the state of the card is changed by the player or the trigger. <br><br>  Knowing this, the hack from the previous part can be done a little better.  In the old hack there was a problem with providing a fake pointer " <em>this</em> ", which should have had a writeable field, and there was only one switching option: true / false.  Based on the documentation obtained by the string dump, this function takes two boolean values;  presumably, they control the superimposed black color and fog of war, shading areas already explored by the player, but which the player does not currently see. <br><br>  New (but still a little dirty) is presented below: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; using pToggleMapFnc = void (__cdecl *)(bool bEnableBlackOverlay, bool bEnableFogOfWar); int APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) { switch (dwReason) { case DLL_PROCESS_ATTACH: { (void)DisableThreadLibraryCalls(hModule); pToggleMapFnc ToggleMap = (pToggleMapFnc)0x008AAEE0; while (!GetAsyncKeyState('0')) { if (GetAsyncKeyState('6')) { ToggleMap(true, true); } else if (GetAsyncKeyState('7')) { ToggleMap(true, false); } else if (GetAsyncKeyState('8')) { ToggleMap(false, true); } else if (GetAsyncKeyState('9')) { ToggleMap(false, false); } Sleep(10); } break; } case DLL_PROCESS_DETACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: break; } return TRUE; }</span></span></span></span></code> </pre> <br>  Calling a function with different combinations of parameters, we managed to get the following behavior: <br><br>  True / True - superimposed black with fog of war <br>  True / False - there is no black imposed, there is a fog of war.  There are no marks on the map. <br>  False / True - superimposed black without fog of war.  Investigated areas are always visible. <br>  False / False - no overlaid black, no fog of war.  The whole map is visible. <br><br>  Below are screenshots for all four states: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/527/464/d1e/527464d1e2627daf0154b7b21bd6b23d.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/db4/781/28f/db478128f2511c439e8b533e3ca82d5b.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/27d/b8b/862/27db8b8620d927a4f9f9a2c8b30c3bbf.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/529/68a/cc752968a178acd9ff711ac0be222b9d.png"><br><br>  Hack has become more clean, because now he performs a direct function call and does not require the transfer of anything unknown.  I hope, obviously, why I consider it ‚Äúan easy way‚Äù, unlike the previous solution, which required long debugging and tracing. <br><br>  In the next, last part of the article, we will think about how to make this hack a little cleaner and more professional.  In addition, we will consider what is needed to port the hack for the new version of the game <a href="http://store.steampowered.com/app/266840/">Extended Edition</a> . <br><br><h2>  Part Three: Putting It All Together </h2><br>  In the previous two parts, we talked about how to develop the hack maps of Age of Mythology.  We did this by finding and performing the reverse development of the parts of the game responsible for switching the states of the map (superimposed black layer, fog of war, fully revealed map) and calling these functions through a DLL injected into the game process.  In this short part we will complete the topic by adding an injector to the source code, which will inject the hack dll developed by us into the Age of Mythology process.  The hack will work in multiplayer mode, in the original game and in the enhanced version. <br><br>  The code is laid out on <a href="https://github.com/codereversing/aommaphack">github</a> and as a whole does not demand an explanation.  The card's hack dll exports the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644984(v%3Dvs.85).aspx">KeyboardProc</a> callback, which controls the logic for switching the states of the card depending on the user keystrokes (7, 8, 9, 0).  The injector installs a keyboard hook in the game, which injects a hack dll into the game and activates the KeyboardProc callback.  After that, all keystrokes transmitted to the game are intercepted and checked for compliance with the four keys for switching card states.  If the switch key is pressed, the corresponding function is called, changing the state of the card. </div><p>Source: <a href="https://habr.com/ru/post/330842/">https://habr.com/ru/post/330842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330832/index.html">Two years with Dart: how we write in a language that is ‚Äúburied‚Äù every year (part 1)</a></li>
<li><a href="../330834/index.html">Design as a world language of the 21st century</a></li>
<li><a href="../330836/index.html">Technology and non-IT: how and why S / 4HANA is used in wholesale</a></li>
<li><a href="../330838/index.html">Attention, Habrahabr: IBM opens free access to a large number of its resources</a></li>
<li><a href="../330840/index.html">SQL Server Integration Services (SSIS) for Beginners - Part 3</a></li>
<li><a href="../330844/index.html">We write a simple driver under Windows to lock USB devices.</a></li>
<li><a href="../330846/index.html">May the Code Review with you</a></li>
<li><a href="../330848/index.html">Top 15 Free Unity Assets for a Beginner 2D Developer</a></li>
<li><a href="../330850/index.html">Microsoft at CodeFest 2017 - report, slides and video reports</a></li>
<li><a href="../330852/index.html">What is missing Gmail. 4 free deskun features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>