<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Connect MATLAB to Wolfram Mathematica</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Calling MATLAB from Mathematica with MATLink 
 How can you call MATLAB functions directly from Mathematica and organize the exchange of data and varia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Connect MATLAB to Wolfram Mathematica</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/bbf/e9b/3e4/bbfe9b3e4dc349928177f2dacade3663.png"></div><br><br><h2>  Calling MATLAB from Mathematica with MATLink </h2><br>  How can you call MATLAB functions directly from Mathematica and organize the exchange of data and variables between the two systems? <br><br>  <b>To do this, there is a cross-platform package called</b> <b><a href="http://matlink.org/">MATLink</a></b> .  With it, it is easy to organize a call to the MATLAB functions directly from Mathematica and transfer various data from one system to another. <br><a name="habracut"></a><br>  I will give a small instruction: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>‚óè Installation</b> <br>  First, go to the main page of MATLink and follow the instructions there.  The easiest way is to download the archive and unpack it into this folder: <br><br>  In [1]: = <pre><code class="hljs perl">SystemOpen@FileNameJoin[{$UserBaseDirectory, <span class="hljs-string"><span class="hljs-string">"Applications"</span></span>}]</code> </pre> <br><br>  Next, follow the instructions for the specific operating system in the ‚ÄúLink with MATLAB‚Äù section of the main page. <br><br>  <b>‚óè Using MATLink</b> <br><br>  MATLink can be downloaded by calculating a cell with the code: <br><br>  In [2]: = <pre> <code class="hljs objectivec">Needs[<span class="hljs-string"><span class="hljs-string">"MATLink`"</span></span>]</code> </pre> <br><br>  And then start MATLAB with the command: <br><br>  In [3]: = <pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">OpenMATLAB</span></span> []</code> </pre> <br><br>  This will launch a new process in MATLAB, with which Mathematica can interact. <br><br>  To use arbitrary MATLAB commands, use <b>MEvaluate</b> .  The data will be transmitted as a string. <br><br>  Example: <br><br>  In [4]: ‚Äã‚Äã= <pre> <code class="hljs objectivec">MEvaluate[<span class="hljs-string"><span class="hljs-string">"magic(4)"</span></span>]</code> </pre> <br>  Out [4] = <pre> <code class="hljs delphi"><span class="hljs-comment"><span class="hljs-comment">(* ==&gt; ans = 16 2 3 13 5 11 10 8 9 7 6 12 4 14 15 1 *)</span></span></code> </pre> <br><br>  To transfer data to MATLAB, you must use <b>MSet</b> : <br><br>  In [5]: = <pre> <code class="hljs pgsql">MSet["x", Range[<span class="hljs-number"><span class="hljs-number">10</span></span>]];MEvaluate["x"]</code> </pre> <br>  Out [5] = <pre> <code class="hljs delphi"><span class="hljs-comment"><span class="hljs-comment">(* ==&gt; x = 1 2 3 4 5 6 7 8 9 10 *)</span></span></code> </pre> <br><br>  To get data back, follow <b>MGet's</b> use: <br><br>  In [6]: = <pre> <code class="hljs objectivec">MGet[<span class="hljs-string"><span class="hljs-string">"x"</span></span>]</code> </pre> <br>  Out [6] = <pre> <code class="hljs delphi"><span class="hljs-comment"><span class="hljs-comment">(* ==&gt; {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.} *)</span></span></code> </pre> <br><br>  A large number of data types are supported, including sparse arrays, structures, and cells. <br><br>  MATLAB functions can be called directly from Mathematica using the <b>MFunction</b> function: <br><br>  In [7]: = <pre> <code class="hljs objectivec">eig = MFunction[<span class="hljs-string"><span class="hljs-string">"eig"</span></span>]; eig[{{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}}]</code> </pre> <br>  Out [7] = <pre> <code class="hljs delphi"><span class="hljs-comment"><span class="hljs-comment">(* ==&gt; {{3.44949}, {-1.44949}} *)</span></span></code> </pre> <br><br>  In the documentation you can read more about the features of use and other functionalities. <br><br><h2>  Some simple examples </h2><br>  Let's build in Mathematica for the beginning the surface of the MATLAB logo and add a manipulator that will regulate the oscillation period: <br><br>  In [8]: = <pre> <code class="hljs markdown">Manipulate[<span class="hljs-string"><span class="hljs-string"> ListPlot3D@MFunction["membrane"</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">k</span></span>], {k, 1, 12, 1} ]</code> </pre> <br>  Out [8] = <br><img src="https://habrastorage.org/getpro/habr/post_images/5c2/3f1/763/5c23f1763aef5a14ed82cee5a0bce9b3.png" alt="image"><br><br>  Fullerene structure (bucky ball) straight from MATLAB: <br><br>  In [9]: = <pre> <code class="hljs markdown">AdjacencyGraph@Round@MFunction[<span class="hljs-string"><span class="hljs-string">"bucky"</span></span>][<span class="hljs-symbol"></span><span class="hljs-symbol"></span>]</code> </pre> <br>  Out [9] = <br><img src="https://habrastorage.org/getpro/habr/post_images/737/53d/b38/73753db3859cd6d4f9e12fa149281694.png" alt="image"><br><br>  Displaying data from Mathematica in a separate scalable window for images that are used in MATLAB is also easy: <br><br>  In [9]: = <pre> <code class="hljs markdown">mlf = LibraryFunctionLoad[<span class="hljs-string"><span class="hljs-string">"demo_numerical", "mandelbrot", {Complex}, Integer</span></span>]; mandel = Table[<span class="hljs-string"><span class="hljs-string">mlf[x + I y</span></span>], {y, -1.25, 1.25, .002}, {x, -2., 0.5, .002}]; MFunction[<span class="hljs-string"><span class="hljs-string">"image", "Output" -&gt; False</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">mandel</span></span>]</code> </pre> <br>  Out [9] = <br><img src="https://habrastorage.org/getpro/habr/post_images/db8/81c/7fd/db881c7fd685760ae946eb8fbc612786.png" alt="image" width="600"><br><br><h2>  Some examples are more complicated. </h2><br>  The following examples illustrate real-world solutions using MATLink, allowing you to use the best qualities of MATLAB and Mathematica. <br><br>  <b>‚óè Fast Delaunay Triangulations</b> <br><br>  Mathematica contains the <a href="http://reference.wolfram.com/language/ComputationalGeometry/ref/DelaunayTriangulation.html">DelaunayTriangulation</a> function inside the <a href="http://reference.wolfram.com/language/Compatibility/tutorial/ComputationalGeometry.html">ComputationalGeometry</a> package <i>(in the 10th version, this package was built into the kernel and now this function is named <a href="http://reference.wolfram.com/language/ref/DelaunayMesh.html">DelaunayMesh</a> , it is optimized and now its performance is not inferior to MATLAB - ed.)</i> , But it works very slowly (although she has her own strengths, such as using exact arithmetic and working with collinear points).  This, in turn, leads to the fact that <a href="http://reference.wolfram.com/language/ref/ListDensityPlot.html">ListDensityPlot</a> works very inefficiently (which becomes noticeable when building several thousand points or more).  Using MATLink, we can use the Delone function from MATLAB to calculate the Delaunay triangulation of a certain set of points as follows: <br><br>  In [10]: = <pre> <code class="hljs vbscript">delaunay = Composition[<span class="hljs-built_in"><span class="hljs-built_in">Round</span></span>, MFunction[<span class="hljs-string"><span class="hljs-string">"delaunay"</span></span>]];</code> </pre> <br><br>  Since the Mathematica function returns a list of adjacent vertices, we need to post-process the result in order to compare it with the result from MATLAB: <br><br>  In [11]: = <pre> <code class="hljs cmake">Needs[<span class="hljs-string"><span class="hljs-string">"ComputationalGeometry`"</span></span>]; delaunayMma[points_] := Module[{tr, triples}, tr = DelaunayTriangulation[points]; triples = Flatten[ <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>[{v, <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>}, Switch[Length[<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>], (* account for nodes with connectivity <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">less</span></span> *) <span class="hljs-number"><span class="hljs-number">1</span></span>, {}, <span class="hljs-number"><span class="hljs-number">2</span></span>, {Flatten[{v, <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>}]}, _, {v, <span class="hljs-comment"><span class="hljs-comment">##}&amp; @@@ Partition[list, 2, 1, {1, 1}]] ] @@@ tr, 1]; Cases[GatherBy[triples, Sort], a_ /; Length[a] == 3 :&gt; a[[1]]] ]</span></span></code> </pre> <br><br>  A random set of points usually has a unique Delaunay triangulation, so we will need to check that the systems produce the same result. <br><br>  In [12]: = <pre> <code class="hljs coffeescript">pts = RandomVariate[NormalDistribution[], {<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}]; Sort[Sort <span class="hljs-regexp"><span class="hljs-regexp">/@ delaunay[pts]] === Sort[Sort /</span></span>@ delaunayMma[pts]]</code> </pre> <br><br>  And build triangulation using: <br><br>  In [13]: = <pre> <code class="hljs mel">trianglesToLines[t_] := Union@Flatten[{{#<span class="hljs-number"><span class="hljs-number">1</span></span>, #<span class="hljs-number"><span class="hljs-number">2</span></span>}, {#<span class="hljs-number"><span class="hljs-number">2</span></span>, #<span class="hljs-number"><span class="hljs-number">3</span></span>}, {#<span class="hljs-number"><span class="hljs-number">1</span></span>, #<span class="hljs-number"><span class="hljs-number">3</span></span>}} &amp; @@ Transpose[Sort /@ t], {{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">2</span></span>}}]; Graphics@GraphicsComplex[pts, Line@trianglesToLines@delaunay[pts]]</code> </pre> <br>  Out [13]: = <br><img src="https://habrastorage.org/getpro/habr/post_images/74a/cb9/cd0/74acb9cd0a07dfb08df2fb7a0ed90378.png" alt="image"><br><br>  However, besides the fact that <b>delaunay</b> works much faster than the <b>DelaunayTriangulation</b> (especially for large data sets), it is also faster than the <b>triangulator</b> , which is used inside <b>ListDensityPlot</b> .  Therefore, we can use <b>delaunay</b> from MATLAB to develop our version of <b>listDensityPlot</b> , which works faster than the built-in function, and can also process large data sets as follows: <br><br>  In [14]: = <pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>[listDensityPlot] = <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>[Graphics] ~<span class="hljs-keyword"><span class="hljs-keyword">Join</span></span>~ {ColorFunction -&gt; Automatic, MeshStyle -&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, Frame -&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>}; listDensityPlot[data_?MatrixQ, opt : OptionsPattern[]] := Module[{<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>, tri, colfun}, tri = delaunay[data[[<span class="hljs-keyword"><span class="hljs-keyword">All</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>;;<span class="hljs-number"><span class="hljs-number">2</span></span>]]]; colfun = OptionValue[ColorFunction]; <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Not</span></span>@MatchQ[colfun, _Symbol | _Function], <span class="hljs-keyword"><span class="hljs-keyword">Check</span></span>[colfun = ColorData[colfun], colfun = Automatic]]; <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>[colfun === Automatic, colfun = ColorData["LakeColors"]]; Graphics[ GraphicsComplex[data[[<span class="hljs-keyword"><span class="hljs-keyword">All</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>;;<span class="hljs-number"><span class="hljs-number">2</span></span>]], GraphicsGroup[{EdgeForm[OptionValue[MeshStyle]], <span class="hljs-type"><span class="hljs-type">Polygon</span></span>[tri]}], VertexColors -&gt; colfun /@ Rescale[data[[<span class="hljs-keyword"><span class="hljs-keyword">All</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]]] ], <span class="hljs-keyword"><span class="hljs-keyword">Sequence</span></span> @@ FilterRules[{opt}, <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>[Graphics]], <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> -&gt; {"GridLinesInFront" -&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>} ] ]</code> </pre> <br><br>  Let's now compare our function with the built-in function, using an array of 30,000 points: <br><br>  In [15]: = <pre> <code class="hljs 1c">pts = RandomReal[{-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-number"><span class="hljs-number">30000</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}]; values = <span class="hljs-built_in"><span class="hljs-built_in">Sin</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Sqrt</span></span>[<span class="hljs-meta"><span class="hljs-meta">#1^2 + #2^2]] &amp; @@@ pts;</span></span></code> </pre> <br><br>  In [16]: = <pre> <code class="hljs php">listDensityPlot[ArrayFlatten[{{pts, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span> /@ values}}], Frame -&gt; <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>] <span class="hljs-comment"><span class="hljs-comment">// AbsoluteTiming</span></span></code> </pre> <br>  Out [16] = <br><pre> <code class="hljs pgsql">{<span class="hljs-number"><span class="hljs-number">0.409001</span></span>, <span class="hljs-comment"><span class="hljs-comment">--Graphics--}</span></span></code> </pre> <br><br>  In [17]: = <pre> <code class="hljs php">ListDensityPlot[ArrayFlatten[{{pts, <span class="hljs-keyword"><span class="hljs-keyword">List</span></span> /@ values}}]] <span class="hljs-comment"><span class="hljs-comment">// AbsoluteTiming</span></span></code> </pre> <br>  Out [17] = <br><pre> <code class="hljs pgsql">{<span class="hljs-number"><span class="hljs-number">12.416587</span></span>, <span class="hljs-comment"><span class="hljs-comment">--Graphics--}</span></span></code> </pre> <br><br>  The difference in execution speed turned out to be quite significant (~ 30 times).  <b>ListDensityPlot</b> is practically unusable for working with hundreds of thousands of points, while the <b>listDensityPlot</b> only takes a few seconds. <br><br>  It is also important to note that for measuring the speed of MATLink, you must use the <a href="http://reference.wolfram.com/language/ref/AbsoluteTiming.html">AbsoluteTiming</a> function, which calculates all elapsed time, while <a href="http://reference.wolfram.com/language/ref/Timing.html">Timing</a> measures only the time when the CPU was used by the Mathematica core, not measuring the time that MATLAB spent. <br><br>  <b>‚óè Filtering audio data using signal processing tools</b> <br><br>  As you know, signal processing functionality was missing in Mathematica until version 9, and is still inferior to MATLAB tools in terms of functionality and ease of use.  Suppose we have version 8 of Mathematica, there are no new functions, and we want to conduct a frequency analysis of some audio file and implement filtering.  Here's how to do it: <br><br>  In [18]: = <pre> <code class="hljs lua">{data, fs} = {#<span class="hljs-string"><span class="hljs-string">[[1, 1, 1]]</span></span>, #<span class="hljs-string"><span class="hljs-string">[[1, 2]]</span></span>} &amp;@ExampleData[{<span class="hljs-string"><span class="hljs-string">"Sound"</span></span>, <span class="hljs-string"><span class="hljs-string">"Apollo13Problem"</span></span>}]; spectrogram = MFunction[<span class="hljs-string"><span class="hljs-string">"spectrogram"</span></span>, <span class="hljs-string"><span class="hljs-string">"Output"</span></span> -&gt; False]; (* Use MATLAB<span class="hljs-string"><span class="hljs-string">'s spectrogram *) spectrogram[data, 1000, 0, 1024, fs]</span></span></code> </pre> <br><br>  Obviously, the frequencies mainly fall in the range below 2.5 kHz, so we can develop a low-pass filter in MATLAB, as well as make an auxiliary function that will return the filtered data: <br><br>  In [19]: = <pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">MSet</span></span>[<span class="hljs-string"><span class="hljs-string">"fs"</span></span>, fs]; <span class="hljs-type"><span class="hljs-type">MEvaluate</span></span>[<span class="hljs-string"><span class="hljs-string">" [z, p, k] = butter(6, 2.5e3/fs, 'low') ; [sos, g] = zp2sos(z, p, k) ; Hd = dfilt.df2tsos(sos, g) ; "</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> = <span class="hljs-type"><span class="hljs-type">MFunction</span></span>[<span class="hljs-string"><span class="hljs-string">"myfilt"</span></span>, <span class="hljs-string"><span class="hljs-string">"@(x)filter(Hd,x)"</span></span>];</code> </pre> <br>  Out [19] = <br><img src="https://habrastorage.org/getpro/habr/post_images/0a1/063/f8a/0a1063f8a016dfebfe121eacf18bd3e7.png" alt="image" width="600"><br><br>  Now we have prepared everything to apply the filter function to the data directly from Mathematica.  This example shows how we can fill in the gaps in functionality.  Thus, we can save a large amount of time to design a filter in Mathematica (and this is not the easiest task) and many hours to debug it.  The code for the Butterworth filter can be taken from anywhere - from file sharing or Stack Overflow, from fragments of previously written code, or, as in this case, from the example in the documentation.  Small changes in parameters for current needs, and we can now work with this material in Mathematica. <br><br>  As a final example, I propose to process some data using our filter and build a spectrogram: <br><br>  In [19]: = <pre> <code class="hljs kotlin">filteredData = <span class="hljs-symbol"><span class="hljs-symbol">filter@</span></span><span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; spectrogram[filteredData, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>, fs]</code> </pre> <br><br>  Purely for fun, we can play both audio files - filtered and source ‚Äî and compare the difference in their sound: <br><br>  In [20]: = <pre> <code class="hljs erlang-repl">ListPlay[data, SampleRate -&gt; fs] ListPlay[filteredData, SampleRate -&gt; fs]</code> </pre> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bae/564/827/bae5648274e5f3544721259e9e613b0d.png" alt="image" width="600"><br><br>  If suddenly you find any errors and problems in the work of MATLink, please report them to the post office (matlink.m@gmail.com), either on GitHub, or in the comments to the <a href="http://mathematica.stackexchange.com/questions/10231/calling-matlab-from-mathematica/24478">original of this article</a> . <br><br><h2>  Additions </h2><br>  <b>‚óè Calling MATLAB from Mathematica using NETLink</b> <br><br>  A quick note about how you can invoke MATLAB using NETLink in the Windows operating system using the MATLAB COM interface: <br><br>  In [21]: = <pre> <code class="hljs objectivec">Needs[<span class="hljs-string"><span class="hljs-string">"NETLink`"</span></span>] matlab = CreateCOMObject[<span class="hljs-string"><span class="hljs-string">"matlab.application"</span></span>]</code> </pre> <br>  Out [21] = <br><pre> <code class="hljs css">¬´<span class="hljs-selector-tag"><span class="hljs-selector-tag">NETObject</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[COMInterface[MLApp.DIMLApp]</span></span>]¬ª</code> </pre> <br><br>  Now you can access the MATLAB functions: <br><br>  In [22]: = <pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">In</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]:= matlab@<span class="hljs-keyword"><span class="hljs-keyword">Execute</span></span>["version"]</code> </pre> <br>  Out [22] = <br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">" ans = 7.9.0.529 (R2009b) "</span></span></code> </pre> <br><br>  In [23]: = <pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">matlab</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">Execute</span></span>["<span class="hljs-keyword"><span class="hljs-keyword">a</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">2</span></span>"];<span class="hljs-selector-tag"><span class="hljs-selector-tag">matlab</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">Execute</span></span>["<span class="hljs-keyword"><span class="hljs-keyword">a</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">2</span></span>"]</code> </pre> <br>  Out [23] = <br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">" ans = 4 "</span></span></code> </pre> <br><br>  <b>‚óè About converting expressions from Mathematica syntax to MATLAB syntax</b> <br><br>  There is a package called <b><a href="http://library.wolfram.com/infocenter/MathSource/577/">ToMatlab</a></b> that converts expressions from Mathematica to their MATLAB equivalents.  Here is an example: <br><br>  In [24]: = <pre> <code class="hljs scala">&lt;&lt;<span class="hljs-type"><span class="hljs-type">ToMatlab</span></span>` <span class="hljs-type"><span class="hljs-type">Expand</span></span>[(x + <span class="hljs-type"><span class="hljs-type">Log</span></span><span class="hljs-meta"><span class="hljs-meta">@y</span></span>)^<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ToMatlab</span></span></code> </pre> <br>  Out [24]: = <br><pre> <code class="hljs matlab">x.^<span class="hljs-number"><span class="hljs-number">5</span></span>+<span class="hljs-number"><span class="hljs-number">5.</span></span>*x.^<span class="hljs-number"><span class="hljs-number">4.</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(y)+<span class="hljs-number"><span class="hljs-number">10.</span></span>*x.^<span class="hljs-number"><span class="hljs-number">3.</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(y).^<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">10.</span></span>*x.^<span class="hljs-number"><span class="hljs-number">2.</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(y).^<span class="hljs-number"><span class="hljs-number">3</span></span>+<span class="hljs-number"><span class="hljs-number">5.</span></span>* ... x.*<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(y).^<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(y).^<span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><br>  You may notice that expressions are quite conveniently broken using <b>...;</b> <br><br>  Here is another example with matrix conversion: <br><br>  In [25]: = <pre> <code class="hljs objectivec">RandomInteger[<span class="hljs-number"><span class="hljs-number">5</span></span>, {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}] <span class="hljs-comment"><span class="hljs-comment">// ToMatlab</span></span></code> </pre> <br>  Out [25]: = <br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">5,0,5,3,4; 5,5,3,0,2; 1,4,4,4,4; 0,3,2,5,5; 4,5,5,1,1</span></span>];</code> </pre> <br><br>  It is worth noting that such things as general definitions cannot be converted to MATLAB syntax.  Of course, those constructions that are not supported by MATLAB ‚Äî template expressions, for example, cannot be converted either. <br><br>  To install this package, simply extract the ToMatlab.m file to the folder: <br><br>  In [26]: = <pre> <code class="hljs perl">FileNameJoin[{$UserBaseDirectory, <span class="hljs-string"><span class="hljs-string">"Applications"</span></span>}]</code> </pre> <br><br>  <i>For questions about Wolfram technologies, write</i> to <b>info-russia@wolfram.com</b> </div><p>Source: <a href="https://habr.com/ru/post/303372/">https://habr.com/ru/post/303372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303362/index.html">Why do those who work a little have higher productivity?</a></li>
<li><a href="../303364/index.html">As an sql query, retrieve information from the database that is not there.</a></li>
<li><a href="../303366/index.html">REST API on Symfony, FOSRestBundle + GlavwebDatagridBundle</a></li>
<li><a href="../303368/index.html">We write a serializer for a network game in C ++ 11</a></li>
<li><a href="../303370/index.html">Tony Robbins seminar review ‚ÄúFree your inner strength‚Äù. Day 4. The power of clean energy (part 2)</a></li>
<li><a href="../303374/index.html">2-3-tree. Naive implementation</a></li>
<li><a href="../303376/index.html">CodeRush for Roslyn: Part 2 - feature overview for better code</a></li>
<li><a href="../303378/index.html">Determine the Phantom bots</a></li>
<li><a href="../303380/index.html">Not Pascal alone: ‚Äã‚Äãwhat did the winner of the computer "Nobel Prize" Niklaus Wirth do for the modern world?</a></li>
<li><a href="../303382/index.html">From blacklists to intelligent call management</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>