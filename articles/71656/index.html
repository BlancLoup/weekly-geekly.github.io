<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About F # for Architects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article grew out of a report made by Chris Smith, one of the F # developers at the DevLink conference. In general, it is of an overview nature, b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About F # for Architects</h1><div class="post__text post__text-html js-mediator-article">  This article grew out of a report made by Chris Smith, one of the F # developers at the DevLink conference.  In general, it is of an overview nature, but despite this, and the fact that the efforts of <a href="http://habrahabr.ru/users/shwars/" class="user_link">shwars</a> , <a href="http://habrahabr.ru/users/mezastel/" class="user_link">mezastel</a> and partly your humble servant F # have repeatedly flashed on Habr√©, I think that this programming language has not yet become so obvious to everyone that this article is completely lost meaning.  Moreover, here Chris is trying to answer the main question, which, I think, torments everyone who has ever heard of F #.  Where does it apply?  It turned out he or not - you judge.  I hope after reading you at least something about all this will become clearer.  If so, I will consider my mission overfulfilled :) <br>  PS The first translation, so do not blame me for some possible bugs. <br><img src="https://habrastorage.org/getpro/habr/post_images/111/d20/9f9/111d209f97636ec2fd0e8e81982ea1c2.png" alt="image"><br><a name="habracut"></a><br>  After the appearance of F #, of course, there are a lot of emotions around it, but the question that most people take is why me?  I think we can assume that F # is something good, because otherwise Microsoft wouldn‚Äôt have spent so much time and effort to put it in a new Visual Studio 2010. <em>[Note.</em>  <em>trans.</em>  <em>- a weak argument :)]</em> <br><br>  Therefore, below we will try to ignore the many emotional expressions that bore our conversations about F # and look the facts in the eye.  I'm not going to convince you to start programming in F #, but instead I will say what the language is good for and let you decide for yourself whether it is worth your attention. <br><br>  If you are programming in C # or VB.NET, and at the same time are immensely happy, then most likely you have no reason to learn F #.  Just stay happy.  ;) But if you occasionally have to contend with your own .NET code, then perhaps F # is just what you were waiting for. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Gossip </h3><br>  There are a lot of rumors about F #.  Here are some of them. <br><ul><li>  <em>The code you are currently writing in C # will become obsolete tomorrow.</em>  - <strong>Not true.</strong>  F # is not going to replace C # or VB.  F # is just different, so some things on it are easier to do, and some are more difficult.  The point is that with F #, you have a choice.  And below we will try to identify some of the situations where F # may be preferable to C #. </li><li>  <em>In F #, you can parallelize code for free.</em>  - <strong>Not true.</strong>  Although F # (and other FNPs) make it easier to parallelize code, it does not do it for nothing.  Generally speaking, you can write the same locks or races on F # as on C #.  The advantage of F # is that you must first obviously aim your gun at the foot.  (Approx. Translation: an allusion to the old programmer's joke about how the <a href="http://duff.geology.washington.edu/staff_pages/shootfoot.html">task</a> is implemented in different languages <a href="http://duff.geology.washington.edu/staff_pages/shootfoot.html">to shoot yourself in the leg</a> .) </li><li>  <em>For functional programming, the future</em> is <strong>not true.</strong>  Functional programming languages ‚Äã‚Äãare nowadays becoming objects of increasing attention - Erlang, Scala, Nemerle, Haskell, etc.  Nevertheless, the key ideas of functional programming appeared a long time ago.  And I do not think that functional programming will become the main and only paradigm to which all will switch.  Rather, in my opinion, this is a good way to solve a specific class of problems.  F # is a hybrid language, and it allows you to write code in the paradigm that best suits the current task. </li><li>  <em>F # programmers are smarter and look better than others.</em>  - <strong>True.</strong>  Absolute. </li><li>  <em>You should rewrite all your ASP.NET applications in F #.</em>  - <strong>Not true.</strong>  In the main DevLink report, Josh Holmes especially stressed that this is a bad idea.  Not that the F # + ASP.NET bundle itself was a bad idea, but the desire to use new technologies just to use new technologies makes things harder than they should be. </li></ul><br>  Let us draw a line under the above: you have to understand what F # is and if its use makes your work more efficient, then use it.  If not, use what you already know. <br><img src="https://habrastorage.org/getpro/habr/post_images/87a/197/e4b/87a197e4b86c4577ae7004c66adc48a7.png"><br><br><h3>  Tongue </h3><br><ul><li>  As I noted above, F # is a multi-paradigm programming language.  You can write functional, imperative, and object-oriented code in it.  This allows you to be more pragmatic, instead of trying to push any task that you have into the Procrustean bed of classes and interfaces. </li><li>  F # uses type inference, which leads to more concise programs.  Think about how much time you spend adding type signatures, semicolons, curly braces in your favorite PL.  All this information is just crutches that make it easier to write a compiler.  Why not write the code you want and let the compiler calculate the rest?  You will see later why I consider the conciseness of F # to be its main strength. </li><li>  F # is a .NET programming language.  It is compiled into IL in the same working cycle as C # with VB and will easily work with already existing .NET code. </li></ul><br><h3>  Instruments </h3><br><ul><li>  F # is included in the standard set of Visual Studio 2010, although present now, as a plug-in for VS2008. </li><li>  It has an interactive programming environment ( <a href="http://ru.wikipedia.org/wiki/REPL" title="REPL">REPL</a> ) for both Ruby and Python, called F # Interactive Window. </li></ul><br>  Of course, it is very easy to get bogged down in the whole variety of details of a new programming language. <br>  The only thing I ask you to remember about F # as a whole is that it is fascinating to program on it.  F # breaks down many of the barriers associated with programming and allows you to concentrate on writing the code you need. <br><br>  It is important to note that F # supports almost all the features that C # has.  Therefore, you can use it without fear of the principle "all or nothing."  You do not need to throw away the existing code and translate everything to F #.  In general, we expect that F # code will be mainly used as class libraries integrated into a large software product.  Perhaps some components of the database server will be written in F #, while the rest of your code will remain in C # / PHP / Smoke Signals / anything. <br><img src="https://habrastorage.org/getpro/habr/post_images/a2a/fba/abb/a2afbaabbe5729975ba3c1ebf245e9fc.png"><br><br>  The ability to seamlessly interact with .NET opens up many possibilities for F #.  You can not only use the strengths of existing tools, such as debugger VS, IntelliSense, but also other .NET platforms, for example, use XNA to run the F # code on the XBox, or Silverlight to run it on the network.  This synergy is probably the main reason why F # is given much more attention than to earlier programming languages ‚Äã‚Äãlike OCaml.  OCaml is great, but does it come with a world-class debugger, visualization libraries, and an ecosystem formed by the developer community? <br><br>  But still, why learn this new language? <br><br>  Let's start with the fact that we consider some terms related to F #. <br><ul><li>  <strong>Statically typed.</strong>  F # is a statically typed language, unlike, for example, dynamically typed Ruby.  This means that the type information is known at compile time.  Therefore, although you can not do some things, such as <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patches</a> , but the code is executed much faster and you can learn about most of the errors at the compilation stage. </li><li>  <strong>Laconic.</strong>  In addition to deducing types, F # also uses significant spaces.  If you shift the lines under the if-construction a few spaces to the right, the compiler will regard them as the body of an operator.  This saves you from having to clog your code with curly braces and saves you vertical space.  Less code on the page means that you can see most of the program at the same time, and less to switch the context by viewing the code.  It may not sound too big, but in fact it will be a great help to your effectiveness. </li><li>  <strong>Extensible.</strong>  It's not about data centers and web servers, but about the fact that if you apply holistic principles for software development to your F # code, you can write enterprise level applications on it.  (Simply put, F # is not just a language for one-time utilities.) </li><li> <strong>Investigated.</strong>  In F #, you do not need to refer to the design to understand how everything works.  You can quickly prototype F # solutions, as well as experiment with algorithms and approaches using the F # Interactive Window.  Relying on the laconic nature of F #, you will not write a lot of code to experiment with your programs. </li><li>  <strong>Libraries.</strong>  F # comes with its own library for writing functional code and much more. </li></ul><br><h3>  Functional vs Object Oriented </h3><br>  Functional programming has been known since the 50s (LISP) - so why is it so important now?  Many will say that things like immutability help write multi-threaded programs, which in my opinion is not so important.  Because if you want to seriously engage in multi-threaded programming, there are PLs created specifically for doing this and only this. <br>  The main advantage of functional programming lies in what is called <em>programming in the small</em> . <br>  What determines the current state of affairs in software development?  - OOP.  The main way in which we solve the problem of converting an algorithm into a code is breaking it up into objects, effectively modeling the subject area with the help of classes and their behavior.  This is <em>programming in general</em> .  The process of abstraction works fine for modeling large systems and dividing them into smaller and smaller levels, but ultimately you will hit the wall. <br>  What about the bodies of the methods?  Real code that is enclosed in classes?  This is programming in small.  The problem with OOP is that when you write code of an algorithmic type, it does not make sense to create classes and interfaces.  When you program in the small, all you really do is transform the data and make calculations. <br>  Imagine that the PLO is a baseball trap.  It is well suited to catch a baseball, but not nearly as comfortable as catching a football.  For this you need fingers to move.  Functional programming and describes the essence of programming in the small.  It focuses on data manipulation, which needs to be implemented without problems with classes and a given type hierarchy. <br><br><h2>  Areas of use </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/008/876/232/0088762324e7902644d7a71ca0c6792b.png"><br>  The first area in which F # is really unsurpassed is technical and quantitative programming, i.e.  in complex mathematical calculations. <br><br><h4>  Simulation </h4><br>  Simulation is one of the areas where F # fits well.  Imagine that you are writing some kind of physical simulator, or are trying to simulate some realistic situation.  In F #, you can neatly write the functions you need without having to pull code abstractions into real-world processes. <br>  Another aspect of simulations that makes F # a good choice for them is the <a href="http://blogs.msdn.com/andrewkennedy/archive/2008/08/20/units-of-measure-in-f-part-one-introducing-units.aspx">unit of measurement</a> .  You can encode units of measure, such as "feet" or "meters per second" into a valid F # type system.  After that, you will receive a compiler warning if you try to add acceleration to speed.  This allows you to protect yourself from a number of bugs. <br><br><h4>  Computational Finance </h4><br>  Some of the very first firms to use F # were in finance computing.  These firms have large databases for automated trading on stock exchanges, risk calculations, etc.  (Just the sort of computerized finance that caused the current global economic crisis :)) F # provides these investment companies not only with a way to express their financial models in a simpler and more declarative way, but also integrate with the rest of their applications through .NET interaction.  (For example, sending intensive computations to several machines via a COM service, and stuff like that) <br><br><h4>  Large data processing </h4><br>  Finally, F # does a good job with data mining tasks.  For example, imagine that you are trying to extract some customer information in order to recognize trends.  In F #, you can simply work with your data in the F # Interactive Window, and there is no need to clutter up your machine with dozens of one-time projects.  Also, using a concise F # programming model, the cost of an error ‚Äî re-factoring or rescheduling your approach ‚Äî is noticeably reduced. <br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/3f5/0c0/2ec3f50c0b7c700c4f29fb6372448d05.png"><br><br><h4>  Language-oriented programming </h4><br>  The next item is the <a href="http://en.wikipedia.org/wiki/Language-oriented_programming">PLO</a> , which means the blurring of the border between PL and natural languages.  (For more information about using F # in YAOP, <a href="http://blogs.msdn.com/chrsmith/archive/2008/05/30/language-oriented-programming-in-f.aspx">see Chris's article.</a> ) <br><br><h4>  Writing parsers </h4><br>  If you want to be advanced in domain-specific languages, why not go ahead and write your own parser?  And in the F # PowerPack library there are FSLex and FSYacc, two great tools for creating parsers.  In fact, the F # compiler parser was created using FSLex and FSYacc. <br><br><h4>  Extensible F # code </h4><br>  Another great example of LOPs is the use of computational expressions that are in F #.  This is a powerful language feature that allows you to write normal F # code and customize the way it is executed.  For example, imagine that you want to write some F # code for interacting with a robot on Mars.  Instead of writing tons of pattern code to try again to send every command you send to an all-terrain vehicle ‚Äî for example, in the case of cosmic obstacles or Martian rebellions ‚Äî you can write a computational expression (so-called F # Workflow) to automatically restart any F # code times until a certain point, or until it succeeds. <br>  (This is quite a complex topic, which actually need to devote more than one article) <br><br><h4>  Creating new languages </h4><br>  Another area in which F # is excellent is the creation of internal domain-specific languages ‚Äã‚Äã(DSL, mini programming languages ‚Äã‚Äãembedded in your code).  Marked unions make the process of creating abstract syntactic trees (or any other tree-like structures) very simple. <br><br><h4>  Expression Trees </h4><br>  Finally, there is Expression Trees in F #, as in C # and VB.NET.  This allows you to get a ‚Äúcompiler-generated‚Äù form of F # code that, together with the appropriate libraries, can allow you to give the program execution to other platforms.  For example, on a SQL server or graphics processor for your video card. <br><br><h3>  Multithreaded programming </h3><br>  F # is also good at multi-threaded programming, to be more precise: in parallel, asynchronous, concurrent and responsive programming domains.  F # does not parallelize your code automatically, and does not have any built-in support for parallel primitives.  Instead, it has several features that make parallel programming easier.  But none of them is a silver bullet. <br><br><h4>  Immutability by default. </h4><br>  In F #, as in most other FNPs, data is immutable by default.  Therefore, if your program lies in the pure functional paradigm, you will not have any problems with races when performing multiple streams, since there is no divided changeable state for the two competing streams. <br><br><h4>  Parallel Extensions in .NET </h4><br>  Generally speaking, this functionality applies not only to F #, but to the whole .NET.  The long way to make writing parallel programs easier was crowned with the introduction of the Parallel Extensions (PFX) library into the fourth version of .NET.  Although PFX provides many excellent features to the .NET platform, there are two things that I particularly liked. <br>  Task Parallel Library (TPL) is a set of classes for abstracting the process of placing program ‚Äútasks‚Äù.  With the help of TPL, you can forget about the need to manually post tasks and manage flows.  Instead you can trust TPL.  He will do it for you, he will also adjust the number of running threads, to be sure that you will not overload the system with parallel tasks. <br>  Another, and perhaps even more remarkable, part of PFX is Concurrent Data Structures.  This is a new set of collection types that are specifically designed to work with high-performance multi-threaded applications.  Therefore, instead of controlling all the details of a shared changeable state, you can simply give the opportunity to write to both threads in one of these competitive structures, and all the dirty work with lock-unlocks will no longer concern you. <br><h4>  Asynchronous programming </h4>  ( <a href="http://msdn.microsoft.com/en-us/library/ms978405.aspx">msdn.microsoft.com/en-us/library/ms978405.aspx</a> details) <br>  You may have heard somewhere before that F # makes asynchronous programming very easy - that‚Äôs one hundred percent true. <br><img src="https://habrastorage.org/getpro/habr/post_images/a98/2fa/fab/a982fafabb553ca6cb6a2195ea3ea922.png"><br>  In order to write asynchronous programs on .NET, you need to use Asynchronous Programming Model (APM).  This is a template in which you start an asynchronous operation, for example, reading from a file, calling BeginOp (i.e. BeginRead) and sending a callback.  When an asynchronous operation completes, a callback is executed in which you must call EndOp (i.e. EndRead) <br>  Although this approach has faithfully served .NET for almost a decade, it‚Äôs pretty damn unpleasant to deal with. <br><ul><li>  Passing states via callback is tedious and provoking errors. </li><li>  It‚Äôs not easy for you to catch and handle exceptions if your code is spread among the myriad callbacks. </li><li>  and.  etc. </li></ul><br>  The slide above shows the code from the development team at Microsoft Patterns and Practices, and is the recommended way to handle a series of pictures in multi-threaded mode.  In any case, it should be noted that there is a lot of code that does not look too simple. <br><img src="https://habrastorage.org/getpro/habr/post_images/b9a/d28/590/b9ad28590d1649e469cd3d1f31591d92.png"><br>  And this is how you can write the same F # program using the F # Asynchronous Workflows library.  As I have said many times, F # was not created specifically for writing multi-threaded programs.  F # Asynchronous Workflows is just some functionality built into the F # library that makes asynchronous programming very easy.  It is enabled via F # Computation Expressions. <br>  In this code, you can see 'let!'  and 'do!'  F # Asynchronous Workflows performs these operations asynchronously, turning all activity on threads and callbacks behind the scenes. <br><br><h2>  disadvantages </h2><br>  So, I told you a lot about how great F # is, but let's go back to reality.  You do not believe that F # is a solid fairy tale? <br><img src="https://habrastorage.org/getpro/habr/post_images/41c/38f/f39/41c38ff39a40470151a14fcfc57b7a98.png"><br>  F # is not suitable for everything, here are some of these areas. <br><br><h4>  Presentation layer </h4><br>  In F # 1.0, we are not going to provide any code generators.  Therefore, you will not be able to use any WYSIWYG editors from WinForms or WPF.  If you want to write a presentation layer in F #, you have to, unfortunately, do it all by hand.  However, this is not the end of the world due to the FNET .NET involvement.  You can simply create your C # UI and call your F # code through the class libraries. <br><br><h4>  Object Oriented Hierarchies </h4><br>  Even though F # allows you to write object-oriented code, this is not the main language paradigm, so writing complex OO code may look a bit strange.  F # also supports many functional constructs that do not support C # and VB, such as tagged unions and currying functions.  Therefore, if you create an F # library that uncovers "functional" code, it would be wrong if you try to use it in non-functional languages. <br>  The main thing here is to properly encapsulate your F # code, programming in small, when you want to integrate it with a large component, programming in general. <br><br>  What to do next if you decide that F # is suitable for some part of your application?  Should you attend to hiring a group of loose nuclear physicists?  Not.  I can only repeat myself and shout a loud "NO!" From the bottom of my heart.  F # - not only for egg heads!  For example, this summer we hired several graduate interns to work on some examples of F #. <br>  Functional programming is essentially nothing complicated, it just considers tasks from a different point of view.  The main thing is to be attentive to the statements of your programmers when they learn F #. <br><ul><li>  <em>"It is almost the same as C #</em> . <em>"</em>  This means that they do not use it correctly.  The whole point of F # is that it offers a different way of thinking about programming, and in this, a different approach is more effective.  If you write a C # code in F #, you won‚Äôt win anything. </li><li>  <em>"F # is too simple for real-world tasks</em> . <em>"</em>  Although F # is easy to learn, you can achieve quite a lot even if you write simple functions. </li><li>  <em>"Functional programming makes my brain</em> . <em>"</em>  This means that you are on the right track.  Studying F # opens up other approaches to solving problems. </li></ul><br><h3>  Support </h3><br>  Let F # today help you write more productive code, but the question is, how easy can you handle it tomorrow?  What are the costs of maintaining an F # code in the long run? <br>  One of the main advantages of F # is that it is short.  I have already mentioned this before, but I will say it again: when you debug the code, the ability to see all the code relating to the problem on the screen saves you from having to constantly switch the context between different code files. <br>  It can be said that hallucinogenic functional code is more difficult to understand than the more usual imperative.  This, of course, is true, but it is also true that first of all you should not write hallucinogenic code.  (Just like there is no need for any other programming language).  The idiomatic F # code is clear and readable.  Of course, you can use many features of the language, such as composition of functions and currying, without complicating the code too much. <br><br><h2>  Conclusion </h2><br>  In conclusion, I repeat: if you really like to use C # or VB, just use them further.  You can benefit from learning F #, as well as learning from any other language, but do not switch to F # if there is no definite reason for it. <br>  But if it seems to you that your language does not allow you to fully express your ideas to you, littering your code with unnecessary syntactic garbage, in which meaning is lost, try F #.  In areas related to a large number of computations or data transformations ‚Äî technical programming, IOP, parallel / asynchronous ‚Äî you can get substantial benefits. <br>  Writing F # code will not make your programs faster or less resource intensive, as if by magic.  All that he does is giving you the opportunity to look at the problem from the other side, from which its solution may turn out more efficient, and simply increases the number of ways to express your ideas. <br>  So, if you haven‚Äôt set yourself F #, you can do it right now: <a href="http://fsharp.net/">fsharp.net</a> <br>  Linux developers can work with F # in Mono.  <a href="http://mono-project.com/">mono-project.com</a> <br><br></div><p>Source: <a href="https://habr.com/ru/post/71656/">https://habr.com/ru/post/71656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../71645/index.html">Testing the world's most powerful plasma engine</a></li>
<li><a href="../71646/index.html">Yota is testing Mobile WiMAX Release 2.0 technology</a></li>
<li><a href="../71648/index.html">IKR has become cheaper and more affordable! We open a set of students for the course!</a></li>
<li><a href="../71651/index.html">Rubik's Cube 2.0</a></li>
<li><a href="../71654/index.html">Comparing OpenOffice and ms office</a></li>
<li><a href="../71657/index.html">Peterhost, accident in DC STEK</a></li>
<li><a href="../71658/index.html">Now for torrents will be disabled?</a></li>
<li><a href="../71659/index.html">Why TV must die</a></li>
<li><a href="../71661/index.html">Book microservices</a></li>
<li><a href="../71664/index.html">Crazy Microsoft Multi-Touch Mouse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>