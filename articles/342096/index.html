<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to discover a million dollars in your AWS account</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We recently talked about ways to save more than a million dollars on AWS annual maintenance . Although we talked in detail about various problems and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to discover a million dollars in your AWS account</h1><div class="post__text post__text-html js-mediator-article">  We recently talked about ways to <a href="https://segment.com/blog/the-million-dollar-eng-problem/">save more than a million dollars on AWS annual maintenance</a> .  Although we talked in detail about various problems and solutions, the most popular question was still: ‚ÄúI know that I spend too much on AWS, but how can we really break up these expenses into understandable parts?‚Äù <br><br>  At first glance, the problem seems rather simple. <br><br>  You can easily split your AWS expenses by month and finish on it.  Ten thousand dollars for EC2, one thousand for S3, five hundred dollars for network traffic, etc.  But there is something important missing - the combination of which particular products and development groups accounts for the lion's share of the costs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And note that you can change hundreds of instances and millions of containers.  Soon, what at first seemed like a simple analytical problem becomes unimaginably complex. <br><br>  In this continuation of the article, we would like to share information about the toolkit that we use ourselves.  We hope to be able to come up with a few ideas on how to analyze your costs with AWS, regardless of whether you have a couple of instances or tens of thousands. <br><a name="habracut"></a><br><h1>  Grouping by "product lines" </h1><br>  If you are doing extensive operations on AWS, you probably have two problems already. <br><br>  Firstly, it is difficult to notice if suddenly one of the development groups suddenly increases its budget. <br><br>  Our AWS bill exceeds $ 100K per month, and the cost of each AWS component changes rapidly.  In each specific week, we can roll out five new services, optimize the performance of DynamoDB and connect hundreds of new customers.  In such a situation, it is easy to miss the attention that some one team spent on EC2 by $ 20,000 more than last month. <br><br>  Secondly, it is difficult to predict how much the cost of servicing new customers will cost. <br><br>  For clarity, our company Segment offers a single API that sends analytical data to any third-party tools, data warehouses, S3 or internal information systems of companies. <br><br>  Although customers quite accurately predict how much traffic they will need and what products they prefer to use, but we constantly have problems with translating such a forecast into a specific dollar amount.  Ideally, we would like to say: ‚Äú1 million new API calls will cost us $ X, so we need to make sure we take at least $ Y from the client‚Äù. <br><br>  The solution to this problem for us was the division of infrastructure into what we call ‚Äúproduct lines‚Äù.  In our case, these directions are vaguely formulated as follows: <br><br><ol><li>  Integration (code that sends data from Segment to various analytics providers). </li><li>  API (a service that receives data in the Segment from client libraries). </li><li>  Data warehouses (a pipeline that loads Segment data into a <a href="https://segment.com/warehouses">user-defined data store</a> ). </li><li>  Website and CDN. </li><li>  Internal systems (common logic and support systems for all of the above). </li></ol><br>  Analyzing the whole project, we came to the conclusion that it is almost impossible to measure <i>everything</i> .  So instead, we set the task of tracking part of the costs in the account, say, 80%, and try to track these costs from beginning to end. <br><br>  It is more useful for businesses to analyze 80% of the account than to aim at 100%, get bogged down at the data collection stage and never produce any result.  Reaching 80% of the costs (the willingness to say ‚Äúthis is enough‚Äù) saved us again and again from futile data picking that does not give a dollar of savings. <br><br><h1>  Collection, then analysis </h1><br>  To split the costs by product, you need to download data for the billing system, that is, collect and subsequently combine the following data: <br><br><ol><li>  AWS billing information in CSV format is a CSV that generates AWS with all cost items. </li><li>  AWS marked resources are resources that can be marked in billing CSV. </li><li>  Unlabeled resources are services like EBS and ECS, which need special data conveyors for marking resource consumption by ‚Äúproduct lines‚Äù. </li></ol><br>  When we have determined the product directions for all this data, we can upload them for analysis to Redshift. <br><br><h1>  1. Billing CSV from AWS </h1><br>  Analyzing your costs starts with parsing a CSV file from AWS.  You can <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/billing-reports.html">activate the corresponding option on the billing portal</a> - and Amazon will save a CSV file with detailed billing information every day to S3. <br><br>  By detailed, I mean VERY detailed.  Here is a typical line in the report: <br><br><pre>  record_type |  LineItem
 record_id |  60280491644996957290021401
 product_name |  Amazon DynamoDB
 rate_id |  0123456
 subscription_id |  0123456
 pricing_plan_id |  0123456
 usage_type |  USW2-TimedStorage-ByteHrs
 operation |  StandardStorage
 availability_zone |  us-west-2
 reserved_instance |  N
 item_description |  $ 0.25 per free-of-month
 usage_start_date |  2017-02-07 03:00:00
 usage_end_date |  2017-02-07 04:00:00
 usage_quantity |  6e-08
 blended_rate |  0.24952229400
 blended_cost |  0.00000001000
 unblended_rate |  0.25000000000
 unblended_cost |  0.00000001000
 resource_id |  arn: aws: dynamodb: us-west-2: 012345: table / a-table
 statement_month |  2017-02-01 </pre><br>  This is due to an impressive amount of $ 0.00000001, that is, one millionth cent, for storage in the DynamoDB database of a single table on February 7 between 3:00 and 4:00 o'clock at night.  On a typical day, our CSV contains approximately six million such records.  ( <i>Unfortunately, most of them are with larger amounts than one millionth cent</i> .) <br><br>  To transfer data from S3 to Redshift we use the <a href="https://github.com/heroku/awsdetailedbilling">awsdetailedbilling</a> tool from Heroku.  This is a good start, but we didn‚Äôt have a normal way to link specific AWS costs to our product lines (that is, whether a specific instance time was used for integrations or for data warehouses). <br><br>  Moreover, approximately 60% of the cost comes from EC2.  Although this is the lion's share of costs, it is absolutely impossible to understand the connection between EC2 instances and specific product lines only from the CSV that AWS generates. <br><br>  There is an important reason why we couldn‚Äôt identify product lines simply by instance name.  The fact is that instead of running one process at a host, we use <a href="https://aws.amazon.com/ecs/">ECS (Elastic Container Service)</a> intensively to place <i>hundreds of</i> containers on a host and use resources much more intensively. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1be/002/833/1be002833c3ad8f73c57a25d2bc66cfa.png"><br><br>  Unfortunately, Amazon accounts <i>only</i> contain EC2 instance costs, so we did not have any information about the costs of containers running on the instance: how many containers were running at the usual time, how much of the pool we used, how many CPU and memory units we used. <br><br>  Worse, <i>nowhere</i> in the CSV is information about container autoscaling reflected.  To obtain this data for analysis, I had to write my own toolkit for collecting information.  In the following chapters, I will explain in more detail how this pipeline works. <br><br>  However, the AWS CSV file provides very good detailed service usage data, which became the basis for the analysis.  You just need to connect them with our grocery lines. <br><br>  <i>Note: This problem is also not going anywhere.</i>  <i>Instance-hours billing will become more and more of a concern in terms of ‚ÄúWhat do I spend my money on?‚Äù Because more and more companies are launching a bunch of containers on a large number of instances using systems like ECS, Kubernetes and Mesos.</i>  <i>There is some irony in the fact that Amazon itself has been experiencing the exact same problem for many years, because each EC2 instance is a Xen hypervisor that works in conjunction with other instances on the same physical server.</i> <br><br><h1>  2. Cost data from AWS marked resources </h1><br>  The most important and ready-to-process data comes from AWS ‚Äútagged‚Äù resources. <br><br>  By default, billing CSV does not contain any tags.  Therefore, it is impossible to distinguish how one EC2 instance or bake behaves compared to another. <br><br>  However, you can activate some labels that will appear next to your expenses for each unit using <a href="http://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/cost-alloc-tags.html">the cost allocation tags</a> . <br><br>  These tags are officially supported by many AWS resources, S3 buckets, DynamoDB tables, etc.  To display the cost allocation tags in CSV, you can enable the corresponding parameter in the AWS billing console.  After a day or so, the tag you selected (we selected <code>product_area</code> ) will begin to appear as a new column next to the corresponding resources in the detailed CSV report. <br><br>  If you‚Äôve not done any more optimizations, you can immediately start using the cost allocation tags for marking up your infrastructure.  This is essentially a ‚Äúfree‚Äù service and does not require any infrastructure to operate. <br><br>  After activating the function, we had two tasks: 1) marking the entire existing infrastructure;  2) checking that all new resources will be automatically tagged. <br><br><h3>  Layout of existing infrastructure </h3><br>  Tagging for existing infrastructure is pretty easy: for each specific AWS product, you request a list of the most expensive resources in Redshift - and slacken people in Slack until they tell you how to mark these resources.  Finish the procedure when tagging 90% or more of the resources by value. <br><br>  However, to ensure that <i>new</i> resources <i>are</i> flagged, some automation and tools are required. <br><br>  For this we use <a href="https://www.terraform.io/">Terraform</a> .  In most cases, the Terraform configuration supports adding the same cost allocation tags that are added through the AWS console.  Here is an example Terraform configuration for S3 Bucket: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">resource</span></span> <span class="hljs-string"><span class="hljs-string">"aws_s3_bucket"</span></span> <span class="hljs-string"><span class="hljs-string">"staging_table"</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">bucket</span></span> = <span class="hljs-string"><span class="hljs-string">"segment-tasks-to-redshift-staging-tables-prod"</span></span> tags { <span class="hljs-attribute"><span class="hljs-attribute">product_area</span></span> = <span class="hljs-string"><span class="hljs-string">"data-analysis"</span></span> <span class="hljs-comment"><span class="hljs-comment"># this tag is what shows up in the billing CSV } }</span></span></code> </pre> <br>  Although Terraform provides a basic configuration, we wanted to make sure that every time a new <code>aws_s3_bucket</code> resource is <code>aws_s3_bucket</code> to the Terraform file, the <code>product_area</code> tag is affixed. <br><br>  Fortunately, Terraform configurations are written in HCL (Hashicorp Configuration Language), which has a configuration parser with comments saved.  So we wrote a validation function that runs through all Terraform files and searches for markup resources without the <code>product_area</code> tag. <br><br><pre> <code class="hljs perl">func checkItemHasTag(item *ast.ObjectItem, resources <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[string]bool) error { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> looking <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">"resource"</span></span> <span class="hljs-string"><span class="hljs-string">"aws_s3_bucket"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> similar t := findS3BucketDeclaration(item) tags, ok := hclchecker.GetNodeForKey(t.List, <span class="hljs-string"><span class="hljs-string">"tags"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"aws_s3_bucket resource has no tags"</span></span>, resource) } t2, ok := tags.(*ast.ObjectType) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"expected 'tags' to be an ObjectType, got %#v"</span></span>, tags) } productNode, ok := hclchecker.GetNodeForKey(t2.List, <span class="hljs-string"><span class="hljs-string">"product_area"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"Could not find a 'product_area' tag for S3 resource. Be sure to tag your resource with a product_area"</span></span>) } }</code> </pre> <br>  We have established continuous integration for the repository with Terraform configs, and then added these checks, so tests will not pass if there is a resource to be markup without the <code>product_area</code> tag. <br><br>  This is not ideal ‚Äî tests are choosy, and people technically have the ability to create unlabeled resources directly in the AWS console, but the system works quite well for this stage.  The easiest way to describe a new infrastructure is through Terraform. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/416/3e9/33c4163e957773ab8160bb4409c6a235.png"><br><br><h3>  Processing data from cost allocation tags </h3><br>  After resource markup, their accounting is a simple task. <br><br><ol><li>  Find <code>product_area</code> tags for each resource to match resource identifiers with <code>product_area</code> tags. </li><li>  Add up the cost of all resources. </li><li>  Add the cost of product lines and record the result in a pivot table. </li></ol><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(unblended_cost) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> awsbilling.line_items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> statement_month = <span class="hljs-meta"><span class="hljs-meta">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> product_name=<span class="hljs-string"><span class="hljs-string">'Amazon DynamoDB'</span></span>;</code> </pre> <br>  You may want to break down the costs of AWS services - we have two separate tables, one for the product segments of Segment, and the other for AWS services. <br><br>  With the usual AWS cost sharing tags, we managed to allocate about 35% of the costs. <br><br><h3>  Analysis of booked instances </h3><br>  This approach is good for marked up, accessible instances.  But in some cases, AWS takes an advance payment for "booking."  Booking guarantees the availability of a certain amount of resources in exchange for an advance payment at reduced rates. <br><br>  In our case, it turns out that several large payments from last year‚Äôs December CSV account should be distributed over all months of the current year. <br><br>  To correctly account for these costs, we decided to use data on separate (unblended) costs for the period.  The request looks like this: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> unblended_cost, usage_start_date, usage_end_date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> awsbilling.line_items <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> start_date &lt; <span class="hljs-string"><span class="hljs-string">'2017-04-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> end_date &gt; <span class="hljs-string"><span class="hljs-string">'2017-03-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> product_name = <span class="hljs-string"><span class="hljs-string">'Amazon DynamoDB'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> resource_id = <span class="hljs-string"><span class="hljs-string">''</span></span>;</code> </pre> <br>  Subscription costs are recorded in the form of "$ X0000 of DynamoDB", so that they can not be attributed to any resource or product direction. <br><br>  Instead, we add up the cost of each resource by product line, and then we distribute the cost of the subscription in accordance with the percentage share.  If 60% of the expenses of EC2 were spent on data storage, we assume that 60% of the subscription fee for these purposes also went away. <br><br>  This is also not perfect.  If most of your account is taken from an advance payment, this distribution strategy will be distorted by small changes in current expenditures for operating instances.  In this case, you will want to distribute expenses based on information on the use of each resource, and it is more difficult to summarize than expenses. <br><br><h1>  3. Cost data from unlabeled AWS resources </h1><br>  Although the DynamoDB instance and table layout is great, other AWS resources <i>do not support</i> cost sharing tags.  These resources required the creation of an abstruse workflow in the style of Ruba Goldberg in order to successfully obtain data on costs and transfer them to Redshift. <br><br>  The two largest groups of unlabeled resources in our case are ECS and EBS. <br><br><h3>  ECS </h3><br>  The ECS system continuously increases and reduces the scale of our services, depending on the number of containers that each of them needs to work.  She is also responsible for rebalancing and packaging in containers in a large number of individual instances. <br><br>  ECS runs containers on hosts based on the number of "reserved CPUs and memory."  Each service tells you how many CPU parts it needs, and ECS either places new containers on the host with enough resources, or scales the number of instances to add the necessary resources. <br><br>  None of these ECS actions is directly reflected in the CSV billing report - but ECS is still responsible for running autoscaling for all of our instances. <br><br>  Simply put, we wanted to understand what ‚Äúpart‚Äù of a particular machine each container uses, but the CSV report only gives us a breakdown of the ‚Äúwhole unit‚Äù by instance. <br><br>  To determine the cost of a particular service, we developed our own algorithm: <br><br><ol><li>  Set up <a href="http://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Subscriptions.html">a Cloudwatch subscription</a> for each event when the ECS task starts or stops. </li><li>  Send relevant data of this event (service names, CPU / memory usage, start or stop, EC2 instance ID) to Kinesis Firehose (to accumulate individual events). </li><li>  Send data from Kinesis Firehose to Redshift. </li></ol><br>  As soon as all the start / stop / size data arrived at Redshift, we multiply the amount of time that this task worked in ECS (say, 120 seconds) by the number of CPU units it used on this machine (up to 4096 - this information is available in task description) to calculate the number of CPU-seconds for each service running on the instance. <br><br>  The total costs of the instance from the account are then divided between the services in accordance with the number of used CPU-seconds. <br><br>  This is also not an ideal method.  EC2 instances do not run all the time at 100% capacity, while the surplus is currently distributed among all services that worked on this instance.  This may or may not be the correct allocation of excess costs.  But (and here you can find out the general theme of this article) that is enough. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df7/f8f/140/df7f8f1408093053a9fc3303f5b1775e.png"><br><br>  In addition, we want to relate each ECS service to the corresponding product line.  However, we cannot mark them in AWS, because ECS <i>does not support cost sharing tags</i> . <br><br>  Instead, we add the <code>product_area</code> key to the Terraform module for each ECS service.  This key does not lead to any metadata sent to AWS, but it fills in a script that reads <code>product_area</code> keys for all services. <br><br>  This script then for each new data transfer publishes to the main branch for DynamoDB a map relating the names of services and product directions in base64 encoding. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a4/502/b35/7a4502b35c40bc99cb0e5dc2dc1155f4.png"><br><br>  Finally, then our tests check every new service that is tagged with the product line. <br><br><h3>  Ebs </h3><br>  Elastic Block Storage (EBS) also occupies a significant part of our account.  EBS volumes are usually connected to EC2 instances, and it makes sense to consider the costs of EBS volumes together with the corresponding EC2 instances for accounting.  However, the CSV billing from AWS does not show <i>which</i> EBS volume is connected to which instance. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1cb/946/278/1cb946278a647528a8f72ae42db1ec91.png"><br><br>  To do this, we again used Cloudwatch - subscribed to events such as ‚Äúconnect volume‚Äù and ‚Äúdisconnect volume‚Äù, and then registered EBS = EC2 links in the DynamoDB table. <br><br>  We then add the costs of the EBS volumes to the costs of the corresponding EC2 instances before we consider the costs of the ECS. <br><br><h1>  Merging data between accounts </h1><br>  So far, we have been discussing all our expenses in the context of a single AWS account.  But in reality this does not reflect our real AWS configuration, which is distributed across different AWS physical accounts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/b35/4c5/10ab354c5e17d774a7fdba82dac77e60.png"><br><br>  We use an operational account (Ops) not only to consolidate data and billing across all accounts, but also to provide a single point of access for engineers to make changes in production.  We separate the Stage stage from the production - so you can check that the API call, for example, to delete the DynamoDB table, is safely handled with the appropriate checks. <br><br>  Among these expense accounts, the Prod account dominates, but Stage account costs also account for a significant portion of the total AWS account. <br><br>  Difficulties begin when you need to write data about ECS services from your Stage account to the Redshift cluster on production. <br><br>  To be able to write ‚Äúbetween accounts‚Äù, we must allow Cloudwatch subscription handlers to take on production roles for writing to Firehose (for ECS) or DynamoDB (for EBS).  This is not easy to do, because you need to add the correct permissions of the correct function in the Stage account (sts.AssumeRole) and in the Prod account, and any error will lead to confusion permissions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/689/63f/c25/68963fc257c191104c3b41721f4ea595.png"><br><br>  For us, this means that the code for accounting does not work on the Stage account, and all information is entered into the database on the Prod account. <br><br>  Although a second service can be added to the Stage account, which is subscribed to the same data, but does not record it, we decided that in this case there is a chance to encounter random problems in the accounting code of the Stage. <br><br><h1>  Statistics issue </h1><br>  Finally, we have everything for proper data analysis: <br><br><ol><li>  Marked resources in CSV. </li><li>  Data when each ECS event starts and stops. </li><li>  Binding the names of ECS services to the relevant product lines. </li><li>  Binding EBS volumes to connected instances. </li></ol><br>  To give it all to the analytic team, I broke the AWS data.  For each AWS service, I summarized the Segment product lines and their costs for this AWS service. <br><br>  These data are given in three different tables: <br><br><ol><li>  Total costs for each ECS service in a given month. </li><li>  Total expenses for each product line in a given month. </li><li>  Total expenses for (AWS service, grocery segment Segment) a given month.  For example, "Data Warehouse Direction spent $ 1,000 on DynamoDB last month." </li></ol><br>  The total costs for individual product lines look like this: <br><br><pre>  month |  product_area |  cost_cents
   --------------------------------------
   2017-03-01 |  integrations |  500
   2017-03-01 |  warehouses |  783 </pre><br>  And the costs of AWS services in combination with the Segment product lines look like this: <br><br><pre>  month |  product_area |  aws_product |  cost_cents
   -------------------------------------------------- -
   2017-03-01 |  integrations |  ec2 |  333
   2017-03-01 |  integrations |  dynamodb |  167
   2017-03-01 |  warehouses |  redshift |  783 </pre><br>  For each of these tables, we have a summary table with totals for each month and an additional pivot table that updates the data for the current month every day.  The unique identifier in the pivot table matches each pass, so you can consolidate the AWS score by finding all the rows for that pass. <br><br>  The resulting data effectively serves as our golden "source of truth", which is used for high-level metrics and reporting to management.  Pivot tables are used to monitor current costs during the month. <br><br>  <i>Note: AWS issues a ‚Äúfinal‚Äù account only a few days after the end of the month, so any logic that marks the billing records as final at the end of the month will be incorrect.</i>  <i>You can find out the final Amazon score when an integer appears in the <code>invoice_id</code> field in the CSV file, not the word ‚ÄúEstimated‚Äù.</i> <br><br><h1>  Some last tips </h1><br>  Before concluding, we realized that in the whole process there are some places where a little preparation and knowledge could save us a lot of time.  Without any sorting here are these places: <br><br><ul><li>  Scripts that aggregate data or copy it from one place to another are rarely reached by developers ‚Äî and their work is often not adequately monitored.  For example, one of our scripts copied CSV billing data from one S3 bucket to another, but crashed with an error of 27-28 of each month, because the Lambda processor did not have enough memory during copying when the CSV file became large enough.  It took us some time to notice this, because Redshift has a lot of data and it looks believable for each month.  Since then, we have added monitoring of the Lambda function to ensure the execution of the script without errors. </li><li>  Make sure these scripts are well documented, especially with information on how they are involved and what configuration is needed.  Link to source code in other places where these scripts are mentioned.  For example, in all the places where you are requesting data from bake S3, put a link to a script that writes data to bake.  Also think about writing the README file in the S3 batch directory. </li><li>  Redshift queries can run really slowly without optimization.  Check with your Redshift specialist in your company and think about what queries you need before creating new tables in Redshift.  In our case, the correct sort key in the CSV billing tables was missed.  <i>After creating the table, you can no longer add sorting keys</i> , so if you do not take care of this in advance, you will have to create a second table with the correct keys, forward write operations there, and then copy all the data. </li><li>  Using the correct sort keys reduced the execution time of the query phase during a pass for the pivot table from approximately 7 minutes to 10-30 seconds. </li><li>  Initially, we planned to run scripts to update the pivot table on a schedule - Cloudwatch can run the AWS Lambda function several times a day.  However, the size of the aisle was inconsistent (especially when it included a record in Redshift) and exceeded the maximum Lambda timeout, so instead we transferred them to the ECS service. </li><li>  Initially, we chose JavaScript for the pivot table update code, because it runs on Lambda and most of the scripts in our company are written in JavaScript.  If I knew that I would have to switch to ECS, I would choose another language with better support for adding 64-bit numbers, parallelizing and canceling work. </li><li>  Every time you start writing new data in Redshift, change the data (say, add new columns) or fix integrity errors with regard to data analysis, add a note to the README file with the date and change information.  This will be extremely useful for your data analysis team. </li><li>  Blended costs are not very helpful with this type of analysis - stick to unblended costs.  They show what specifically AWS charges for this resource. </li><li>  The CSV report has 8 or 9 lines, where Amazon does not indicate the name of the service.  They represent the total amount of the invoice, but give up any attempts to summarize the unmixed expenses for a given month.  Make sure that these figures are excluded from the summation of expenses. </li></ul><br><h1>  Bottom line </h1><br>  Getting AWS visuals is not easy.  This requires a lot of work ‚Äî both for developing and configuring the toolkit, and for identifying expensive resources on AWS. <br><br>  The biggest victory we have achieved is the possibility of simple continuous cost forecasting instead of periodic ‚Äúone-time analyzes‚Äù. <br><br>  To do this, we automated all data collection, implemented tag support in Terraform and our continuous integration system, and explained to all members of the development team how to tag their infrastructure correctly. <br><br>  All our data is not dead weight in PDF, but is continuously updated in Redshift.  If we want to answer new questions and generate new reports, we instantly get the results using a SQL query. <br><br>  In addition, we exported all the data in Excel format, where we can accurately calculate how much a new client will cost us.  And we can also see if a lot more money suddenly goes to some kind of service or product line - we see it before unplanned expenses affect the financial condition of the company. <br><br>         , - ,                    ! </div><p>Source: <a href="https://habr.com/ru/post/342096/">https://habr.com/ru/post/342096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342078/index.html">How to launch and promote your application based on the SAP Cloud Platform using Skolkovo and SAP</a></li>
<li><a href="../342080/index.html">Run / debug Python scripts in LXC / LXD containers from under VS Code</a></li>
<li><a href="../342088/index.html">How to increase the level of service and increase the profits of companies using communication solutions</a></li>
<li><a href="../342090/index.html">Java nested classes</a></li>
<li><a href="../342094/index.html">Export data in any format: what IDE can do on IntelliJ platform</a></li>
<li><a href="../342098/index.html">Testing through the eyes of the developer: tools, myths, situations</a></li>
<li><a href="../342100/index.html">Universal smart multi-signature contract in Ethereum</a></li>
<li><a href="../342102/index.html">Technical features of the ICO. Start</a></li>
<li><a href="../342104/index.html">In five days I was interviewed at five Silicon Valley companies and received five job offers</a></li>
<li><a href="../342106/index.html">Just about D3.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>