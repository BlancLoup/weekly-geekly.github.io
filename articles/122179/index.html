<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making Linux From Scratch our universal distribution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It so happened that a couple of years ago, on duty, the development team to which I belong fell in an unexpected task - developing a hardware manageme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making Linux From Scratch our universal distribution</h1><div class="post__text post__text-html js-mediator-article">  It so happened that a couple of years ago, on duty, the development team to which I belong fell in an unexpected task - developing a hardware management system (this is something unexpected, for the direction of development is) with a management PC for Linux. <br>  The development of the Linux part was conducted (and conducted) under Ubuntu, in the environment of Code :: Blocks.  But, as practice has shown, for quality work you need something much lighter with a guaranteed response time.  A console was enough to work, since the tasks of organizing the user interface were solved on a remote computer connected via TCP / IP. <br>  Then the idea came to use the Linux distribution of its own assembly, which (in fact, in the distribution of the distribution kit), I actually did in my spare time.  The choice fell on the LFS.  About the fact that such LFS has already been repeatedly written even on Habr√©, I will describe the solution of several additional (except for simple Linux) tasks that confronted me in our particular case. <br>  At first there was one such task - to use the real-time core. <br>  However, further, when the idea of ‚Äã‚Äãa USB flash drive with a distribution kit came to everyone‚Äôs liking, the tasks of reproducing flash drives and launching the system on various computers appeared (there are many test booths, having your flash drive stuck in your pocket and go to any one).  This is where the problems appeared - LFS is not 100% portable from one computer to another.  To adapt it to a specific computer, you need to edit some of the scripts, which is problematic under the conditions of yesterday‚Äôs Windows coders' commands (some were transferred to the virtual machine from Ubuntu, but the console and scripts are a disaster).  The reproduction of the system also requires the repetition of some manipulations performed during the assembly process (install the same GRUB). <br><a name="habracut"></a><br>  Naturally, the solution of all problems is on the Internet, but I think that collecting some information in one place will not hurt anyone. <br>  So, the specific tasks were the following ... <br><br><h5>  1. Using a Linux kernel with a real-time patch </h5><br>  It was one of the easiest tasks.  The build process went through the <a href="http://www.linuxfromscratch.org/lfs/">LFS</a> book with the only exception - instead of the standard kernel book, 2.6.33.9 was taken and an <a href="">RT patch</a> for it.  Everywhere, where there were manipulations with a kernel (installation of Linux Headers and kernels directly), we work with our patched version. <br>  Also, it would not be superfluous to say that the distribution was built without connecting a swap partition (2GB of RAM is in our case above the roof, the presence of a swap is not desirable because of its negative effect on the guaranteed response time, and it is extremely destructive for a flash drive) one single ext2fs partition. <br><br><h5>  2. Automatic login (under development conditions, security is not important to us, and we let the system under the root for several reasons) </h5><br>  The idea of ‚Äã‚Äãan automatic login was taken <a href="http://littlesvr.ca/linux-stuff/articles/autologinconsole/autologinconsole.php">from here</a> . <br>  An autologin.c file was created with the following content: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ execlp(<span class="hljs-string"><span class="hljs-string">"login"</span></span>, <span class="hljs-string"><span class="hljs-string">"login"</span></span>, <span class="hljs-string"><span class="hljs-string">"-f"</span></span>, <span class="hljs-string"><span class="hljs-string">"root"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Then the file was compiled with the command: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>gcc autologin.c -o /usr/local/sbin/autologin</code> <br> <br>  Further, it was decided that two consoles with automatic input would be enough (one to start the system, the other for everything else, if necessary). <br>  In the / etc / inittab file of the line: <br><br> <code>1:2345:respawn:/sbin/agetty tty1 9600 <br> 2:2345:respawn:/sbin/agetty tty2 9600</code> <br> <br>  were replaced by: <br><br> <code>1:2345:respawn:/sbin/agetty -n -l /usr/local/sbin/autologin tty1 9600 <br> 2:2345:respawn:/sbin/agetty -n -l /usr/local/sbin/autologin tty2 9600</code> <br> <br>  After that, there were no problems with the automatic login, so there was no additional manipulation of the scripts. <br><br><h4>  3. Unlinking the system from the order of connecting disks </h4><br>  Different BIOS has its own troubles.  Some, for example, believe that the first is the disk from which we boot.  In this case, our flash drive will be sda.  Others believe that you must first go hard drives, and then other devices.  In this case, our flash drive will have the name sdb, sdc, and so on. <br>  As a result, the system cannot boot from a disk that does not exist, the root directory cannot be mounted for the reason that the wrong disk is specified in / etc / fstab. <br>  Everything is solved either by fixing /boot/grub/grub.cfg and / etc / fstab for a specific machine, or using to load and mount not the drive name (sda, sdb, etc.), but the UUID of the file system, which for this file system the flash drive will be unique and, most importantly, permanent. <br>  The problem is that GRUB is able to work with a UUID, but the kernel does not, that is, it is impossible to directly mount the root system using a UUID (without knowing the name of the device).  This is not a bug, but a consequence of the ideological considerations of Linus Torvalds, so you should not hope for such a possibility in the future.  However, the workaround is - this is the <a href="http://en.gentoo-wiki.com/wiki/Initramfs">initramfs</a> . <br>  Initramfs is a temporary file system that helps in loading and mounting file systems of this system. <br>  The standard LFS assembly initramfs is not included, so to build it we will use the recommendations from the <a href="http://en.gentoo-wiki.com/wiki/Initramfs">Gentoo Wiki</a> and some of our own considerations (the option from the Gentoo Wiki did not solve the problem with the drive names without changes, and did not really work). <br>  To create the simplest system initramfs that mounts our main UUID, we need a simple shell and init script.  The full set of command line utilities is cumbersome enough for initramfs, so busybox is often used for this purpose, which, with its modest size and requirements, implements some of the most frequently used utilities. <br>  We are taking the latest version of busybox: <br><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> sources <br> wget http://busybox.<span class="hljs-built_in"><span class="hljs-built_in">net</span></span>/downloads/busybox-<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">18</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.tar.bz2</code> </pre> <br><br>  Unpack and configure: <br><br> <code>tar jxf busybox-1.18.4.tar.bz2 <br> cd busybox-1.18.4 <br> make menuconfig</code> <br> <br>  Configuration is done using a menu (like the Linux kernel).  In principle, the standard configuration is enough for our needs, but, just in case, it is worth checking that the following features are connected: <br>  Support for devfs - devfs support for working with / dev. <br>  Build Busybox as a static library (no shared libraries) - static layout, so as not to pull a bunch of so-libraries. <br>  Support version 2.6.x Linux kernels - support for 2.6 kernels. <br>  As well as support for the functionality of the utilities: sh, cat, cut, findfs, mount, umount, sleep, echo, switch_root. <br><br>  Compile: <br><br> <code>make</code> <br> <br>  Now we collect the directory tree of our file system: <br><br> <code>mkdir /usr/src/initramfs <br> cd /usr/src/initramfs <br> mkdir -p bin lib dev etc mnt/root proc root sbin sys <br> cp -a /dev/{null,console} /usr/src/initramfs/dev/</code> <br> <br>  Copy busybox and create links to utilities: <br><br> <code>cp /sources/busybox-1.18.4/busybox ./bin/ <br> cd bin <br> ln -s busybox sh <br> ln -s busybox cat <br> ln -s busybox cut <br> ln -s busybox findfs <br> ln -s busybox mount <br> ln -s busybox umount <br> ln -s busybox sleep <br> ln -s busybox switch_root <br> cd ..</code> <br> <br>  It remains to write the init script: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #    proc  sysfs mount -t proc none /proc mount -t sysfs none /sys # USB-     #     10 ,       sleep 10 #     mount -t devtmpfs none /dev #   UUID       for cmd in $(cat /proc/cmdline) ; do case $cmd in root=*) uuid=$(echo $cmd | cut -d= -f3) mount -o ro $(findfs UUID="$uuid") /mnt/root ;; esac done #      umount /dev umount /proc umount /sys #    exec switch_root /mnt/root /sbin/init</span></span></code> </pre><br><br>  Making our script executable: <br><br> <code>chmod +x /usr/src/initramfs/init</code> <br> <br>  Putting our temporary file system into archive: <br><br> <code>cd /usr/src/initramfs <br> find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; /boot/initrd.img-2.6.33-rt31</code> <br> <br>  Pay attention to the file name - it must match the name of the kernel (this is necessary for GRUB to pick it up correctly).  That is, if the kernel is named vmlinux- <u>2.6.33-rt31</u> , then initramfs should be named initrd.img- <u>2.6.33-rt31</u> . <br><br>  Now, when grub-mkconfig is executed, GRUB will detect the initramfs and also include the root system UUID in the configuration.  For verification, you can fix /boot/grub/grub.cfg by hand.  For example, the configuration: <br><br> <code>menuentry "Linux 2.6.33-rt31" --class gnu-linux --class gnu --class os { <br> insmod ext2 <br> set root='(hd0,1)' <br> search --no-floppy --fs-uuid --set 47029df8-8567-417d-b813-eedfe1ff8b0f <br> linux /boot/vmlinux-2.6.33-rt31 root=/dev/sda1 ro <br> }</code> <br> <br>  fix on: <br><br> <code>menuentry "Linux 2.6.33-rt31" --class gnu-linux --class gnu --class os { <br> insmod ext2 <br> set root='(hd0,1)' <br> search --no-floppy --fs-uuid --set 47029df8-8567-417d-b813-eedfe1ff8b0f <br> linux /boot/vmlinux-2.6.33-rt31 root=UUID=47029df8-8567-417d-b813-eedfe1ff8b0f ro <br> initrd /boot/initrd.img-2.6.33-rt31 <br> }</code> <br> <br>  The file system UUID can be found as follows (for example, for / dev / sdb1): <br><br> <code>blkid -p -o udev /dev/sdb1</code> <br> <br>  It remains to correct / etc / fstab, replacing the line: <br><br> <code>/dev/sda1 / ext2 defaults 1 1</code> <br> <br>  on <br><br> <code>UUID= 47029df8-8567-417d-b813-eedfe1ff8b0f / ext2 defaults 1 1</code> <br> <br>  It should also be noted that for all the manipulations above, it is necessary that the devtmpfs (CONFIG_DEVTMPFS = y) and initramfs (CONFIG_BLK_DEV_INITRD = y) support be enabled in the kernel. <br><br><h5>  4. Detaching the system from the network card </h5><br>  If more than one network card is installed in the computer, then parallel loading of the kernel modules does not guarantee that the boards will always be assigned names.  For example, there are two boards.  Board_1 has the name of the interface in the system eth0, Board_2 is eth1.  At the next reboot, it may happen that the Board_1 becomes eth1, and the Board_2 becomes eth0. <br>  To this end, the LFS binds the name to a specific board.  When booting on another computer there is a very high probability that the network will not rise. <br>  In my particular case, the board on all computers is the same and the IP is static (communication only with the terminal computer directly). <br>  The network interface in LFS is raised by the /etc/rc.d/init.d/network script.  We will add a script so that each time the system loads the configuration file /etc/udev/rules.d/70-persistent-net.rules is generated and this file is deleted upon completion of the work.  I suspect that there is a simpler method, but the method found has earned, and there was no time and special desire to delve into the principles of Udev work. <br>  We add to the beginning of the start section of the case command: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> NIC <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /sys/class/net/* <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> INTERFACE=<span class="hljs-variable"><span class="hljs-variable">${NIC##*/}</span></span> udevadm <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --action=add <span class="hljs-variable"><span class="hljs-variable">$NIC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br><br>  And at the end of the stop section (just before ;;) we add: <br><br><pre> <code class="bash hljs">rm /etc/udev/rules.d/70-persistent-net.rules</code> </pre><br><br>  Now, when booting on any system, the name of the network interface will be eth0 (except for the most exotic cases) and the network will go up.  Of course, the /etc/sysconfig/network-devices/ifconfig.eth0 directory with the ipv4 file must exist.  The contents of this file are described in the LFS book. <br><br><h5>  5. Writing a script that produces an LFS installation on any USB flash drive </h5><br>  The last thing left is to make an archive of the system and a script that will install it on an arbitrary medium. <br>  Boot into another system (not from a USB flash drive), mount a USB flash drive, for example in / mnt / usb-os.  Archiving content: <br><br> <code>cd /mnt/usb-os <br> tar -cvjf ~/pack.tar.bz2 *</code> <br> <br>  We write a script to install install_usb-os.sh.  As a parameter, the script takes the name of the device on which the system is to be deployed (for example, / dev / sdb).  The script itself will create the necessary partition and file system (/ dev / sdb1 if the name / dev / sdb is specified), unpack the archive and install GRUB. <br><br>  <b>It should run as root and, in fact, very dangerous.</b> <b><br></b>  <b>In case of an incorrect indication of the device name, all data on the working disk can be destroyed!</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh # ,       if [ "x${1}" = "x" ] ; then echo "Usage: install_usb-os device_name" exit fi #  ,     umount ${1}1 #      if [ ! -e /mnt/USBOSTmp ]; then mkdir /mnt/USBOSTmp fi #  MBR,      echo "Building partitions..." parted -s ${1} mklabel msdos parted -s ${1} unit % mkpart primary ext2 0 100 #          echo "Preparing filesystem..." mkfs -t ext2 ${1}1 mount -t ext2 ${1}1 /mnt/USBOSTmp #   echo "Unpacking distributive..." tar -xvf ./pack.tar.bz2 -C /mnt/USBOSTmp #    console  null # (,    , -  ) mknod -m 600 /mnt/USBOSTmp/dev/console c 5 1 mknod -m 666 /mnt/USBOSTmp/dev/null c 1 3 #     (  ..) echo "Mounting necessary file systems..." mount -v --bind /dev /mnt/USBOSTmp/dev mount -vt devpts devpts /mnt/USBOSTmp/dev/pts mount -vt tmpfs shm /mnt/USBOSTmp/dev/shm mount -vt proc proc /mnt/USBOSTmp/proc mount -vt sysfs sysfs /mnt/USBOSTmp/sys #  UUID         #  fstab uu=`blkid -p -o value ${1}1 | grep -` echo "Writing fstab for uuid=$uu..." cat &gt; /mnt/USBOSTmp/tmp/fstab &lt;&lt; "EOF" proc /proc proc defaults 0 0 sysfs /sys sysfs defaults 0 0 devpts /dev/pts devpts gid=4,mode=620 0 0 tmpfs /dev/shm tmpfs defaults 0 0 EOF echo "UUID=$uu / ext2 defaults 1 1" &gt;&gt; /mnt/USBOSTmp/tmp/fstab #    ,     #       #        GRUB cat &gt; /mnt/USBOSTmp/tmp/update.sh &lt;&lt; "EOF" echo "Starting internal update script for $H_DEV ..." mv -v /tmp/fstab /etc/fstab grub-mkconfig -o /boot/grub/grub.cfg echo "Updating mbr $H_DEV2..." grub-setup $H_DEV2 EOF #    chmod +x /mnt/USBOSTmp/tmp/update.sh #     root-, #       echo "Running update..." chroot /mnt/AxiOMATmp/ /usr/bin/env -i HOME=/root TERM="$TERM" PS1='\u:\w\$ ' PATH=/bin:/usr/bin:/sbin:/usr/sbin H_DEV=${1}1 H_DEV2=${1} /tmp/update.sh #   ,    rm -v /mnt/USBOSTmp/tmp/update.sh umount -v /mnt/USBOSTmp/dev/pts umount -v /mnt/USBOSTmp/dev/shm umount -v /mnt/USBOSTmp/dev umount -v /mnt/USBOSTmp/proc umount -v /mnt/USBOSTmp/sys umount ${1}1 rm -rvf /mnt/USBOSTmp echo "Installation finished!"</span></span></code> </pre><br><br>  Now we will make our script executable: <br><br> <code>chmod +x install_usb-os.sh</code> <br> <br>  We place the archive pack.tar.bz2 in the directory with the script and the installer is ready! </div><p>Source: <a href="https://habr.com/ru/post/122179/">https://habr.com/ru/post/122179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122172/index.html">Home, Catalog and Lists in the online store</a></li>
<li><a href="../122174/index.html">The main thing is the tail! or opt-out 2</a></li>
<li><a href="../122175/index.html">The first coin with a QR code</a></li>
<li><a href="../122176/index.html">100,000 NektoMe users</a></li>
<li><a href="../122178/index.html">AS3 Vector in AMF3: we lift the curtain</a></li>
<li><a href="../122181/index.html">Microsoft has announced successes in the fight against autorun viruses</a></li>
<li><a href="../122182/index.html">i-garden</a></li>
<li><a href="../122183/index.html">Wireless chips from Renesas Electronics Corp can work without batteries</a></li>
<li><a href="../122184/index.html">Experienced trivia-4, or "Measuring backups?"</a></li>
<li><a href="../122185/index.html">Amazon's hasty pre-order HP TouchPad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>