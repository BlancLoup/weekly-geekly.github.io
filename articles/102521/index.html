<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JPEG decoding for dummies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="UPD. Was forced to remove monospace formatting. One fine day, habraparser stopped understanding formatting inside the pre and code tags. The whole tex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JPEG decoding for dummies</h1><div class="post__text post__text-html js-mediator-article">  <i>UPD.</i>  <i>Was forced to remove monospace formatting.</i>  <i>One fine day, habraparser stopped understanding formatting inside the pre and code tags.</i>  <i>The whole text turned to mush.</i>  <i>Administration habr could not help me.</i>  <i>Now uneven, but at least readable.</i> <br><br>  [FF D8] <br><br>  Have you ever wanted to know how a jpg file works?  Now we will understand!  Warm up your favorite compiler and hex editor, we will decode it: <br><img src="https://habrastorage.org/storage/2d7e527a/4e4bf9fd/2a392e99/464246bb.png"><br>  Specially took a smaller picture.  This is a familiar, but strongly squeezed Google favicon: <img src="https://habrastorage.org/getpro/habr/post_images/606/696/104/60669610479084c8ecd776f5a2acd10c.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Immediately I warn you that the description is simplified, and the information provided is not complete, but then it will be easy to understand the specification. <br><br>  Even without knowing how the encoding happens, we can already extract something from the file. <br>  <b>[FF D8]</b> - the start marker.  It is always at the beginning of all jpg-files. <br>  Following are the bytes <b>[FF FE]</b> .  This is a marker indicating the beginning of the section with a comment.  The next 2 bytes <b>[00 04]</b> is the section length (including these 2 bytes).  So in the next two <b>[3A 29]</b> - the comment itself.  These are the character codes ":" and ")", i.e.  normal emoticon.  You can see it in the first line of the right side of the hex editor. <br><a name="habracut"></a><br><h2>  A bit of theory </h2><br>  Very briefly in steps: <br><ol><li>  Normally, the image is converted from RGB color space to <a href="http://ru.wikipedia.org/wiki/YCbCr">YCbCr</a> . </li><li>  Often the channels Cb and Cr are thinned, that is, the average value is assigned to a block of pixels.  For example, after thinning 2 times vertically and horizontally, the pixels will have the following correspondence: <br><img src="https://habrastorage.org/getpro/habr/post_images/89c/a1f/c09/89ca1fc0959d07711faf72e45359a2be.png"></li><li>  Then the channel values ‚Äã‚Äãare divided into 8x8 blocks (everyone saw these small squares on a too compressed image). </li><li>  Each block is subjected to a <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BA%25D0%25BE%25D1%2581%25D0%25B8%25D0%25BD%25D1%2583%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">discrete cosine transform (DCT)</a> , which is a kind of <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D0%25BA%25D1%2580%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5">discrete Fourier transform</a> .  Get the 8x8 matrix of coefficients.  Moreover, the upper left coefficient is called the DC coefficient (it is the most important and is the average value of all values), and the remaining 63 coefficient is the AC coefficients. </li><li>  The resulting coefficients are quantized, i.e.  each is multiplied by the quantization matrix coefficient (each encoder usually uses its own quantization matrix). </li><li>  Then they are encoded by <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25A5%25D0%25B0%25D1%2584%25D1%2584%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Huffman codes</a> . </li></ol>  Let's think about the order in which this data can be encoded.  Suppose, first, the Y channel is encoded completely, for the whole image, then Cb, then Cr.  Everyone remembers downloading pictures on dial-up.  If they were encoded this way, we would have to wait for the download of the entire image before it appears on the screen.  It will also be unpleasant if the end of the file is lost.  There are probably other good reasons.  Therefore, the encoded data are arranged alternately, in small pieces. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c4/665/8c0/5c46658c0cf703e0176ae4577d43632f.png"><br><br>  I recall that each block Y <sub>ij</sub> , Cb <sub>ij</sub> , Cr <sub>ij</sub> is a matrix of DCT coefficients encoded by Huffman codes.  In the file they are arranged in this order: <nobr>Y</nobr> <sub>00</sub> Y <sub>10</sub> Y <sub>01</sub> Y <sub>11</sub> Cb <sub>00</sub> Cr <sub>00</sub> Y <sub>20</sub> <br><br><h2>  Reading file </h2><br>  After we have extracted the comment, it will be easy to understand that: <br><ul><li>  The file is divided into sectors preceded by markers. </li><li>  Markers are 2 bytes long, with the first byte [FF]. </li><li>  Almost all sectors store their length in the next 2 bytes after the marker. </li></ul>  For convenience, highlight the markers: <br>  <font color="red">FF D8 FF FE</font> 00 04 3A 29 <font color="red">FF DB</font> 00 43 00 A0 6E 78 <br>  8C 78 64 A0 8C 82 8C B4 AA A0 BE F0 FF FF F0 DC <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <font color="red">FF DB</font> 00 <br>  43 01 AA B4 B4 F0 D2 F0 FF FF FF FF FF FF FF FF <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <br>  FF FF <font color="red">FF C0</font> 00 11 08 00 10 00 10 03 01 22 00 02 <br>  11 01 03 11 01 <font color="red">FF C4</font> 00 15 00 01 01 00 00 00 00 <br>  00 00 00 00 00 00 00 00 00 00 03 02 <font color="red">FF C4</font> 00 1A <br>  10 01 00 02 03 01 00 00 00 00 00 00 00 00 00 00 <br>  00 01 00 12 02 11 31 21 <font color="red">FF C4</font> 00 15 01 01 01 00 <br>  00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 <font color="red">FF</font> <font color="red"><br></font>  <font color="red">C4</font> 00 16 11 01 01 01 00 00 00 00 00 00 00 00 00 <br>  00 00 00 00 11 00 01 <font color="red">FF DA</font> 00 0C 03 01 00 02 11 <br>  03 11 00 3F 00 AE E7 61 F2 1B D5 22 85 5D 04 3C <br>  82 C8 48 B1 DC BF <font color="red">FF D9</font> <br><br><h4>  Marker [FF DB]: DQT - quantization table. </h4><br><br>  <font color="red">FF DB</font> <font color="blue">00 43</font> 00 A0 6E 78 <br>  8C 78 64 A0 8C 82 8C B4 AA A0 BE F0 FF FF F0 DC <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <br>  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF <br><br>  The section header always takes 3 bytes.  In our case it is [00 43 00].  The header consists of: <br>  <b>[00 43]</b> Length: 0x43 = 67 bytes <br>  <b>[0_]</b> The length of the values ‚Äã‚Äãin the table: 0 (0 - 1 byte, 1 - 2 bytes) <br>  <b>[_0]</b> Table ID: 0 <br>  The remaining 64 bytes need to fill the table 8x8. <br>  [A0 6E 64 A0 F0 FF FF FF] <br>  [78 78 8C BE FF FF FF FF] <br>  [8C 82 A0 F0 FF FF FF FF] <br>  [8C AA DC FF FF FF FF] <br>  [B4 DC FF FF FF FF FF] <br>  [F0 FF FF FF FF FF FF] <br>  [FF FF FF FF FF FF FF] <br>  [FF FF FF FF FF FF FF] <br><br>  Look at the order in which the table values ‚Äã‚Äãare filled.  This order is called zigzag order: <br><img src="https://habrastorage.org/getpro/habr/post_images/1bb/864/cb2/1bb864cb21ec837caa4c9d9055ae76a7.png"><br><br><h4>  Marker [FF C0]: SOF0 - Baseline DCT </h4><br>  This marker is called SOF0, and means that the image is encoded with the base method.  It is very common.  But the progressive-method familiar to you is no less popular on the Internet, when you first load an image with a low resolution, and then a normal picture.  This allows you to understand what is shown there, without waiting for the full load.  The specification defines a few more, as it seems to me, not very common methods. <br><br>  <font color="red">FF C0</font> <font color="blue">00 11</font> 08 00 10 00 10 03 01 22 00 02 <br>  11 01 03 11 01 <br><br>  <b>[00 11]</b> Length: 17 bytes. <br>  <b>[08]</b> Precision: 8 bits.  In the base method is always 8. As I understand it, this is the width of the channel values. <br>  <b>[00 10]</b> The height of the pattern: 0x10 = 16 <br>  <b>[00 10]</b> Pattern width: 0x10 = 16 <br>  <b>[03]</b> Number of components: 3. Most often it is Y, Cb, Cr. <br><br>  1st component: <br>  <b>[01]</b> ID: 1 <br>  <b>[2_]</b> Horizontal thinning (H <sub>1</sub> ): 2 <br>  <b>[_2]</b> Vertical thinning (V <sub>1</sub> ): 2 <br>  <b>[00]</b> Quantization Table ID: 0 <br><br>  2nd component: <br>  <b>[02]</b> ID: 2 <br>  <b>[1_]</b> Horizontal thinning (H <sub>2</sub> ): 1 <br>  <b>[_1]</b> Vertical thinning (V <sub>2</sub> ): 1 <br>  <b>[01]</b> Quantization table ID: 1 <br><br>  3rd component: <br>  <b>[03]</b> ID: 3 <br>  <b>[1_]</b> Horizontal thinning (H <sub>3</sub> ): 1 <br>  <b>[_1]</b> Vertical thinning (V <sub>3</sub> ): 1 <br>  <b>[01]</b> Quantization table ID: 1 <br><br>  Now look at how to determine how thinned the image is.  Find <nobr>H</nobr> <sub>max</sub> = 2 and <nobr>V</nobr> <sub>max</sub> = 2.  Channel i will be cut in <nobr>H</nobr> <sub>max</sub> / H <sub>i</sub> times horizontally and <nobr>V</nobr> <sub>max</sub> / V <sub>i</sub> times vertically. <br><br><h4>  Marker [FF C4]: DHT (Huffman table) </h4><br>  This section stores codes and values ‚Äã‚Äãobtained by <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25A5%25D0%25B0%25D1%2584%25D1%2584%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Huffman coding</a> . <br><br>  <font color="red">FF C4</font> <font color="blue">00 15</font> 00 01 01 00 00 00 00 <br>  00 00 00 00 00 00 00 00 00 00 03 02 <br><br>  <b>[00 15]</b> length: 21 bytes. <br>  <b>[0_]</b> class: 0 (0 is a table of DC coefficients, 1 is a table of AC coefficients). <br>  <b>[_0]</b> table ID: 0 <br>  The length of the Huffman code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <br>  Number of codes: <b>[01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00]</b> <br>  The number of codes means the number of codes of this length.  Note that the section stores only the length of the codes, not the codes themselves.  We have to find the codes ourselves.  So, we have one code of length 1 and one - length 2. Total 2 codes, there are no more codes in this table. <br>  Each code is associated with a value; they are listed next in the file.  Values ‚Äã‚Äãare single-byte, so we read 2 bytes. <br>  <b>[03]</b> - the value of the 1st code. <br>  <b>[02]</b> - the value of the 2nd code. <br><br>  Further in the file you can see 3 more markers [FF C4], I will skip the analysis of the corresponding sections, it is similar to the above. <br><br><h4>  Building a tree of Huffman codes </h4><br>  We need to build a binary tree on the table that we got in the DHT section.  And already on this tree, we learn each code.  Values ‚Äã‚Äãare added in the order shown in the table.  The algorithm is simple: in whatever node we are, we always try to add value to the left branch.  And if she is busy, then right.  And if there is no place there, then we return to the level above, and try from there.  You need to stop at a level equal to the length of the code.  The left branches correspond to the <nobr>value 0</nobr> , the <nobr>right - 1</nobr> . <br>  <i>Comment:</i> <i><br></i>  <i>No need to start from the top every time.</i>  <i>Added value - go back one level.</i>  <i>Does the right branch exist?</i>  <i>If yes, go up again.</i>  <i>If not, create the right branch and go there.</i>  <i>Then, from this point, start the search to add the next value.</i> <br><br>  Trees for all tables in this example: <br><img src="https://habrastorage.org/getpro/habr/post_images/95b/32a/4ae/95b32a4aed58e4b2f5c9c8a4dc3ea8b5.png"><br>  <b>UPD (thanks to <a href="https://habrahabr.ru/users/anarsoul/" class="user_link">anarsoul</a> ):</b> <i>At the nodes of the first tree (DC, id = 0), the values ‚Äã‚Äã0x03 and 0x02 should be</i> <br><br>  In the circles - the values ‚Äã‚Äãof the codes, under the circles - the codes themselves (I will explain that we got them by going from the top to each node).  It is with such codes (this and other tables) that the very content of the picture is encoded. <br><br><h4>  Marker [FF DA]: SOS (Start of Scan) </h4><br>  Byte [DA] in the marker means - "YES!  Finally, we went directly to the analysis section of the encoded image! ".  However, the section is symbolically called SOS. <br><br>  &amp; nbsp <font color="red">FF DA</font> <font color="blue">00 0C</font> 03 01 00 02 11 <br>  03 11 00 3F 00 <br><br>  <b>[00 0C]</b> The length of the header part (and not the entire section): 12 bytes. <br>  <b>[03] The</b> number of scan components.  We have 3, one for Y, Cb, Cr. <br><br>  1st component: <br>  <b>[01]</b> Image component number: 1 (Y) <br>  <b>[0_]</b> Huffman table ID for DC coefficients: 0 <br>  <b>[_0]</b> Huffman table ID for AC coefficients: 0 <br><br>  2nd component: <br>  <b>[02]</b> Image component number: 2 (Cb) <br>  <b>[1_]</b> Huffman table identifier for DC coefficients: 1 <br>  <b>[_1]</b> Huffman table identifier for AC coefficients: 1 <br><br>  3rd component: <br>  <b>[03]</b> Image component number: 3 (Cr) <br>  <b>[1_]</b> Huffman table identifier for DC coefficients: 1 <br>  <b>[_1]</b> Huffman table identifier for AC coefficients: 1 <br><br>  These components alternate cyclically. <br><br>  <b>[00], [3F], [00] You</b> can read about these bytes in the specification. <br><br>  This ends the header part, from here to the end (marker [FF D9]) encoded data. <br><br>  <b>[AE] [E7] [61] [F2] [1B]</b> <br>  101011101110011101100001111100100 <br><br>  Finding DC coefficient. <br>  <b>1.</b> We read a sequence of bits <i>(if we meet 2 bytes [FF 00], then this is not a marker, but simply a byte [FF])</i> .  After each bit, we move along the Huffman tree (with the corresponding identifier) ‚Äã‚Äãalong the 0 or 1 branch, depending on the read bit.  We stop if we are in the final node. <br>  <font color="blue">10</font> 1011101110011101100001111100100 <br><br>  <b>2.</b> Take the value of the node.  If it is 0, then the coefficient is 0, write to the table and go on to reading other coefficients.  In our case, 02. This value is the length of the coefficient in bits.  That is, we read the next 2 bits, this will be the coefficient. <br>  <font color="blue">10</font> <font color="magenta">10</font> 11101110011101100001111100100 <br><br>  <b>3.</b> If the first digit of the value in binary representation is 1, then leave it as it is: DC_coef = value.  Otherwise, convert: <nobr>DC_coef = value-2 is the <sup>length of the value</sup> +1</nobr> .  Write the coefficient in the table at the beginning of the zigzag - the upper left corner. <br><br>  Finding AC coefficients. <br>  <b>1.</b> Similar to p. 1, finding the DC coefficient.  We continue to read the sequence: <br>  <font color="blue">10</font> <font color="magenta">10</font> <font color="blue">1110</font> 1110011101100001111100100 <br><br>  <b>2.</b> Take the value of the node.  If it is 0, this means that the remaining values ‚Äã‚Äãof the matrix must be filled with zeros.  Further the next matrix is ‚Äã‚Äãalready encoded.  The first few who have read this far and have written about this to me in PM will get a plus in karma.  In our case, the value of the node: 0x31. <br>  The first nibble: 0x3 is exactly the number of zeros we need to add to the matrix.  These are 3 zero coefficients. <br>  The second nibble: 0x1 is the length of the coefficient in bits.  We read the next bit. <br>  <font color="blue">10</font> <font color="magenta">10</font> <font color="blue">1110</font> <font color="magenta">1</font> 110011101100001111100100 <br><br>  <b>3.</b> Similar to p. 3 of finding the DC-coefficient. <br><br>  As you already understood, it is necessary to read the AC-coefficients until we stumble upon the zero code value, or until the matrix is ‚Äã‚Äãfilled. <br>  In our case, we get: <br>  <font color="blue">10</font> <font color="magenta">10</font> <font color="blue">1110</font> <font color="magenta">1</font> <font color="blue">1100</font> <font color="magenta">11</font> <font color="blue">101</font> <font color="magenta">10</font> <font color="blue">0</font> <font color="magenta">0</font> <font color="blue">0</font> <font color="magenta">1</font> <font color="blue">11110</font> <font color="magenta">0</font> <font color="blue">100</font> <br>  and matrix: <br><br>  [2 0 3 0 0 0 0 0] <br>  [0 1 2 0 0 0 0 0] <br>  [0 -1 -1 0 0 0 0 0] <br>  [1 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br><br>  Have you noticed that the values ‚Äã‚Äãare filled in the same zigzag order? <br>  <i>The reason for using such an order is simple - since the larger the values ‚Äã‚Äãof v and u, the smaller the significance of the coefficient S <sub>vu</sub> in the discrete-cosine transform.</i>  <i>Therefore, at high compression ratios, minor coefficients are zeroed out, thereby reducing the file size.</i> <br><br>  Similarly, we get another 3 matrix Y-channel ... <br><br>  [-4 1 1 1 0 0 0 0] [5 -1 1 0 0 0 0 0] <br>  [0 0 1 0 0 0 0 0] [-1 -2 -1 0 0 0 0 0] <br>  [0 -1 0 0 0 0 0 0] [0 -1 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [-1 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br><br>  [-4 2 2 1 0 0 0 0] <br>  [-1 0 -1 0 0 0 0 0] <br>  [-1 -1 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br><br>  Oh, I forgot to say that the coded DC coefficients are not the DC coefficients themselves, but their differences between the coefficients of the previous table (of the same channel)!  It is necessary to correct the matrix: <br>  DC for the 2nd: 2 + (-4) = -2 <br>  DC for the 3rd: -2 + 5 = 3 <br>  DC for the 4th: 3 + (-4) = -1 <br><br>  [-2 1 1 1 0 0 0 0] [3 -1 1 0 0 0 0 0] [-1 2 2 1 0 0 0 0] <br>  ‚Ä¶‚Ä¶‚Ä¶ <br><br>  Now order.  This rule is valid until the end of the file. <br><br>  ... and on the matrix for Cb and Cr: <br><br>  [-1 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [1 1 0 0 0 0 0 0] [1 -1 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [1 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br><br>  Since there is only one matrix, DC coefficients can not touch. <br><br><h2>  Calculations </h2><br><h4>  Quantization </h4><br>  Do you remember that the matrix passes the quantization stage?  Matrix elements need to be multiplied by the elements of the quantization matrix.  It remains to choose the right one.  First, we scanned the first component, its image component = 1. The image component with this identifier uses the quantization matrix 0 (we have the first of the two).  So, after multiplication: <br><br>  [320 0 300 0 0 0 0 0] <br>  [0 120 280 0 0 0 0 0] <br>  [0 -130 -160 0 0 0 0 0] <br>  [140 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br><br>  Similarly, we get another 3 matrix Y-channel ... <br><br>  [-320 110 100 160 0 0 0 0] [480 -110 100 0 0 0 0] <br>  [0 0 140 0 0 0 0 0] [-120 -240 -140 0 0 0 0 0] <br>  [0 -130 0 0 0 0 0 0] [0 -130 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [-140 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br><br>  [-160 220 200 160 0 0 0 0] <br>  [-120 0 -140 0 0 0 0 0] <br>  [-140 -130 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0 0] <br><br>  ... and on the matrix for Cb and Cr. <br><br>  [-170 0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [180 210 0 0 0 0 0 0] [180 -210 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [240 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br>  [0 0 0 0 0 0 0] [0 0 0 0 0 0 0] <br><br><h4>  Inverse discrete cosine transform </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/9a1/1c0/b3d/9a11c0b3dc426b03ed5440c12ad6f36c.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d21/1da/ab8/d211daab85e2947353fe9dfca930b934.png"><br><br>  The formula should not deliver difficulties *.  S <sub>vu</sub> is our derived coefficient matrix.  u is a column, v is a string.  s <sub>yx</sub> - directly the values ‚Äã‚Äãof the channels. <br><br>  <i>* Generally speaking, this is not entirely true.</i>  <i>When I was able to decode and display a 16x16 image on the screen, I took a 600x600 image (by the way, it was the cover of my favorite album Mind.In.A.Box - Lost Alone).</i>  <i>It didn't work out right away - various bugs surfaced.</i>  <i>Soon I could admire the correctly loaded picture.</i>  <i>Only very upset the download speed.</i>  <i>I still remember, it took 7 seconds.</i>  <i>But it is not surprising if you thoughtlessly use the above formula, then to calculate one channel of one pixel you will need to find 128 cosines, 768 multiplications, and some additions.</i>  <i>Just think - almost a thousand difficult operations on just one channel of one pixel!</i>  <i>Fortunately, there is room for optimizing (after long experiments, I reduced the download time to the 15ms timer accuracy limit, and after that I changed the image to a photo with a 25 times larger area. Perhaps I will write about this in a separate article).</i> <br><br>  I will write the result of calculating only the first matrix of the channel Y (values ‚Äã‚Äãare rounded): <br>  [138 92 27 -17 -17 28 93 139] <br>  [136 82 5 -51 -55 -8 61 111] <br>  [143 80 -9 -77 -89 -41 32 32 86] <br>  [157 95 6 -62 -76 -33 36 86] <br>  [147 103 37 -12 -21 11 62 100] <br>  [87 72 50 36 37 55 79 95] <br>  [-10 5 31 56 71 73 68 62] <br>  [-87 -50 6 56 79 72 48 29] <br><br>  and 2 remaining: <br>  Cb cr <br>  [60 52 38 20 0 -18 -32 -40] [19 27 41 60 80 99 113 120] <br>  [48 41 29 13 -3 -19 -31 -37] [0 6 18 34 51 66 78 85] <br>  [25 20 12 2 -9 -19 -27 -32] [-27 -22 -14 -4 7 17 25 30] <br>  [-4 -6 -9 -13 -17 -20 -23 -25] [-43 -41 -38 -34 -30 -27 -24 -22] <br>  [-37 -35 -33 -29 -25 -21 -18 -17] [-35 -36 -39 -43 -47 -51 -53 -55] <br>  [-67 -63 -55 -44 -33 -22 -14 -10] [-5 -9 -17 -28 -39 -50 -58 -62] <br>  [-90 -84 -71 -56 -39 -23 -11 -4] [32 26 14 -1 -18 -34 -46 -53] <br>  [-102 -95 -81 -62 -42 -23 -9 -1] [58 50 36 18 -2 -20 -34 -42] <br><br>  And now ... a mini test! <br>  What to do next? <br><ol><li>  Oh, let's go eat! </li><li>  Yes, I do not drive in, what I mean. </li><li>  Once the color values ‚Äã‚Äãof YCbCr are obtained, it remains to convert to RGB, like this: <nobr>YCbCrToRGB (Y</nobr> <sub>ij</sub> , Cb <sub>ij</sub> , Cr <sub>ij</sub> ), Y <sub>ij</sub> , Cb <sub>ij</sub> , Cr <sub>ij</sub> are our resulting matrices. </li><li>  4 matrices Y, and Cb and Cr each, since we thinned the channels and 4 pixels Y correspond to Cb and Cr each.  Therefore, calculate as follows: <nobr>YCbCrToRGB (Y</nobr> <sub>ij</sub> , Cb <sub>[i / 2] [j / 2]</sub> , Cr <sub>[i / 2] [j / 2]</sub> ) </li></ol>  If you chose 1 and 4, then I'm happy for you.  Either you understood correctly, or you will soon enjoy food. <br><br><h4>  YCbCr to RGB </h4><br>  R = Y + 1.402 * Cr <br>  G = Y - 0.34414 * Cb - 0.71414 * Cr <br>  B = Y + 1.772 * Cb <br>  Do not forget to add 128 each. If the values ‚Äã‚Äãfall outside the interval [0, 255], then assign the boundary values.  The formula is simple, but it also erases the share of CPU time. <br><br>  Here are the resulting tables for the channels R, G, B for the left upper square 8x8 of our example: <br>  255 248 194 148 169 215 255 255 <br>  255 238 172 115 130 178 255 255 <br>  255 208 127 59 64 112 208 255 <br>  255 223 143 74 77 120 211 255 <br>  237 192 133 83 85 118 184 222 <br>  177 161 146 132 145 162 201 217 <br>  56 73 101 126 144 147 147 141 <br>  0 17 76 126 153 146 127 108 <br><br>  231 185 117 72 67 113 171 217 <br>  229 175 95 39 28 76 139 189 <br>  254 192 100 31 15 63 131 185 <br>  255 207 115 46 28 71 134 185 <br>  255 241 175 125 112 145 145 193 230 <br>  226 210 187 173 172 189 209 225 <br>  149 166 191 216 229 232 225 220 <br>  72 110 166 216 238 231 206 186 <br><br>  255 255 249 203 178 224 255 255 <br>  255 255 226 170 140 187 224 255 <br>  255 255 192 123 91 138 184 238 <br>  255 255 208 139 103 146 188 239 <br>  255 255 202 152 128 161 194 232 <br>  255 244 215 200 188 205 210 227 <br>  108 125 148 172 182 184 172 167 <br>  31 69 122 172 191 183 153 134 <br><br><h2>  the end </h2><br>  In general, I am not an expert on JPEG, so I can hardly answer all the questions.  Just when I was writing my decoder, I often had to face various incomprehensible problems.  And when the image was displayed incorrectly, I did not know where I had made a mistake.  Maybe he incorrectly interpreted the bits, and maybe incorrectly used DCT.  There was a lack of a step-by-step example, so I hope this article will help in writing a decoder.  I think it covers the description of the base method, but still it is impossible to do only by it.  I offer you links that helped me: <br>  <a href="http://ru.wikipedia.org/wiki/JPEG">ru.wikipedia.org/JPEG</a> - for superficial acquaintance. <br>  <a href="http://en.wikipedia.org/wiki/JPEG">en.wikipedia.org/JPEG</a> is a much more sensible article on encoding / decoding processes. <br>  <a href="http://www.w3.org/Graphics/JPEG/itu-t81.pdf">JPEG Standard (JPEG ISO / IEC 10918-1 ITU-T Recommendation T.81)</a> - can not do without the 186-page specification.  But there is no reason to panic - three quarters are flowcharts and applications. <br>  <a href="http://www.impulseadventure.com/photo/">impulseadventure.com/photo</a> - Good detailed articles.  By examples, I figured out how to build Huffman trees and use them when reading the relevant section. <br>  <a href="http://www.impulseadventure.com/photo/jpeg-snoop.html">JPEGsnoop</a> - On the same site there is a great utility that pulls out all the information of a jpeg-file. <br><br>  [FF D9] </div><p>Source: <a href="https://habr.com/ru/post/102521/">https://habr.com/ru/post/102521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../102512/index.html">Microsoft revealed the details of the new architecture XBox 360 250 GB</a></li>
<li><a href="../102515/index.html">Top 7 gadgets from China</a></li>
<li><a href="../102516/index.html">String Calculator - a simple calculator that counts math expressions with comments.</a></li>
<li><a href="../102518/index.html">How to make friends Mac OS X with Microsoft DFS</a></li>
<li><a href="../102520/index.html">Heliotrope - the world's first "solar" house, which produces energy</a></li>
<li><a href="../102523/index.html">Go language from the point of view of a PHP developer</a></li>
<li><a href="../102525/index.html">Next Startup Weekend</a></li>
<li><a href="../102526/index.html">Swype keyboard updated world typing speed record</a></li>
<li><a href="../102527/index.html">Broken links - some statistics</a></li>
<li><a href="../102528/index.html">How to make a cloud (cluster) hosting for a couple of kopecks *</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>