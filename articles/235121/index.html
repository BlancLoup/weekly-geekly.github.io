<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Atom - the minimum brick of a reactive application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Dmitry Karlovsky and I ... client-side developer. I have 8 years of support for various websites and web applications: from unknown ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Atom - the minimum brick of a reactive application</h1><div class="post__text post__text-html js-mediator-article">  Hello, my name is Dmitry Karlovsky and I ... client-side developer.  I have 8 years of support for various websites and web applications: from unknown online stores to such giants as Yandex.  And all this time I am not only figging in production, but also sharpening the ax to be at the cutting edge of technology.  And now, when you know that I‚Äôm not just fucking off the mountain, let me tell you about one architectural trick I‚Äôve been using for the last year. <br><br>  This article introduces the reader to the abstraction "atom", designed to automate the tracking of dependencies between variables and effectively update their values.  Atoms can be implemented in any language, but the examples in the article will be in javascript. <br><br>  Caution: reading can cause a dislocation of the brain, an attack of holivar, as well as sleepless nights of refactoring. <br><a name="habracut"></a><br><h4>  From simple to complex </h4><br>  This chapter briefly demonstrates the typical evolution of a fairly simple application, gradually leading the reader to the concept of the atom. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's imagine for a start such a simple task: you need to write a greeting message to the user.  Implementing this is not very difficult: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$foo = {} $foo.message = <span class="hljs-string"><span class="hljs-string">', !'</span></span> $foo.sayHello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML = $foo.message } $foo.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ $foo.sayHello() }</code> </pre> <br>  But it would not be bad to contact the user by name.  Suppose we have a username stored in localStorage, then the implementation will be a little more complicated: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$foo = {} $foo.userName = localStorage.userName $foo.message = <span class="hljs-string"><span class="hljs-string">', '</span></span> + $foo.userName + <span class="hljs-string"><span class="hljs-string">'!'</span></span> $foo.sayHello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML = $foo.message } $foo.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ $foo.sayHello() }</code> </pre><br>  But wait, the calculation of userName and message occurs during initialization, but what if at the time of the call to sayHello its name has already changed?  It turns out we will greet him by the old name, which is not very good.  So let's rewrite the code so that the message is calculated only when it really needs to be shown: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$foo = {} $foo.userName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localStorage.userName } $foo.message = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span> + $foo.userName() + <span class="hljs-string"><span class="hljs-string">'!'</span></span> } $foo.sayHello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML = $foo.message() } $foo.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ $foo.sayHello() }</code> </pre><br>  Notice that we had to change the message and userName fields interface - now they are stored not in the values ‚Äã‚Äãthemselves, but in the functions that return them. <br><br><blockquote>  Thesis 1: In order not to condemn yourself and other developers to tedious refactorings when changing the interface, try to immediately use an interface that allows you to change the internal implementation most freely. </blockquote><br>  We could hide the function call using <a href="http://msdn.microsoft.com/en-us/library/dd548687(VS.85).aspx">Object.defineProperty</a> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$foo = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty( $foo, <span class="hljs-string"><span class="hljs-string">"userName"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localStorage.userName } }) <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty( $foo, <span class="hljs-string"><span class="hljs-string">"message"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span> + $foo.userName + <span class="hljs-string"><span class="hljs-string">'!'</span></span> } }) $foo.sayHello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML = $foo.message } $foo.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ $foo.sayHello() }</code> </pre><br>  But I would recommend an explicit function call for the following reasons: <br><br>  * IE8 supports Object.defineProperty only for dom nodes. <br>  * Functions can be built into chains of the form $ foo.title ('Hello!') .UserName ('Anonymous'). <br>  * The function can be passed as a callback to somewhere: $ foo.userName.bind ($ foo) - the property will be transferred in its entirety (both the getter and the setter). <br>  * The function can store various additional information in its fields: from global identifier to validation parameters. <br>  * If you turn to a non-existent property, an exception will be raised instead of silently returning undefined. <br><br>  But what if the username changes after we show the message?  On good, you need to track this moment and redraw the message: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$foo = {} $foo.userName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localStorage.userName } $foo.message = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span> + $foo.userName() + <span class="hljs-string"><span class="hljs-string">'!'</span></span> } $foo._sayHello_listening = <span class="hljs-literal"><span class="hljs-literal">false</span></span> $foo.sayHello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !$foo._sayHello_listening ){ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'storage'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> event </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( event.key === <span class="hljs-string"><span class="hljs-string">'userName'</span></span> ) $foo.sayHello() }, <span class="hljs-literal"><span class="hljs-literal">false</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._sayHello_listening = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML = $foo.message() } $foo.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ $foo.sayHello() }</code> </pre><br>  And here we have committed a terrible sin - the implementation of the sayHello method, suddenly, knows about the internal implementation of the userName property (knows where it gets its value from).  It is worth noting that in the examples they are nearby only for clarity.  In a real application, such methods will be in different objects, the code will be in different files, and it will be supported by different people.  Therefore, this code should be rewritten so that one property can subscribe to changes of another through its public interface.  In order not to overcomplicate the code, let's use the <a href="http://api.jquery.com/trigger/">jQuery pub / sub</a> implementation: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$foo = {} $foo.bus = $({}) $foo._userName_listening = <span class="hljs-literal"><span class="hljs-literal">false</span></span> $foo.userName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._userName_listening ){ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'storage'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> event </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( event.key !== <span class="hljs-string"><span class="hljs-string">'userName'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $foo.bus.trigger( <span class="hljs-string"><span class="hljs-string">'changed:$foo.userName'</span></span> ) }, <span class="hljs-literal"><span class="hljs-literal">false</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._userName_listening = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localStorage.userName } $foo._message_listening = <span class="hljs-literal"><span class="hljs-literal">false</span></span> $foo.message = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._message_listening ){ $foo.bus.on( <span class="hljs-string"><span class="hljs-string">'changed:$foo.userName'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ $foo.bus.trigger( <span class="hljs-string"><span class="hljs-string">'changed:$foo.message'</span></span> ) } ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._message_listening = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">', '</span></span> + $foo.userName() + <span class="hljs-string"><span class="hljs-string">'!'</span></span> } $foo._sayHello_listening = <span class="hljs-literal"><span class="hljs-literal">false</span></span> $foo.sayHello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._sayHello_listening ){ $foo.bus.on( <span class="hljs-string"><span class="hljs-string">'changed:$foo.message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>{ $foo.sayHello() } ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._message_listening = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.innerHTML = $foo.message() } $foo.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ $foo.sayHello() }</code> </pre><br>  In this case, the communication between the properties is implemented via a single $ foo.bus bus, but it can be a scattering of individual EventEmitters.  Basically, the same scheme will be: if one property depends on another, then it must somewhere subscribe to its changes, and if it changes itself, then you need to send a notification about your change.  In addition, this code does not provide for a formal reply at all, when monitoring the value of a property is no longer required.  Let's enter the showName property, depending on the state of which we will show or not show the username in the welcome message.  The peculiarity of such a rather typical formulation of the problem is that if showName = 'false', then the message text does not depend on the value of userName and therefore we should not subscribe to this property.  Moreover, if we have already subscribed to it, because previously there was showName = 'true', then we need to unsubscribe from userName, after receiving showName = 'false'.  And so that life doesn‚Äôt seem to be paradise at all, let‚Äôs add another requirement: the values ‚Äã‚Äãobtained from localStorage properties must be cached so that it does not touch it again.  The implementation, by analogy with the previous code, will turn out to be too voluminous for this article, so we will use a slightly more compact pseudocode: <br><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> $foo.userName : subscribe <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> localStorage return <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from localStorage <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> $foo.showName : subscribe <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> localStorage return boolean from localStorage <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> $foo.message : subscribe <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> $foo.showName switch test $foo.showName when <span class="hljs-literal"><span class="hljs-literal">true</span></span> subscribe <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> $foo.userName return <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from $foo.userName when <span class="hljs-literal"><span class="hljs-literal">false</span></span> unsubscribe from $foo.userName return <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> $foo.sayHello : subscribe <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> $foo.message put <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> dom <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from $foo.message <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> start : <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> $foo.sayHello</code> </pre><br>  Here duplication of information is striking: next to actually obtaining the value of a property, we have to subscribe to its changes, and when it becomes known that the value of a property is not required - on the contrary, unsubscribe from its changes.  This is very important, because if in time you do not unsubscribe from the non-affecting properties, then as the application becomes more complex and the number of processed data increases, the overall performance will degrade more and more. <br><br><blockquote>  Thesis 2: In time, unsubscribe from non-affecting dependencies, otherwise, sooner or later, the application will begin to slow down. </blockquote><br>  The architecture described above is called Event-Driven.  And this is the least terrible version of it - in the more common case, subscription, cancellation and several ways to calculate the value are scattered in different places of the project.  Event-Driven architecture is very fragile, because you have to manually monitor timely subscriptions and unsubscribes, and the person is a lazy creature and not very attentive.  Therefore, the best solution is to minimize the influence of the human factor, hiding the event propagation mechanism from the programmer, allowing him to concentrate on describing how some data is obtained from others. <br><br>  Let's simplify the code, leaving only the minimum necessary information about dependencies: <br><br><pre> <code class="vbscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> userName : return <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from localStorage <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> showName : return boolean from localStorage <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> $foo.message : switch test $foo.showName when <span class="hljs-literal"><span class="hljs-literal">true</span></span> return <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from $foo.userName when <span class="hljs-literal"><span class="hljs-literal">false</span></span> return <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> $foo.sayHello : put <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> dom <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from $foo.message <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> start : <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> $foo.sayHello</code> </pre><br>  Keen readers have most likely already noticed that, after getting rid of a manual subscription-unsubscribe, the descriptions of the properties are so-called ‚Äúpure functions‚Äù.  Indeed, we have an <a href="http://en.wikipedia.org/wiki/Functional_reactive_programming">FRP</a> (Functional Reactive Paradigm).  Let's look at each term in more detail: <br><br>  Functional - each variable is described as a function that generates its value based on the values ‚Äã‚Äãof other variables. <br>  Reactive - a change in one variable automatically leads to an update of the values ‚Äã‚Äãof all variables depending on it. <br>  Paradigm - a programmer needs a few turn of thinking to understand and accept the principles of building an application. <br><br>  As you can see, everything described above revolves around variables and dependencies between them.  Let's call such frp-variables "atoms" and formulate their main properties: <br><br>  1. An atom stores in itself exactly one value.  This value can be either a primitive or any object, including the exception object. <br>  2. An atom stores a function for calculating a value based on other atoms through an arbitrary number of intermediate functions.  Appeals to other atoms when it is executed are tracked so that the atom always has up-to-date information about what other atoms affect its state, as well as about the state of which atoms depend on it. <br>  3. When changing the value of an atom, dependent on it should be updated in a cascade. <br>  4. Exceptions should not violate the consistency of the application state. <br>  5. The atom must be easily integrated with the imperative environment. <br>  6. Since almost every memory slot is wrapped into an atom, the implementation of atoms should be as fast and compact as possible. <br><br><br><h4>  Problems with the implementation of atoms </h4><br><br><h5>  1. Keeping dependencies up to date </h5><br>  If the calculation of the value of one atom required the value of another, then we can safely say that the first depends on the second.  If it wasn‚Äôt required, there is no direct correlation, but an indirect one is possible.  But tracking is necessary and only direct dependencies are sufficient. <br><br>  This is realized very simply: at the time of starting the calculation of one atom, somewhere in the global variable, it is remembered that it is current, and at the time of getting the value of another, besides returning this value, they are linked to each other.  That is, each atom in addition to the slot for the actual value should have two sets: the leading atoms (masters) and the slave (slaves). <br><br>  With the link, everything is somewhat more complicated: at the moment of start, you need to replace the set of leading atoms with the empty one, and after completing the calculation, compare the set with the previous one and link those who are not in the new set. <br><br>  This is how the autotracking of dependencies works in KnockOutJS and MeteorJS. <br><br>  But how do atoms know when to re-run the value calculation?  About this further. <br><br><br><h5>  2. Cascade consistent update of values </h5><br>  It would seem, what could be easier?  Immediately after changing the value, we run over the dependent atoms and initiate their update.  This is exactly what KnockOutJS does, and that is why it slows down during mass updates.  If one atom (A) depends on, for example, the other two (B, C), then if we consistently change their values, then the value of atom A will be calculated twice.  Now imagine that it does not depend on two, but on two thousand atoms, and each calculation takes at least 10 milliseconds. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebb/0a1/674/ebb0a1674d8b2b32328c042d32d95c48.svg" alt="image"><br><br>  While for KnockOutJS, developers in narrow places put throttl ingi and debouncers, MeteorJS developers approached the problem more systematically: they made a deferred call to recalculate dependent atoms instead of an immediate one.  For the above case, atom A recalculates its value exactly once and does it at the end of the current event handler, that is, after all the changes we made to atoms B, C, and any others. <br><br>  But this is not really a complete solution to the problem ‚Äî it pops up again when the depth of atom dependencies becomes greater than 2. I will illustrate with a simple example: atom A depends on atoms B and C, and C in turn depends on D. In case we if we successively change atoms B and D, then atoms A and C will be recalculated pending, and if the C atom changes its value, then the delayed calculation of the value A will be started again. This is usually not so fatal for speed, but if the calculation of A is quite a long operation, then doubling it can be shots  pour in the most unexpected place applications. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b5/95d/834/7b595d8345c54d0beacb1c95735a403f.svg" alt="image"><br><br>  Having understood the problem, it is easy to come up with a solution: it is enough to memorize the maximum depth among the leaders plus one when linking atoms, and when iterating over the pending ones to update the atoms, first of all update the atoms with a smaller depth.  Such a simple technique makes it possible to guarantee that by the time of recalculation of the value of an atom, all the atoms on which it directly depends are of current importance. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e9/93f/24e/8e993f24e4d969214462a118e93a3e1a.svg" alt="image"><br><br><h5>  3. Exception handling </h5><br>  Imagine this situation: atoms B and C depend on A. Atom B started calculating the value and turned to A. A - also began to calculate its value, but at that moment an exceptional situation occurred - it could be an error in the code or the absence of data - no matter.  The main thing is that the atom A must remember this exception, but allow it to surface further so that B can also remember or process it.  Why is this so important?  Because when C starts calculating the value and turns to A, the events for it should be the same as for B: when accessing A, an exception has surfaced that can be intercepted and processed, but you can do nothing and then the exception to be caught by the library implementing the atoms and stored in the computed atom.  If atoms did not memorize exceptions, then any access to them would trigger the launch of the same code inevitably leading to the same exception.  These are unnecessary expenses on processor resources, so it‚Äôs better to cache them like normal values. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b26/b16/26d/b26b1626dd884d1386a15788aaff3e36.svg" alt="image"><br><br>  Another, and even more important, point is that in the cascade update of atoms, the calculation of the values ‚Äã‚Äãof the same occurs in the opposite direction.  For example, atom A depends on B, and that depends on C, and that in general from D. When initialized, A begins to calculate its value and refers to B, that of C, and that of D. But the state is updated in the reverse order: D, then C, then B, and finally A: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4e/48e/d81/c4e48ed81ca62fd4e4de51437679c5c3.svg" alt="image"><br><br>  Subsequently, someone changes the value of the atom D. He notifies the atom C that its value is no longer relevant.  Then the atom C calculates its value and if it is not equal to the previous one, then it notifies atom B, which acts in a similar way to notify A. If at some of these moments we do not catch the exception and as a result do not notify dependent atoms, then we will have a situation when the application is in an inconsistent state: half of the application contains new data, half is old, but it is sure that new, and the third half has completely fallen and cannot rise at all, waiting for the data to change. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9e/e3a/b79/e9ee3ab7997eed21cc94e518ebbb7319.svg" alt="image"><br><br><h5>  4. Cyclic dependencies </h5><br>  The presence of cyclic dependencies indicates a logical error in the program.  However, the program should not hang or spin in an infinite cycle of deferred calculations.  Instead, the atom must detect that its value was required to calculate its value and to initiate an exception. <br><br>  It is detected simply: when starting a calculation, the atom remembers that it is now calculated, and when someone calls its value, it checks whether it is in the state of calculation and if it is, throws an exception. <br><br><h5>  5. Asynchrony </h5><br>  Asynchronous code is always a problem, because it turns the logic into spaghetti, which is difficult to follow behind the intricacies and easy to make mistakes.  When developing in javascript, you have to constantly balance between simple and clear synchronous code and asynchronous calls.  The main problem of asynchrony is that it as a <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25B4%25D0%25B0_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">monad</a> seeps through the interfaces: you cannot write a synchronous implementation of module A, and then, invisibly from module B using it, replace implementation A with asynchronous.  To make this change, you have to change the logic of module B, and the dependent C and D, and so on.  Asynchrony is like a virus that breaks through all of our abstractions and sticks out the internal realization to the outside. <br><br>  But atoms easily and simply solve this problem, although they didn‚Äôt even think about it at all: it‚Äôs all about reactivity.  When one atom accesses another, it can issue some answer at once, and in the meantime start an asynchronous task, after which it updates its value and the entire application is updated next in accordance with the received data.  Immediate response can be of several types: <br><br>  a) Return some default value.  For the trailing atoms, it would look like ‚Äúit was one value and suddenly it changed,‚Äù but they will not be able to understand the actual data they showed or not.  And it is often necessary to know that, for example, to show the user a message that his data has not disappeared anywhere and is about to be loaded. <br><br>  b) Return the locally cached version.  This option is suitable for relatively rarely changing data.  For example, the username from the beginning of this article is okay if, between the launches of an application, it changes its name and therefore it will see the previous name for a short time, then it will be able to start working with the application almost immediately.  Of course, this approach is not suitable for critical data, especially in conditions of poor connectivity, when an update can take a very long time. <br><br>  c) Honestly admit that there is no data and return a special value meaning no data.  For javascript this will be undefined.  But in this case, the correct handling of this value should be everywhere in the dependent code - this is a fairly large amount of the same type code in which it is easy enough to make a mistake, so by choosing this path, get ready for the constantly appearing Null Pointer Exception. <br><br>  d) After launching the asynchronous task, throw a special exception, which, as described above, will cascadely spread over all dependent atoms to those atoms where it can be processed.  For example, an atom responsible for displaying a list of users might catch an exception and instead of silently dropping a user to draw a message ‚Äúloading‚Äù or ‚Äúloading error‚Äù.  That is, starting with some remote atom, the exceptional situation becomes quite a regular one.  The advantage of this method is that the lack of data can be processed only in a relatively small number of code points, and not all the way to these places.  But here it is important to remember that with dependence on several atoms, the calculation will stop after the first to throw an exception, and the rest will not know that their data is also needed, although all the leading atoms could request their data in one single request.                ,  try-catch   . <br><br><h5> 6.     </h5><br>      FRP,           .  ,            . ,             .   ,       ,       ,    . ,     ,         . <br><br>      3     : <br><br> )   ‚Äî ,     .    ,  -     . <br> )  ‚Äî ,   .    ,        .       ,      .         ,   ,    ,    . <br> )   ‚Äî ,        . <br><br><h5> 7.   </h5><br>       ‚Äî      1 ,           . <br><br> ,    : <br><br> )   <br> )   (    ,     ) <br> )  :  ,  ,  , , ‚Ä¶ <br> )    <br> )    <br> )   <br> )    <br> )  ( ,       ) <br> )  ,    <br><br>       .   ,   : <br><br> )  ,      .       ,    ,        .   $digest  AngularJS,         ,     - ,     ¬´¬ª. <br><br> )    .        .         ,             . <br><br> )   -.      ,    (),       ,    ,           .        ‚Äî , , 10 ,  1  + 10 .    ,    ,        ,       . <br><br> )   .  ,     ,        ,     . <br><br> ) ,  ,     ,   .      ,   ,      ,   ,       . <br><br><h4>  Epilogue </h4><br>  ,        : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ccc/3a1/d76/ccc3a1d76b17523e0f1988c27c34fd8c.svg" alt="image"><br><br> A ‚Äî  .   ‚Äî   .   ‚Äî   . <br> S ‚Äî   ,      ,   ,        . <br> M ‚Äî  ,    . <br><br>    .      .    ,        . <br><br>     : <br> get ‚Äî  .    ,    pull   . <br> pull ‚Äî       .           .      ,        push . <br> push ‚Äî    ,       ,      merge  <br> merge ‚Äî     .    , dirty-checking, . <br> notify ‚Äî     . <br> fail ‚Äî     . <br> set ‚Äî                merge   ,   put. <br> put ‚Äî    push,     ,      . <br><br>    ,          .        javascript  "$jin.atom".     ,   ,  ,   .      . <br><br>   <a href="http://habrahabr.ru/post/240773/"></a> ,      .      . </div><p>Source: <a href="https://habr.com/ru/post/235121/">https://habr.com/ru/post/235121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../235107/index.html">Consulo - IDE where Java and C # live together</a></li>
<li><a href="../235109/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ122 (August 24 - 31, 2014)</a></li>
<li><a href="../235111/index.html">The evolution of remote control</a></li>
<li><a href="../235117/index.html">Placeholders - evil</a></li>
<li><a href="../235119/index.html">5 more layouts from VWO</a></li>
<li><a href="../235123/index.html">US providers are asked to ban the development of municipal high-speed Internet</a></li>
<li><a href="../235125/index.html">How to survive a tax audit?</a></li>
<li><a href="../235131/index.html">Our bike or scripts to facilitate the life of the admin</a></li>
<li><a href="../235135/index.html">Fastening for tablet MoveO! TPC-7SG on hand</a></li>
<li><a href="../235137/index.html">Amnesty and zeroing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>