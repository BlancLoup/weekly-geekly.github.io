<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Platform for video service for a quarter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will tell how we managed to build our platform for video service on Odnoklassniki in Java for 3 months. 

 To begin with, what is a video ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Platform for video service for a quarter</h1><div class="post__text post__text-html js-mediator-article">  Today we will tell how we managed to build our platform for video service on Odnoklassniki in Java for 3 months. <br><br>  To begin with, what is a video service on Odnoklassniki.  It is available both on the web and in versions for mobile devices.  One of the differences between Odnoklassniki and other social networks is the presence of video displays, where videos are collected in the TOP of the Week, Novinki and Channels sections.  For these sections, the video is automatically selected by a sly algorithm based on the number of views, classes and the rate of growth of the video's popularity.  And of course, the showcase shows channels with content from partners: - TV shows, TV shows, cartoons and movies. <br><br>  Basically, this is a standard video service.  The user uploads the video, then it passes moderation, after which other users can watch it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Over 10 million unique users a day use video service on Odnoklassniki, who watch over 70 million videos and download 50,000 videos per day. <br><br>  Videobase Odnoklassniki has over 28 million videos.  Outgoing traffic in the evenings reaches 80 gigabits per second.  Daily downloaded 5 terabytes of new video per day are converted to our internal format and the output is 2 terabytes.  The resulting files are stored in three copies, which, in total, totals 6 terabytes of new video per day.  Inbound traffic load reaches 2 gigabits at peak hours. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/317/bc7/398/317bc739899f6407b5d19312c96d2fc5.png"><br><a name="habracut"></a><br>  What does all this work?  Now the video service park has about 200 servers, and soon there will be much more.  The storage occupies 70 servers, the total volume is 5 Petabytes.  30 servers are engaged in the storage of metadata, this is the database and caches in front of them.  Another 60 servers are engaged in the transformation of custom video into our formats.  Another 30 servers - for download and distribution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/363/1ec/838/3631ec8381e251d573ab0b2a5ab04faa.png"><br><br>  We started developing video service on Odnoklassniki back in 2010.  At first, we didn‚Äôt have our own platform and we only allowed users to share links to content that was located on other resources: Rutube, YouTube, Mail.Ru Video.  In 2011, we launched the video download through the Odnoklassniki portal, but it all worked on the basis of the Mail.Ru Video platform.  The service began to grow, new requirements began to be made, and in January 2013 we realized that without creating our video platform, our service could not develop further. <br><br>  New platform - new requirements.  The first inherent requirement that applies to all Odnoklassniki servers is reliability, fault tolerance and full functionality retention in case of loss of the server or data center.  Next comes the resuming download.  It is necessary, otherwise we will lose user content.  In third place is video playback from any moment without pre-buffering the entire video.  We wanted to see all this on mobile devices.  We also love and know how to exploit Java services, so it was also added to the list of requirements. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1bf/87c/f81/1bf87cf8180685e55f57e8bb0d2e5680.png"><br><br>  Let's see what the whole video pipeline looks like from the inside.  The user uploads the video to the upload server (we will denote it in the pictures with the up arrow).  Then the video goes to the server storage, and then to the transformation server.  On it, we convert the video into our internal format, save it to a temporary storage, after which the download server (down arrow) distributes this content to users. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba3/2a1/dc3/ba32a1dc3e76c7b5ad46d743e8be361a.png"><br><br>  Let us consider in more detail the implementation of each stage. <br><br><h1>  Loading </h1><br>  Once again I will remind the requirements.  We wanted to implement a renewable load and provide fault tolerance in case of server loss.  That is, if a user uploads content to a specific server, and that one fails or network access disappears, then all download should continue on another server.  We set as our goal to ensure that we will process all the uploaded video in any case.  Of course, there is nginx for reloading, but we decided that its use is not quite convenient for our own storage, and therefore we implemented our solution in Java. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42f/00a/5c9/42f00a5c9b0f1211ad06c86c8f111483.png"><br><br>  What does our video load balancing system look like?  We have 6 servers, 2 in each data center.  For load balancing inside data centers, we use LVS (Linux Virtual Server).  This allows you to store multiple servers behind a single IP address and transfer requests to them, depending on their workload. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38a/5d0/4ce/38a5d04ced3d7d35671db8d5a26bb7db.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d6/afd/0b0/9d6afd0b0794b368cdc24e21c2ccb6b7.png"><br><br>  To ensure fault tolerance in data centers, we use DNS-GSLB.  The user clicks the "Add Video" button, gets a link to download, then the domain name is authorized into the IP address of one of the data centers.  DNS-GSLB is Global Server Load Balancing, its main function is to provide fault tolerance at the level of data centers.  In case of a data center failure, our DNS will not resolve (resolve, resolve) the domain name to this data center. <br><br>  Once again: if the server fails, the user is transferred to another one, and in the event of the entire data center failure, a new query via DNS resumes downloading via another data center.  What is convenient?  By the fact that we, first of all, do not write code, but use ready-made solutions, and secondly, this allows us to balance the load for any stateless services. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a5/c3d/ee6/6a5c3dee66a91113f7c25bca961c1461.png"><br><br>  Now how we have implemented stateless-service.  The user starts downloading to a specific server, and that, in turn, in units of the order of a megabyte, sends data to the distributed storage (we will talk about it later), necessarily via several data centers.  Upload server is implemented in Java, Apache Tomcat is used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3a/cf0/3d2/b3acf03d25cf5a67373a6749ca9cea2b.png"><br><br>  What happens when we lose a server, a data center, or, for example, a user simply reestablished a connection some time after the connection was broken?  Our new upload server, which does not have any session with this user, according to the state of the distributed storage, detects the last successfully loaded bytes, and resumes downloading from the disconnect point.  Fault tolerance is almost 100%.  Even if the data center is lost during the download process, the process resumes from the point where the gap occurred. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3d/35a/f23/d3d35af23123d1ac8fe77c73624954ba.png"><br><br><h1>  Transformation (recoding) </h1><br>  After the video is in temporary storage, it is converted to our internal unified format.  The basic format requirements are the ability to play it in different browsers and on different platforms.  Also, he should be able to store video in both high and low quality, be fault tolerant and scalable. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/504/583/4cf504583ad661d10787e0b8542d862a.png"><br><br>  When choosing a format, we analyzed the following data: the current prevalence of browsers and operating systems, including Android and iOS, the ability to play video in them through HTML5 and Flash.  Since the current Odnoklassniki player is implemented in Flash, we decided to support both HTML5 video and Flash. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb9/1b1/48b/cb91b148b025d7ea4672689d82942104.png"><br><br>  Having considered the formats supported by Flash and HTML5, we chose the MP4, as the media container - the H264 codec, the audio codec - AAC. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/182/26d/9a9/18226d9a98acded93381b4b5bdfcb2ef.png"><br><br>  So, after the video is successfully uploaded, it should go on conversion to our internal format.  This is done on the transformation servers, where we use the native FFMpeg library.  We now have about 60 transformation servers.  What happens to the video?  The upload server uploads the video to the temporary storage and at the end of the upload adds the transformation task to the queue. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/7ac/854/ad77ac8544a1eabe9f9cb5e5ac7c19fe.png"><br><br>  Tasks are distributed to the servers, but the fact is that FFMpeg is a rather unstable thing, it sometimes freezes, eats up all the system resources, and there are cases when the video is not converted the first time.  Therefore, we have added a permanent tracking of the status of tasks performed.  That is, the process looks like this: the upload server uploaded the video to the queue, the transformation server took over the task and, at some intervals, checks the status of its execution.  In the event of a server failure, the task is restarted, or it is returned to the queue and transferred to another server. <br><br>  Everything is fine, but after all, the previous server could simply have lost the connection.  And we do not need the server to do extra work when restoring a connection, which another server is already doing.  To do this, each time checking the queue, we return the possibility of continuing work.  That is, the algorithm is as follows: the server woke up, turned to the queue and said that it would continue to perform the task.  The queue responds that the task is no longer relevant, and the server takes on a new task. <br><br>  This scheme works great, but we have a Single Point of Failure, it is our turn.  If we lose the data center, where we store the queue, or the server itself, then we will have serious problems.  Here we would need to implement some kind of distributed queue solution, but we did not exploit such things and did not want to complicate the infrastructure.  We simply used Zookeeper, which Odnoklassniki is very actively using in his other services. <br><br>  What is a zookeeper?  This is a server of distributed locks, it has ready-made solutions in the form of a choice of a leader.  The choice of a leader is such a process in a distributed system, when in case of loss of a server, the whole system will come to a stable state due to the appointment of a ‚Äúleader‚Äù.  He knows that he is the "leader", and all the servers know this too. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3a/875/47e/c3a87547e2b430fccb878b48210e6724.png"><br><br>  In fact, in this system, ‚Äúcandidate1‚Äù and ‚Äúcandidate2‚Äù do nothing, they are just backup servers located in other data centers.  The queue is fully executed on the "leader".  In the event of the loss of the ‚Äúleader‚Äù, a new one is selected, and the whole system learns that the first candidate has become the new ‚Äúleader‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10c/57f/f4d/10c57ff4d00af35ef62ce59ee6d67478.png"><br><br>  Upload servers start adding tasks to it, transformation servers ping, everything is fine.  However, the state of the queue at the time of the fall of the old leader is unknown on the new leader.  Since we have all the videos and time stamps uploaded by users in the temporary storage, we can restore the queue using them.  After receiving some responses from the queue after a while, all the transformation servers will inform us in a short while about the tasks that they are performing, and we will get the same state that the leader had. <br>  This delay period is dozens of seconds and does not noticeably affect the users. <br><br>  For video transformation, we use FFMpeg, and for extracting any interesting information we use <a href="https://code.google.com/p/mp4parser/">MP4 parser</a> .  The entire transformation server is written in Java and works quite simply - takes the task from the queue, runs FFMpeg through the Java wrapper, cuts the video into four qualities, extracts the images for the splash screen and metadata, and finally saves all the received information to the permanent storage. <br><br>  In the process of creating different versions of the quality, we are faced with such a problem.  It turned out that 15% of the loaded video in the title have the wrong length.  That is, for example, the title of the video shows the duration of 2 hours, and in fact there is a video stream there for a couple of minutes.  Faced with this, we had to calculate the length of frames, this parameter we use both in calculating the output parameters of the video, and for cutting thumbnails. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75a/ce4/2ad/75ace42ad4124f2208050fec1c16eb41.png"><br><br><h1>  Storage </h1><br>  After cutting the video, it is sent to the repository.  Now it consists of about 70 servers, each of which has 36 double-byte drives.  Total 5 petabytes.  The storage is distributed, fault tolerant, it is called One Blob Storage (OBS).  To store the state of the clusters, we use Zookeeper.  Videos are stored on disks in blocks of 64 megabytes.  Hard disk failure is not a problem for this storage.  There are additional drives on the servers.  In case of failure of one of them, on the other, his condition is automatically restored.  Each video we store in triplicate.  Thus, from each video there are four new ones, each of which is stored in triplicate, one in each DC. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de9/faf/c35/de9fafc352ac2328d8735891de376503.png"><br><br><h1>  Distribution of content </h1><br>  Probably the most interesting part.  Requirements: <br><ul><li>  Return of video from any moment without preliminary buffering. </li><li>  High performance, we expected about 150 gigabits per second. </li><li>  Fault tolerance. </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d03/937/0d7/d039370d7edfdbd2a0f38828dea2ba4c.png"><br><br>  In principle, for the implementation of pseudo-streaming, that is, the return of the video from any moment, nginx has suitable modules.  But nginx works with files, and we wanted to cache only what the user actually looks at.  For example, we have a two-hour movie, and the user watched about 5 minutes.  Then we cache only this piece.  I had to write my solution again in Java. <br><br>  Let's see, for a start, what pseudo-streaming is.  When playing a video, there is some buffered part in it.  If the user goes to the unbuffered part, then we must start playback from this point without buffering.  How does it work?  During the transformation of the video into our internal format, we alternate between video and audio samples, and also insert a so-called sync sample every few seconds.  The resulting result is as follows: we have a header and there are blocks.  Accordingly, when the user selects a place, then we understand from which block one can begin to give data.  The title indicates the beginning of each block. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bbb/3f8/837/bbb3f8837276ed3e37f3bcda3700530d.png"><br><br>  On the one hand, it is advantageous to use a lot of such blocks.  But then the volume of the title grows, and this is the volume that the user is forced to download before the first frame of the video appears.  Trying to optimize the title, we came up with this solution: the maximum size of the video file header should not exceed 6 megabytes.  At the same time in one video 500-700 blocks are obtained. <br><br>  In the process of cutting, besides the choice of the synchronization frequency of video and audio, there was another problem.  Standard video converters usually put a caption at the end of the file.  This is much more convenient for them, because all the displacements of all blocks are already known.  And in the case of streaming video, the main thing is not to forget to move the title to the beginning. <br><br><h1>  Pseudo-streaming </h1><br>  Consider the implementation of pseudo-streaming in HTML5.  The player has a moov atom, when selecting a place, it calculates the upset, it requests the byte-range-request-data itself and provides the native search.  The Flash player has a slightly worse situation, he simply makes a request to the server at the start (the URL has the start time in seconds), and then the server has to prepare a full-fledged video file for him from this place, that is, recalculate the title, as if the video was started since the request of the user. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a64/3de/440/a643de440ec9b532a3eff8a1fb2d1b80.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/366/fc3/29e/366fc329e0ffd989f714352580ee5a02.png"><br><br>  When pseudo-streaming files can only be viewed from the beginning, from the middle and from the end, only the viewed part of the video is cached on the distribution server.  We decided that we would be caching video blocks of 256 kilobytes.  And all this will do in Java. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53b/2b6/a5f/53b2b6a5f142ec44549741dd8f54afb3.png"><br><br>  Consider the architecture of our distributor.  This is such a caching layer between our permanent storage, it has several levels of caches.  Historically, about 96 GB of RAM are allocated to us on servers.  Here we put another SSD-drives. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcb/130/3d6/bcb1303d69441cc027dce9e678926240.png"><br><br>  The algorithm works as follows: the user has requested the video from the server;  if it is cached in memory, then we give it, if not, then check the disk;  if it is not, then go to our store.  We immediately put the video from the storage into RAM and distribute it to users.  In RAM, we use only the LRU cache and, when preempting, we check the counter, how many views we have of this segment.  If a segment is watched more than a certain number of times, then we force it onto a disk;  if the segment was viewed a little, then we throw it away. <br><br>  96 gigabyte cache requirements: <br><ul><li>  The cache should not affect the GC, it should be LRU.  Now we have about 20 thousand requests per second processed on the server, that is, it should be high-performance. </li><li>  The cache must be persistent, that is, persist after a restart or update of the distribution service. </li></ul><br><br>  Requirements for the second level of caching on disks are lower.  It is enough to use FIFO caching, the internal OBS solution is also applied, only locally. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76c/066/ee7/76c066ee7bba531cf2962268bc5fe3be.png"><br><br>  Large volumes of 100 gigabytes and a ban on the impact on the GC lead us to offheap-caching.  Offheap caching options, in principle, a lot.  There are Direct-ByteBuffer, memory-mapped files, but they have problems.  For example, the native code is not portable, and in these solutions the limitation of the maximum amount of allocated files is about 2 gigabytes.  Of course, you can assemble them from blocks, but this will not be very convenient.  Solution: use shared-memory, use Unsafe to access it.  All this is implemented on our open source one-nio library, it can be viewed on <a href="https:/github.com/odnoklassniki/one-nio">github</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44f/f88/d89/44ff88d89525afcefd0b6bab358ea438.png"><br><br>  For distribution we use selectors.  Our distribution HTTP server is part of the one-nio library.  The server is equipped with two gigabit fiber-optic cards.  He has 10 gigabit Ethernet cards to access the storage. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a3/021/076/0a3021076b70219cc7bf3f17e5430ede.png"><br><br>  According to the results of testing, we successfully cope with the distribution of 20 Gigabits.  That is, as much as we can provide external network cards.  At the same time, the processor load is about 30%.  Now our engineers are working to reconfigure the system and start distributing more.  The main limitation is 6 slots on one server and the effectiveness of our cache.  We got it somewhere 80/20: 80% of block requests are taken from the cache, 20% of requests come from OBS.  Probably, this is not bad, but for 20 Gigabit, we almost completely select the 4 Gigabit Ethernet access resource to our permanent storage. <br><br><h1>  Balancing </h1><br>  Everything is great, but 20 gigabits is not enough for our users.  We use clusters from all servers for video distribution, as well as the standard balancing algorithm, which was previously considered when downloading videos.  But we have a problem: if users watch the same video, and we will distribute it from different nodes, then the effectiveness of our super cache will be greatly reduced. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f8/2ee/8c8/5f82ee8c852662c0bd07aaeeb6977b79.png"><br><br>  We needed to make sure that on 10 servers the total cache size was about a terabyte.  To do this, they wrote their balancer.  Its main idea is that we split all videos into a certain number of partitions (the main thing is that there are a lot of them), and we assign some partitions to each server.  Actually, each server distributes only its own video content.  To ensure fault tolerance (even load distribution across other servers in the cluster), we add replicas to each partition. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/b71/464/e6eb71464a19572d107f01f3106346b2.png"><br><br>  If the Server is dropped, respectively, the distribution takes place with this partition from one server, and the other partition from the other.  The load is evenly distributed across all servers, and everything would be great, but the content of these servers is not cached.  Thus, we will form a large number of requests to our permanent storage.  It can not stand this, especially during peak hours.  To do this, we ‚Äúwarm up‚Äù the partitions for the future, that is, sometimes we send the user with some probability to the replicas ‚Äî to the replica1 or the replica2.  Thus, we kill two birds with one stone: we warm up this cache and balance the load on the storage, but on the other hand, we effectively use the cache within the cluster. <br><br>  Also, do not forget that the byte range is easy to implement on this HTTP server, but rebuilding a moov atom from a place is not an easy task.  The rebuild itself takes place on the distributing servers.  For this, we tried to use the MP4 parser, but it generated a lot of garbage, had a great impact on the GC and was extremely inefficient.  We have the number of requests for rewind - a hundred per second.  We abandoned the MP4 parser and implemented our Java solution to rebuild the moov atom from time to time.  It turned out to be extremely effective, the title is rebuilt from 6 megabytes to 3 in time to ten milliseconds. <br><br>  There is such an interesting fact: in August 2012, when the rover landed on Mars, NASA decided to organize an online video broadcast.  For this, they invited nginx.  Nginx had a platform that distributes, caches, deployed on 40 Amazon-EC2 servers.  These are, of course, not super-efficient servers, but 40 of them are serious enough.  A testing company was invited, which tested the load on this video service, and they tested a load of about 25 gigabits per second.  I think that one of our server after some modifications will withstand 25 gigabits per second.  They carried out shutdown of servers.  First, we deduced 10 servers, the traffic sank a little, rebalanced and returned to normal.  They disconnected 10 more servers, the traffic sat down and did not return to 25 gigabits, but remained at the level of 12 gigabits per second.  It turned out that the distribution to nginx, this, of course, was the distribution of streaming video, but they had only one video script.  20 servers provided a performance of about 12 gigabits. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eee/f66/495/eeef66495eaebd982bf6e5a0e5e4ecf4.png"><br><br>  Below are the main milestones of our project.  It is worth noting that we started development in January 2013, and in May 2013, the entire Java platform was launched on 100% of the portals. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/621/dc3/543/621dc354337b415d46a5943ead6a8023.png"><br><br><h1>  Technology </h1><br>  We tried to make the most of the technologies that we worked out.  I understand that, perhaps, startups usually try to minimize coding and integrate existing solutions as much as possible.  We decided to save on integration and launch. <br><br>  On the other hand, we used very little technology, this is our internal One-nio library, which is available in open source.  Of all this, only our storage is proprietary, OBS, but this is due to some problems, the need to untie it from our internal configuration architecture.  The only alternative solution was FFMpeg, which was used for cutting video. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/280/5a4/884/2805a4884afc822b0a83f0dad8cf909c.png"><br><br>  Actually, this is how all these technologies are distributed across our servers.  Everything except FFMpeg is Java. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4b/f38/b80/e4bf38b80149a1132f438e55bed6f98e.png"><br><br><h1>  results </h1><br>  We ensured that the service is fully operational in case of loss of data centers and servers.  We gave users the opportunity to resume downloading videos within 12 hours after disconnecting.  That is, if you downloaded the video, and you lost the network (this is especially true for mobile devices), if you continue downloading within 12 hours, we will fully load the file. <br>  We also provided video viewing from any point in time in Flash and HTML5.  The latter is very important for mobile devices.  We achieved interesting results in terms of traffic from one server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/145/8c8/fe6/1458c8fe6c8d33f2d7d18c298adbf505.png"><br><br>  The main plans for the near future are to try add-ons on the HTML5 player.  You can also improve the work of FFMpeg with codecs.  We get all sorts of interesting metadata from a user-uploaded video, such as GPS, but we still don‚Äôt use GPS coordinates. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/20c/d03/c58/20cd03c58e5d246fe38481ed9caba69c.png"><br><br><h1>  And a few more words about the video platform </h1><br>  We allow Odnoklassniki users to upload videos up to 8 gigabytes to us, which is four times the maximum size of a video on VKontakte that can be downloaded.  And the length of the downloaded video is not limited by anything (YouTube, for example, has a 15-minute limit for some accounts).  The maximum video resolution, however, is lower than we would like - only 720p, which, incidentally, corresponds to the HD standard.  Nevertheless, we will soon acquire new capacities, which will increase the quality to the desired 1080p. <br><br>  In addition, unlike other video resources, the Odnoklassniki service supports an expanded range of video formats - there are more than 20 of them, including .evo and .asf.  This is the highest figure among competitors, although they support all major formats, including MP4. <br><br>  Downloading content is available not only in the form of files: you can add a video by link from other video resources. <br><br>  A powerful backend in the face of the video platform we developed allowed us to implement a full-fledged online cinema on Odnoklassniki.  Licensed content that we receive from our partners is available to users of the social network for free.        , , ¬´¬ª,         ,    ‚Äî ¬´¬ª, ¬´¬ª  .   ,        ‚Äî    . </div><p>Source: <a href="https://habr.com/ru/post/219429/">https://habr.com/ru/post/219429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219417/index.html">From the ISS will try to conduct data transmission to Earth using lasers</a></li>
<li><a href="../219419/index.html">Suggestions for learning programming language</a></li>
<li><a href="../219423/index.html">System and business intelligence in anticipation of the most significant event of the sphere!</a></li>
<li><a href="../219425/index.html">Adventure game that is played by changing its Javascript code</a></li>
<li><a href="../219427/index.html">Overview of 6 Budget Wheel Platforms for Ebay Robots</a></li>
<li><a href="../219431/index.html">Organization of multitasking in the OS kernel</a></li>
<li><a href="../219435/index.html">Filtering the blacklist of sites by URL</a></li>
<li><a href="../219437/index.html">The quality of transposing samples in Ableton Live 8 tools and free plugins</a></li>
<li><a href="../219439/index.html">Strange Analytical Beast Axiom</a></li>
<li><a href="../219441/index.html">Getting started with the graph database Neo4j</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>