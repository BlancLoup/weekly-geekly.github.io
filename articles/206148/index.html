<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating your own drivers for Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many of my friends and acquaintances twist their fingers at their heads, or they wonder if their skulls are too tight for me when they find out that I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating your own drivers for Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/35f/c3f/2dc35fc3f46e7e46fdfb6ca17b989f0c.jpg"><br><br>  Many of my friends and acquaintances twist their fingers at their heads, or they wonder if their skulls are too tight for me when they find out that I am writing drivers for Linux.  The word ‚Äúdriver‚Äù is shrouded in some almost mystical sense, and only selected gurus can grasp the Tao of its writing. <br>  Fortunately, it is not.  I do not know how things are going with writing drivers for other operating systems, incl.  and most popular, but under linux, regardless of the hardware architecture, drivers are written very simply.  To write a driver, you need basic knowledge of the C language, an understanding of the Linux operating system (basic), an understanding of what we want to receive, a desire to read the documentation and source codes, and also perseverance.  Everything. <br>  Do you want to see how to write a driver for your device?  Then dive under the cat! <br><a name="habracut"></a><br>  The ease of writing drivers is due to the fact that the linux source code is superbly documented and is available in source code, there are many examples in the network and a lot of literature.  And to create a driver, you need only your favorite distribution and kernel sources, and the compiler for the architecture you need.  I wrote my first non-training driver for the PowerPC 8360 processor, it interacted with the FPGA chip and reset the default settings.  Strange as it sounds, I did it by rewriting the SPI driver for this architecture a bit.  I say this to the fact that a unified standardization of writing programs in the Linux kernel allows for such things. <br>  The Linux driver development handbook is ‚ÄúLinux Device Drivers‚Äù.  The book is an exhaustive guide to development and if something is missing in the book, then you can definitely find it yourself in the source code of the kernel.  Of course, this post does not pretend to replace this wonderful book.  Moreover, it was written based on the reading of these works, but still is not a brief retelling of this book.  The author of these lines aims to interest the reader in the simplicity and elegance of the Linux operating system, and lower the threshold for people to enter driver development.  Believe it is very simple! <br><br><h4>  What we will write a driver for </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since the main purpose of this article is to write drivers, we will pay minimum attention to the hardware.  I hope everyone is friends with a soldering iron, and those who are not friends - it is time to start making friends, I will briefly tell you what and how was done. <br><br>  We will write a driver for a display of the <a href="http://www.gaw.ru/html.cgi/txt/lcd/chips/hd44780/start.htm">HD44780</a> family connected via an LPT port to a computer.  I know that the port is ancient, and the type of display is not less than the years to me, but still - this is a beautiful and simple example of writing drivers for linux, without delving into the hardware details.  And all the more so, to remake this driver for this screen for other architectures will be a matter of replacing one line! <br><br>  So, we need an LPT port;  a cord for an old printer and an optional CENTRONICS connector for up to 36 pins, although you can simply unwind the cable;  Of course, the screen of the HD44780 family, the best is at least 4x40 characters, although even the smallest ones will do;  Well, a variable resistor of 10 kOhm, to adjust the contrast.  Since I don‚Äôt have an LPT port a long time ago, I bought the first available PCI card (PCI-E can also be used).  And the board got so much Chinese that I couldn‚Äôt even find any documentation on the soldered chip on it.  Nothing, we will also reverse it :)))). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/458/8c1/589/4588c1589f9e4bc924837e1ead3164ed.jpg"><br>  <b>Hardware source</b> <br><br>  We assume that to get these components was not difficult, and your hands are burning with impatience to do everything. <br><br><h4>  A warning!!! <br>  Read carefully! </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/051/a66/069/051a6606969c6b0ee5e7965e7d9b5ccf.jpg"><br><br>  I want to indicate that we work in the most difficult conditions, with iron, and we will also work at the core level.  We live, so to speak, inside the patient.  Any error in the program and the kernel falls.  At what it may not even have time to wave to you kernel_panic, just suddenly everything stops working.  Please note that you started the driver, unloaded it, and suddenly the implicit glitches began - that's all, your path - reboot.  If the system is alive, then the reboot command.  If not already, then hardware reset.  Although in severe cases, the system can sometimes restart itself. <br><br>  Plus, if you do not know what you are doing (writing to the port, referring to memory areas, etc.), then it is better not to do it.  For all this, at best, can knock down the settings (the incorrect value written to port 70h used to reset the BIOS to x86) or even spoil the hardware (for example, by putting the GPIO leg on the ground).  Therefore, clearly understand what you are doing, both on the hardware and on the software level! <br><br><h4>  Getting started </h4><br><br>  For the lucky owners of the built-in <a href="http://ru.wikipedia.org/wiki/IEEE_1284">lpt-port</a> in your computer, I will say that in your case the port lives at the standard address <b>378h</b> .  You can wake me in the middle of the night and I will say this figure, so much is connected with it.  But now we have been given an enemy wage, and we have to defeat it! <br>  We insert the board into a PCI or PCI-E slot, boot up and see what happens on the PCI bus with the following command: <br><br><pre><code class="bash hljs">lspci -v ‚Ä¶ 05:01.0 Serial controller: Device 4348:5053 (rev 10) (prog-if 02 [16550]) Subsystem: Device 4348:5053 Flags: medium devsel, IRQ 18 I/O ports at c030 [size=8] I/O ports at c020 [size=8] Kernel driver <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> use: serial</code> </pre> <br><br>  As you can see, linux found something on the PCI bus, and even tried to give it some kind of left, obviously wrong driver.  But we are most interested in the addresses on which this port sits.  These lines are: I / O ports, namely the digits <b>c030h</b> and <b>c020h</b> . <br>  We now need to find out which addresses are responsible for what.  To do this, we connect LEDs with resistors to the output port in approximately the same way (resistors are approximately 310 Ohms, or more or less, it does not matter) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d2/403/322/5d24033224d4bb44bb8d89c89cbd21f4.gif"><br>  <b>Checkout scheme</b> <br><br>  Since I already have a blank LED for this kind of test, I inserted the wires directly into the CENTRONICS connector and I did not fit all 8 pieces of wires, so I inserted only 6 (the first 4 and the last two). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a4/4b4/43a/9a44b443ab8aa7f2ed94e662cb10afd8.jpg"><br>  <b>Assembled Port Tester</b> <br><br>  And sketch a small program to check. <br><br>  To work with the port, I took an example from here <a href="http://www.faqs.org/docs/Linux-mini/IO-Port-Programming.html">www.faqs.org/docs/Linux-mini/IO-Port-Programming.html#s9</a> .  The only thing that needs to be corrected is the line: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;asm/io.h&gt;</span></span></span></span></code> </pre><br><br>  on <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/io.h&gt;</span></span></span></span></code> </pre><br><br>  We make normal delays per second (instead of usleep (100,000); <br>  , we write sleep (1);) and make three consecutive conclusions to the port: <br><br><pre> <code class="cpp hljs">outb(<span class="hljs-number"><span class="hljs-number">0</span></span>, BASEPORT); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0xAA</span></span>, BASEPORT); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, BASEPORT); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br>  Define #define BASEPORT change to port 0xc030.  Compile, run from under the root: LEDs are off.  Change to another digit - <b>0xc020</b> - ale op: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/949/9b3/623/9499b362324d0d97fc7a2b09c25649b0.jpg"><br>  <b>Zero</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b54/037/8db/b540378dbd307ef6a90c2613e1b7839d.jpg"><br>  <b>On the conclusions of AAh</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98c/b79/9ae/98cb799aeec6458356b800f3e7dcf084.jpg"><br>  <b>And, of course, in a second FFh</b> <br><br>  The result is obvious.  Those.  With the port numbering, we guessed it, you can proceed to the wood.  The LPT port of this board lives at.  <b>0Xc020</b> ! <br><br>  I want to draw the attention of tinsmith programmers to the magic number 0xAA - this is a sequence of ones and zeros.  <i>Like</i> this: <i>10101010b</i> .  This is very convenient for any debugging.  In general, anyone who works with iron should easily translate binary, decimal, hexadecimal back and forth in mind. <br><br><h4>  Taki display </h4><br><br>  Drum roll, it's time to put together a piece of iron!  For this we need to solder everything together.  We collect everything according to the following scheme. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40c/c14/a78/40cc14a78f6c0fddf20d2bf43a4868e2.jpg"><br>  <b>I know that the scheme is not according to GOST, but this is not Radio magazine either.</b> <br><br>  To power the screen, I spread the USB cable, and now I have two wires going to the screen.  There is a tricky option, it‚Äôs just that no hands reach it - it is to power the USB right into the LPT wire, soldering one of the many earth wires.  As hands reach - I will definitely do it.  I will add only this article :)))). <br>  As a result, after energizing, we should get something like this.  Adjust the brightness with a resistor so that two bars appear.  They indicate that the display is not initialized. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/4b8/22c/d344b822c8602f496aaf0658b558a64a.jpg"><br>  <b>Device Assembly</b> <br><br>  Fuh, with the hardware we finished, it's time to move on to the program. <br><br><h4>  We start evil experiments with the screen in the program </h4><br><br>  As a finished product for working with the display, I used the code from the Arduino taken <a href="http://www.dfrobot.com/wiki/index.php%3Ftitle%3DI2C/TWI_LCD1602_Module_(SKU:_DFR0063)">from here</a> .  I also do not like this platform, but the code is suitable for displays connected via <i>I2C</i> .  If the last word to you does not mean anything, do not be intimidated.  The bottom line is that the same display is connected via two wires (as the bus name implies), and then there is a register, which again converts the transmitted byte into a parallel bus, just like our LPT port.  As a result, having thrown out some of the work with I2C, we get a valid libu. <br>  For cleanliness, I rewrote it, added a couple of necessary functions, renamed some conflicting ones, made some other changes (I don‚Äôt remember, a lot of water has flowed under the bridge) and got a candy. <br>  By the way, the code was used on the STM32, also with displays connecting via I2C.  And now we port it already to x86 and under linux.  Here it is - the great power of code portability!  Spending just 10 minutes to adapt the code already under the new platform. <br>  Work with the port is carried out in one single function - it is an unbearable node, and depending on the platform, the output method should be changed.  There was a conclusion on I2C: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expanderWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _data)</span></span></span></span>{ outb(((_data) | _backlightval), BASEPORT); <span class="hljs-comment"><span class="hljs-comment">//x86 instruction!!!!! }</span></span></code> </pre><br><br>  Pay attention to this feature.  Replacing it, the code can be run in AVR, STM32, MIPS, etc. <br>  Already familiar to us output to the port.  Define the port defined in the header lcd.h.  Everything, now it is possible to try to draw a conclusion.  The program has become even easier and clearer. <br>  The print_to_string wrapper function is used for display. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_to_string</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> col, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> row, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre><br><br>  The first parameter is the column number (from zero to 19), the second line number (from zero to three), the third is a pointer to a character string, and the last is the length of the string.  The string is not checked for the ending ‚Äú\ 0‚Äù, the length must be controlled independently!  As a result, let's try the display: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/io.h&gt; #include "lcd.h" #define LCD_STRINGS 4 // #define LCD_COLUMNS 20 // int main() { LCD_init(0, LCD_COLUMNS, LCD_STRINGS);//  print_to_string (0, 0, "XXXXXXXXXXXXXXXXXXXX" , 20); print_to_string (0, 1, "YYYYYYYYYYYYYYYYYYYY" , 20); print_to_string (0, 2, "ZZZZZZZZZZZZZZZZZZZZ" , 20); print_to_string (0, 3, "MMMMMMMMMMMMMMMMMMMM" , 20); exit(0); }</span></span></span></span></code> </pre><br><br>  As a result, something like this should appear on the screen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af3/e8e/b55/af3e8eb55a1fb1db1b96530cac28a8d8.jpg"><br>  <b>Our first debut!</b> <br><br>  Do not be intimidated by this pornography.  This screen was written off for dead pixels, more precisely, the controller from static static there just died (there are several of them).  It is not suitable for work, but it is for all such experiments.  Such shitty screens are made by the Chinese! <br><br>  At this one could stop, because  With this example, you can display any characters, download fonts, etc.  But, not as a driver.  Although you can remake a demon or something else, as far as fantasy allows. <br>  Therefore, for those who become bored to read further, I post the full version of this example <a href="http://yadi.sk/d/R1eWqL-MRbxXf">here</a> . <br>  Our global goal is a device driver, so let's get to it. <br><br><h4>  Driver Build Tool </h4><br><br>  To start writing a driver, you need to put the necessary tools.  How to prepare tools for Ubuntu and Debian is well explained in this article <a href="http://blog.markloiseau.com/2012/04/hello-world-loadable-kernel-module-tutorial/">blog.markloiseau.com/2012/04/hello-world-loadable-kernel-module-tutorial</a> <br>  I‚Äôll just say briefly that if you don‚Äôt need to build debian packages and you‚Äôre writing a module for yourself, it‚Äôs enough to install the necessary components with the following command: <br><br><pre> <code class="bash hljs">sudo apt-get install build-essential linux-headers-$(uname -r)</code> </pre><br><br>  I strongly recommend that you also download the source code of your kernel.  There are two options to do this.  The first, and obvious, but perhaps slightly hemorrhoid is to find out the version of your kernel with the command: <br><br><pre> <code class="bash hljs">uname - a</code> </pre><br><br>  and download it from <a href="https://www.kernel.org/">www.kernel.org</a> .  I'm lazy to climb the links and look for the kernel version, I trust this thing automation. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    sudo -s cd /usr/src/ apt-get source linux-image-$(uname -r) #      . #      linux_3.8.0-9.18.tar.gz      /usr/src/linux-3.8.0</span></span></code> </pre><br><br>  Truncate, remember this path or add a link to it, for example / usr / src / linux, but I do not recommend it, because  Kernels tend to upgrade.  Here the question is controversial to be or not to be, decide for yourself. <br>  Now you have a real treasure: a storehouse of current documentation and a monstrous number of examples of source code, and of course the necessary springboard for building the module. <br>  I highly recommend climbing Documents, drivers and others into the daddy, looking at the source code - this is incredibly useful! <br><br><h4>  Own driver </h4><br><br>  If you think that we now just fix the makefile and get a ready-made driver, then you are deeply mistaken.  Everything, now we are in another world: not in user space, in kernel space.  And here are completely different rules. <br>  To realize the full misfortune of the situation, you must understand that the core is one big, very large program.  This means that global variables, functions, etc.  may be available elsewhere in the kernel!  Therefore, ALL global variables (they should be avoided to the maximum) should be declared static! <br>  We will not rebuild the kernel by embedding the driver into it, and restart each time trying it.  This is certainly fun, but very long.  Instead, we will make a kernel module, which we will load and unload directly during operation. <br>  In our future module, compared to the user space program, the changes will not be very significant.  First of all, let's move all the files into one in order not to have problems with compiling (or, if necessary, embed each other).  Header is left, but we clearly define all the parameters of the functions (if there are no parameters, then it is necessary to prescribe void).  We recall that we are in kernel space, and all our libraries are different.  We change all headers for nuclear: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; /* everything... */ #include &lt;asm/io.h&gt; #include &lt;linux/unistd.h&gt; #include &lt;linux/delay.h&gt; /* udelay */ #include &lt;asm/uaccess.h&gt; #include &lt;linux/miscdevice.h&gt;</span></span></span></span></code> </pre><br><br>  Note that even unistd.h and io.h have become nuclear. <br><br>  Let's take the <a href="http://blog.markloiseau.com/2012/04/hello-world-loadable-kernel-module-tutorial/">hello world</a> module as the primary driver base.  Let's fix the init function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ LCD_init(<span class="hljs-number"><span class="hljs-number">0</span></span>, LCD_COLUMNS, LCD_STRINGS); print_to_string (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello Habrahabr "</span></span> , <span class="hljs-number"><span class="hljs-number">20</span></span>); printk(KERN_INFO <span class="hljs-string"><span class="hljs-string">"Lpt module init\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Non-zero return means that the module couldn't be loaded. }</span></span></code> </pre><br><br>  Here everything is almost unchanged.  The function of working with iron is changing (the most platform-dependent), since  It will work with the nuclear output function to the port: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expanderWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _data)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//outb(((_data) | _backlightval), BASEPORT); //x86 instruction rootfs!!!!! outb_p(((_data) | _backlightval),BASEPORT); //x86 instruction kernel!!!!! }</span></span></code> </pre><br><br>  And, oddly enough, the delay function.  In general, the delay - a separate song, which can devote an entire article.  We should have everything quickly, and as little as possible to occupy the core to any nonsense.  But still: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayMicroseconds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//usleep(value); //rootfs if (value &gt; 1000) msleep(value/1000); udelay(value%1000); return 0; //kernel }</span></span></code> </pre><br><br>  The explanation of such a fraud is simple: udelay inside the kernel can not take values ‚Äã‚Äãmore than a thousand.  To avoid incidents, such a stub is necessary. <br>  After that, we collect something like this makefile: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> = lptlcd obj-m := $(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span>).o KERNELDIR ?= /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) CC = gcc all: $(MAKE) -C $(KERNELDIR) M=$(PWD) clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</code> </pre><br><br>  And we load the module into the system with the following command: <br><br><pre> <code class="bash hljs">sudo insmod lptlcd.ko</code> </pre><br><br>  If we did everything correctly, then we will not get any errors, and the screen will correctly initialize and dmesg will show the message of your module in the last line: <br><br> <code>[10036.950566] Lpt module init</code> <br> <br>  You can unload the module with the command <br><br><pre> <code class="bash hljs">sudo rmmod lptlcd</code> </pre><br><br>  dmesg will say: <br><br> <code>[10077.176714] Cleaning up module</code> <br> <br>  Generally, in order not to constantly press dmesg there is a script there is a solution that Comrade <a href="https://habrahabr.ru/users/jtu/" class="user_link">Jtu</a> suggested to <a href="https://habrahabr.ru/users/jtu/" class="user_link">me</a> : <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> sudo dmesg -c; sleep 1; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br><br>  Or, if you are using a distribution other than Ubuntu, you should execute it as root, and remove sudo. <br><br>  Result on the screen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/835/988/78a/83598878a83e016e52439acbc1477ef5.jpg"><br>  <b>Hello to you!</b> <br><br>  If you saw all this - congratulations, this is your first working useless kernel module that displays the inscription on the screen!  This is certainly entertaining, but we still have to turn our experiments into a normal driver with which to work.  And for this you still have to talk about the materiel, at least a little. <br><br><h4>  A few words about the materiel </h4><br><br>  Like it or not, but without knowledge of certain materiels you will not get far. There are symbolic, block and network devices.  Also, each device has a major and minor device number.  Better than in the book ‚Äú <a href="http://www.linuxcenter.ru/lib/books/lkmpg.phtml">The Linux Kernel Module Programming Guide</a> ‚Äù can not be said, for this I will quote from the book in the spoiler: <br><div class="spoiler">  <b class="spoiler_title">Major and minor device number</b> <div class="spoiler_text">  Major and minor device number <br>  Let's take a look at some device files.  Listed below are those that represent the first three partitions on the primary hard disk: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ls -l /dev/hda[1-3] brw-rw---- 1 root disk 3, 1 Jul 5 2000 /dev/hda1 brw-rw---- 1 root disk 3, 2 Jul 5 2000 /dev/hda2 brw-rw---- 1 root disk 3, 3 Jul 5 2000 /dev/hda3</span></span></code> </pre><br><br><br>  Noticed a column with numbers separated by a comma?  The first number is called the ‚ÄúHigh Number‚Äù of the device.  The second - "Junior number."  The major number indicates which driver is used to maintain the hardware.  Each driver has its own unique major number.  All device files with the same major number are controlled by the same driver.  All of the above device files have a major number of 3, because they are all controlled by the same driver. <br>  The minor number is used by the driver to distinguish between the hardware it controls.  Returning to the example above, we note that although all three devices are serviced by the same driver, each of them has a unique minor number, so the driver ‚Äúsees‚Äù them as different hardware devices. <br>  Devices are divided into two large groups - block and character.  The main difference between block and character devices is that data is exchanged with a block device in portions of bytes - blocks.  They have an internal buffer, thereby increasing the rate of exchange.  In most Unix systems, the size of a single block is 1 kilobyte or another number, which is a power of 2. But character devices are only information transfer channels that the data follow in sequence, byte by byte.  Most devices belong to the character class, since they are not limited by the block size and do not need to be buffered.  If the first character in the list received by the ls-l / dev command is 'b', then this is a block device, if 'c', then a character device.  The devices that were given in the example above are block.  The following is a list of some character devices (serial ports): <br><pre> <code class="bash hljs">crw-rw---- 1 root dial 4, 64 Feb 18 23:34 /dev/ttyS0 crw-r----- 1 root dial 4, 65 Nov 17 10:26 /dev/ttyS1 crw-rw---- 1 root dial 4, 66 Jul 5 2000 /dev/ttyS2 crw-rw---- 1 root dial 4, 67 Jul 5 2000 /dev/ttyS3</code> </pre><br><br><br>  If you are interested in knowing how high-order device numbers are assigned, look in the /usr/src/linux/documentation/devices.txt file. <br>            mknod.    ,    ¬´coffee¬ª,    12    2,    mknod /dev/coffee c 12 2.          /dev,   ,       . ,    ,   ,        ‚Äî       .  ‚Äî          ,    . <br>   ,      ,      .      ,     ,   ,     .  ,              . ,    ‚Äî   .    ,     . <br>  ,    ¬´¬ª,      , , PCI ,      .      : <br><pre> <code class="bash hljs">% ls -l /dev/fd0 /dev/fd0u1680 brwxrwxrwx 1 root floppy 2, 0 Jul 5 2000 /dev/fd0 brw-rw---- 1 root floppy 2, 44 Jul 5 2000 /dev/fd0u1680</code> </pre><br><br><br>          ,    ‚Äî  ,        (  2).    ,         ,   ,       .    ?     ,       ,  1.44 .  ‚Äî    ,     1.68 ,   ,     ¬´¬ª  (¬´superformatted¬ª disk).       ,  - .   ,    ,    ,        .  ,  ¬´¬ª,   ,     . <br></div></div><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create a device file </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will use a character device driver file. </font><font style="vertical-align: inherit;">In order not to retell the book Linux Device Driver, as well as to simplify your life, I took a ready-made example of registering the character driver from </font></font><a href="http://www.ibm.com/developerworks/ru/library/l-linux_kernel_20/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> article. </font><font style="vertical-align: inherit;">This article does not search for a free fixed minor, but uses a dynamic minor. </font><font style="vertical-align: inherit;">For us, that's the thing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the module will now look like this: working with the screen that we have implemented above remains unchanged, but we rewrite the rest of it from scratch. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We define the file_operations structure</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_operations</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lptlcd_fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .read = dev_read, .write = dev_write, };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where dev_read and dev_write are pointers to functions (callback registration) that will handle read and write from the device file, respectively. </font><font style="vertical-align: inherit;">Here you can still, yes, and probably need to add .open and .release pointers to check for a single opening and closing of the device file, but I'm still lazy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To register the driver, we start this structure</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">miscdevice</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lptlcd_dev</span></span></span><span class="hljs-class"> = {</span></span> MISC_DYNAMIC_MINOR, <span class="hljs-string"><span class="hljs-string">"lptlcd"</span></span>, &amp;lptlcd_fops };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISC_DYNAMIC_MINOR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a macro for the dynamic minor, the string "lptlcd" is the name of the device, as it will appear in the / dev / folder (in our case it will be / dev / lptlcd), &amp; lptlcd_fops is a pointer to the file_operations structure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The driver registration code is also very simple.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret; <span class="hljs-comment"><span class="hljs-comment">//   ret = misc_register( &amp;lptlcd_dev ); //    if( ret ) printk( KERN_ERR "=== Unable to register misc device\n" ); //  LCD_init(0, LCD_COLUMNS, LCD_STRINGS); print_to_string (0, 0, "lptlcd init " , 16); return ret; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Device deregistration is simple: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dev_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ misc_deregister( &amp;lptlcd_dev ); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, do not forget the macros installation of cones, license, author and version </font></font><br><br><pre> <code class="cpp hljs">module_init( dev_init ); module_exit( dev_exit ); MODULE_LICENSE(<span class="hljs-string"><span class="hljs-string">"GPL"</span></span>); MODULE_AUTHOR( <span class="hljs-string"><span class="hljs-string">"Dolin Sergey &lt;dlinyj@gmail.com&gt;"</span></span> ); MODULE_VERSION( <span class="hljs-string"><span class="hljs-string">"0.1"</span></span> );</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The magic begins in the dev_read and dev_write functions. </font><font style="vertical-align: inherit;">I'll start with the first</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *info_str = <span class="hljs-string"><span class="hljs-string">"lcdlpt device driver\nAuthor Dolin Sergey aka dlinyj dliny@gmail.com\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// buffer! static ssize_t dev_read( struct file * file, char * buf, size_t count, loff_t *ppos ) { int len = strlen( info_str ); if( count &lt; len ) return -EINVAL; if( *ppos != 0 ) { return 0; } if( copy_to_user( buf, info_str, len ) ) return -EINVAL; *ppos = len; return len; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It does the following: if we produce a reading of the device file, for example: </font></font><br><br><pre> <code class="bash hljs">cat /dev/lptlcd</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we will see the line behind the info_str pointer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code is so obvious that I hope it does not need comments. </font><font style="vertical-align: inherit;">The only thing is that the copy_to_user function along with the copy_from_user function is used to copy data between user and kernel address spaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The other function is dev_write, which is what shoves the data on the screen.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> str_pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  static int col_pos = 0; //  static ssize_t dev_write( struct file *file, const char *buf, size_t count, loff_t *ppos ) { int i; //  . for (i=0; i&lt;count;i++) { //     setCursor(col_pos, str_pos); //       ,    if ((col_pos==0) &amp;&amp; (str_pos==0)) clear(); //   ,     if (buf[i] != '\n') { write_l(buf[i]); col_pos++; } //  ,      else {col_pos=LCD_COLUMNS;} //        if (col_pos == LCD_COLUMNS) { col_pos=0; str_pos++; //   ,      if (str_pos == LCD_STRINGS) { str_pos=0; } } } return count; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my opinion, do not add or remove. </font><font style="vertical-align: inherit;">I hope everything is clear. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We compile, add the module to the kernel and see that we have a file:</font></font><br><br><pre> <code class="bash hljs">$ ls /dev/lptlcd /dev/ttylptlcd</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We try to read from it and write something down: </font></font><br><br><pre> <code class="bash hljs">$ cat /dev/lptlcd lcdlpt device driver Author Dolin Sergey aka dlinyj dliny@gmail.com <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -ne <span class="hljs-string"><span class="hljs-string">"Trolo Pysh\nPysh"</span></span> &gt; /dev/lptlcd</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we‚Äôll see this: </font></font><br><br><img src="http://img-fotki.yandex.ru/get/9503/74270808.19/0_b4d06_afb782cd_XL.jpg"><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I‚Äôm a UFO driver.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everything, we now have a fully working driver with a reciprocating device! </font><font style="vertical-align: inherit;">Congratulations, you can run to the storage shed for champagne, and then in the user space under the magic bubbles to write programs that work with this device. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But still I personally have some doubts, here is something wrong ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Want MORE !!! </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, now we have written quite a working driver, which can already be used in everyday practice. Display any text on it, even text from a file, to use in your programs. But there is a feeling of incompleteness, imperfection. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you take and read any documentation on the screen, for example, an article that </font></font><a href="https://habrahabr.ru/users/dihalt/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DIHALT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wrote </font><font style="vertical-align: inherit;">about </font></font><a href="http://easyelectronics.ru/avr-uchebnyj-kurs-podklyuchenie-k-avr-lcd-displeya-hd44780.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initializing the display for the AVR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then you will be surprised by the wealth of possibilities.</font></font> For example: <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. You can load text into memory, and then simply move the visible area, saving time for loading new data (as we remember, we have great delays). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. You can display the text in any position. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. You can clear the screen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. And of course, you can upload your own fonts. Do not flatter yourself about this, only 8 characters are available. For example, the task of implementing a Russian menu with this screen without a Russian font, with Latin letters and partially loaded Russian (8 characters), turns into a quite entertaining rebus for the whole department (was, floated). So this is used for some specific characters. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I found a good example of using the ability to download fonts on a coffee machine at work, in which a similar screen is just installed, just Russified.</font></font><br><br><img src="http://img-fotki.yandex.ru/get/9802/74270808.18/0_b44c2_f601b9cb_XL.jpg"><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The screen on the coffee machine</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here you can clearly see the use of symbols: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- two symbols for sugar, an empty circle (did not guess to remove) and a full one; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- five characters of a running line (in a symbol of 5 columns). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total 2 + 5 - there is only one spare character, which is also probably used. Do not really run away. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the display has enough chips, so much that I am already lazy to read in the documentation. But, as we see, we cannot do all this for now. And at this wonderful moment it is time to get my piano out of the bushes, which is already there a long time ago. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before I started the implementation of this idea (even before I started buying parts), I googled, and did someone do something like that. And, about a miracle (!), Such a driver already exists. Wrote it</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Michael McLellan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and dwells the driver </font></font><a href="http://lcd-mod.sourceforge.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Honestly, this driver made a mixed impression on me. Let's say it has become a valuable tool, how to NOT write drivers - rewriting it under a different inclusion scheme will be a nontrivial task, as there is a dull record of bytes, and which ones, where and why is not clear. Portability is missing as a class. A bunch of define-s for different cores endure mosk. Plus, the driver was originally conceived under the full </font><a href="http://lcd-mod.sourceforge.net/wiring.php"><font style="vertical-align: inherit;">wiring</font></a><font style="vertical-align: inherit;"> scheme (8 bits per data port, see the </font><a href="http://lcd-mod.sourceforge.net/wiring.php"><font style="vertical-align: inherit;">lcd-mod.sourceforge.net/wiring.php</font></a><font style="vertical-align: inherit;"> scheme</font></font><a href="http://lcd-mod.sourceforge.net/wiring.php"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and I was immediately focused on a 4-bit bus. Though it is slower (about two times, because a byte is sent by two parcels), but firstly, it will be less soldering, and secondly - it will not be necessary to look for other ports. And thirdly, I already had an excellent and logical code for a 4-bit bus. As a result, I decided to write my own driver from scratch, telling me how to do it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Okay, to hell with lyrics. </font><font style="vertical-align: inherit;">There is an invaluable thing in that driver - it is processing of control or ESC sequences. </font><font style="vertical-align: inherit;">If you bother and swing this ‚Äúgrand piano‚Äù, then you can find all sorts of readme and how-that there. </font><font style="vertical-align: inherit;">Also at the office there is a fact. </font><font style="vertical-align: inherit;">So that you do not have to climb all this data, I decided to put everything in one heap and in Russian. </font><font style="vertical-align: inherit;">First, a few words about these sequences, you all came across them when the printf operator was added a line break in the form of '\ n' - this is the simplest ESC sequence, which is interpreted as the character 0Ah in ASCII. </font><font style="vertical-align: inherit;">The same parsley lies in the management of this display.</font></font><br><br>  So, control sequences for our screen: <br><br><ul><li>  \ 033 = Sending an ESC sequence from which commands begin. </li><li>  [A = Move cursor one line up </li><li>  [B = Move cursor one line down </li><li>  [C = Move the cursor one position to the right. </li><li>  [D = Move the cursor one position to the left </li><li>  [H = Move the cursor to the upper left corner - home (position 0.0) </li><li>  [J = Clear all, does NOT return the cursor home! </li><li>  [K = Erases to the end of the line, does NOT return the cursor home! </li><li>  [M = New Character Map (DZ - explain why!) </li><li>  [Y = Position Y (see FAQ below) </li><li>  [X = Position X (see FAQ below) </li><li>  [R = CGRAM memory selection </li><li>  [V = Scroll Enabled </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [W = Scrolling off </font></font></li><li>  [b = Backlight on / off (will not work with us). </li></ul><br><br>  Other useful commands work without the \ 033 prefix! <br><br><ul><li>  \ r = Carriage return (return the cursor to position 0 on the current line!) </li><li>  \ n = New line </li><li>  \ t = Tab (default 3 characters) </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea seemed to me very cool, and I brazenly decided to borrow this function in our project. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, all these sequences work wonderfully in a conventional console, they can be used when displaying text. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who has not yet understood what it is and why, then he described </font></font><a href="http://lcd-mod.sourceforge.net/faq.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lcd-mod.sourceforge.net/faq.php</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> here in more detail </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In order not to suffer, I freely translated it and carefully put it in the spoiler with pictures</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FAQ</font></font></b> <div class="spoiler_text"> Q. ,   ,      ? <br> A.       ,  vt52- <a href="http://ru.wikipedia.org/wiki/VT52">ru.wikipedia.org/wiki/VT52</a> ,       .        ,       ASCII  .    ,      ‚Äî '\r'     '\n' (. <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B4_%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA%25D0%25B8"></a> ). ,  : <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"Line One\r\nLine Two"</span></span> &gt; /dev/lptlcd</code> </pre><br><br><img src="http://img-fotki.yandex.ru/get/9302/74270808.18/0_b4cf8_c5fbdac5_XL.jpg"><br> <b> </b> <br><br>     ‚ÄúLine One‚Äù  ‚ÄúLine Two‚Äù    .   ,    ‚Äúecho‚Äù : <br> -n ‚Äî       '\n' <br> -e ‚Äî      <br><br> Q.       ,      ? <br> A.               .  For example: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"line1\r\nline2"</span></span> &gt; /dev/lptlcd</code> </pre><br> (.  ) <br> Q. ,    ,  n    n- ,    n-1 ,    ? <br> A.  ,     ‚Äúecho‚Äù.  ,       '\n'   .    -n,    . <br><br> Q.       ? <br> A.           : ESC-Y[Y-+037][X-+037].  For example: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"\033[Y\037\037Hello"</span></span> &gt; /dev/lptlcd</code> </pre><br><br><img src="http://img-fotki.yandex.ru/get/9299/74270808.18/0_b4cf9_770b4e58_XL.jpg"><br> <b>Hello   0:0</b> <br><br>      ,         ‚ÄúHello‚Äù; <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"\033[Y\040\040Hello"</span></span> &gt; /dev/lptlcd</code> </pre><br>    ,    1, 1; <br><br><img src="http://img-fotki.yandex.ru/get/9510/74270808.18/0_b4cfa_fea16246_XL.jpg"><br> <b>Hello   1:1 (  )</b> <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"\033[Y\041\041Hello"</span></span> &gt; /dev/lptlcd</code> </pre><br> ,      2, 2 <br><br><img src="http://img-fotki.yandex.ru/get/9118/74270808.18/0_b4cfb_54e4f2dd_XL.jpg"><br> <b>Hello   2:2 (  ,   )</b> <br><br>  ‚Äú037‚Äù    ,       ,       ,     vt52        (    :) ).. <br><br> Q.       ? <br> A.   HD4480            ,       .     GUI    ,      (       ).  ,      . ,   . <br>     ,     : Esc-R[ ][8 ,    ].         ,      5 .      .  For example: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"\033[R1\037\037\037\037\037\037\037\037"</span></span> &gt; /dev/lptlcd</code> </pre><br>    1,     .  ,          . <br><br><img src="http://img-fotki.yandex.ru/get/9258/74270808.18/0_b4cfc_f3d08f29_XL.jpg"><br> <b>   </b> <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"\033[R2\037\000\037\000\037\000\037\000"</span></span> &gt; /dev/lptlcd</code> </pre><br>     0    . <br><br><img src="http://img-fotki.yandex.ru/get/9811/74270808.18/0_b4cfd_2d727c22_XL.jpg"><br> <b>  </b> <br><br>    ¬´¬ª ,    : <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"\000\001\002\003\004\005\006\007"</span></span> &gt; /dev/lptlcd</code> </pre><br><br><img src="http://img-fotki.yandex.ru/get/9299/74270808.19/0_b4d00_c1845c61_XL.jpg"><br>  ,       . <br></div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, as you can see, the dev_write function needs to be rewritten. </font><font style="vertical-align: inherit;">And she now began to look like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ssize_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dev_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( struct file *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">loff_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ppos )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;count;i++) handleInput(buf[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the handleInput function took all the dirty work of debriefing. </font><font style="vertical-align: inherit;">The code of this function is monstrous, so I will not give it here. </font><font style="vertical-align: inherit;">I'll leave it to you on your homework to sort it out and find the backdoor. </font><font style="vertical-align: inherit;">Who will find the Easter egg in the code, be noted in the comments, to that sweetie. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For priming backdoor vidos (it is implemented in the driver)</font></font><br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/GeTzT1Csb0w%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253,15700255&amp;usg=ALkJrhi-fm6fdCGTVWAs4kR_GWWQ_92B6A" frameborder="0" allowfullscreen=""></iframe><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASCII-ART Move! </font><font style="vertical-align: inherit;">Easter</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> egg starts! Those who show me a similar vidos on their screens will receive a gift from me! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, as a result, we got a kosher screen, which can be used to display various useful and useless information. </font><font style="vertical-align: inherit;">Here, for example, you can display the current time on it.</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -en <span class="hljs-string"><span class="hljs-string">"\033[H`date +\"%d.%m.%Y\"` \r\n`date +%r`"</span></span> &gt; /dev/lptlcd ; sleep 1s; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br><br><img src="http://img-fotki.yandex.ru/get/9811/74270808.19/0_b4d03_594ab865_XL.jpg"><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And they still go! </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, I wrote - share it with the people! </font><font style="vertical-align: inherit;">Source codes are available </font></font><a href="http://yadi.sk/d/ZjQRL_I1ENemT"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by reference</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (I‚Äôm still not going to use the github for code exchange, shame).</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What I would like to do </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just because the screen on the table is little clear why you need it, it's true. </font><font style="vertical-align: inherit;">Especially in the age of tablets and other equipment. </font><font style="vertical-align: inherit;">When everything can be redirected to your smartphone. </font><font style="vertical-align: inherit;">Another thing is that the New Year is coming soon, and I remember one wonderful New Year's device - a Christmas tree on the lpc2104 </font></font><br><br><img src="http://img-fotki.yandex.ru/get/9510/74270808.19/0_b4d07_542b5c01_XL.jpg"><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embedded Artists Cristmas Tree processor.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You shouldn't google this device, all references to it are removed even from the official site, and rare references to it are difficult to find even in the open spaces the internet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I even took a video of the work of this Christmas tree</font></font><br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/MQ-g7VSCXIQ%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700253,15700255&amp;usg=ALkJrhgWFBXYcgDLQtctw7yv0qyYv_hC9w" frameborder="0" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How the Embedder Christmas Tree Works </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the cheerful blinking of lights, this funny device had a cool feature - it was possible to correspond with other owners of such Christmas trees. </font><font style="vertical-align: inherit;">There was a certain sideboard, where through a special form it was possible to drive a message and it was sent out by Christmas trees and displayed on the screen. </font><font style="vertical-align: inherit;">It was very, very cool and fun. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now attention: idea!</font></font></b>  Now nothing prevents to pay 500 rubles for a month (and if we throw off, the amount will be quite small), and rent a server on a virtual machine.  There put a programmer who will send messages.  Either jabber or some other methods (but at least nc and telnet do everything).  And on the computer to put the receiver of these messages.  And on the New Year we all will have congratulations. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who is ready to help realize this, and who will make such screens for themselves? </font><font style="vertical-align: inherit;">If we have at least three people, it will be very, very fun! </font><font style="vertical-align: inherit;">Join the developer community :)))). </font><font style="vertical-align: inherit;">I will listen to ANY ideas!</font></font><br><br><h4>  Total </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'll be brief. This post, I set a goal not to retell the book Linux Device Drivers, but simply to show that writing firewood is a trivial task. I deliberately left the USB, because there is a lot of theory, pitfalls and other hemorrhoids. But you can easily rewrite this module for USB-LPT-laces, such as this </font></font><br><br><img src="http://img-fotki.yandex.ru/get/9811/74270808.18/0_b4be6_c4ae3c61_L.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is done relatively simply: the exchange protocol with usb is intercepted and implemented in your program. Believe me - it's easy. It will be interesting how - I'll tell you! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this driver, by changing the entire ONE (!!!) output line to the port, can be rewritten for use, for example, on the Raspberry Pi on the GPIO port. I will not tell you exactly what to write, but everything is solved by reading the datasheet by the percentage used and it takes only a few minutes.</font></font><br><br><h4>  Thanks: </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. I want to express my main gratitude to my teacher </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boronin Sergey Sergeevich </font></font></b> <a href="https://habrahabr.ru/users/sboronin/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sboronin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for teaching programming under linux and an excellent course of developing drivers for linux. Thanks to his courses, I am a very successful developer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Comrade </font></font><a href="https://habrahabr.ru/users/ariman/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ariman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with his wonderful series of articles about the development of the display for the router ( </font></font><a href="http://habrahabr.ru/post/163689/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://habrahabr.ru/post/163861/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://habrahabr.ru/post/164635/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">third</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> part (and the fourth was promised ...)). This series, albeit a very specific one, perfectly illustrates the creation of a device and the writing of appropriate drivers for it. And I repeatedly turned to it as a source of invaluable information, both in driver development and in the development of modules for OpenWRT.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Of course, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Greg Kroah-Hartman,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> author of the book ‚ÄúLinux Device Driver‚Äù </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This book is just a bible, and in the core you can often find drivers that are based on examples of it. </font><font style="vertical-align: inherit;">For example, in USB drivers I met this:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /drivers/usb/misc/idmouse.c </font></font><br>  ... <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derived from the USB Skeleton driver 1.1, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Copyright ¬© 2003 Greg Kroah-Hartman (greg@kroah.com)</font></font><br>  ... </blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And so in many drivers. </font><font style="vertical-align: inherit;">So, use the book - this is the bible. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Michael McLellan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> author of a similar driver. </font><font style="vertical-align: inherit;">As he says in his driver:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LCD driver for * HD44780 compatible displays the connected to the parallel port, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Because real men use device files is.</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, I do not have his coordinates, except for the link to </font></font><a href="http://www.linkedin.com/pub/mikey-mclellan/8/4a5/47b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linkedin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mail from its programs no longer works. So, how can I personally thank him, I don‚Äôt know ... If someone writes him, I will be very grateful.</font></font><br><br><h5>  Links </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Sources of my rootfs program working with a display </font></font><a href="http://yadi.sk/d/R1eWqL-MRbxXf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swing</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2. Sources of my kernel module, which we sorted out in this post </font></font><a href="http://yadi.sk/d/XuS67B_IRbxaL"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">swing</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. </font></font><a href="http://lcd-mod.sourceforge.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúGrand piano in the bushes‚Äù</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. </font></font><a href="http://dmilvdv.narod.ru/translate.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dmilvdv.narod.ru/translate.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Translations of articles. Handbook - Linux Device Drivers, Third Edition ". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. An excellent library of articles on programming in Russian from IBM lives </font></font><a href="https://www.ibm.com/developerworks/ru/views/global/libraryview.jsp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Specifically </font></font><a href="http://www.ibm.com/developerworks/ru/views/linux/libraryview.jsp%3Fsort_by%3D%26show_abstract%3Dtrue%26show_all%3D%26search_flag%3D%26contentarea_by%3DLinux%26search_by%3D%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0%2B%25D0%25BC%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B9%2B%25D1%258F%25D0%25B4%25D1%2580%25D0%25B0%2BLinux%26topic_by%3D-1%26type_by%3D%25D0%25B2%25D1%2581%25D0%25B5%26ibm-search%3D%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the development of kernel modules</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Description of the HD44780 display (for AVR, but in general it is universal) </font></font><a href="http://easyelectronics.ru/avr-uchebnyj-kurs-podklyuchenie-k-avr-lcd-displeya-hd44780.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">easyelectronics.ru/avr -uchebnyj-kurs-podklyuchenie-k-avr-lcd-displeya-hd44780.html</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Display programs (kernel module and spectrum analyzer for this module) by Michael McLellan</font></font><a href="http://linux.downloadatoz.com/developer-michael-mclellan.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linux.downloadatoz.com/developer-michael-mclellan.html </font></font></a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Do not shoot the pianist, he plays as </font><a href="http://linux.downloadatoz.com/developer-michael-mclellan.html"><font style="vertical-align: inherit;">best</font></a><font style="vertical-align: inherit;"> he can. </font><font style="vertical-align: inherit;">Such an enormous article in my innate illiteracy cannot be written normally. </font><font style="vertical-align: inherit;">Be sure to send me comments, edits, and additions, I will be very grateful !!! </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nothing warms the soul like a comment left. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPPS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The text also has Easter eggs, who will find - that sweetie;))) </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So I </font></font><a href="https://groups.google.com/forum/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">created a group</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for the messenger who want to participate :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For participants who wish, please join :)))</font></font></div><p>Source: <a href="https://habr.com/ru/post/206148/">https://habr.com/ru/post/206148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206136/index.html">Broadcasting XXI century</a></li>
<li><a href="../206138/index.html">Cisco vs Aruba: Arguments Exhausted?</a></li>
<li><a href="../206142/index.html">Arcanum and Fallout 2 with touch screen and stylus in Windows 8</a></li>
<li><a href="../206144/index.html">The power of a word. How a simple explanation saved user relationships.</a></li>
<li><a href="../206146/index.html">We buy train tickets in the New Year</a></li>
<li><a href="../206150/index.html">The second life of old dial gauges</a></li>
<li><a href="../206152/index.html">Tuning mooedit, work on the bugs</a></li>
<li><a href="../206154/index.html">rusEfi: ignition and other buns</a></li>
<li><a href="../206160/index.html">Basics of developing a client network I2P. Part 2</a></li>
<li><a href="../206164/index.html">Startups from Silicon Valley with Russian-speaking founders. Jacob Diener and Igor Katsman - the founders of Driveway Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>