<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stack programming with a human face</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think many of you have found articles and books about stack programming and the Forth language on the Internet. First, a wave of enthusiasm: how sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stack programming with a human face</h1><div class="post__text post__text-html js-mediator-article">  I think many of you have found articles and books about stack programming and the Forth language on the Internet.  First, a wave of enthusiasm: how simple it is, logical, understandable and powerful!  And why are these ideas so insignificant?  Why do so few programmers really use languages ‚Äã‚Äãlike Fort?  After some time, a wave of disappointment comes up: yes, an interesting idea, but how hard it is to read the source code, how dreary work is being done with variables, strings and fractional numbers!  An interesting toy, useful to a group of baitosles, no more. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8a/3de/65e/e8a3de65e55f988c9e154f4ca5174be2.gif" alt="image"><br><br>  Often this ends it.  But personally, I could not come to terms with the idea that elegant concatenative programming will remain in the shadow of other ideas.  Yes, difficulty reading the source code.  Yes, one line syndrome.  Yes, each time to understand the algorithm, you have to imagine in the imagination to broadcast the program and imagine the stack, reading the source code.  But really, these are the shortcomings that are necessarily inherent in stack languages ‚Äã‚Äãand without which stack programming would no longer be stackable?  Is it really impossible to at least smooth out these shortcomings and make life easier for programmers?  It turns out that it is possible and necessary! <br><a name="habracut"></a><br><h4>  Problem one: single line syndrome </h4><br>  I first found the phrase ‚Äúsingle-line syndrome‚Äù in Barron‚Äôs ‚ÄúIntroduction to Programming Languages‚Äù.  And although the term is not widely spread, it very expressively characterizes many languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A single-line syndrome is characteristic of those languages ‚Äã‚Äãthat allow the free structure of the source code of a program and have short, and sometimes even single-character keywords.  The programmer is trying to ‚Äúcram‚Äù as many keywords as possible into one line, which is why the programs do not look too readable.  This syndrome is especially pronounced in the APL and its descendants, in Brainfuck and, of course, in the Fort.  Look again at the illustration at the beginning of the post and calculate the average number of words per line. <br><br>  But this is a solvable problem.  In Forte, the single-line syndrome appeared due to the addictions of Moore, who loves short and meaningful English words very much.  Unfortunately, such words quickly end, and suffixes and prefixes (so-called namespaces on the knee) Moore does not like.  Therefore, now the whole world enjoys laconic hieroglyphs in the spirit of "@! C @ C! / MOD CR \ S P", stuck in one line.  The problem is simply solved by the selection of more successful words.  Why write: <br><pre><code class="dos hljs">: <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span>-EXAMPLE OVER OVER + ROT ROT - * ;</code> </pre> <br>  If I may: <br><pre> <code class="dos hljs">define <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-exemple (ab -- {a+b}*{ab})    over over    (ab -- abab)    +    (ab -- ab a+b=c)    rot rot    (abc -- cab)    - * end</code> </pre><br>  And even better: <br><pre> <code class="dos hljs">define <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-exemple [ab -- r]    [ab -&gt; abab]    +    [abc (=a+b) -&gt; cab]    - / end</code> </pre><br>  But such a record will be discussed below. <br><br><h4>  Problem two: code inside out </h4><br>  Another difficulty is the management structure inside out.  Of course, they are elegant from the point of view of the idea and implementation, but how can such a code be hard to read: <br><br><pre> <code class="dos hljs">: sign-test ( n -- ) dup <span class="hljs-number"><span class="hljs-number">0</span></span> &lt; [ drop "" ] [ zero? [ "" ] [ "" ] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> ;</code> </pre><br>  In this example, the code blocks are elementary and the whole definition of the word is in full view.  But it is worth a little more to complicate it, as the program will seem unreadable to the author a week after writing. <br><br>  The most usual if and while from imperative programming are in a hurry to help: <br><br><pre> <code class="dos hljs">define sign-test [x]   [x -&gt; xx]   <span class="hljs-number"><span class="hljs-number">0</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>     " "    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>     "   "   end-ifprint-string end</code> </pre><br>  Maybe they are not as powerful and extensible, but very understandable and practical.  And if you really want to create something like arithmetic if from the good old Fortran, the mechanism of code blocks at the top of the stack can be included in the language as an additional element and not be used everywhere, but only where it is really necessary and justified.  Fortunately, to eat such a mechanism is not asking, and the implementation will not be too complicated. <br><br>  As for the Fort, he has another problem with it: all the same words.  Moore did not want to add identical final words like END to complex structures, so IF, DO and other words should be closed with their own unique words.  Therefore, we see all these IF ELSE THEN, which lead even experienced programmers to a dead end.  If you really do not want to complicate the parser and the mechanism of words, why not enter words like END-IF?  This is reflected in Moore‚Äôs dislike of suffixes and prefixes.  But, like the first problem, this moment is also easily solved and is not a specific shortcoming of stack languages. <br><br><h4>  Problem three: interpretation in the head </h4><br>  Due to a number of features of the program on Forte and other stack languages, it is difficult to read and delve into their essence.  The thing is that every time you read a block of code in which a new word is introduced, you have to interpret the program in your imagination and at every step imagine what elements are in what order are on the stack and how functions work with them.  Needless to say that in some places it is very tiring and unproductive.  But the most unpleasant thing is that, unlike the previous features that have simply historically been so unfortunate, the need for such an interpretation is an eternal companion of stack programming. <br><br>  Of course, it is impossible to get rid of this drawback, but there are ways that make it much easier for a programmer to read the source code.  And most importantly: the first steps have already been taken.  Indeed, Fort programmers adopted a certain notation to make it easier to read the source code: <br><br><pre> <code class="dos hljs">(  --  )</code> </pre><br>  Such comments facilitate the understanding of the numbers on the stack, their number and order.  You do not need to strain your imagination every time to understand how many numbers and in what sequence you need to put on the stack before calling the function and how many numbers on the stack will remain as a result of the calculations.  But here is a riddle: if such comments are very visual and useful, why do Fort programmers write them only at the beginning of the definition of a word, and even then not always?  What religion interferes with after the heap drop dup swap rot to write such an explanatory comment? <br><br>  Let's return to the second code example.  Of course, this is a case in a vacuum, but in real complex programs such comments will be relevant: <br><br><pre> <code class="dos hljs">define <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-exemple (ab -- {a+b}/{ab})    over over    (ab -- abab)    +    (ab -- ab a+b=c)    rot rot    (abc -- cab)    - / end</code> </pre><br>  There is no need for the programmer every time after all these swap, rot and + to simulate in his head the order of the numbers in the stack.  Just need to run through the eyes of the comments.  But here is a new problem: records <br><br><pre> <code class="dos hljs">(ab -- abab)</code> </pre><br>  AND <br><pre> <code class="dos hljs">over over</code> </pre><br>  are similar.  Just the first entry is made in a declarative style, and the second - in the imperative.  That is, the lines in the program are constantly duplicated.  With the same success, we can talk about the convenience of the assembler: on the left, write code with a bunch of mov and ret, and on the right in the comments a = a + 1, and then talk about readability.  Well, yes, read the comments.  But they can be contrived to write so that when using any programming language they will be read very easily and clearly.  From this, of course, it does not follow that such languages ‚Äã‚Äãare convenient.  They can be arbitrarily bad from the point of view of reading the source code. <br><br>  There is a natural desire to combine (ab - abab) and over over.  Indeed, if you write comments in a certain notation, the compiler can parse them and manually add the necessary words to rearrange the elements of the stack.  Comments in parentheses are completely ignored and are intended only for humans.  Comments in square brackets are needed both by the person and the broadcaster.  The translator analyzes such comments in which a person writes what he needs, and not how to arrive at such a result.  That is, you can work with the stack in a declarative style. <br><br>  Consider the main, so to speak, varieties of such expressions: <br>  1. define foo [bar] or [bar - foo] <br>  After the name of the new function in square brackets you need to specify the number of arguments that should be on top of the stack.  If, when calling a function that requires three arguments, there are only two arguments on the stack, then the traditional Fort system will generate an error: the stack is empty.  But with such comments, the translator will be able to ‚Äúlook‚Äù at the comment and determine the names of the missing arguments: aha, the argument r is missing here when calling the function foo.  Agree, it is much more informative than the lean "stack is empty."  Naturally, all that has been said applies only to working interactively when source code is available.  After compilation, these comments will disappear, they are needed only for debugging and reading the source code.  For comparison, error output in gforth: <br><br><pre> <code class="dos hljs">: add-xy ( xy -- x+y ) compiled + ; ok <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> add-xy . <span class="hljs-number"><span class="hljs-number">9</span></span> ok <span class="hljs-number"><span class="hljs-number">4</span></span> add-xy . :<span class="hljs-number"><span class="hljs-number">6</span></span>: Stack underflow <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt;add-xy&lt;&lt;&lt; . Backtrace: $<span class="hljs-number"><span class="hljs-number">7</span></span>FF17383C310 + ok</code> </pre><br>  2. [ab -&gt; a] <br>  The following types of expressions differ from the purely descriptive word -&gt;, which is similar to the word - in classic comments.  If the number of elements on the left is greater than the number of elements on the right, then the translator comes to the conclusion: some elements need to be thrown away, they are no longer needed.  If an element is on the top of the stack, then this structure is converted to drop, but if it is not, the translator first performs a permutation of the elements of the stack so that the garbage will be on top of the stack, after which the drop will be applied.  Do I have to say how such a record makes life easier for a programmer in the event that you need to remove, say, two items from the middle of the stack.  Let the translator himself decide how best to do it, the programmer only describes what he needs. <br>  3. [ab -&gt; ba] <br>  Such expressions mean a permutation of elements: the number of elements to the left and right of the word -&gt; is the same and the elements themselves are the same.  It remains only to choose the optimal scheme of permutation.  Let the car do it, people are so arranged that long chains over swap drop rot enter them into a stupor. <br>  4. [ab -&gt; aabb] <br>  The number of elements on the left is less than the number of elements on the right.  This suggests that some elements need to be duplicated.  But what are these elements and in what order should they be located? Let the translator decide.  It is inconvenient for a person to think in terms of swap dup rot dup. <br>  5. [ab -&gt; ab] <br>  Nothing has changed, purely descriptive design.  An example application is given below. <br><br>  Naturally, in such declarative expressions you can use the usual comments: <br><br><pre> <code class="dos hljs">dup rot + [ab -&gt; ab (a + b)]</code> </pre><br><br>  We describe some words of the Fort in the new form: <br><pre> <code class="dos hljs">define dup [x]    [x -&gt; xx] end define drop [x]    [x -&gt; ] end define swap [xy]    [xy -&gt; yx] end define over [xyz]    [xy -&gt; xyx] end define rot [xyz]    [xyz -&gt; yzx] end</code> </pre><br><br><h4>  Problem four: floating point numbers </h4><br>  Imagine a stack consisting of 32-bit cells that store integers.  All such a stack is good: and the speed of arithmetic operations, and the convenience of working with the addresses of variables.  But if we need to multiply 3.14 by 4?  Where to put a fractional number?  If you organize the stack as a set of 64-bit cells in which floating-point numbers are stored and store integers as fractional numbers with a zero fractional part, advantages such as the speed of arithmetic operations will immediately evaporate. <br><br>  We introduce the second stack for floating point numbers.  Cells in it will be, say, 64-bit, but they will be less.  All numbers without a point are put on the vertices of the integer (integer) stack, and all numbers with a dot (even if they have a zero fractional part) are stored in a fractional (float) stack.  That is, we can multiply the numbers mentioned as follows: <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">14</span></span> *f</code> </pre><br>  where * f multiplies fractional numbers (similar to + f, -f, and so on). <br><br>  We also introduce a new declarative expression: <br>  [stack: abc -&gt; stack: abc] <br>  Which takes items from one stack and puts them in another: <br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> [integer: z1 z2 -&gt; float: z1 z2] <span class="hljs-number"><span class="hljs-number">2</span></span> times <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-float end-times</code> </pre><br>  The fractional stack will show the numbers 4.0 and 5.0.  The reverse operation "cuts off" the fractional part. <br>  Define new words: <br><pre> <code class="dos hljs">define integer-&gt;float [x]    [integer: x -&gt; float: x] end define float-&gt;integer [x]    [float: x -&gt; intger: x] end</code> </pre><br>  Similarly with the return stack. <br><br>  Fasting turned out quite voluminous and sometimes controversial, so much of the material will be in the second part.  Again, the ideas and criticisms from the discussion will correct the writing plan. </div><p>Source: <a href="https://habr.com/ru/post/242821/">https://habr.com/ru/post/242821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242807/index.html">Development of the program in Multimedia Builder on the example of a utility for remote work with cash register software</a></li>
<li><a href="../242811/index.html">Creating a Wi-Fi teapot "for dummies": how we have not broken Kickstarter (for now)</a></li>
<li><a href="../242813/index.html">Once again about education in school</a></li>
<li><a href="../242815/index.html">#MBLTDev 2014 through the eyes of a simple iOS developer from Tinkoff Bank</a></li>
<li><a href="../242819/index.html">network manager + wifi http login automation</a></li>
<li><a href="../242823/index.html">SpeechMarkup API - we turn speech into data</a></li>
<li><a href="../242827/index.html">Interview: Tim Messerschmidt, PayPal</a></li>
<li><a href="../242829/index.html">Sergey Povolyashko. Why does size matter? - report from SPMConf</a></li>
<li><a href="../242833/index.html">Bearded designers are the last to think about design.</a></li>
<li><a href="../242835/index.html">GamepadAPI or browser joystick</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>