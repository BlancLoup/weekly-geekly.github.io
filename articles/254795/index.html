<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Worst API ever created</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A detailed look at logging context switching using the Event Tracing API for Windows. 
 In response to the post last week, I received the following em...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Worst API ever created</h1><div class="post__text post__text-html js-mediator-article"><h3>  A detailed look at logging <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">context switching</a> using the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb968803%2528v%3Dvs.85%2529.aspx">Event Tracing API</a> for Windows. </h3><br>  In response to the post last week, I received the following email: <br><blockquote>  Maybe I‚Äôm a little late with a question about your recent post, but just in case, I‚Äôll ask: do you have any methods (strategies) of working with an external library that you can‚Äôt get rid of and that violates some (or all ) principles of writing API design (most likely, refer to the principles, recommendations, which are described in the <a href="http://mollyrocket.com/casey/stream_0028.html">previous</a> article of the author. <i>Approx. transl.</i> )?  Maybe there are some stories?  This is a vague question, but I‚Äôm just asking about any experience (as a user) of using an API that I really remember. <br></blockquote><br>  <i>- Michael Bartnett</i> <br><br>  It reminded me that, really, I always wanted to describe in detail the steps necessary to use a bad API - just to highlight how bad it can be for a developer.  I don‚Äôt think that the people who develop the API really understand how important it is to do it correctly and how much unnecessary work hundreds, thousands and sometimes millions of other developers do when incorrect, erroneous API development.  So, I felt it was important to write an article that would show how much unnecessary work a written API can call. <br><br>  It would probably be a good article in a weekly review of bad APIs.  But, since I don‚Äôt have time for something like this and I can only make out one API, the most important question arises: which API should I choose? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Event Tracing API for Windows </h1><br><a name="habracut"></a><br><br>  Now is a great time in the history of computing for writing an article about a bad API (on the other hand, it can be said that this is the worst time to make a living using programming).  There are so many bad APIs now that I can randomly select one API and most likely I will find enough problems to write an article of 3000 words.  But if I was going to choose one, separate operation in one API, then my choice seems reasonable among all APIs that I have ever used. <br><br>  Currently, there are a lot of APIs that make a lot of effort to get into the top-ranking "worst APIs".  For example, CSS, with the appearance of a new version, can take half the places in the top 10 ranking for the year.  In times of its popularity, DirectShow certainly dominated the ranking of its era.  In the new generation, newcomers such as the Android SDK, along with the development tools, demonstrate real potential for their intricacies, so the quality of the API, when called from C ++ code, is the last thing you're worried about. <br><br>  But when I thought long and hard about who was the winner in the ‚Äúhard category of bad API‚Äù - there was one real one - Event Tracing API for Windows. <br><br>  The Event Tracing API for Windows is an API that does something very simple: it allows any component of the system (including regular applications) to notify about "events" that can be received ("absorbed") by any other component.  This is a logging system that is used to record the performance and debugging information of any component, starting with the system core. <br><br>  Now, usually, there is no reason for game developers to use Event Tracing API for Windows directly.  You can use utilities such as PerfMon to view information about your game, such as how many working sets (working set) it uses or how hard it works with the disk.  But there is one specific thing that only provides direct access to the Event Tracing API: the ability to track the context switching time. <br><br>  Yes, if you have a fairly recent version of Windows (for example, 7 or 8), the OS kernel will log all context switches, including CPU timestamp.  You can actually relate them to your own profiling in the game.  This is incredibly useful information (from the category of information that can only be obtained directly from the "iron").  This is the reason why such utilities as <a href="http://www.radgametools.com/">RAD</a> , <a href="http://www.radgametools.com/telemetry.htm">Telemetry</a> can show you when the streams you started were interrupted and have to wait until the system itself does its work;  something that can be critically important for debugging weird performance issues. <br><br>  It sounds very good.  I mean that the context switching time is very significant information and even if the API is not of the best quality, it‚Äôs still very cool, isn't it? <br><br>  Is not it? <br><br><h1>  First of all - write an example of using the API </h1><br><br>  Before we take a look at the real Event Tracing API for Windows, I want to do step by step what I said at the lecture last week: first write a usage example.  Whenever you evaluate the quality of an API, or create a new API, you always, always, ALWAYS have to start by writing some code as if you are a user who is trying to do the things for which your API is intended.  If there are no restrictions, this is the only way to get a good and clean look at the future of how the API will work.  It would be "magical."  And then, when you have some examples of use, You can move forward and start thinking about practical problems and about the best way for you to implement. <br><br>  So, if I were a developer without any knowledge of Event Tracing API for Windows, how would I want to get a list of context switches?  Well, 2 ways come to mind. <br><br>  The simplest approach would be like: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    etw_event_trace Trace = ETWBeginTrace(); ETWAddEventType(Trace, ETWType_ContextSwitch); //    event EventBuffer[4096]; int EventCount; while(EventCount = ETWGetEvents(Trace, sizeof(EventBuffer), EventBuffer)) { {for(int EventIndex = 0; EventIndex &lt; EventCount; ++EventIndex) { assert(EventBuffer[EventIndex].Type == ETWType_ContextSwitch); //  EventBuffer[EventIndex].ContextSwitch }} } //    ETWEndTrace(Trace);</span></span></code> </pre> <br>  which will lead to an API that will look, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> etw_event_type { ETWType_None, ETWType_ContextSwitch, ... ETWType_Count, }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">etw_event_context_switch</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> TimeStamp; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ProcessID; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> FromThreadID; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ToThreadID; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">etw_event</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Type; <span class="hljs-comment"><span class="hljs-comment">// event_type union { etw_event_context_switch ContextSwitch; ... }; }; struct etw_event_trace { void *Internal; }; event_trace ETWBeginTrace(void); void ETWAddEventType(event_trace Trace, event_type); int ETWGetEvents(event_trace Trace, size_t BufferSize, void *Buffer); void ETWEndTrace(event_trace Trace);</span></span></code> </pre><br><br>  This is one way to do this.  Very simple, easy to understand.  It's hard enough to make a mistake.  If someone went through a debugger, he would see exactly what was going on and you simply could say what went wrong. <br><br>  However, I can imagine a situation where the critical performance code would not want to pay for copying from the kernel buffer to your buffer - what this API requires ( <code>ETWGetEvents</code> should copy events from some internal OS buffer, since they need to be taken from somewhere) .  The version will be a little more difficult to take some displayed memory using the API, which you use as a buffer for reading: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    etw_event_trace Trace = ETWBeginTrace(4096*sizeof(etw_event)); ETWAddEventType(Trace, ETWType_ContextSwitch); //    etw_event_range Range; while(ETWBeginEventRead(Trace, &amp;Range)) { {for(etw_event *Event = Range.First; Event != Range.OnePastLast; ++Event) { assert(Event-&gt;Type == ETWType_ContextSwitch); //  Event-&gt;ContextSwitch }} ETWEndEventRead(Trace, &amp;Range); } //    ETWEndTrace(Trace);</span></span></code> </pre><br><br>  All I did here was to change the return mechanism: instead of copying, a pointer to a certain block (a ‚Äúranged pointer‚Äù means a pointer to a certain range. In general, a pointer that knows where the data it points to ends. <i>Note .</i> ).  In <code>ETWBeginTrace</code> , the user transmits the maximum number of events, which affects the buffer size and the kernel allocates a memory area (in the user address space) that is sufficient for the specified number of events.  Then the system, if it can, writes directly to the allocated buffer and, thus, avoids unnecessary copying.  When the user calls <code>ETWBeginEventRead()</code> , pointers are returned to the beginning and end of some part of the memory for the events.  Since the buffer will be processed as a ring buffer, the user expects to be able to loop through all the received events in the event that there are more than one event.  I added the ‚Äúend of reading‚Äù call, as some implementations may require the kernel to know what part of the buffer the user is viewing, thus avoiding writing to a memory that is actively being read.  I don‚Äôt really know if such things are needed at all, but if you want to get basic information and give the kernel maximum flexibility to implement, this version definitely supports more possible implementations than the version with <code>ETWGetEvents()</code> . <br><br>  The API will be updated, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">etw_event_range</span></span></span><span class="hljs-class"> {</span></span> etw_event *First; etw_event *OnePastLast; }; <span class="hljs-function"><span class="hljs-function">event_trace </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ETWBeginTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BufferSize)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ETWBeginEventRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event_trace Trace, etw_event_range *Range)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ETWEndEventRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event_trace Trace, etw_event_range *Range)</span></span></span></span>;</code> </pre><br><br>  If you really want to, you can even support both versions of reading events using the same API - you just need to allow the <code>ETWGetEvents()</code> call.  Also, to supplement the API with error messages, it would be nice to have something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ETWLastGetEventsOverflowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event_trace Trace)</span></span></span></span>;</code> </pre><br>  so that after each call to <code>ETWGetEvents()</code> be able to check, and not too many events have occurred since the last check? <br><br>  To each his own, but I think that most developers will not have any problems with the API that I just proposed.  Everyone has their own tastes and I am sure that everyone will notice something that he does not like, but I doubt that someone will say that the API is terrible.  The API is pretty simple and I think most developers will be able to easily embed this API into their code without too much thought. <br><br>  The reason why the API is so simple is not because I used a lot of API development experience to subtly show my vision of a good API.  On the contrary.  The API is simple, because the problem it is designed to solve is elementary.  How to move data from one place to another is, in fact, the simplest problem for the API that may arise in the system.  This is a celebrated <code>memcpy()</code> . <br><br>  But it is the simplicity of the task that makes the Event Tracing API for Windows shine.  Even if all that needs to be done is to move the memory from one place to another, using this API causes all sorts of difficulties that you can imagine. <br><br><h1>  ‚ÄúRun‚Äù tracking </h1><br><br>  I don't know how anyone wants to start teaching how to use the Event Tracing API for Windows.  Maybe there are good examples teaching this that I just never met.  I had to put together pieces of code taken from various scraps of documentation during many hours of experiments.  Every time I figured out one more step in the overall process, I thought: ‚ÄúWait, seriously ??‚Äù.  And every time Microsoft implicitly answered: "Seriously." <br><br>  If I tell you how to use the API, then you lose the opportunity to experience a screaming experience, so I will say that if you want to feel everything in full, interrupt the reading and try to get the context switching time yourself.  I can guarantee that you will receive hours of unbridled fun and anxiety.  Those of you who prefer to save time, avoiding heaps of obscure moments - just read on. <br><br>  OK, let's start.  The equivalent of my function <code>ETWBeginTrace()</code> is the call proposed by Microsoft, <code>StartTrace()</code> .  At first glance, it seems rather harmless: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TRACEHANDLE *SessionHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *SessionName, EVENT_TRACE_PROPERTIES *Properties)</span></span></span></span>;</code> </pre><br><br>  However, when you look at what needs to be transferred to the place of the <code>Properties</code> parameter, things get a little more complicated.  The structure <code>EVENT_TRACE_PROPERTIES</code> , defined by Microsoft, looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EVENT_TRACE_PROPERTIES</span></span></span><span class="hljs-class"> {</span></span> WNODE_HEADER Wnode; ULONG BufferSize; ULONG MinimumBuffers; ULONG MaximumBuffers; ULONG MaximumFileSize; ULONG LogFileMode; ULONG FlushTimer; ULONG EnableFlags; LONG AgeLimit; ULONG NumberOfBuffers; ULONG FreeBuffers; ULONG EventsLost; ULONG BuffersWritten; ULONG LogBuffersLost; ULONG RealTimeBuffersLost; HANDLE LoggerThreadId; ULONG LogFileNameOffset; ULONG LoggerNameOffset; };</code> </pre><br><br>  where, in turn, the first data member is also a structure that expands to the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNODE_HEADER</span></span></span><span class="hljs-class"> {</span></span> ULONG BufferSize; ULONG ProviderId; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { ULONG64 HistoricalContext; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> ULONG Version; ULONG Linkage; }; }; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { HANDLE KernelHandle; LARGE_INTEGER TimeStamp; }; GUID Guid; ULONG ClientContext; ULONG Flags; };</code> </pre><br>  A quick glance at this mass of strange data raises only questions: why are there such members as <code>"EventsLost"</code> and <code>"BuffersWritten"</code> (‚Äúnumber of <code>"BuffersWritten"</code> events‚Äù and ‚Äúnumber of recorded buffers‚Äù, respectively, from the documentation. <i>Approx. Transl.</i> ) ?  The reason is as follows: instead of making different data structures for different operations that can be used to track events, Microsoft has grouped API functions into several groups, and all functions in each group share a combined structure for parameters.  Therefore, instead of the user getting a clear idea of ‚Äã‚Äãwhat is being fed into the input and returning from a function, simply looking at the parameters of the function - it should depend entirely on the MSDN documentation for each API, and hope that the documentation correctly lists which members of the giant Parameter structures are used for each call and when they are intended to transfer input and output parameters. <br><br>  Of course, since there are so many different ways to use this structure, Microsoft requires that you completely nullify this huge beast before using: <br><br><pre> <code class="cpp hljs">EVENT_TRACE_PROPERTIES SessionProperties = {<span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre><br>  For the <code>StartTrace()</code> function, if you just want to receive the data directly and will not log them to a file, you need to fill in some members.  These two have some meaning: <br><br><pre> <code class="cpp hljs">SessionProperties.EnableFlags = EVENT_TRACE_FLAG_CSWITCH; SessionProperties.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;</code> </pre><br>  The member <code>EnableFlags</code> says we want to get it.  We want a context switch, so we set this flag.  And now let's see what happens when there are more than 32 events from one provider?  I do not know, but I assume that Microsoft was not particularly concerned about this opportunity.  But I was, that's why I used <code>enum</code> in my sentence, since it supports billions of types of events.  But wait, "32 types of events should be enough for everyone" - so Microsoft offered a 32-bit flag field.  There are no problems, but this is definitely a sign of a close-minded thinking, which leads to things like duplication of functions with an <code>Ex</code> prefix at the end of the name (‚ÄúEx‚Äù from ‚ÄúExtended‚Äù is an extended version of the function. <i>Approx. Transl.</i> ). <br><br>  <code>LogFileMode</code> determines whether we want to receive events directly or we want the kernel to write them to disk.  Since these are completely different operations, I would like to break them into calls for different functions, but, wait a minute, we have one big structure for everything - we drop everything there. <br><br>  Things get a little weird with this field: <br><br><pre> <code class="cpp hljs">SessionProperties.Wnode.ClientContext = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  What does this record mean?  Well, terribly called <code>"ClientContext"</code> ("Context of the <code>"ClientContext"</code> . <i>Approx. Translation</i> ), actually refers to the way in which you want to get the time of events.  <code>"TimestampType"</code> ("TileTimeType". <i>Approx. Transl.</i> ) Would be a little clearer, but not important.  Real fun is a simple <code>"1"</code> on the right. <br><br>  It turns out that there is a set of values ‚Äã‚Äãthat <code>ClientContext</code> can accept, but Microsoft does not always give them names.  So you just have to read the documentation and remember that 1 means that time comes from <code>QueryPerformanceCounter</code> , 2 means ‚Äúsystem time‚Äù, and 3 means the number of CPU cycles. <br><br>  In case this is not obvious, there are many reasons why a publicly available API should never do that.  In the hidden part of the implementation, from time to time, I will act in a similar way, in situations where, say, you need to use -1 and -2 for some intricate indexing scheme.  But for an API that is literally used by millions of developers, you should always give names to your constants. <br><br>  First, it makes the code more readable.  No one knows what a <code>ClientContext</code> with a value of <code>"1"</code> , but the value of <code>USE_QUERY_PERFORMANCE_COUNTER_TIMESTAMPS</code> will be crystal clear.  Secondly, it makes the code searchable.  No one can normally search for ‚Äú1‚Äù in the code base, but <code>USE_QUERY_PERFORMANCE_COUNTER_TIMESTAMPS</code> is easily searched.  You might think: ‚Äúwell, no problem, I‚Äôll look for <code>ClientContext = 1</code> ‚Äù, but remember that more complex use of this API may include the use of variables, for example: <code>". . .ClientContext = TimestampType;"</code>  .  Third, the code will not compile for later versions of the SDK, where some things have changed.  For example, if you decide to disable the use of <code>USE_QUERY_PERFORMANCE_COUNTER_TIMESTAMPS</code> , they can remove the definition ( <code>#define</code> ) of this constant and make <code>USE_QUERY_PERFORMANCE_COUNTER_TIMESTAMPS_DEPRECATED</code> .  After such changes, the old code will not compile with the new version of the SDK and the developer will look at the new documentation and, thus, will see what he should use in return. <br><br>  Etc., etc., etc. <br><br>  Perhaps the most annoying field we have to fill: <br><br><pre> <code class="cpp hljs">SessionProperties.Wnode.Guid = SystemTraceControlGuid;</code> </pre><br><br>  <code>GUID</code> tells who is trying to track events.  In our case, we are trying to take data from the kernel log and <code>SystemTraceControlGuid</code> - a globally defined <code>GUID</code> that points specifically to this log.  I‚Äôm sure that a better name could be given for this <code>GUID</code> , but this is an insignificant problem compared to the fact that if you try to compile this line of code, you will see that the linker cannot find <code>SystemTraceControlGuid</code> . <br><br>  This happens, of course, because the <code>GUID</code> so large that Microsoft could not have found a way to embed them in the header files (I can count a few possible ways, but I suppose they didn‚Äôt like any of them) So Microsoft forces you to select one file in your project, in which, the Windows header files will embed <code>GUID</code> definitions.  In order to do this, you must write something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INITGUID </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   SystemTraceControlGuid  evntrace.h. #include &lt;windows.h&gt; #include &lt;strsafe.h&gt; #include &lt;wmistr.h&gt; #include &lt;evntrace.h&gt; #include &lt;evntcons.h&gt;</span></span></span></span></code> </pre><br>  So, now you have to carefully choose where you do it - perhaps create a new file in your project, where all <code>GUID</code> will be located - everyone can refer to them (or some kind of nonsense there).  In general, you can not identify them twice. <br><br>  But whatever it is, we are almost done with filling out the structure.  All we need is to deal with the <code>SessionName</code> parameter, which we have to pass as a string, right?  Since this is just a session name, I guess I can just do the following: <br><br><pre> <code class="cpp hljs">ULONG Status = StartTrace(&amp;SessionHandle, <span class="hljs-string"><span class="hljs-string">"CaseyTown!!!"</span></span>, &amp;SessionProperties);</code> </pre><br>  because it's a cool session title, don't you think so? <br><br>  But alas, things don't work that way.  It turns out that despite the fact that you have already specified a <code>GUID</code> for <code>SessionProperties</code> , which indicates that the kernel is the source of events - you also need to specify the predefined constant <code>KERNEL_LOGGER_NAME</code> as the name of the session.  Why?  Well, this is because there is a small surprise that I will save for you so that you can enjoy the intrigue of everything that happens. <br><br>  Ok so start: <br><br><pre> <code class="cpp hljs">ULONG Status = StartTrace(&amp;SessionHandle, KERNEL_LOGGER_NAME, &amp;SessionProperties);</code> </pre><br>  It looks good, right?  WRONG. <br><br>  It turns out that, despite the fact that the <code>SessionName</code> string <code>SessionName</code> passed as the second parameter, this is just a ‚Äúconvenient‚Äù feature.  In fact, <code>SessionName</code> should be implemented directly in the <code>SessionProperties</code> , but since Microsoft does not want to limit the maximum length of the string name, it was decided to just go ahead and package this string after the <code>EVENT_TRACE_PROPERTIES</code> structure.  Which means that, in fact, you can NOT do this: <br><br><pre> <code class="cpp hljs">EVENT_TRACE_PROPERTIES SessionProperties = {<span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre><br>  And should do so: <br><br><pre> <code class="cpp hljs">ULONG BufferSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(EVENT_TRACE_PROPERTIES) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(KERNEL_LOGGER_NAME); EVENT_TRACE_PROPERTIES *SessionProperties =(EVENT_TRACE_PROPERTIES*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(BufferSize); ZeroMemory(SessionProperties, BufferSize); SessionProperties-&gt;LoggerNameOffset = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(EVENT_TRACE_PROPERTIES);</code> </pre><br><br>  Yes, everything is correct - every user of the Event Tracing API for Windows must do arithmetic calculations and manually arrange the structure in a packaged format.  I cannot imagine why the name should be packaged in this way, but I am sure that if you need everyone to do this, you must provide an auxiliary macro or function that will do the right things for the user and save him from understanding your weird data packaging logic. <br><br>  But wait, at least you don't need to copy the name yourself!  Microsoft decided that the <code>StartTrace()</code> function of this API would copy the name into the structure for you, since in the end, the name is passed as the second parameter. <br><br>  Well, this is a beautiful gesture, but not so accepted in practice.  It turns out that the forced transfer of <code>KERNEL_LOGGER_NAME</code> as a <code>SessionName</code> ‚Äî along with the <code>GUID</code> ‚Äî is not, after all, superfluous, and this is the kind of surprise I mentioned.  The real reason why the <code>SessionName</code> parameter should be set to <code>KERNEL_LOGGER_NAME</code> is that Windows allows you to have only one session in the system ‚Äî in general, a session that reads events from the <code>SystemTraceControlGuid</code> .  Other <code>GUID</code> can have multiple sessions, but not <code>SystemTraceControlGuid</code> .  So, in fact, when you transfer <code>KERNEL_LOGGER_NAME</code> - you say that you want to have one, unique session that can exist in the system at any time with <code>SystemTraceControlGuid</code> <code>GUID</code> .  If someone has already started this session - your attempt to start it - will fail. <br><br>  Huh, everything is getting better.  The session name is global for the entire operating system and does not close automatically upon abnormal termination of the process that started the session.  So, if you wrote the code that calls <code>StartTrace()</code> , but somewhere a bug went through - no matter how - and your program crashed - <code>KERNEL_LOGGER_NAME</code> - the session will still work!  And, when you try to start your program again, possibly after fixing the bug, your attempt to call <code>StartTrace()</code> will fail with <code>ERROR_ALREADY_EXISTS</code> . <br><br>  So, in principle, the <code>StartTrace()</code> call, which will helpfully copy <code>SessionName</code> into a structure for you - in rare cases is the first call you want to do, in any case.  You will most likely make the following call: <br><br><pre> <code class="cpp hljs">ControlTrace(<span class="hljs-number"><span class="hljs-number">0</span></span>, KERNEL_LOGGER_NAME, SessionProperties, EVENT_TRACE_CONTROL_STOP);</code> </pre><br>  This call terminates any existing session and the subsequent <code>StartTrace()</code> call will succeed.  But, of course, <code>ControlTrace()</code> does not copy the session name as <code>StartTrace()</code> does, which means that, in practice, you have to do it yourself, since the <code>StartTrace()</code> call comes after the <code>ControlTrace()</code> call! <br><br><pre> <code class="cpp hljs">StringCbCopy((LPSTR)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)pSessionProperties + pSessionProperties-&gt;LoggerNameOffset), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(KERNEL_LOGGER_NAME), KERNEL_LOGGER_NAME);</code> </pre><br><br>  This is insane, but the consequences of all this are even more insane.  If you think about what it means to have only one possible tracking process that is attached to the kernel log, you will quickly realize that security issues come into play.  And what if some other process called <code>StartTrace()</code> to track the kernel log - how does the system know that our process has the ability to take and stop tracking the log and start another with our own settings? <br><br>  The answer is funny - no way.  In fact, kernel log tracking is fully accessible to all - let the best process win!  Whoever called <code>StartTrace()</code> , well, he gets the opportunity to configure the log tracking for himself. <br><br>  Well, not quite.  Obviously, you don‚Äôt want any process to steal kernel kernel tracking from another process.  Therefore, Microsoft has decided that the best solution to the problem is simply to deny access to the kernel log to all processes, except those that have administrator rights. <br><br>  Yes, that's right - I'm not exaggerating.  If you just want to get a list of context switches, even if for your own process, then it should be run with admin privileges.  All the delights of "clicking-right-button-launch-from-name-administrator".  If you have not done so and just started your process in the usual way, then your call to <code>StartTrace</code> will end with an error, because the process does not have enough privileges.  (In theory, you have the opportunity to add a user to the ‚ÄúPerformance Log Users‚Äù group and thus avoid running the process as an administrator, but I just say it now - in fact, I can't remember whether it will work for connections to kernel log or just for all other types of tracking ...) <br><br>  Amazing right?  ,   ,      2   ( <code>ETWBeginTrace()</code> / <code>ETWAddEventType()</code> ),    ,  ,  ,  ,  ,  ,   ,      <code>GUID</code> -,   <code>#define</code>  <code>#include</code> - ,  ,         . <br><br>  ,        ! <br><br><h1> ¬´¬ª  </h1><br><br>  ,   .  ,    ¬´ ¬ª      , ? ! ,     Event Tracing  Windows.     !     !      -, ,  ,     ,   ‚Ä¶    <code>OpenTrace()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">TRACEHANDLE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EVENT_TRACE_LOGFILE *Logfile)</span></span></span></span>;</code> </pre><br>    ?   , ,  ¬´¬ª  ‚Äî   ,   . ,   ,       .     ,        <code>OpenTrace()</code> . <br><br> ,  ,   <code>OpenTrace()</code> ,    <code>EVENT_TRACE_LOGFILE</code> . ,   ,    -,       ,    -   ¬´¬ª ‚Äî  .   ,    <code>StartTrace()</code> , <code>OpenTrace()</code> ‚Äî     ,     -, ,  ,  ,       ‚Äî    . <br><br>  <code>EVENT_TRACE_LOGFILE</code>   : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EVENT_TRACE_LOGFILE</span></span></span><span class="hljs-class"> {</span></span> LPTSTR LogFileName; LPTSTR LoggerName; LONGLONG CurrentTime; ULONG BuffersRead; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { ULONG LogFileMode; ULONG ProcessTraceMode; }; EVENT_TRACE CurrentEvent; TRACE_LOGFILE_HEADER LogfileHeader; PEVENT_TRACE_BUFFER_CALLBACK BufferCallback; ULONG BufferSize; ULONG Filled; ULONG EventsLost; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { EVENT_CALLBACK *EventCallback; EVENT_RECORD_CALLBACK *EventRecordCallback; }; ULONG IsKernelTrace; PVOID Context; };</code> </pre><br>   ,    " <code>Callback</code> " (  . <i>. .</i> ) ‚Äî      .       ‚Äî     .         . <br><br> ,  , <code>EVENT_TRACE_LOGFILE</code>      -  Microsoft     : <br><br><pre> <code class="cpp hljs">EVENT_TRACE_LOGFILE LogFile = {<span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre><br>    <code>OpenTrace()</code>    ,   -     ,   ¬´¬ª  . ,     ,      : <br><br><pre> <code class="cpp hljs">LogFile.LoggerName = KERNEL_LOGGER_NAME;</code> </pre><br> ,            .  Why?  !  ‚Äî   ,   . Microsoft ,     . <br><br>  ,     , ,   ,   : <br><br><pre> <code class="cpp hljs">LogFile.LoggerName = KERNEL_LOGGER_NAME; LogFile.ProcessTraceMode = (PROCESS_TRACE_MODE_REAL_TIME | PROCESS_TRACE_MODE_EVENT_RECORD | PROCESS_TRACE_MODE_RAW_TIMESTAMP);</code> </pre><br> <code>PROCESS_TRACE_MODE_REAL_TIME</code> ,    , ‚Äî   ,        -,    ,     . <code>PROCESS_TRACE_MODE_EVENT_RECORD</code> ‚Äî   ,   Windows,       <code>EventRecordCallback</code> ,    <code>EventCallback</code> (,   ,   API       !).   <code>PROCESS_TRACE_MODE_RAW_TIMESTAMP</code> ‚Äî  Windows    <code>ClientContext</code> ,     <code>StartTrace()</code> .  ,    : ,   , ,      " <code>2</code> "      " <code>2</code> " ‚Äî     " <code>2</code> ",   .     " <code>1</code> "  " <code>3</code> " ‚Äî  ‚Ä¶   . <br><br> -,    API  ,    : <br><br><pre> <code class="cpp hljs">LogFile.EventRecordCallback = CaseyEventRecordCallback;</code> </pre><br>   , -,    : <br><br><pre> <code class="cpp hljs">TRACEHANDLE ConsumerHandle = OpenTrace(&amp;LogFile);</code> </pre><br><br>  ,         ( !),  ,          <code>StartTrace()</code>  <code>OpenTrace()</code> .  2 API,        .     <code>TRACEHANDLE</code> .        .     .     . ! <br><br>  <code>StartTrace()</code>     <code>ULONG</code>   ,     .  <code>OpenTrace()</code>    ,     <code>INVALID_HANDLE_VALUE</code> ,   - . <code>StartTrace()</code>            (  -)       . <code>OpenTrace()</code>         ,    -   . <br><br><h1> ¬´¬ª  </h1><br><br>         ‚Äî   , -,    ,   ?   , ,  ,     ,     <code>OpenTrace()</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CaseyEventRecordCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EVENT_RECORD *EventRecord)</span></span></span><span class="hljs-function"> </span></span>{ EVENT_HEADER &amp;Header = EventRecord-&gt;EventHeader; UCHAR ProcessorNumber = EventRecord-&gt;BufferContext.ProcessorNumber; ULONG ThreadID = Header.ThreadId; int64 CycleTime = Header.TimeStamp.QuadPart; <span class="hljs-comment"><span class="hljs-comment">// Process event here. }</span></span></code> </pre><br><br>  ,             .  ,    ,    -   , ‚Äî .      ? <br><br>  , Windows    ,    ¬´¬ª ,      ,   API: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TRACEHANDLE *HandleArray, ULONG HandleCount, LPFILETIME StartTime, LPFILETIME EndTime)</span></span></span></span>;</code> </pre><br><br>    ,       Windows    ,      ,      . ,  ? ,  ,        ( - , , )        ? <br><br>   ,  ,      ,   Event Tracing API  Windows       :  <code>ProcessTrace</code>    . <br><br> ,    .  <code>ProcessTrace()</code> ,     , ,     ,   ,        .             <code>CloseTrace()</code> .  ,            ‚Äî    ,      ,     <code>ProcessTrace()</code> ! <br><br>  ,   ,    .       ,      <code>ProcessTrace()</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DWORD WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Win32TracingThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPVOID Parameter)</span></span></span><span class="hljs-function"> </span></span>{ ProcessTrace(&amp;ConsumerHandle, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><br> ,  ,    <code>OpenTrace()</code> ‚Äî       ,    : <br><pre> <code class="cpp hljs">DWORD ThreadID; HANDLE ThreadHandle = CreateThread(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Win32TracingThread, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;ThreadID); CloseHandle(ThreadHandle);</code> </pre><br><br> , ,  ,   ,             Event Tracing API  Windows. <br><br><h1>   API   </h1><br><br> ,  ,   :  API,   ,          ,        .           .       ---     API ,   ‚Äî  ,  Event Tracing API  Windows ‚Äî   API   . <br><br>     API,   ,       ( , 10  ). ,  ,            ‚Äî      ¬´ ¬ª.  ,              ,   .    ,           ,   ,   ,  <code>SessionName</code>   <code>KERNEL_LOGGER_NAME</code> ,  <code>GUID</code> ‚Äî <code>SystemTraceControlGuid</code> . <br><br> ,   ,   ,       API,   ‚Äî ¬´   ‚Äî    API¬ª.    ,         API    .         ‚Äî    ,  API <i></i>  ‚Äî ,        ,    ,    Microsoft- .      2  (.  ¬´   ‚Äî    API¬ª. <i>. .</i> ),    ,  ,  ,         Microsoft. <br><br> <u> </u> : <br>       ‚Äî    //    ( ). <br><br>        Windows,    ,   API Windows  Linux,    API Windows,  Linux API ‚Äî    ‚Äî   .     .        Linux API? </div><p>Source: <a href="https://habr.com/ru/post/254795/">https://habr.com/ru/post/254795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254785/index.html">We need instant messengers. More messengers</a></li>
<li><a href="../254787/index.html">Perl 6: nextsame and its relatives</a></li>
<li><a href="../254789/index.html">Translation of hours in Russia, again ... and php5-intl</a></li>
<li><a href="../254791/index.html">Aspect-oriented programming. The basics</a></li>
<li><a href="../254793/index.html">Two worlds of virtual machines</a></li>
<li><a href="../254797/index.html">The taste and color or coloring for Android</a></li>
<li><a href="../254799/index.html">Development of MMO RPG - a practical guide. Episode 1</a></li>
<li><a href="../254801/index.html">Android Volley custom Loader</a></li>
<li><a href="../254803/index.html">About interfaces</a></li>
<li><a href="../254805/index.html">Import data from YouTube and Vimeo to Google.Docs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>