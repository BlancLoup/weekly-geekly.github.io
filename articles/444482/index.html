<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What does memory expand in Ruby?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We at Phusion run a simple multi-threaded HTTP proxy on Ruby (distributes DEB and RPM packages). I saw on it a memory consumption of 1.3 GB. But this ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What does memory expand in Ruby?</h1><div class="post__text post__text-html js-mediator-article">  We at <a href="https://www.phusionpassenger.com/">Phusion</a> run a simple multi-threaded HTTP proxy on Ruby (distributes DEB and RPM packages).  I saw on it a memory consumption of 1.3 GB.  But this is crazy for a stateless process ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/f7a/d2b/9baf7ad2bd3ecdfb0779482c018473eb.jpg"></div><br>  <i><font color="gray">Question: What is it?</font></i>  <i><font color="gray">Answer: Memory use by the Ruby process over time!</font></i> <br><br>  It turns out that I am not alone in this problem.  Ruby applications can use a lot of memory.  But why?  According to <a href="https://devcenter.heroku.com/articles/tuning-glibc-memory-behavior">Heroku</a> and <a href="https://www.speedshop.co/2017/12/04/malloc-doubles-ruby-memory.html">Nate Berkopek</a> , <a href="https://www.speedshop.co/2017/12/04/malloc-doubles-ruby-memory.html">swelling</a> is mainly due to memory fragmentation and excessive <a href="https://www.speedshop.co/2017/12/04/malloc-doubles-ruby-memory.html">heap</a> allocation. <br><a name="habracut"></a><br>  Berkopek came to the conclusion that there are two solutions: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Either use a completely different memory allocator than glibc - usually <a href="http://jemalloc.net/">jemalloc</a> , or: </li><li> Set the magic environment variable <code>MALLOC_ARENA_MAX=2</code> . </li></ol><br>  I am worried about the description of the problem and the proposed solutions.  Something is wrong here ... I am not sure that the problem is fully described or that these are the only available solutions.  It also annoys me that many refer to jemalloc as a magic silver bullet. <br><br>  <b>Magic is just a science that we do not yet understand</b> .  So I went on a research trip to find out the whole truth.  In this article we will cover the following topics: <br><br><ol><li>  How memory allocation works. <br></li><li>  What is this ‚Äúfragmentation‚Äù and ‚Äúexcessive allocation‚Äù of memory that everyone is talking about? <br></li><li>  What causes high memory consumption?  Is the situation consistent with what people are saying, or is there something else?  (spoiler: yes, there is something else). <br></li><li>  Are there any alternative solutions?  (spoiler: I found one). </li></ol><br>  <i>Note: This article is relevant only for Linux, and only for multi-threaded Ruby applications.</i> <br><br><h1>  Content </h1><br><ul><li>  <a href="https://habr.com/ru/post/444482/">Ruby Memory Allocation: An Introduction</a> <br><ul><li>  <a href="https://habr.com/ru/post/444482/">Ruby</a> </li><li>  <a href="https://habr.com/ru/post/444482/">System memory allocator</a> </li><li>  <a href="https://habr.com/ru/post/444482/">Core</a> </li><li>  <a href="https://habr.com/ru/post/444482/">Memory usage</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/444482/">What is fragmentation?</a> <br><ul><li>  <a href="https://habr.com/ru/post/444482/">Ruby Fragmentation</a> </li><li>  <a href="https://habr.com/ru/post/444482/">Fragmentation at the memory allocator level</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/444482/">Is the fragmentation of Ruby heap pages causing memory swelling?</a> </li><li>  <a href="https://habr.com/ru/post/444482/">The study of fragmentation at the level of memory allocator</a> <br><ul><li>  <a href="https://habr.com/ru/post/444482/">Excessive memory allocation and glibc</a> </li><li>  <a href="https://habr.com/ru/post/444482/">Visualization of system heaps</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/444482/">Magic trick: circumcision</a> </li><li>  <a href="https://habr.com/ru/post/444482/">Conclusion</a> <br><ul><li>  <a href="https://habr.com/ru/post/444482/">Visualizer source code</a> </li><li>  <a href="https://habr.com/ru/post/444482/">What about performance?</a> </li><li>  <a href="https://habr.com/ru/post/444482/">Need more tests</a> </li></ul></li></ul><br><a name="1"></a><h1>  Ruby Memory Allocation: An Introduction </h1><br>  Memory allocation in Ruby occurs on three levels, from top to bottom: <br><br><ol><li>  A Ruby interpreter that manages Ruby objects. <br></li><li>  Library of the operating system memory allocator. <br></li><li>  Core. </li></ol><br>  Let's go through each level. <br><br><a name="1_1"></a><h3>  Ruby </h3><br>  On its side, Ruby organizes objects in areas of memory called <i>Ruby heap pages</i> .  Such a heap page is divided into equal-sized slots, where one object occupies one slot.  Whether it is a string, a hash table, an array, a class, or something else, it occupies one slot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/155/0be/2d61550be208df42ad3052ca1f821807.png"></div><br><br>  Slots on the heap page can be busy or free.  When Ruby selects a new object, it immediately tries to occupy an empty slot.  If there are no free slots, a new heap page will be highlighted. <br><br>  The slot is small, about 40 bytes.  Obviously, some objects will not fit into it, for example, 1 MB lines each.  Then Ruby stores the information elsewhere outside the heap page, and places a pointer in this external memory area in the slot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e96/1c6/1e5e961c6c90ed1cd17daa8ab19d8212.png"></div><br>  <i><font color="gray">Data that does not fit in the slot is stored outside the heap page.</font></i>  <i><font color="gray">Ruby places a pointer to external data in the slot.</font></i> <br><br>  As pages of a heap of Ruby, and any external areas of storage are selected by means of the distributor of memory of system. <br><br><a name="1_2"></a><h3>  System memory allocator </h3><br>  The operating system memory allocator is part of glibc (runtime environment C).  It is used by almost all applications, not just Ruby.  It has a simple API: <br><br><ul><li>  Memory is allocated by calling <code>malloc(size)</code> .  You give it the number of bytes you want to allocate, and it returns either the allocation address or an error. </li><li>  The allocated memory is freed by calling <code>free(address)</code> . </li></ul><br>  Unlike Ruby, where slots of the same size are allocated, the memory allocator deals with requests for allocating memory of any size.  As you will learn later, this fact leads to some complications. <br><br>  In turn, the memory allocator accesses the kernel API.  It takes much larger chunks of memory from the kernel than its own subscribers request, since the kernel call is expensive and the kernel API has a restriction: it can allocate memory only in multiples of 4 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/dba/21a/323dba21a7b5ad2df8e1f9335d6b7c11.png"></div><br>  <i><font color="gray">The memory allocator allocates large chunks ‚Äî they are called system heaps ‚Äî and divides their contents to satisfy requests from applications.</font></i> <br><br>  The area of ‚Äã‚Äãmemory that the memory allocator allocates from the kernel is called the heap.  Note that it has nothing to do with the pages of the Ruby heap, so for clarity we will use the term <i>system heap</i> . <br><br>  Then the memory allocator assigns parts of the system heaps to its callers until there is free space.  In this case, the memory allocator allocates a new system heap from the kernel.  This is similar to how Ruby selects objects from Ruby heap pages. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/f81/c11/453f81c11aaadb818ecdcf798112db99.png"></div><br>  <i><font color="gray">Ruby allocates memory from a memory allocator, which, in turn, allocates it from the kernel</font></i> <br><br><a name="1_3"></a><h3>  Core </h3><br>  The kernel can allocate memory only for 4 KB units.  One such 4 KB block is called a page.  In order not to be confused with the pages of the Ruby heap, for clarity we will use the term <i>system page</i> (OS page). <br><br>  The reason is difficult to explain, but this is how all modern kernels work. <br><br>  Allocating memory through the kernel has a significant impact on performance, so memory allocators try to minimize the number of kernel calls. <br><br><a name="1_4"></a><h3>  Memory usage </h3><br>  Thus, memory is allocated at several levels, and each level allocates more memory than it really needs.  On the pages of a heap of Ruby there can be free slots, as in the system heaps.  Therefore, the answer to the question ‚ÄúHow much memory is used?‚Äù Fully depends on what level you ask! <br><br>  Tools like <code>top</code> or <code>ps</code> show the memory usage from the <b>kernel</b> point of view.  This means that the upper levels must work in concert to free up memory from the kernel's point of view.  As you learn further, it is more difficult than it seems. <br><br><a name="2"></a><h1>  What is fragmentation? </h1><br>  Fragmentation of memory means that memory allocations are randomly scattered.  This can cause interesting problems. <br><br><a name="2_1"></a><h3>  Ruby Fragmentation </h3><br>  Consider Ruby garbage collection.  Garbage collection for an object means marking the Ruby heap page slot as free, allowing it to be reused.  If the entire Ruby heap page consists only of free slots, then it can be completely reset back to the memory allocator (and, possibly, back to the core). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/cde/97d/27bcde97d27e6aeed3dc2020a4eda766.png"></div><br><br>  But what happens if not all slots are free?  What if we have a lot of Ruby heap pages, and the garbage collector frees objects in different places, so that ultimately there are a lot of free slots, but on different pages?  In such a situation, Ruby has free slots to accommodate objects, but the memory allocator and the kernel will continue to allocate memory! <br><br><a name="2_2"></a><h3>  Fragmentation at the memory allocator level </h3><br>  The memory allocator has a similar, but completely different problem.  He does not need to immediately release entire system heaps.  In theory, it can free up any single system page.  But since the memory allocator deals with allocations of memory of arbitrary size, there may be several allocations on the system page.  It cannot free up the system page until all selections are released. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76b/723/850/76b72385026fa24bd18b7db324d7353b.png"></div><br><br>  Think about what happens if we have a selection of 3 KB, as well as a selection of 2 KB, divided into two system pages.  If you release the first 3 KB, both system pages will remain partially occupied and cannot be released. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/cf1/70f/cc2cf170facbc6bca673014e33389606.png"></div><br><br>  Therefore, in the event of an unsuccessful set of circumstances, there will be a lot of free space on the system pages, but they are not completely free. <br><br>  Worse: what to do if there are a lot of empty seats, but none of them is large enough to satisfy a new selection request?  The memory allocator will have to allocate a completely new system heap. <br><br><a name="3"></a><h1>  Is the fragmentation of Ruby heap pages causing memory swelling? </h1><br>  It is likely that fragmentation causes excessive memory use in Ruby.  If so, which of the two fragmentation does more harm?  It‚Ä¶ <br><br><ol><li>  Fragmentation of Ruby Heap Pages?  Or <br></li><li>  Fragmentation of the memory allocator? </li></ol><br>  The first option is just enough to check.  Ruby provides two APIs: <code>ObjectSpace.memsize_of_all</code> and <code>GC.stat</code> .  With this information, you can calculate all the memory that Ruby received from the allocator. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/f7e/30e/cb8f7e30e363d2fa57f0fc37b84183fe.png"></div><br><br>  <code>ObjectSpace.memsize_of_all</code> returns the memory occupied by all active Ruby objects.  That is, all the space in their slots and any external data.  In the diagram above, this is the size of all blue and orange objects. <br><br>  <code>GC.stat</code> lets you know the size of all free slots, i.e. the entire gray area in the illustration above.  Here is the algorithm: <br><br><pre> <code class="cpp hljs">GC.stat[:heap_free_slots] * GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]</code> </pre> <br>  To summarize them, this is all the memory Ruby knows about, and it includes the fragmentation of the Ruby heap pages.  If, in terms of the kernel, memory usage is higher, then the remaining memory goes somewhere outside the control of Ruby, for example, to third-party libraries or fragmentation. <br><br>  I wrote a simple test program that creates a bunch of threads, each of which selects lines in a loop.  Here is the result after a while: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/859/2fc/a4e8592fc1d2edf2f11957844d33e55d.png"></div><br><br>  it's ... just ... madness! <br><br>  The result shows that Ruby has such a weak effect on the total amount of used memory that it does not matter whether Ruby heap pages are fragmented or not. <br><br>  We'll have to look for the culprit elsewhere.  At least we now know that Ruby is not to blame. <br><br><a name="4"></a><h1>  The study of fragmentation at the level of memory allocator </h1><br>  Another likely suspect is a memory allocator.  In the end, Neith Berkopek and Heroku noticed that fussing with the memory allocator (either a complete replacement with jemalloc, or setting the magic environment variable <code>MALLOC_ARENA_MAX=2</code> ) dramatically reduces memory usage. <br><br>  Let's first see what <code>MALLOC_ARENA_MAX=2</code> does and why it helps.  Then we investigate fragmentation at the distributor level. <br><br><a name="4_1"></a><h3>  Excessive memory allocation and glibc </h3><br>  The reason why <code>MALLOC_ARENA_MAX=2</code> helps is multithreading.  When several threads simultaneously try to allocate memory from the same system heap, they fight for access.  Only one thread at a time can receive memory, which reduces the performance of multi-threaded memory allocation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a40/99c/65b/a4099c65b73541efa05c38008fa0e181.png"></div><br>  <i><font color="gray">At any one time, only one thread can work with the system heap.</font></i>  <i><font color="gray">In multithreaded tasks, a conflict occurs and, consequently, performance decreases.</font></i> <br><br>  There is an optimization in the memory allocator for such a case.  He tries to create several system heaps and assign them to different threads.  Most of the time, the thread only works with its heap, avoiding conflicts with other threads. <br><br>  In fact, the maximum number of system heaps allocated in this way is, by default, equal to the number of virtual processors multiplied by 8. That is, in a dual-core system with two hyper-threads each, <code>2 * 2 * 8 = 32</code> system heaps are obtained!  This is what I call <b>over-allocation</b> . <br><br>  Why is the default multiplier so big?  Because the leading developer of the memory allocator is Red Hat.  Their clients are large companies with powerful servers and a ton of RAM.  The above optimization allows to increase the average performance of multithreading by 10% due to a significant increase in memory usage.  For Red Hat customers, this is a good compromise.  For most of the rest - it is unlikely. <br><br>  Nate in his blog and the Heroku article argue that increasing the number of system heaps increases fragmentation, and refers to official documentation.  The variable <code>MALLOC_ARENA_MAX</code> reduces the maximum number of system heaps allocated for multi-threading.  By this logic, it reduces fragmentation. <br><br><a name="4_2"></a><h3>  Visualization of system heaps </h3><br>  Is it true that Nate and Heroku claim that increasing the number of system heaps increases fragmentation?  In fact, is there any problem with fragmentation at the memory allocator level?  I didn‚Äôt want to take either of these assumptions for granted, so I began research. <br><br>  Unfortunately, there are no tools for visualizing system heaps, so <b>I wrote such a visualizer myself</b> . <br><br>  First, you need to somehow save the system heap distribution scheme.  I studied the <a href="https://github.com/bminor/glibc/tree/master/malloc">sources of the memory allocator</a> and looked at how it represents memory internally.  Then I wrote a library that iterates through these data structures and writes a schema to a file.  Finally, I wrote a tool that takes such a file as input and compiles the visualization as HTML and PNG images ( <a href="https://github.com/FooBarWidget/heap_dumper_visualizer">source code</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/adb/064/309adb06474b3ec49bb2d0d6622bbb48.png"></div><br><br>  Here is an example of the visualization of one particular system heap (there are many more).  The small blocks in this visualization represent the system pages. <br><br><ul><li>  Red areas - used memory cells. </li><li>  Gray - free areas not released back to the core. </li><li>  White areas are released for the core. </li></ul><br>  The following conclusions can be drawn from the visualization: <br><br><ol><li>  There is a certain fragmentation.  Red spots are scattered in memory, and some system pages are only half red. <br></li><li>  To my surprise, <i>most</i> system heaps contain a significant amount of completely free system pages (gray)! </li></ol><br>  And then it hit me: <br><br>  <i><b>Although fragmentation remains a problem, it's not about her!</b></i> <br><br>  Rather, the problem is in a large amount of gray: this memory allocator <i>does not give the memory back to the core</i> ! <br><br>  After re-examining the source code of the memory allocator, it turned out that by default it sends only system pages to the kernel at the end of the system heap, and even this <i>rarely</i> does.  Probably, this algorithm is implemented for performance reasons. <br><br><a name="5"></a><h1>  Magic trick: circumcision </h1><br>  Fortunately, I found one trick.  There is one software interface that will cause the memory allocator to free up for the kernel not only the last, but <i>all the</i> relevant system pages.  It is called <a href="http://man7.org/linux/man-pages/man3/malloc_trim.3.html">malloc_trim</a> . <br><br>  I knew about this function, but did not think that it was useful, because the manual says the following: <br><br><blockquote>  The malloc_trim () function attempts to free up free memory at the top of the heap. </blockquote><br>  <b>The manual is wrong!</b>  Analysis of the source code says that the program frees all relevant system pages, not just the top ones. <br><br>  What happens if you call this function during garbage collection?  I modified the source code of Ruby 2.6 to call <code>malloc_trim()</code> in the <code>gc_start</code> function from gc.c, for example: <br><br><pre> <code class="cpp hljs">gc_prof_timer_start(objspace); { gc_marks(objspace, do_full_mark); <span class="hljs-comment"><span class="hljs-comment">// BEGIN MODIFICATION if (do_full_mark) { malloc_trim(0); } // END MODIFICATION } gc_prof_timer_stop(objspace);</span></span></code> </pre> <br>  And here are the test results: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/cfc/063/1f4cfc063a1c0672a80ed11baec2c323.png"></div><br><br>  <b>What a big difference!</b>  A simple patch reduced memory consumption to almost the level of <code>MALLOC_ARENA_MAX=2</code> . <br><br>  Here is how it looks in the visualization: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/410/594/9de410594884baa131d3b8e52d7c6656.png"></div><br><br>  We see a lot of white areas that correspond to system pages released back to the core. <br><br><a name="6"></a><h1>  Conclusion </h1><br>  It turned out that the fragmentation, in the main, nothing to do with it.  Defragmentation is still useful, but the main problem is that the memory allocator does not like to free memory back to the core. <br><br>  Fortunately, the solution was very simple.  The main thing was to find the root cause. <br><br><a name="6_1"></a><h3>  Visualizer source code </h3><br>  <a href="https://github.com/FooBarWidget/heap_dumper_visualizer">Source</a> <br><br><a name="6_2"></a><h3>  What about performance? </h3><br>  Performance remained one of the main concerns.  The call to <code>malloc_trim()</code> cannot do for free, and according to the code the algorithm works in linear time.  So I turned to <a href="https://twitter.com/codefolio">Noah Gibbs</a> , who ran the benchmark Rails Ruby Bench.  To my surprise, the patch caused a slight <b>increase in</b> performance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/115/88c/7e511588c662a60e0f8a82556b2e1988.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/c8e/f91/474c8ef919bf360ecf45f365e1a87ab0.jpg"></div><br><br>  It blew my mind.  The effect is incomprehensible, but the news is good. <br><br><a name="6_3"></a><h3>  Need more tests </h3><br>  In this study, only a limited number of cases have been verified.  It is not known what the effect is on other workloads.  If you want to help with testing, please <a href="">contact me</a> . </div><p>Source: <a href="https://habr.com/ru/post/444482/">https://habr.com/ru/post/444482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444470/index.html">20 habits of attention hygiene: how to use technology, but do not allow them to select their time and attention</a></li>
<li><a href="../444472/index.html">Emulate Amazon web services in the JVM process. Avoiding Roskomnadzor and accelerate development and testing</a></li>
<li><a href="../444474/index.html">Construction of the Sakhalin - Kuril communication line. Excursion on the Segero - ship-laying layer</a></li>
<li><a href="../444476/index.html">Competition from RUSNANO: take an online course on modern microelectronics, then a practical tour with FPGA, get a prize</a></li>
<li><a href="../444480/index.html">How to reduce the weight of an element of aircraft design by a third</a></li>
<li><a href="../444486/index.html">The SIRIUS-19 project is a four-month imitation of an expedition to the moon in a ground complex in Moscow</a></li>
<li><a href="../444488/index.html">Matrix Powerwatch inside and out: what's new?</a></li>
<li><a href="../444494/index.html">La Moto Volante (Lazareth LMV 496) - flying transforming motorcycle</a></li>
<li><a href="../444496/index.html">New HTTPS Interception Detection Tools</a></li>
<li><a href="../444500/index.html">March 29, Moscow - Backend Stories 3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>