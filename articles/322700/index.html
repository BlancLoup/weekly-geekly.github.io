<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The hunt for the mythical MVC. User Interface Building</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Detective by IT materials. Part two 


 In this part, I will show how the user interface division initially looked like and what the View and Controll...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The hunt for the mythical MVC. User Interface Building</h1><div class="post__text post__text-html js-mediator-article"><h2 id="detektiv-po-materialam-it-chast-vtoraya">  Detective by IT materials.  Part two </h2><br><p>  In this part, I will show how the user interface division initially looked like and what the View and Controller were.  Let me try to tell you why modern GUI libraries use their union and what interesting solutions can be found in this area today.  References to the original sources are given at the beginning of the <a href="https://habrahabr.ru/post/321050/">first part</a> . </p><br><p>  I'll start with the view.  Despite the fact that the View is defined as a module that displays the Model - " <em>and the view is a (visual) representation of its model</em> ", in <strong>practice</strong> , all graphical GUI elements are usually referred to as a viewport; that is, the View what we <strong>see</strong> on the computer screen. </p><br><p>  It is clear that there is some contradiction here, since such graphic components as menus, buttons, toolbars are not used to display information about the system, but primarily to control the system.  The keyboard and mouse have always been the means of control of the program and were in the ‚Äúlist‚Äù of the Controller (no matter how it was interpreted).  Therefore, it seems illogical and strange that the buttons made of plastic are considered controls and belong to the Controller, and the buttons drawn on the screen, and in fact perform the same functions (produce incoming events), for some reason belong to the View. </p><br><p><img src="https://habrastorage.org/files/457/d0d/d26/457d0dd26f0947158968cabee4283fec.png" alt="View or Controller"></p><a name="habracut"></a><br><p>  In addition, since it is reasonably considered that it is not good to ‚Äúprescribe logic‚Äù in graphic elements, it is often concluded that the View should be thin and stupid (dumb View) and, accordingly, the logic of the interface can be found in the most unexpected places, up to the domain model (even Fowler writes about ‚Äúpollution‚Äù of the Model with the settings of the <a href="https://habrahabr.ru/post/53536/">GUI Architectures</a> interface). </p><br><p>  And again, in order to clarify the situation, we propose to turn to the "architectural principles" and primary sources.  When it comes to decomposition, one of the basic ‚Äúarchitectural‚Äù rules is that it is necessary to divide into modules primarily based on the <strong>tasks</strong> that the system solves.  Each module should be responsible for solving a specific task (preferably one) and perform the corresponding function. </p><br><p>  Accordingly, in order to understand how to divide the user interface into modules, first of all, it is necessary to analyze what it does and what tasks it solves.  After all, the interface is a <strong>function</strong> , not graphic elements.  And this function is to ensure user <strong>interaction</strong> with the system.  What does it mean: </p><br><ol><li>  <strong>display</strong> and conveniently display system information to the user </li><li>  <strong>enter</strong> user data and commands into the system (transfer them to the system) </li></ol><br><p>  That is, in the general case, the user interface is <strong>bidirectional</strong> and solves <strong>two</strong> problems, one of which is connected with the <strong>output</strong> and presentation of information, and the second with the <strong>input of</strong> commands and data.  It is these tasks that determine how to divide the interface into modules.  Again, look at the picture from the source (Reenskaug): </p><br><p><img src="https://habrastorage.org/files/3b4/81a/6e1/3b481a6e1e88416f943593d5a20ee4e4.png" alt="View Controller Separation"></p><br><p>  As you can see, the <strong>user interface is</strong> quite naturally and logically divided into two relatively independent <strong>functional</strong> modules.  Moreover, such a functional division based on solvable problems is universal.  No matter the sound is an interface, graphic or touch, it should have a module responsible for <strong>entering</strong> control commands and data (hence the name Controller - control), and the module responsible. <strong>Output</strong> and presentation of information about the system and what is happening in it (View - View, presentation). </p><br><p>  Now let's see how the View / Control division <strong>looked like</strong> in practice.  And in order to do this, we need a little excursion into history.  The fact is that initially the term <strong>CONTROLLER</strong> did not exist at all.  Instead, Reenskaug used the term <strong>EDITOR</strong> ( <strong>MODEL-VIEW-EDITOR)</strong> and wrote about the separation of the user interface into View and Editor.  " <em>This was the first set.</em> " (Trygve Reenskaug).  I'll try to explain why. </p><br><p>  In spite of the availability of technical capabilities (raster screens) during the creation of MVC and SmallTalk, user interfaces were still mostly command-based ( <em>Command-Based Interface</em> ) and were essentially ordinary text editors.  In SmallTalk, the interface was called Editor.  And that's how he looked: </p><br><p><img src="https://habrastorage.org/files/e8e/65f/800/e8e65f800a7647dcb85dfe36a6aa1735.png" alt="Smalltalk editor"></p><br><p>  We can say that the Editor combines the functions of the Controller and View.  He made it possible to relatively conveniently enter commands and data (displaying keystrokes and processing input from the keyboard), and at the same time output information about the execution of commands and what is happening in the system in general. </p><br><p>  Only gradually this Editor was transformed into what we are now used to understand by GUI. </p><br><p>  Initially, a simple but very fruitful idea arose - to divide a single window into multiple panels.  The multi-panel paradigm appeared much earlier than MVC (multi-panel browsers were definitely present in Smalltalk-76) and was a significant advance in itself.  It is still actively used in almost all text interfaces. </p><br><p> Reenskaug, of course, also used it.  It must be borne in mind here that Dynabook, around which smallTalk and graphical interfaces and, in particular, MVC, were created in Xerox Parc, was conceived as a ‚Äúchildren's computer‚Äù.  Therefore, the task was to make work with computer programs available to any unprepared user, in particular a child.  Reenskaug proceeded from the fact that the user may be completely unaware of the program and how it works.  And in order for it to interact with the program, it is necessary in some way to display to it the basic information about the system and the domain model underlying it, so that the user understands what he is dealing with. </p><br><p>  Such information was displayed on separate panels, which actually became the View.  As a rule, the domain model was displayed using several different Views: " <em>MVC was conceived as a general solution enabling users to control large and complex data sets ... It is especially useful when the user needs to see the Model simultaneously in different contexts and / or from different points of view.</em> "And since Reenskaug believed that the graphical presentation of information was clearer than the textual one, his main types were graphs and diagrams of various kinds. </p><br><p>  Further.  Since the user knows nothing (or almost nothing) about the system, and sees only various View, conveniently and visually displaying the information he needs, respectively, and the management of the system should have looked as if the user controlled directly the View and the fact that they are displayed.  Therefore, not one ‚ÄúGeneral Editor‚Äù was used to enter commands, but a whole multitude of specialized editors, each of whom was associated with his own View and was focused on entering commands (interacting with the domain model) only in the context of this View. <em>the information that is presented by the view</em> . </p><br><p>  Thus, if for the specialist the interface was usually served as a general editor, giving the opportunity to enter any commands into the system (but for this it was necessary to study the manuals, know the commands and understand how the system works), then for the unprepared user the minimum interface becomes a pair - View and the associated specialized Editor (which itself will later be renamed the Controller).  Such an interface provided a very reduced set of commands and capabilities, but they could be used without prior training. </p><br><p>  The first report of Reenskaug was called: "THING-MODEL-VIEW-EDITOR. An Example from a planning system".  It presented the first MVC implementation using the example of a large project planning and management system (a kind of task-manager).  The domain model was the network (network) of "activities", which described <em>what</em> should be done (activity), in what order, for what time, <em>who</em> participates in what activities and what resources are required for each activity.  An example was intended to show that ‚Äú <em>one Model can be displayed with the help of many different Views‚Äù</em> and this is how the user interface looked like: </p><br><p><img src="https://habrastorage.org/files/94f/595/fcb/94f595fcb6e74732a8bb7fe8357da110.png" alt="Reenskaug MVC"></p><br><p>  The domain model was displayed using three different diagrams (Views).  It should be noted that the views of both Reenskaug and SmallTalk were not at all ‚Äúpassive‚Äù, they independently processed the user's actions related to them, in particular, they allowed scrolling and selection of elements: ‚Äú <em>A list of textual items and a possible selection within the list.</em>  <em>It is able to make it to the scroll itself.</em>  ‚ÄúThis is an important moment and I will come back to it. </p><br><p>  The first diagram shows a set of activities related to a certain project / network and the connections between them.  Just as the list allows you to select / highlight a certain element, this diagram allows you to select an activity.  Associated with the diagram is an editor that allows you to query and edit information related to the selected activity from the system.  For example: the duration of the activity, who participates in it, what activities precede and TP </p><br><p>  The second chart - GanttView (Gantt‚Äôs calendar or timeline) shows the location of the project and its activities over time.  This chart also allows you to select an activity.  The editor associated with GanttView allows " <em>to pass on to operations on the network</em> ."  In particular, it allows you to change the planned start and end date of the selected activity, as well as plan and manage the project / network as a whole. </p><br><p>  The third diagram is a diagram of the resources required for the implementation of activities, depending on time.  It is curious that not the editor is associated with this diagram, but a list, and depending on what activity is selected in this list, the resource diagram displays only those resources that relate to the selected activity.  This combination of two types, one of which "controls" the displayed information of the other is characteristic of many interfaces.  And the idea to use for "control" is not a text editor, but the list will form the basis of most controllers in SmallTalk-80. </p><br><p>  The term <strong>Controller</strong> arose almost just before Reenskaug left Xerox PARC " <em>After long discussions, particularly with Adele Goldberg</em> ".  And because of this, the original works of Reenskaug can be difficult to read, since he calls the whole interface (and in this case, writes about the primary separation of the application into Model and Editor) and the editor panels that are associated with the same View to enter commands and ‚Äúcontrol View‚Äù and which later became the Controllers themselves - ‚Äú <em>The controller from Smalltalk-80 was called the <strong>Editor</strong></em> ‚Äù (Reenskaug) </p><br><p>  Also, the responsibilities of the Controller Reenskaug assigned management of the interface itself, and in particular the set of <em>its Views</em> : " <em>Controller was responsible for creating and coordinating its subordinate views</em> ."  Accordingly, he sometimes writes that the Controller is a connection between the user and the system, and sometimes it is a connection between the user and the Views and that the Controller transmits commands to the Views. </p><br><p>  Nevertheless, as can be seen from the example, the Reenskaugovsky Editor-Controller was quite visible and had a graphic representation. </p><br><p>  Let's see how things were in SmallTalk-80. </p><br><p>  <strong>First, in SmallTalk-80, the text editors that Reenskaug used to enter commands became ‚Äúofficially‚Äù Controllers.</strong> </p><br><p>  ‚Äú <em>ParagraphEditor</em> ‚Äù and ‚Äú <em>TextEditor</em> ‚Äù, which have standard text input and editing functions, in SmallTalk-80 were descendants of the ‚Äú <em>Controller</em> ‚Äù class: </p><br><p>  Since, as already mentioned, the editors combined the Input and Output functions, they were also used to <strong>display</strong> textual information in many Views - TextView, TextEditorView. </p><br><p>  Steve Barbeck gives a rather detailed explanation about this: " <em>All controllers that accept keyboard input are the ParagraphEditor inheritors in the Controller hierarchy. ParagraphEditor preceded the creation of the MVC paradigm. It simultaneously performs two functions - it processes text input from the keyboard and displays on the screen. Therefore, in a sense, it is a cross between a View and a Controller. Views that use the ParagraphEditor subclasses as a controller completely overturn standard roles - for</em>  <em>In order to display the text, they send it to their controller</em> "[ <em>All controllers that control the hierarchy.</em>  <em>ParagraphEditor predates paradigm.</em>  <em>It is a handful of ways to control the text.</em>  <em>Roles for display controller;</em>  <em>they implement the controller</em> ]. </p><br><p>  I will try to write further about the reason for such ‚Äúparadoxes‚Äù, for now just pay attention to it. </p><br><p>  <strong>Second: in SmallTalk-80, each Type (subspecies) MUST be associated with its own Controller, which made it possible to perform certain operations with the information that the View displays</strong> </p><br><p>  Accordingly, any set of Views (subspecies) that make up the user interface is in fact always accompanied by exactly the same set of Controllers associated with it.  Again, Steve Barbek has a whole section devoted to this topic, which is called ‚ÄúCommunication Between Controllers‚Äù. </p><br><p>  <strong>Third: the main improvement was that the mouse was used rather than the keyboard for entering commands.</strong> </p><br><p>  In SmallTalk-80, in addition to the controller editors ( <em>ParagraphEditor</em> and <em>TextEditor</em> ), <strong>MouseMenuController</strong> appears, which becomes the main tool for entering commands.  User interfaces from Command-driven become Menu-driven ( <a href="https://revisionworld.com/gcse-revision/ict/software/user-interfaces">User Interfaces</a> ) </p><br><p>  Available commands for each species were formed explicitly in the form of a list.  And MouseMenuController associated with the View provided for their display and convenient input a <strong>special graphical tool</strong> - <strong>pop-up pop-up menu</strong> , which appeared when you click the corresponding mouse button.  So they looked like this: </p><br><p><img src="https://habrastorage.org/files/f66/d7b/b37/f66d7bb3725f40b79befe4e252c86f56.png" alt="SmallTalk menu"></p><br><p>  I repeat: the pop-up menu belonged to MouseMenuController.  The menus were a special graphical tool / tool for conveniently displaying and entering commands (defined in the context of a certain type), which the Controller associated with this View provided to the user.  Here is what Krasner writes: " <em>Although the menu can be viewed as a pair of view-controller, but most often they are considered input devices and therefore belong to the controller sphere ... MouseMenuController class is responsible for creating pop-up menus when you click a mouse button ... By default, PopUpMenus returns numeric the value that the controller that called them uses to determine what action he needs to take ... Due to the extensive use of pop-up menus, most user interface controllers are under</em>  <em>MouseMenuController "lasso.</em> </p><br><p>  So the main controller SmallTalk-80 (MouseMenuController) also had its graphical part - the <em>pop-up menu</em> , and the separation of the user interface into Views and Controllers began to look like this (illustration taken from Glenn Krasner's article): </p><br><p><img src="https://habrastorage.org/files/251/bb4/5ec/251bb45ec3d04b2ba7e297d1057428ca.png" alt="SmallTalk View Controller Separation"></p><br><p>  The menu related to MouseMenuController can be seen absolutely in all SmallTalk applications and examples.  So with the expanded menus, the already mentioned Workspace and Inspector look like: </p><br><p><img src="https://habrastorage.org/files/40f/385/a60/40f385a603d040989be0b141cd242b49.png" alt="SmallTalk MVC"></p><br><p>  And this is what the Browser looks like, which includes 5 Views (subviews) and their corresponding Controllers </p><br><p><img src="https://habrastorage.org/files/87e/ed1/5c8/87eed15c8a8a471ebff24efba7f140b5.png" alt="SmallTalk MVC"></p><br><p>  I suppose that precisely because of the wide use of pop-up menus, Reenskaug wrote that the controller in smalltalk " <em>is an ephemeral component that View creates, if necessary, as a link between the View and input devices such as a mouse and keyboard</em> ". </p><br><p>  So, we can dispel another myth: </p><br><blockquote>  <strong>Myths: All graphical elements of the user interface belong to the View.</strong>  <strong>The controller is solely a logic for handling mouse movements, keyboard keys and other incoming events produced by the user.</strong> </blockquote><p>  In fact, both in the implementation of Reenskaug and then in Smalltalk-80 most of the Controllers had a ‚Äú <strong>graphic component helping the user to enter commands and data</strong> ‚Äù.  And it was these Controllers that were mainly used in user applications.  Although, of course, there were Controllers without a graphic component, but they were mainly used for lower-level system tasks (more on that later). </p><br><p>  Summing up, it turns out that the <strong>Controller</strong> is a <strong>part of the user interface</strong> that is responsible for 1) providing the user with <strong>convenient means for entering commands and data</strong> , and then 2) <strong>translating</strong> user actions into calls to the corresponding Model methods and <strong>transferring</strong> them to it. </p><br><p>  This is how the controller itself defined Reenskaug: " <em>The controller is the connection between the user and the system. It provides the user with a menu and other means to enter commands and data. The controller receives the result of such user actions, translates them into appropriate messages and sends these messages</em> " [ <em>A controller is the link between the user and the system.</em>  <em>It provides a means for users of</em>  <em>The controller receives these messages</em> .] </p><br><p>  Modern graphical interfaces (GUI) for entering commands use the whole range of available tools: text and graphic menus, buttons, pop-up pop-up menus, various switches (as in real devices), text fields for data entry (TextEditor reduced to TextField).  All these elements are mainly for management, not for displaying information.  In English, they are called - <strong>controls</strong> (controls). </p><br><p>  And if we continue the analogy, the separation of the View / Controller in modern systems would look something like this: </p><br><p><img src="https://habrastorage.org/files/1bc/c44/6a5/1bcc446a57ed4e94b0749c456d5a431b.png" alt="View controller"></p><br><p>  It can be said that the Controller is the ‚Äúcontrol panel‚Äù.  A View is a ‚Äúoverview panel‚Äù or ‚Äúsystem monitoring panel‚Äù that includes text descriptions, lists, tables, charts, scales, light displays, and all sorts of status indicators. </p><br><p>  The beauty of MVC is that its ideas are universal and applicable not only to information systems.  It does not matter whether the device or the program, <strong>in the simplest case, the</strong> interface, as a rule, contains a control unit / panel that allows you to enter commands ‚Äî the Controller, and a display unit ‚Äî View. </p><br><h2 id="realizaciya-vidov-i-kontrollerov">  Implementing Views and Controllers </h2><br><p>  What does this give us?  Well, firstly, it becomes clear that the logic of the View cannot be placed in the Controller: </p><br><p><img src="https://habrastorage.org/files/b97/cda/4b7/b97cda4b709e48f2aa05b086172fb8ce.png" alt="View controller"></p><br><p>  If all the logic of the GUI work were brought to the Controller, then this would violate several principles at once: </p><br><ul><li>  the main principle that determines the quality of decomposition is <em>High Cohesion + Low Coupling</em> , which says that it is necessary to cut into modules so that the connections, especially strong ones, remain mostly inside the modules, and not between them </li><li>  <em>Single responsibility principle</em> . </li></ul><br><p>  The second.  Thin View, considered solely as a set of graphic elements, does not perform any function and therefore is of little use in terms of re-use.  If we consider the View as a full-fledged functional module that solves a fairly general and popular task - visualization and convenient presentation of data, then with the right approach, it becomes an ideal candidate for re-use. </p><br><p>  In this sense, the separation of the user interface into View and Controller is a very beautiful step - the Controller has absorbed most of the dependencies.  The view from the Model needs only data to be displayed in a specific format.  Accordingly, potentially the same View can be used to visualize information in different applications. </p><br><p>  Recently, the concept of <strong>Dashboards</strong> (information panels) has been actively developed and used, for which sets of universal widgets are created, which allow visualizing and conveniently visualizing "anything."  In contrast to the "stupid look," such " <em>full-fledged blocks of visualization</em> " (encapsulating its own logic, settings and able to work independently) are very much in demand and valuable by themselves. </p><br><p><img src="https://habrastorage.org/files/a69/310/6c2/a693106c29ed4650bc71ef42d75613a1.png" alt="Dashboard"></p><br><p>  When the View and the Controller are treated as functional modules responsible for solving certain tasks, it becomes clear that in order to encapsulate their work logic, they do not need to mix it with graphics.  After all, any module, if necessary, can be divided into sub-modules and have its own internal structure. </p><br><p>  As we found out the main SmallTalk-80 controller - MouseMenuController was not at all ‚Äújust a handler of user actions with a mouse and keyboard‚Äù, in fact, he did quite a few things: </p><br><ol><li>  I asked the set and names of commands available to the user in the context of a certain View, </li><li>  Defined the logic of how to translate these commands into calls to the corresponding Model methods. </li><li>  Displays available commands </li><li>  I processed low-level mouse movements and created high-level events to which it is convenient to tie the execution of commands (Event Driven Approach). </li></ol><br><p><img src="https://habrastorage.org/files/4e5/12c/027/4e512c027f2643e188b9c98fb273e2cf.png" alt="SamllTalk Controller"></p><br><p>  For such Controllers, the MVC architecture simply ‚Äúasked‚Äù.  And in SmallTalk-80 it was used: " <em>pop-up menu are implemented as a special kind of MVC class</em> " (Krasner). </p><br><p>  Here it is important to understand that the Model in this ‚Äúinternal‚Äù MVC has nothing to do with the domain model, it is the internal auxiliary model that describes the ‚Äústate‚Äù of the controller itself (in particular, which command is selected) and the logic for changing this state. </p><br><p>  The situation is similar with the view. </p><br><blockquote>  <strong>Myths: The fact that View is just a ‚Äúgraphic‚Äù is the same idealization as the Controller is ‚Äúpurely logic‚Äù.</strong> </blockquote><p>  Visualization of information is not an easy task, for the solution of which, as a rule, additional data are required that characterize the very process of display.  Most species used in real-world applications are rather complex objects with their ‚Äústate‚Äù and the logic of its change. </p><br><p>  For example, a View rarely can display the entire Model as a whole, it usually reflects only some part of it and it needs to ‚Äúknow‚Äù which ‚Äúpart of the Model‚Äù should be reflected at the moment.  Many types allow you to "select" some elements, and then they need to store information about the secretions somewhere. </p><br><p>  Where was this kind of additional data stored and the logic of their change?  In principle, the answer is obvious and, if you remember, Reenskaug answered this question - of course, in the View itself.  But!  Not mixed with graphics, but in a separate sub-module / class / script, that is, in some <strong>internal model</strong> . </p><br><p>      ,      ,     .               ,    .  ,   ScrollController.          MVC.           ‚Äî   . </p><br><p><img src="https://habrastorage.org/files/8dc/dca/76c/8dcdca76c8584b218561f65456c92af7.png" alt="MVC View"></p><br><p>    ,     ‚Äî <a href="http://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> : <em>Presentation Model pulls the state and behavior of the view out into a model class that is part of the presentation</em> . </p><br><p> <strong>   !</strong>        ,   MVC  ¬´¬ª    -         .        " <em>Presentation Model is not a GUI friendly facade to a specific domain object</em> "   PresentationModel, ViewModel, ApplicationModel       ,      <strong></strong>   . </p><br><p>  ,    ,  ,   PresentationModel       .   Microsoft  : " <em>Presentation model class acts as a fa√ßade on the model with UI-specific state and behavior, by encapsulating the access to the model and providing a public interface that is easy to consume from the view</em> " ( <a href="https://msdn.microsoft.com/en-us/library/ff921080.aspx">MSDN: Presentation Model</a> ) </p><br><p>     <em>  </em> ,   ,       .     . </p><br><p>      Java     .  Java Swing ¬´application-data models¬ª  ¬´GUI-state models¬ª    . , ,     Java Swing     MVC.      ,  M          .     , ‚Ä¶ </p><br><p>      <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/JList.html">JList</a> .     ,      ‚Äì <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/ListModel.html">ListModel</a> .          ‚Äî <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/ListSelectionModel.html">ListSelectionModel</a> ,          (item selection).               ‚Äì ¬´GUI-state model¬ª: </p><br><p> " <em>The models provided by Swing fall into two general categories: GUI-state models and application-data models.</em> </p><br><p> <em>GUI state models are interfaces that define the visual status of a GUI control, such as whether a button is pressed or armed, or which items are selected in a list. GUI-state models typically are relevant only in the context of a graphical user interface (GUI).</em> </p><br><p> <em>An application-data model is an interface that represents some quantifiable data that has meaning primarily in the context of the application, such as the value of a cell in a table or the items displayed in a list. These data models provide a very powerful programming paradigm for Swing programs that need a clean separation between their application data/logic and their GUI</em> " (    <a href="http://www.eecs.yorku.ca/course_archive/2004-05/W/3461/FowlerArticle.pdf">A Swing Architecture Overview</a> ). </p><br><p>   <a href="http://docs.oracle.com/javase/7/docs/api/javax/swing/JTable.html%3Fis-external%3Dtrue">JTable</a>  application-data ,      ‚Äì <a href="http://docs.oracle.com/javase/7/docs/api/javax/swing/table/TableModel.html">TableModel</a> ,     GUI-state ‚Äî ListSelectionModel  <a href="http://docs.oracle.com/javase/7/docs/api/javax/swing/table/TableColumnModel.html">TableColumnModel</a> . </p><br><p>     <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/JButton.html">JButton</a>   GUI-state  ‚Äì <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/ButtonModel.html">ButtonModel</a> .     .     ,        ,     (/ ). </p><br><p>     ,  ,     application-data ,         .  GUI-state     ,       .             GUI-state . </p><br><p><img src="https://habrastorage.org/files/dc5/6fd/873/dc56fd8734aa4118ae744044a9773b8d.png" alt="MVC JavaSwing GUI-state models"></p><br><p> ,          GUI   data.    ,        .        . </p><br><p>        ,         (  ).              ( SmallTalk     ‚Äî ScrollController)     .       GUI-state               ,      ,    ,      / . </p><br><p>    <strong></strong>    ,          :      ¬´On¬ª,      ,  - ‚Ä¶         ¬´On¬ª.   -   " ", . </p><br><p>                .       ButtonModel,    isSelected()       ,         (  ).      ,  ButtonModel    GUI-state   application-data </p><br><p>              ,    : </p><br><p><img src="https://habrastorage.org/files/3c7/764/ed8/3c7764ed889e4bde850c6871d7b4db7b.png" alt="MVC PresentationModel"></p><br><p>     .                   PresentationModel    "".      .    (2),       ui-,            ui-state .      (1),                 PresentationModel.   PresentationModel  ApplicationModel        .     ‚Ä¶          ,            .      ,        (, -    ?).  ,    GUI-state  ,      . </p><br><h2 id="obedinennyy-vidkontroller-uproschennyy-mvc">  . ¬´ MVC¬ª </h2><br><p>     Java Swing,          ‚Äì    SmallTalk-80     pop-up       MVC (  ,     ) Swing    gui   ¬´ MVC¬ª,         ,        .     :  <em>ViewController</em>  <em>UI-object</em> , <em>IU-delegate</em> .    ,    : <a href="http://www.javaworld.com/article/2076632/core-java/mvc-meets-swing.html">MVC meets Swing</a> . </p><br><p><img src="https://habrastorage.org/files/860/929/151/8609291517e7408cae14be9dc0461819.png" alt="MVC"></p><br><p>       ,   ¬´ MVC¬ª -    GUI       SmallTalk-80: VisualAge Smalltalk  IBM, Visual SmallTalk, VisualWorks SmallTalk, MacApp‚Ä¶ ( <a href="https://books.google.es/books%3Fid%3DW8_Une9cbbgC%26pg%3DPA124%26lpg%3DPA124%26dq%3Dsmalltalk%2Bmvc%26source%3Dbl%26ots%3DoQrY1q7oDa%26sig%3DRkeymilwgxn99K8ZJRCl4s-lqbQ%26hl%3Dru%26sa%3DX%26redir_esc%3Dy">Smalltalk, Objects, and Design</a>  124-125). </p><br><p>    MVC,      ,    ,   SmallTalk-80   .  Why?       . </p><br><p>   SmallTalk-80           <strong>  </strong> .                  .      ,                   ¬´¬ª.            . </p><br><p>  ,        ,  ¬´  ¬ª               . </p><br><p>       ,                 .      ui-,    Swing: " <em>this split didn't work well in practical terms because the view and controller parts of a component required a tight coupling (for example, it was very difficult to write a generic controller that didn't know specifics about the view)</em> ". </p><br><p>      SmallTalk-80      <strong>  </strong> :      ,    .  ,          : " <em>       ,        ,   ,       ‚Äì defaultControllerClass.              </em> " [ <em>Because view and controller classes are often designed in consort, a view's controller is often simply initialized to an instance of the corresponding controller class. To support this, the message defaultControllerClass, that returns the class of the appropriate controller, is defined in many of the subclasses of View</em> ‚Äì Glenn Krasner ]. </p><br><p>    ?         ,    "        ".        ,   SmallTalk-80           ,   .  -   ( )   ,   ,     popup menu,      . </p><br><p>    : " <em>         ;          ¬´aMessage¬ª    aMessage        ,     ¬´aMessage¬ª.</em> " [ <em>Finally, the controller messages were almost always passed directly on to the model; that is, the method for message aMessage, which was sent to the controller when the menu item aMessage was selected, was almost always implemented as ‚Üëmodel aMessage</em> ]. </p><br><p>           ,     ¬´¬ª     .           ,   pop-up ,        ,    . </p><br><p>    ,      : - ‚Äì   ,        ‚Äì  -,    GUI ‚Äì  ui-state .              ( ,   )              . </p><br><p>      ,    GUI      smallTalk-80    ui-     .         : pop-up    ,   TextEdit   . </p><br><p>         ¬´ui-¬ª  ¬´¬ª,    ,    ‚Äì         ,      .             . </p><br><p>   ,   ui-    ParagraphEditor,      ‚Äì         ,       .  <strong></strong>    , ,   (toggle button, radio button, check box)   ... </p><br><p><img src="https://habrastorage.org/files/4bc/b46/d69/4bcb46d6989b46c5a8cd109d333c92fc.jpg" alt="MVC"></p><br><p>         .      ()                  <strong></strong>     . ,      ,    (popUpMenu),         ‚Äì   (ListView).  ‚Äî  . </p><br><p>        : " <em>,        <strong></strong> ,    </em> " ( <em>Model, View and Controller are actually roles that can be played by the objects</em> ‚Ä¶ ‚Äì <a href="http://www.artima.com/articles/dci_vision.html">The DCI Architecture: A New Vision of Object-Oriented Programming</a> <em>)</em> . </p><br><p> ,   SmallTalk-80 <strong> </strong>    ,   ,    ,      ,  TextView      . </p><br><p>       ?    . ,      "    "      .         (  ) <strong></strong>  .     ,    ,  pop-up ,          ¬´  ¬ª.  gui-      ‚Äî , ,    , ‚Ä¶       ‚Äì    ,   ¬´ ¬ª /      ,   .         ui-      . </p><br><h2 id="interfeys-kak-composite">  Interface as Composite </h2><br><p>  Another important idea that has definitely remained is the understanding that the interface should be divided into modules, and not into a single block or page. </p><br><p>  As can be seen from the examples, most of the interfaces were composite and included many Views and Controllers. </p><br><p>  For the designation of such difficult-to-composite Interfaces, Reenskaug in his second later work uses the special term ‚ÄúTool‚Äù (user tool) and he has a separate section devoted to this topic, which is called ‚Äú <strong>Tool as a Composite</strong> ‚Äù. </p><br><p><img src="https://habrastorage.org/files/f17/9a4/842/f179a4842aa749de9898f6c3d17f265c.png" alt="Reenskaug MVC"></p><br><p>  In the figure, the Tool already shows the interface from the first Reenskaug report consisting of three blocks (which Reenskaug calls the Editor).  And this is what Reenskaug writes about this: </p><br><ul><li>  <em>This is a model for the mental model.</em> </li><li>  <em>If applicable.</em> </li><li>  <em>A tool that sets up their operation.</em>  <em>(Eg, there are several editors).</em> </li></ul><br><p>  <em>Complex editors can be again subdivided into a Controller. This is a composite pattern.</em> </p><br><p>  As you can see, the <em>Composite</em> pattern for Reenskaug refers to the entire interface, and not to the View at all.  Where did the idea come from that the <em>Composite</em> in MVC refers exclusively to the View? </p><br><p>  Everything is simple - because in SmallTalk-80 each Kind had its own Controller, then the composition there was <strong>explicitly</strong> specified for Species only, and the corresponding composition (hierarchy) of the Controllers was simply ‚Äúcalculated‚Äù: " <em>Since each view is associated with a unique controller, the tree view of the tree with each controller</em> . "  This decision was not particularly successful and led to the fragility of the system - it was enough to leave some Species without a Controller and the whole system collapsed.  Therefore, in SmallTalk-80 a ‚Äúcrutch‚Äù was invented - the Controller, which was called ‚ÄúNoController‚Äù.  This controller did nothing and, by default, contacted Views that ‚Äúexclusively displayed information‚Äù and did not need a controller.  Its sole purpose was to ensure that the chain of controllers corresponding to the species was not interrupted.  (You can read in detail with Steve Barbek in the section ‚ÄúCommunication Between Controllers‚Äù). </p><br><p>  So in reality, both in SmallTalk-80 and in Reenskaug, the user interface always included not only the composition of Views, but also the exact composition of the corresponding Controllers. </p><br><p>  And if we talk about the <em>Composite</em> template, then, of course, it is more correct to refer it not to the View but to the entire user interface, as is done in Reenskaug and how it is done in modern GUI libraries.  The interfaces of large applications are divided into "gui-components" or widgets, which in turn can be divided into simpler components and form a tree structure. </p><br><p>  Each such gui-component is a stand-alone module that simultaneously displays some information and processes the user's actions related to it, causing high-level events to which it is convenient to bind the execution of commands (View + Controller).  He also encapsulates his work logic, usually in the form of an internal GUI-state model.  That is, in essence, is MVC (or "simplified MVC").  And such full-fledged gui-components can really be developed in parallel and independently, and also reused. </p><br><p>  The consequence of the <em>Composite</em> pattern and the fact that each gui component can be implemented as a small MVC is some <strong>hierarchy</strong> or <strong>recursiveness of</strong> MVC.  Due to the fact that they rarely write about it, the analogs of this idea are also being rediscovered.  Here is a famous article on this topic - the <a href="http://www.javaworld.com/article/2076128/design-patterns/hmvc--the-layered-pattern-for-developing-strong-client-tiers.html%3Fpage%3D2">Hierarchical model ‚Äì view ‚Äì controller</a> and an interesting discussion - the <a href="http://c2.com/cgi/wiki%3FRecursiveModelViewController">Recursive Model View Controller</a> .  And here is a picture from the article: </p><br><p><img src="https://habrastorage.org/files/27a/745/695/27a7456952f64302afb70197c9fd4cf0.gif" alt="Hierarchical model ‚Äì view ‚Äì controller"></p><br><p>  In practice, building interfaces from independent and fully-fledged ui-components actively uses and develops ebay.  You can read about this in detail in their great article <a href="http://www.ebaytechblog.com/2014/10/02/dont-build-pages-build-modules/">Don't Build Pages, Build Modules</a> : " <em>When it comes to view, people still think pages instead of building UI modules. We found that as the complexity of the pages grows, it becomes exponentially more difficult to maintain. What we we want to divide the page into small manageable parts, each of which can be developed independently. We want to get away from the idea of ‚Äã‚Äãbuilding pages directly. Instead, we divide the page into logical UI modules and do it recursively until the module</em>  <em>It will not be <a href="http://addyosmani.com/first/">in FIRST</a> . This means that the page is constructed from high-level modules that are built from sub-modules "in turn.</em> </p><br><p><img src="https://habrastorage.org/files/23b/c9c/e6d/23bc9ce6d9014255a5b86fe76cf7aacf.png" alt="MVC"></p><br><h2 id="summiruya">  Summing up </h2><br><p>  I don‚Äôt want to say that the original MVC is the only correct one.  My goal was only to show that it was much more complicated and richer than the simplified schema, which we are usually presented as MVC.  Creating real applications based on them is like building an airplane based on schemes from a children's designer and it‚Äôs surprising that it doesn‚Äôt fly.  On the other hand, if we consider MVC not as a scheme, but first of all, as a set of architectural ideas, then it really becomes simple, logical and very understandable, and literally deduced from these ideas. </p><br><p>  And when there is an understanding of exactly what is being done, with the help of what ‚Äútools‚Äù, for the sake of which, then MVC ceases to be ‚Äúdogma‚Äù and it can be varied depending on the needs of a particular project.  And the terms are not so important. </p><br><p>  When I hear or read about the front controller or that "the controller is a single point of entry into the system," I understand that the term Controller in these guys is called the facade.  And this does not mean that their architecture is wrong.  On the contrary, at least it‚Äôs good that they have a Facade in general, but then you need to look at how it is implemented, whether the implementation of the business of logic and so on does not delay </p><br><p>  When it is said that the Controller is a business logic, then it is not terrible ... Just accept that in this case the Domain Model is called the Controller.  What is important is not how it is called, but how it is implemented and whether it is separated from the user interface. </p><br><p>  The term View is often used interchangeably with the term User Interface.  So, too, "can." </p><br><p>  The point is not in terms, but in essence.  It seems to me that the root of most problems lies in the fact that very few people write about the essence of MVC.  Instead, the terms Model, View and Controller are taken out of the context of architectural ideas, they are given some formal definitions, and then they are often used to denote modules in poor-quality decomposition, the <em>Observer</em> pattern is hung, and all this is presented under the ‚ÄúMVC brand‚Äù. </p><br><p>  As Wirth wrote: " <em>The most difficult project task is to find the most adequate system decomposition into hierarchically built modules, with minimization of functions and code duplication</em> ." </p><br><p>  Therefore, the main idea that I wanted to convey, is that MVC is not about Model, View and Controller, not about how they are interconnected and not about the <em>Observer</em> pattern.  MVC is about how to correctly divide the system into functionally meaningful modules that are loosely connected with each other and useful in their own right.  Modules that can actually be developed and used independently can be reused ... Which is actually the basis of any good architecture. </p><br><p>  A Model, View and Controller is just the result of the <strong>initial decomposition</strong> offered by talented people.  Also, the <em>Facade</em> , <em>Observer, Linker</em> patterns are simply the tools that they used to ease connectivity and reduce complexity. </p><br><p>  Thanks to everyone who ‚Äúreached out‚Äù to the end.  We will be very grateful for valid criticism.  Especially interesting is the opinion of people closely acquainted with SmallTalk. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322700/">https://habr.com/ru/post/322700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322688/index.html">Automation on the methodology of BDD. Our experience of successful implementation</a></li>
<li><a href="../322690/index.html">Why can't I send UDP packets through a browser?</a></li>
<li><a href="../322692/index.html">How to understand who you are: Junior, Middle or Senior?</a></li>
<li><a href="../322694/index.html">How a two-year repository on GitHub has become a trend in 48 hours</a></li>
<li><a href="../322696/index.html">EMC DPO: How to protect your products from fakes</a></li>
<li><a href="../322702/index.html">Mechanical Shakespeare: Are machines capable of literary creativity?</a></li>
<li><a href="../322704/index.html">Puzzle game Neo Angle. Work with levels in Unity</a></li>
<li><a href="../322706/index.html">Social bots: who, how and why use bots?</a></li>
<li><a href="../322708/index.html">Data Science Weekend March 3-4</a></li>
<li><a href="../322710/index.html">Primitives for implementing 1-Wire master using PWM and ICP on AVR AtMega microcontrollers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>