<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of the stack, queue and soundboard in the F # language in a functional style</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I recently got acquainted with the concept of functional programming. Perhaps in this article I reinvent the wheel, but I believe that these actions a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of the stack, queue and soundboard in the F # language in a functional style</h1><div class="post__text post__text-html js-mediator-article">  I recently got acquainted with the concept of functional programming.  Perhaps in this article I reinvent the wheel, but I believe that these actions are very useful for learning, as well as for a clearer understanding of functional programming. <br><br>  Let's try to implement the basic data types: the stack, the queue, and the decks ‚Äî in F #, using pure functions whenever possible.  Naturally, they will be based on lists. <br><br>  First of all, it is necessary to define the pure function.  The simplest definition is: a <b>function is called pure if it is deterministic and has no side effects.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The determinism of a function means that it produces the same result for the same set of arguments. <br>  Side effects of functions are changing global variables, exception handling, I / O operations, and so on. <br><br><h4>  Stack </h4><br>  First of all, let's start with the stack.  In F #, the main data type for storing several elements of the same type is not an array, but a list.  If we are faced with the task of turning the list into a stack, what functions will we need? <br><br>  First, we need a function to add an item to the top of the stack.  This function is traditionally called push.  However, this function does not particularly interest us, since it is very simply implemented: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> push stk el = el :: stk</code> </pre> <br><br>  A fairly simple function that has the type <b>'a list -&gt;' a -&gt; 'a list</b> , but not all further functions will allow you to treat yourself in such a simple way. <br><br>  Much more interesting is the case of pushing the top of the stack, especially if we limit ourselves to pure functions.  How do we cope with this task? <br><br><a name="habracut"></a><br>  To do this, it‚Äôs enough to remember that when defining the pop function, there were always two approaches: either an object was pushed out of the top of the stack and simultaneously removed from it, or a method was first called to get the value of the top, and then a method to remove the top. <br><br>  The first approach cannot be performed in a functional style, since this is a clear example of a function with a side effect: the stack value is returned as a result of the function, and its removal is a side effect. <br>  Moreover, using the first approach, we also lose the determinism of the function: applying it to the same stack instance will give us a different result. <br><br>  So let's stop on the second approach.  To do this, we write two functions: head, which will return a value at the top of the stack, and pop, which will return a list that has no vertex. <br><br>  We will deal with the first.  What do we need to return?  There are two possible options: the stack is empty or the stack is not empty.  If the stack is not empty, then everything is clear: we derive the element from the vertex.  And if the stack is empty?  After all, instead of conditional statements in F #, pattern matching is used.  We have a limitation that when using different templates, data of the same type must be returned.  Come to the aid of so-called.  <b>optional types</b> that take values <b>Some (x)</b> or <b>None</b> . <br><br>  Now we can write a function: <br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head stk = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> stk with |[] -&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> |hd :: _ -&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hd)</code> </pre><br><br>  If we look at the type of the head function, we will see that it is of the type <b>'a list -&gt;' a option</b> , that is, it takes a list as a parameter and returns a value of an optional type. <br>  The function works as follows: accepting the stk list, it looks at its value.  If it is empty, that is, stk = [], then it returns None, which corresponds to the fact that this list has no vertex, if not empty, it separates the first element of the list from the rest and returns it in the form of an optional type.  The underscore in pattern matching means that it does not matter what should be in this place. <br>  At the same time, our function is pure: determinism is present, there are no side effects. <br><br>  Looking at this function, now we can easily write the pop function, which will be somewhat symmetrical, but will not need an optional type, since the role None will execute an empty list: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pop stk = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> stk with |[] -&gt; [] |_:: tl -&gt; tl</code> </pre><br><br>  This function has the type: <b>'a list -&gt;' a list</b> <br><br>  Thus, the following code gives us all the functions for working with the stack. <br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> push stk el = el :: stk <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head stk = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> stk with |[] -&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> |hd :: _ -&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hd) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pop stk = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> stk with |[] -&gt; [] |_ :: tl -&gt; tl</code> </pre><br><br><h4>  Turn </h4><br>  The queue differs from the stack in that the addition of a new element occurs at the end of the list, and the extraction occurs from the beginning of the queue.  We implement the functions add (add an item to the queue), head (who is currently in the queue) and delque (remove the item from the queue).  And if the head and delque functions are beyond doubt, then an attempt to write <b>let head = que :: el</b> will lead to a compilation error, since the operator :: has the type <b>'a -&gt;' a list -&gt; 'a list</b> , i.e., the left operand can not be a list. <br><br>  The problem is solved again using pattern matching, but now we use recursive functions in order to get to the end.  If the queue is empty, then it doesn‚Äôt matter to add from the end or from the beginning, since there are none, so add to the beginning, which will be the end at the same time.  If the list is not empty, then we divide it into the first element and all the others, and apply our function recursively to the remaining elements of the list. <br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec add que el = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> que with |[] -&gt; el :: [] |hd :: tl -&gt; hd :: (add tl el)</code> </pre><br><br>  Thus, the full set of functions for the queue has the form: <br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec add que el = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> que with |[] -&gt; el :: [] |hd :: tl -&gt; hd :: (add tl el) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head que = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> que with |[] -&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> |hd :: _ -&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hd) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delque que = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> que with |[] -&gt; [] |_ :: tl -&gt; tl</code> </pre><br><br><h4>  Dec </h4><br>  The most interesting data structure is the decks, or the bidirectional queue, i.e. the addition and deletion of elements can occur both from the beginning and from the end.  By analogy with the functions head and pop for the stack, we introduce the functions tail and delend for the deck.  Here the implementation will be more interesting.  We need the last element, but in functional programming there are no cycles.  How should we be?  Once again, recursion comes to the rescue, but it is too early to rejoice. <br>  If we write completely by analogy: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec tail deq = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> deq with |[] -&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> |_ :: tl -&gt; tail tl</code> </pre><br><br>  then we will successfully get None <b>for any argument</b> .  This is due to the fact that <b>any list</b> in F # is represented as <b>a = a :: []</b> , i.e., if we unwind the tangle of the list in succession, then in the end we will have nothing left. <br>  This problem is solved by adding just one condition, if we recall that the operator :: has the type <b>'a -&gt;' a list -&gt; 'a list</b> , i.e., the operand to the left of :: must have the type of the list element, and not be the list itself, so change the code as follows: <br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec tail deq = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> deq with |[] -&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> |hd :: [] -&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hd) |_ :: tl -&gt; tail tl</code> </pre><br><br>  The modified function will now work correctly, since the recursion will end on the last element of the deck and return it safely. <br><br>  We figured it out, but what do we do with the delend function?  We need to replace the last item in the list, but how to do it?  Let's recall that the operator :: returns a list and is associative to the right, which allows us to consider the following code: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec delend deq = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> deq with |[] -&gt; [] |hd1 :: hd2 :: [] -&gt; hd1 :: [] |hd :: tl -&gt; hd :: (delend tl)</code> </pre><br><br>  Here it is, our desired code.  Thanks to the operator :: on the right side, we will not lose the beginning of the list, and the recursion will end on the penultimate element of the list, creating a new list without the former last element. <br><br>  Thus, for the deck, we get the following set of functions: <br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addbegin deq el = el :: deq <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec addend deq el = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> deq with |[] -&gt; el :: [] |hd :: tl -&gt; hd :: (addend tl el) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head deq = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> deq with |[] -&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> |hd :: _ -&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hd) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delbegin deq = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> deq with |[] -&gt; [] |_ :: tl -&gt; tl <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec tail deq = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> deq with |[] -&gt; <span class="hljs-literal"><span class="hljs-literal">None</span></span> |hd :: [] -&gt; <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hd) |_ :: tl -&gt; tail tl <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rec delend deq = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> deq with |[] -&gt; [] |hd1 :: hd2 :: [] -&gt; hd1 :: [] |hd :: tl -&gt; hd :: (delend tl)</code> </pre><br><br>  Thanks for attention!  Any code written in this article can be tested in any environment that allows programming under F # </div><p>Source: <a href="https://habr.com/ru/post/236375/">https://habr.com/ru/post/236375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../236365/index.html">How I chose a hedgehog copywriter - and how much it costs to write trash and burn</a></li>
<li><a href="../236367/index.html">Not just gadgets: Apple iAd ad network</a></li>
<li><a href="../236369/index.html">Analyzing the cloud contact center: where to start</a></li>
<li><a href="../236371/index.html">Entity Framework and Rule Names</a></li>
<li><a href="../236373/index.html">Google Chrome: Sunset for SHA-1</a></li>
<li><a href="../236377/index.html">Introducing the updated Webmaster Tools API</a></li>
<li><a href="../236379/index.html">Fighting sms at the wheel</a></li>
<li><a href="../236383/index.html">Equation or all the same observation?</a></li>
<li><a href="../236387/index.html">Tabnabbing: extravagant phishing</a></li>
<li><a href="../236389/index.html">When did it all start?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>