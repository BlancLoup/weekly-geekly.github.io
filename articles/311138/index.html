<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating Babylon.js and WebGL based shaders: theory and examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="During their report on the second day of the Build 2014 conference, Microsoft evangelists Steven Guggenheimer and John Shevchuk spoke about the implem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating Babylon.js and WebGL based shaders: theory and examples</h1><div class="post__text post__text-html js-mediator-article">  During their <a href="http://channel9.msdn.com/Events/Build/2014/KEY02">report on the second day of the Build 2014 conference,</a> Microsoft evangelists Steven Guggenheimer and John Shevchuk spoke about the implementation of Babylon.js support for Oculus Rift.  One of the key points of their demonstration was the mention of the lens imitation technology developed by us: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/31b/106/310/31b1063103bd4b229f3c121a5543fc98.jpg"></div><br>  I also attended the report by Frank Olivier and Ben Constable on the use of <a href="http://channel9.msdn.com/Events/Build/2014/3-558">graphics in IE using Babylon.js.</a> <br><br>  These reports reminded me of one question that I was often asked about Babylon.js: ‚ÄúWhat do you mean by shaders?‚Äù I decided to devote a whole article to this question to explain the principle of shaders and give some examples of their basic types. <a name="habracut"></a><br>  This translation is part of a series of articles for developers from Microsoft. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Theory </h1><br>  Before we begin our experiences, we need to understand how everything functions. <br><br>  Working with hardware accelerated 3D graphics, we are dealing with two different processors: the central (CPU) and the graphics (GPU).  A graphics processor is just a form of highly specialized CPU. <br><br>  A GPU is a state machine tuned by a CPU.  For example, it is the CPU that instructs the GPU to display lines instead of triangles, turn on transparency, and so on. <br><br>  Once all the states have been configured, the CPU will determine what needs to be rendered based on two main components: geometry, which is calculated based on a list of points or vertices (stored in an array called vertex buffer), and a list of indices ‚Äî faces or triangles that are stored in the index buffer. <br><br>  Finally, the CPU will determine how to render the geometry, and specifically for this will set the shaders for the GPU.  Shaders are a piece of code executed by the GPU for all vertices and pixels that need to be rendered. <br><br>  A vertex is a kind of point in 3D space (as opposed to a point in 2D space). <br><br>  There are 2 types of shaders: vertex and pixel (fragment) shaders. <br><br>  <b>Graphic pipeline</b> <br><br>  Before going directly to the shaders, we will make another small digression.  To display pixels, the GPU receives geometry data from the CPU. <br><br>  With the help of an index buffer containing a list of vertex indices, 3 vertices are combined into a triangle.  Each entry in the index buffer corresponds to the vertex number in the vertex buffer (this avoids duplicate vertices). <br><br>  For example, the index buffer in the example below is a list of two faces: [1 2 3 1 3 4].  The first face contains vertices 1, 2, and 3. The second face contains vertices 1, 3, and 4. Thus, in this case, the geometry consists of four vertices: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/676/1ac/162/6761ac162a1e428c9e5dc4c21519648b.png"></div><br><blockquote>  Vertex - Top <br>  Vertex Buffer - Vertex Buffer <br>  Index Bufer - Index Buffer <br>  Face - Edge </blockquote><br>  The vertex shader is executed at each vertex of the triangle.  The main purpose of the vertex shader is to display a pixel for each vertex (that is, to perform a projection of the 3D vertex on a 2D screen). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8ef/db8/27a/8efdb827a2394d668717b250ec50a3b5.png"></div><br>  Using these 3 pixels (defining parameters of a 2D triangle on the screen), the GPU will analyze all pixel-related values ‚Äã‚Äã(at least its position) and apply a pixel shader to generate a color for each pixel of the triangle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3bb/fac/ee0/3bbfacee00a9433ea2d7c2c29e8b5b6c.png"></div><br>  The same is done for all faces in the index buffer. <br><br>  The GPU is very efficient when performing parallel processes and therefore can easily process multiple faces simultaneously, while achieving high performance. <br><br>  <b>GLSL</b> <br><br>  As mentioned earlier, for rendering triangles the GPU will need 2 shaders: vertex and pixel.  Both are written in a special language called GLSL (Graphics Library Shader Language), which is a bit like C. <br><br>  Especially for Internet Explorer 11, we developed a compiler that converts GLSL to HLSL (High Level Shader Language) - the shader language of DirectX 11. This allowed us to increase the security of the shader code: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8bf/7cf/d3f/8bf7cfd3f32f4608b6e7d5ac433783aa.png"></div><br>  Here is an example of a simple vertex shader: <br><br><pre><code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Attributes attribute vec3 position; attribute vec2 uv; // Uniforms uniform mat4 worldViewProjection; // Varying varying vec2 vUV; void main(void) { gl_Position = worldViewProjection * vec4(position, 1.0); vUV = uv; }</span></span></code> </pre> <br><br>  <b>Vertex Shader Structure</b> <br><br>  The vertex shader contains the following elements: <br><br><ul><li>  <b>Attributes</b> : The attribute defines a portion of a vertex.  By default, a vertex must have at least position data (vector3: x, y, z).  But you, as a developer, can provide more data.  For example, in the code above there is a vector2 called uv (texture coordinates, allowing us to apply a 2D texture to a 3D object). <br><br></li><li>  <b>Uniform Variables:</b> Determined by the CPU and used by the shader.  The only uniform variable that we have in this case is the matrix used to project the position of the vertex (x, y, z) on the screen (x, y). <br><br></li><li>  <b>Varying variables:</b> These are the values ‚Äã‚Äãthat are created by the vertex shader and are passed to the pixel shader.  In our case, the vertex shader will transfer the vUV value (a simple copy of uv) to the pixel shader.  Consequently, texture coordinates and pixel position are determined here.  The GPU will add these values, and the pixel shader will use them directly. <br><br></li><li>  <b>main:</b> The main () function is the code that runs in the GPU for each vertex.  It should at least give a value for gl_position (the position of the current vertex on the screen). </li></ul><br>  As can be seen from the example above, there is nothing complicated in the vertex shader.  It generates a system variable (starts with gl_) called gl_position to determine the position of a particular pixel, and also sets a varying variable called vUV. <br><br>  <b>Magic at the heart of matrices</b> <br><br>  The matrix in our shader is called worldViewProjection.  It projects the position of the vertex into the gl_position variable.  But how do we get the value of this matrix?  Since this is a uniform variable, we need to define it on the CPU side (using JavaScript). <br><br>  This is a difficult to understand aspect of working with 3D graphics.  You need a good understanding of complex mathematical calculations (or use a 3D engine like Babylon.js, which we will talk about later). <br><br>  The worldViewProjection matrix consists of three separate matrices: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/417/d92/8a4/417d928a4647460c82161ec14e27fe9e.png"></div><br>  The result is a matrix that allows you to convert 3D vertices to 2D pixels, taking into account the position of the viewpoint and everything related to the position, scale and rotation of the current object. <br><br>  The task of the 3D designer is to create this matrix and maintain the relevance of its data. <br><br>  <b>And again shaders</b> <br><br>  After the vertex shader runs on each vertex (i.e., 3 times), we get 3 pixels with the correct vUV and gl_position value.  Next, the GPU will transfer these values ‚Äã‚Äãto each pixel inside the triangle formed by the three main pixels. <br><br>  Then a pixel shader will be applied to each pixel: <br><br><pre> <code class="javascript hljs">precision highp float; varying vec2 vUV; uniform sampler2D textureSampler; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_FragColor = texture2D(textureSampler, vUV); }</code> </pre><br>  <b>The structure of the pixel (or fragment) shader</b> <br><br>  In its structure, the pixel shader is similar to the vertex one: <br><br><ul><li>  <b>Varying variables:</b> These are the values ‚Äã‚Äãthat are created by the vertex shader and are passed to the pixel shader.  In our case, the pixel shader will get the vUV value from the vertex shader. <br><br></li><li>  <b>Uniform Variables:</b> Determined by the CPU and used by the shader.  The only uniform variable that we have in this case is a sampler that is needed to read texture colors. <br><br></li><li>  <b>main:</b> The main function is the code that runs in the GPU for each pixel.  It should at least give a value for gl_FragColor (the color of the current pixel). </li></ul><br>  This pixel shader is very simple: it reads the texture color using the texture coordinates from the vertex shader (which, in turn, got them from the vertex). <br><br>  <a href="https://tutsplus.github.io/webgl-babylon-js-shaders/sphere-demo/index.html">That's what happened in the end.</a>  Rendering is performed in real time;  You can move the sphere with the mouse. <br><br>  To get this result, you need to work carefully with the code WebGL.  Of course, WebGL is a very powerful API.  But it is low-level, so you have to do everything yourself: from creating a buffer to determining the structure of the vertices.  You will also need to perform many mathematical calculations, set up states, control texture loading, and so on. <br><br><h1>  Too hard?  BABYLON.ShaderMaterial to the rescue </h1><br>  I know what you thought: ‚ÄúShaders are, of course, cool, but I don‚Äôt want to understand all the intricacies of WebGL and independently do all the calculations.‚Äù <br><br>  No problem!  That is why we created Babylon.js. <br><br>  Here‚Äôs what the code for the same realm looks like in Babylon.js.  First you need a simple web page: <br><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>Babylon.js<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Babylon.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"application/vertexShader"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"vertexShaderCode"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> precision highp float; </span><span class="hljs-comment"><span class="actionscript"><span class="hljs-comment">// Attributes attribute vec3 position; attribute vec2 uv; // Uniforms uniform mat4 worldViewProjection; // Normal varying vec2 vUV; void main(void) { gl_Position = worldViewProjection * vec4(position, 1.0); vUV = uv; } </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"application/fragmentShader"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fragmentShaderCode"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> precision highp float; varying vec2 vUV; uniform sampler2D textureSampler; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">void</span></span></span><span class="actionscript"> main(</span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">void</span></span></span><span class="actionscript">) { gl_FragColor = texture2D(textureSampler, vUV); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"index.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">html</span></span></span><span class="css">, </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">body</span></span></span><span class="css"> { </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">width</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">100%</span></span></span><span class="css">; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">height</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">100%</span></span></span><span class="css">; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">padding</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0</span></span></span><span class="css">; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">margin</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0</span></span></span><span class="css">; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">overflow</span></span></span><span class="css">: hidden; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">margin</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0px</span></span></span><span class="css">; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">overflow</span></span></span><span class="css">: hidden; } </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#renderCanvas</span></span></span><span class="css"> { </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">width</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">100%</span></span></span><span class="css">; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">height</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">100%</span></span></span><span class="css">; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">touch-action</span></span></span><span class="css">: none; </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">-ms-touch-action</span></span></span><span class="css">: none; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"renderCanvas"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Shaders here are set by script tags.  In Babylon.js, they can also be specified in separate .fx files. <br><br>  Babylon.js is available for download <a href="http://www.babylonjs.com/%3FWT.mc_id%3D14113-DEV-tuts-article4">at the link here</a> or in our <a href="">repository on GitHub.</a>  To access the BABYLON.StandardMaterial object, you need version 1.11 or higher. <br><br>  Finally, the main JavaScript code looks like this: <br>  "Use strict"; <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"DOMContentLoaded"</span></span>, startGame, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startGame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BABYLON.Engine.isSupported()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"renderCanvas"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> engine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BABYLON.Engine(canvas, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BABYLON.Scene(engine); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BABYLON.ArcRotateCamera(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, BABYLON.Vector3.Zero(), scene); camera.attachControl(canvas); <span class="hljs-comment"><span class="hljs-comment">// Creating sphere var sphere = BABYLON.Mesh.CreateSphere("Sphere", 16, 5, scene); var amigaMaterial = new BABYLON.ShaderMaterial("amiga", scene, { vertexElement: "vertexShaderCode", fragmentElement: "fragmentShaderCode", }, { attributes: ["position", "uv"], uniforms: ["worldViewProjection"] }); amigaMaterial.setTexture("textureSampler", new BABYLON.Texture("amiga.jpg", scene)); sphere.material = amigaMaterial; engine.runRenderLoop(function () { sphere.rotation.y += 0.05; scene.render(); }); } };</span></span></code> </pre><br>  As you can see, I use BABYLON.ShaderMaterial to get rid of the need to compile, link, or manipulate shaders. <br><br>  When creating the BABYLON.ShaderMaterial object, you need to specify the DOM element used to store the shaders or the base name of the files in which the shaders are located.  For the second option, you will also need to create a file for each shader using the following naming principle: basename.vertex.fx and basename.fragment.fx.  Then you will need to create a material like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cloudMaterial = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BABYLON.ShaderMaterial(<span class="hljs-string"><span class="hljs-string">"cloud"</span></span>, scene, <span class="hljs-string"><span class="hljs-string">"./myShader"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: [<span class="hljs-string"><span class="hljs-string">"position"</span></span>, <span class="hljs-string"><span class="hljs-string">"uv"</span></span>], <span class="hljs-attr"><span class="hljs-attr">uniforms</span></span>: [<span class="hljs-string"><span class="hljs-string">"worldViewProjection"</span></span>] });</code> </pre><br>  You must also specify the names of any used attributes and uniform variables.  You can then directly set the values ‚Äã‚Äãof uniform variables and samplers using the setTexture, setFloat, setFloats, setColor3, setColor4, setVector2, setVector3, setVector4, and setMatrix functions. <br><br>  Pretty simple, right? <br><br>  Remember the worldViewProjection matrix?  With Babylon.js and BABYLON.ShaderMaterial you don‚Äôt have to worry about it.  The BABYLON.ShaderMaterial object will calculate everything automatically, since we declare the matrix in the list of uniform variables. <br><br>  The BABYLON.ShaderMaterial object can independently manage the following matrices: <br><br><ul><li>  world; </li><li>  view; </li><li>  projection; </li><li>  worldView; </li><li>  worldViewProjection. </li></ul><br>  No complicated calculations.  For example, with each execution of sphere.rotation.y + = 0.05, the world matrix of this sphere is generated and transmitted to the GPU. <br><br><h1>  CYOS: Build your own shader </h1><br>  We will go even further and create a page where you can dynamically edit the shaders and watch the result in real time.  To do this, we need the old code, as well as the BABYLON.ShaderMaterial object for compiling and executing the created shaders. <br><br>  I used a <a href="http://ace.c9.io/">code editor</a> <a href="http://www.babylonjs.com/CYOS%3FWT.mc_id%3D14113-DEV-tuts-article4">for CYOS</a> <a href="http://ace.c9.io/">called ACE.</a>  It is incredibly convenient and features a syntax highlighting feature. <br><br>  In the Templates field, you can select pre-installed shaders, we will talk about them a little later.  You can also change the 3D object used to preview the shaders in the Meshes field. <br><br>  The Compile button is used to create a new BABYLON.ShaderMaterial object from shaders.  Here is its code: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Compile shaderMaterial = new BABYLON.ShaderMaterial("shader", scene, { vertexElement: "vertexShaderCode", fragmentElement: "fragmentShaderCode", }, { attributes: ["position", "normal", "uv"], uniforms: ["world", "worldView", "worldViewProjection"] }); var refTexture = new BABYLON.Texture("ref.jpg", scene); refTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE; refTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE; var amigaTexture = new BABYLON.Texture("amiga.jpg", scene); shaderMaterial.setTexture("textureSampler", amigaTexture); shaderMaterial.setTexture("refSampler", refTexture); shaderMaterial.setFloat("time", 0); shaderMaterial.setVector3("cameraPosition", BABYLON.Vector3.Zero()); shaderMaterial.backFaceCulling = false; mesh.material = shaderMaterial;</span></span></code> </pre><br>  Suspiciously simple, right?  So, it remains only to get 3 pre-computed matrices: world, worldView and worldViewProjection.  The vertex data will contain the position, normal, and texture coordinates.  Also the following 2 textures will be loaded: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/89f/d69/7d9/89fd697d90ca495fa9a872e2cac494ab.png"></div><br>  <i>amiga.jpg</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d85/a67/bc1/d85a67bc186f4656af9d36e16b6c100c.png"></div><br>  <i>ref.jpg</i> <br><br>  And this is the renderLoop, where I update 2 uniform variables: <br><br><ul><li>  time variable - to get funny animations; </li><li>  variable cameraPosition - to get information about the position of the camera in the shaders (which is very useful when calculating the lighting); </li></ul><br><pre> <code class="javascript hljs">engine.runRenderLoop(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ mesh.rotation.y += <span class="hljs-number"><span class="hljs-number">0.001</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shaderMaterial) { shaderMaterial.setFloat(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, time); time += <span class="hljs-number"><span class="hljs-number">0.02</span></span>; shaderMaterial.setVector3(<span class="hljs-string"><span class="hljs-string">"cameraPosition"</span></span>, camera.position); } scene.render(); });</code> </pre><br>  In addition, CYOS is now available for Windows Phone due to our work for Windows Phone 8.1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3b9/956/7fb/3b99567fb82f4053b467705f54ca8557.png"></div><br>  <b>Basic</b> <br><br>  Let's start with the basic shader in CYOS.  We have already considered something similar.  This shader calculates gl_position and uses texture coordinates to get the color for each pixel. <br><br>  To calculate the position of a pixel, you need the worldViewProjection matrix and the position of the vertex: <br><br><pre> <code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Attributes attribute vec3 position; attribute vec2 uv; // Uniforms uniform mat4 worldViewProjection; // Varying varying vec2 vUV; void main(void) { gl_Position = worldViewProjection * vec4(position, 1.0); vUV = uv; }</span></span></code> </pre><br>  The texture coordinates (uv) are transferred to the pixel shader unchanged. <br><br>  Pay attention to the first line: precision mediump float;  - it must be added to the vertex and pixel shader to work properly in Chrome.  It is responsible for ensuring that high precision numbers are not used to improve performance. <br><br>  With a pixel shader, everything is even simpler: you just need to use the texture coordinates and get the texture color: <br><br><pre> <code class="javascript hljs">precision highp float; varying vec2 vUV; uniform sampler2D textureSampler; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_FragColor = texture2D(textureSampler, vUV); }</code> </pre><br>  As was seen earlier, the uniform-variable textureSampler is filled with an amiga texture, so the result looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e93/63b/26a/e9363b26a3e94038b7869897c46a8c48.png"></div><br>  <b>Black and white</b> <br><br>  Let's move on to the second shader, black and white.  It will use the parameters of the previous one, but in black and white rendering.  Leave the same settings as the vertex shader and make small changes to the pixel code. <br><br>  The easiest way to achieve this effect is to take just one component, for example, as shown below: <br><br><pre> <code class="javascript hljs">precision highp float; varying vec2 vUV; uniform sampler2D textureSampler; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_FragColor = vec4(texture2D(textureSampler, vUV).ggg, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br>  We used .ggg instead of .rgb (in computer graphics this operation is called swizzle).  But if you want to get a real black and white effect, it is best to calculate the relative brightness, which takes into account all the components of the color: <br><br><pre> <code class="javascript hljs">precision highp float; varying vec2 vUV; uniform sampler2D textureSampler; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { float luminance = dot(texture2D(textureSampler, vUV).rgb, vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.59</span></span>, <span class="hljs-number"><span class="hljs-number">0.11</span></span>)); gl_FragColor = vec4(luminance, luminance, luminance, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br>  Scalar product is calculated as follows: <br><br><pre> <code class="javascript hljs">result = v0.x * v1.x + v0.y * v1.y + v0.z * v1.z</code> </pre><br>  In our case: <br><br><pre> <code class="javascript hljs">luminance = r * <span class="hljs-number"><span class="hljs-number">0.3</span></span> + g * <span class="hljs-number"><span class="hljs-number">0.59</span></span> + b * <span class="hljs-number"><span class="hljs-number">0.11</span></span></code> </pre><br>  <em>(these values ‚Äã‚Äãare calculated taking into account that the human eye is more sensitive to green)</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fde/449/039/fde449039a3f4e108f19d0044d892a79.png"></div><br>  <b>Cell shading</b> <br><br>  Next on the list is a shader filled with cells, it's a bit more complicated. <br><br>  In this case, we need to add the position of the vertex and the normal to the vertex in the pixel shader.  The vertex shader will look like this: <br><br><pre> <code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Attributes attribute vec3 position; attribute vec3 normal; attribute vec2 uv; // Uniforms uniform mat4 world; uniform mat4 worldViewProjection; // Varying varying vec3 vPositionW; varying vec3 vNormalW; varying vec2 vUV; void main(void) { vec4 outPosition = worldViewProjection * vec4(position, 1.0); gl_Position = outPosition; vPositionW = vec3(world * vec4(position, 1.0)); vNormalW = normalize(vec3(world * vec4(normal, 0.0))); vUV = uv; }</span></span></code> </pre><br>  Learn that the position data of the vertex and the normal to the vertex are transmitted unchanged, so we also need to apply the world matrix to take into account the rotation of the object. <br><br>  Here is what a pixel shader will look like: <br><br><pre> <code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Lights varying vec3 vPositionW; varying vec3 vNormalW; varying vec2 vUV; // Refs uniform sampler2D textureSampler; void main(void) { float ToonThresholds[4]; ToonThresholds[0] = 0.95; ToonThresholds[1] = 0.5; ToonThresholds[2] = 0.2; ToonThresholds[3] = 0.03; float ToonBrightnessLevels[5]; ToonBrightnessLevels[0] = 1.0; ToonBrightnessLevels[1] = 0.8; ToonBrightnessLevels[2] = 0.6; ToonBrightnessLevels[3] = 0.35; ToonBrightnessLevels[4] = 0.2; vec3 vLightPosition = vec3(0, 20, 10); // Light vec3 lightVectorW = normalize(vLightPosition - vPositionW); // diffuse float ndl = max(0., dot(vNormalW, lightVectorW)); vec3 color = texture2D(textureSampler, vUV).rgb; if (ndl &gt; ToonThresholds[0]) { color *= ToonBrightnessLevels[0]; } else if (ndl &gt; ToonThresholds[1]) { color *= ToonBrightnessLevels[1]; } else if (ndl &gt; ToonThresholds[2]) { color *= ToonBrightnessLevels[2]; } else if (ndl &gt; ToonThresholds[3]) { color *= ToonBrightnessLevels[3]; } else { color *= ToonBrightnessLevels[4]; } gl_FragColor = vec4(color, 1.); }</span></span></code> </pre><br>  This shader is designed to simulate light, therefore, in order not to calculate smooth shading over the entire surface of the object, we will calculate the light intensity based on several brightness thresholds.  For example, if the intensity is from 1 (maximum) to 0.95, the color of the object, taken from the texture, will be superimposed directly, without changes.  If the intensity is from 0.95 to 0.5, a factor of 0.8 will be applied to the color value and so on. <br><br>  As a result, the process of creating such a shader can be divided into 4 steps: <br><br><ul><li>  First, we declare the brightness thresholds and constants for each degree of intensity. </li><li>  We calculate the illumination based on the Phong algorithm (based on the consideration that the light source does not move). </li></ul><br><pre> <code class="javascript hljs">vec3 vLightPosition = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Light vec3 lightVectorW = normalize(vLightPosition - vPositionW); // diffuse float ndl = max(0., dot(vNormalW, lightVectorW));</span></span></code> </pre><br>  The intensity of light incident on a pixel depends on the angle between the normal to the top and the direction of the light. <br><br><ul><li>  Get the texture color for the pixel. </li><li>  Check the brightness threshold and apply a constant of the appropriate degree of intensity. </li></ul><br>  As a result, we get something similar to the multiplier effect: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/91e/241/aec/91e241aec3964e149a48ccfa927cf11d.png"></div><br>  <b>Phong</b> <br><br>  We already used the Phong algorithm in the previous example.  Now consider it more. <br><br>  With the vertex shader, everything will be pretty simple, since most of the work will be in the pixel one: <br><br><pre> <code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Attributes attribute vec3 position; attribute vec3 normal; attribute vec2 uv; // Uniforms uniform mat4 worldViewProjection; // Varying varying vec3 vPosition; varying vec3 vNormal; varying vec2 vUV; void main(void) { vec4 outPosition = worldViewProjection * vec4(position, 1.0); gl_Position = outPosition; vUV = uv; vPosition = position; vNormal = normal; }</span></span></code> </pre><br>  According to the algorithm, it is necessary to calculate the diffuse and specular components using the directions of light and the normal to the vertex: <br><br><pre> <code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Varying varying vec3 vPosition; varying vec3 vNormal; varying vec2 vUV; // Uniforms uniform mat4 world; // Refs uniform vec3 cameraPosition; uniform sampler2D textureSampler; void main(void) { vec3 vLightPosition = vec3(0, 20, 10); // World values vec3 vPositionW = vec3(world * vec4(vPosition, 1.0)); vec3 vNormalW = normalize(vec3(world * vec4(vNormal, 0.0))); vec3 viewDirectionW = normalize(cameraPosition - vPositionW); // Light vec3 lightVectorW = normalize(vLightPosition - vPositionW); vec3 color = texture2D(textureSampler, vUV).rgb; // diffuse float ndl = max(0., dot(vNormalW, lightVectorW)); // Specular vec3 angleW = normalize(viewDirectionW + lightVectorW); float specComp = max(0., dot(vNormalW, angleW)); specComp = pow(specComp, max(1., 64.)) * 2.; gl_FragColor = vec4(color * ndl + vec3(specComp), 1.); }</span></span></code> </pre><br>  In the previous example, we used only the diffuse component, so it remains only to add a mirror.  This picture <a href="http://en.wikipedia.org/wiki/Phong_shading">from a Wikipedia article</a> explains the principle of shader operation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bdd/8f2/6a7/bdd8f26a712b4eabac8667ea1c5cade9.png"></div><br>  <i>Posted by: Brad Smith aka Rainwarrior</i> <br><br>  Result: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1ea/d08/1cc/1ead081cc05e4ea996baff79a7eb92e5.png"></div><br>  <b>Discard</b> <br><br>  For this type of shader, I would like to introduce a new concept: the discard keyword.  Such a shader will ignore any pixel that is not red, resulting in an illusion of a hollow object. <br><br>  The vertex shader will be the same in this case as for the base shader: <br><br><pre> <code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Attributes attribute vec3 position; attribute vec3 normal; attribute vec2 uv; // Uniforms uniform mat4 worldViewProjection; // Varying varying vec2 vUV; void main(void) { gl_Position = worldViewProjection * vec4(position, 1.0); vUV = uv; }</span></span></code> </pre><br>  The pixel shader will check the color of each pixel and use the discard keyword when, for example, the value of the green component is too large: <br><br><pre> <code class="javascript hljs">precision highp float; varying vec2 vUV; <span class="hljs-comment"><span class="hljs-comment">// Refs uniform sampler2D textureSampler; void main(void) { vec3 color = texture2D(textureSampler, vUV).rgb; if (color.g &gt; 0.5) { discard; } gl_FragColor = vec4(color, 1.); }</span></span></code> </pre><br><br>  The result looks quite funny: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/348/c44/c0f/348c44c0fc4e4d4285bdbcdc64075dd6.png"></div><br>  <b>Wave</b> <br><br>  Perhaps we have already played enough with pixel shaders.  Now I would like to pay more attention to vertex shaders. <br><br>  For this example, we need a pixel shader with Phong shading. <br><br>  In the vertex shader, we use a uniform variable called time to get dynamic values.  This variable will generate a wave in which the vertices will change their position: <br><br><pre> <code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Attributes attribute vec3 position; attribute vec3 normal; attribute vec2 uv; // Uniforms uniform mat4 worldViewProjection; uniform float time; // Varying varying vec3 vPosition; varying vec3 vNormal; varying vec2 vUV; void main(void) { vec3 v = position; vx += sin(2.0 * position.y + (time)) * 0.5; gl_Position = worldViewProjection * vec4(v, 1.0); vPosition = position; vNormal = normal; vUV = uv; }</span></span></code> </pre><br>  The sine is multiplied by position.y, and this gives the following result: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dfa/ba6/a95/dfaba6a95f2c443ead9da6c52bd06ae3.png"></div><br>  <b>Spherical Environment Mapping</b> <br><br>  <a href="http://www.clicktorelease.com/blog/creating-spherical-environment-mapping-shader%3FWT.mc_id%3D14113-DEV-tuts-article4">This beautiful tutor</a> inspired us to create this shader.  I recommend to familiarize yourself with it, and then see the Wave shader in CYOS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/71b/3d1/c97/71b3d1c97cbb4f9d9a0c24eecf449f0e.png"></div><br>  <b>Fresnel</b> <br><br>  And finally, my favorite shader, Fresnel.  It changes intensity depending on the angle between the viewing direction and the normal to the top. <br><br>  The vertex shader here is exactly the same as the shader with the cell fill, and we can easily calculate the <a href="http://en.wikipedia.org/wiki/Fresnel_term">Fresnel reflection value</a> required for the pixel shader (you can use the normals and camera positions to determine the viewing direction): <br><br><pre> <code class="javascript hljs">precision highp float; <span class="hljs-comment"><span class="hljs-comment">// Lights varying vec3 vPositionW; varying vec3 vNormalW; // Refs uniform vec3 cameraPosition; uniform sampler2D textureSampler; void main(void) { vec3 color = vec3(1., 1., 1.); vec3 viewDirectionW = normalize(cameraPosition - vPositionW); // Fresnel float fresnelTerm = dot(viewDirectionW, vNormalW); fresnelTerm = clamp(1.0 - fresnelTerm, 0., 1.); gl_FragColor = vec4(color * fresnelTerm, 1.); }</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d47/906/f12/d47906f12500478baeffedf288c8c313.png"></div><br>  <b>Your shader</b> <br><br>  I think now you are ready to create your own shader.  Feel free to share the results of experiments in the comments below. <br><br>  Here are some additional links for those who want to learn more about the material: <br><br><blockquote>  ¬ª <a href="">Babylon.js repository;</a> <br>  " <a href="http://www.html5gamedevs.com/forum/16-babylonjs/">Babylon.js forum;</a> <br>  ¬ª <a href="http://www.babylonjs.com/CYOS/">CYOS;</a> <br>  ¬ª <a href="http://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL article on Wikipedia;</a> <br>  ¬ª <a href="https://www.opengl.org/documentation/glsl/">GLSL documentation.</a> </blockquote><br>  And a few more of my articles on the same topic: <br><br><blockquote>  ¬ª <a href="http://www.microsoftvirtualacademy.com/training-courses/introduction-to-webgl-3d-with-html5-and-babylon-js/%3FWT.mc_id%3D14113-DEV-tuts-article4">Introduction to WebGL 3D with HTML5 and Babylon.JS;</a> <br>  <a href="http://channel9.msdn.com/events/Build/2014/3-558/%3FWT.mc_id%3D14113-DEV-tuts-article4">Cutting Edge Graphics in HTML.</a> </blockquote><br>  As well as JavaScript lessons from our team: <br><br><blockquote>  ¬ª <a href="http://channel9.msdn.com/Series/Practical-Performance-Tips-to-Make-Your-HTMLJavaScript-Faster/06/%3FWT.mc_id%3D14113-DEV-tuts-article4">Practical Performance Tips to Make your HTML / JavaScript Faster</a> (a series of lessons in seven parts, covering many topics: from adaptive design to optimize performance and casual games); <br>  ¬ª <a href="http://www.microsoftvirtualacademy.com/training-courses/the-modern-web-platform-jump-start/%3FWT.mc_id%3D14113-DEV-tuts-article4">The Modern Web Platform Jump Start</a> (basic HTML, CSS and JS); <br>  ¬ª <a href="http://www.microsoftvirtualacademy.com/training-courses/developing-universal-windows-apps-with-html-and-javascript-jump-start%3FWT.mc_id%3D14113-DEV-tuts-article4">Developing Universal Windows App with HTML and JavaScript Jump Start</a> (use already written JS code to create an application). </blockquote><br>  And, of course, you can always use some of our free tools to optimize your web experience: the <a href="http://www.asp.net/get-started/websites%3FWT.mc_id%3D14113-DEV-tuts-article4">Visual Studio Community</a> , the <a href="https%253A%252F%252Fgamedevelopment.tutsplus.com%252Ftutorials%252Fbuilding-shaders-with-babylonjs-and-webgl-theory-and-examples--cms-24146%26xtz%3D-180">Azure</a> trial version and the <a href="http://dev.modern.ie/%3Futm_source%3DTuts%26utm_medium%3Darticle4%26utm_campaign%3DTuts">cross-browser testing tools for</a> Mac, Linux or Windows. </div><p>Source: <a href="https://habr.com/ru/post/311138/">https://habr.com/ru/post/311138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311126/index.html">How it was: reveal the details of Droidcon Moscow 2016</a></li>
<li><a href="../311128/index.html">.Net Core, exchange with 1C over TCP / IP between different devices</a></li>
<li><a href="../311130/index.html">UWP beginner: Responsive Design (VB.NET + C #)</a></li>
<li><a href="../311134/index.html">Locks aren't that slow.</a></li>
<li><a href="../311136/index.html">The Incredible Adventures of Aliens in Y Combinator</a></li>
<li><a href="../311140/index.html">Measuring Apache Ignite Cache Performance</a></li>
<li><a href="../311142/index.html">Grouping Fancy Bear uses malware for OS X in cyber attacks</a></li>
<li><a href="../311144/index.html">We integrate messengers (using Slack as an example): GitHub, RSS (in particular, Java), jobs for your request</a></li>
<li><a href="../311146/index.html">Welcome to Spark ... on Java: Interview with Evgeny Borisov</a></li>
<li><a href="../311150/index.html">Analysis of the use of data redundancy as the required additional memory when sorting by the merge algorithm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>