<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make your code 80 times faster</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All beaver! 

 We are starting the third set for the Python Developer course, which means that there is an open lesson in front of us, which partially...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make your code 80 times faster</h1><div class="post__text post__text-html js-mediator-article"> All beaver! <br><br>  We are starting the third set for the <a href="https://otus.pw/JyLT/">Python Developer</a> course, which means that there is <a href="https://otus.pw/Vm95/">an open lesson</a> in front of us, which partially replace the old-format open door days and where you can get acquainted with interesting material from our teachers, and that we found another interesting material .  This time to speed up the "snake" code. <br><br>  Go. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      PyPy is able to speed up the code by 2 times, which pleases very many people.  I want to share a short, personal story, proving that PyPy is capable of more. <br><br>  DISCLAIMER: This is not a miracle cure for all occasions, yes, it worked specifically in this case, but it may not be as effective in many others.  However, the method is still interesting.  Moreover, the steps described here, I applied during development in the same manner, which makes the article a vital example of optimizing PyPy. <br><br>  I <a href="https://github.com/antocuni/evolvingcopter">experimented</a> with evolutionary algorithms a few months ago: the plan was ambitious - to automatically develop logic capable of controlling (simulated) quadcopter, that is, the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%2598%25D0%2594-%25D1%2580%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580">PID controller</a> ( <b>spoiler</b> : does not fly). <br><br><img src="https://habrastorage.org/webt/sk/j-/q8/skj-q8zokqvqvri1eirxsybvwu0.jpeg"><a name="habracut"></a><br><br>  The idea is that in the presence of a population of random creatures, in each generation the fittest survive and reproduce with small, random changes. <br><br>  However, within the framework of this post, the initial task is not so important, so we move directly to the code.  To control the quadcopter, the creature uses the <code>run_step</code> method, which is run in each <code>delta_t</code> (full code): <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Creature</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> INPUTS = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment"># z_setpoint, current z position OUTPUTS = 1 # PWM for all 4 motors STATE_VARS = 1 ... def run_step(self, inputs): # state: [state_vars ... inputs] # out_values: [state_vars, ... outputs] self.state[self.STATE_VARS:] = inputs out_values = np.dot(self.matrix, self.state) + self.constant self.state[:self.STATE_VARS] = out_values[:self.STATE_VARS] outputs = out_values[self.STATE_VARS:] return outputs</span></span></code> </pre> <br><ul><li>  inputs - numpy array in which the final point and the current position along the Z axis are located; </li><li>  outputs - the numpy array in which the thrust is transmitted to the motors.  For a start, all 4 motors are limited to the same pitch, so the quadrocopter moves up and down along the Z axis; </li><li>  <code>self.state</code> contains arbitrary values ‚Äã‚Äãof unknown size that are passed from one step to another; </li><li>  <code>self.matrix</code> and <code>self.constant</code> contain the logic itself.  By transferring the ‚Äúcorrect‚Äù values ‚Äã‚Äãto them, theoretically, we could get a perfectly tuned PID controller.  They randomly mutate between generations. </li></ul><br>  <code>run_step</code> is called at 100 Hz (in the virtual simulation time interval).  The generation consists of 500 creatures, each of which we test for 12 virtual seconds.  Thus, each generation contains 600,000 <code>run_step</code> executions. <br><br>  At first I tried to run the code on CPython;  and here is the result: <br><br><pre> <code class="bash hljs">$ python -m ev.main Generation 1: ... [population = 500] [12.06 secs] Generation 2: ... [population = 500] [6.13 secs] Generation 3: ... [population = 500] [6.11 secs] Generation 4: ... [population = 500] [6.09 secs] Generation 5: ... [population = 500] [6.18 secs] Generation 6: ... [population = 500] [6.26 secs]</code> </pre> <br>  That is ~ 6.15 seconds / generation, except for the first. <br><br>  Then, I tried PyPy 5.9: <br><br><pre> <code class="bash hljs">$ pypy -m ev.main Generation 1: ... [population = 500] [63.90 secs] Generation 2: ... [population = 500] [33.92 secs] Generation 3: ... [population = 500] [34.21 secs] Generation 4: ... [population = 500] [33.75 secs]</code> </pre> <br>  Oh!  It turned out ~ 5.5 times slower than with CPython.  In part, this was expected: nympy is based on cpyext, known for its slowness.  (Actually, we <a href="https://morepypy.blogspot.it/2017/10/cape-of-good-hope-for-pypy-hello-from.html">are working</a> on this - on the <code>cpyext-avoid-roundtrip</code> brunch, the result is better than with CPython, but we'll talk about this in another post). <br><br>  Let's try to avoid cpyext.  The first obvious step is to use numpypy instead of numpy (here‚Äôs a <a href="https://github.com/antocuni/evolvingcopter/blob/master/ev/pypycompat.py">hack</a> that allows you to use only part of the micronumpy).  Check if the speed has improved: <br><br><pre> <code class="bash hljs">$ pypy -m ev.main <span class="hljs-comment"><span class="hljs-comment"># using numpypy Generation 1: ... [population = 500] [5.60 secs] Generation 2: ... [population = 500] [2.90 secs] Generation 3: ... [population = 500] [2.78 secs] Generation 4: ... [population = 500] [2.69 secs] Generation 5: ... [population = 500] [2.72 secs] Generation 6: ... [population = 500] [2.73 secs]</span></span></code> </pre> <br>  On average, ~ 2.7 seconds: 12 times faster than PyPy + numpy and more than 2 times faster than the original CPython.  Already, many would run to tell how good PyPy is. <br><br>  But let's try to improve the result.  As usual, let's analyze what it takes the most time.  Here is the link to the vmprof <a href="http://vmprof.com/">profile</a> .  We spend a lot of time inside numpypy and allocate tons of temporary arrays to store the results of various operations. <br><br>  In addition, we will look at the jit <a href="http://vmprof.com/">trace</a> and find the run function: this is the loop in which we spend most of the time, it consists of 1796 operations.  The operations for the line <code>np.dot(...)</code> <code>+ self.constant</code> are between lines 1217 and 1456. Below is an excerpt calling <code>np.dot(...)</code> .  Most of the operators cost nothing, but in line 1232 we see the RPython function call <a href="https://bitbucket.org/pypy/pypy/src/89d1f31fabc86778cfaa1034b1102887c063de66/pypy/module/micronumpy/ndarray.py%3Fat%3Ddefault%26fileviewer%3Dfile-view-default">descr_dot</a> ;  on implementation, we see that it creates a new W_NDimArray to store the result, which means it will have to do <code>malloc()</code> : <br><br><img src="https://habrastorage.org/webt/jp/i-/mm/jpi-mm0z8jbb-kwbsteiptkq-iw.png"><br><br>  An interesting implementation of the part <code>+ self.constant</code> - the call to <code>W_NDimArray.descr_add</code> was embedded in JIT, so it is easier for us to understand what is happening.  In particular, we see a call to <code>__0_alloc_with_del____</code> , allocating W_NDimArray for the result, and aw_malloc, allocating the array itself.  Then there is a long list of 149 simple operations that define the fields of the final array, create an iterator, and finally call <code>acall_assembler</code> ‚Äî this is the actual logic to perform the addition, which JIT 'or separately.  <code>call_assembler</code> one of the operations for making JIT-to-JIT calls: <br><br><img src="https://habrastorage.org/webt/7-/zo/ld/7-zoldb9m185qvqrjo-buyd08m4.png"><br><br>  All this is not very optimal: in our case, it is known that the size of <code>self.matrix</code> always (3, 2) - which means we do a lot of work, including 2 <code>malloc()</code> calls for temporary arrays, just to call two functions that the total amount is 6 multiplications and 6 additions.  Note that this is not the fault of JIT: CPython + numpy having to do the same, but in hidden calls C. <br><br>  The well-known compiler optimization - reversal of the loop will probably help to solve this problem.  From the point of view of the compiler, a loop reversal is always accompanied by a risk - if the matrix is ‚Äã‚Äãtoo large, you will end up with a large, shapeless mass of code that will be useless if the size of the array is constantly changing.  This is one of the main reasons why PyPy JIT in this case is not even trying to do that. <br><br>  However, we know that the matrix is ‚Äã‚Äãsmall and always the same size.  Therefore, we deploy the cycle manually: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecializedCreature</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Creature)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> Creature.__init__(self, *args, **kwargs) <span class="hljs-comment"><span class="hljs-comment"># store the data in a plain Python list self.data = list(self.matrix.ravel()) + list(self.constant) self.data_state = [0.0] assert self.matrix.shape == (2, 3) assert len(self.data) == 8 def run_step(self, inputs): # state: [state_vars ... inputs] # out_values: [state_vars, ... outputs] k0, k1, k2, q0, q1, q2, c0, c1 = self.data s0 = self.data_state[0] z_sp, z = inputs # # compute the output out0 = s0*k0 + z_sp*k1 + z*k2 + c0 out1 = s0*q0 + z_sp*q1 + z*q2 + c1 # self.data_state[0] = out0 outputs = [out1] return outputs</span></span></code> </pre> <br>  The <a href="https://github.com/antocuni/evolvingcopter/blob/master/ev/creature.py">code</a> additionally has a health check to make sure that the value is equal to that provided via <code>Creature.run_step</code> . <br><br>  Let's check how it works.  First with CPython: <br><br><pre> <code class="bash hljs">$ python -m ev.main Generation 1: ... [population = 500] [7.61 secs] Generation 2: ... [population = 500] [3.96 secs] Generation 3: ... [population = 500] [3.79 secs] Generation 4: ... [population = 500] [3.74 secs] Generation 5: ... [population = 500] [3.84 secs] Generation 6: ... [population = 500] [3.69 secs]</code> </pre><br>  It looks good - 60% faster than the original implementation of CPython + numpy.  Check PyPy: <br><br><pre> <code class="bash hljs">Generation 1: ... [population = 500] [0.39 secs] Generation 2: ... [population = 500] [0.10 secs] Generation 3: ... [population = 500] [0.11 secs] Generation 4: ... [population = 500] [0.09 secs] Generation 5: ... [population = 500] [0.08 secs] Generation 6: ... [population = 500] [0.12 secs] Generation 7: ... [population = 500] [0.09 secs] Generation 8: ... [population = 500] [0.08 secs] Generation 9: ... [population = 500] [0.08 secs] Generation 10: ... [population = 500] [0.08 secs] Generation 11: ... [population = 500] [0.08 secs] Generation 12: ... [population = 500] [0.07 secs] Generation 13: ... [population = 500] [0.07 secs] Generation 14: ... [population = 500] [0.08 secs] Generation 15: ... [population = 500] [0.07 secs]</code> </pre><br>  Yes, this is not a mistake.  After a couple of generations, time stabilizes in the region of ~ 0.07-0.08 seconds per generation.  Which is about 80 (eighty) times faster than the implementation of CPython + numpy, and 35-40 times faster than the naive PyPy + numpy. <br><br>  Let's look at the <a href="http://vmprof.com/">trace</a> again: there are no more expensive calls and no temporary malloc () 's.  The root of the logic is in lines 386-416, where we see the execution of fast C-level multiplications and additions: float_mul and float_add are translated directly to the mulsd and addsd86 commands. <br><br>  As I said, this is a very specific example, and this method is not universal: unfortunately, you should not wait for 80-fold acceleration of an arbitrary code.  However, this clearly shows the potential of PyPy in high-speed computations.  And most importantly, this is not a trial benchmark, designed specifically for good performance. PyPy is a small but realistic example. <br><br>  How to reproduce the result <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/antocuni/evolvingcopter $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> evolvingcopter $ {python,pypy} -m ev.main --no-specialized --no-numpypy $ {python,pypy} -m ev.main --no-specialized $ {python,pypy} -m ev.main</code> </pre><br>  THE END <br><br>  If anything, then we are waiting for questions here or at <a href="https://otus.pw/Vm95/">an open lesson</a> . </div><p>Source: <a href="https://habr.com/ru/post/349230/">https://habr.com/ru/post/349230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349220/index.html">As we did "narrative" - ‚Äã‚Äãa new format of publications in Yandex. Dzen</a></li>
<li><a href="../349222/index.html">Hakintosh: upgrading from macOS Sierra 10.12 to High Sierra 10.13</a></li>
<li><a href="../349224/index.html">PostgreSQL indexes - 10</a></li>
<li><a href="../349226/index.html">The blockchain program committee or how to fight off the ICO</a></li>
<li><a href="../349228/index.html">Unit tests when using Corutin in Android application</a></li>
<li><a href="../349232/index.html">Let's talk about usernames</a></li>
<li><a href="../349234/index.html">Security Week 4: Bots for GTA fans, malicious addons for Chrome with Yandex technologies</a></li>
<li><a href="../349236/index.html">Measuring and shaping the frequency characteristics of electric guitars</a></li>
<li><a href="../349238/index.html">My remarks on the book by L.P. Plekhanov "Fundamentals of self-timed electronic circuits"</a></li>
<li><a href="../349242/index.html">Monitoring IT Performance with Splunk IT Service Intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>