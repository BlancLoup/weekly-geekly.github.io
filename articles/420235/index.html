<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Zenject: How an IoC container can kill Dependency Injection on your project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Where do the dangers begin from? Suppose you have firmly decided that you will develop a project, adhering to a specific concept or approach. In our s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Zenject: How an IoC container can kill Dependency Injection on your project</h1><div class="post__text post__text-html js-mediator-article">  Where do the dangers begin from?  Suppose you have firmly decided that you will develop a project, adhering to a specific concept or approach.  In our situation, this is DI, although, for example, Reactive Programming may also be in its place.  It is quite logical that in order to realize your goal, you will turn to ready-made solutions (in our example - the DI Zenject container).  You will familiarize yourself with the documentation and start building an application framework using basic functionality.  If at first the use of the solution you do not have any unpleasant feelings, then most likely it will linger on your project for the rest of its life.  As you work with the basic functions of the solution (container), you may have questions or desires to make some functionality more beautiful or effective way.  Surely, first of all you refer to the more advanced features of the solution (container).  And at this stage the following situation may arise: you already know and trust the chosen solution well, which is why many may not think about how ideologically correct the use of one or another functionality in a solution may be, or the transition to another solution is already quite expensive and inappropriate ( for example, the deadline is approaching.  It is at this stage that the most dangerous situation may arise - the solution functionality is applied with little caution, or in rare cases just on the machine (mindlessly). <br><a name="habracut"></a><br><h3>  Who might be interested? </h3><br>  This article will be useful for those who are well acquainted with DI, as well as for beginners in DI.  To understand enough basic knowledge of what patterns are used DI, the purpose of the DI and the functions that the IoC container performs.  It's not about the intricacies of the Zenject implementation, but about the use of part of its functionality.  The article is based only on the official Zenject documentation and code samples from it, as well as on the book by Mark Siman ‚ÄúDeploying Dependencies in .NET‚Äù, which is a classic exhaustive work on the DI theory.  All quotes in this article are excerpts from the book by Mark Siman.  Despite the fact that we will focus on a specific container, the article may be useful to those who use other containers. <br><br>  The purpose of this article is to show how a tool whose purpose is to help you implement DI on your project can steer you in a completely different direction, pushing you to make errors that bind your code, which reduces testability of the code, in general, deprive you of all the advantages that can give you DI. <br><br>  <i><b>Disclaimer</b></i> : The purpose of the article is not to criticize Zenject himself or his authors.  Zenject can be used strictly for its intended purpose and can serve as an excellent tool for implementing DI, provided that you do not use its full set of functions, by defining for yourself some limitations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Introduction </h3><br>  <i>Zenject</i> is an open source dependency injection container designed to be used with the Unity3D game engine, providing work on most platforms supported by Unity3D.  It should be noted that Zenject can also be used for C # applications developed without Unity3D.  This container is quite popular among Unity developers, actively supported and developed.  In addition, Zenject has all the necessary container DI functionality. <br><br>  I used Zenject in 3 large Unity projects, and also communicated with a large number of developers using it.  The reason for writing this article is frequently asked questions: <br><br><ul><li>  Is using Zenject a good solution? </li><li>  What is wrong with Zenject? </li><li>  What difficulties arise when using Zenject? </li></ul><br>  As well as some projects in which the use of Zenject did not lead to the solution of problems of strong code connectivity and unsuccessful architecture, but rather aggravated the situation. <br><br>  Let's see why developers have such questions and problems.  You can reply as follows: <br><blockquote>  Ironically, DI containers themselves tend to be stable dependencies.  ... When you decide to develop your application based on a DI container, you risk being limited by this choice for the entire life cycle of the application. </blockquote>  It is worth making a remark that with proper and limited use of the container, the transition to using another container in the application (or abandoning the use of the container in favor of the ‚Äú <i>implementation for the poor</i> ‚Äù) is quite possible and does not take much time.  However, in such a situation, it is unlikely that you will need this. <br><br>  Before you begin to understand the potentially dangerous functionality of Zenject, it makes sense to superficially refresh a few basic aspects of DI. <br><br>  The first aspect is the <i>purpose of the DI containers.</i>  Mark Siman writes in his book on this subject the following: <br><blockquote>  DI Container is a software library that can automate many tasks performed when assembling objects and managing their life cycle. </blockquote><blockquote>  Do not expect that the DI container will magically turn strongly bound code into loosely coupled.  The container can increase the efficiency of using DI, but the emphasis in the application should be made primarily on the use of patterns and work with DI. </blockquote>  The second aspect is the <i>DI patterns</i> .  Mark Siman outlines four basic patterns, sorted by frequency and the need to use them: <br><br><ol><li>  Implementing a constructor - How can you ensure that the required dependency is always available to the developed class? </li><li>  Implementing a property - How can I allow DI as an option in a class if there is a suitable local default? </li><li>  Method implementation - How can dependencies be introduced into a class if they are different for each operation? </li><li>  Ambient Context - How can we make the dependency available in each module without including the end-to-end aspects of the application in each API component? </li></ol><br>  The questions listed next to the name of the patterns fully describe their scope.  At the same time, the article will not discuss the Implementation of the Constructor (as there are almost no complaints about its implementation in Zenject) and the Environmental Context (its implementation is not in the container, but you can easily implement it based on the existing functionality). <br>  Now you can go directly to the potentially dangerous functionality of Zenject. <br><br><h3>  Dangerous functionality. </h3><br><h4>  Implementing Properties </h4><br>  This is the second most common DI pattern, after the introduction of the constructor, but it is used much less frequently.  Implemented in Zenject as follows: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBar Bar { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  In addition, in Zenject there is still such a thing as ‚ÄúField Injection‚Äù.  Let's see why in all Zenject this functionality is the most dangerous. <br><br><ul><li>  To show the container which field to embed, the attribute is used.  This is an understandable solution, in terms of simplicity and logic of the implementation of the container itself.  However, we see an attribute (as well as a namespace) in the class code.  That is, at least indirectly, but the class begins to know about where it gets the addiction from.  Plus, we are starting to strongly tie the class code to the container.  In other words, we can‚Äôt stop using Zenject without manipulating the class code. </li><li>  The pattern itself is used in a situation where the dependency has a local default.  That is, this is an optional dependency, and if the container cannot provide it, then there will be no errors in the project, and everything will work.  However, using Zenject, you always get this dependency - the dependency becomes optional. </li><li>  Since the dependency is not optional in this case, it begins to spoil the entire logic of the constructor implementation, because only dependencies should be implemented there.  By implementing non-optional dependencies through properties, you get the opportunity to create circular dependencies in your code.  They will not be so obvious, because in Zenject first implements the implementation of the constructor, and then the implementation of the property, and you will not receive a warning from the container. </li><li>  Using the DI container implies an implementation of the Composition Root pattern, however, using the attribute to set up property injection means that you configure the code not only in the Layout Root, but also as needed in each class. </li></ul><br><h4>  Factories (and MemoryPool) </h4><br>  The Zenject documentation has a whole <a href="">section</a> dedicated to factories.  This functionality is implemented at the level of the container itself, and it is also possible to create your custom factories.  Let's take a look at the first example from the documentation: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> { DiContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enemy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container</span></span></span><span class="hljs-function">)</span></span> { Container = container; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = Container.Resolve&lt;Player&gt;(); WalkTowards(player.Position); ... etc. } }</code> </pre> <br>  Already in this example there is a gross violation of DI.  But this is rather an example of how to make a fully custom factory.  What is the main problem here? <br><blockquote>  A DI container may be mistakenly considered a service locator, but it should only be used as a mechanism for building object graphs.  If we consider the container from this point of view, it makes sense to limit its use only to the layout root.  This approach has the important advantage that it eliminates any binding between the container and the rest of the application code. </blockquote>  Let's turn to how the built-in factories from Zenject work.  For this, there is an IFactory interface, the implementation of which leads us to the PlaceholderFactory class: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlaceholderFactory</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TValue</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IPlaceholderFactory</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IProvider provider, InjectContext injectContext</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  In it, we see the InjectContext parameter with many constructors, of the form: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InjectContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container, Type memberType</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = container; MemberType = memberType; }</code> </pre> <br>  And again, we get the transfer of the container itself as a dependency class.  This approach is a gross violation of the DI and the partial transformation of the container into the Service Locator. <br>  In addition, the disadvantage of this solution is that the container is used to create short-term dependencies, and should only create long-term dependencies. <br><br>  To avoid such violations, the authors of the container could completely exclude the possibility of transferring the container as a dependency to all registered classes.  It would be easy to implement this, given that the entire container works by means of reflection and analysis of the parameters of methods and constructors for creating and assembling an application object graph. <br><br><h4>  Method Implementation </h4><br>  The logic of the implementation of the Method implementation in Zenject is as follows: first, the constructor is implemented in all classes, then the properties are introduced, and finally the methods are implemented.  Consider the implementation example provided in the documentation: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBar bar, Qux qux</span></span></span><span class="hljs-function">)</span></span> { _bar = bar; _qux = qux; } }</code> </pre> <br>  What are the disadvantages here: <br><br><ul><li>  You can write arbitrarily methods that will be implemented within a single class.  Thus, as in the case of the implementation of the property, we are able to make as many cyclic dependencies as possible. </li><li>  Like the implementation of a property, the implementation of the method is implemented according to the attribute, which connects your code with the code of the container itself. </li><li>  The implementation of the method in Zenject is used only as an alternative to constructors, which is convenient in the case of MonoBehaviour classes, but absolutely contradicts the theory described by Mark Siman.  A classic example of a canonical method implementation is the use of factories (factory methods). </li><li>  If there are several implemented methods in the class, or there is also a constructor besides the method, it turns out that the dependencies needed by the class will be scattered in different places, which will prevent us from perceiving the whole picture.  That is, if class 1 has a constructor, then the number of its parameters can visually show whether there is a design error in the class, and whether the principle of sole responsibility is violated, and if the dependencies are scattered by several methods, the constructor, or maybe even a couple of properties, then the picture will not be as obvious as it could be. </li></ul><br>  It follows that the presence of such an implementation of the implementation of the method in a container that contradicts the DI theory does not have a single plus.  With a big reservation, a plus can only be considered the possibility of using the embedded method as a constructor for MonoBehaviour.  But this is quite a controversial point, because from the point of view of container logic, DI patterns and Unity3D internal memory management, all MonoBehaviour objects of your application can be considered managed resources, and in this case, it will be much more efficient to delegate the life cycle management of such objects not to a DI container, but to an auxiliary class (be it a Wrapper, ViewModel, Fasade, or something else). <br><br><h4>  Global bindings </h4><br>  This is a fairly convenient auxiliary functionality that allows you to set global binders that can live independently from the transition between scenes.  Details can be read <a href="https://github.com/svermeulen/Zenject">in the documentation</a> .  This functionality is extremely convenient and quite useful.  It is worth noting that it does not violate the patterns and principles of DI, however, it has an unobvious and ugly implementation.  The bottom line is that you create a special kind of prefab, attach a script with the container configuration (Installer) to it and save it in a strictly defined project folder, without the ability to move it somewhere and without any references to it.  The disadvantage of this instrument lies solely in its implicitness.  When it comes to regular installers, everything is pretty simple: on the stage you have an object, the installer script hangs on it.  If a new developer comes to the project, then the installer becomes an excellent point to dive into the project.  The developer can, on the basis of a single installer, make an idea of ‚Äã‚Äãwhich modules the project consists of and how the object graph is built.  But with the use of global binding, the installer on the scene ceases to be a sufficient source of this information.  There are no references to the global binding in the code of other installers (present on the scenes) and therefore, you do not see the full graph of objects.  And only in the course of the analysis of classes, you understand that the part of the binding is not enough in the insteller on the stage.  Once again I will make a reservation that this flaw is purely cosmetic. <br><br><h4>  Identifiers </h4><br>  The ability to specify a specific binding identifier in order to get a certain dependence in the class from the set of similar dependencies.  Example: <br><br><pre> <code class="cs hljs">Container.Bind&lt;IFoo&gt;().WithId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>).To&lt;Foo1&gt;().AsSingle(); Container.Bind&lt;IFoo&gt;().To&lt;Foo2&gt;().AsSingle(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar1</span></span> { [Inject(Id = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>)] IFoo _foo; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar2</span></span> { [Inject] IFoo _foo; }</code> </pre> <br>  This functionality can actually be situationally useful, and comes as an additional option for the implementation of properties.  However, along with the convenience, it inherits all the problems identified in the ‚ÄúImplementing Properties‚Äù item, adding even greater code connectivity by means of introducing some constant that must be remembered when configuring your code.  By accidentally deleting this identifier, you can easily get a non-working from the working application. <br><br><h4>  Signals and ITickable </h4><br>  Signals are an analogue of the ‚ÄúEvent Aggregator‚Äù mechanism built into the container.  The idea of ‚Äã‚Äãimplementing this functionality is undoubtedly noble, as it aims to reduce the number of connections between objects that communicate by means of the subscription-event mechanism.  A rather voluminous example can be viewed in the <a href="">documentation</a> , however, it will not be in the article, because the concrete implementation does not matter. <br><br>  ITickable interface support - replacing standard Update, LateUpdate and FixedUpdate methods in Unity by delegating calls to update objects with the ITickable interface to the container.  An example is also in the <a href="https://github.com/svermeulen/Zenject">documentation</a> , and its implementation in the context of the article also does not matter. <br><br>  The problem of Signals and ITickable does not concern the aspects of their implementation, its root lies in using the side effects of container operation.  At its core, the container is aware of almost all classes and their instances within the project, but its responsibility is to create a graph of objects and manage their life cycle.  Adding mechanisms by the type of Signals, ITickable, and so on, we are adding more and more responsibility to the container, and we are increasingly tying the application code onto it, making it an exclusive and irreplaceable part of the code, practically a ‚ÄúDivine Object‚Äù. <br><br><h3>  Instead of output </h3><br><blockquote>  The most important thing about containers is to understand that the use of DI does not depend on the use of the container DI.  An application can be built from many loosely coupled classes and modules, and none of these modules need to know anything about the container. </blockquote>  Be careful when using ready-made (boxed) solutions or small plug-ins.  Use them thoughtfully.  After all, similar theoretical mistakes and blots can sin even more ambitious things that you rely on (for example, the game engines of the scale of Unity3D itself).  And this, ultimately, will not affect the work of the solution you use, but the sustainability, performance and quality of your final product.  I hope everyone who read to the end, the article will be useful or, at least, will not be sorry for the time spent on reading it. </div><p>Source: <a href="https://habr.com/ru/post/420235/">https://habr.com/ru/post/420235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420223/index.html">A few simple tips: how to prevent a drone from crashing</a></li>
<li><a href="../420225/index.html">Infinite algorithmic melody based on prime numbers</a></li>
<li><a href="../420227/index.html">Turkish President announced a ban on the import of electronics from the US</a></li>
<li><a href="../420229/index.html">Can children in villages become programmers if they are taught only to railway workers? Talk with "Circle"</a></li>
<li><a href="../420233/index.html">UE4 | Inventory for multiplayer # 5 | Information transfer between Server and Client</a></li>
<li><a href="../420237/index.html">Qt wrapper around gRPC framework in C ++</a></li>
<li><a href="../420239/index.html">Mobile development. Swift: the mystery of the protocols</a></li>
<li><a href="../420243/index.html">Breakthrough Philanthropy: Breakthrough projects on a scale of Humanity</a></li>
<li><a href="../420245/index.html">How to prevent memory overruns when using Java collections</a></li>
<li><a href="../420247/index.html">Is it worth it to go to a specialist in the Far East</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>