<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fur rendering using Shells and Fins algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My today's post on programming graphics will not be as voluminous as the previous ones. In almost any difficult business, there is sometimes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fur rendering using Shells and Fins algorithm</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a1e/0b8/486/a1e0b8486a8ff4b126a8fbe24c24a749.png" alt="image" align="right">  Hi, Habr!  My today's post on programming graphics will not be as voluminous as the previous ones.  In almost any difficult business, there is sometimes a place for frivolous, and today we will render the seals.  More precisely, I want to talk about the implementation of the algorithm rendering fur Shells and Fins (SAF) traditionally for Direct3D 11 and OpenGL 4. For details, I ask under the cat. <br><a name="habracut"></a><br>  The SAF fur rendering algorithm, as the name implies, consists of 2 parts: the rendering of shells and the rendering of fins.  Perhaps some of these names seem funny, but they fully reflect what is created by the algorithm to create the illusion of a fleecy surface.  More details on the implementation of the algorithm for Direct3D 10 can be found in the <a href="http://developer.download.nvidia.com/SDK/10.5/direct3d/Source/Fur/doc/FurShellsAndFins.pdf">article and the NVidia</a> demo, my demo for Direct3D 11 and OpenGL 4 can be found <a href="https://github.com/rokuz/GraphicsDemo">here</a> .  The project is called Demo_Fur.  You will need Visual Studio 2012/2013 and <a href="http://www.cmake.org/">CMake</a> to build. <br><br><h4>  Shells and Fins algorithm </h4><br>  The fur consists of a huge number of hairs, to draw each of them separately at the current moment is not possible in real time, although NVidia had certain <a href="http.developer.nvidia.com/GPUGems2/gpugems2_chapter23.html">attempts</a> .  In order to create the illusion of a fleecy surface, a technology is applied, somewhat resembling voxel rendering.  A three-dimensional texture is prepared, which is a small area of ‚Äã‚Äãthe fur surface.  Each voxel in it determines the likelihood of villi passing through itself, which, from a graphical point of view, determines the value of transparency at a particular point during rendering.  Such a three-dimensional texture can be generated (one of the methods described <a href="http://steps3d.narod.ru/tutorials/fur-tutorial.html">here</a> ).  A natural question arises how to render this texture.  For this, ‚Äúshells‚Äù are drawn around the geometry, i.e.  copies of the original geometry, formed by scaling this geometry to small values.  It turns out a kind of matryoshka, on each layer of which is superimposed a layer of three-dimensional texture of fur.  Layers are drawn in series with alpha blending turned on, which results in some illusion of fleecy.  However, this is not enough for the material to resemble fur.  To achieve the goal, you must select the correct lighting model. <br>  Fur belongs to the category of pronounced anisotropic materials.  Classical lighting models (for example, the <a href="http://en.wikipedia.org/wiki/Blinn%25E2%2580%2593Phong_shading_model">Blinna-Phong</a> model) treat surfaces as isotropic, i.e.  surface properties do not depend on its orientation.  In practice, this means that when the plane is rotated around its normal, the nature of the illumination does not change.  Illumination models of this class for calculating the shadows use the angle between the normal and the direction of light incidence.  Anisotropic lighting models use tangents (vectors perpendicular to the normals, which together with the normals and binormals form the basis) to calculate the illumination.  Read more about anisotropic lighting <a href="http://steps3d.narod.ru/tutorials/anisotropic-tutorial.html">here</a> . <br>  Anisotropic illumination is calculated separately for each fur layer.  The values ‚Äã‚Äãof the tangent at one or another point on the surface are determined using a tangent map.  The tangent map is formed in much the same way as the well-known <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25BB%25D1%258C%25D0%25B5%25D1%2584%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D1%2583%25D1%2580%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">normal map</a> .  In the case of fur texture, the tangent vector will be the normalized direction of the hair.  Thus, the three-dimensional texture of the fur will contain 4 channels.  A packed tangent vector will be stored in RGB, the alpha channel will contain the probability of passing the villus through this point.  Add to this an account of the self-shadowing of the fur and get quite realistic looking material. <br>  The illusion will be broken if the person carefully looks at the outer edges of the object.  At certain angles between the faces in a situation where one face is visible and the other is not, fur layers may be invisible to the observer.  In order to avoid this situation, additional geometry is formed on such edges, which is drawn along their normals.  The result is somewhat similar to the fins of the fish, which determined the second part of the algorithm name. <br><br><h4>  Implementation on Direct3D 11 and OpenGL 4 </h4><br>  The implementations on both APIs are generally identical, only minor details differ.  Rendering will be done according to the following scheme: <br><ol><li>  Rendering the uncovered parts of the scene.  In my demo for such parts the standard lighting model Blinna-Phong is used. </li><li>  Rendering fins.  We will implement geometry extrusion using a geometry shader.  To understand whether it is necessary to draw an edge between two polygons, it is necessary to determine whether this edge is external to the object.  A sign of this will be the values ‚Äã‚Äãof the angles between the normals to the polygons and the normalized vector of vision.  If these values ‚Äã‚Äãhave a different sign, then the edge will be external, and therefore it must be pulled out.  Geometric shaders in Direct3D and OpenGL can work with a limited number of primitives.  We need to simultaneously process 2 adjacent polygons with one common edge.  To represent this structure, 4 vertices are minimally needed, which is graphically shown in the figure below on the left. <br><img src="https://habrastorage.org/getpro/habr/post_images/0be/c2e/7b0/0bec2e7b09abd0cfaacdc1c4909d4de1.png"><br>  The right side of the figure shows the extrusion of a common edge 1-2 and the formation of two new polygons 1-5-6 and 1-6-2. <br>  The primitive that consists of 4 vertices is D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ (GL_LINES_ADJACENCY in OpenGL).  In order to use it, we need to prepare a special index buffer.  It is rather simple to build such a buffer if there are data on the contiguity of triangles in the 3D model.  The index buffer will contain groups of 4 indices describing 2 adjacent triangles. <br>  It is important to note here that it is not possible to easily obtain adjacency data for any model.  For most smoothed models, this is not a problem, however, at the edges of the smoothing groups, vertices are usually duplicated to achieve proper lighting.  This means the actual lack of adjacency in the index buffer in the presence of visual adjacency.  In this case, it is necessary to look for adjacent triangles, guided not only by indices, but also by the actual location of the vertices in space.  This task is no longer so trivial, since in this case as many triangles can divide into one face. <br>  Geometric shaders for pulling "fins" are listed below under the spoilers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">HLSL Geometry Shader for Direct3D 11</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;common.h.hlsl&gt; struct GS_INPUT { float4 position : SV_POSITION; float2 uv0 : TEXCOORD0; float3 normal : TEXCOORD1; }; struct GS_OUTPUT { float4 position : SV_POSITION; float3 uv0 : TEXCOORD0; }; texture2D furLengthMap : register(t0); SamplerState defaultSampler : register(s0); [maxvertexcount(6)] void main(lineadj GS_INPUT pnt[4], inout TriangleStream&lt;GS_OUTPUT&gt; triStream) { float3 c1 = (pnt[0].position.xyz + pnt[1].position.xyz + pnt[2].position.xyz) / 3.0f; float3 c2 = (pnt[1].position.xyz + pnt[2].position.xyz + pnt[3].position.xyz) / 3.0f; float3 viewDirection1 = -normalize(viewPosition - c1); float3 viewDirection2 = -normalize(viewPosition - c2); float3 n1 = normalize(cross(pnt[0].position.xyz - pnt[1].position.xyz, pnt[2].position.xyz - pnt[1].position.xyz)); float3 n2 = normalize(cross(pnt[1].position.xyz - pnt[2].position.xyz, pnt[3].position.xyz - pnt[2].position.xyz)); float edge = dot(n1, viewDirection1) * dot(n2, viewDirection2); float furLen = furLengthMap.SampleLevel(defaultSampler, pnt[1].uv0, 0).r * FUR_LENGTH; if (edge &gt; 0 &amp;&amp; furLen &gt; 1e-3) { GS_OUTPUT p[4]; p[0].position = mul(pnt[1].position, modelViewProjection); p[0].uv0 = float3(pnt[1].uv0, 0); p[1].position = mul(pnt[2].position, modelViewProjection); p[1].uv0 = float3(pnt[2].uv0, 0); p[2].position = mul(float4(pnt[1].position.xyz + pnt[1].normal * furLen, 1), modelViewProjection); p[2].uv0 = float3(pnt[1].uv0, 1); p[3].position = mul(float4(pnt[2].position.xyz + pnt[2].normal * furLen, 1), modelViewProjection); p[3].uv0 = float3(pnt[2].uv0, 1); triStream.Append(p[2]); triStream.Append(p[1]); triStream.Append(p[0]); triStream.RestartStrip(); triStream.Append(p[1]); triStream.Append(p[2]); triStream.Append(p[3]); triStream.RestartStrip(); } }</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">GLSL Geometry Shader for OpenGL 4.3</b> <div class="spoiler_text"><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">430</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(lines_adjacency) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(triangle_strip, max_vertices = <span class="hljs-number"><span class="hljs-number">6</span></span>) out; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> VS_OUTPUT { vec2 uv0; vec3 normal; } gsinput[]; out vec3 texcoords; const <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> FUR_LAYERS = <span class="hljs-number"><span class="hljs-number">16.0</span></span>f; const <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> FUR_LENGTH = <span class="hljs-number"><span class="hljs-number">0.03</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 modelViewProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D furLengthMap; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec3 viewPosition; void main() { vec3 c1 = (gl_in[<span class="hljs-number"><span class="hljs-number">0</span></span>].gl_Position.xyz + gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position.xyz + gl_in[<span class="hljs-number"><span class="hljs-number">2</span></span>].gl_Position.xyz) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>f; vec3 c2 = (gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position.xyz + gl_in[<span class="hljs-number"><span class="hljs-number">2</span></span>].gl_Position.xyz + gl_in[<span class="hljs-number"><span class="hljs-number">3</span></span>].gl_Position.xyz) / <span class="hljs-number"><span class="hljs-number">3.0</span></span>f; vec3 viewDirection1 = -<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(viewPosition - c1); vec3 viewDirection2 = -<span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(viewPosition - c2); vec3 n1 = <span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(gl_in[<span class="hljs-number"><span class="hljs-number">0</span></span>].gl_Position.xyz - gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position.xyz, gl_in[<span class="hljs-number"><span class="hljs-number">2</span></span>].gl_Position.xyz - gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position.xyz)); vec3 n2 = <span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span>(gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position.xyz - gl_in[<span class="hljs-number"><span class="hljs-number">2</span></span>].gl_Position.xyz, gl_in[<span class="hljs-number"><span class="hljs-number">3</span></span>].gl_Position.xyz - gl_in[<span class="hljs-number"><span class="hljs-number">2</span></span>].gl_Position.xyz)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> edge = <span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(n1, viewDirection1) * <span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(n2, viewDirection2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> furLen = texture(furLengthMap, gsinput[<span class="hljs-number"><span class="hljs-number">1</span></span>].uv0).r * FUR_LENGTH; vec4 p[<span class="hljs-number"><span class="hljs-number">4</span></span>]; vec3 uv[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; furLen &gt; <span class="hljs-number"><span class="hljs-number">1e-3</span></span>) { p[<span class="hljs-number"><span class="hljs-number">0</span></span>] = modelViewProjectionMatrix * vec4(gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position.xyz, <span class="hljs-number"><span class="hljs-number">1</span></span>); uv[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vec3(gsinput[<span class="hljs-number"><span class="hljs-number">1</span></span>].uv0, <span class="hljs-number"><span class="hljs-number">0</span></span>); p[<span class="hljs-number"><span class="hljs-number">1</span></span>] = modelViewProjectionMatrix * vec4(gl_in[<span class="hljs-number"><span class="hljs-number">2</span></span>].gl_Position.xyz, <span class="hljs-number"><span class="hljs-number">1</span></span>); uv[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vec3(gsinput[<span class="hljs-number"><span class="hljs-number">2</span></span>].uv0, <span class="hljs-number"><span class="hljs-number">0</span></span>); p[<span class="hljs-number"><span class="hljs-number">2</span></span>] = modelViewProjectionMatrix * vec4(gl_in[<span class="hljs-number"><span class="hljs-number">1</span></span>].gl_Position.xyz + gsinput[<span class="hljs-number"><span class="hljs-number">1</span></span>].normal * furLen, <span class="hljs-number"><span class="hljs-number">1</span></span>); uv[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vec3(gsinput[<span class="hljs-number"><span class="hljs-number">1</span></span>].uv0, FUR_LAYERS - <span class="hljs-number"><span class="hljs-number">1</span></span>); p[<span class="hljs-number"><span class="hljs-number">3</span></span>] = modelViewProjectionMatrix * vec4(gl_in[<span class="hljs-number"><span class="hljs-number">2</span></span>].gl_Position.xyz + gsinput[<span class="hljs-number"><span class="hljs-number">2</span></span>].normal * furLen, <span class="hljs-number"><span class="hljs-number">1</span></span>); uv[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vec3(gsinput[<span class="hljs-number"><span class="hljs-number">2</span></span>].uv0, FUR_LAYERS - <span class="hljs-number"><span class="hljs-number">1</span></span>); gl_Position = p[<span class="hljs-number"><span class="hljs-number">2</span></span>]; texcoords = uv[<span class="hljs-number"><span class="hljs-number">2</span></span>]; EmitVertex(); gl_Position = p[<span class="hljs-number"><span class="hljs-number">1</span></span>]; texcoords = uv[<span class="hljs-number"><span class="hljs-number">1</span></span>]; EmitVertex(); gl_Position = p[<span class="hljs-number"><span class="hljs-number">0</span></span>]; texcoords = uv[<span class="hljs-number"><span class="hljs-number">0</span></span>]; EmitVertex(); EndPrimitive(); gl_Position = p[<span class="hljs-number"><span class="hljs-number">1</span></span>]; texcoords = uv[<span class="hljs-number"><span class="hljs-number">1</span></span>]; EmitVertex(); gl_Position = p[<span class="hljs-number"><span class="hljs-number">2</span></span>]; texcoords = uv[<span class="hljs-number"><span class="hljs-number">2</span></span>]; EmitVertex(); gl_Position = p[<span class="hljs-number"><span class="hljs-number">3</span></span>]; texcoords = uv[<span class="hljs-number"><span class="hljs-number">3</span></span>]; EmitVertex(); EndPrimitive(); } }</code> </pre></div></div><br><br></li><li>  Rendering "shells".  Obviously, to obtain the proper number of layers of fur, the geometry must be drawn several times.  For multiple drawing of geometry we will use hardware instansing.  In order to determine which fur layer is drawn in the shader, it suffices to use the semantics of SV_InstanceID in Direct3D and the gl_InstanceID variable in OpenGL. <br>  To illuminate the fur, I used the Kajiya-Kay anisotropic model.  An important detail was the use of a special texture to set the length of the fur.  This texture is necessary to prevent the appearance of long fur in unexpected places (for example, around the cat's eyes).  Pixel and fragment shaders for calculating the fur lighting are listed below under the spoilers. <br><br><div class="spoiler">  <b class="spoiler_title">HLSL pixel shader for Direct3D 11</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;common.h.hlsl&gt; struct PS_INPUT { float4 position : SV_POSITION; float3 uv0 : TEXCOORD0; float3 tangent : TEXCOORD1; float3 normal : TEXCOORD2; float3 worldPos : TEXCOORD3; }; texture2D diffuseMap : register(t1); texture3D furMap : register(t2); SamplerState defaultSampler : register(s0); float4 main(PS_INPUT input) : SV_TARGET { const float specPower = 30.0; float3 coords = input.uv0 * float3(FUR_SCALE, FUR_SCALE, 1.0f); float4 fur = furMap.Sample(defaultSampler, coords); clip(fur.a - 0.01); float4 outputColor = float4(0, 0, 0, 0); outputColor.a = fur.a * (1.0 - input.uv0.z); outputColor.rgb = diffuseMap.Sample(defaultSampler, input.uv0.xy).rgb; float3 viewDirection = normalize(input.worldPos - viewPosition); float3x3 ts = float3x3(input.tangent, cross(input.normal, input.tangent), input.normal); float3 tangentVector = normalize((fur.rgb - 0.5f) * 2.0f); tangentVector = normalize(mul(tangentVector, ts)); float TdotL = dot(tangentVector, light.direction); float TdotE = dot(tangentVector, viewDirection); float sinTL = sqrt(1 - TdotL * TdotL); float sinTE = sqrt(1 - TdotE * TdotE); outputColor.xyz = light.ambientColor * outputColor.rgb + light.diffuseColor * (1.0 - sinTL) * outputColor.rgb + light.specularColor * pow(abs((TdotL * TdotE + sinTL * sinTE)), specPower) * FUR_SPECULAR_POWER; float shadow = input.uv0.z * (1.0f - FUR_SELF_SHADOWING) + FUR_SELF_SHADOWING; outputColor.rgb *= shadow; return outputColor; }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">GLSL Fragment Shader for OpenGL 4.3</b> <div class="spoiler_text"><pre> <code class="hljs xml">#version 430 core in VS_OUTPUT { vec3 uv0; vec3 normal; vec3 tangent; vec3 worldPos; } psinput; out vec4 outputColor; const float FUR_LAYERS = 16.0f; const float FUR_SELF_SHADOWING = 0.9f; const float FUR_SCALE = 50.0f; const float FUR_SPECULAR_POWER = 0.35f; // lights struct LightData { vec3 position; uint lightType; vec3 direction; float falloff; vec3 diffuseColor; float angle; vec3 ambientColor; uint dummy; vec3 specularColor; uint dummy2; }; layout(std430) buffer lightsDataBuffer { LightData lightsData[]; }; uniform sampler2D diffuseMap; uniform sampler2DArray furMap; uniform vec3 viewPosition; void main() { const float specPower = 30.0; vec3 coords = psinput.uv0 * vec3(FUR_SCALE, FUR_SCALE, 1.0); vec4 fur = texture(furMap, coords); if (fur.a <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0.01</span></span></span><span class="hljs-tag">) </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">discard</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">float</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">d</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">psinput.uv0.z</span></span></span><span class="hljs-tag"> / </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">FUR_LAYERS</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">outputColor</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">vec4(texture(diffuseMap,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">psinput.uv0.xy</span></span></span><span class="hljs-tag">)</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.rgb</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fur.a</span></span></span><span class="hljs-tag"> * (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1.0</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">d</span></span></span><span class="hljs-tag">)); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">vec3</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">viewDirection</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">normalize(psinput.worldPos</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">viewPosition</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">vec3</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tangentVector</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">normalize((fur.rgb</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0.5</span></span></span><span class="hljs-tag">) * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2.0</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mat3</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ts</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">mat3(psinput.tangent,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cross</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">psinput.normal</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">psinput.tangent</span></span></span><span class="hljs-tag">), </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">psinput.normal</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tangentVector</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">normalize(ts</span></span></span><span class="hljs-tag"> * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tangentVector</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">float</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TdotL</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">dot(tangentVector,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lightsData</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.direction</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">float</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TdotE</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">dot(tangentVector,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">viewDirection</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">float</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sinTL</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">sqrt(1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TdotL</span></span></span><span class="hljs-tag"> * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TdotL</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">float</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sinTE</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">sqrt(1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TdotE</span></span></span><span class="hljs-tag"> * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TdotE</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">outputColor.rgb</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">lightsData[0].ambientColor</span></span></span><span class="hljs-tag"> * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">outputColor.rgb</span></span></span><span class="hljs-tag"> + </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lightsData</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.diffuseColor</span></span></span><span class="hljs-tag"> * (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1.0</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sinTL</span></span></span><span class="hljs-tag">) * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">outputColor.rgb</span></span></span><span class="hljs-tag"> + </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lightsData</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.specularColor</span></span></span><span class="hljs-tag"> * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pow</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">abs</span></span></span><span class="hljs-tag">((</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TdotL</span></span></span><span class="hljs-tag"> * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TdotE</span></span></span><span class="hljs-tag"> + </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sinTL</span></span></span><span class="hljs-tag"> * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">sinTE</span></span></span><span class="hljs-tag">)), </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">specPower</span></span></span><span class="hljs-tag">) * </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">FUR_SPECULAR_POWER</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">float</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">shadow</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">d</span></span></span><span class="hljs-tag"> * (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1.0</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">FUR_SELF_SHADOWING</span></span></span><span class="hljs-tag">) + </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">FUR_SELF_SHADOWING</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">outputColor.rgb</span></span></span><span class="hljs-tag"> *= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">shadow;</span></span></span><span class="hljs-tag"> }</span></span></code> </pre></div></div></li></ol><br>  As a result, we can get such seals. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89c/5c1/c3f/89c5c1c3fb1438dc82dab620df840144.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/c77/b2e/6cb/c77b2e6cbc892c97f98d9400dddb9eba.jpg"><br><br>  For comparison, the picture on the right shows the rendering of a cat using the Blinna-Phong model using normal maps. <br><img src="https://habrastorage.org/getpro/habr/post_images/55c/4c7/608/55c4c7608ede2fcd3ea5b9a99aeb3577.jpg"><br><br><h4>  Performance </h4><br>  The SAF algorithm is quite simple to implement, but it can significantly complicate the life of a video card.  Each model will be drawn several times to obtain a specified number of layers of fur (I used 16 layers).  In the case of complex geometry, this can be a significant performance drop.  In the cat model used, the fur-covered part occupies approximately 3,000 polygons, therefore, about 48,000 polygons will be drawn for rendering the skin.  When drawing "fins", the most simple geometric shader is not used, which can also affect the case of a highly detailed model. <br>  Performance measurements were taken on a computer with the following configuration: AMD Phenom II X4 970 3.79GHz, 16Gb RAM, AMD Radeon HD 7700 Series, Windows 8.1. <br><br>  Average frame time.  1920x1080 / MSAA 8x / full screen <br><table><tbody><tr><th>  API / Number of cats </th><th>  one </th><th>  25 </th><th>  100 </th></tr><tr><td>  Direct3d 11 </td><td>  2.73615ms </td><td>  14.3022ms </td><td>  42.8362ms </td></tr><tr><td>  Opengl 4.3 </td><td>  2.5748ms </td><td>  13.4807ms </td><td>  34.2388ms </td></tr></tbody></table><br>  Overall, the implementation on OpenGL 4 roughly corresponds to the implementation on Direct3D 11 in terms of performance on an average and a small number of objects.  On a large number of objects, implementation on OpenGL runs slightly faster. <br><br><h4>  Conclusion </h4><br>  The SAF algorithm is one of the few ways to implement fur in interactive rendering.  However, it cannot be said that the algorithm is necessary to the overwhelming number of games.  To date, a similar level of quality (and perhaps even higher) is achieved with the help of art and skilled hands of a graphic designer.  The combination of translucent planes with well-chosen textures for representing hair and fur is the standard of modern games, and the considered algorithm and its variations are rather a matter of the games of the future. </div><p>Source: <a href="https://habr.com/ru/post/228753/">https://habr.com/ru/post/228753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228729/index.html">How to hear electromagnetic waves</a></li>
<li><a href="../228733/index.html">What to read at your leisure. Gaming Industry News Digest for June</a></li>
<li><a href="../228735/index.html">EFF sues NSA for not disclosing 0day vulnerabilities</a></li>
<li><a href="../228745/index.html">Chinese scientists hope to send an improved version of their lunar rover to Mars</a></li>
<li><a href="../228751/index.html">TJ Holowaychuk: Goodbye Node.js</a></li>
<li><a href="../228755/index.html">ISEE-3. 17 years of sleep</a></li>
<li><a href="../228757/index.html">Some interesting and useful things for web developer # 21</a></li>
<li><a href="../228761/index.html">MKI game station: an exhibition of game consoles at the Exhibition of Economic Achievements, where almost everything can be touched</a></li>
<li><a href="../228771/index.html">Tricky canister</a></li>
<li><a href="../228777/index.html">Solitaire finances sing romance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>