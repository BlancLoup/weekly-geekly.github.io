<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the component-oriented approach to programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Unity Engine itself (hereinafter Unity), like many other game engines, is most suited to component-oriented programming (hereinafter referred to a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the component-oriented approach to programming</h1><div class="post__text post__text-html js-mediator-article">  The Unity Engine itself (hereinafter Unity), like many other game engines, is most suited to component-oriented programming (hereinafter referred to as the CPC), since the Behavioral Pattern is one of the basic patterns of the engine architecture, along with the ‚ÄúComponent‚Äù pattern from the Decoupling Patterns classification.  Therefore, the component is the basic unit for the implementation of business logic in Unity.  In this article I will talk about how to apply the CPC in Unity. <br><a name="habracut"></a><br><habracut>  In general, CPC can be viewed as the development of OOP principles with the elimination of a problem area known as the fragile base class.  In turn, the development of CPC can be considered Service-oriented programming.  But back to the topic.  It should be immediately noted that KOP-KOP, but never forget the principles of GRASP, SOLID and others. <br><br>  We will call the component a class inherited from MonoBehaviour.  Here the very name of the base class is very well chosen, makes it clear that this behavior, and says that it is executed by the .mono platform.  But it is very convenient to assume that MONO is one thing, * one * behavior.  And the first thing you need to pay attention to when developing components: one component - one behavior.  The sole responsibility principle of SOLID and high cohesion of methods within a class by GRASP in action. <br><br>  Now pay attention to GRASP.  Programming should be at the level of abstractions, not specific implementations (Low Coupling).  And even seemingly simple gameplay requires the creation of UML interface diagrams.  What for?  Is it not excessive, the principle of ‚ÄúYAGNI‚Äù (You Ain't Gonna Need It) does not give rest.  Not superfluous when justified.  Who comes up with the game?  Game designers, these insidious people of civilian appearance.  And it does not happen that they do not change anything.  Because you need to be ready for change, but more often you need to be ready to expand the game logic.  Moreover, all these changes will not be made immediately, but then, when the developers themselves already forget why it was done this way and not otherwise.  Therefore, UML diagrams, even abstractions, should always be done: this is the project documentation.  I will develop the UML diagrams in Visual Studio in order to later generate C # code from them. <br>  So, let's start developing the game;  for example, create core gameplay of the tower defense game.  There are different approaches to the development steps, I will use the abbreviated version. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  First step: problem statement </h4><br>  No matter how many multipage documentation is created for the game, you should always be able to select the main thing.  A rough description of the gameplay, of course, is better divided into use case: <br>  The player must not allow enemies to destroy the House.  For this, he must place the towers that will destroy the enemies that fell within the radius of action.  At the same time one tower can attack only one enemy.  When he dies or goes out of range of the tower, the next available one is selected.  Enemies appear in waves, with each wave their number increases.  Enemies are moving from the point of appearance along the road to the House.  Going to the house begin to destroy it.  When the house is destroyed - the game is over. <br><br><h4>  Second step: problem analysis </h4><br>  Let's start with the study of the main thing: towers, creeps and houses.  So, having created a scene with already placed game objects (towers and a house), we should get the result: creeps appear, move to the house, dying on the way from the damage of the towers, and reaching the house, cause it damage.  At death, the creep disappears from the scene.  With the destruction of the house or the installation of all creeps - the game is over. <br><br>  Select the main game entities, we indicate their properties and behavior: <br><br>  1) Tower.  Properties: damage, cooldown between shots, radius of target selection, target selection logic. <br>  Behavior: target selection and target attack. <br>  Also, for a variety of gameplay there will be different types of towers: by damage, damage radius and target selection logic. <br>  2) Creep.  Properties: HP, damage, cooldown between attacks, movement speed. <br>  Behavior: Moving the route to the House.  Attack at home when approaching him closely.  When HP = 0, is considered killed. <br>  Different types of creeps - for example, on HP. <br>  3) Home.  Properties: HP. <br>  Behavior: When HP = 0, the player lost. <br><br><h4>  The third step: decomposition </h4><br>  I believe that the correct decomposition of tasks is very important.  Most of the time it is worth spending on the elaboration of abstractions and the logical connection between them. <br><br>  Let's start with the generalization of behavior, to identify what should be the components. <br><br>  1) There are two entities in the game that have damage behavior: tower and creep.  Highlight this behavior in the component, here is its interface: <br><br><img src="https://habrastorage.org/files/3ad/eec/fd0/3adeecfd0afe44dfbdff2055a37519ce.png"><br><br>  Stand still, someone will say: ‚ÄúWhat about encapsulation?  It turns out that anyone can change the cooldown and damage? ‚ÄùNo, only the game designer, setting up the component properties in an intuitive way.  Therefore, all properties will only get to display information in the UI, and the set will not be needed.  In addition, Unity will not be able to display properties in the inspector with the specified get / set construct, and you will need to create fields marked with [SerializeField].  And rightly so, other classes from the code will not be able to change the value of the property. <br><br>  Let's go back to the component.  Someone will trigger the launch of this behavior and stop it, indicate the target, change the target.  But who? <br><br>  2) Since the logic of target selection will be different for different types of towers, and not only the tower, but the creep will use this behavior, it is necessary to distinguish two logical components. <br><br>  <i>The first</i> will work with physics, as soon as a creep enters the collider trigger, it adds it to the target queue, creating an event that the targets are said to have increased.  As soon as the creep leaves the affected area, remove this target from the queue, create an event that deletes the creep from the queue. <br><br>  Of course, this behavior is redundant for the house: the house will never run away.  Anyway.  Let's call this interface of the future ITrigger component.  With two Unity methods: OnTriggerEnter / OnTriggerExit. <br><br><img src="https://habrastorage.org/files/8e0/479/0e4/8e04790e4d0548f588d71637c84701a0.png"><br><br>  <i>The second</i> logical component will react to these events and use the IDamageDealer itself to inflict damage on the selected target and stop the infliction of damage. <br><br><img src="https://habrastorage.org/files/760/7ba/b65/7607bab655bc45d2bdb47de2236c3969.png"><br><br>  But how then can this second component choose a target differently, depending on the type of tower and, if at all, a creep?  A simple option is a certain universal method SelectTarget (Type of target selection logic (tower type, creep)), depending on the type of target selection logic, select it.  But versatility is not always good, especially when it comes to components.  Here, Interface Segregation Principle is recalled: several specific are better than one universal one.  Therefore, there will be different components for different behavior of target selection, united by one ITargetSelector interface. <br><br><img src="https://habrastorage.org/files/c75/6d0/010/c756d0010fbd4f798ccb751248fff835.png"><br><br>  KeepSelector: selects a home as a target. <br>  SimpleCreepSelector: selects the first target in the list. <br>  WeakCreepSelector: selects the weakest target to add it. <br><br>  Thus, it is easy to expand the core-gameplay of the mechanics of target selection (the basic mechanics, since only the towers differ from it).  However, there is another option to do with inheritance.  There will be a basic TargetSelector component with default logic for the tower.  And the KeepSelector and WeakCreepSelector classes will override the method of adding to the list of targets (to check the house or creep) and the method of selecting a target. <br><br>  3) The game has two entities that have the following behavior: when taking damage, the number of hit points decreases until it dies. <br><br><img src="https://habrastorage.org/files/186/c83/c43/186c83c4370048538e1587d3bb9b2ac3.png"><br><br>  Why do I need IsDead when I can just check the condition HP &lt;= 0?  Even in the current implementation in two places it is necessary to check the condition that the creep has not died.  Therefore, following the simple principle of DRY (Do not repeat yourself), we will not duplicate logic.  So it will be easier to change the logic, if you add any more conditions. <br><br>  In order to easily extend the method of applying damage in the future, let's give this behavior to another auxiliary component: <br><br><img src="https://habrastorage.org/files/760/7ba/b65/7607bab655bc45d2bdb47de2236c3969.png"><br><br>  So we can in the future combine two components, IHittable and IDamageDealer without inheritance and redefining the method of applying damage.  It‚Äôs also easy to extend behavior by assigning other components that implement IDamageDealer. <br><br>  4) One entity has a route movement behavior: IRouteFollower.  Properties: WayPoints [], Speed; <br><br>  5) Now we need to identify the component that will handle the logic of loss and winnings: check IsDead at home and all creeps, taking into account the wave number. <br><br><img src="https://habrastorage.org/files/772/426/181/772426181be84e8fa3b5a1eb13d9e334.png"><br><br>  In the implementation logic, at Start we will call the crypt spawn method, in Update we check how many creeps are dead from those that were spawned, and, taking into account the number of waves and the current wave, spun or say that the player won.  Also check whether the house is destroyed: if so, the player has lost. <br><br><h4>  Fourth step: implementation </h4><br>  Now you can make the implementation of the first version of the game.  However, someone will ask: ‚ÄúWhere are the Tower and Creep classes themselves?‚Äù. <br>  In Unity, we will create prefabs that are configured both visually (towers of different types, creeps, houses) and logically ‚Äî that is, with added components.  Also, the properties of the components must be configured, so there is no need to create separate classes.  But we need to understand (for the reaction in OnTriggerEnter / OnTriggerExit) what is creep and what is home.  For this purpose, Unity has tags.  Some are frustrated that only one game object can have one tag, but this is normal: do not make universal objects. <br><br>  We start the implementation with the generation of UML code diagrams, getting a dummy skeleton.  Then create an implementation of the behavior of the components.  Do not forget that it is better to use abstractions, rather than specific implementations, although this will increase connectivity.  An example of my implementation can be found here: <a href="https://github.com/sountex/COPTD">https://github.com/sountex/COPTD</a> <br><br>  So done.  And now how to expand the gameplay - say, adding the economy?  For the murder of the crypt now need to get money, and spend them on the construction of towers.  Do not rush to add new properties to the class that implements one of the creep behaviors.  Recall the principle of the sole responsibility of the class and highlight this new behavior into a new component.  By creating a new component, the behavior of which will include storing data on the amount of money brought in for the killing, we will make a better solution suitable for reuse.  A little about reuse.  For example, in the RTS - there are also units that do damage and take it, buildings.  Thanks to the component-oriented approach and abstraction, all created components are easy to use in games of another genre. <br><br><h4>  Next step: testing </h4><br>  To test the behavior of a game object as a set of components, BDD (Behavior-driven development) is most convenient.  And for testing separately Unit Test components.  But this is a separate topic. </habracut></div><p>Source: <a href="https://habr.com/ru/post/243479/">https://habr.com/ru/post/243479/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243465/index.html">Parsing Heads-up Display from the Recon Instruments MOD Live ski mask. Attempting to fix ...</a></li>
<li><a href="../243471/index.html">[LibGDX] Create Flappy Bird Clone - Zombie Bird</a></li>
<li><a href="../243473/index.html">Get Linux for three weeks</a></li>
<li><a href="../243475/index.html">Exposing Intel Advertising Article</a></li>
<li><a href="../243477/index.html">Service Ahoba.co has become a nominee in the competition "Startup of the Year 2014"!</a></li>
<li><a href="../243481/index.html">Reverse engineering GPS WatchLock lock for personal use</a></li>
<li><a href="../243483/index.html">We write and run ASP.NET vNext applications on Mac</a></li>
<li><a href="../243485/index.html">We are migrating file servers from Windows Server 2003 to Windows Server 2012 R2</a></li>
<li><a href="../243487/index.html">Installing, configuring and using chkrootkit vulnerability scanner</a></li>
<li><a href="../243489/index.html">How important commercial information flows away. Infographics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>