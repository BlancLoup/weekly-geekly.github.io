<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Idiom ranges</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Idiom ranges are extremely successful iterator development. It allows you to write high-performance code that does not allocate memory, where it is no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Idiom ranges</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b39/b45/b7a/b39b45b7a55a47559974bb8ce9280187.png" alt="image" align="right"><br>  Idiom ranges are extremely successful iterator development.  It allows you to write high-performance code that does not allocate memory, where it is not necessary, being at an extremely high level of abstraction.  In addition, it makes libraries much more versatile and their interfaces flexible.  Under the cat a brief description and practical examples of the use of idioms, performance tests, as well as a comparison with popular implementations of iterators in C ++ and C #. <br><a name="habracut"></a><br>  Further in the article, instead of the English ‚Äúrange‚Äù, the well-established translation ‚Äúrange‚Äù will be used.  It cuts a bit of hearing, and this word has many other meanings, but it is still better suited for Russian text. <br><br><h2>  Some theory </h2><br>  The article is extremely practical, but first we still synchronize the theory.  First, an understanding of <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B2%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">lazy computations</a> is required.  Secondly, structural typing is needed.  And if you can read about lazy calculations on the wiki and everything is very clear there, then there are problems with the accuracy of formulations of structural typing.  Very <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25BE%25D0%25B2">little</a> is written on the wiki. <br><br>  Here, by structural typing, we mean <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">duck typing</a> , but with verification at the compilation stage.  This is how the templates work in C ++ and D, the interfaces in Go.  That is, the function accepts arguments of all types, such that all the methods and operators used by the function can be called on the object.  Unlike the more common nominative typing, where it is necessary to specify a list of implementable interfaces, the structural one does not impose any type declaration requirements.  It is enough that with the object you can do what is used inside the function.  However, compatibility checking does not occur at runtime during a dynamic invocation, but at compile time.  If such a formulation is still not clear - it does not matter, practical application will be much clearer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  AB group calculation </h2><br><h3>  Formulation of the problem </h3><br>  Consider one simple task.  You need to write a function that calculates which AB group the user belongs to.  With AB testing, we need to split all users into several random groups.  Traditionally, this is done as follows: we consider the hash of the user id and the test id and take the remainder of the division by the number of groups.  Hash gives some randomization, and the use of the id test makes the splitting different for different tests.  If we discard all the details of the domain, we need a function that is formally described by the formula: <br><br><pre><code class="hljs swift">ab_group(groupId, userId, <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>) = hash(groupId + userId) % <span class="hljs-built_in"><span class="hljs-built_in">count</span></span></code> </pre> <br>  , where groupId and userId are strings, and count is a positive number.  Jenkins_one_at_a_time_hash is used as hash (). <br><br><h3>  Realization in the forehead </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ab_group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; testId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; uid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> concat = testId + uid; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> hashVal = string_hash32(concat.c_str(), concat.size()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashVal % count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_hash32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> hash, i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (hash = i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { hash += key[i]; hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>); hash ^= (hash &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>); } hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>); hash ^= (hash &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>); hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre><br>  The implementation of the hash function was honestly copied from somewhere, and everything else, as you see, requires only 3 lines of code.  This implementation solves the problem: the tests pass, the results are the same as previously calculated.  There is only one drawback - the speed of work.  The choice of C ++ is justified by the need to use the function from the infinidb plugin.  We needed to count the group on the fly for the entire user base.  It was expected that the function would produce a speed of tens of millions per second, because the hash function worked with such speed. <br><br><h3>  Optimization </h3><br>  In order to understand what is slowing down, it was not even necessary to run the profiler.  At the time of writing, it was clear that this would not work quickly because of one line: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> concat = testId + uid;</code> </pre> <br>  Here is the creation of a new line with the allocation of memory for it and then copying.  At the same time, we release the memory immediately upon exiting the function.  That is, in fact, the row object in the heap is not needed.  You can of course allocate memory on the stack, but this approach does not pretend to a general solution. <br><br>  A programmer who was not familiar with the idiom of ranges suggested a completely classical solution.  Since only the first part of the hash calculation function depends on the string itself, it can be put into a separate function that returns the intermediate result.  It can be called several times for different lines, passing the intermediate result from the call to the call.  Well, in the end to call a finalizer, which will give the final hash. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_hash32_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { hash += key[i]; hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>); hash ^= (hash &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_hash32_end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span><span class="hljs-function"> </span></span>{ hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>); hash ^= (hash &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>); hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ab_group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; testId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; uid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> hash = <span class="hljs-number"><span class="hljs-number">0</span></span>; hash = string_hash32_start(hash, test_id); hash = string_hash32_start(hash, uid); hash = string_hash32_end(hash); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashVal % count; }</code> </pre><br>  The approach is quite understandable, a lot, where it is done.  That's just not very well read, and the original function had to be disassembled.  But it is not always possible to do so.  Require an algorithm of several passes over the entire line or a passage in the opposite direction, and such an approach would no longer be implementable. <br><br><h3>  Ranges </h3><br>  In order to make the function truly generic, we need a minimum of changes.  We do not touch the algorithm at all, just change the type of the argument from the sishna string to the pattern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Range&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string_hash32_v3</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> hash = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c : r) { hash += c; hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>); hash ^= (hash &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>); } hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>); hash ^= (hash &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>); hash += (hash &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br>  That is, the function began to accept any object, foreach on which gives char.  Any container from std is suitable for this role, with the argument char.  A sishnaya zero-terminated string is also easily wrapped in such a container.  But, most importantly, you can now pass a lazy generator. <br><br>  Take the function concat from the ranges-v3 library.  This function returns an object that supports the iteration interface on it and gives element-wise the contents of all collections passed to it.  First goes through the first, then the second, and so on.  That is, it looks like the string a + b, only it does not allocate memory, but simply refers to the original lines.  And since it quacks like a duck, we will use it like a duck: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ab_group_ranges_v3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; testId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; uid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> concat = concat(testId, uid); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> hashVal = string_hash32_v3(concat); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashVal % count; }</code> </pre> <br>  It looks the same as the very first non-optimized version, just instead of the + operator, we called the function concat from the ranges-v3 library.  But it works significantly faster. <br><br>  Time for 20 million hashes, ms <br><table><tbody><tr><td></td><td>  gcc 4.8.5 </td><td>  gcc 5.3.0 </td><td>  gcc 6.2.0 </td></tr><tr><td>  plus </td><td>  1609 </td><td>  1658 </td><td>  1655 </td></tr><tr><td>  v3 </td><td>  987 </td><td>  855 </td><td>  630 </td></tr><tr><td>  plain </td><td>  631 </td><td>  640 </td><td>  640 </td></tr></tbody></table><br>  <i>Explanation of the table.</i>  <i>plus is the very first implementation using string concatenation.</i>  <i>v3 - implementation on ranges.</i>  <i>plain is the first optimized version, with a split of hashing into start and end.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Sources</b> <div class="spoiler_text">  Unfortunately, I am now on vacation and do not have access to the source code of this benchmark.  If possible, they will be posted on github.  While I can offer only independent experiments, the benefit is that ranges-v3 are header-only and it is not difficult to use it. <br></div></div><br>  We can observe an interesting phenomenon: with GCC6, a generic version with ranges works as fast as an optimized, highly specialized one.  Of course, the optimizer did a good job here.  You can clearly see the development of optimizations from gcc4 to gcc5 and 6. <br><br>  All iterators and method calls on them were inline.  The extra conditions in the loop are reordered and simplified.  As a result, on some compilers, the disassembler of both versions shows the same thing.  And on the GCC6, the range version is even slightly faster.  I didn‚Äôt study this phenomenon, but I‚Äôm sure I‚Äôm working correctly, so I can only rejoice at the development of technology and advise using the latest versions of compilers. <br><br>  Sometimes the optimizer works wonders.  For example, in the image processing library it can combine successive transformations into one faster one: 2 turns can be assembled into one, any affine transformations can be assembled into one.  The translation of the original article <a href="http://habrahabr.ru/post/218429/">was on Habr√©</a> . <br><br>  From interesting examples: 4 rotations by 90 degrees, the compiler was thrown out of the code altogether. <br><br><h2>  Search for substrings </h2><br>  As shown in the examples and benchmarks, the ranges are fast.  However, their main advantage is that they are comfortable and fast at the same time.  Well, or at least show an excellent ratio of ease of writing to speed. <br><br>  Consider the following task: to find all the occurrences of numbers in a given string.  Next, D is used to increase readability, not C ++.  For such a function, you can offer two classic interfaces.  Convenient: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allNumbersArr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  And fast: <br><br><pre> <code class="hljs cs">Nullable!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_t begin</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  With convenient everything is clear: the input line, the output array of numbers.  The disadvantage is that you need to create an array for the result.  And create only in a heap. <br><br>  C fast is harder.  At first glance, it is not very clear how to use it.  It returns one value and that is not always, sometimes it can return null.  It is assumed that the function will be called in a loop to crawl all values ‚Äã‚Äãand will receive a label from where to start the search. <br><br><pre> <code class="hljs pgsql">string test = "123 gfd 44"; size_t <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; Nullable!<span class="hljs-type"><span class="hljs-type">double</span></span> iter; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iter = findNumber(test, <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>), !iter.<span class="hljs-keyword"><span class="hljs-keyword">isNull</span></span>) { <span class="hljs-type"><span class="hljs-type">double</span></span> val = iter.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; writeln(val); }</code> </pre> <br>  Not the most intuitive and readable way.  But it does not require arrays and works faster.  True, every time you use a function, you will have to write this not the most trivial while, not to forget that you need a begin variable and how to use Nullable.  In pure C, by the way, I would have to add a pointer to begin, and in the absence of Nullable, add another flag that they did not find anything.  Well, or compare the resulting begin with a long string.  In general, fast, but uncomfortable. <br><br>  Ranges offer to combine convenience with speed.  The implementation will look like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allNumbers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input)</span></span></span><span class="hljs-function"> </span></span>{ alias re = ctRegex!`\d+(\.\d+)?`; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> matches = matchAll(input, re); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> matches.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>!(a =&gt; a.hit.to!<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>); }</code> </pre> <br>  The function returns a <a href="https://habrahabr.ru/post/183488/">Voldemort type</a> (a type that cannot be named, it does not have a name outside the map implementation).  The matchAll function will return a lazy range, which will begin to search when it is first accessed.  map is also lazy, so it will not touch matches until asked.  That is, at the time the function is called, the search for all entries will not occur and an array will not be created for them.  But the result looks like all occurrences of numbers.  Examples of using: <br><br><pre> <code class="hljs cs">auto toWrite = allNumbers(<span class="hljs-string"><span class="hljs-string">"124 ads 85 3.14 43"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (d; toWrite) { writeln(d); }</code> </pre> <br>  Here writeln will go through all entries and print on the screen. <br><br><pre> <code class="hljs pgsql">auto toSum = allNumbers("1 2 3 4 5"); writeln("sum is ", sum(toSum));</code> </pre> <br>  sum - standard library algorithm.  Accepts a range of any numbers and, obviously, summarizes.  Again, you have to go through all, but no arrays, at one time there is one double. <br><br><pre> <code class="hljs lisp">auto toCheck = allNumbers(<span class="hljs-string"><span class="hljs-string">"1qwerty"</span></span>)<span class="hljs-comment"><span class="hljs-comment">; writeln("there are some ", !toCheck.empty);</span></span></code> </pre> <br>  And then we generally just checked, and whether there are numbers in the string.  In this case, the minimum required.  If there are numbers, the search will stop at the first and empty returns false.  A full line pass will only occur if there are no numbers.  I think many people were pushing for performance problems because arrays were created to check for availability.  As the most epic case: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>.query(‚Äú<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>‚Äù).count() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Raised the entire table in memory only to check if it is not empty.  Such code happens.  And it is no longer possible to ‚Äúrazvidet‚Äù.  From the sql query, the ranges, of course, will not save (nothing will help here at all), but in the case of strings or files, there will be no extra work. <br><br>  It is important to note that the functions of the standard D library, as well as the ranges-v3 for C ++, as well as any good functions for working with ranges, do not indicate specific types.  They are generalized to the limit, and you can concatenate regular arrays, lists, and hashes, and most importantly, other ranges.  Nothing prevents the argument from passing the result of the algorithm, whether it be filtering, mapping, or another concatenation.  In this sense, Range is an iterator development.  They also build generalized algorithms like stl, and there is hope that stl2 will take ranges as a basis. <br><br>  So far we have considered only two algorithms: search and union.  In fact, there are a lot of lazy ranges.  For D you can look at the list <a href="https://dlang.org/phobos/std_algorithm.html">here</a> and <a href="https://dlang.org/phobos/std_range.html">here</a> .  For C ++, the best source is the <a href="https://ericniebler.github.io/range-v3/">Ranges-V3</a> library. <br><br><h2>  A short overview of the most useful algorithms </h2><br>  iota is a generator of a sequence of natural numbers.  From 0 to preset.  There are versions for setting the step and the initial values. <br><br>  chunks - split the input range into several others with a fixed length.  Allows you to take care of non-multiple length, empty input data and so on.  Very handy for working with APIs that limit the size of the input data (Facebook REST with restrictions on all bulk requests) <br><br><pre> <code class="hljs cs">auto numbers = iota(<span class="hljs-number"><span class="hljs-number">35</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (chunk; numbers.chunks(<span class="hljs-number"><span class="hljs-number">10</span></span>)) { writeln(chunk); }</code> </pre> <br>  Displays <br><br><pre> <code class="hljs json">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] [<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>] [<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">26</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">29</span></span>] [<span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>]</code> </pre> <br>  enumerate - for the input range, creates a range from the element and its number in the source <br>  zip - collects several ranges into the range, where in the first element a tuple from the first elements of the source, in the second from the second, and so on.  Very handy for simultaneously iterating over collections of the same length. <br>  repeat - repeat to infinity the specified value <br>  take - take the specified number of elements <br><br><pre> <code class="hljs swift">auto infPi = <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span>(<span class="hljs-number"><span class="hljs-number">3.14</span></span>); writeln(infPi.take(<span class="hljs-number"><span class="hljs-number">10</span></span>)); [<span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>]</code> </pre> <br><h2>  Benefits of structural typing </h2><br>  This paragraph is more likely to refer to structural typing in general than to ranges, but it still could not have done without them.  Classic OOP "problem": you cannot pass an array of children to a function where an array of ancestors is expected.  It is impossible not because the authors of languages ‚Äã‚Äãare so bad, but because it will lead to logical errors.  Suppose it would be possible.  Arrays are usually passed by reference.  Now we will transfer to the function, expecting an array of animals, an array of cats.  And this function will take, but add a dog to the array!  And at the exit we have an array of cats in which there is a dog.  Const could solve the problem, but only this particular case, and I don‚Äôt want to prohibit the insertion of cats. <br><br>  But you can always iterate and call methods of objects.  With ranges on C ++, it would look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">walk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Animal { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">walk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Range&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">walkThemAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range animals)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> animal : animals) { animal-&gt;walk(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ walkThemAll(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat[<span class="hljs-number"><span class="hljs-number">100</span></span>]); }</code> </pre> <br>  Thanks to the Range template, it is typified by cats, and the dog cannot be shoved in there. <br><br><h2>  How is this different from iterators? </h2><br>  In the abstract, these are iterators.  But this is theoretically, and there are many differences from existing implementations.  From C ++ iterators ranges are consistent.  They themselves know where they end and it‚Äôs very difficult to get an invalid range.  An iterator in C ++ is rather a pointer, and a range is a reference to std :: vector. <br><br>  In C #, iterators are more advanced and have no integrity problems.  But there are several other fundamental differences.  First, iterators in sharpe are just one kind of band - InputRange.  It is an entity that is iterated in one direction without the ability to go back or at least copy the current state.  In addition to them, there are ForwardRange (with state preservation), BidirectionalRange (ability to iterate in the opposite direction), RandomAccessRange (random access through the operator []), OutputRange (write without reading).  All this is not even theoretically covered by a single yield return. <br><br>  Secondly, performance.  The virtual machine will have to create a miracle to make the optimizations available in C ++.  And all because of the gap of execution and switching between contexts.  And generics, in contrast to templates, do not generate code and cannot optimize particular cases.  And as the C ++ example shows, these optimizations speed up the code many times over.  My preliminary benchmarks, in which I am not sure, show that an attempt to independently implement concat fails due to speed.  Plain concatenation is simply faster.  Most likely jit does a good job with working on a solid line, and GC with reuse of memory.  But millions of unnecessary switching and function calls to throw no one. <br><br>  Third, ready-made algorithms.  On D or C ++ there is already a mass of lazy algorithms.  Sharpe boasts only generators.  The presence of agreements allows you to write a code like <br><br><pre> <code class="hljs swift">array.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.chunks(<span class="hljs-number"><span class="hljs-number">10</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(a=&gt;sum(a)).<span class="hljs-built_in"><span class="hljs-built_in">enumerate</span></span>;</code> </pre> <br>  The call chain is endless.  In C ++, there is no such call through a dot, but there is an operator | overloaded for ranges.  Therefore, you can do the same thing, just replacing.  on |. <br><br><h3>  And in go, perl, #my_favorite_lang is also structural typing! </h3><br>  Yes, and it allows you to write something very similar.  Not accepted, but you can do.  This will not work quickly because it is the same as in C #.  The go interfaces, like C # generics, use indirect calls instead of code generation.  That is, each iteration will require at least 2 virtual calls.  During the virtual call you can do several iterations with inline, so the difference with C ++ will be several times. <br><br>  That's all, thank you for reading to here. <br><br>  <i>The material was prepared for the presentation at CrazyPanda and copied here as is.</i>  <i>Distribution and copying by the author is not prohibited, but subject to the <a href="https://habrahabr.ru/info/help/rules/">rules of habrahabr</a> .</i>  <i>If the habrasoobschestvo interested in the question, then perhaps continue to follow directly to the habr.</i> <br><br>  Related Links: <br><br>  ¬ª <a href="http://ericniebler.com/2013/11/07/input-iterators-vs-input-ranges/">Ericniebler.com/2013/11/07/input-iterators-vs-input-ranges</a> <br>  ¬ª <a href="https://www.youtube.com/watch%3Fv%3DmFUXNMfaciE">Www.youtube.com/watch?v=mFUXNMfaciE</a> <br>  ¬ª <a href="http://ericniebler.com/2015/02/03/iterators-plus-plus-part-1/">Ericniebler.com/2015/02/03/iterators-plus-plus-part-1</a> <br>  ¬ª <a href="https://github.com/ericniebler/range-v3">Github.com/ericniebler/range-v3</a> <br>  ¬ª <a href="https://dlang.org/phobos/std_range.html">Dlang.org/phobos/std_range.html</a> <br>  ¬ª <a href="https://dlang.org/phobos/std_algorithm.html">Dlang.org/phobos/std_algorithm.html</a> </div><p>Source: <a href="https://habr.com/ru/post/318266/">https://habr.com/ru/post/318266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318256/index.html">Programming gaming applications on the Corona SDK: part 1</a></li>
<li><a href="../318258/index.html">Deploy a VMware Virtual SAN 6.2 Test Cluster</a></li>
<li><a href="../318260/index.html">"Programmer - Analytical thinking = 1C programmer" and other GoToHack results</a></li>
<li><a href="../318262/index.html">Security Week 51-52: Custom Top News 2016</a></li>
<li><a href="../318264/index.html">Today I again earned Bitcoin: why is it bad?</a></li>
<li><a href="../318268/index.html">Optimize redux storage for more productive changes.</a></li>
<li><a href="../318272/index.html">Financial Telegram-bot in 30 minutes with Market Data API</a></li>
<li><a href="../318274/index.html">Slow evolution of interfaces or the saga of the fourth button</a></li>
<li><a href="../318276/index.html">Anonymous Father Frost 2016-2017: post boasting New Year's gifts</a></li>
<li><a href="../318278/index.html">VR application from scratch on libgdx: part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>