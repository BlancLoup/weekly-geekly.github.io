<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple algebraic data types</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the sixth article from the series "Theory of Categories for Programmers." Previous articles have already been published on Habr√©: 
 0. Categor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple algebraic data types</h1><div class="post__text post__text-html js-mediator-article">  <i>This is the sixth article from the series "Theory of Categories for Programmers."</i>  <i>Previous articles have already been published on Habr√©:</i> <br>  <a href="http://habrahabr.ru/post/245797/">0. Category Theory for Programmers: Preface</a> <br>  <a href="http://habrahabr.ru/post/246009/">1. Category: essence of composition</a> <br>  <a href="http://habrahabr.ru/post/247765/">2. Types and functions</a> <br>  <a href="http://habrahabr.ru/post/248257/">3. Categories, large and small</a> <br>  <a href="http://habrahabr.ru/post/249113/">4. Categories Claisley</a> <br>  <a href="http://habrahabr.ru/post/271927/">5. Works and Copies</a> <br><br>  In the previous article the basic operations on types were considered: product and coproduct.  We now show that combining these mechanisms allows us to construct many of the everyday data structures.  Such a construction has significant applied value.  For example, if we are able to check basic data types for equality, and also know how to reduce the equality of work and coproduct to equality of components, then the equality operators for composite types can be inferred automatically.  In Haskell, for an extensive subset of complex types, the equality and comparison operators, conversion to and from the string, and many other operations are automatically output. <br><br>  Let us take a closer look at the place of creation and type creation in programming. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Type product </h2><br>  The canonical implementation of a work of types in programming languages ‚Äã‚Äãis a pair.  In Haskell, a pair is a primitive type constructor, and in C ++ it is a relatively complex template from the standard library. <br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/423/e77/94e/423e7794ede1545c9447a953da50cd9d.jpg" alt="Pair" width="150" height="102"><br>  Strictly speaking, a product of types is not commutative: it is impossible to substitute a pair of type <code>(Int, Bool)</code> instead of <code>(Bool, Int)</code> , although they contain the same data.  However, the product is commutative up to an isomorphism defined by the <code>swap</code> function, which is inverse to itself: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">swap</span></span> :: (a, b) -&gt; (b, a) swap (x, y) = (y, x)</code> </pre> <br>  Couples can be viewed as different storage formats for the same information, like big endian and little endian. <br><a name="habracut"></a><br>  By investing one pair into another, you can combine as many types as you like into your work.  The same can be obtained more easily if you notice that nested pairs are equivalent to tuples.  This is a consequence of the fact that different orders of imbedding of pairs are isomorphic to each other.  There are two possible combining order in the product of the three types <code>a</code> , <code>b</code> and <code>c</code> (in a given sequence).  Namely, <br><pre> <code class="haskell hljs">((a, b), c)</code> </pre>  or <br><pre> <code class="haskell hljs">(a, (b, c))</code> </pre> <br>  These types are different in the sense that a function that expects an argument of the first type cannot pass the argument of the second, but the values ‚Äã‚Äãof the types are in one-to-one correspondence.  Here is the function that sets this display in one direction: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">alpha</span></span> :: ((a, b), c) -&gt; (a, (b, c)) alpha ((x, y), z) = (x, (y, z))</code> </pre> <br>  But back to her: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">alpha_inv</span></span> :: (a, (b, c)) -&gt; ((a, b), c) alpha_inv (x, (y, z)) = ((x, y), z)</code> </pre> <br>  So, there is an isomorphism of types;  these are just different ways of repacking the same data. <br><br>  Considering the product of types as a binary operation, we see that the isomorphism above is very similar to the associative law in monoids: <br><pre> <code class="haskell hljs">(a * b) * c = a * (b * c)</code> </pre> <br>  The only difference is that in a monoid both products are absolutely identical, and for types they are equal up to isomorphism. <br><br>  If we consider this distinction unimportant, then we can extend the analogy with monoids further and show that Singleton <code>()</code> is a neutral element with respect to the multiplication of types, just as 1 is neutral with respect to the multiplication of numbers.  Indeed, attaching <code>()</code> to an element of type <code>a</code> does not add any information.  Type of <br><pre> <code class="haskell hljs">(a, ())</code> </pre> <br>  isomorphic to <code>a</code> , where isomorphism is given by functions <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">rho</span></span> :: (a, ()) -&gt; a rho (x, ()) = x</code> </pre> <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">rho_inv</span></span> :: a -&gt; (a, ()) rho_inv x = (x, ())</code> </pre> <br>  Our observations can be formalized as a statement that the category of the set <strong>Set</strong> is <em>monoidal</em> , that is, a category that is also a monoid with respect to the multiplication of objects (in this case with respect to the Cartesian product).  A strict definition will be given below. <br><br>  Haskell has a more general way of defining works, especially convenient, as we will soon see when they are combined with type sums.  We use named constructors with several arguments.  For example, an alternative definition of a pair looks like this: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pair</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">P</span></span></span><span class="hljs-class"> ab</span></span></code> </pre> <br>  Here, <code>Pair ab</code> is the name of the type constructor, parametrized by two other types, <code>a</code> and <code>b</code> , and <code>P</code> is the name of the data constructor.  We define a specific type, passing two types to the <code>Pair</code> type constructor, and create a pair of this type, passing the appropriately typed values ‚Äã‚Äãto the <code>P</code> constructor.  For example, we define the variable <code>stmt</code> as a pair from <code>String</code> and <code>Bool</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stmt</span></span> :: <span class="hljs-type"><span class="hljs-type">Pair</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> stmt = <span class="hljs-type"><span class="hljs-type">P</span></span> <span class="hljs-string"><span class="hljs-string">"This statement is"</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre> <br>  The first line is a type declaration.  It consists of the <code>Pair</code> type constructor with <code>String</code> and <code>Bool</code> instead of <code>a</code> and <code>b</code> .  The second line defines the value of a variable, obtained by applying the data constructor <code>P</code> to a specific line and a logical value.  Once again: type constructors are used to construct types, data constructors are used to construct values. <br><br>  Since the namespaces of the types and data in Haskell do not overlap, often the same name is used for both constructors.  For example, <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pair</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pair</span></span></span><span class="hljs-class"> ab</span></span></code> </pre> <br>  If you look at the built-in type of a pair with Lenin's squint, then it is recognized that it is in fact a variation on the topic of the last declaration, only the <code>Pair</code> constructor is replaced with a binary operator <code>(,)</code> .  You can use <code>(,)</code> in the same way as any other named constructor, in prefix notation: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stmt</span></span> = (,) <span class="hljs-string"><span class="hljs-string">"This statement is"</span></span> <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre> <br>  Similarly, <code>(,,)</code> constructs triples, etc. <br><br>  Instead of using generic pairs or tuples, you can enter a separate name for the product of specific types.  For example, <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stmt</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stmt</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span></span></code> </pre> <br>  is a product of <code>String</code> and <code>Bool</code> , but has its own name and constructor.  The advantage of this definition is that you can create many types with the same content, but with different semantics and functionality that the type system will not allow to mix with each other. <br><br>  Programming on tuples and multi-argument constructors often leads to confusion and errors, because you have to keep track of which component is responsible for what.  It would be better to be able to give the components proper names.  The product of types with named fields is called a Haskell entry and a <code>struct</code> in C. <br><br><h2>  Records </h2><br>  Consider a simple example.  We will describe the chemical elements of a single structure consisting of two lines (Latin name and symbol) and an integer corresponding to the atomic mass.  To do this, you can use a tuple <code>(String, String, Int)</code> and keep in mind what component is responsible for what.  To extract components from a tuple, we will apply pattern matching.  The following function checks whether the character of a chemical element is a prefix of its Latin name (for example, <strong>He</strong> is the <strong>Helium</strong> prefix): <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">startsWithSymbol</span></span> :: (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> startsWithSymbol (name, symbol, _) = isPrefixOf symbol name</code> </pre> <br>  In such code, it is easy to make a mistake, it is difficult to read and maintain.  Much better to define instead of a tuple entry: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Element</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">symbol</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">atomicNumber</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br>  These representations are isomorphic, as can be seen with the help of the following reciprocal transformations: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tupleToElem</span></span> :: (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Element</span></span> tupleToElem (n, s, a) = <span class="hljs-type"><span class="hljs-type">Element</span></span> { name = n , symbol = s , atomicNumber = a }</code> </pre> <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">elemToTuple</span></span> :: <span class="hljs-type"><span class="hljs-type">Element</span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) elemToTuple e = (name e, symbol e, atomicNumber e)</code> </pre> <br>  Note that the field names of the record are simultaneously accessor functions.  For example, <code>atomicNumber e</code> returns the <code>atomicNumber</code> field of the <code>atomicNumber</code> record.  Thus, the <code>atomicNumber</code> function has the type: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">atomicNumber</span></span> :: <span class="hljs-type"><span class="hljs-type">Element</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre> <br>  Using <code>Element</code> type entries, the <code>startsWithSymbol</code> function becomes more readable: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">startsWithSymbol</span></span> :: <span class="hljs-type"><span class="hljs-type">Element</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> startsWithSymbol e = isPrefixOf (symbol e) (name e)</code> </pre> <br>  In Haskell, you can crank a trick that turns the <code>isPrefixOf</code> function into an infix operator, framing it with reverse apostrophes.  This makes the code more readable: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">startsWithSymbol</span></span> e = symbol e `isPrefixOf` name e</code> </pre> <br>  We were able to omit the brackets due to the fact that the priority of the infix operator is lower than the priority of the function call. <br><br><h2>  Sum of Types </h2><br>  In the same way that a product in the category of sets induces the products of types, coproduction produces sums of types.  The canonical implementation of the sum of types in Haskell is: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Left</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Right</span></span></span><span class="hljs-class"> b</span></span></code> </pre> <br>  Like pairs, <code>Either</code> commutative (up to isomorphism) can be nested, and the order of nesting is not important (up to isomorphism).  For example, the sum of three types looks like this: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OneOfThree</span></span></span><span class="hljs-class"> abc = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sinistral</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Medial</span></span></span><span class="hljs-class"> b | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dextral</span></span></span><span class="hljs-class"> c</span></span></code> </pre> <br>  It turns out that <strong>Set</strong> forms a (symmetric) monoidal category with respect to the coproduct operation.  The binary operation takes the disjoint sum, and the neutral element is the initial object.  In terms of types, <code>Either</code> is a monoidal operation, and an uninhabited <code>Void</code> type is its neutral element.  Consider that <code>Either</code> is addition, and <code>Void</code> is zero.  Indeed, adding <code>Void</code> to the sum of types does not change the set of values ‚Äã‚Äãof the type.  For example, <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Either</span></span> a <span class="hljs-type"><span class="hljs-type">Void</span></span></code> </pre> <br>  isomorphic to <code>a</code> .  Indeed, since the <code>Void</code> type is not populated, there is no way to construct the <code>Right</code> value.  Hence, the only inhabitants of <code>Either a Void</code> are <code>Left</code> values, which are simply a wrapper over a value of type <code>a</code> .  Symbolically, this can be written as <code>a + 0 = a</code> . <br><br>  Sums of types are very common in Haskell.  In C ++, their analogs (combinations or variants) are used much less frequently for a number of reasons. <br><br>  First, the simplest sums of types are enums that are implemented in C ++ using <code>enum</code> .  By equivalent <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Color</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Red</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Green</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Blue</span></span></span></span></code> </pre> <br>  in C ++ will <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { Red, Green, Blue };</code> </pre> <br>  An even simpler sum of types. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">False</span></span></span></span></code> </pre> <br>  in C ++ it is a primitive type <code>bool</code> . <br><br>  Further, the sums of types encoding the presence or absence of a value are implemented in C ++ using various tricks with "impossible" values, such as empty strings, negative numbers, null pointers, etc. In Haskell, the explicit, intentional optional values ‚Äã‚Äãare written using <code>Maybe</code> : <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br>  The type of <code>Maybe</code> is the sum of two types.  Mentally turn its designers into separate types.  The first will take the form: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NothingType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span></span></code> </pre> <br>  This is an enumeration with a single value of <code>Nothing</code> .  In other words, it is a singleton equivalent to a type <code>()</code> .  The second part of <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JustType</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br>  is a wrapper over type <code>a</code> .  We could write <code>Maybe</code> as <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> () a</span></span></code> </pre> <br>  More complex sums of types are fabricated in C ++ using pointers.  A pointer can either be null or point to a value of a particular type.  For example, in Haskell the list is defined as a (recursive) sum of types: <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">List</span></span> a = <span class="hljs-type"><span class="hljs-type">Nil</span></span> | <span class="hljs-type"><span class="hljs-type">Cons</span></span> a (<span class="hljs-type"><span class="hljs-type">List</span></span> a)</code> </pre> <br>  In C ++, the same type is written as: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> {</span></span> Node&lt;A&gt; * _head; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: List() : _head(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) {} <span class="hljs-comment"><span class="hljs-comment">// Nil List(A a, List&lt;A&gt; l) // Cons : _head(new Node&lt;A&gt;(a, l)) {} };</span></span></code> </pre> <br>  The null pointer here encodes an empty list. <br><br>  Note that the Haskell <code>Nil</code> and <code>Cons</code> constructors have turned into two overloaded constructors of the <code>List</code> class with similar arguments: no arguments in the <code>Nil</code> case, a value and a list for <code>Cons</code> .  The <code>List</code> class does not need a label that would distinguish the components of the sum of types;  instead, it uses the special value <code>nullptr</code> for <code>_head</code> to represent <code>Nil</code> . <br><br>  An important distinction between types in Haskell and in C ++ is that Haskell has data structures that are immutable.  If an object was created using a specific constructor, it will remember forever which constructor was used with which arguments.  So an instance of the class <code>Maybe</code> , created as <code>Just "energy"</code> , will never turn into <code>Nothing</code> .  Similarly, an empty list will always remain empty, and a three-element list will always store the same three elements. <br><br>  Immunity makes constructors reversible: an object can always be disassembled into its component parts used in its creation.  Such deconstruction is carried out by comparison with a sample, which is a particular designer.  Constructor arguments are replaced with variable names (or other patterns). <br><br>  The <code>List</code> type has two constructors, so the deconstruction of an arbitrary <code>List</code> consists of two corresponding pattern matching.  The first sample matches the empty <code>Nil</code> list, the second one with the list created with <code>Cons</code> .  For example, we define a simple function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maybeTail</span></span> :: <span class="hljs-type"><span class="hljs-type">List</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (<span class="hljs-type"><span class="hljs-type">List</span></span> a) maybeTail <span class="hljs-type"><span class="hljs-type">Nil</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> maybeTail (<span class="hljs-type"><span class="hljs-type">Cons</span></span> _ t) = <span class="hljs-type"><span class="hljs-type">Just</span></span> t</code> </pre> <br>  The first part of the <code>maybeTail</code> definition uses the <code>Nil</code> constructor as a pattern for matching and returns <code>Nothing</code> .  The second part uses the <code>Cons</code> constructor as a sample.  The first argument of the sample is represented by a dash, since we are not interested in the value contained in it.  The second argument, <code>Cons</code> associated with the variable <code>t</code> (hereinafter, we will talk about variables, although, strictly speaking, they are unchanged: the variable that is once associated with the value never changes).  The value of the function on this sample is <code>Just t</code> .  So, depending on how the value of the <code>List</code> type is created, it will coincide with one of the samples.  If it was created with <code>Cons</code> , the function will get both arguments used (the first of which will be ignored). <br><br>  More complex sums of types are implemented in C ++ by a hierarchy of polymorphic classes.  A family of classes with a common ancestor can be interpreted as a sum of types in which the table of virtual functions serves as an implicit label of the component.  What Haskell serves as pattern matching is implemented in C ++ by calling the dispatch function. <br><br>  The reader is rarely seen in C ++ using <code>union</code> as a sum of types due to its excessive limitations.  You can't even put <code>std::string</code> in a <code>union</code> , because this class has a copy constructor. <br><br><h2>  Type algebra </h2><br>  Separately, the product and the sum of the types allow you to define many useful data structures, but the real power comes from their combination. <br><br>  Let's summarize the above.  We considered two commutative monoidal structures underlying the type system.  These are the sum of types with a neutral element <code>Void</code> and the product of types with a neutral element <code>()</code> .  It is convenient to imagine them as addition and multiplication.  In this case, <code>Void</code> zero, and <code>()</code> is one. <br><br>  Let's see how far this analogy goes.  For example, is it true that multiplying by zero gives zero?  In other words, is any product isomorphic to a <code>Void</code> type <code>Void</code> ? <br><br>  Are there pairs of, say, <code>Int</code> and <code>Void</code> ?  To create a pair, both values ‚Äã‚Äãare needed.  The value of the <code>Int</code> type is not a problem, but there is a catch with <code>Void</code> : this type is not populated (there is not a single value of this type).  Thus, for any type <code>a</code> type <code>(a, Void)</code> also not populated and, therefore, equivalent to <code>Void</code> .  In other words, <code>a*0 = 0</code> . <br><br>  Addition and multiplication of numbers are connected by the distribution law: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span> * (b + c) = a * b + a * c</code> </pre> <br>  Is it for sum and product types?  Yes, up to isomorphism.  The left part of the identity corresponds to the type <br><pre> <code class="haskell hljs">(a, <span class="hljs-type"><span class="hljs-type">Either</span></span> bc)</code> </pre> <br>  and right - <pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Either</span></span> (a, b) (a, c)</code> </pre> <br>  Let's present functions which will transform types there and back: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prodToSum</span></span> :: (a, <span class="hljs-type"><span class="hljs-type">Either</span></span> bc) -&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span> (a, b) (a, c) prodToSum (x, e) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Left</span></span> y -&gt; <span class="hljs-type"><span class="hljs-type">Left</span></span> (x, y) <span class="hljs-type"><span class="hljs-type">Right</span></span> z -&gt; <span class="hljs-type"><span class="hljs-type">Right</span></span> (x, z)</code> </pre> <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sumToProd</span></span> :: <span class="hljs-type"><span class="hljs-type">Either</span></span> (a, b) (a, c) -&gt; (a, <span class="hljs-type"><span class="hljs-type">Either</span></span> bc) sumToProd e = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Left</span></span> (x, y) -&gt; (x, <span class="hljs-type"><span class="hljs-type">Left</span></span> y) <span class="hljs-type"><span class="hljs-type">Right</span></span> (x, z) -&gt; (x, <span class="hljs-type"><span class="hljs-type">Right</span></span> z)</code> </pre> <br>  The <code>case of</code> construction is used for pattern matching within a function.  The arrow separates the sample and its corresponding expression.  For example, when calling <code>prodToSum</code> with an argument <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prod1</span></span> :: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Float</span></span>) prod1 = (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-type"><span class="hljs-type">Left</span></span> <span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>)</code> </pre> <br>  the variable <code>e</code> in <code>case e of</code> will be equal <code>Left "Hi!"</code>  .  It will match the <code>Left y</code> pattern, substituting <code>"Hi!"</code>  instead of <code>y</code> .  Since the variable <code>x</code> previously associated with <code>2</code> , the result of the <code>case of</code> construction (and the entire function) will be, as expected, <code>Left (2, "Hi!")</code> . <br><br>  The proof that the functions above are mutually inverse will be left to the reader as an exercise.  They only repack the same data from one format to another. <br><br>  Two monoids connected by distributive law are called <em>semi-rings</em> in mathematics.  This is not a complete <em>ring</em> , since we cannot determine the subtraction of types.  The set of statements true for the generators of the semiring of natural numbers can be transferred to types.  Here are some examples: <br><table><tbody><tr><td>  <b>Numbers</b> <br></td><td>  <b>Types</b> <br></td></tr><tr><td>  0 <br></td><td> <code>Void</code> <br> </td></tr><tr><td>  one <br></td><td> <code>()</code> <br> </td></tr><tr><td>  a + b <br></td><td> <code>Either ab = Left a | Right b</code> <br> </td></tr><tr><td>  a * b <br></td><td>  <code>(a, b)</code> or <code>Pair ab = Pair ab</code> <br></td></tr><tr><td>  2 = 1 + 1 <br></td><td> <code>data Bool = True | False</code> <br> </td></tr><tr><td>  1 + a <br></td><td> <code>data Maybe = Nothing | Just a</code> <br> </td></tr></tbody></table><br>  The list type is of particular interest because it is defined as a solution to the equation.  The type defined is found on both sides of the equality: <br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">List</span></span> a = <span class="hljs-type"><span class="hljs-type">Nil</span></span> | <span class="hljs-type"><span class="hljs-type">Cons</span></span> a (<span class="hljs-type"><span class="hljs-type">List</span></span> a)</code> </pre> <br>  Making the usual substitutions and replacing <code>List a</code> with <code>x</code> , we get <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> + a * x</code> </pre> <br>  This equation cannot be solved by traditional algebraic methods, since types cannot be subtracted or divided.  Let us recursively substitute the expression <code>(1 + a*x)</code> instead of <code>x</code> on the right and expand the brackets by distributivity.  Will get <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> + a*x x = <span class="hljs-number"><span class="hljs-number">1</span></span> + a*(<span class="hljs-number"><span class="hljs-number">1</span></span> + a*x) = <span class="hljs-number"><span class="hljs-number">1</span></span> + a + a*a*x x = <span class="hljs-number"><span class="hljs-number">1</span></span> + a + a*a*(<span class="hljs-number"><span class="hljs-number">1</span></span> + a*x) = <span class="hljs-number"><span class="hljs-number">1</span></span> + a + a*a + a*a*a*x ... x = <span class="hljs-number"><span class="hljs-number">1</span></span> + a + a*a + a*a*a + a*a*a*a...</code> </pre> <br>  In the end, we come to an infinite sum of products (tuples), which can be interpreted as follows: the list is either empty, <code>1</code> ;  either consists of a single element, <code>a</code> ;  either consists of a pair, <code>a*a</code> ;  either from a triplet, <code>a*a*a</code> , and so on. The formal definition obtained fully corresponds to the intuitive notion of the list as a line, where instead of letters are values ‚Äã‚Äãof type <code>a</code> . <br><br>  We will return to lists and other recursive structures further, after studying functors and fixed points. <br><br>  Solving equations with symbolic variables is an algebra!  Therefore, these data types are called algebraic (ADT). <br><br>  Summing up, we give one very important interpretation of type algebra.  Note that the product of types <code>a</code> and <code>b</code> must contain both a value of type <code>a</code> <em>and a</em> value of type <code>b</code> , which implies a population of both types.  On the other hand, the sum of types contains either a value of type <code>a</code> , <em>or a</em> value of type <code>b</code> , so it is enough that at least one of them is populated.  The logical operations of <em>conjunction</em> and <em>disjunction</em> form a semiring, which is in accordance with the following type algebra: <br><table><tbody><tr><td>  <b>Logics</b> <br></td><td>  <b>Types</b> <br></td></tr><tr><td>  false <br></td><td> <code>Void</code> <br> </td></tr><tr><td>  true <br></td><td> <code>()</code> <br> </td></tr><tr><td>  a ||  b <br></td><td> <code>Either ab = Left a | Right b</code> <br> </td></tr><tr><td>  a &amp;&amp; b <br></td><td> <code>(a, b)</code> <br> </td></tr></tbody></table><br>  This analogy can be deepened and is the basis of the Curry-Howard isomorphism between logic and type theory.  We will return to this issue when considering functional types. <br><br><h2>  Exercises </h2><br><ol><li>  Show that <code>Maybe a</code> and <code>Either () a</code> is isomorphic. <br></li><li>  Consider the following sum of types in Haskell: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span></span></code> </pre> <br>  To define the <code>area</code> function on the <code>Shape</code> type, we use the pattern matching: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">area</span></span> :: <span class="hljs-type"><span class="hljs-type">Shape</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Float</span></span> area (<span class="hljs-type"><span class="hljs-type">Circle</span></span> r) = pi * r * r area (<span class="hljs-type"><span class="hljs-type">Rect</span></span> dh) = d * h</code> </pre> <br>  Implement <code>Shape</code> in C ++ or Java as an interface and create two classes: <code>Circle</code> and <code>Rect</code> .  Then write the <code>area</code> as a virtual function. <br></li><li>  (Continued) It‚Äôs easy to add a new <code>circ</code> function that calculates the perimeter of a <code>Shape</code> .  In Haskell, the definition of the <code>Shape</code> type will remain unchanged;  The following code can be added anywhere in the program: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">circ</span></span> :: <span class="hljs-type"><span class="hljs-type">Shape</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Float</span></span> circ (<span class="hljs-type"><span class="hljs-type">Circle</span></span> r) = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * pi * r circ (<span class="hljs-type"><span class="hljs-type">Rect</span></span> dh) = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * (d + h)</code> </pre> <br>  Add <code>circ</code> to your C ++ or Java program.  What parts of the original program had to be modified? <br></li><li>  (Continued) Add a new Shape <code>Square</code> <code>Shape</code> type and make the appropriate updates to the rest of the code.  What had to change in Haskell?  What about C ++ or Java?  (Even if you don't know Haskell, the changes should be pretty obvious.) <br></li><li>  Show that the formal identity <code>a + a = 2 * a</code> holds for types (up to isomorphism).  Recall that <code>2</code> in the type language corresponds to <code>Bool</code> (see the table above). <br></li></ol><br><h2>  Thanks </h2><br>  The author is grateful to Gershom Bazerman for reviewing the post and helpful comments. </div><p>Source: <a href="https://habr.com/ru/post/274103/">https://habr.com/ru/post/274103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274091/index.html">‚ÄúRoslyn is still a very raw technology‚Äù - an interview with Sergey Shkredov, the head of .NET-direction in JetBrains</a></li>
<li><a href="../274093/index.html">Third New Year Call Center: Ultra-fast ReactJS and Typescript Development</a></li>
<li><a href="../274097/index.html">Receptions work in Blender. Part 2</a></li>
<li><a href="../274099/index.html">Who needs Go and why?</a></li>
<li><a href="../274101/index.html">The digest of interesting materials from the world of Drupal # 16</a></li>
<li><a href="../274105/index.html">GOTPass: new passwordless user authentication system</a></li>
<li><a href="../274107/index.html">Erlang for web development (2) -> DB and deploy;</a></li>
<li><a href="../274109/index.html">The digest of interesting materials for the mobile developer # 135 (December 21-27)</a></li>
<li><a href="../274117/index.html">The botnet of thousands of hacked Aethra routers was used to attack Wordpress sites</a></li>
<li><a href="../274129/index.html">I want sites to open instantly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>