<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We pump over Stream API, or we need more sugar.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, I managed to translate into Java 8 one of the projects I am working on. At first, of course, there was the euphoria of compactness an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We pump over Stream API, or we need more sugar.</h1><div class="post__text post__text-html js-mediator-article"> Not so long ago, I managed to translate into Java 8 one of the projects I am working on.  At first, of course, there was the euphoria of compactness and expressiveness of the structures using the Stream API, but over time I wanted to write even shorter, more flexible and expressive.  At first, I added static methods to utility classes, but it only made the code worse.  In the end, I came to the idea that we need to expand the streaming interfaces themselves, with the result that the small library <a href="https://github.com/amaembo/streamex">StreamEx</a> was born. <br><a name="habracut"></a><br>  In Java 8, there are four streaming interfaces ‚Äî an object <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a> and three primitive <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html">IntStream</a> , <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/LongStream.html">LongStream,</a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/DoubleStream.html">DoubleStream</a> .  To fully replace standard threads, you need to wrap them all.  Thus, I have classes <code>StreamEx</code> , <code>IntStreamEx</code> , <code>LongStreamEx</code> and <code>DoubleStreamEx</code> .  To save the original interface, I had to write quite a few boring methods like the following: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntStreamEx</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntStream</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IntStream stream; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">StreamEx&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapToObj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IntFunction&lt;? extends U&gt; mapper)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamEx&lt;&gt;(stream.mapToObj(mapper)); } ... }</code> </pre> <br>  It was also necessary to create static constructors, and not only those that already exist in the original classes, but also some others (say, to replace <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Random.html">random.ints (),</a> there is an <code>IntStreamEx.of(random)</code> method).  But then flows appeared that I can expand as I see fit.  Below is a brief overview of the additional functionality. <br><br><h4>  Reduction in popular collectors </h4><br>  With the standard Stream API, you often have to write <code>.collect(Collectors.toSet())</code> or <code>.collect(Collectors.toList())</code> .  It looks verbose, even if you import the <code>Collectors</code> statically.  In <code>StreamEx</code> I added methods <code>toSet</code> , <code>toList</code> , <code>toCollection</code> , <code>toMap</code> , <code>groupingBy</code> with several signatures.  The <code>toMap</code> can <code>toMap</code> function for keys if it is identity.  A couple of examples: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs">List&lt;User&gt; users; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.of(users).map(User::getName).toList(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map&lt;Role, List&lt;User&gt;&gt; getUsersByRole() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.of(users).groupingBy(User::getRole); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Map&lt;String, Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcStringLengths</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;String&gt; strings)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.of(strings).toMap(String::length); }</code> </pre> <br>  The <code>joining</code> methods also correspond to collectors, but before that the contents of the stream are passed through <code>String::valueOf</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; numbers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.of(numbers).joining(<span class="hljs-string"><span class="hljs-string">"; "</span></span>); }</code> </pre> <br><h4>  Reduced search and filtering </h4><br>  Sometimes it is required to select only objects of a certain class in a stream.  You can write <code>.filter(obj -&gt; obj instanceof MyClass)</code> .  However, this does not specify the type of stream, so you have to either manually type the elements or add one more step. <code>.map(obj -&gt; (MyClass)obj)</code> .  When using <code>StreamEx</code> this is done concisely using the select method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Element&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elementsOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NodeList nodeList)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStreamEx.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, nodeList.getLength()).mapToObj(nodeList::item).select(Element.class).toList(); }</code> </pre> <br>  In the implementation of the <code>select</code> method, by the way, the map step is not used, but simply after filtering, an unsafe stream type conversion is used, so the pipeline does not lengthen once again. <br><br>  Quite often, you have to throw null from the stream, so I added the <code>nonNull()</code> method to replace <code>filter(Objects::nonNull)</code> .  There is also a <code>remove(Predicate)</code> method that removes elements from the stream that satisfy the predicate ( <code>filter</code> backwards).  It allows more frequent use of references to methods: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNonEmptyLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Reader reader)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.ofLines(reader).map(String::trim).remove(String::isEmpty).toList(); }</code> </pre> <br>  There are <code>findAny(Predicate)</code> and <code>findFirst(Predicate)</code> - shortcuts for <code>filter(Predicate).findAny()</code> and <code>filter(Predicate).findFirst()</code> .  The <code>has</code> method allows you to find out if there is a specific element in the stream.  Similar methods are added to primitive streams. <br><br><h4>  append and prepend </h4><br>  Often there is a need to add one or two special values ‚Äã‚Äãto a stream or to glue two threads together.  Using the standard <code>Stream.concat</code> not very nice, as it adds nested brackets and spoils the idea of ‚Äã‚Äãreading the program from left to right.  To replace <code>concat</code> I made <code>append</code> and <code>prepend</code> , which allow you to add another stream or a given set of values ‚Äã‚Äãto the end or beginning of the current thread: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDropDownOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.of(users).map(User::getName).prepend(<span class="hljs-string"><span class="hljs-string">"(none)"</span></span>).toList(); }</code> </pre> <br>  Now you can expand the array like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] addValue(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] arr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IntStreamEx.of(arr).append(value).toArray(); }</code> </pre> <br><h4>  Comparators </h4><br>  In Java 8, comparators are much easier to write using methods to extract a key like <code>Comparator.comparingInt</code> .  To reduce the most common situations of sorting, searching for the maximum and minimum by one key, the family of methods <code>sortingBy</code> , <code>maxBy</code> and <code>minBy</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMostActiveUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.of(users).maxByLong(User::getNumberOfPosts).orElse(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre> <br>  By the way, sorting by comparator is added to primitive streams (sometimes it comes in handy).  There, however, there is an extra boxing under the hood, but you can rely on aggressive optimizations of the JIT compiler. <br><br><h4>  Iterable </h4><br>  Many people want <code>Stream</code> implement the <code>Iterable</code> interface, because it contains an <code>iterator()</code> method.  This is not done, in particular, because <code>Iterable</code> implies reusability, and the iterator can only be taken once from the stream.  Although <a href="http://stackoverflow.com/questions/20129762/why-does-streamt-not-implement-iterablet">the Stack Overflow</a> noted that the JDK already has an exception to this rule - <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/DirectoryStream.html">DirectoryStream</a> .  Anyway, sometimes you want to use the usual <code>for</code> loop instead of the terminal <code>forEach</code> .  This gives a number of advantages: you can use any variables, not only effectively final, you can throw any exceptions, it is easier to debug, shorter than the spectra, etc. In general, I think that there is no big sin if you created the stream and immediately use its in <code>for</code> loop.  Of course, care must be taken not to pass it on to methods that take <code>Iterable</code> and can bypass it several times.  Example: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyNonEmptyLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Reader reader, Writer writer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(String line : StreamEx.ofLines(reader).remove(String::isEmpty)) { writer.write(line); writer.write(System.lineSeparator()); } }</code> </pre> <br>  If you like, use, but be careful. <br><br><h4>  Map Keys and Values </h4><br>  Often there is a need to process all <code>Map</code> keys whose values ‚Äã‚Äãsatisfy a given condition, or vice versa.  To write this directly is somewhat sad: you have to mess with <code>Map.Entry</code> .  I hid it under the hood of the static methods <code>ofKeys(map, valuePredicate)</code> and <code>ofValues(map, keyPredicate)</code> : <br><br><pre> <code class="java hljs">Map&lt;String, Role&gt; nameToRole; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEnabledRoleNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.ofKeys(nameToRole, Role::isEnabled).toSet(); }</code> </pre> <br><h4>  EntryStream </h4><br>  For more complex <code>Map</code> processing scenarios, a separate <code>EntryStream</code> class has been <code>EntryStream</code> - <code>Map.Entry</code> object <code>Map.Entry</code> .  It partially repeats the functionality of <code>StreamEx</code> , but also contains additional methods that allow processing keys and values ‚Äã‚Äãseparately.  In some cases, this makes it easier to both generate a new <code>Map</code> and disassemble an existing <code>Map</code> .  For example, you can invert Map-List like this (strings from lists of values ‚Äã‚Äãfall into keys, and keys form new lists of values): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map&lt;String, List&lt;String&gt;&gt; invert(Map&lt;String, List&lt;String&gt;&gt; map) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EntryStream.of(map).flatMapValues(List::stream).invert().grouping(); }</code> </pre> <br>  It uses <code>flatMapValues</code> , which turns the stream <code><code>Entry&lt;String, List&gt;  Entry&lt;String, String&gt;</code> ,  <code>invert</code> ,      ,    <code>grouping</code> ‚Äî      <code>Map</code> . <br> <br>         <code>Map</code>  : <br> <br> <code class="java">public Map&lt;String, String&gt; stringMap(Map&lt;Object, Object&gt; map) { return EntryStream.of(map).mapKeys(String::valueOf).mapValues(String::valueOf).toMap(); }</code> <br>            ,   : <br> <br> <code class="java">Map&lt;String, Group&gt; nameToGroup; public Map&lt;String, List&lt;User&gt;&gt; getGroupMembers(Collection&lt;String&gt; groupNames) { return StreamEx.of(groupNames).mapToEntry(nameToGroup::get).nonNullValues().mapValues(Group::getMembers).toMap(); }</code> <br>  <code>mapToEntry</code>  <code>EntryStream</code>        . <br> <br>    . , - .  ‚Äî  <a href="https://github.com/amaembo/streamex">GitHub</a> ,     <a href="http://repo1.maven.org/maven2/io/github/amaembo/streamex/">Maven Central</a> . JavaDoc  ,      .  , , -   .</code> <code><code>Entry&lt;String, List&gt;  Entry&lt;String, String&gt;</code> ,  <code>invert</code> ,      ,    <code>grouping</code> ‚Äî      <code>Map</code> . <br> <br>         <code>Map</code>  : <br> <br> <code class="java">public Map&lt;String, String&gt; stringMap(Map&lt;Object, Object&gt; map) { return EntryStream.of(map).mapKeys(String::valueOf).mapValues(String::valueOf).toMap(); }</code> <br>            ,   : <br> <br> <code class="java">Map&lt;String, Group&gt; nameToGroup; public Map&lt;String, List&lt;User&gt;&gt; getGroupMembers(Collection&lt;String&gt; groupNames) { return StreamEx.of(groupNames).mapToEntry(nameToGroup::get).nonNullValues().mapValues(Group::getMembers).toMap(); }</code> <br>  <code>mapToEntry</code>  <code>EntryStream</code>        . <br> <br>    . , - .  ‚Äî  <a href="https://github.com/amaembo/streamex">GitHub</a> ,     <a href="http://repo1.maven.org/maven2/io/github/amaembo/streamex/">Maven Central</a> . JavaDoc  ,      .  , , -   .</code> <pre> <code class="hljs javascript"><code>Entry&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, List&gt;  Entry&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;</code> ,  <code>invert</code> ,      ,    <code>grouping</code> ‚Äî      <code><span class="hljs-built_in"><span class="hljs-built_in">Map</span></span></code> . <br> <br>         <code><span class="hljs-built_in"><span class="hljs-built_in">Map</span></span></code>  : <br> <br> <code class="java">public <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; stringMap(<span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt; map) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EntryStream.of(map).mapKeys(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::valueOf).mapValues(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::valueOf).toMap(); }</code> <br>            ,   : <br> <br> <code class="java"><span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Group&gt; nameToGroup; public <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, List&lt;User&gt;&gt; getGroupMembers(Collection&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; groupNames) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.of(groupNames).mapToEntry(nameToGroup::get).nonNullValues().mapValues(Group::getMembers).toMap(); }</code> <br>  <code>mapToEntry</code>  <code>EntryStream</code>        . <br> <br>    . , - .  ‚Äî  <a href="https://github.com/amaembo/streamex">GitHub</a> ,     <a href="http://repo1.maven.org/maven2/io/github/amaembo/streamex/">Maven Central</a> . JavaDoc  ,      .  , , -   .</code> </pre> <code><code>Entry&lt;String, List&gt;  Entry&lt;String, String&gt;</code> ,  <code>invert</code> ,      ,    <code>grouping</code> ‚Äî      <code>Map</code> . <br> <br>         <code>Map</code>  : <br> <br> <code class="java">public Map&lt;String, String&gt; stringMap(Map&lt;Object, Object&gt; map) { return EntryStream.of(map).mapKeys(String::valueOf).mapValues(String::valueOf).toMap(); }</code> <br>            ,   : <br> <br> <code class="java">Map&lt;String, Group&gt; nameToGroup; public Map&lt;String, List&lt;User&gt;&gt; getGroupMembers(Collection&lt;String&gt; groupNames) { return StreamEx.of(groupNames).mapToEntry(nameToGroup::get).nonNullValues().mapValues(Group::getMembers).toMap(); }</code> <br>  <code>mapToEntry</code>  <code>EntryStream</code>        . <br> <br>    . , - .  ‚Äî  <a href="https://github.com/amaembo/streamex">GitHub</a> ,     <a href="http://repo1.maven.org/maven2/io/github/amaembo/streamex/">Maven Central</a> . JavaDoc  ,      .  , , -   .</code> <pre> <code class="hljs javascript"><code>Entry&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, List&gt;  Entry&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;</code> ,  <code>invert</code> ,      ,    <code>grouping</code> ‚Äî      <code><span class="hljs-built_in"><span class="hljs-built_in">Map</span></span></code> . <br> <br>         <code><span class="hljs-built_in"><span class="hljs-built_in">Map</span></span></code>  : <br> <br> <code class="java">public <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; stringMap(<span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt; map) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EntryStream.of(map).mapKeys(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::valueOf).mapValues(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::valueOf).toMap(); }</code> <br>            ,   : <br> <br> <code class="java"><span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Group&gt; nameToGroup; public <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, List&lt;User&gt;&gt; getGroupMembers(Collection&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; groupNames) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamEx.of(groupNames).mapToEntry(nameToGroup::get).nonNullValues().mapValues(Group::getMembers).toMap(); }</code> <br>  <code>mapToEntry</code>  <code>EntryStream</code>        . <br> <br>    . , - .  ‚Äî  <a href="https://github.com/amaembo/streamex">GitHub</a> ,     <a href="http://repo1.maven.org/maven2/io/github/amaembo/streamex/">Maven Central</a> . JavaDoc  ,      .  , , -   .</code> </pre> <code><code>Entry&lt;String, List&gt;  Entry&lt;String, String&gt;</code> ,  <code>invert</code> ,      ,    <code>grouping</code> ‚Äî      <code>Map</code> . <br> <br>         <code>Map</code>  : <br> <br> <code class="java">public Map&lt;String, String&gt; stringMap(Map&lt;Object, Object&gt; map) { return EntryStream.of(map).mapKeys(String::valueOf).mapValues(String::valueOf).toMap(); }</code> <br>            ,   : <br> <br> <code class="java">Map&lt;String, Group&gt; nameToGroup; public Map&lt;String, List&lt;User&gt;&gt; getGroupMembers(Collection&lt;String&gt; groupNames) { return StreamEx.of(groupNames).mapToEntry(nameToGroup::get).nonNullValues().mapValues(Group::getMembers).toMap(); }</code> <br>  <code>mapToEntry</code>  <code>EntryStream</code>        . <br> <br>    . , - .  ‚Äî  <a href="https://github.com/amaembo/streamex">GitHub</a> ,     <a href="http://repo1.maven.org/maven2/io/github/amaembo/streamex/">Maven Central</a> . JavaDoc  ,      .  , , -   .</code> </div><p>Source: <a href="https://habr.com/ru/post/255659/">https://habr.com/ru/post/255659/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255649/index.html">Best approaches to moving a MATLAB code to a fixed point</a></li>
<li><a href="../255651/index.html">Create a beautiful date / time / data picker in android</a></li>
<li><a href="../255653/index.html">Developing a cross-platform application using the Ionic Framework</a></li>
<li><a href="../255655/index.html">Video surveillance through 3 / 4G (part 1)</a></li>
<li><a href="../255657/index.html">Our devices to control the lighting in the smart home</a></li>
<li><a href="../255661/index.html">Magvik filter</a></li>
<li><a href="../255663/index.html">Interview with Stanislav Shalunov - developer of technology used in BitTorrent and Apple</a></li>
<li><a href="../255665/index.html">PHP Digest number 60 - interesting news, materials and tools (March 30 - April 13, 2015)</a></li>
<li><a href="../255667/index.html">We do the IR remote control for the camera</a></li>
<li><a href="../255669/index.html">Bubot: Scout - a machine with control through a web interface without a line of code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>