<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Polymorphism without virtual functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article presents a pattern that can be used to provide dynamic binding without using virtual functions to call overloaded methods for objects of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Polymorphism without virtual functions</h1><div class="post__text post__text-html js-mediator-article">  This article presents a pattern that can be used to provide dynamic binding without using virtual functions to call overloaded methods for objects of a heterogeneous container when it is traversed. <a name="habracut"></a><br><br><h4>  On the Rights of Introduction </h4><br>  It is usually not recommended to resort to shared objects between processes in C ++, however this is possible.  We will understand why this is generally necessary: <br><ol><li>  In dynamic linking, when a virtual function is called for an object, the compiler does not know which function should be executed.  To allow calls to virtual functions, the compiler compiles a <i>table of virtual functions</i> ( <a href="http://en.wikipedia.org/wiki/Virtual_method_table">vtable</a> ) for each class that declares virtual functions.  Vtable contains offsets for these virtual functions.  When, during the execution of a program, a class object is created, it is assigned a pointer to a Vtable class.  Since  this pointer is in the data segment of the process that creates the object, even if the object is created in the shared memory segment, the pointer to the Vtable will be available only for the process that created the object.  This means that other processes that will try to call the virtual function of the shared object will fail.  This is the main reason for considering alternatives to dynamic linking for sharing objects between processes. </li><li>  Pointers to objects in C ++ created in shared memory will be available in different processes only if they associate a shared memory segment with the same virtual address, which the OS cannot guarantee (the OS can offer a virtual address and associate the process with this address only if that address is no longer used).  The solution is to use offsets for virtual addresses, which, when creating a pointer to an object, are added to the base virtual address.  Likewise, instead of pointers in C ++, we must have offsets. </li><li>  The compiler allocates static data members of the class in the standard process data segment, i.e., different processes will have different copies of these members.  Thus, if one copy of these static data members is needed, they must be replaced with offsets by the base virtual address (which is mapped to shared memory). </li><li>  Simultaneous use of the same shared object by different processes may result in data corruption.  To ensure <a href="http://en.wikipedia.org/wiki/Mutual_exclusion">mutual exclusion, mutual</a> <i>IPC</i> ( <a href="http://en.wikipedia.org/wiki/Inter-process_communication">inter-process communication</a> ) mechanism should be used. </li></ol><br>  "Curiously Recurring Template Pattern" ( <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> ) is the most commonly used alternative to dynamic linking.  CRTP is used to implement static polymorphism.  Static polymorphism achieves a similar effect due to virtual functions, allowing you to select overloaded methods in derived classes at the compilation stage, rather than at run time.  Using CRTP, the Derived class inherits the Base base template class that implements the Derived class interface.  To properly remove instances of a derived class, Base inherits the Deletor class, which defines a virtual destructor.  Virtual destructor provides objects of derived classes through a pointer to the base class. <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Deletor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Deletor() {} }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Deletor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;DoIt(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base&lt;Derived1&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* implementation for Derived1 */</span></span> } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base&lt;Derived2&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* implementation for Derived2 */</span></span> } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Derived1 Obj1; Derived2 Obj2; Obj1.Run(); <span class="hljs-comment"><span class="hljs-comment">/* runs DoIt() implementation */</span></span> Obj2.Run(); <span class="hljs-comment"><span class="hljs-comment">/* runs DoIt() implementation */</span></span> };</code> </pre> <br>  Without using a base class of type Deletor, as in the example above, derived classes cannot be stored heterogeneously (for example, in a container), because each CRTP base class is a unique type.  Base and Base are unrelated classes, so even though these objects can be stored heterogeneously in the BaseDeletor * container of objects, it will not be possible to provide polymorphism with iterations (by calling, for example, the DoIt () method, as in the example).  CRTP is suitable for applications where clients need to create only one type of derived class. <br><br><h4>  Simulated interface (design pattern) </h4><br>  The pattern presented here uses templates of static member functions, rather than template classes.  This pattern requires the creation of a base class that defines patterns of static functions that will have access to the interface functions of derived classes.  The goal is to add objects of derived classes to the container and then, when passing the container, it would be possible to call interface functions without having to know anything about the type of the object. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Suppose that we need a class hierarchy with a dynamically related method <code>int siRun(int&amp;)</code> .  We create the base class <code>RunnableInterface</code> with the static template function <code>Run_T</code> and the virtual destructor. <br><br>  <code>Run_T(...)</code> has the same return type and the same input parameters as <code>siRun(..)</code> , plus one additional parameter at the beginning, which is a pointer to the object that the static template function works with.  Thus, we declare a private variable <code>*m_pfnRun_T</code> , which is a function pointer, a constructor initializing this pointer to zero, a template function ( <code>Init</code> ) to set the pointer value to the correct implementation of a static function ( <code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <h4> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </h4> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <ul><li> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </li> <li> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </li> <li> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </li> </ul> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <ol><li> <code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </li> <li> <code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </li> </ol> <code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code><code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <pre> <code class="hljs lua"><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  <span class="hljs-string"><span class="hljs-string">""</span></span>      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">error</span></span></a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span>   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } // This corresponding macro is used to check the existence of the // interface <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derived</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMemberFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME, FNPROTOTYPE)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code><code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(<span class="hljs-number"><span class="hljs-number">1</span></span>); RunnableInterface* const pObj2 = new AdjustmentTest(<span class="hljs-number"><span class="hljs-number">4</span></span>); std::list&lt;RunnableInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} void siRun(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* const pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>   ,    :     . <br>     Qt Creator <span class="hljs-number"><span class="hljs-number">5.0</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>  MinGW <span class="hljs-number"><span class="hljs-number">4.7</span></span> x86    Windows XP  Windows <span class="hljs-number"><span class="hljs-number">7</span></span> x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( <span class="hljs-number"><span class="hljs-number">1</span></span>)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> <span class="hljs-number"><span class="hljs-number">1</span></span> - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a // static boolean member <span class="hljs-string"><span class="hljs-string">"value"</span></span> that is set to <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the specified // member <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function">. // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">This</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">macro</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">created</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">based</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">information</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">that</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">was</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrieved</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">following</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLs</span></span></span><span class="hljs-function">: // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">https</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">groups.google.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forum</span></span></span><span class="hljs-function">/?</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromgroups</span></span></span><span class="hljs-function">#!</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topic</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">comp.lang.c</span></span></span><span class="hljs-function">++/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DAq3H8Ph_1k</span></span></span><span class="hljs-function"> // </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">://</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectmix.com</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-function">/779528-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">member</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">only</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vc</span></span></span><span class="hljs-function">-9-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a.html</span></span></span><span class="hljs-function"> #</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMemberFunctionChecker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FNNAME)</span></span></span></span> template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (&amp; check(...))[<span class="hljs-number"><span class="hljs-number">2</span></span>]; public: static const bool value = (sizeof(check&lt;C&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == sizeof(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulReset_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_ulSayHello_T_Offset(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulRun_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulReset_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_ulSayHello_T_Offset); // Make sure Init() was called. <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBaseOffset = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnReset_T(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_pfnSayHello_T(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} int siRun() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnRun_T); // Make sure Init() was called. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*m_pfnRun_T)(this); } void siReset(int &amp;k) { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   <span class="hljs-number"><span class="hljs-number">2</span></span>      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code><code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> <span class="hljs-number"><span class="hljs-number">2</span></span> - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include <span class="hljs-string"><span class="hljs-string">"testiface.h"</span></span> #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">10</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from Base"</span></span> &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = <span class="hljs-number"><span class="hljs-number">1</span></span>): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">100</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedOnce"</span></span> &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } void siReset(int &amp;k) { k = m_value*<span class="hljs-number"><span class="hljs-number">1000</span></span>; } void siSayHello() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello from DerivedTwice"</span></span> &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   <span class="hljs-number"><span class="hljs-number">3</span></span>   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  <span class="hljs-string"><span class="hljs-string">"OWNER"</span></span> (    ,   )     ;       ; <span class="hljs-string"><span class="hljs-string">"CLIENT"</span></span>               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code><code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code><code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of <span class="hljs-string"><span class="hljs-string">'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'</span></span>; Required from <span class="hljs-string"><span class="hljs-string">'void TestInterface::Init [with T = DerivedTwice]</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><b><span class="hljs-string"><span class="hljs-string"> 3 - main.cpp</span></span></b></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="cpp"><span class="hljs-string"><span class="hljs-string">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process'</span></span> address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">write</span></span> permission <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, BufSize ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pBuf == NULL) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not map view of file ("</span></span> &lt;&lt; GetLastError() &lt;&lt; <span class="hljs-string"><span class="hljs-string">").\n"</span></span> &lt;&lt; std::endl; CloseHandle( hMapFile ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *pBuf1 = (<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*)pBuf; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"OWNER PROCESS: "</span></span> &lt;&lt; std::endl; // Create TestInterface objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> available memory addr pObj3 = new(pBuf1)DerivedTwice; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"CLIENT PROCESS: "</span></span> &lt;&lt; std::endl; // Access objects that are <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> szHexBuf[<span class="hljs-number"><span class="hljs-number">12</span></span>]; sprintf(szHexBuf, <span class="hljs-string"><span class="hljs-string">"0x%lx"</span></span>, (unsigned long) pBuf); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"pBuf: "</span></span> &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a list. std::list&lt;TestInterface*&gt; list1; list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj1); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj2); list1.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(), pObj3); // Let TestInterface objects greet, run <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> reset generically. std::list&lt;TestInterface*&gt;::iterator i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RUN: "</span></span> &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"RESET: "</span></span> &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Press any key to end program"</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and destroy objects in shared memory"</span></span> &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"..."</span></span> &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!kbhit()) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fFirstProcess) { // Objects are no longer needed, call destructors. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = list1.begin(); i != list1.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call <span class="hljs-string"><span class="hljs-string">"delete p;"</span></span> p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </pre> <code><code><code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> <h4> <code><code><code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </h4> <code><code><code><code><code><code>&amp;Run_T)    (siRun</code> )        . <br> <code class="cpp">class RunnableInterface { private: int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun( k ); } protected: template&lt;typename T&gt; void Init() { m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} int siRun(int &amp;k) { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this, k); } virtual ~RunnableInterface() {} };</code> <br> ,  <code>*m_pfnRun_T</code>       <code></code> . <code>void* const pObj</code> ,     <code>RunnableInterface</code> ,     . <br> <br>    ,  ,  ""      (, <code>siRun()</code> ),   <code>static_cast</code>           ,   , ,       .  ,    <i>SFINAE</i> ( <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error</a> ),     ,     ,     ;  <code>CreateMemberFunctionChecked</code>  ,     ""   ,  ,   , ,        .   <code>CheckMemberFunction</code>     <code>Init()</code> ,        .  <code>FNNAME</code>       ;    <code>CheckMemberFunction</code>    ,   <code></code> . <br> <code class="cpp">// Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } // This corresponding macro is used to check the existence of the // interface function in the derived class. #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); }</code> <br>   ,  <code>RunnableInterface</code> : <br> <code class="cpp">class RunnableInterface { private: CreateMemberFunctionChecker(siRun); int (*m_pfnRun_T)(void* const, int&amp;); template&lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k ) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } protected: template&lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)(int&amp;)); m_pfnRun_T = &amp;Run_T&lt;T&gt;; } public: RunnableInterface(): m_pfnRun_T(0) {} virtual ~RunnableInterface() {} int siRun(int &amp;k) { assert(m_pfnRun_T); return (*m_pfnRun_T)(this, k); } };</code> <br>        ,   <code>int siRun(int &amp;k)</code> . ,         -  <code>Init();   int Derived::siRun(int &amp;k)</code>        ( <code>Run_T</code> ),   : <br> <code class="cpp">class Test: public RunnableInterface { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*2; return 0; } protected: int m_value; public: Test(int value): m_value(value) { RunnableInterface::Init&lt;Test&gt;(); } }; class AdjustmentTest: public Test { friend class RunnableInterface; private: int siRun(int &amp;k) { k = m_value*3; return 0; } public: AdjustmentTest(int value): Test(value) { RunnableInterface::Init&lt;AdjustmentTest&gt;(); } };</code> <br> <code>friend class RunnableInterface;</code>       ,     <code>RunnableInterface</code>       <code>private</code>  <code>protected</code> . <br>         <code>TestInterface*</code>       (      CRTP),    : <br> <code class="cpp">int main() { RunnableInterface* const pObj1 = new Test(1); RunnableInterface* const pObj2 = new AdjustmentTest(4); std::list&lt;RunnableInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); std::list&lt;RunnableInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++ ) { RunnableInterface* const p = *i; int k; const int j = p-&gt;siRun(k); std::cout &lt;&lt; "RUN: " &lt;&lt; j &lt;&lt; ":" &lt;&lt; k &lt;&lt; std::endl &lt;&lt; std::endl; delete p; } return 0; }</code> <br>      -      <code>RunnableInterface</code> ?  ,             - ,      .        ,               . ,   ,       ,    .  Windows, <code>GetModuleHandle()</code> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684229(v%3Dvs.85).aspx"></a>  ,      .               .  ,  Windows     : <br> <code class="cpp">class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siRun(k); } typedef void (*PFN_RUN_T)(void* const, int&amp;); CreateMemberFunctionChecker(siRun); // Offset to static template member functions. unsigned long m_ulRun_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, void (T::*)(int&amp;)); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0) {} void siRun(int &amp;k) { assert(m_ulRun_T_Offset); // Make sure Init() was called. char* const pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); (*pfnRun_T)(this, k); } virtual ~TestInterface() {} };</code> <br>  <br>     1, 2  3   ,    :     . <br>     Qt Creator 5.0.2  MinGW 4.7 x86    Windows XP  Windows 7 x64. <br> <img src="http://habrastorage.org/storage2/e92/59a/6eb/e9259a6eb35be39caf7217ed69b4ecd9.jpg"> <br> <br>  testiface.h ( 1)   TestInterface,    : <br> int siRun(); void siReset(int &amp;k); void siSayHello(); <br> <i><b> 1 - testiface.h</b></i> <br> <code class="cpp">#ifndef TESTIFACE_H #define TESTIFACE_H #include &lt;windows.h&gt; // for GetModuleHandle() // Using the SFINAE (Substitution Failure Is Not An Error) technique, // the following macro creates a template class with typename T and a // static boolean member "value" that is set to true if the specified // member function exists in the T class. // This macro was created based on information that was retrieved from // the following URLs: // https://groups.google.com/forum/?fromgroups#!topic/comp.lang.c++/DAq3H8Ph_1k // http://objectmix.com/c/779528-call-member-function-only-if-exists-vc-9-a.html #define CreateMemberFunctionChecker(FNNAME) template&lt;typename T&gt; struct has_member_##FNNAME; template&lt;typename R, typename C&gt; class has_member_##FNNAME&lt;RC::*&gt; { private: template&lt;RC::*&gt; struct helper; template&lt;typename T&gt; static char check(helper&lt;&amp;T::FNNAME&gt;*); template&lt;typename T&gt; static char (&amp; check(...))[2]; public: static const bool value = (sizeof(check&lt;C&gt;(0)) == sizeof(char)); } #define CheckMemberFunction(FNNAME, FNPROTOTYPE) { assert(has_member_##FNNAME&lt;FNPROTOTYPE&gt;::value); } typedef int (*PFN_RUN_T)(void* const); typedef void (*PFN_RESET_T)(void* const, int&amp;); typedef void (*PFN_SAYHELLO_T)(void* const); #ifndef SINGLE_PROCESS class TestInterface { private: // Implement template functions. template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); // Offsets to static template member functions. unsigned long m_ulRun_T_Offset, m_ulReset_T_Offset, m_ulSayHello_T_Offset; protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); char *pBaseOffset = (char*)GetModuleHandle(NULL); m_ulRun_T_Offset = (unsigned long)&amp;Run_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulReset_T_Offset = (unsigned long)&amp;Reset_T&lt;T&gt; - (unsigned long)pBaseOffset; m_ulSayHello_T_Offset = (unsigned long)&amp;SayHello_T&lt;T&gt; - (unsigned long)pBaseOffset; } public: TestInterface(): m_ulRun_T_Offset(0), m_ulReset_T_Offset(0), m_ulSayHello_T_Offset(0) {} int siRun() { assert(m_ulRun_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RUN_T pfnRun_T = (PFN_RUN_T)(pBaseOffset + m_ulRun_T_Offset); return (*pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_ulReset_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_RESET_T pfnReset_T = (PFN_RESET_T)(pBaseOffset + m_ulReset_T_Offset); (*pfnReset_T)(this, k); } void siSayHello() { assert(m_ulSayHello_T_Offset); // Make sure Init() was called. char *pBaseOffset = (char*)GetModuleHandle(NULL); PFN_SAYHELLO_T pfnSayHello_T = (PFN_SAYHELLO_T)(pBaseOffset + m_ulSayHello_T_Offset); (*pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #else class TestInterface { private: template &lt;typename T&gt; static int Run_T(void* const pObj) { return static_cast&lt;T*&gt;(pObj)-&gt;siRun(); } template &lt;typename T&gt; static void Reset_T(void* const pObj, int &amp;k) { static_cast&lt;T*&gt;(pObj)-&gt;siReset(k); } template &lt;typename T&gt; static void SayHello_T(void* const pObj) { static_cast&lt;T*&gt;(pObj)-&gt;siSayHello(); } // Pointers to static template member functions. PFN_RUN_T m_pfnRun_T; PFN_RESET_T m_pfnReset_T; PFN_SAYHELLO_T m_pfnSayHello_T; CreateMemberFunctionChecker(siRun); CreateMemberFunctionChecker(siReset); CreateMemberFunctionChecker(siSayHello); protected: template &lt;typename T&gt; void Init() { CheckMemberFunction(siRun, int (T::*)()); CheckMemberFunction(siReset, void (T::*)(int&amp;)); CheckMemberFunction(siSayHello, void (T::*)()); m_pfnRun_T = &amp;Run_T&lt;T&gt;; m_pfnReset_T = &amp;Reset_T&lt;T&gt;; m_pfnSayHello_T = &amp;SayHello_T&lt;T&gt;; } public: TestInterface(): m_pfnRun_T(0), m_pfnReset_T(0), m_pfnSayHello_T(0) {} int siRun() { assert(m_pfnRun_T); // Make sure Init() was called. return (*m_pfnRun_T)(this); } void siReset(int &amp;k) { assert(m_pfnReset_T); // Make sure Init() was called. (*m_pfnReset_T)(this, k); } void siSayHello() { assert(m_pfnSayHello_T); // Make sure Init() was called. (*m_pfnSayHello_T)(this); } virtual ~TestInterface() {} }; #endif // SINGLE_PROCESS #endif // TESTIFACE_H</code> <br> testclasses.h   2      <code>Base</code> ( <code>TestInterface</code> ), <code>DerivedOnce</code> ( <code>Base</code> )  <code>DerivedTwice</code> ( <code>DerivedOnce</code> ).        <code>TestInterface::Init(),  </code> -  .  ,     ,    <code>TestInterface()</code> .      <code>TestInterface</code>      <code>siRun, siReset, siSayHello</code> ,     <code>private/protected</code> . <br> <br> <i><b> 2 - testclasses.h</b></i> <br> <code class="cpp">#ifndef TESTCLASSES_H #define TESTCLASSES_H #ifndef TESTIFACE_H #include "testiface.h" #endif class Base: public TestInterface { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*10; } void siSayHello() { std::cout &lt;&lt; "Hello from Base" &lt;&lt; std::endl; } protected: int m_value; public: Base(int value = 1): m_value(value) { TestInterface::Init&lt;Base&gt;(); } }; class DerivedOnce: public Base { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*100; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedOnce" &lt;&lt; std::endl; } public: DerivedOnce(): Base() { TestInterface::Init&lt;DerivedOnce&gt;(); ++m_value; } }; class DerivedTwice: public DerivedOnce { friend class TestInterface; private: int siRun() { return m_value; } void siReset(int &amp;k) { k = m_value*1000; } void siSayHello() { std::cout &lt;&lt; "Hello from DerivedTwice" &lt;&lt; std::endl; } public: DerivedTwice(): DerivedOnce() { TestInterface::Init&lt;DerivedTwice&gt;(); ++m_value; } }; #endif // TESTCLASSES_H</code> <br>  main.cpp   3   WinAPI  : <br>   <code>Base, DerivedOnce, DerivedTwice</code>      (owner)         (client) <br>   ,               <code>TestInterface*</code> ,     <code>siRun, siReset, siSayHello</code> .         ;  "OWNER" (    ,   )     ;       ; "CLIENT"               (   ,  .. ),        ,              . <br> <br>      ,  <code>DerivedTwice::siSayHello()</code> ,     .      (-  <code class="bash">CheckMemberFunction(siSayHello, void (T::*)())  TestInterface::Init()): <br> Assertion failed! Expression: has_member_siSayHello&lt;void (T::*)()&gt;::value</code> <br>    <code>siSayHello</code>  <code>DerivedTwice</code> ,  -  (, <code>double d</code> ),    .     (-  <code>TestInterface::Init()   DerivedTwice</code> ): <br> <code class="bash">In instantiation of 'static void TestInterface::SayHello_T(void*) [with T = DerivedTwide]'; Required from 'void TestInterface::Init [with T = DerivedTwice]</code> <br> <i><b> 3 - main.cpp</b></i> <br> <code class="cpp">#include &lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;assert.h&gt; #include "testclasses.h" int main() { const SIZE_T BufSize = 1024; const TCHAR szName[] = TEXT("Local\\SharedMemBlockObject"); const HANDLE hMapFile = CreateFileMapping( INVALID_HANDLE_VALUE, // use paging file NULL, // default security PAGE_READWRITE, // read/write access 0, // maximum object size (high-order DWORD) BufSize, // maximum object size (low-order DWORD) szName ); // name of mapping object if (hMapFile == NULL) { std::cout &lt;&lt; "Could not create file mapping object (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; return 1; } const bool fFirstProcess = (GetLastError() != ERROR_ALREADY_EXISTS); // Map the file to this process' address space. const LPCTSTR pBuf = (LPTSTR) MapViewOfFile( hMapFile, // handle to map object FILE_MAP_ALL_ACCESS, // read/write permission 0, 0, BufSize ); if (pBuf == NULL) { std::cout &lt;&lt; "Could not map view of file (" &lt;&lt; GetLastError() &lt;&lt; ").\n" &lt;&lt; std::endl; CloseHandle( hMapFile ); return 1; } Base *pObj1; DerivedOnce *pObj2; DerivedTwice *pObj3; char *pBuf1 = (char*)pBuf; if (fFirstProcess) { std::cout &lt;&lt; "OWNER PROCESS: " &lt;&lt; std::endl; // Create TestInterface objects in shared memory. pObj1 = new(pBuf1)Base; // first available memory addr pBuf1 += sizeof(Base); // skip to next available memory addr pObj2 = new(pBuf1)DerivedOnce; pBuf1 += sizeof(DerivedOnce); // skip to next available memory addr pObj3 = new(pBuf1)DerivedTwice; } else { std::cout &lt;&lt; "CLIENT PROCESS: " &lt;&lt; std::endl; // Access objects that are in shared memory. pObj1 = (Base*)pBuf1; // addr where Base obj was created pBuf1 += sizeof(Base); pObj2 = (DerivedOnce*)pBuf1; // addr where DerivedOnce obj was created pBuf1 += sizeof(DerivedOnce); pObj3 = (DerivedTwice*)pBuf1; // addr where DerivedTwice obj was created } char szHexBuf[12]; sprintf(szHexBuf, "0x%lx", (unsigned long) pBuf); std::cout &lt;&lt; "pBuf: " &lt;&lt; szHexBuf &lt;&lt; std::endl &lt;&lt; std::endl; // Place TestInterface* objects in a list. std::list&lt;TestInterface*&gt; list1; list1.insert(list1.end(), pObj1); list1.insert(list1.end(), pObj2); list1.insert(list1.end(), pObj3); // Let TestInterface objects greet, run and reset generically. std::list&lt;TestInterface*&gt;::iterator i; for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; p-&gt;siSayHello(); std::cout &lt;&lt; "RUN: " &lt;&lt; p-&gt;siRun() &lt;&lt; std::endl; int kk; p-&gt;siReset( kk ); std::cout &lt;&lt; "RESET: " &lt;&lt; kk &lt;&lt; std::endl &lt;&lt; std::endl; } std::cout &lt;&lt; "Press any key to end program" &lt;&lt; std::endl; if (fFirstProcess) std::cout &lt;&lt; " and destroy objects in shared memory" &lt;&lt; std::endl; std::cout &lt;&lt; "..." &lt;&lt; std::endl; while (!kbhit()) Sleep(100); if (fFirstProcess) { // Objects are no longer needed, call destructors. for (i = list1.begin(); i != list1.end(); i++) { TestInterface* const p = *i; // We need to call the destructor explicitly because // the new with placement operator was used. // We cannot call "delete p;" p-&gt;~TestInterface(); } } UnmapViewOfFile(pBuf); CloseHandle(hMapFile); return 0; }</code> <br>    <br> ,    ,  ,                .          .               .</code></code></code></code></code> </div><p>Source: <a href="https://habr.com/ru/post/182824/">https://habr.com/ru/post/182824/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182806/index.html">Qualimetric approach to rating startups</a></li>
<li><a href="../182808/index.html">WWDC: The official broadcast will be available on Apple.com and Apple TV</a></li>
<li><a href="../182812/index.html">Sale of tablets from Barnes & Noble - up to 44% discount</a></li>
<li><a href="../182820/index.html">Search on Drupal 7 using Apache Solr Part 5 - widgets for facet filters</a></li>
<li><a href="../182822/index.html">Console comfort 2</a></li>
<li><a href="../182826/index.html">SQL Reporting Services in the Clouds</a></li>
<li><a href="../182828/index.html">"Continuous page repainting and debugging page redrawing" in Chrome Dev Tools</a></li>
<li><a href="../182832/index.html">Universal Remote Control for XBMC from TP Link MR3020</a></li>
<li><a href="../182834/index.html">Spintires campaign on Kickstarter was a success</a></li>
<li><a href="../182840/index.html">Transferring backups to offsite storage: WAN accelerator in Veeam Backup & Replication v7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>