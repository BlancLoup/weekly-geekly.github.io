<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the Go Module System</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The upcoming release of version 1.11 of the Go programming language will bring experimental support for the modules ‚Äî a new dependency management syst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the Go Module System</h1><div class="post__text post__text-html js-mediator-article"><p>  The upcoming release of version 1.11 of the Go programming language will bring experimental support for the <em>modules</em> ‚Äî a new dependency management system for Go.  (comment perev .: <a href="">release took place</a> ) </p><br><p>  Recently <a href="https://roberto.selbach.ca/playing-with-go-modules/">I wrote about this small post</a> .  Since then, something has changed slightly, and we have become closer to release, so it seems to me that the time has come for a new article - add more practice. </p><br><p>  So, here's what we‚Äôll do: create a new package and then make a few releases to see how it works. </p><a name="habracut"></a><br><h2 id="sozdanie-modulya">  Module creation </h2><br><p> First, create our package.  Let's call it "testmod".  An important detail: <strong>the package directory should be placed <em>outside of</em> your <code>$GOPATH</code> , because, inside it, module support is disabled by default</strong> .  Go modules are the first step to total <code>$GOPATH</code> rejection in the future. </p><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> testmod $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> testmod</code> </pre> <br><p>  Our package is quite simple: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf("Hi, %s", name) }</span></span></code> </pre> <br><p>  The package is ready, but it is not yet a <em>module</em> .  Let's fix it. </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mod init github.com/robteix/testmod <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: creating <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>.mod: module github.com/robteix/testmod</code> </pre> <br><p>  We have a new file called <code>go.mod</code> in the package directory with the following contents: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span></span></code> </pre> <br><p>  Not much, but this is exactly what turns our package into a <em>module</em> . </p><br><p>  Now we can push this code into the repository: </p><br><pre> <code class="hljs ruby">$ git init $ git add * $ git commit -am <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> $ git push -u origin master</code> </pre> <br><p>  Until now, anyone willing to use our package would apply <code>go get</code> : </p><br><pre> <code class="hljs swift">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/testmod</code> </pre> <br><p>  And this command would bring the latest code from the <code>master</code> branch.  This option still works, but it would be better for us not to do this anymore, because now "there is a better way."  It is dangerous to take code directly from the <code>master</code> branch, since we never know for sure that the authors of the package have not made changes that will ‚Äúbreak‚Äù our code.  To solve this particular problem, the Go modules were invented. </p><br><h2 id="nebolshoe-otstuplenie-o-versionirovanii-moduley">  A small digression about module versioning </h2><br><p>  Go modules are versioned, plus there is some specificity of individual versions.  You will have to become familiar with the concepts underlying <a href="https://semver.org/lang/ru/">semantic versioning</a> . </p><br><p>  In addition, Go uses repository tags when looking for versions, and some versions are different from the rest: for example, versions 2 and more should have a different import path than for versions 0 and 1 (we get to that). </p><br><p>  By default, Go loads the latest <em>version with a label</em> available in the repository. <br>  This is an important feature, since it can be used when working with the <code>master</code> branch. </p><br><p>  What is important for us now is that when creating the release of our package, we need to put a label with the version in the repository. </p><br><p>  Let's do it and do it. </p><br><h2 id="delaem-svoy-pervyy-reliz">  Making your first release </h2><br><p>  Our package is ready and we can "release" it to the whole world.  We do this with the help of version labels.  Let the version number be 1.0.0: </p><br><pre> <code class="hljs ruby">$ git tag v1.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> $ git push --tags</code> </pre> <br><p>  These commands create a label in my Github repository that marks the current commit as release 1.0.0. </p><br><p>  Go does not push this, but it‚Äôs a good idea to create an additional new branch ("v1") to which we can send fixes. </p><br><pre> <code class="hljs ruby">$ git checkout -b v1 $ git push -u origin v1</code> </pre> <br><p>  Now we can work in the <code>master</code> branch without worrying that we can break our release. </p><br><h2 id="ispolzovanie-nashego-modulya">  Using our module </h2><br><p>  Let's use the created module.  We will write a simple program that imports our new package: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"roberto"</span></span>)) }</code> </pre> <br><p>  Until now, you would run <code>go get github.com/robteix/testmod</code> to download the package, but with the modules it becomes more interesting.  First we need to enable modules support in our new program. </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> init <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span></code> </pre> <br><p>  As you probably expected, based on what was read earlier, a new <code>go.mod</code> file with the module name inside appeared in the directory: </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mod</span></span></span></span></code> </pre> <br><p>  The situation becomes even more interesting when we try to build our program: </p><br><pre> <code class="hljs go">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: finding github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span>: downloading github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  As you can see, the <code>go</code> command automatically found and downloaded the package imported by our program. <br>  If we check our <code>go.mod</code> file, we see that something has changed: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  And we have another new file called <code>go.sum</code> , which contains package hashes to check the correctness of the version and files. </p><br><pre> <code class="hljs matlab">github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> h1:<span class="hljs-number"><span class="hljs-number">9</span></span>EdH0EArQ/rkpss9Tj8gUnwx3w5p0jkzJrd5tRAhxnA= github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>/go.<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> h1:UVhi5McON9ZLc5kl5iN2bTXlL6ylcxE9VInV71RrlO8=</code> </pre> <br><h2 id="delaem-reliz-reliz-s-ispravleniem-oshibki">  Making a release with bug fix. </h2><br><p>  Now, let's say we found a problem in our package: there is no punctuation in the greeting! <br>  Some people will get mad, because our friendly greeting is no longer so friendly. <br>  Let's fix this and release a new version: </p><br><pre> <code class="hljs pgsql">// Hi <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a friendly greeting func Hi(<span class="hljs-type"><span class="hljs-type">name</span></span> string) string { - <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s", <span class="hljs-type"><span class="hljs-type">name</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf("Hi, %s!", <span class="hljs-type"><span class="hljs-type">name</span></span>) }</code> </pre> <br><p>  We made this change right in the <code>v1</code> branch, because it has nothing to do with what we will do next in the <code>v2</code> branch, but in real life, you might need to make these changes to the <code>master</code> and then backport them to <code>v1</code> .  In any case, the fix should be in the <code>v1</code> branch and we need to mark it as a new release. </p><br><pre> <code class="hljs ruby">$ git commit -m <span class="hljs-string"><span class="hljs-string">"Emphasize our friendliness"</span></span> testmod.go $ git tag v1.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> $ git push --tags origin v1</code> </pre> <br><h2 id="obnovlenie-moduley">  Modules update </h2><br><p>  By default, Go does not update modules without demand.  "And this is good," because we all would like to be predictable in our builds.  If the Go modules would be updated automatically every time a new version comes out, we would return to the "Dark Ages to-Go1.11".  But no, we need <em>to tell</em> Go to update the modules for us. </p><br><p>  And we will do it with the help of our old friend - <code>go get</code> : </p><br><ul><li><p>  run <code>go get -u</code> to use the last <em>minor or patch</em> release (i.e., the command will update from 1.0.0 to, say, 1.0.1 or to 1.1.0, if such a version is available) </p><br></li><li><p>  Run <code>go get -u=patch</code> to use the latest patch version (i.e., the package will be updated to 1.0.1, but <em>not</em> to 1.1.0) </p><br></li><li><p>  Run <code>go get package@version</code> to upgrade to a specific version (for example, <code>github.com/robteix/testmod@v1.0.1</code> ) </p><br></li></ul><br><p>  In this list there is no way to upgrade to the latest <em>major</em> version.  There is a good reason for this, as we shall soon see. </p><br><p>  Since our program used version 1.0.0 of our package and we just created version 1.0.1, <em>any</em> of the following commands will update us to 1.0.1: </p><br><pre> <code class="hljs kotlin">$ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -u $ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> -u=patch $ go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/robteix/<span class="hljs-symbol"><span class="hljs-symbol">testmod@</span></span>v1.0.1</code> </pre> <br><p>  After starting (say <code>go get -u</code> ), our <code>go.mod</code> has changed: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span></code> </pre> <br><h2 id="mazhornye-versii">  Major versions </h2><br><p>  In accordance with the specification of semantic versioning, the major version <em>differs</em> from the minor version.  Major versions may break backward compatibility.  From the point of view of the Go modules, the major version is a completely <em>different package</em> . </p><br><p>  It may sound wild at first, but it makes sense: two versions of the library that are incompatible with each other are two different libraries. </p><br><p>  Let's make a major change in our package.  Suppose, over time, it became clear to us that our API is too simple, too limited for our users  usceices ‚Äô, so we need to change the <code>Hi()</code> function to accept the greeting language as a parameter: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> testmod <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Hi returns a friendly greeting in language lang func Hi(name, lang string) (string, error) { switch lang { case "en": return fmt.Sprintf("Hi, %s!", name), nil case "pt": return fmt.Sprintf("Oi, %s!", name), nil case "es": return fmt.Sprintf("¬°Hola, %s!", name), nil case "fr": return fmt.Sprintf("Bonjour, %s!", name), nil default: return "", errors.New("unknown language") } }</span></span></code> </pre> <br><p>  Existing programs that use our API will break down because they a) do not pass the language as a parameter and b) do not expect an error to return.  Our new API is no longer compatible with version 1.x, so meet version 2.0.0. </p><br><p>  Earlier, I mentioned that some versions have features, and now such a case. <br>  <strong>Versions 2 <em>and more</em> should change the import path.</strong>  Now they are different libraries. </p><br><p>  We will do this by adding a new <em>version path</em> to the name of our module. </p><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">github</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">robteix</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testmod</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span></span></code> </pre> <br><p>  Everything else is the same: push, put a label that is v2.0.0 (and optionally sod v2) </p><br><pre> <code class="hljs smalltalk"><span class="hljs-string"><span class="hljs-string">$ </span></span>git commit testmod.go -m <span class="hljs-comment"><span class="hljs-comment">"Change Hi to allow multilang"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git checkout -b v2 # optional but recommended <span class="hljs-string"><span class="hljs-string">$ </span></span>echo <span class="hljs-comment"><span class="hljs-comment">"module github.com/robteix/testmod/v2"</span></span> &gt; go.mod <span class="hljs-string"><span class="hljs-string">$ </span></span>git commit go.mod -m <span class="hljs-comment"><span class="hljs-comment">"Bump version to v2"</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git tag v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-string"><span class="hljs-string">$ </span></span>git push --tags origin v2 # or master if we don<span class="hljs-string"><span class="hljs-string">'t have a branch</span></span></code> </pre> <br><h2 id="obnovlenie-mazhornoy-versii">  Major version upgrade </h2><br><p>  Even though we have released a new, incompatible version of our library, the existing programs are <em>not broken</em> , because they continue to use version 1.0.1. <br>  <code>go get -u</code> <em>will not</em> download version 2.0.0. </p><br><p>  But at some point, as a library user, I may want to upgrade to version 2.0.0, because, for example, I am one of those users who need support for multiple languages. </p><br><p>  To upgrade, you need to change my program accordingly: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { g, err := testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  Now, when I start <code>go build</code> , it ‚Äúcomes off‚Äù and will download version 2.0.0 for me.  Note that although the import path now ends with "v2", Go still refers to the module by its real name ("testmod"). </p><br><p>  As I said, the major version is a different package in all respects.  These two Go modules are unrelated.  This means that we can have two incompatible versions in one binary: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod"</span></span> testmodML <span class="hljs-string"><span class="hljs-string">"github.com/robteix/testmod/v2"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(testmod.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>)) g, err := testmodML.Hi(<span class="hljs-string"><span class="hljs-string">"Roberto"</span></span>, <span class="hljs-string"><span class="hljs-string">"pt"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } fmt.Println(g) }</code> </pre> <br><p>  And it eliminates the common problem with dependency management, when dependencies depend on different versions of the same library. </p><br><h2 id="navodim-poryadok">  Restore order </h2><br><p>  Let's go back to the previous version, which uses only testmod 2.0.0 - if we now check the contents of <code>go.mod</code> , we notice something: </p><br><pre> <code class="hljs lua">module <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod v1<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> github.com/robteix/testmod/v2 v2<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span></code> </pre> <br><p>  By default, Go does not remove dependencies from <code>go.mod</code> until you ask for it.  If you have dependencies that are no longer needed, and you want to clean them, you can use the new <code>tidy</code> command: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> tidy</code> </pre> <br><p>  Now we have only those dependencies that we really use. </p><br><h2 id="vendoring">  Vending </h2><br><p>  Go modules ignore the <code>vendor/</code> directory by default.  The idea is to gradually get rid of vendoring <sup><a href="https://habr.com/ru/post/421411/">1</a></sup> .  But if we still want to add "checked out" dependencies to our version control, we can do it: </p><br><pre> <code class="hljs matlab">$ go <span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p>  The team will create the <code>vendor/</code> directory in the root of our project, containing the source code of all dependencies. </p><br><p>  However, the <code>go build</code> by default still ignores the contents of this directory.  If you want to collect dependencies from the <code>vendor/</code> directory, you must explicitly ask for this. </p><br><pre> <code class="hljs matlab">$ go build -<span class="hljs-built_in"><span class="hljs-built_in">mod</span></span> vendor</code> </pre> <br><p>  I assume that many developers who want to use vendor will run <code>go build</code> , as usual, on their machines and use <code>-mod vendor</code> on their CIs. </p><br><p>  Again, the Go modules are moving away from the idea of ‚Äã‚Äãvendoring to using proxies for modules for those who do not want to directly depend on the upstream version control services. </p><br><p>  There are ways to ensure that <code>go</code> will not be available network (for example, using <code>GOPROXY=off</code> ), but this is the topic of the next article. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The article may seem complicated to someone, but this is due to the fact that I tried to explain a lot of things at once.  The reality is that Go modules are generally simple today - we, as usual, import the package into our code, and the <code>go</code> command does the rest for us.  Build dependencies are automatically loaded. </p><br><p>  The modules also eliminate the need for <code>$GOPATH</code> , which was a stumbling block for new Go developers who had trouble understanding why you need to put something in a particular directory. </p><br><p><del>  Vending (unofficially) declared obsolete in favor of using a proxy. </del>  <sup><a href="https://habr.com/ru/post/421411/">one</a></sup> <br>  I can make a separate article about proxies for Go modules. </p><br><p>  Notes: </p><br><p>  <sup>1</sup> I think this is too loud, and some may have the impression that the vendoring is being removed right now.  This is not true.  Vending still works, albeit slightly differently than before.  Apparently, there is a desire to replace the vendor with something better, for example, a proxy (not a fact).  For now, it's just a desire for a better solution.  Vending will not go away until a good replacement is found (if there is one). </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/421411/">https://habr.com/ru/post/421411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421399/index.html">Turla Cybergroup Outlook Backdoor Analysis</a></li>
<li><a href="../421401/index.html">Anatomy of recommendation systems. Part two</a></li>
<li><a href="../421403/index.html">Security Week 32: Fortnite Android Drama</a></li>
<li><a href="../421407/index.html">Technical mitap in Petersburg on September 13 - How to make big changes on the backend</a></li>
<li><a href="../421409/index.html">Spy stuff: stay secret</a></li>
<li><a href="../421413/index.html">Proper access to default methods of interfaces through reflection in Java 8, 9, 10</a></li>
<li><a href="../421415/index.html">Magic Leap - sad trash</a></li>
<li><a href="../421417/index.html">Coffee machine for coffee independent or Wacaco mobile coffee machine</a></li>
<li><a href="../421419/index.html">An ode to ‚Äúfoamed‚Äù nickel, non-existent sapphires and the Soviet deputy minister: the iconic OTTO SX-P1 in Japan, the USA and the USSR</a></li>
<li><a href="../421421/index.html">LAppS: Half a million 1KB-WebSocket messages per second with TLS on one CPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>