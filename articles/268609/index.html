<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust in details: we write scalable chat from scratch, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1: Implementing WebSocket. Introduction 
 In this series of articles we will look at the process of creating a scalable chat that will work in re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust in details: we write scalable chat from scratch, part 1</h1><div class="post__text post__text-html js-mediator-article"><h2>  Part 1: Implementing WebSocket.  Introduction </h2><br>  In this series of articles we will look at the process of creating a scalable chat that will work in real time. <br>  The purpose of this review is to step through the basics of the rapidly gaining popularity of the Rust programming language in practice, with fair system interface coverage. <br><br>  In the first part, we will look at the initial setting of the environment and the implementation of the simplest WebSocket server.  To understand the technical details of the article, you will not need experience with the Rust language, although knowledge of the basics of the system API (POSIX) and C / C ++ will not be superfluous.  Before you start reading, prepare a little time (and coffee) - the article describes everything as detailed as possible and therefore quite long. <br><br><a name="habracut"></a><br><h2>  1 Rust - the reason for choosing </h2><br>  I became interested in the Rust programming language because of a long-standing fascination with system programming, which is an interesting though, but also quite complicated - all because there are a lot of completely unobvious moments and tricky problems for both novice and experienced developers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/6cb/58e/b4c/6cb58eb4cc054b529dba66132d4a45b9.png" align="right">  And, perhaps, the most difficult problem here is safe work with memory.  It is the incorrect work with memory that causes many bugs: <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B1%25D1%2583%25D1%2584%25D0%25B5%25D1%2580%25D0%25B0">buffer overflow</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2582%25D0%25B5%25D1%2587%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">memory leaks</a> , double memory <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2581%25D1%258F%25D1%2587%25D0%25B8%25D0%25B9_%25D1%2583%25D0%25BA%25D0%25B0%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C">freeings</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2581%25D1%258F%25D1%2587%25D0%25B8%25D0%25B9_%25D1%2583%25D0%25BA%25D0%25B0%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C">hanging references</a> , pointer dereferencing to already freed memory, etc.  And such errors sometimes entail serious problems in security - for example, the cause of the not-long-ago sensational bug in OpenSSL, <a href="https://ru.wikipedia.org/wiki/Heartbleed">Heartbleed</a> , is nothing more than a careless handling of memory.  And this is only the tip of the iceberg - no one knows how many similar gaps lie in the software that we use every day. <br><br>  C ++ has come up with several ways to solve such problems ‚Äî for example, using smart pointers <sup><a href="https://habr.com/ru/post/268609/">[1]</a></sup> or allocation on the stack <sup><a href="https://habr.com/ru/post/268609/">[2]</a></sup> .  Unfortunately, even applying such approaches, there is still a chance that, as it were, ‚Äúshoot yourself a leg‚Äù - go beyond the buffer or use low-level functions for working with memory that always remain available. <br><br>  That is, at the level of the language there is no obligatory condition to apply such practices - instead, it is considered that ‚Äúgood developers‚Äù always use them themselves and never make mistakes.  However, I believe that the existence of such critical problems in the code is in no way connected with the level of developers, because people cannot thoroughly check manually large amounts of code - this is the task of the computer.  To some extent, static analysis tools help here - but, again, they are used by no means all and not always. <br><br>  It is for this reason that there is another fundamental method of getting rid of problems in working with memory: garbage collection is a separate complex area of ‚Äã‚Äãknowledge in computer science.  Almost all modern languages ‚Äã‚Äãand virtual machines have some form of automatic garbage collection, and despite the fact that in most cases this is a fairly good solution, it has its drawbacks: first, automatic garbage collectors are difficult to understand and implement <sup><a href="https://habr.com/ru/post/268609/">[3 ]</a></sup> .  Secondly, the use of garbage collection implies a pause to free up unused memory <sup><a href="https://habr.com/ru/post/268609/">[4]</a></sup> , which usually entails the need for fine-tuning to reduce waiting time in high-loaded applications. <br><br>  The Rust language has a different approach to the problem - one can say the golden mean - automatic release of memory and resources without additional memory consumption or processor time and without the need to independently monitor each step.  This is achieved through the use of the concepts of <em>ownership</em> and <em>borrowing</em> . <br><br>  The language is based on the assertion that each value can have only one <em>owner</em> - that is, there can be only one variable variable pointing to a specific memory area: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     (),   1, 2,  3, //       `foo`. let bar = foo; //     `bar`. //          `foo`, //      "" - ..,    .</span></span></code> </pre> <br><br>  This approach has interesting consequences: since the value is associated exclusively with one variable, the resources associated with this value (memory, file descriptors, sockets, etc.) are automatically released when the variable leaves the scope (which is specified by blocks of code inside the curly braces , <code>{</code> and <code>}</code> ). <br><br>  Such artificial restrictions may seem unnecessary and unnecessarily overcomplicated, but if you think well, then, by and large, this is the ‚Äúkiller feature‚Äù Rust, which appeared solely for practical reasons.  This approach allows Rust to look like a high-level language while maintaining the effectiveness of low-level code written in C / C ++. <br><br>  However, despite all its interesting features, until recently Rust had its own serious flaws - for example, a very unstable API, in which no one could guarantee the preservation of compatibility.  But the creators of the language have come a long way in almost a decade <sup><a href="https://habr.com/ru/post/268609/">[5]</a></sup> , and now, with the release of a stable version 1.0, the language has evolved to a state where it can be started to be put into practice in real projects. <br><br><h2>  2 Goals </h2><br>  I prefer to learn new languages ‚Äã‚Äãand concepts by developing relatively simple projects with applications in the real world.  Thus, the possibilities of the language are studied precisely when they become necessary.  As a project for studying Rust, I chose anonymous chat service like Chat Roulette and many others.  In my opinion, this is a suitable choice for the reason that chats are usually demanding a low response time from the server and imply a large number of simultaneous connections.  We will count on several thousand - so we can look at the memory consumption and performance of programs written in Rust in a real environment. <br><br>  The end result should be a binary program file with scripts for deploying our server on various cloud hosting. <br><br>  But before we start writing code, we need to make a small digression to clarify some points with I / O, since proper work with it is a key point when developing network services. <br><br><h2>  3 I / O options </h2><br>  To complete the tasks, our service needs to send and receive data through network sockets. <br><br>  At first glance, the task is simple, but in fact there are many possible ways to solve it of varying complexity and varying effectiveness.  The main difference between them lies in the approach to <em>locks</em> : the standard practice here is to stop the processor while waiting for new data to arrive in the socket. <br><br>  Since we cannot build a service for one user who will block the rest, we must somehow isolate them from each other.  A typical solution is to create a separate thread of execution for each user.  Thus, not the whole process will be blocked, but only one of its threads.  The disadvantage of this approach, despite its relative simplicity, is the increased memory consumption ‚Äî each thread, when created, reserves some part of the memory for the stack <sup><a href="https://habr.com/ru/post/268609/">[6]</a></sup> .  In addition, the case is complicated by the need to <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">switch the</a> execution <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581%25D1%2582%25D0%25B0">context</a> - modern server processors usually have from 8 to 16 cores, and if we create more threads than hardware allows, the OS scheduler stops coping with switching tasks with sufficient speed. <br><br>  Therefore, scaling a multi-threaded program to a large number of connections can be quite difficult, and in our case it is hardly reasonable at all - after all, we are planning several thousand simultaneously connected users.  In the end, you have to be ready for the Habraeffect! <br><br><h2>  4 event loop </h2><br><img src="https://habrastorage.org/files/4a2/6db/edc/4a26dbedc5e64bc7a65e904f75424d4f.png" align="left">  To work effectively with I / O, we will use multiplexing system APIs based on <em>the event loop</em> .  The Linux kernel has an <em>epoll</em> mechanism <sup><a href="https://habr.com/ru/post/268609/">[7]</a></sup> for this, and <em>kqueue</em> <sup><a href="https://habr.com/ru/post/268609/">[8]</a></sup> in FreeBSD and OS X. <br><br>  Both of these APIs are arranged in a rather similar way, and the general idea is simple: instead of waiting for new data to come to the sockets through the network, we ask the <em>sockets to notify us</em> of the bytes that came. <br><br>  Alerts in the form of <em>events</em> come in a common cycle, which in this case acts as a blocker.  That is, instead of constantly checking thousands of sockets for the presence of new data in them, we just wait for the sockets themselves to tell us about it - and the difference is quite significant, since quite often connected users are in standby mode, sending nothing and not getting.  This is especially true for applications using WebSocket.  In addition, using asynchronous I / O, we have virtually no overhead - all that is required to be stored in memory is the socket file descriptor and client status (in the case of a chat, this is several hundred bytes per connection). <br><br>  A curious feature of this approach is the ability to use asynchronous I / O not only for network connections, but also, for example, to read files from disk - the event loop accepts any type of file descriptors (and sockets in the * NIX world are them). <br><br><blockquote>  The event loop in Node.js and the EventMachine gems in Ruby work in exactly the same way. <br>  The same is true for the nginx web server, which uses exclusively asynchronous I / O <sup><a href="https://habr.com/ru/post/268609/">[9]</a></sup> . <br></blockquote><br><br><h2>  5 Starting a project </h2><br><blockquote>  Further text implies that you already have Rust installed.  If not, then follow the <a href="http://kgv.github.io/rust_book_ru/src/installing-rust.html">documentation on the official site</a> . <br></blockquote><br>  In the standard delivery of Rust, there is a program called <code>cargo</code> that performs functions similar to Maven, Composer, npm, or rake - it manages dependencies of our application, builds a project, runs tests, and most importantly, it simplifies the process of creating a new project. <br><br>  This is what we need at the moment, so let's try to open a terminal and type this command: <br><br><pre> <code class="hljs pgsql">cargo <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> chat <span class="hljs-comment"><span class="hljs-comment">--bin</span></span></code> </pre><br><br>  The argument <code>--bin</code> indicates to Cargo that it is necessary to create a running application, and not a library. <br><br>  As a result, we will have two files: <br><br><pre> <code class="hljs">Cargo.toml src/main.rs</code> </pre><br><br>  <code>Cargo.toml</code> contains a description and links to project dependencies (similar to <code>package.json</code> in JavaScript). <br>  <code>src/main.rs</code> is the main source file and entry point to our program. <br><br>  We won't need anything else to begin with, so you can try to compile and run the program with one command - <code>cargo run</code> .  The same command displays errors in the code, if any. <br><br><blockquote>  If you are a happy Emacs user, you will be happy to know that it is compatible with Cargo ‚Äúout of the box‚Äù - just install the <code>rust-mode</code> package from the MELPA repository and configure the compile command to start the <code>cargo build</code> . <br></blockquote><br><br><h2>  6 Event Handling in Rust </h2><br>  Let's move from theory to practice.  Let's try to run a simple event loop that will wait for new messages to appear.  To do this, we do not need to manually connect various system APIs - just use the existing library for working with asynchronous I / O called <em>‚Äú <a href="https://github.com/carllerche/mio">Metal IO</a> ‚Äù</em> or <em>mio</em> . <br><br>  As you remember, the Cargo program handles dependencies.  It loads libraries from the <a href="https://crates.io/"><em>crates.io</em></a> repository, but also allows you to get them from the Git repository directly - this option is useful in cases where we need to use the latest version of the library that has not yet been loaded into the package repository. <br><br>  At the time of writing this article, only the already outdated version 0.3 is available in the repository for <code>mio</code> - there are many useful changes in the development version 0.4, which are also incompatible with the old versions.  Therefore, we connect it directly through GitHub, adding such lines to <code>Cargo.toml</code> : <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies.mio</span></span>] git = <span class="hljs-string"><span class="hljs-string">"https://github.com/carllerche/mio"</span></span></code> </pre><br><br>  After we have defined the dependency in the project description, we will add import to <code>main.rs</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> mio; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> mio::*;</code> </pre><br><br>  Using <code>mio</code> is easy.  First of all, let's create a loop of events by calling the <code>EventLoop::new()</code> function.  From the empty cycle, however, there is no use, so let's immediately add event handling to our chat, defining a <a href="http://kgv.github.io/rust_book_ru/src/structs.html"><em>structure</em></a> with functions that will correspond to the <code>Handler</code> interface. <br><br>  Although in the Rust language there is no support for ‚Äútraditional‚Äù object-oriented programming, structures are in many ways similar to classes, and in a manner similar to classical OOP, they can implement interfaces that are regulated in the language through <a href="http://kgv.github.io/rust_book_ru/src/traits.html"><em>types</em></a> . <br><br>  Let's define a new structure: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketServer</span></span></span></span>;</code> </pre><br><br>  And we realize the type <a href="https://carllerche.github.io/mio/mio/trait.Handler.html"><code>Handler</code></a> for her: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> WebSocketServer { <span class="hljs-comment"><span class="hljs-comment">//         ,  //  Handler     :  //      . //          ,    //      mio: type Timeout = usize; type Message = (); }</span></span></code> </pre><br><br>  Now run the event loop: <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> event_loop = EventLoop::new().unwrap(); <span class="hljs-comment"><span class="hljs-comment">//     Handler: let mut handler = WebSocketServer; // ...        : event_loop.run(&amp;mut handler).unwrap(); }</span></span></code> </pre><br><br>  Here, for the first time, we encounter the use of <em>borrowings</em> : notice the <code>&amp;mut</code> on the last line.  This means that we temporarily transfer ‚Äúownership‚Äù of a value, associating it with another variable with the possibility of <em>changing (mutation) the</em> data. <br><br><img src="https://habrastorage.org/files/3bf/4d9/f97/3bf4d9f975bf45999980199c9935215e.png"><br><br>  Simply put, you can imagine the principle of borrowing as follows (pseudocode): <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     "" -  owner: let mut owner = value; //          : { let mut borrow = owner; //        . //        : borrow.mutate(); //       : owner = borrow; }</span></span></code> </pre><br><br>  The above code is equivalent to this: <br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//     "" -  owner: let owner = value; { //     : let mut borrow = &amp;mut owner; //     ,     . //       : borrow.mutate(); //         //     . }</span></span></code> </pre><br><br>  For each <em>scope</em> , a variable can have only one <em>mutable borrow</em> , and even the value owner cannot read or change it until the borrowing goes out of scope. <br><br>  In addition, there is a simpler way to borrow values ‚Äã‚Äãthrough <em>immutable borrow (immutable borrow)</em> , which allow the value to be read-only.  And, unlike <code>&amp;mut</code> , changeable borrowing, it does not set any limits on reading, only on writing - as long as there are unchangeable borrowings in the field of visibility, the value cannot change and be borrowed through <code>&amp;mut</code> . <br><br>  It's okay if such a description did not seem clear enough to you - sooner or later an intuitive understanding will come, since the borrowings in Rust are used everywhere, and as you read the article you will find more practical examples. <br><br>  Now let's go back to our project.  Run the ‚Äú <code>cargo run</code> ‚Äù command and Cargo will download all necessary dependencies, compile the program (with some warnings that we can ignore for now), and launch it. <br><br>  As a result, we will see a terminal window with a flashing cursor.  This is not a very interesting result, but at least it shows that the program is running correctly - we have successfully launched a cycle of events, although it still doesn‚Äôt do anything useful.  Let's fix this situation. <br><br><blockquote>  To interrupt the execution of the program, use the key combination Ctrl + C. <br></blockquote><br><br><h2>  7 TCP server </h2><br>  To start a TCP server that will accept connections via the WebSocket protocol, we will use the intended structure (struct) - <code>TcpListener</code> from the <code>mio::tcp</code> package.  The process of creating a server-side TCP socket is fairly straightforward - we bind to a specific address (IP + port number), listen to the socket, and accept connections.  We will not depart much from him. <br><br>  Let's take a look at the code: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> mio::tcp::*; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::net::SocketAddr; ... <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> address = <span class="hljs-string"><span class="hljs-string">"0.0.0.0:10000"</span></span>.parse::&lt;SocketAddr&gt;().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> server_socket = TcpListener::bind(&amp;address).unwrap(); event_loop.register(&amp;server_socket, Token(<span class="hljs-number"><span class="hljs-number">0</span></span>), EventSet::readable(), PollOpt::edge()).unwrap();</code> </pre><br><br>  Let's look at it line by line. <br><br>  First of all, we need to import into the scope of our <code>main.rs</code> module a packet for working with TCP and the <code>SocketAddr</code> structure describing the socket address ‚Äî we add these lines to the beginning of the file: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> mio::tcp::*; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::net::SocketAddr;</code> </pre><br><br>  Let's parse the string <code>"0.0.0.0:10000"</code> into the structure describing the address and assign a socket to this address: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> address = <span class="hljs-string"><span class="hljs-string">"0.0.0.0:10000"</span></span>.parse::&lt;SocketAddr&gt;().unwrap(); server_socket.bind(&amp;address).unwrap();</code> </pre><br><br>  Notice how the compiler outputs the necessary type of structure for us: since <code>server_socket.bind</code> expects an argument of type <code>SockAddr</code> , we do not need to specify it explicitly and clutter the code ‚Äî the Rust compiler is able to determine it itself. <br><br>  Create a listening socket and start listening: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> server_socket = TcpListener::bind(&amp;address).unwrap();</code> </pre><br><br>  You might also notice that we almost always call <code>unwrap</code> for the result of the function ‚Äî this is the error handling pattern in Rust, and we will return to this topic soon. <br><br>  Now let's add the created socket to the event loop: <br><br><pre> <code class="rust hljs">event_loop.register(&amp;server_socket, Token(<span class="hljs-number"><span class="hljs-number">0</span></span>), EventSet::readable(), PollOpt::edge()).unwrap();</code> </pre><br><br>  The <code>register</code> call is more complicated - the function takes the following arguments: <br><br><ul><li>  <em>Token</em> is a unique identifier for the socket.  When an event enters a loop, we must somehow understand which socket it belongs to - in this case, the <em>token</em> serves as a link between the sockets and the events generated by them.  In the example above, we associate a <code>Token(0)</code> token with a server socket waiting for a connection. </li><li>  <em>EventSet</em> describes which events we subscribe to: the arrival of new data on a socket, the availability of a socket for writing, or both.  <code>EventSet::readable()</code> in the case of a server socket only signs us up for one event ‚Äî the establishment of a connection with a new client. </li><li>  <em>PollOpt</em> sets event subscription settings.  <code>PollOpt::edge()</code> means that events are triggered <em>by a front (edge-triggered)</em> , and not <em>by a level (level-triggered)</em> . <br><br>  The difference between the two approaches, whose names are borrowed from electronics, is when the socket notifies us of an event that has occurred - for example, when a data receipt event occurs (that is, if we subscribe to the <code>readable()</code> event) in the event of a level trigger, we get alert if the socket buffer has readable data.  In the case of a signal at the front, we will receive an alert at the moment when the socket receives <em>new data</em> ‚Äî that is, if we did not read the entire contents of the buffer while processing the event, we will not receive new alerts until new ones are received. data.  A more detailed description (in English) is in response to the <a href="http://stackoverflow.com/questions/1966863/level-vs-edge-trigger-network-event-mechanisms">Stack Overflow</a> . </li></ul><br><br>  Now let's compile the resulting code and run the program using the <code>cargo run</code> command.  In the terminal, we still will not see anything except the blinking cursor - but if we separately execute the <code>netstat</code> command, we will see that our socket is waiting for connections to the port number 10,000: <br><br><pre> $ netstat -ln |  grep 10,000
 tcp 0 0 127.0.0.1:10000 0.0.0.0:* LISTEN
</pre><br><br><h2>  8 Accepted connections </h2><br>  All connections using the <em>WebSocket</em> protocol begin with <em>handshaking</em> (so-called <em>handshake</em> ) - a special sequence of requests and responses sent over HTTP.  This means that before proceeding with the implementation of WebSocket, we must teach our server to communicate using the basic protocol, HTTP / 1.1. <br><br>  But we need only a small part of HTTP: a client who wants to establish a connection through WebSocket sends a request with <code>Connection: Upgrade</code> and <code>Upgrade: websocket</code> , and we must respond to this request in a certain way.  And that's all - we do not need to write a full-fledged web server with the distribution of files, static content, etc.  - for this there are more advanced and suitable tools (for example, the same nginx). <br><br><img src="https://habrastorage.org/files/8ff/ce8/90d/8ffce890d31a41fbac9b6ca594128c7f.png"><br>  <em>WebSocket connection request headers.</em> <br><br><br>  But before we start implementing HTTP, we need to write code to establish connections with clients and subscribe to events coming from them. <br><br>  Consider the basic implementation: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketServer</span></span></span></span> { socket: TcpListener, clients: HashMap&lt;Token, TcpStream&gt;, token_counter: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_TOKEN: Token = Token(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> WebSocketServer { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timeout</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> = (); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ready</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, event_loop: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> EventLoop&lt;WebSocketServer&gt;, token: Token, events: EventSet) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> token { SERVER_TOKEN =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client_socket = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.accept() { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }, <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">None</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">" accept  'None'"</span></span>), <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(sock)) =&gt; sock }; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.token_counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_token = Token(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.token_counter); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients.insert(new_token, client_socket); event_loop.register(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients[&amp;new_token], new_token, EventSet::readable(), PollOpt::edge() | PollOpt::oneshot()).unwrap(); } } } }</code> </pre><br><br>  There was a lot of code, so let's take a closer look at it - step by step. <br><br>  First of all, we need to add a state to the server structure of <code>WebSocketServer</code> - it will store the server socket and the sockets of the connected clients. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketServer</span></span></span></span> { socket: TcpListener, clients: HashMap&lt;Token, TcpStream&gt;, token_counter: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre><br><br>  To store client sockets, we use the <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> data structure from the standard collection library, <code>std::collections</code> is the standard implementation for <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588-%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">hash tables</a> (also known as dictionaries and associative arrays).  As a key, we will use tokens that are already familiar to us, which should be unique for each connection. <br><br>  To start, we can generate tokens in a simple way - using a counter, which we will increment by one for each new connection.  To do this, we need the <code>token_counter</code> variable in the structure. <br><br>  Next, the <code>Handler</code> type from the <code>mio</code> library comes in handy again: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> WebSocketServer</code> </pre><br><br>  In the implementation of the type, we need to <em>override</em> the callback function (callback) - <code>ready</code> .  Redefinition is understood to mean that the <code>Handler</code> type already contains a <code>ready</code> dummy function and blanks for some other callback functions.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The implementation defined in the type does not, of course, do anything useful, so we need to define our own version of the function to handle the events of interest to us: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ready</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, event_loop: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> EventLoop&lt;WebSocketServer&gt;, token: Token, events: EventSet)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function will be called every time the socket becomes available for reading or writing (depending on the subscription), and through its call parameters we get all the necessary information: an instance of the structure of the event cycle, the token associated with the event source (in this case, the socket), and a special structure </font></font><code>EventSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that contains a set of flags with information about the event ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in case of notification of the availability of a socket for reading, or </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">writable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - for writing, respectively). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A listening socket generates </font><em><font style="vertical-align: inherit;">readable</font></em><font style="vertical-align: inherit;"> events.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the moment when the new client enters the waiting queue. But before we begin to connect, we need to make sure that the source of the event is the listening socket. We can easily verify this using </font></font><em><a href="http://kgv.github.io/rust_book_ru/src/patterns.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pattern matching</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> token { SERVER_TOKEN =&gt; { ... } }</code> </pre><br><br>  What does it mean?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The syntax </font></font><code>match</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resembles the standard </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">switch</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> construction </font><font style="vertical-align: inherit;">of ‚Äútraditional‚Äù imperative programming languages, but gives much more possibilities. </font><font style="vertical-align: inherit;">For example, in Java, a construct is </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limited to a specific set of types and works only for numbers, strings, and enum enums. </font><font style="vertical-align: inherit;">In Rust, however, </font></font><code>match</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it allows you to make comparisons for almost any type, including multiple values, structures, etc. </font><font style="vertical-align: inherit;">In addition to matching, it </font></font><code>match</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also allows capturing content or parts of samples in a manner similar to regular expressions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the above example, we associate a token with a sample </font></font><code>Token(0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äî as you remember, it is associated with a listening socket. </font><font style="vertical-align: inherit;">And to make our intentions more understandable when reading the code, we defined this token as a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constant</font></font></em> <code>SERVER_TOKEN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_TOKEN: Token = Token(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the example of expression </font></font><code>match</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in this case is equivalent to this: </font></font><code>match { Token(0) =&gt; ... }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we are sure that we are dealing with a server socket, we can establish a connection with the client:</font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client_socket = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.accept() { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }, <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">None</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">unreachable!</span></span>(), <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(sock)) =&gt; sock };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we do the pattern matching again, this time checking the result of executing the function </font></font><code>accept()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that returns the client socket in a type ‚Äúwrapper‚Äù </font></font><code>Result&lt;Option&lt;TcpStream&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><em><code>Result</code></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a special type that is fundamental to error handling in Rust ‚Äî it is a wrapper around ‚Äúunspecified‚Äù results, such as errors, timeouts (time-out), etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In each case, we can decide for ourselves what to do with such results, but correctly processing all errors, although, of course, correctly, but rather tedious. Here we are assisted by a function already familiar to us </font></font><code>unwrap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which provides standard behavior: interrupting program execution in the event of an error, and ‚Äúunpacking‚Äù the result of executing the function from the container</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the event that everything is in order. Thus, using </font></font><code>unwrap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we mean that we are only interested in the immediate result, and the situation with the fact that the program will stop its execution in case of an error suits us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a valid behavior in some moments, however, in the case of </font></font><code>accept()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it, it would be unwise to use it </font></font><code>unwrap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since in the case of an unsuccessful set of circumstances, a call may turn into stopping our server and disconnecting all users. Therefore, we simply output the error to the log and continue with the execution:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; },</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type </font></font><code>Option</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- similar to the </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúwrapper‚Äù, which determines the presence or absence of any value. The absence of a value is indicated by </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, otherwise, the value takes the form </font></font><code>Some(value)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As you probably guess, this type is comparable to the types of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">None</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in other languages, only </font></font><code>Option</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">safer due to the fact that all </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values ‚Äã‚Äãare localized and (as well as </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) require mandatory ‚Äúunpacking‚Äù before use - so you will never see ‚ÄúFamous‚Äù mistake </font></font><code>NullReferenceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if you don‚Äôt want it yourself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So let's unpack the result returned </font></font><code>accept()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">None</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">unreachable!</span></span>(),</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the situation is when the value is </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not </font><font style="vertical-align: inherit;">returned as a result </font><font style="vertical-align: inherit;">- </font></font><code>accept()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will </font><font style="vertical-align: inherit;">be </font><font style="vertical-align: inherit;">returned </font><font style="vertical-align: inherit;">only if we try to call this function as applied to the client (that is, not listening) socket. And since we are sure that we are dealing with a server-side socket, then we shouldn‚Äôt have to do this before executing this piece of code in a normal situation - so we use a special construct </font></font><code>unreachable!()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that interrupts the program with an error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We continue to compare the results with the samples:</font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client_socket = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.accept() { ... <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(sock)) =&gt; sock }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the most interesting thing: since it </font></font><code>match</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is not just an instruction, but an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expression</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (that is, it </font></font><code>match</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also returns a result), in addition to matching, it also allows you to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capture</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> values. Thus, we can use it to assign results to variables ‚Äî which we do above, unpacking the value from a type </font></font><code>Result&lt;Option&lt;TcpStream&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and assigning it to a variable </font></font><code>client_socket</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We save the resulting socket in a hash table, not forgetting to increase the token counter:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> new_token = Token(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.token_counter); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients.insert(new_token, client_socket); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.token_counter += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we need to subscribe to events from the socket with which we have just established a connection ‚Äî let's register it in the event loop. This is done in exactly the same way as with the registration of the server socket, only now we will provide another token as parameters, and, of course, another socket:</font></font><br><pre> <code class="rust hljs">event_loop.register(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients[&amp;new_token], new_token, EventSet::readable(), PollOpt::edge() | PollOpt::oneshot()).unwrap();</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You may have noticed another difference in the set of arguments: in addition to </font></font><code>PollOpt::edge()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we have added a new option </font></font><code>PollOpt::oneshot()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It instructs to temporarily remove the registration of a socket from a loop when an event is triggered, which is useful for simplifying server code. </font><font style="vertical-align: inherit;">Without this option, we would need to manually monitor the current state of the socket ‚Äî can we now write, can we now read, etc. </font><font style="vertical-align: inherit;">Instead, we will simply register the socket every time, with the set of options and subscriptions we need at the moment. </font><font style="vertical-align: inherit;">On top of that, this approach is useful for multi-threaded event cycles, but more on that next time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, due to the fact that our structure</font></font><code>WebSocketServer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complicated, we need to change the server registration code in the event loop. </font><font style="vertical-align: inherit;">The changes are quite simple and mainly concern the initialization of the new structure:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> server = WebSocketServer { token_counter: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">//     1 clients: HashMap::new(), //   -, HashMap socket: server_socket //       }; event_loop.register(&amp;server.socket, SERVER_TOKEN, EventSet::readable(), PollOpt::edge()).unwrap(); event_loop.run(&amp;mut server).unwrap();</span></span></code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9 Parsim HTTP </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have established a connection with the client, according to the protocol, we need to parse the incoming HTTP request and ‚Äú </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upgrade</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù the connection to the WebSocket protocol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this is a rather boring task, we will not do all this manually - instead, we will use the </font></font><code>http-muncher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP parsing </font><font style="vertical-align: inherit;">library </font><font style="vertical-align: inherit;">, adding it to the dependency list. </font><font style="vertical-align: inherit;">The library adapts the HTTP parser from Node.js for Rust (which is also a parser in nginx), which allows processing requests in streaming mode, which will be very useful for TCP connections. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's add dependencies to </font></font><code>Cargo.toml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] http-muncher = <span class="hljs-string"><span class="hljs-string">"0.2.0"</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We will not consider the library API in detail, and immediately proceed to writing the parser: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> http_muncher; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> http_muncher::{Parser, ParserHandler}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpParser</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ParserHandler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> HttpParser { } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketClient</span></span></span></span> { socket: TcpStream, http_parser: Parser&lt;HttpParser&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketClient { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">2048</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.try_read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf) { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {:?}"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }, <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">None</span></span>) =&gt; <span class="hljs-comment"><span class="hljs-comment">//      . break, Ok(Some(len)) =&gt; { self.http_parser.parse(&amp;buf[0..len]); if self.http_parser.is_upgrade() { // ... break; } } } } } fn new(socket: TcpStream) -&gt; WebSocketClient { WebSocketClient { socket: socket, http_parser: Parser::request(HttpParser) } } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we also need to make some changes to the implementation of the function </font></font><code>ready</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the structure </font></font><code>WebSocketServer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> token { SERVER_TOKEN =&gt; { ... <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients.insert(new_token, WebSocketClient::new(client_socket)); event_loop.register(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients[&amp;new_token].socket, new_token, EventSet::readable(), PollOpt::edge() | PollOpt::oneshot()).unwrap(); ... }, token =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients.get_mut(&amp;token).unwrap(); client.read(); event_loop.reregister(&amp;client.socket, token, EventSet::readable(), PollOpt::edge() | PollOpt::oneshot()).unwrap(); } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try again to consider the new code line by line. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we import the library and add the controlling structure for the parser:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> http_muncher; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> http_muncher::{Parser, ParserHandler}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpParser</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ParserHandler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> HttpParser { }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we add a type implementation </font></font><code>ParserHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that contains some useful callback functions (as well as </font></font><code>Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>mio</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the case of a structure </font></font><code>WebSocketServer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). These callbacks are called as soon as the parser has any useful information - HTTP headers, request content, and so on. But now we just need to find out if the client sent a set of special headers to switch the HTTP connection to the WebSocket protocol. In the structure of the parser, there are already necessary functions for this, therefore, we will not redefine callbacks yet, leaving their standard implementations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there is one detail: the HTTP parser has its own state, which means that we will need to create a new instance of the structure.</font></font><code>HttpParser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for every new customer. </font><font style="vertical-align: inherit;">Given that each client will keep parser status, let's create a new structure that describes an individual client:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketClient</span></span></span></span> { socket: TcpStream, http_parser: Parser&lt;HttpParser&gt; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since now we can store the client socket in the same place, we can replace the definition </font></font><code>HashMap&lt;Token, TcpStream&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>HashMap&lt;Token, WebSocketClient&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the server structure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, it would be convenient to move the code that relates to the processing of clients in the same structure - if you keep everything in one function </font></font><code>ready</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the code will quickly turn into ‚Äúnoodles‚Äù. </font><font style="vertical-align: inherit;">So let's add a separate implementation </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the structure </font></font><code>WebSocketClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketClient { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { ... } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function does not need to take any parameters - we already have a required state inside the structure itself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can start reading data from the client:</font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">2048</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.try_read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf) { ... } }</code> </pre><br><br>  What's going on here?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We begin an infinite loop (construction </font></font><code>loop { ... }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), allocate 2 KB of memory for the buffer where we will write data, and try to write incoming data to it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The call </font></font><code>try_read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may fail, so we are matching the sample by type </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.try_read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf) { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(e) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {:?}"</span></span>, e); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }, ... }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we check if there are any more bytes to read in the TCP socket buffer: </font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.try_read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf) { ... <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">None</span></span>) =&gt; <span class="hljs-comment"><span class="hljs-comment">//      . break, ... }</span></span></code> </pre><br><br> <code>try_read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the result </font></font><code>Ok(None)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if we have read all the available data from the client. </font><font style="vertical-align: inherit;">When this happens, we interrupt the endless cycle and continue to wait for new events. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, here is the handling of the case when the call has </font></font><code>try_read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">written data to our buffer:</font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.try_read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf) { ... <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(len)) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.http_parser.parse(&amp;buf[<span class="hljs-number"><span class="hljs-number">0</span></span>..len]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.http_parser.is_upgrade() { <span class="hljs-comment"><span class="hljs-comment">// ... break; } } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we send the data to the parser and immediately check the existing HTTP headers for the presence of a request to ‚Äúswitch‚Äù the connection to WebSocket mode (more precisely, we expect the header </font></font><code>Connection: Upgrade</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last improvement is a function </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that we need in order to make it more convenient to create instances of the client structure </font></font><code>WebSocketClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(socket: TcpStream) -&gt; WebSocketClient { WebSocketClient { socket: socket, http_parser: Parser::request(HttpParser) } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the so-called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">associated function</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which in its behavior is in many respects similar to the static methods from the traditional object-oriented approach, and </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can compare the </font><font style="vertical-align: inherit;">function specifically </font><font style="vertical-align: inherit;">with the designer. Here we simply create an instance </font></font><code>WebSocketClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but it should be understood that we can do it in the same way without the ‚Äúconstructor‚Äù function ‚Äî this is more a matter of convenience, because without using constructor functions, the code can become often repetitive, without any particular need. In the end, the principle of </font></font><a href="https://ru.wikipedia.org/wiki/Don%25E2%2580%2599t_repeat_yourself"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DRY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (‚Äúdo not repeat‚Äù) was invented for a reason. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are a couple of details. Please note that we do not use the keyword</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explicitly - Rust allows you to automatically return the last expression of a function as its result. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this line requires an explanation:</font></font><br><pre> <code class="rust hljs">http_parser: Parser::request(HttpParser)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we create a new instance of the structure </font></font><code>Parser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using an associative function </font></font><code>Parser::request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As an argument, we pass the created instance of the previously defined structure </font></font><code>HttpParser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have dealt with clients, we can return to the server code, in which </font></font><code>ready</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we make the following changes </font><font style="vertical-align: inherit;">in the handler </font><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> token { SERVER_TOKEN =&gt; { ... }, token =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients.get_mut(&amp;token).unwrap(); client.read(); event_loop.reregister(&amp;client.socket, token, EventSet::readable(), PollOpt::edge() | PollOpt::oneshot()).unwrap(); } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have added a new condition in </font></font><code>match</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which handles all other tokens, besides </font></font><code>SERVER_TOKEN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- that is, events in client sockets. </font><font style="vertical-align: inherit;">With the existing token, we can borrow a variable reference to the corresponding instance of the client structure from the hash table:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.clients.get_mut(&amp;token).unwrap();</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's call for this client the function </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we defined above:</font></font><br><br><pre> <code class="rust hljs">client.read();</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end, we have to re-register the client in the event loop (due </font></font><code>oneshot()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><pre> <code class="rust hljs">event_loop.reregister(&amp;client.socket, token, EventSet::readable(), PollOpt::edge() | PollOpt::oneshot()).unwrap();</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the differences from the client socket registration procedure are minor - in fact, we simply change the name of the called function from </font></font><code>register</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>reregister</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, passing all the same parameters. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all - now we know when the client wants to establish a connection using the WebSocket protocol, and now we can think about how to respond to such requests.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10 Connection confirmation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In fact, we could send back such a simple set of headers: </font></font><br><br><pre> <code class="hljs pgsql">HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">101</span></span> Switching Protocols <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: Upgrade Upgrade: websocket</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it were not for one important detail: the WebSocket protocol commits us to also send a properly composed header </font></font><code>Sec-WebSocket-Accept</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. According to the </font></font><a href="https://tools.ietf.org/html/rfc6455"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you need to do this by following certain rules - we need to get and remember the header sent by the client </font></font><code>Sec-WebSocket-Key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, add a certain static string ( </font></font><code>"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) to it, then hash the result with the SHA-1 algorithm, and finally encode it all in base64. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The standard Rust library has no functions for working with SHA-1 and base64, but all the necessary libraries are in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crates.io</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repository </font><font style="vertical-align: inherit;">, so let's add them to ours </font></font><code>Cargo.toml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] ... rustc-serialize = <span class="hljs-string"><span class="hljs-string">"0.3.15"</span></span> sha1 = <span class="hljs-string"><span class="hljs-string">"0.1.1"</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The library </font></font><code>rustc-serialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains functions for encoding binary data in base64, and </font></font><code>sha1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obviously, for hashing in SHA-1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function that generates the response key is quite simple:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> sha1; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> rustc_serialize; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> rustc_serialize::base64::{ToBase64, STANDARD}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen_key</span></span></span></span>(key: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> m = sha1::Sha1::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">20</span></span>]; m.update(key.as_bytes()); m.update(<span class="hljs-string"><span class="hljs-string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span></span>.as_bytes()); m.output(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf.to_base64(STANDARD); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We get the link to the string with the key as an argument of the function </font></font><code>gen_key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, create a new instance of the SHA-1 hash, add the key sent by the client to it, then add the constant string defined in the RFC, and return the result as a string encoded in base64. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in order to use this function as intended, we first need to get a header from the client </font></font><code>Sec-WebSocket-Key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Let's go back to the HTTP parser from the previous section. As you remember, the type </font></font><code>ParserHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows us to redefine callbacks that are called when new headers are received. Now is the time to take advantage of this opportunity - let's improve the implementation of the relevant structure:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpParser</span></span></span></span> { current_key: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;, headers: Rc&lt;RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;&gt;&gt; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ParserHandler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> HttpParser { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_header_field</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, s: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.current_key = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(std::<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>::from_utf8(s).unwrap().to_string()); <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_header_value</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, s: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.headers.borrow_mut() .insert(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.current_key.clone().unwrap(), std::<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>::from_utf8(s).unwrap().to_string()); <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_headers_complete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By itself, this code is quite simple, but here we are faced with a new important concept - </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">co-ownership</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you already know, in Rust a value can have only one owner, but in some moments we may need to share ownership - for example, in this case we need to find a specific header in the hash table, but at the same time we need to write these headers in the parser. Thus, we get 2 owners of the variable </font></font><code>headers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>WebSocketClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ParserHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/files/38e/1eb/db1/38e1ebdb168f49fc926e8050b11bb8f0.png" align="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To resolve this contradiction in Rust there is a special type </font></font><a href="https://doc.rust-lang.org/std/rc/"><code>Rc</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is a wrapper with </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reference counting</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (which can be considered a type of garbage collection). Basically, we transfer ownership of the container.</font></font><code>Rc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which in turn we can safely share into many owners with the help of black language magic - we just clone the value </font></font><code>Rc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using the function </font></font><code>clone()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the container manages the memory for us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">True, there is a nuance here - a value that contains </font></font><code>Rc</code> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unchangeable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and due to the limitations of the compiler, we cannot somehow influence it. In fact, this is just a consequence of the Rust rule about the variability of data - you can have as many borrowings as a variable, but you can only change it if the owner is one.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here a contradiction comes again - after all, we need to add new headings to the list, despite the fact that we are sure that we change this variable only in one place, so that we do not formally break the Rust rules. Only the compiler with us on this score will not agree - when you try to change the contents </font></font><code>Rc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a compilation error will occur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, of course, in the language there is a solution to this problem - it uses another type of container </font></font><a href="https://doc.rust-lang.org/core/cell/index.html"><code>RefCell</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It solves it due to the mechanism </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data </font><em><font style="vertical-align: inherit;">internal variability</font></em><font style="vertical-align: inherit;"> . Simply put, </font></font><code>RefCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it allows us to put aside all the validation rules to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runtime</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (runtime) - instead of having to check them statically at </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compile time</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Thus, we will need to wrap our headers in two containers at the same time - </font></font><code>Rc&lt;RefCell&lt;...&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(which, of course, looks pretty scary for unprepared minds). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at these lines from the handler </font></font><code>HttpParser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.headers.borrow_mut() .insert(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.current_key.clone().unwrap(), ...</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a construction is generally consistent with changeable borrowing </font></font><code>&amp;mut</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, with the difference that all checks for limiting the number of borrowings will be carried out dynamically during program execution, so we, and not the compiler, should be closely watched, otherwise a runtime error may occur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The variable </font></font><code>headers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will </font><font style="vertical-align: inherit;">directly own the </font><font style="vertical-align: inherit;">structure </font></font><code>WebSocketClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so let's add new properties to it and write a new constructor function:</font></font><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//   RefCell  Rc    use std::cell::RefCell; use std::rc::Rc; ... struct WebSocketClient { socket: TcpStream, http_parser: Parser&lt;HttpParser&gt;, //      WebSocketClient: headers: Rc&lt;RefCell&lt;HashMap&lt;String, String&gt;&gt;&gt; } impl WebSocketClient { fn new(socket: TcpStream) -&gt; WebSocketClient { let headers = Rc::new(RefCell::new(HashMap::new())); WebSocketClient { socket: socket, //      : headers: headers.clone(), http_parser: Parser::request(HttpParser { current_key: None, // ...     : headers: headers.clone() }) } } ... }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we </font></font><code>WebSocketClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have access to parsed headings, and therefore we can find among them the one that is interesting to us - </font></font><code>Sec-WebSocket-Key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Taking into account the fact that we have a client key, the procedure for drafting an answer will not cause any difficulties. </font><font style="vertical-align: inherit;">We just need to piece together a string and write it to the client socket. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But since we cannot just send data to non-blocking sockets, we first need to ask the event loop to let us know about the availability of the socket for writing. </font><font style="vertical-align: inherit;">This is easy to do - you need to change the set of flags </font></font><code>EventSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>EventSet::writable()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when the socket is reregistered. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember this line?</font></font><br><pre> <code class="rust hljs">event_loop.reregister(&amp;client.socket, token, EventSet::readable(), PollOpt::edge() | PollOpt::oneshot()).unwrap();</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can store a set of events of interest to us in the state of the client - we will change the structure </font></font><code>WebSocketClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketClient</span></span></span></span> { socket: TcpStream, http_parser: Parser&lt;HttpParser&gt;, headers: Rc&lt;RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;&gt;&gt;, <span class="hljs-comment"><span class="hljs-comment">//   , `interest`: interest: EventSet }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we will change the re-registration procedure accordingly: </font></font><br><pre> <code class="rust hljs">event_loop.reregister(&amp;client.socket, token, client.interest, <span class="hljs-comment"><span class="hljs-comment">//    `EventSet`    PollOpt::edge() | PollOpt::oneshot()).unwrap();</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains for us to change the value </font></font><code>interest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the right places. </font><font style="vertical-align: inherit;">To simplify this process, let's formalize it using connection states:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientState</span></span></span></span> { AwaitingHandshake, HandshakeResponse, Connected }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we define the </font></font><a href="http://kgv.github.io/rust_book_ru/src/enums.html"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enumeration of</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all possible states for the client connected to the server. </font><font style="vertical-align: inherit;">The first state </font></font><code>AwaitingHandshake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,, means that we expect a new client to connect using HTTP. </font></font><code>HandshakeResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will mean a state when we respond to the client via HTTP. </font><font style="vertical-align: inherit;">And finally, the </font></font><code>Connected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state when we have successfully established a connection with the client and communicate with it using the WebSocket protocol. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a state variable to the client structure:</font></font><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketClient</span></span></span></span> { socket: TcpStream, http_parser: Parser&lt;HttpParser&gt;, headers: Rc&lt;RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;&gt;&gt;, interest: EventSet, <span class="hljs-comment"><span class="hljs-comment">//   : state: ClientState }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And add the initial values ‚Äã‚Äãof the new variables to the constructor: </font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketClient { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(socket: TcpStream) -&gt; WebSocketClient { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> headers = Rc::new(RefCell::new(HashMap::new())); WebSocketClient { socket: socket, ... <span class="hljs-comment"><span class="hljs-comment">// Initial events that interest us interest: EventSet::readable(), // Initial state state: ClientState::AwaitingHandshake } } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can change the state in the function </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Remember these lines?</font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.socket.try_read(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> buf) { ... <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(len)) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.http_parser.is_upgrade() { <span class="hljs-comment"><span class="hljs-comment">// ... break; } } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's change the stub in the condition block for </font></font><code>is_upgrade()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the code for changing the connection state:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.http_parser.is_upgrade() { <span class="hljs-comment"><span class="hljs-comment">//     HandshakeResponse self.state = ClientState::HandshakeResponse; //       Writable // (..    ): self.interest.remove(EventSet::readable()); self.interest.insert(EventSet::writable()); break; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After we changed the set of flags of interest to </font></font><code>Writable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we will add the code necessary to send a response to establish the connection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will change the function </font></font><code>ready</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the implementation of the structure </font></font><code>WebSocketServer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The procedure of writing the response to the socket is simple (and practically does not differ from the reading procedure), and we only need to separate one type of event from the other:</font></font><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ready</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, event_loop: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> EventLoop&lt;WebSocketServer&gt;, token: Token, events: EventSet) { <span class="hljs-comment"><span class="hljs-comment">//        ? if events.is_readable() { // Move all read handling code here match token { SERVER_TOKEN =&gt; { ... }, ... } ... } //        : if events.is_writable() { let mut client = self.clients.get_mut(&amp;token).unwrap(); client.write(); event_loop.reregister(&amp;client.socket, token, client.interest, PollOpt::edge() | PollOpt::oneshot()).unwrap(); } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Only a little remains - we need to assemble in parts and send the response line: </font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fmt; ... <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> WebSocketClient { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  -    Rc&lt;RefCell&lt;...&gt;&gt;: let headers = self.headers.borrow(); //           : let response_key = gen_key(&amp;headers.get("Sec-WebSocket-Key").unwrap()); //       . //         (printf  , format  Python,  ..), //   Rust    -        // ,         ""  //  .           . let response = fmt::format(format_args!("HTTP/1.1 101 Switching Protocols\r\n\ Connection: Upgrade\r\n\ Sec-WebSocket-Accept: {}\r\n\ Upgrade: websocket\r\n\r\n", response_key)); //    : self.socket.try_write(response.as_bytes()).unwrap(); //    : self.state = ClientState::Connected; //         `readable()` ( ): self.interest.remove(EventSet::writable()); self.interest.insert(EventSet::readable()); } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to connect to our server. </font><font style="vertical-align: inherit;">Open the development console in your favorite browser (by pressing F12, for example), and enter the following code:</font></font><br><br><pre> <code class="javascript hljs">ws = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(<span class="hljs-string"><span class="hljs-string">'ws://127.0.0.1:10000'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ws.readyState == WebSocket.OPEN) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Connection is successful'</span></span>); }</code> </pre><br><br><img src="https://habrastorage.org/files/c11/8ce/d28/c118ced2830f4a40962e1cb8a26baf7f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems that everything works - we are connected to the server!</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our fascinating journey through the possibilities and unusual concepts of the Rust language has come to an end, but we have touched only the very beginning - the series of articles will continue (of course, the sequels will be just as long and boring! :)). We need to consider many other interesting questions: secure TLS connections, multi-threaded event cycles, load testing and optimization, and, of course, the most important thing is that we still need to finish implementing the WebSocket protocol and write the chat application itself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But before we get to the application, you will need to do a little refactoring and separating the library code from the application code. Most likely, we will also consider publishing your library on </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crates.io</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All current code is available on </font></font><a href="https://github.com/nbaksalyar/rust-chat"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you can fork the repository and try to change something in it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To follow the appearance of the following parts of the article I suggest to follow me on </font></font><a href="https://twitter.com/nbaksalyar"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See you soon!</font></font><br><br><h2>  Notes </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] It should be noted that Rust essentially uses </font></font><a href="https://en.wikipedia.org/wiki/Smart_pointer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smart pointers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the level of language - the idea of borrowing is very similar to the types </font></font><code>unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>shared_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] For example, </font></font><a href="http://lars-lab.jpl.nasa.gov/JPL_Coding_Standard_C.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the coding standard for C in the NASA Jet Propulsion Laboratory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the software development standard in the automotive industry </font></font><a href="https://ru.wikipedia.org/wiki/MISRA_C"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISRA C</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generally prohibit the use of dynamic memory allocation via </font></font><code>malloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead, local variables are allocated on the stack and preallocated memory is used.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Simple garbage collection algorithms are fairly easy to use, but more complex options, such as multi-threaded assembly, may require a lot of effort to implement. For example, in the Go language, multithreaded garbage collection appeared only to version 1.5, which was released almost 3 years after the first one. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] Generally speaking, many implementations of functions </font></font><code>malloc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>free()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have the same problem due to </font></font><a href="http://ru.stackoverflow.com/questions/180995/%25D0%25A4%25D1%2580%25D0%25B0%25D0%25B3%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F-%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memory fragmentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] ‚ÄúGraydon Hoare [...] started working on a new programming language called Rust in 2006‚Äù - </font></font><a href="http://www.infoq.com/news/2012/08/Interview-Rust"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InfoQ: ‚ÄúInterview On Rust‚Äù</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] The man page </font></font><code>pthread_create(3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tells you about 2 MB on a 32-bit Linux system. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] For comparison, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">epoll</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with other system APIs I recommend reading the publication ‚Äú</font></font><a href="https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparing and Evaluating epoll, select, and poll Event Mechanisms</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù, University of Waterloo, 2004 (English) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[8]‚Äú </font></font><a href="http://people.freebsd.org/~jlemon/papers/kqueue.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kqueue: A generic and scalable event notification facility</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù(English) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[9]‚Äú </font></font><a href="http://habrahabr.ru/post/260065/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NGINX from the inside: born for performance and scaling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I express my gratitude for the help: </font></font><br> <a href="https://habrahabr.ru/users/podust/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for illustrations and proofreading. </font></font><br> <a href="https://habrahabr.ru/users/vgacich/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VgaCich</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for reading drafts and corrections.</font></font><br></div><p>Source: <a href="https://habr.com/ru/post/268609/">https://habr.com/ru/post/268609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268593/index.html">Huawei and NTT DOCOMO successfully tested 5G technology in the field</a></li>
<li><a href="../268597/index.html">Mobile communications in Europe</a></li>
<li><a href="../268599/index.html">Enable HTTP / 2 in NGINX for the site</a></li>
<li><a href="../268605/index.html">Primary key - GUID or autoincrement? Part two</a></li>
<li><a href="../268607/index.html">Volker Simonis - Interiors of SAP JVM [Meeting JUG in St. Petersburg]</a></li>
<li><a href="../268611/index.html">The digest of interesting materials for the mobile # 124 developer (October 5-11)</a></li>
<li><a href="../268613/index.html">Using hardlinks (hardlink) for Synology DSM incremental backup</a></li>
<li><a href="../268615/index.html">Programming with YII2: get down to work</a></li>
<li><a href="../268617/index.html">Create a REST service on Rust. Part 4: go to the REST API</a></li>
<li><a href="../268619/index.html">Ode to a good vendor: choose a platform for launching a VoIP SaaS project</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>