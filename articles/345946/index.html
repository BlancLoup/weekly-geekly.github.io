<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Objective-C compliant "Swift" code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Although Apple has written, it would seem, detailed documentation on how you can use the Swift code inside the Objective-C application (and vice versa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Objective-C compliant "Swift" code</h1><div class="post__text post__text-html js-mediator-article">  Although Apple has written, it would seem, detailed <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html">documentation</a> on how you can use <a href="https://en.wikipedia.org/wiki/Swift_(programming_language)">the Swift</a> code inside <a href="https://en.wikipedia.org/wiki/Objective-C">the Objective-C</a> application (and vice versa), but when it comes to business, this is for some reason not enough.  When I first came up with the need to ensure compatibility of the <a href="https://en.wikipedia.org/wiki/Software_framework">framework</a> written entirely in Swift with an Objective-C application, <a href="https://www.apple.com/">the Apple</a> documentation for some reason gave rise to more questions than it gave answers (or at least left many spaces) .  Intensive use of search engines showed that this topic was covered in the Web quite poorly: a couple of questions on <a href="https://stackoverflow.com/questions/24206732/cant-use-swift-classes-inside-objective-c">StackOverflow</a> , a couple of <a href="https://medium.com/ios-os-x-development/swift-and-objective-c-interoperability-2add8e6d6887">introductory articles</a> (on English-language resources, of course) - that's all that was found. <br><br>  This article is a summary of the information found, as well as the experience gained.  I emphasize that she does not claim to be called, as they say, good practice, but only suggests possible actions in the circumstances described or is a kind of academic experiment. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <u><b>Last updated February 2019.</b></u> <br><br><blockquote> <b>TL; DR.</b>  To use the “Swift” code inside the “Objective-C” you will have to sacrifice some “features” of the “Swift” and write a wrapper over the code that will not use techniques that are incompatible with the “Objective-C” ( <a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html">“structures”</a> , <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html">“generics”</a> , <a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html">“Enum associated values”</a> , <a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html">“protocol extensions”</a> , etc.), and will be based on the NSObject <a href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">heirs</a> . </blockquote><br><br><h3>  Start </h3><br><br>  So, we have an Objective-C project and some Swift code that we want to use in this project.  For example, let it be a third-party “Swift” framework, which we add to the project, say, with the help <a href="https://cocoapods.org/">of CocoaPods</a> .  As usual, add the desired dependency in the <a href="https://guides.cocoapods.org/syntax/podfile.html">“Podfile”</a> , execute <code>pod install</code> , open the <a href="https://developer.apple.com/library/archive/featuredarticles/XcodeConcepts/Concept-Workspace.html">“xcworkspace” file</a> . <br><br>  To import a framework into an Objective-C file, you do not need to <code>import</code> entire framework, as we used to do in Swift, nor try to import individual framework <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> public files, as we used to do in Objective-C.  In any file in which we need access to the framework's functionality, we import a file called <code>&lt;&gt;-Swift.h</code> - this is an automatically generated header file that is a guide to “Objective-C” files to the public “API” contained in imported “Swift” files.  It looks like this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourProjectName-Swift.h"</span></span></span></span></code> </pre> <br><br><h3>  Using Swift Classes in Objective-C Files </h3><br><br>  If you succeeded after importing the “Swift” heading, just using any of its classes or methods in the “Objective-C” project, you are very lucky - it means that someone before you takes care of compatibility.  The fact is that Objective-C “digests” only the descendant classes of <code>NSObject</code> and sees only the <a href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html">public</a> “API”.  And inside classes, public <a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html">properties</a> , <a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html">initializers,</a> and <a href="https://docs.swift.org/swift-book/LanguageGuide/Methods.html">methods</a> must be annotated with <code>@objc</code> . <br><br>  If we import our own “Swift” code, then we, of course, have the opportunity to add the “inheritance” from anything, and add an <a href="https://docs.swift.org/swift-book/ReferenceManual/Attributes.html">annotation (or attribute)</a> <code>@objc</code> .  But in this case, probably, we have the opportunity and the necessary code to write in “Objective-C”.  Therefore, it makes more sense to focus on the case when we want to import someone else's “Swift” code into our project.  In this case, most likely, we have no possibility to add any inheritance or anything to the necessary classes.  What to do in this case?  It remains to write <a href="https://en.wikipedia.org/wiki/Wrapper_function">wrappers</a> ! <br><br>  Suppose the imported framework contains the following class we need: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Implementation goes here. } }</span></span></code> </pre><br><br>  We create our “Swift” file, import the external framework into it, create our own class inherited from <code>NSObject</code> , and in it declare a private member of the external class type.  To be able to call the methods of the outer class, we define methods in our class that internally call the corresponding methods of the outer class through a private member of the class (it sounds confusing, but I think everything’s clear by code): <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SwiftFramework public class SwiftClassObjCWrapper: NSObject { private let swiftClass = SwiftClass() public func swiftMethod() { swiftClass.swiftMethod() } }</code> </pre><br><br>  (Access to the <code>NSObject</code> class and <code>NSObject</code> annotations appears after importing <a href="https://developer.apple.com/documentation/foundation">Foundation</a> .) <br><br>  For obvious reasons, we cannot use the same class and method names in declarations.  And here the annotation <code>@objc</code> comes to the rescue: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span>(<span class="hljs-type"><span class="hljs-type">SwiftClass</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftClassObjCWrapper</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swiftClass = <span class="hljs-type"><span class="hljs-type">SwiftClass</span></span>() <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { swiftClass.swiftMethod() } }</code> </pre><br><br>  Now, when calling from the Objective-C code, the names of the classes and methods will look exactly as we would like them to be - as if we are writing the corresponding names from the external class: <br><br><pre> <code class="objectivec hljs">SwiftClass *swiftClass = [SwiftClass new]; [swiftClass swiftMethod];</code> </pre><br><br><h3>  Features of using “Swift” methods in “Objective-C” files </h3><br><br>  Unfortunately, not any (public) “Swift” methods can simply be marked <code>@objc</code> and used inside Objective-C.  Swift and Objective-C are different languages ​​with different capabilities and different logic, and quite often when writing a Swift code, we use its capabilities that Objective-C does not have or that are implemented fundamentally differently. <br><br>  For example, the default settings will have to be abandoned.  This method: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherSwiftMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parameter: Int = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Implementation goes here. }</span></span></code> </pre><br><br>  ... inside the "Objective-C" code will look like this: <br><br><pre> <code class="objectivec hljs">[swiftClassObject anotherSwiftMethodWithParameter:<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br><br>  ( <code>1</code> is the value passed by us, the argument has no default value.) <br><br><h4>  Method names </h4><br><br>  “Objective-C” has its own system, according to which the “Swift” method will be named in the “Objective-C” environment.  In most simple cases, it is quite satisfactory, but often requires our intervention to become readable.  For example, the method name in the spirit of <code>do(thing:)</code> “Objective-C” will transform into <code>doWithThing:</code> which may not coincide with our intention.  In this case, the <code>@objc</code> annotation <code>@objc</code> comes to the rescue: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span>(doThing:) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thing: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Type</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Implementation goes here. }</span></span></code> </pre><br><br><h4>  Methods throwing <a href="https://en.wikipedia.org/wiki/Exception_handling">exceptions</a> </h4><br><br>  If the “Swift” method is marked with <a href="https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html"><code>throws</code></a> , then “Objective-C” will add one more parameter to its signature — an error that the method may throw.  For example: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span>(doThing:error:) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thing: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Type</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Implementation goes here. }</span></span></code> </pre><br><br>  Using this method will occur in the spirit of "Objective-C" (so to speak): <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; [swiftClassObject doThing:thingValue error:&amp;error]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Handle error. }</span></span></code> </pre><br><br><h4>  Using Swift Types in Parameters and Return Values </h4><br><br>  If the parameter values ​​or the return value of “Swift” - a non-standard “Swift” type is used that is not transferred automatically to the Objective-C environment, this method will not be used in the Objective-C environment again ... over him not to "conjure". <br><br>  If this “Swift” -type is an inheritor of <code>NSObject</code> , then, as mentioned above, there are no problems.  But most often it turns out that it is not.  In this case, the wrapper helps us out again.  For example, the original "Swift" code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// } } class AnotherSwiftClass { func anotherSwiftMethod() -&gt; SwiftClass { return SwiftClass() } }</span></span></code> </pre><br><br>  Wrap for him: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span>(<span class="hljs-type"><span class="hljs-type">SwiftClass</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftClassObjCWrapper</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swiftClassObject: <span class="hljs-type"><span class="hljs-type">SwiftClass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(swiftClassObject: <span class="hljs-type"><span class="hljs-type">SwiftClass</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.swiftClassObject = swiftClassObject <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() } <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { swiftClassObject.swiftMethod() } } <span class="hljs-meta"><span class="hljs-meta">@objc</span></span>(<span class="hljs-type"><span class="hljs-type">AnotherSwiftClass</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnotherSwiftClassWrapper</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> anotherSwiftClassObject = <span class="hljs-type"><span class="hljs-type">AnotherSwiftClass</span></span>() <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherSwiftMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwiftClassObjCWrapper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">SwiftClassObjCWrapper</span></span>(swiftClassObject: anotherSwiftClassObject.anotherSwiftMethod()) } }</code> </pre><br><br>  Using inside Objective-C: <br><br><pre> <code class="objectivec hljs">AnotherSwiftClass *anotherSwiftClassObject = [AnotherSwiftClass new]; SwiftClass *swiftClassObject = [anotherSwiftClassObject anotherSwiftMethod]; [swiftClassObject swiftMethod];</code> </pre><br><br><h3>  Implementing Swift Protocols Objective-C Classes </h3><br><br>  For example, let's take, of course, the protocol, in the parameters or return values ​​of methods of which Swift-types are used, which cannot be used in Objective-C: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftClass</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftProtocolMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwiftClass</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(swiftProtocolObject: SwiftProtocol)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Implementation goes here. }</span></span></code> </pre><br><br>  We'll have to wrap up again.  For starters, <code>SwiftClass</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span>(<span class="hljs-type"><span class="hljs-type">SwiftClass</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftClassObjCWrapper</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swiftClassObject = <span class="hljs-type"><span class="hljs-type">SwiftClass</span></span>() }</code> </pre><br><br>  Next, we will write our own protocol, similar to <code>SwiftProtocol</code> , but using wrapped versions of the classes: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span>(<span class="hljs-type"><span class="hljs-type">SwiftProtocol</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftProtocolObjCWrapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftProtocolMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwiftClassObjCWrapper</span></span> }</code> </pre><br><br>  Then the most interesting thing: we will declare the “Swift” class, which adapts the “Swift” protocol we need.  It will be something of a bridge between our protocol, which we wrote to adapt in the “Objective-C” project and the “Swift” method, which accepts the object of the original “Swift” protocol.  The class members will be listed as an instance of the protocol that we described.  And the class methods in the protocol methods will call the methods of the protocol we wrote: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftProtocolWrapper</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swiftProtocolObject: <span class="hljs-type"><span class="hljs-type">SwiftProtocolObjCWrapper</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(swiftProtocolObject: <span class="hljs-type"><span class="hljs-type">SwiftProtocolObjCWrapper</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.swiftProtocolObject = swiftProtocolObject } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftProtocolMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwiftClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swiftProtocolObject.swiftProtocolMethod().swiftClassObject } }</code> </pre><br><br>  Unfortunately, wrapping a method that accepts a protocol instance cannot be done: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftMethodWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(swiftProtocolObject: SwiftProtocolObjCWrapper)</span></span></span></span> { methodOwnerObject.swiftMethodWith(swiftProtocolObject: <span class="hljs-type"><span class="hljs-type">SwiftProtocolWrapper</span></span>(swiftProtocolObject: swiftProtocolObject)) }</code> </pre><br><br>  Not the easiest chain?  Yes.  Although, if the classes and protocols used have a significant number of methods, the wrapper will not seem so disproportionately voluminous with respect to the source code. <br><br>  Actually, using the protocol in the “Objective-C” code itself will already look quite harmonious.  Implementation of protocol methods: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectiveCClass</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftProtocol</span></span></span><span class="hljs-class">&gt; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectiveCClass</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftClass</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">swiftProtocolMethod</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [SwiftClass new]; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br><br>  And using the method: <br><br><pre> <code class="objectivec hljs">(ObjectiveCClass *)objectiveCClassObject = [ObjectiveCClass new]; [methodOwnerObject swiftMethodWithSwiftProtocolObject:objectiveCClassObject];</code> </pre><br><br><h3>  Enumerated types in "Swift" and "Objective-C" </h3><br><br>  When using the “Swift” enumerated types in the “Objective-C” projects, there is only one nuance: they must have an integer <a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html">Raw Type</a> .  Only then can we annotate <code>enum</code> as <code>@objc</code> . <br><br>  What to do if we cannot change the <code>enum</code> type, but want to use it inside „Objective-C“?  We can, as usual, wrap a method that uses instances of this enum type, and give it our own <code>enum</code> .  For example: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftEnum</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> firstCase <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> secondCase } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwiftClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swiftMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwiftEnum</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Implementation goes here. } } @objc(SwiftEnum) enum SwiftEnumObjCWrapper: Int { case firstCase case secondCase } @objc(SwiftClass) public class SwiftClassObjCWrapper: NSObject { let swiftClassObject = SwiftClass() @objc public func swiftMethod() -&gt; SwiftEnumObjCWrapper { switch swiftClassObject.swiftMethod() { case .firstCase: return .firstCase case .secondCase: return .secondCase } } }</span></span></code> </pre><br><br><h3>  Conclusion </h3><br><br>  Here, perhaps, all that I wanted to report on this topic.  Most likely, there are other aspects of integration of the “Swift” code in “Objective-C”, but I am sure that it is quite possible to cope with them by armed with the logic described above. <br><br>  This approach, of course, has its drawbacks.  In addition to the most obvious (writing a significant amount of additional code), there is one more important one: the “Swift” code is transferred to the “Objective-C” runtime and will most likely not work as fast or, at least, otherwise.  Although the difference in many cases with the naked eye will not be noticeable. </div><p>Source: <a href="https://habr.com/ru/post/345946/">https://habr.com/ru/post/345946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345936/index.html">How to start creating an open source project in the new year</a></li>
<li><a href="../345938/index.html">ScadaPy - creating mnemonic schemes</a></li>
<li><a href="../345940/index.html">The problem of a chess horse and probability</a></li>
<li><a href="../345942/index.html">A couple of ways to send notifications to your smartphone from your server</a></li>
<li><a href="../345944/index.html">Simula - 50 years of OOP</a></li>
<li><a href="../345948/index.html">Enterprise Architecture vs alchemy enterprises. Part 2. Nowhere is easier: simple framework and simple enterprise.</a></li>
<li><a href="../345950/index.html">Welcome to the era of deep neuroevolution</a></li>
<li><a href="../345954/index.html">Simplify the work with RecyclerView</a></li>
<li><a href="../345956/index.html">History 3 places Russian AI Cup 2017</a></li>
<li><a href="../345958/index.html">How I wrote the game in 6 days</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>