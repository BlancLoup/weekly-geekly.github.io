<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finding the maximum common subsequence</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to review the popular algorithms for solving the problem of finding the maximum common subsequence or LCS (longest commo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finding the maximum common subsequence</h1><div class="post__text post__text-html js-mediator-article">  In this article, I would like to review the popular algorithms for solving the problem of finding the maximum common subsequence or LCS (longest common sequense).  Since the emphasis is on learning, rather than on real use, Python was chosen as the language for implementation, which will reduce the amount of code and focus on the main ideas. <br><a name="habracut"></a><br><h4>  Definitions </h4><br>  <b>A sequence</b> is an ordered set of elements.  A string is a special case of a sequence, further examples will consider lines for simplicity, but without changes they can be used for arbitrary text or anything else consistent. <br>  Let there be a sequence <em>x</em> consisting of elements <em>x <sub>1</sub> x <sub>2</sub> ... x <sub>m</sub></em> and a sequence <em>y</em> consisting of elements <em>y <sub>1</sub> y <sub>2</sub> ... y <sub>n</sub></em> .  <em>z</em> is a subsequence of <em>x</em> if there exists a strictly increasing set of indices of elements <em>x</em> from which <em>z</em> is obtained. <br>  <strong>A common subsequence</strong> for <em>x</em> and <em>y is</em> a sequence <em>z</em> , which is both a subsequence of <em>x</em> and a subsequence of <em>y</em> . <br>  The maximum common subsequence is a common subsequence with a maximum long.  Further in the text we will use the abbreviation <strong>LCS</strong> . <br>  As an example, let <em>x = <strong>HA</strong> B <strong>R</strong> AHA <strong>BR</strong></em> , <em>y = <strong>HARB</strong> OU <strong>R</strong></em> , in this case <strong>LCS (x, y) = HARBR</strong> .  You can already go directly to the <strong>LCS</strong> calculation algorithm, but it would be good to understand why we may need it. <br><br><h4>  Practical application </h4><br>  The most common use is for use in file comparison programs, such as GNU diff.  Having the LCS found for two texts, it‚Äôs trivial to make a list of elementary changes for turning x into y or back.  As a bonus, based on the length of the common subsequence, you can set a metric to determine the similarity of the two sequences.  Everything, now you can just get down to business. <br><br><h4>  The first approach or folk art </h4><br>  First, a couple of observations: <br><ol><li>  If for the x and y sequences we have already calculated LCS (x, y) = z, then the LCS for sequences obtained from x and y by adding the same element will consist of z and this added element </li><li>  If we add to the x and y sequences one for a different element, then for the xa and yb thus obtained, the LCS must be the larger of two: LCS (x, yb) or LCS (xa, y) </li></ol><br>  These observations are enough to implement recursion: <br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCS_RECURSIVE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(x) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> len(y) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x[<span class="hljs-number"><span class="hljs-number">-1</span></span>] == y[<span class="hljs-number"><span class="hljs-number">-1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCS_RECURSIVE(x[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], y[:<span class="hljs-number"><span class="hljs-number">-1</span></span>]) + [x[<span class="hljs-number"><span class="hljs-number">-1</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: left = LCS_RECURSIVE(x[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], y) right = LCS_RECURSIVE(x, y[:<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(left) &gt; len(right) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> right</code> </pre> <br>  Now you might think that this is not the case.  In the worst case, when there are no identical LCS_RECURSIVE elements between x and y, it will be called 2 <sup>len (x) + len (y)</sup> times, at the recursion level len (x) + len (y).  Even if you close your eyes to performance, the code: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid4 x = [uuid4().hex <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">500</span></span>)] y = [uuid4().hex <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">500</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> LCS_RECURSIVE(x,y)</code> </pre><br>  without an additional call, sys.setrecursionlimit will not succeed.  Not the most successful implementation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Dynamic programming or 64 kb is enough for everyone </h4><br>  The considered algorithm is also known as the Needleman ‚Äì Wunsch algorithm. <br>  The whole approach is reduced to the stage-by-stage filling of the matrix, where the rows are the elements x, and the columns are the elements y.  When filling, there are two rules arising from observations already made: <br>  1. If the element x <sub>i</sub> is equal to y <sub>j,</sub> then in the cell (i, j) the value of the cell (i-1, j-1) is written with the addition of one <br>  2. If the element x <sub>i is</sub> not equal to y <sub>j,</sub> then the maximum of the values ‚Äã‚Äã(i-1, j) and (i, j-1) is written in the cell (i, j). <br>  Filling takes place in a double cycle of i and j with an increase in the values ‚Äã‚Äãby one, so at each iteration the cell values ‚Äã‚Äãneeded at this step are already calculated: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fill_dyn_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> L = [[<span class="hljs-number"><span class="hljs-number">0</span></span>]*(len(y)+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(len(x)+<span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x_i,x_elem <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(x): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y_i,y_elem <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(y): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x_elem == y_elem: L[x_i][y_i] = L[x_i<span class="hljs-number"><span class="hljs-number">-1</span></span>][y_i<span class="hljs-number"><span class="hljs-number">-1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: L[x_i][y_i] = max((L[x_i][y_i<span class="hljs-number"><span class="hljs-number">-1</span></span>],L[x_i<span class="hljs-number"><span class="hljs-number">-1</span></span>][y_i])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L</code> </pre><br>  Illustration of what is happening: <br><img src="https://habrastorage.org/storage2/4c7/061/02a/4c706102aa8f467337723aa092f4bd5a.gif"><br>  The cells in which the values ‚Äã‚Äãdirectly increased were highlighted.  After filling the matrix, connecting these cells, we get the desired LCS.  Connecting with the need to move from the maximum index to the minimum, if the cell is highlighted, then add the corresponding element to the LCS, if not, then move up or to the left depending on where the larger value is in the matrix: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCS_DYN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> L = fill_dyn_matrix(x, y) LCS = [] x_i,y_i = len(x)<span class="hljs-number"><span class="hljs-number">-1</span></span>,len(y)<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x_i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> y_i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x[x_i] == y[y_i]: LCS.append(x[x_i]) x_i, y_i = x_i<span class="hljs-number"><span class="hljs-number">-1</span></span>, y_i<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> L[x_i<span class="hljs-number"><span class="hljs-number">-1</span></span>][y_i] &gt; L[x_i][y_i<span class="hljs-number"><span class="hljs-number">-1</span></span>]: x_i -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: y_i -= <span class="hljs-number"><span class="hljs-number">1</span></span> LCS.reverse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCS</code> </pre><br>  The complexity of the algoritm is O (len (x) * len (y)), the same estimate by memory.  Thus, if I want to compare two files of 100,000 lines line by line, then I will need to store in memory a matrix of 10 <sup>10</sup> elements.  Those.  real use threatens to get MemoryError almost out of the blue.  Before proceeding to the next algorithm, we note that when filling the matrix L at each iteration over the elements x, we need only the line obtained in the previous move.  Those.  if the task were limited only to finding the length of the LCS without having to calculate the LCS itself, then it would be possible to reduce the memory usage to O (len (y)), saving only two rows of the matrix L. <br><br><h4>  Fight for a place or Hishberg Algorithm (Hirschberg) </h4><br>  The idea behind this algorithm is simple: if you divide the input sequence x = x <sub>1</sub> x <sub>2</sub> ... x <sub>m</sub> into two arbitrary parts for any boundary index i by xb = x <sub>1</sub> x <sub>2</sub> ... x <sub>i</sub> and xe = x <sub>i + 1</sub> x <sub>i + 2</sub> ... x <sub>m</sub> , then there is a way to similarly partition y (there is such an index j dividing y into yb = y <sub>1</sub> y <sub>2</sub> ... y <sub>j</sub> and ye = y <sub>j + 1</sub> y <sub>j + 2</sub> ... y <sub>n</sub> ) such that LCS (x, y) = LCS (xb, yb) + LCS (xe, ye). <br>  In order to find this partition y is proposed: <br><ol><li>  Fill the dynamic matrix L with fill_dyn_matrix for xs and y.  L1 equate the last row of the computed matrix L </li><li>  Fill in the L matrix for * xe and * y (inverse sequences for xe and y, in Python terms: list (reversed (x)), list (reversed (y))).  Equate * L2 the last row of the computed matrix L, L2 is the opposite of * L2 </li><li>  Take j equal to the index for which the sum L1 [j] + L2 [j] is maximal </li></ol><br>  This can be represented as filling the matrix L from two opposite ends: <br><img src="https://habrastorage.org/storage2/4ea/d72/3b7/4ead723b702710d2daa745cf3faec206.png"><br>  Note that since there is a need only in the last row of the matrix L, then the calculation does not need to store the entire matrix.  By slightly changing the implementation of fill_dyn_matrix we get: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lcs_length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> curr = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*(<span class="hljs-number"><span class="hljs-number">1</span></span> + len(y)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x_elem <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x: prev = curr[:] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y_i, y_elem <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(y): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x_elem == y_elem: curr[y_i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = prev[y_i] + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: curr[y_i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = max(curr[y_i], prev[y_i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curr</code> </pre><br>  Now directly, about the algorithm itself.  It is a classic divide and conquer: as long as there are elements in the sequence x, we divide x in half, find the appropriate partition for y and return the sum of recursive calls for pairs of sequences (xb, yb) and (xe, ye).  Note that in the trivial case, if x consists of one element and occurs in y, we simply return a sequence of this single element x. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LCS_HIRSHBERG</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> x_len = len(x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x_len == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> x_len == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> y: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x[<span class="hljs-number"><span class="hljs-number">0</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: i = x_len // <span class="hljs-number"><span class="hljs-number">2</span></span> xb, xe = x[:i], x[i:] L1 = lcs_length(xb, y) L2 = reversed(lcs_length(xe[::<span class="hljs-number"><span class="hljs-number">-1</span></span>], y[::<span class="hljs-number"><span class="hljs-number">-1</span></span>])) SUM = (l1 + l2 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l1,l2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itertools.izip(L1, L2)) _, j = max((sum_val, sum_i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sum_i, sum_val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(SUM)) yb, ye = y[:j], y[j:] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCS_HIRSHBERG(xb, yb) + LCS_HIRSHBERG(xe, ye)</code> </pre><br>  Now the memory requirements are O (len (y)), the time required for the calculation has doubled, but still asymptotically O (len (x) len (y)). <br><br><h4>  Hunt-Szymanski Algorithm Algorithm (Hunt-Szymanski Algorithm) </h4><br>  The first thing we need is to create a hash of the matchlist table, which will contain the indexes of the elements of the second sequence.  The time required for this is O (len (y)).  The following code on python does this: <br><pre> <code class="python hljs">y_matchlist = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index, elem <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(y): indexes = y_matchlist.setdefault(elem, []) indexes.append(index) y_matchlist[elem] = indexes</code> </pre><br>  For the ‚ÄúHARBOR‚Äù sequence, the hash will be as follows: {'A': [1], 'B': [3], 'H': [0], 'O': [4], 'R': [2, 6] , 'U': [5]}. <br><br>  Next, iterating over the elements of the sequence x, we fill the array THRESH with the corresponding indices from the prepared matchlist, so that the value of the kth THRESH element should be the index y_index, provided THRESH [k-1] &lt;y_index and y_index &lt;THRESH [k].  Thus, at any moment in time the array THRESH is sorted and we can use a binary search to find the appropriate k.  When updating the THRESH element, we also add the sequence element corresponding to the y_index index to our LCS.  The following code can clarify: <br><pre> <code class="python hljs">x_length, y_length = len(x), len(y) min_length = min(x_length, y_length) THRESH = list(itertools.repeat(y_length, min_length+<span class="hljs-number"><span class="hljs-number">1</span></span>)) LINK_s1 = list(itertools.repeat(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, min_length+<span class="hljs-number"><span class="hljs-number">1</span></span>)) LINK_s2 = list(itertools.repeat(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, min_length+<span class="hljs-number"><span class="hljs-number">1</span></span>)) THRESH[<span class="hljs-number"><span class="hljs-number">0</span></span>], t = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x_index,x_elem <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(x): y_indexes = y_matchlist.get(x_elem, []) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reversed(y_indexes): k_start = bisect.bisect_left(THRESH, y_index, <span class="hljs-number"><span class="hljs-number">1</span></span>, t) k_end = bisect.bisect_right(THRESH, y_index, k_start, t) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(k_start, k_end+<span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> THRESH[k<span class="hljs-number"><span class="hljs-number">-1</span></span>] &lt; y_index <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> y_index &lt; THRESH[k]: THRESH[k] = y_index LINK_x[k] = (x_index, LINK_x[k<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k &gt; t: t = k</code> </pre><br>  After that, we just have to assemble the sequence from LINK_x. <br>  The running time of this algorithm is O ((r + n) log n), where n is the length of the larger sequence, and r is the number of matches, in the worst case with r = n * n, we get the run time worse than in the previous solution.  Memory requirements remain on the order of O (r + n). <br><br><h4>  Total </h4><br>  There are quite a few algorithms that solve this problem, asymptotically, the most efficient algorithm (Masek and Paterson) has an O (n * n / log n) time estimate.  Given the overall low efficiency in LCS calculations, in practice, the simplest preparations are performed before the algorithm works, such as discarding identical elements at the beginning and at the end of sequences and finding trivial differences between sequences.  Also, there are some optimizations using bit operations that do not affect the asymptotic behavior of the operation time. <br>  <a href="http://clck.ru/1-pej">download all code with examples</a> </div><p>Source: <a href="https://habr.com/ru/post/142825/">https://habr.com/ru/post/142825/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142819/index.html">Multi-client Network Protocol on C #</a></li>
<li><a href="../142820/index.html">Google launches 3D virtual travel on Google Maps</a></li>
<li><a href="../142821/index.html">Festival of international multimedia creativity "Multimatograf"</a></li>
<li><a href="../142823/index.html">Using additional CPU instructions in one of the PHP tasks to speed up performance</a></li>
<li><a href="../142824/index.html">Draw me completely or how to stretch the "submit" and "button"</a></li>
<li><a href="../142826/index.html">WWDC 2012 will be held from June 11 to 15</a></li>
<li><a href="../142827/index.html">The future of microservers on MIPS processors</a></li>
<li><a href="../142828/index.html">STALKER received an heir</a></li>
<li><a href="../142829/index.html">"Bad" sites are discharging the battery of mobile devices</a></li>
<li><a href="../142830/index.html">Pi number in pixels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>