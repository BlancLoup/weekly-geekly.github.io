<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ 11 variadic templates and long arithmetic at compile time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the thirty years that have elapsed since its appearance in the depths of Bell Labs, C ++ has come a long way, going from ‚Äúadvanced C‚Äù to one of the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ 11 variadic templates and long arithmetic at compile time</h1><div class="post__text post__text-html js-mediator-article">  In the thirty years that have elapsed since its appearance in the depths of Bell Labs, C ++ has come a long way, going from ‚Äúadvanced C‚Äù to one of the most popular and expressive compiled languages.  Especially a lot, to the author‚Äôs purely personal view, gave C ++ a new standard C ++ 11, which is rapidly gaining support for compilers.  In this article we will try to ‚Äútouch with hands‚Äù one of its most powerful features - templates with a variable number of arguments ( <b>variadic templates</b> ). <br><br>  Developers familiar with the Alexandrescu books probably remember the concept of <i>the type list</i> .  In the good old C ++ 03, if you need to use a previously unknown number of template arguments, you are asked to create such a list and then use it with a clever hack.  This way tuples were implemented (now std :: tuple) and so on.  and so on  And the chapter on type lists made it clear that on C ++ templates you can perform almost any calculations (do <a href="http://habrahabr.ru/post/218341/">Œª-calculus</a> , for example), so long as they can be written in a functional style.  The same concept could be applied to long arithmetic: store long numbers as lists of ints, enter the main class of the form <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> digit, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigInteger</span></span></span><span class="hljs-class"> {</span></span> };</code> </pre>  , operations on it and so on.  But to the glory of the new standard, we will go the other way. <br><a name="habracut"></a><br><br><h2>  Parameter packs </h2><br>  So the foundation is the new syntax introduced in C ++ 11.  To begin with, let's look at how the definition of a tuple class, which is not a crime against humanity, should look like: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre>  Note the three dots in the template arguments.  Now <code>Types</code> is not a type name, but a <b>parameter pack</b> is a collection of zero or more arbitrary types.  How to use it?  Cleverly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first way: as a set of argument types of functions or methods.  This is done like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">just_do_nothing_for_no_reason</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Types... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// indeed }</span></span></code> </pre>  Here <code>Types... args</code> is another special syntactic construction ( <b>function parameter pack</b> ), which expands into the corresponding parameter pack of the function argument chain.  Since C ++ supports autodetection of template function arguments, this function can now be called with any number of arguments of any type. <br><br>  Well, then what?  What <em>can you do</em> with all these arguments? <br><br>  First, you can simply use further, as the types of other functions or templates with a variable number of arguments: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; tuple&lt;Types...&gt; make_tuple(Types... args) { tuple&lt;Types...&gt; result(args...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre>  <code>Types... args</code> we already know.  <code>args...</code> is another special construction ( <b>parameter pack expansion</b> ), which in this case will be expanded into a list of function arguments separated by a comma.  So, if you make a call to <code>make_tuple(1, 1.f, '1')</code> somewhere in the code, then a function of the <code>make_tuple(1, 1.f, '1')</code> will be created and called <br><pre> <code class="cpp hljs">tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; make_tuple(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a1, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a2, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> a3) { tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; result(a1, a2, a3); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Secondly, it can be used in more complex transformations.  In fact, the parameter pack expansion supports more than just the substitution of everything and everything, separated by commas.  So, you can easily implement the following function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Types...&gt; just_double_everything(Types... args) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Types...&gt; result((args * <span class="hljs-number"><span class="hljs-number">2</span></span>)...); <span class="hljs-comment"><span class="hljs-comment">// OMG return result; }</span></span></code> </pre>  Iiii - yes, you guessed it!  The construction <code>((args * 2)...)</code> will unfold in <code>(a1 * 2, a2 * 2, a3 * 2)</code> . <br><br>  And finally, thirdly (and in the most banal), argument lists can be used in recursion: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; where, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; what)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> where &lt;&lt; what; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ostream&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream&amp; where, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; what, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Types&amp; ... other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> print(where &lt;&lt; what &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>, other...); }</code> </pre>  The output is type-safe printf - definitely worth it! <br><br>  With the help of a certain amount of patterned magic, one can learn how to extract from packs the type and value by number and perform other machinations.  An example under the spoiler. <br><div class="spoiler">  <b class="spoiler_title">Listing tuples</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ...&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">seq</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//     template&lt;int N, int... S&gt; //     Python' range() struct make_range : make_range&lt;N-1, N-1, S...&gt; { }; template&lt;int ...S&gt; struct make_range&lt;0, S...&gt; { typedef seq&lt;S...&gt; result; }; template&lt;typename... Types, int... range&gt; std::ostream&amp; operator_shl_impl( std::ostream&amp; out, const std::tuple&lt;Types...&gt;&amp; what, const seq&lt;range...&gt; /* a dummy argument */ ) { return print(out, std::get&lt;range&gt;(what)...); } template&lt;typename... Types&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const std::tuple&lt;Types...&gt;&amp; what) { using range = typename make_range&lt;sizeof...(Types)&gt;::result; return operator_shl_impl(out, what, range()); }</span></span></code> </pre><br>  Here we see the not yet mentioned, but quite easy to understand command <code>sizeof...(Types)</code> - it returns the number of types in the parameter pack.  By the way, it can be implemented independently. <br><br>  So, the whole point of the line <br><pre> <code class="cpp hljs">print(out, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;range&gt;(what)...);</code> </pre>  It does nothing but <i>calls a function with arguments from the tuple</i> .  Just think!  It is for this focus that we needed a list of numbers from 0 to (n - 1) - it is thanks to him that this line unfolds into something like <br><pre> <code class="cpp hljs">print(out, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(what), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(what), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(what));</code> </pre>  Write the list generator from (n - 1) to 0 - and you will be able to expand the tuples in one line: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> reversed_tuple = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;rev_range&gt;(my_tuple)...);</code> </pre><br>  Moral: pack expansion is a killer tool. <br></div></div><br><br><h2>  Long arithmetic </h2><br>  We begin our implementation of long arithmetic.  First, let's define the main class: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... digits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigUnsigned</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> length = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(digits); <span class="hljs-comment"><span class="hljs-comment">//   }; using Zero = BigUnsigned&lt; &gt;; using One = BigUnsigned&lt;1&gt;;</span></span></code> </pre><br>  In the best traditions of computation at the stage of compilation in C ++, all, in fact, the data are not stored here, but are the direct arguments of the template.  C ++ will distinguish the implementation of the BigUnsigned class with different sets of parameters, due to which we will be able to implement our calculations.  We agree that the first parameter will contain the lower 32 bits of our long number, and the last one will contain the most significant 32 bits, including, possibly, leading zeros (personally, I see this as the most logical solution). <br><br>  Before we deal with the implementation of addition, let's define the concatenation operation on our long numbers.  Using the example of this operation, we will introduce the standard tactics that we will use in the future. <br><br>  So, we define an operation on two types: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Concatenate</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; };</code> </pre>  We mean that these two types will be BigUnsigned implementations.  We implement the operation for them: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... b&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Concatenate</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a...&gt;, BigUnsigned&lt;b...&gt;&gt; {</span></span> <span class="hljs-comment"><span class="hljs-comment">// &gt;&gt; -    C++11 using Result = BigUnsigned&lt;a..., b...&gt;; // !    ! };</span></span></code> </pre><br>  It is equally trivial to implement bit operations, for example, (very naive) xor: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Xor</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... b&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Xor</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a...&gt;, BigUnsigned&lt;b...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = BigUnsigned&lt; (a^b)... &gt;; <span class="hljs-comment"><span class="hljs-comment">//  ,     a  b  };</span></span></code> </pre><br>  Now, actually, addition.  Do not go anywhere - you have to use recursion.  Define the main class and recursion base: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class">&lt;Zero, A&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = A; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class">&lt; A, Zero&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = A; }; <span class="hljs-comment"><span class="hljs-comment">//       ,      : template&lt; &gt; struct Sum&lt;Zero, Zero&gt; { using Result = Zero; };</span></span></code> </pre><br>  Now - the main calculations: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_0, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a_tail, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> b_0, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... b_tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_0, a_tail...&gt;, BigUnsigned&lt;b_0, b_tail...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> carry = b_0 &gt; UINT32_MAX - a_0 ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Concatenate&lt; BigUnsigned&lt;a_0 + b_0&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Sum&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Sum&lt; BigUnsigned&lt;a_tail...&gt;, BigUnsigned&lt;b_tail...&gt; &gt;::Result, BigUnsigned&lt;carry&gt; &gt;::Result &gt;::Result; };</code> </pre><br>  So what happened. <br><br>  View template <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_0, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a_tail, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> b_0, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... b_tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_0, a_tail...&gt;, BigUnsigned&lt;b_0, b_tail...&gt;&gt; {</span></span></code> </pre>  we need to separate the least significant digits of long numbers from all the older ones.  If we used a more general pattern <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a..., <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> b...&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a...&gt;, BigUnsigned&lt;b...&gt;&gt; {</span></span></code> </pre>  , it would not be so easy to do this, and we would need some more supporting structures.  (But one could write them wisely and subsequently realize the multiplication of Karatsuba, nya!) <br><br>  Next, the string <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> carry = b_0 &gt; UINT32_MAX - a_0 ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre>  calculates a so-called carry bit, indicating whether an overflow occurred in the current bit or not.  (Instead of the <code>UINT32_MAX</code> constant, <code>UINT32_MAX</code> can and should use <a href="http://www.cplusplus.com/reference/limits/numeric_limits/">std :: numeric_limits</a> .) <br><br>  Finally, the final calculation finds the result, applying recursion by the rule <br><br><img src="//habrastorage.org/files/98d/19a/6cf/98d19a6cf87c4f5eb1743074e0e75088.png"><br><br>  Well, you can test!  The calculations themselves will look something like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> A = BigUnsigned&lt;<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>ULL&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> B = One; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> C = Sum&lt;A, B&gt;::Result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Compiled!  It started!  But ... how do you know the value of C?  How, actually, to test? <br><br>  Easy way: let's call an error at compile time.  For example, we write in main <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ C::entertain_me(); }</code> </pre><br>  When trying to compile such code, we get a logical error: <br><pre> <code class="bash hljs">static_bignum.cpp:   ¬´int main(int, char**)¬ª: static_bignum.cpp:32:5: : ¬´entertain_me¬ª    ¬´C {aka static_bignum::BigUnsigned&lt;0, 1&gt;}¬ª C::entertain_me(); ^</code> </pre>  However, this whining about the g ++ error gave us the main secret - now we see that C is equal to <code>static_bignum::BigUnsigned&lt;0, 1&gt;</code> , that is, 2 <sup>32</sup> - everything came together! <br><br>  A less simple way: let's write a function that will generate a string with a binary representation of a given number.  The stock will look something like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryRepresentation</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_0, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryRepresentation</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_0, a...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } };</span></span></code> </pre>  We use the standard object <a href="http://www.cplusplus.com/reference/bitset/bitset/">std :: bitset</a> to print the current 32 bits at each stage: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryRepresentation</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_0, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryRepresentation</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_0, a...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;32&gt; bset(a_0); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BinaryRepresentation&lt;BigUnsigned&lt;a...&gt;&gt;::str() + bset.to_string(); } };</code> </pre>  It remains only to specify the base recursion: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryRepresentation</span></span></span><span class="hljs-class">&lt;Zero&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"0b"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Oppa Python Style } };</span></span></code> </pre><br>  The new version of our primitive test will look like <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> A = BigUnsigned&lt;<span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFFFFFF</span></span>ULL&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> B = One; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> C = Sum&lt;A, B&gt;::Result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; BinaryRepresentation&lt;C&gt;::str() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre>  and give us just a stunning readability response <br><pre> <code class="bash hljs">0b00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000</code> </pre>  However, a careful calculation of the number of zeros can be sure that it is still 2 <sup>32</sup> ! <br><br>  The difficult, but most convincing way - the derivation of a decimal representation - will require some work from us, namely the implementation of the division operation. <br><br>  For this we need certain, uh, prerequisites. <br><div class="spoiler">  <b class="spoiler_title">Implementation of the subtraction</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Difference</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OverflowError</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -  (    ) //     --    : template&lt;&gt; struct Difference&lt;Zero, Zero&gt; { using Result = Zero; }; template&lt;uint32_t n, uint32_t... tail&gt; //   --   struct Difference&lt;BigUnsigned&lt;n, tail...&gt;, Zero&gt; { using Result = BigUnsigned&lt;n, tail...&gt;; }; template&lt;uint32_t n, uint32_t... tail&gt; //    --   struct Difference&lt;Zero, BigUnsigned&lt;n, tail...&gt;&gt; { using Result = OverflowError; }; template&lt;class A&gt; struct Difference&lt;OverflowError, A&gt; { using Result = OverflowError; }; template&lt;class A&gt; struct Difference&lt;A, OverflowError&gt; { using Result = OverflowError; }; template&lt;uint32_t a_n, uint32_t b_n, uint32_t... a_tail, uint32_t... b_tail&gt; struct Difference&lt;BigUnsigned&lt;a_n, a_tail...&gt;, BigUnsigned&lt;b_n, b_tail...&gt; &gt; { using A = BigUnsigned&lt;a_n, a_tail...&gt;; //      using B = BigUnsigned&lt;b_n, b_tail...&gt;; using C = typename Difference&lt;BigUnsigned&lt;a_tail...&gt;, BigUnsigned&lt;b_tail...&gt;&gt;::Result; using Result_T = typename std::conditional&lt; //    ? a_n &gt;= b_n, C, typename Difference&lt;C, One&gt;::Result &gt;::type; using Result = typename std::conditional&lt; //     a_n == b_n &amp;&amp; std::is_same&lt;Result_T, Zero&gt;::value, Zero, typename Concatenate&lt; BigUnsigned&lt;a_n - b_n&gt;, Result_T &gt;::Result &gt;::type; };</span></span></code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">Implementation of bit shifts</b> <div class="spoiler_text">  Define the main classes and set the recursion base: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shift</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShiftLeft</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shift</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShiftRight</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shift</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigShiftLeft</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shift</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigShiftRight</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shift</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmallShiftLeft</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shift</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmallShiftRight</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shift&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigShiftLeft</span></span></span><span class="hljs-class"> &lt;Zero, shift&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = Zero; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shift&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigShiftRight</span></span></span><span class="hljs-class"> &lt;Zero, shift&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = Zero; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shift&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmallShiftLeft</span></span></span><span class="hljs-class"> &lt;Zero, shift&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = Zero; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shift&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmallShiftRight</span></span></span><span class="hljs-class">&lt;Zero, shift&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = Zero; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> carry = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigShiftLeft</span></span></span><span class="hljs-class"> &lt;BigUnsigned&lt;a...&gt;, 0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = BigUnsigned&lt;a...&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigShiftRight</span></span></span><span class="hljs-class"> &lt;BigUnsigned&lt;a...&gt;, 0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = BigUnsigned&lt;a...&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmallShiftLeft</span></span></span><span class="hljs-class"> &lt;BigUnsigned&lt;a...&gt;, 0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = BigUnsigned&lt;a...&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmallShiftRight</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a...&gt;, 0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = BigUnsigned&lt;a...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> carry = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre>  I decided that it is logical to divide any bit shift into the alternate use of small (shift less than 32 bits) and large (shift is a multiple of 32 bits), since their implementations differ significantly.  So a big shift: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shift&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigShiftLeft</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a...&gt;, shift&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Concatenate&lt; BigUnsigned&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> BigShiftLeft&lt; BigUnsigned&lt;a...&gt;, shift - <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;::Result &gt;::Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_0, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a_tail, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shift&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigShiftRight</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_0, a_tail...&gt;, shift&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> BigShiftRight&lt; BigUnsigned&lt;a_tail...&gt;, shift - <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;::Result; };</code> </pre>  Here, shift denotes a shift of 32 ‚ãÖ shift bits, and the operation itself simply ‚Äúeats‚Äù or adds in turn entire 32-bit words. <br><br>  A small shift is a bit more delicate work: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_0, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a_tail, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> shift&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmallShiftLeft</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_0, a_tail...&gt;, shift&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(shift &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-string"><span class="hljs-string">"shift in SmallShiftLeft must be less than 32 bits"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> carry = a_0 &gt;&gt; (<span class="hljs-number"><span class="hljs-number">32</span></span> - shift); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Concatenate&lt; BigUnsigned&lt;(a_0 &lt;&lt; shift)&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Sum&lt; <span class="hljs-comment"><span class="hljs-comment">//   Or  Xor,  Sum     typename SmallShiftLeft&lt;BigUnsigned&lt;a_tail...&gt;, shift&gt;::Result, BigUnsigned&lt;carry&gt; &gt;::Result &gt;::Result; }; template&lt;uint32_t a_0, uint32_t... a_tail, size_t shift&gt; struct SmallShiftRight&lt;BigUnsigned&lt;a_0, a_tail...&gt;, shift&gt; { static_assert(shift &lt; 32, "shift in SmallShiftRight must be less than 32 bits"); static const uint32_t carry = a_0 &lt;&lt; (32 - shift); using Result = typename Concatenate&lt; BigUnsigned&lt;(a_0 &gt;&gt; shift) | SmallShiftRight&lt;BigUnsigned&lt;a_tail...&gt;, shift&gt;::carry&gt;, typename SmallShiftRight&lt;BigUnsigned&lt;a_tail...&gt;, shift&gt;::Result &gt;::Result; };</span></span></code> </pre>  Here again you have to take care of accurate bit shifting. <br><br>  Finally, just a shift: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shift</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShiftLeft</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> BigShiftLeft&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SmallShiftLeft&lt;A, shift % <span class="hljs-number"><span class="hljs-number">32</span></span>&gt;::Result, shift / <span class="hljs-number"><span class="hljs-number">32</span></span> &gt;::Result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shift</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShiftRight</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Result = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SmallShiftRight&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> BigShiftRight&lt;A, shift / <span class="hljs-number"><span class="hljs-number">32</span></span>&gt;::Result, shift % <span class="hljs-number"><span class="hljs-number">32</span></span> &gt;::Result; };</code> </pre>  As promised, he just correctly uses the big and small shifts. <br></div></div><div class="spoiler">  <b class="spoiler_title">Implementing Comparison Operations</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThan</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThanOrEqualTo</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThan</span></span></span><span class="hljs-class">&lt;Zero, A&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThanOrEqualTo</span></span></span><span class="hljs-class">&lt;Zero, A&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThanOrEqualTo</span></span></span><span class="hljs-class">&lt;Zero, Zero&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThanOrEqualTo</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;n, tail...&gt;, Zero&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThan</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;n, tail...&gt;, Zero&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || GreaterThan&lt;BigUnsigned&lt;tail...&gt;, Zero&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> b_n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a_tail, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... b_tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThan</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_n, a_tail...&gt;, BigUnsigned&lt;b_n, b_tail...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> A_tail = BigUnsigned&lt;a_tail...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> B_tail = BigUnsigned&lt;b_tail...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = GreaterThan&lt;A_tail, B_tail&gt;::value || (GreaterThanOrEqualTo&lt;A_tail, B_tail&gt;::value &amp;&amp; a_n &gt; b_n); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> b_n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a_tail, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... b_tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreaterThanOrEqualTo</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_n, a_tail...&gt;, BigUnsigned&lt;b_n, b_tail...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> A_tail = BigUnsigned&lt;a_tail...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> B_tail = BigUnsigned&lt;b_tail...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = GreaterThan&lt;A_tail, B_tail&gt;::value || (GreaterThanOrEqualTo&lt;A_tail, B_tail&gt;::value &amp;&amp; a_n &gt;= b_n); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LessThan</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = !GreaterThanOrEqualTo&lt;A, B&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LessThanOrEqualTo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = !GreaterThan&lt;A, B&gt;::value; };</code> </pre></div></div><br>  So division.  Let's start as expected: with the definition of classes and the task of the base of recursion. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Division</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Division</span></span></span><span class="hljs-class">&lt;A, Zero&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Quotient = DivisionByZeroError; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Residue = DivisionByZeroError; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Division</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;n, tail...&gt;, One&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Quotient = BigUnsigned&lt;n, tail...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Residue = Zero; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DummyDivision</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Quotient = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Residue = A; };</code> </pre><br>  Here we have introduced an additional dummy class <code>struct DivisionByZeroError {}</code> , <br>  the only function of which is to slightly brighten up the unattractive life of a programmer, <br>  trying to debug a template program.  So, when trying to compile a program like <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; BinaryRepresentation&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Division&lt;One, Zero&gt;::Quotient&gt;::str() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; ... }</code> </pre>  clang will give us a warning like <pre> <code class="bash hljs">static_bignum.cpp:229:18: error: implicit instantiation of undefined template <span class="hljs-string"><span class="hljs-string">'BinaryRepresentation&lt;DivisionByZeroError&gt;'</span></span></code> </pre>  Why we need a mysterious class <code>DummyDivision</code> , we will see. <br><br>  So, the division algorithm itself will be the simplest (and probably rather inefficient).  Let it be necessary to divide A by B. If A is less than B, then the solution is obvious: the remainder is A, the quotient is 0. (Actually, the obvious division also produces the auxiliary class <code>DummyDivision</code> .) Otherwise, let Q be the result of dividing A by 2B, R is the remainder of this division, that is, <code>A = 2BQ + R</code>  Then, obviously, <code>A / B = 2Q + R / B</code> ;  however, since R is guaranteed to be less than 2B, then <code>R / B</code> is either 0 or 1. In turn, <code>A % B = R % B</code> , and <code>R % B</code> is equal to either R or <code>R - B</code>  Actually, the code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a_n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> b_n, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... a_tail, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... b_tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Division</span></span></span><span class="hljs-class">&lt;BigUnsigned&lt;a_n, a_tail...&gt;, BigUnsigned&lt;b_n, b_tail...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> A = BigUnsigned&lt;a_n, a_tail...&gt;; <span class="hljs-comment"><span class="hljs-comment">//      ..  .. using B = BigUnsigned&lt;b_n, b_tail...&gt;; using D = typename std::conditional&lt; //  :   2B GreaterThanOrEqualTo&lt;A, B&gt;::value, Division&lt;A, typename SmallShiftLeft&lt;B, 1&gt;::Result&gt;, DummyDivision&lt;A, B&gt; // (  ) &gt;::type; using Q = typename D::Quotient; //   using R = typename D::Residue; public: using Quotient = typename Sum&lt; //  2Q (,  ,  Q &lt;&lt; 1)  R / B typename SmallShiftLeft&lt;Q, 1&gt;::Result, typename std::conditional&lt;GreaterThanOrEqualTo&lt;R, B&gt;::value, One, Zero&gt;::type //  &lt;type_traits&gt;  std::conditional,  //    ,      &gt;::Result; using Residue = typename std::conditional&lt; GreaterThanOrEqualTo&lt;R, B&gt;::value, typename Difference&lt;R, B&gt;::Result, R &gt;::type; };</span></span></code> </pre> <br>  Iiii finally decimal representation!  It is clear that to print a decimal representation of a number, you can divide it for a long time by 10. The remainder of the first division will give the youngest character, the remainder of the division of the first quotient by 10 will give the second character and so on.  However, we take into account that in C ++ we are not obliged to print number digit by digit;  we are quite satisfied to divide the number with the remainder, for example, by 100, in order to get two signs at once.  Therefore, we will divide by the largest number that enters <code>uint32_t</code> , namely, by 10 <sup>9</sup> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecimalRepresentation</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecimalRepresentation</span></span></span><span class="hljs-class">&lt;Zero&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Digit</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,       template&lt;&gt; struct Digit&lt;Zero&gt; { static const uint32_t value = 0; }; template&lt;uint32_t digit, uint32_t... tail&gt; struct Digit&lt;BigUnsigned&lt;digit, tail...&gt;&gt; { static const uint32_t value = digit; }; template&lt;uint32_t n, uint32_t... tail&gt; struct DecimalRepresentation&lt;BigUnsigned&lt;n, tail...&gt;&gt; { private: static const uint32_t modulo = 1000000000UL; static const uint32_t modulo_log = 9; using D = Division&lt;BigUnsigned&lt;n, tail...&gt;, BigUnsigned&lt;modulo&gt;&gt;; using Q = typename D::Quotient; using R = typename D::Residue; static_assert(Digit&lt;R&gt;::value &lt; modulo, "invalid division by power of 10"); public: static std::string str(void) { //  C++     ,        . //      ,   . std::string stail = DecimalRepresentation&lt;Q&gt;::str(); //    if(stail == "0") stail = ""; std::string curr = std::to_string(Digit&lt;R&gt;::value); //     if(stail != "") while(curr.size() &lt; modulo_log) curr = "0" + curr; return stail + curr; } };</span></span></code> </pre><br>  And finally, our code <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> A = BigUnsigned&lt;<span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>ULL&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> B = One; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> C = Sum&lt;A, B&gt;::Result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; DecimalRepresentation&lt;C&gt;::str() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  gives out <code>4294967296</code> , which is exactly equal to 2 <sup>32</sup> ! <br><br><div class="spoiler">  <b class="spoiler_title">All code together</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;bitset&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;type_traits&gt; template&lt;uint32_t... digits&gt; struct BigUnsigned { static const size_t length = sizeof...(digits); }; using Zero = BigUnsigned&lt; &gt;; using One = BigUnsigned&lt;1&gt;; template&lt;class A, class B&gt; struct Concatenate { using Result = void; }; template&lt;uint32_t... a, uint32_t... b&gt; struct Concatenate&lt;BigUnsigned&lt;a...&gt;, BigUnsigned&lt;b...&gt;&gt; { // &gt;&gt; -    C++11 using Result = BigUnsigned&lt;a..., b...&gt;; }; template&lt;class A, class B&gt; struct Sum; template&lt;class A&gt; struct Sum&lt;Zero, A&gt; { using Result = A; }; template&lt;class A&gt; struct Sum&lt; A, Zero&gt; { using Result = A; }; //       ,      : template&lt; &gt; struct Sum&lt;Zero, Zero&gt; { using Result = Zero; }; template&lt;uint32_t a_0, uint32_t... a_tail, uint32_t b_0, uint32_t... b_tail&gt; struct Sum&lt;BigUnsigned&lt;a_0, a_tail...&gt;, BigUnsigned&lt;b_0, b_tail...&gt;&gt; { static const uint32_t carry = b_0 &gt; UINT32_MAX - a_0 ? 1 : 0; using Result = typename Concatenate&lt; BigUnsigned&lt;a_0 + b_0&gt;, typename Sum&lt; typename Sum&lt; BigUnsigned&lt;a_tail...&gt;, BigUnsigned&lt;b_tail...&gt; &gt;::Result, BigUnsigned&lt;carry&gt; &gt;::Result &gt;::Result; }; template&lt;class A&gt; struct BinaryRepresentation; template&lt;uint32_t a_0, uint32_t... a&gt; struct BinaryRepresentation&lt;BigUnsigned&lt;a_0, a...&gt;&gt; { static std::string str(void) { std::bitset&lt;32&gt; bset(a_0); return BinaryRepresentation&lt;BigUnsigned&lt;a...&gt;&gt;::str() + bset.to_string(); } }; template&lt;&gt; struct BinaryRepresentation&lt;Zero&gt; { static std::string str(void) { return "0b"; // Oppa Python Style } }; template&lt;class A, class B&gt; struct Difference; struct OverflowError {}; template&lt;&gt; struct Difference&lt;Zero, Zero&gt; { using Result = Zero; }; template&lt;uint32_t n, uint32_t... tail&gt; struct Difference&lt;BigUnsigned&lt;n, tail...&gt;, Zero&gt; { using Result = BigUnsigned&lt;n, tail...&gt;; }; template&lt;uint32_t n, uint32_t... tail&gt; struct Difference&lt;Zero, BigUnsigned&lt;n, tail...&gt;&gt; { using Result = OverflowError; }; template&lt;class A&gt; struct Difference&lt;OverflowError, A&gt; { using Result = OverflowError; }; template&lt;class A&gt; struct Difference&lt;A, OverflowError&gt; { using Result = OverflowError; }; template&lt;uint32_t a_n, uint32_t b_n, uint32_t... a_tail, uint32_t... b_tail&gt; struct Difference&lt;BigUnsigned&lt;a_n, a_tail...&gt;, BigUnsigned&lt;b_n, b_tail...&gt; &gt; { using A = BigUnsigned&lt;a_n, a_tail...&gt;; //      using B = BigUnsigned&lt;b_n, b_tail...&gt;; using C = typename Difference&lt;BigUnsigned&lt;a_tail...&gt;, BigUnsigned&lt;b_tail...&gt;&gt;::Result; using Result_T = typename std::conditional&lt; //    ? a_n &gt;= b_n, C, typename Difference&lt;C, One&gt;::Result &gt;::type; using Result = typename std::conditional&lt; //     a_n == b_n &amp;&amp; std::is_same&lt;Result_T, Zero&gt;::value, Zero, typename Concatenate&lt; BigUnsigned&lt;a_n - b_n&gt;, Result_T &gt;::Result &gt;::type; }; template&lt;class A, size_t shift&gt; struct ShiftLeft; template&lt;class A, size_t shift&gt; struct ShiftRight; template&lt;class A, size_t shift&gt; struct BigShiftLeft; template&lt;class A, size_t shift&gt; struct BigShiftRight; template&lt;class A, size_t shift&gt; struct SmallShiftLeft; template&lt;class A, size_t shift&gt; struct SmallShiftRight; template&lt;size_t shift&gt; struct BigShiftLeft &lt;Zero, shift&gt; { using Result = Zero; }; template&lt;size_t shift&gt; struct BigShiftRight &lt;Zero, shift&gt; { using Result = Zero; }; template&lt;size_t shift&gt; struct SmallShiftLeft &lt;Zero, shift&gt; { using Result = Zero; }; template&lt;size_t shift&gt; struct SmallShiftRight&lt;Zero, shift&gt; { using Result = Zero; static const uint32_t carry = 0; }; template&lt;uint32_t... a&gt; struct BigShiftLeft &lt;BigUnsigned&lt;a...&gt;, 0&gt; { using Result = BigUnsigned&lt;a...&gt;; }; template&lt;uint32_t... a&gt; struct BigShiftRight &lt;BigUnsigned&lt;a...&gt;, 0&gt; { using Result = BigUnsigned&lt;a...&gt;; }; template&lt;uint32_t... a&gt; struct SmallShiftLeft &lt;BigUnsigned&lt;a...&gt;, 0&gt; { using Result = BigUnsigned&lt;a...&gt;; }; template&lt;uint32_t... a&gt; struct SmallShiftRight&lt;BigUnsigned&lt;a...&gt;, 0&gt; { using Result = BigUnsigned&lt;a...&gt;; static const uint32_t carry = 0; }; template&lt;uint32_t... a, size_t shift&gt; struct BigShiftLeft&lt;BigUnsigned&lt;a...&gt;, shift&gt; { using Result = typename Concatenate&lt; BigUnsigned&lt;0&gt;, typename BigShiftLeft&lt; BigUnsigned&lt;a...&gt;, shift - 1 &gt;::Result &gt;::Result; }; template&lt;uint32_t a_0, uint32_t... a_tail, size_t shift&gt; struct BigShiftRight&lt;BigUnsigned&lt;a_0, a_tail...&gt;, shift&gt; { using Result = typename BigShiftRight&lt; BigUnsigned&lt;a_tail...&gt;, shift - 1 &gt;::Result; }; template&lt;uint32_t a_0, uint32_t... a_tail, size_t shift&gt; struct SmallShiftLeft&lt;BigUnsigned&lt;a_0, a_tail...&gt;, shift&gt; { static_assert(shift &lt; 32, "shift in SmallShiftLeft must be less than 32 bits"); static const uint32_t carry = a_0 &gt;&gt; (32 - shift); using Tail = typename Sum&lt; //    Or  Xor,  Sum     typename SmallShiftLeft&lt;BigUnsigned&lt;a_tail...&gt;, shift&gt;::Result, BigUnsigned&lt;carry&gt; &gt;::Result; using Result = typename std::conditional&lt; std::is_same&lt;Tail, BigUnsigned&lt;0&gt;&gt;::value, //   ,   (!) BigUnsigned&lt;(a_0 &lt;&lt; shift)&gt;, typename Concatenate&lt; BigUnsigned&lt;(a_0 &lt;&lt; shift)&gt;, Tail &gt;::Result &gt;::type; }; template&lt;uint32_t a_0, uint32_t... a_tail, size_t shift&gt; struct SmallShiftRight&lt;BigUnsigned&lt;a_0, a_tail...&gt;, shift&gt; { static_assert(shift &lt; 32, "shift in SmallShiftRight must be less than 32 bits"); static const uint32_t carry = a_0 &lt;&lt; (32 - shift); using Result = typename Concatenate&lt; BigUnsigned&lt;(a_0 &gt;&gt; shift) | SmallShiftRight&lt;BigUnsigned&lt;a_tail...&gt;, shift&gt;::carry&gt;, typename SmallShiftRight&lt;BigUnsigned&lt;a_tail...&gt;, shift&gt;::Result &gt;::Result; }; template&lt;class A, size_t shift&gt; struct ShiftLeft { using Result = typename BigShiftLeft&lt; typename SmallShiftLeft&lt;A, shift % 32&gt;::Result, shift / 32 &gt;::Result; }; template&lt;class A, size_t shift&gt; struct ShiftRight { using Result = typename SmallShiftRight&lt; typename BigShiftRight&lt;A, shift / 32&gt;::Result, shift % 32 &gt;::Result; }; template&lt;class A, class B&gt; struct GreaterThan; template&lt;class A, class B&gt; struct GreaterThanOrEqualTo; template&lt;class A&gt; struct GreaterThan&lt;Zero, A&gt; { static const bool value = false; }; template&lt;class A&gt; struct GreaterThanOrEqualTo&lt;Zero, A&gt; { static const bool value = false; }; template&lt; &gt; struct GreaterThanOrEqualTo&lt;Zero, Zero&gt; { static const bool value = true; }; template&lt;uint32_t n, uint32_t... tail&gt; struct GreaterThanOrEqualTo&lt;BigUnsigned&lt;n, tail...&gt;, Zero&gt; { static const bool value = true; }; template&lt;uint32_t n, uint32_t... tail&gt; struct GreaterThan&lt;BigUnsigned&lt;n, tail...&gt;, Zero&gt; { static const bool value = n &gt; 0 || GreaterThan&lt;BigUnsigned&lt;tail...&gt;, Zero&gt;::value; }; template&lt;uint32_t a_n, uint32_t b_n, uint32_t... a_tail, uint32_t... b_tail&gt; struct GreaterThan&lt;BigUnsigned&lt;a_n, a_tail...&gt;, BigUnsigned&lt;b_n, b_tail...&gt;&gt; { using A_tail = BigUnsigned&lt;a_tail...&gt;; using B_tail = BigUnsigned&lt;b_tail...&gt;; static const bool value = GreaterThan&lt;A_tail, B_tail&gt;::value || (GreaterThanOrEqualTo&lt;A_tail, B_tail&gt;::value &amp;&amp; a_n &gt; b_n); }; template&lt;uint32_t a_n, uint32_t b_n, uint32_t... a_tail, uint32_t... b_tail&gt; struct GreaterThanOrEqualTo&lt;BigUnsigned&lt;a_n, a_tail...&gt;, BigUnsigned&lt;b_n, b_tail...&gt;&gt; { using A_tail = BigUnsigned&lt;a_tail...&gt;; using B_tail = BigUnsigned&lt;b_tail...&gt;; static const bool value = GreaterThan&lt;A_tail, B_tail&gt;::value || (GreaterThanOrEqualTo&lt;A_tail, B_tail&gt;::value &amp;&amp; a_n &gt;= b_n); }; template&lt;class A, class B&gt; struct LessThan { static const bool value = !GreaterThanOrEqualTo&lt;A, B&gt;::value; }; template&lt;class A, class B&gt; struct LessThanOrEqualTo { static const bool value = !GreaterThan&lt;A, B&gt;::value; }; struct DivisionByZeroError { }; template&lt;class A, class B&gt; struct Division; template&lt;class A&gt; struct Division&lt;A, Zero&gt; { using Quotient = DivisionByZeroError; using Residue = DivisionByZeroError; }; template&lt;uint32_t n, uint32_t... tail&gt; struct Division&lt;BigUnsigned&lt;n, tail...&gt;, One&gt; { using Quotient = BigUnsigned&lt;n, tail...&gt;; using Residue = Zero; }; template&lt;class A, class B&gt; struct DummyDivision { using Quotient = Zero; using Residue = A; }; template&lt;uint32_t a_n, uint32_t b_n, uint32_t... a_tail, uint32_t... b_tail&gt; struct Division&lt;BigUnsigned&lt;a_n, a_tail...&gt;, BigUnsigned&lt;b_n, b_tail...&gt;&gt; { private: using A = BigUnsigned&lt;a_n, a_tail...&gt;; using B = BigUnsigned&lt;b_n, b_tail...&gt;; using D = typename std::conditional&lt; GreaterThanOrEqualTo&lt;A, B&gt;::value, Division&lt;A, typename SmallShiftLeft&lt;B, 1&gt;::Result&gt;, DummyDivision&lt;A, B&gt; &gt;::type; using Q = typename D::Quotient; using R = typename D::Residue; public: using Quotient = typename Sum&lt; typename SmallShiftLeft&lt;Q, 1&gt;::Result, typename std::conditional&lt;GreaterThanOrEqualTo&lt;R, B&gt;::value, One, Zero&gt;::type &gt;::Result; using Residue = typename std::conditional&lt; GreaterThanOrEqualTo&lt;R, B&gt;::value, typename Difference&lt;R, B&gt;::Result, R &gt;::type; }; template&lt;class A&gt; struct DecimalRepresentation; template&lt;&gt; struct DecimalRepresentation&lt;Zero&gt; { static inline std::string str(void) { return "0"; } }; template&lt;class A&gt; struct Digit; template&lt;&gt; struct Digit&lt;Zero&gt; { static const uint32_t value = 0; }; template&lt;uint32_t digit, uint32_t... tail&gt; struct Digit&lt;BigUnsigned&lt;digit, tail...&gt;&gt; { static const uint32_t value = digit; }; template&lt;uint32_t n, uint32_t... tail&gt; struct DecimalRepresentation&lt;BigUnsigned&lt;n, tail...&gt;&gt; { private: static const uint32_t modulo = 1000000000UL; static const uint32_t modulo_log = 9; using D = Division&lt;BigUnsigned&lt;n, tail...&gt;, BigUnsigned&lt;modulo&gt;&gt;; using Q = typename D::Quotient; using R = typename D::Residue; static_assert(Digit&lt;R&gt;::value &lt; modulo, "invalid division by power of 10"); public: static std::string str(void ){ std::string stail = DecimalRepresentation&lt;Q&gt;::str(); if(stail == "0") stail = ""; std::string curr = std::to_string(Digit&lt;R&gt;::value); if(stail != "") while(curr.size() &lt; modulo_log) curr = "0" + curr; return stail + curr; } }; using A = BigUnsigned&lt;0xFFFFFFFFULL&gt;; using B = One; using C = Sum&lt;A, B&gt;::Result; int main(int argc, char** argv) { std::cout &lt;&lt; DecimalRepresentation&lt;C&gt;::str() &lt;&lt; std::endl; }</span></span></span></span></code> </pre> </div></div><br><br><h2>     </h2><br><br> -,  ,       .   <br>    :  (),   ,   <br> .  ,    <code>BigSigned&lt;int, uint32_t...&gt;</code> <br>          . <br><br> -, .       , ,   . <br> (  ,      , ,  , <br>    .)  ,       . <br><br> -,  ,    ‚Äî     <br>       .           ‚Äî ,    . </div><p>Source: <a href="https://habr.com/ru/post/248897/">https://habr.com/ru/post/248897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248887/index.html">Hacking a bitcoin exchange on Rails</a></li>
<li><a href="../248889/index.html">‚ÄúOpen Financial Data: Possibilities for Using It‚Äù</a></li>
<li><a href="../248891/index.html">Do not rush to throw out the old servers, you can assemble fast Ethernet-storage in an hour</a></li>
<li><a href="../248893/index.html">Practice "Intel IoT". Galileo Gen2 - Linux & Arduino</a></li>
<li><a href="../248895/index.html">Buttons do not happen much</a></li>
<li><a href="../248899/index.html">We write extensions with Roslyn by 2015 studios (part 1)</a></li>
<li><a href="../248901/index.html">Annotation to "Effective Modern C ++" by Scott Myers. Part 2</a></li>
<li><a href="../248903/index.html">Launch Linux in Microsoft Azure</a></li>
<li><a href="../248907/index.html">Software routing with VyOS</a></li>
<li><a href="../248909/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.1 of 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>