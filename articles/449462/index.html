<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using PKCS # 11 cryptographic token mechanisms in scripting languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In his comments on the article ‚ÄúAn English-language cross-platform utility for viewing Russian x509 qualified certificates,‚Äù user Pas very correctly n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using PKCS # 11 cryptographic token mechanisms in scripting languages</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/zf/pt/t6/zfptt6z2xd1tfn_xoovblv2gpuk.png" align="left">  In his comments on the <a href="https://habr.com/ru/post/440754/">article</a> ‚ÄúAn English-language cross-platform utility for viewing Russian x509 qualified certificates,‚Äù user <a href="https://habr.com/ru/users/pas/" class="user_link">Pas</a> very correctly noted about PKCS # 11 tokens that they ‚Äúcan count everything themselves‚Äù.  Yes, tokens are actually cryptographic computers.  And the natural desire is to use these computers in scripting languages, be it Python, Perl or Ruby.  We have already somehow considered the <a href="https://habr.com/ru/post/335712/">use of PKCS # 11 tokens</a> with the support of Russian cryptography in Python for signing and encrypting documents to create a certificate request: <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/fad/2c8/cc8/fad2c8cc898827d22442885cc9513afd.png" alt="image"><br><br>  Here we will continue the conversation about the Tcl language.  In the previous <a href="https://habr.com/ru/post/443480/">article</a> , when we reviewed and validated certificates stored on PKCS # 11 tokens / smartcards, we used the <a href="http://rkeene.org/projects/info/wiki/tclpkcs11">TclPKCS11 version 0.9.9</a> package to access them (certificates).  As already noted, unfortunately, the package was developed for RSA cryptography and taking into account the PKCS # 11 v.2.20 standard.  Today, the PKCS # 11 v.2.40 standard is being used and the technical committee on cryptography TK-26 is guided by it, issuing recommendations for domestic manufacturers of tokens / smartcards that support Russian cryptography.  And with all this in mind, a new package <a href="https://github.com/a513/TclPKCS11">TclPKCS11 version 1.0.1 has appeared</a> .  Immediately make a reservation, all the cryptographic interfaces for RSA in the new version of the TclPKCS11 v.10.1 package are saved.  The library package is written in C language. <br><br>  So what's new in the package?  First of all, a command was added that allows you to get a list of cryptographic mechanisms supported by the connected token: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="plaintext hljs">::pki::pkcs11::listmechs &lt;handl&gt; &lt;slotid&gt;</code> </pre> <br>  How to get a list of slots with connected tokens is shown <a href="https://habr.com/ru/post/443480/">here</a> (procedure - proc :: slots_with_token): <br><br><pre> <code class="plaintext hljs">proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] }</code> </pre> <br>  Take a simple script: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path . package require pki::pkcs11 #      RuToken set lib "/usr/local/lib64/librtpkcs11ecp_2.0.so" &lt;source lang="bash"&gt;set handle [pki::pkcs11::loadmodule $lib] #    #       set labslot [::slots_with_token $handle] if {[llength $labslot] == 0} { puts "     " exit } set slotid 0 set lmech [pki::pkcs11::listmechs $handle $slotid] set i 0 foreach mm $lmech { #   if {[string first "GOSTR3410" $mm] != -1} { puts -nonewline "[lindex $mm 0] " if {$i == 2} {puts "";set i 0} else { incr i} } } puts "\n" exit</code> </pre> <br>  This script allows you to get a list of mechanisms for GOSTR3410 cryptography supported on tokens of the RuToken family.  For a start, let's take, as <a href="https://habr.com/ru/users/pas/" class="user_link">Pas</a> wrote in the <a href="https://habr.com/ru/post/440754/">article</a> , ‚Äúthe beloved of all kinds of EDO Rutoken Light‚Äù <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = ruToken Lite 0 {ruToken Lite } $</code> </pre> <br>  And it will naturally turn out that he does not support any of the mezanism of GOST, which was to be proved.  Take another token Rutoken EDS: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = ruToken ECP } 0 {ruToken ECP } CKM_GOSTR3410_KEY_PAIR_GEN CKM_GOSTR3410 CKM_GOSTR3410_DERIVE CKM_GOSTR3410_WITH_GOSTR3411 $</code> </pre> <br>  Yes, this token supports Russian cryptography, but only the signature of GOST R 34.10-2001, which is practically <a href="https://habr.com/ru/post/436370/">out of use</a> .  But if you take the token Rutoken EDS-2.0, then everything will be fine, it supports GOST R 34.10-2012 with the keys of length 256 and 512 bits: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = RuTokenECP20 0 {RuTokenECP20 } CKM_GOSTR3410_KEY_PAIR_GEN CKM_GOSTR3410 CKM_GOSTR3410_DERIVE CKM_GOSTR3410_512_KEY_PAIR_GEN CKM_GOSTR3410_512 CKM_GOSTR3410_12_DERIVE CKM_GOSTR3410_WITH_GOSTR3411 CKM_GOSTR3410_WITH_GOSTR3411_12_256 CKM_GOS TR3410_WITH_GOSTR3411_12_512 $</code> </pre><br><img src="https://habrastorage.org/webt/1y/za/nm/1yzanmwujk76deyqsdqgw8kge3u.png" align="left">  If we started talking about the support of Russian cryptography, including grasshopper and magma encryption algorithms, with these or other tokens, then software and <a href="https://habr.com/ru/post/403563/">cloud</a> tokens most fully support it, and this is natural: <br><br><pre> <code class="plaintext hljs">$ tclsh TEST_for_HABR.tcl listtok(0) = LS11SW2016_LIN_64 0 {LS11SW2016_LIN_64 }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">List of mechanisms</b> <div class="spoiler_text">  CKM_GOSTR3410_KEY_PAIR_GEN <br>  CKM_GOSTR3410_512_KEY_PAIR_GEN <br>  CKM_GOSTR3410 <br>  CKM_GOSTR3410_512 <br>  CKM_GOSTR3410_WITH_GOSTR3411 <br>  CKM_GOSTR3410_WITH_GOSTR3411_12_256 <br>  CKM_GOSTR3410_WITH_GOSTR3411_12_512 <br>  CKM_GOSTR3410_DERIVE <br>  CKM_GOSTR3410_12_DERIVE <br>  CKM_GOSR3410_2012_VKO_256 <br>  CKM_GOSR3410_2012_VKO_512 <br>  CKM_KDF_4357 <br>  CKM_KDF_GOSTR3411_2012_256 <br>  CKM_KDF_TREE_GOSTR3411_2012_256 <br>  CKM_GOSTR3410_KEY_WRAP <br>  CKM_GOSTR3410_PUBLIC_KEY_DERIVE <br>  CKM_LISSI_GOSTR3410_PUBLIC_KEY_DERIVE <br>  CKM_GOST_GENERIC_SECRET_KEY_GEN <br>  CKM_GOST_CIPHER_KEY_GEN <br>  CKM_GOST_CIPHER_ECB <br>  CKM_GOST_CIPHER_CBC <br>  CKM_GOST_CIPHER_CTR <br>  CKM_GOST_CIPHER_OFB <br>  CKM_GOST_CIPHER_CFB <br>  CKM_GOST_CIPHER_OMAC <br>  CKM_GOST_CIPHER_KEY_WRAP <br>  CKM_GOST_CIPHER_ACPKM_CTR <br>  CKM_GOST_CIPHER_ACPKM_OMAC <br>  CKM_GOST28147_KEY_GEN <br>  CKM_GOST28147 <br>  CKM_GOST28147_KEY_WRAP <br>  CKM_GOST28147_PKCS8_KEY_WRAP <br>  CKM_GOST_CIPHER_PKCS8_KEY_WRAP <br>  CKM_GOST28147_ECB <br>  CKM_GOST28147_CNT <br>  CKM_GOST28147_MAC <br>  CKM_KUZNYECHIK_KEY_GEN <br>  CKM_KUZNYECHIK_ECB <br>  CKM_KUZNYECHIK_CBC <br>  CKM_KUZNYECHIK_CTR <br>  CKM_KUZNYECHIK_OFB <br>  CKM_KUZNYECHIK_CFB <br>  CKM_KUZNYECHIK_OMAC <br>  CKM_KUZNYECHIK_KEY_WRAP <br>  CKM_KUZNYECHIK_ACPKM_CTR <br>  CKM_KUZNYECHIK_ACPKM_OMAC <br>  CKM_MAGMA_KEY_GEN <br>  CKM_MAGMA_ECB <br>  CKM_MAGMA_CBC <br>  CKM_MAGMA_CTR <br>  CKM_MAGMA_OFB <br>  CKM_MAGMA_CFB <br>  CKM_MAGMA_OMAC <br>  CKM_MAGMA_KEY_WRAP <br>  CKM_MAGMA_ACPKM_CTR <br>  CKM_MAGMA_ACPKM_OMAC <br>  CKM_GOSTR3411 <br>  CKM_GOSTR3411_12_256 <br>  CKM_GOSTR3411_12_512 <br>  CKM_GOSTR3411_HMAC <br>  CKM_GOSTR3411_12_256_HMAC <br>  CKM_GOSTR3411_12_512_HMAC <br>  CKM_PKCS5_PBKD2 <br>  CKM_PBA_GOSTR3411_WITH_GOSTR3411_HMAC <br>  CKM_TLS_GOST_KEY_AND_MAC_DERIVE <br>  CKM_TLS_GOST_PRE_MASTER_KEY_GEN <br>  CKM_TLS_GOST_MASTER_KEY_DERIVE <br>  CKM_TLS_GOST_PRF <br>  CKM_TLS_GOST_PRF_2012_256 <br>  CKM_TLS_GOST_PRF_2012_512 <br>  CKM_TLS12_MASTER_KEY_DERIVE <br>  CKM_TLS12_KEY_AND_MAC_DERIVE <br>  CKM_TLS_MAC <br>  CKM_TLS_KDF <br>  CKM_TLS_TREE_GOSTR3411_2012_256 <br>  CKM_EXTRACT_KEY_FROM_KEY <br>  CKM_SHA_1 <br>  CKM_MD5 <br></div></div><br><pre> <code class="plaintext hljs">$</code> </pre> <br>  Go to the next new feature added to the package: <br><br><pre> <code class="plaintext hljs">set listcertsder [pki::pkcs11::listcertsder $handle $slotid]</code> </pre> <br>  This function returns a list of certificates stored in the token.  The question naturally arises, how does it differ from the existing function pki :: pkcs11 :: listcerts? <br><br>  First of all, the new feature does not use the package :: pki.  One of the returned items is the cert_der element, which contains the full certificate.  This is convenient, for example, when exporting a certificate, or obtaining its print (fingetprint).  <a href="https://habr.com/ru/post/440754/">Previously, you</a> had to collect a full certificate from a tbs certificate and its signature.  A complete list of returned items for each certificate is clearly visible when listing the contents of one certificate: <br><br><pre> <code class="plaintext hljs">. . . array set derc [[pki::pkcs11::listcertsder $handle $slotid] 0] parray derc derc(cert_der) = 3082064a ‚Ä¶ derc(pkcs11_handle) = pkcsmod0 derc(pkcs11_id) = 5882d64386211cf3a8367d2f87659f9330e5605d derc(pkcs11_label) = Thenderbird-60   derc(pkcs11_slotid) = 0 derc(type) = pkcs11 . . .</code> </pre> <br>  The pkcs11_id element stores the CKA_ID attribute value SHA-1 hash of the public key.  The cert_der element is the CKA_VALUE certificate, pkcs11_label is CKA_LABEL. <br><br>  The pkcs11_id element (CKA_ID in the terminology of the PKCS # 11 standard) is along with the pkcs11_handle library and the slot identifier with the token pkcs11_slotid the key element <a href="https://habr.com/ru/post/316328/">for accessing</a> keys and certificates stored on tokens. <br><br>  So, if we want to change the label (pkcs11_label) of the certificate or keys, we execute a command like this: <br><br><pre> <code class="plaintext hljs">pki::pkcs11::rname &lt;cert|key|all&gt; &lt;  &gt;</code> </pre> <br>  To remove a certificate or keys from a token, the following command is executed: <br><br><pre> <code class="plaintext hljs">pki::pkcs11::delete &lt;cert|key|all&gt; &lt;  &gt;</code> </pre> <br>  The list of key elements can be formed as follows: <br><br><pre> <code class="plaintext hljs">set listparam {} lappend listparam pkcs11_handle lappend listparam $handle lappend listparam pkcs11_slotid lappend listparam $pkcs11_slotid lappend listparam pkcs11_id lappend listparam $pkcs11_id</code> </pre> <br>  etc. <br>  The function call in this case looks like this (we will delete the certificate and its associated keys): <br><br><pre> <code class="plaintext hljs">pki::pkcs11::delete all $listparam</code> </pre> <br>  The reader has probably guessed that this list can be arranged as a dict dictionary: <br><br><pre> <code class="plaintext hljs">set listparam [dict create pkcs11_handle $pkcs11_handle] dict set listparam pkcs11_slotid $pkcs11_slotid) dict set listparam pkcs11_id $pkcs11_id</code> </pre> <br>  There are other ways, for example, through an array. <br><br>  Once again, we note that the list of key elements must always contain the elements pkcs11_handle and pkcs11_slotid, which unambiguously determine the connected token.  The rest of the composition is determined by a specific function. <br><br>  To install on the certificate token, use the following function: <br><br><pre> <code class="plaintext hljs">set pkcs11_id_cert [::pki::pkcs11::importcert &lt;cert_der_hex&gt; &lt;  &gt;</code> </pre> <br>  The function returns the value of CKA_ID in hexadecimal.  The list of key parameters determines the token on which the certificate will be located: <br><br><pre> <code class="plaintext hljs">{pkcs11_handle &lt;handle&gt; pkcs11_slotid &lt;slotid&gt;}</code> </pre><br>  Next up is the hash calculation.  In Russian cryptography today, three types of hash functions are used: <br>  - GOST R 34.11-94 <br>  - GOST R 34 .11-2012 with a hash length of 256 bits (stribog256) <br>  - GOST R 34 .11-2012 with a hash length of 512 bits (stribog512) <br>  To determine which hash the token supports, we have the function pki :: pkcs11 :: listmechs. <br><br>  The hash calculation function is as follows: <br><br><pre> <code class="plaintext hljs">set &lt;&gt; [pki::pkcs11::digest &lt;gostr3411|stribog256|stribog512|sha1&gt; &lt;  &gt; &lt;  &gt;]</code> </pre> <br>  Note that the result of the calculation is represented in hexadecimal form: <br><pre> <code class="plaintext hljs">. . . set listparam [dict create pkcs11_handle $pkcs11_handle] dict set listparam pkcs11_slotid $pkcs11_slotid set res_hex [pki::pkcs11::digest stribog256 0123456789 $listparam] puts $res_hex 086f2776f33aae96b9a616416b9d1fe9a049951d766709dbe00888852c9cc021</code> </pre><br>  For verification, take <a href="https://habr.com/ru/post/415423/">openssl with the support of Russian cryptography</a> : <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>|/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lirssl_csp_64/bin/lirssl_s tatic dgst -md_gost12_256 (stdin)= 086f2776f33aae96b9a616416b9d1fe9a0499 51d766709dbe00888852c9 cc021 $</code> </pre> <br>  As you can see, the result is identical. <br><br>  To verify the electronic signature, whether it is a certificate or a list of revoked certificates or a signed document in the format, we now lack only the signature verification function: <br><br><pre> <code class="plaintext hljs">set result [pki::pkcs11::verify &lt; &gt; &lt; &gt; &lt;  &gt;]]</code> </pre> <br>  If the signature has passed verification, then 1 is returned; otherwise, it returns 0. To verify the electronic signature, the document itself must be signed, the document hash determined by the signature type, and the public key that generated the signature with all parameters (value, type and parameters) .  All key information in the form of an asn1 publickeyinfo structure should be included in the list of key elements: <br><blockquote>  lpkar (pkcs11_handle) = pkcsmod0 <br>  lpkar (pkcs11_slotid) = 0 <br>  lpkar (pubkeyinfo) = 301f06082a85030701010101301306072a85030202240 <br>  006082a8503070101020203430004407d9306687af5a8e63af4b09443ed2e03794be <br>  10eba6627bf5fb3da1bb474a3507d2ce2cd24b63c727a02521897d1dd6edbdc7084d <br>  8886a39289c3f81bdf2e179 </blockquote>  The ASN1 public key structure is taken from the signer‚Äôs certificate: <br><br><pre> <code class="plaintext hljs">proc ::pki::x509::parse_cert_pubkeyinfo {cert_hex} { array set ret [list] set wholething [binary format H* $cert_hex] ::asn::asnGetSequence wholething cert ::asn::asnPeekByte cert peek_tag if {$peek_tag != 0x02} { # Version number is optional, if missing assumed to be value of 0 ::asn::asnGetContext cert - asn_version ::asn::asnGetInteger asn_version ret(version) } ::asn::asnGetBigInteger cert ret(serial_number) ::asn::asnGetSequence cert data_signature_algo_seq ::asn::asnGetObjectIdentifier data_signature_algo_seq ret(data_signature_algo) ::asn::asnGetSequence cert issuer ::asn::asnGetSequence cert validity ::asn::asnGetUTCTime validity ret(notBefore) ::asn::asnGetUTCTime validity ret(notAfter) ::asn::asnGetSequence cert subject ::asn::asnGetSequence cert pubkeyinfo binary scan $pubkeyinfo H* ret(pubkeyinfo) return $ret(pubkeyinfo) }</code> </pre> <br>  The text of the script to verify the electronic signature of certificates from the file is <div class="spoiler">  <b class="spoiler_title">here</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#! /usr/bin/env tclsh package require pki lappend auto_path . package require pki::pkcs11 #     PKCS#11 #set pkcs11_module "/usr/local/lib/libcackey.so" #set pkcs11_module "/usr/local/lib64/librtpkcs11ecp_2.0.so" set pkcs11_module "/usr/local/lib64/libls11sw2016.so" puts "Connect the Token and press Enter" gets stdin yes set handle [pki::pkcs11::loadmodule $pkcs11_module] set slots [pki::pkcs11::listslots $handle] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid #    break } } # PEM  DER proc ::cert_to_der {data} { if {[string first "-----BEGIN CERTIFICATE-----" $data] != -1} { set data [string map {"\r\n" "\n"} $data] } array set parsed_cert [::pki::_parse_pem $data "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"] if {[string range $parsed_cert(data) 0 0 ] == "0" } { #   DER- "0" == 0x30 set asnblock $parsed_cert(data) } else { set asnblock "" } return $asnblock } proc usage {use error} { puts "Copyright(C) Orlov Vladimir (http://soft.lissi.ru) 2019" if {$use == 1} { puts $error puts "Usage:\nverify_cert_with_pkcs11 &lt;file with certificate&gt; \[&lt;file with CA certificate&gt;\]\n" } } set countcert [llength $argv] if { $countcert &lt; 1 || $countcert &gt; 2 } { usage 1 "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { usage 1 "File $file not exist" exit } #  cert_user puts "Loading user certificate: $file" set fd [open $file] chan configure $fd -translation binary set cert_user [read $fd] close $fd if {$cert_user == "" } { usage 1 "Bad file with certificate user: $file" exit } set cert_user [cert_to_der $cert_user] if {$cert_user == ""} { puts "User certificate bad" exit } catch {array set cert_parse [::pki::x509::parse_cert $cert_user]} if {![info exists cert_parse]} { puts "User certificate bad" exit } #parray cert_parse if {$countcert == 1} { if {$cert_parse(issuer) != $cert_parse(subject)} { puts "Bad usage: not self signed certificate" } else { set cert_CA $cert_user } } else { set fileca [lindex $argv 1] if {![file exists $fileca]} { usage 1 "File $fileca not exist" exit } #  cert_CA puts "Loading CA certificate: $fileca" set fd [open $fileca] chan configure $fd -translation binary set cert_CA [read $fd] close $fd if {$cert_CA == "" } { usage 1 "Bad file with certificate CA=$fileca" exit } set cert_CA [cert_to_der $cert_CA] if {$cert_CA == ""} { puts "CA certificate bad" exit } } foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid } } #    #array set cert_parse_CA [::pki::x509::parse_cert $cert_CA] catch {array set cert_parse_CA [::pki::x509::parse_cert $cert_CA]} #array set cert_parse_CA [::pki::x509::parse_cert $cert_CA_256] #array set cert_parse_CA [::pki::x509::parse_cert $CA_12_512] if {![info exists cert_parse_CA]} { puts "CA certificate bad" exit } ############################### set aa [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] set tbs_cert [binary format H* $cert_parse(cert)] #puts "SIGN_ALGO1=$cert_parse(signature_algo)" catch {set signature_algo_number [::pki::_oid_name_to_number $cert_parse(signature_algo)]} if {![info exists signature_algo_number]} { set signature_algo_number $cert_parse(signature_algo) } #puts "SIGN_ALGO=$signature_algo_number" switch -- $signature_algo_number { "1.2.643.2.2.3" - "1 2 643 2 2 3" { # "GOST R 34.10-2001 with GOST R 34.11-94" set digest_algo "gostr3411" } "1.2.643.7.1.1.3.2" - "1 2 643 7 1 1 3 2" { # "GOST R 34.10-2012-256 with GOSTR 34.11-2012-256" set digest_algo "stribog256" } "1.2.643.7.1.1.3.3" - "1 2 643 7 1 1 3 3" { # "GOST R 34.10-2012-512 with GOSTR 34.11-2012-512" set digest_algo "stribog512" } default { puts "  :$signature_algo_number" exit } } #   tbs-!!!! set digest_hex [pki::pkcs11::digest $digest_algo $tbs_cert $aa] puts "digest_hex=$digest_hex" puts [string length $digest_hex] # asn-   #    binary scan $cert_CA H* cert_CA_hex array set infopk [pki::pkcs11::pubkeyinfo $cert_CA_hex [list pkcs11_handle $handle pkcs11_slotid $token_slotid]] parray infopk set lpk [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] # pybkeyinfo     lappend lpk "pubkeyinfo" #lappend lpk $pubinfo lappend lpk $infopk(pubkeyinfo) array set lpkar $lpk parray lpkar puts "Enter PIN user for you token \"$token_slotlabel\":" #set password "01234567" gets stdin password if { [pki::pkcs11::login $handle $token_slotid $password] == 0 } { puts "Bad password" exit } if {[catch {set verify [pki::pkcs11::verify $digest_hex $cert_parse(signature) $lpk]} res] } { puts $res exit } if {$verify != 1} { puts "BAD SIGNATURE=$verify" } else { puts "SIGNATURE OK=$verify" } puts "!" exit</code> </pre> <br></div></div><br>  Save the script in a file and try to execute it: <br><br><pre> <code class="bash hljs">$./verify_cert_with_pkcs11.tcl Copyright(C) Orlov Vladimir (http://museum.lissi-crypto.ru/) Usage: verify_cert_with_pkcs11 &lt;file with certificate&gt; &lt;file with CA certificate&gt; $</code> </pre> <br>  It is surprising, but what about certificates on a token?  First, we solved the problem of using PKCS # 11 cryptographic machines.  We used them.  And in order to get a certificate from a token, there is a function of the pki :: pkcs11 :: listcertsder package, which allows you to select the required certificate and check it.  This can be considered a homework assignment. <br><br>  The appearance of the new version of the TclPKCS11v.1.0.1 package allowed <a href="https://github.com/a513/TclPKCS11">us</a> to refine the certificate <a href="https://habr.com/ru/post/443480/">viewing utility</a> , adding to it the functions of importing a certificate for a token, deleting certificates and associated keys from a token, changing the labels of certificates and keys, etc .: <br><br><img src="https://habrastorage.org/webt/tn/7x/e8/tn7xe89tddtvfw0r6vmtqe2oeaa.png"><br><br>  The most important added feature is certificate digital signature verification: <br><br><img src="https://habrastorage.org/webt/v8/sf/sr/v8sfsrp3tyghuwkyvseltrdtrsy.png"><br><br>  The attentive reader correctly noted that nothing is said about the generation of the key pair.  This feature is also added to the TclPKCS11 package: <br><br><pre> <code class="plaintext hljs">array set genkey [pki::pkcs11::keypair &lt; &gt; &lt;&gt; &lt;  &gt;]</code> </pre> <br>  How the functions from the TclPKCS11 package are used can of course be found in the utility source code. <br><br>  The function of generating a key pair will be discussed in detail in the next article, when the utility for creating a request for a qualified certificate will be presented with generating a key pair on the PKCS # 11 token, a mechanism for obtaining a certificate in the certification authority ( <a href="https://habr.com/ru/post/413493/">CA</a> ) and importing it to the token: <br><br><img src="https://habrastorage.org/webt/zn/c4/zu/znc4zukmmtywwnpo4ycwze4zseo.png"><br><br>  In the same article will be considered and the function of signing the document.  This will be the last article in this series.  Further, a number of articles are planned on support of Russian cryptography in the Ruby scripting language that is in fashion today.  See you! </div><p>Source: <a href="https://habr.com/ru/post/449462/">https://habr.com/ru/post/449462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449438/index.html">Synchronized security in Sophos Central</a></li>
<li><a href="../449442/index.html">What will be with authentication and passwords? Translation of the Javelin "Strong Authentication Status" report with comments</a></li>
<li><a href="../449446/index.html">Description of the device and the operation of the network of the fifth generation, deployed on the basis of the fourth generation</a></li>
<li><a href="../44945/index.html">JavaFX RIA technology is almost ready for release.</a></li>
<li><a href="../44946/index.html">About two visitors of the restaurant who ordered fish.</a></li>
<li><a href="../449464/index.html">Widget vk.com installs a counter from mail.ru on the site without asking</a></li>
<li><a href="../449468/index.html">As an "ethical hacking" software maker for gambling turned into a complete nightmare</a></li>
<li><a href="../44947/index.html">Qualities of a promising employee</a></li>
<li><a href="../449472/index.html">Cataclysm Dark Days Ahead, static analysis and bagels</a></li>
<li><a href="../449476/index.html">New type of SSD-storage will reduce power consumption in the data center - how it works</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>