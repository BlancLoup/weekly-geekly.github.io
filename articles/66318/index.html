<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Boost is easy. Part 2. Boost.Date_time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you already understood, this article will focus on the Boost.Date_Time library. Library to work with time. 




 In the article we will consider th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Boost is easy. Part 2. Boost.Date_time</h1><div class="post__text post__text-html js-mediator-article">  As you already understood, this article will focus on the Boost.Date_Time library.  Library to work with time. <br><br><br><br><br>  In the article we will consider the following parts of the library: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Gregorian </li><li>  Posix time </li><li>  Local time </li></ul><br><br><a name="habracut"></a><br><h1>  Introduction </h1><br>  Now it is probably difficult to find a person who would not be faced with the need to use time for their own purposes, or rather its digital representation.  The goals can be completely different, from simple measurements of time intervals in which a certain piece of code is executed (absolutely not the right method of profiling, by the way, but now is not about that), to support full-fledged calendars in their applications that should be relevant for any person on the globe.  All these manipulations can be performed using a rather austere and easy to use, but at the same time powerful library Boost.Date_Time.  The library includes: leap year, <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA%25D0%25BE%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B5%25D0%25BA%25D1%2583%25D0%25BD%25D0%25B4%25D0%25B0">leap second</a> , summer time, etc. <br>  We will understand some terminology used in the library: <br>  There are three global types of time sharing in the library: <br><ol><li>  <strong>Time Point</strong> - a certain point in the time continuum, for example, your date of birth </li><li>  <strong>Time Duration</strong> - a time interval that is not tied to any point in the time continuum </li><li>  <strong>Time Interval</strong> - the time interval associated with a certain point in the time continuum </li></ol><br>  It is also necessary to remember about the resolution of each method of obtaining time, the resolution ( <strong>Resolution</strong> ) shows what is the minimum unit of time that can be used when analyzing the time object you have.  Ie this is nothing more than the degree of accuracy of the obtained time point.  Finally, we turn to a direct acquaintance with the capabilities of the library. <br><br><h1>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html">boost :: gregorian</a> </h1><br>  <em>All examples used in this article imply the use of using namespace boost :: &lt;matching_namespace&gt; at the beginning of each compiled unit.</em> <br>  This component represents the <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B5%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BA%25D0%25B0%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B4%25D0%25B0%25D1%2580%25D1%258C">Gregorian calendar</a> and every conceivable opportunity to work with it.  It in turn is divided into the following components: <br><ul><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html">Date</a> <br></li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html">Date duration</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html">Date Period</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html">Date iterators</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html">Date Generators / Algorithms</a> </li></ul><br>  Let us examine the purpose of each of them: <br><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html"><strong>boost :: gregorian :: date</strong></a> - designed for simple storage of the date - point in the time continuum.  Supports creation of a date from a string of a specific format, as well as through the class <a href="http://www.boost.org/doc/libs/1_37_0/doc/html/boost/date_time/day_clock.html">boost :: date_time :: day_clock</a> , based on the standard C / C ++ mechanism associated with <a href="http://cplusplus.com/reference/clibrary/ctime/time_t/">time_t</a> <br>  In addition to storing the date (which cannot be changed for an object except by using operator =), the class has methods * for getting specific parts of the date (year (), month (), day () etc.), converting the internal representation of the date into a string , of a specific format (to_simple_string (), to_iso_string (), to_iso_extended_string ()) and conversion to (and back) the standard C / C ++ structure <a href="http://cplusplus.com/reference/clibrary/ctime/tm/">tm</a> (to_tm (), date_from_tm ()) <br><br>  * - <em>I do not provide a description of each function, moreover, I will not, provides a complete list of available functions, you can see a list of them in the links corresponding to a particular class.</em>  <em>There are a lot of functions and they are quite easy to use, I also omit the availability of function parameters, if I consider it insignificant at the moment.</em> <br>  Example: <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">date xGPWStart(1941, Jun, 22); <br> date xNowdays = day_clock::local_day(); <br> std::cout &lt;&lt; <font color="#A31515">"The Great Patriotic War was started in "</font> &lt;&lt; xGPWStart &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"And the current data is "</font> &lt;&lt; xNowdays;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Conclusion: <br><blockquote>  The Great Patriotic War was started in 1941-Jun-22 <br>  And the current data is 2009-Jul-26 </blockquote><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html"><strong>boost :: gregorian :: date_duration</strong></a> - serves to count the days, using <strong>boost :: gregorian :: date</strong> for calculations. <br>  For convenience of working with <b>date_duration,</b> there are three classes: <strong>months_duration</strong> , <strong>years_duration</strong> and <strong>weeks_duration</strong> (there are also typedefs for these types, presented for convenience: <strong>months</strong> , <strong>years,</strong> and <strong>weeks,</strong> respectively), which can be added or subtracted from date_duration to get the desired result.  There is a pitfall associated with these three classes.  If you use them in your calculations, you can get a result that you do not expect.  I will give an example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">date xSomeDay(1999, Jan, 28); <br> date xDayInNextMonth; <br> std::cout &lt;&lt; <font color="#A31515">"That's right: "</font> &lt;&lt; ( xDayInNextMonth = xSomeDay + months(1) ) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"And that's not: "</font> &lt;&lt; xDayInNextMonth + months(1); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><blockquote>  That's right: 1999-Feb-28 <br>  And that's not: 1999-Mar-31 </blockquote><br>  This behavior is due to the special feature of the <strong>months_duration</strong> class, which will always use the end of the month in arithmetic operations if the original object pointed to one of the possible numbers that end the months (28, 29, 30, 31).  Be careful when using this type, by the way <strong>month_iterator is</strong> deprived of this disadvantage (advantages?), But we'll talk about it later. <br><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html"><strong>boost :: gregorian :: date_period</strong></a> - the class is presented for conveniently representing the interval between two dates, can be used to determine whether a specific date is included in the time interval (contains ()), the intersection of intervals (intersects (), intersection ()), date adjacency ( is_adjacent ()) and determine the relationship of the location of one date relative to another (is_after (), is_before ()).  In addition, there are methods for the combination of intervals (merge (), span ()) and their changes (shift (), expand ()).  It is important to remember that the last period in the period is not included in the entire period, that is, in the period 1-Jan-1999 \ 10-Jan-1999 the last day will be January 9, not 10. <br>  Example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">date_period xGPWDuration( date(1941, Jun, 22), date(1945, May, 9) ); <br> date_period xStalinLifeYears( date(1878, Dec, 18), date(1953, Mar, 6) ); date_period xJukovsIncorrectLifeYears( date(1896, Dec, 6), date(1974, Jun, 14) ); <br> std::cout &lt;&lt; <font color="#A31515">"The Great Patriotic War duration is "</font> &lt;&lt; xGPWDuration &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"Was the GPW inside the Stalin's life years? "</font> &lt;&lt; std::boolalpha &lt;&lt; xStalinLifeYears.contains(xGPWDuration) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"Jukov's incorrect life years is "</font> &lt;&lt; xJukovsIncorrectLifeYears &lt;&lt; std::endl; <br> xJukovsIncorrectLifeYears.expand( days(5) ); <br> std::cout &lt;&lt; <font color="#A31515">"Jukov's correct life years is "</font> &lt;&lt; xJukovsIncorrectLifeYears &lt;&lt; std::endl; <br> <font color="#008000">//Last day isn't included in the interval</font> <br> date_period xFirstPeriod( date(1999, Jan, 1), date(1999, Jan, 10) ); <br> date_period xSecondPeriod( date(1999, Jan, 10), date(1999, Jan, 12) ); <br> std::cout &lt;&lt; <font color="#A31515">"Does these periods intersect? "</font> &lt;&lt; std::boolalpha &lt;&lt; xFirstPeriod.intersects(xSecondPeriod) &lt;&lt; std::endl; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  The Great Patriotic War duration is [1941-Jun-22/1945-May-08] <br>  Was the GPW inside the Stalin's life years?  true <br>  Jukov's incorrect life years [1896-Dec-06/1974-Jun-13] <br>  Jukov's correct life years is [1896-Dec-01/1974-Jun-18] <br>  Does these periods intersect?  false </blockquote><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html"><strong>boost :: gregorian :: date_iterator</strong></a> - as it should be clear from the name - this is a typical iterator designed for ‚Äúmoving‚Äù on dates.  <strong>The date_iterator</strong> is not interesting in itself, because it is an abstract class, its descendant classes are more interesting: <strong>day_iterator</strong> , <strong>week_iterator</strong> , <strong>month_iterator</strong> , <strong>year_iterator</strong> . <br>  As an example, we use the example from <strong>date_duration</strong> , in which we received an incorrect date (due to pitfalls with months).  As I mentioned earlier, there are <b>no</b> similar problems in <b>date_iterator</b> : <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">month_iterator xSomeDay(date(1999, Jan, 28)); <br> std::cout &lt;&lt; <font color="#A31515">"That's right: "</font> &lt;&lt; *++xSomeDay &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"And that's too!: "</font> &lt;&lt; *++xSomeDay; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><blockquote>  That's right: 1999-Feb-28 <br>  And that's too !: 1999-Mar-28 </blockquote><br><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html"><strong>Algorithms for working with dates</strong></a> - a set of various classes and functions for various manipulations of dates.  Each class has a get_data () method that allows you to get the date generated by this class.  Classes provide us with the following functionality: <br><ul><li>  Get the first, last or random day for a given month and week (first_day_of_the_week_in_the_month (), last_day_of_the_week_in_the_month (), nth_day_of_the_week_in_the_month).  The day of the week to search is set. </li><li>  Specify a partial date (without specifying the year) (partial_date ()).  And then get the full date using get_data () </li><li>  Calculate the first day of the week before or after the specified date (first_day_of_the_week_before (), first_day_of_the_week_after ()).  The day of the week for the calculation is given </li></ul><br>  Functions provide the following functionality: <br><ul><li>  Calculate the number of days from the current date to the next or previous, given, day of the week (days_until_weekday (), days_before_week_day ()). </li><li>  Generate the date, which will be the date of the next or previous, given, day of the week.  The new date will be generated relative to the pre-set date. </li></ul><br>  Examples: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">last_day_of_the_week_in_month xLastFriday(Friday, Jul); <br> partial_date xJunTen(10, Jun); <br> std::cout &lt;&lt; <font color="#A31515">"What is the date of the last friday in the July 2009? "</font> &lt;&lt; xLastFriday.get_date(2009) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"Just dusplay 10 Jun of 2009 "</font> &lt;&lt; xJunTen.get_date(2009) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"How much days from now till next friday? "</font> &lt;&lt; days_until_weekday( day_clock::local_day(), greg_weekday(Friday) )&lt;&lt; std::endl; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  What is the date of the last friday in July 2009?  2009-Jul-31 <br>  Just dusplay 10 Jun of 2009 2009-Jun-10 <br>  How many days from now till next friday?  five </blockquote><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html"><strong>boost :: gregorian :: gregorian_calendar</strong></a> - provides a useful set of static functions for working with dates. <br>  Instead of describing functions, I‚Äôll give an example of their use (the functions are simple and their name speaks for itself): <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">std::cout &lt;&lt; <font color="#A31515">"What the day of the GPW begining? "</font> &lt;&lt; DayToString( gregorian_calendar::day_of_week( gregorian_calendar::ymd_type(1941, Jun, 22) ) ) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"And what is the number of this day frome the epoch start? "</font> &lt;&lt; gregorian_calendar::day_number( gregorian_calendar::ymd_type(1941, Jun, 22) ) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"And what is the number of this day frome the epoch start? "</font> &lt;&lt; gregorian_calendar::day_number( gregorian_calendar::ymd_type(1400, Jan, 1) ) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"What is the last day in the February 1941? "</font> &lt;&lt; gregorian_calendar::end_of_month_day(1941, Feb) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"What is the date of the 3333333 day from the epoch start? "</font> &lt;&lt; date( gregorian_calendar::from_day_number(3333333) ) &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"Is the 2004 year a leap year? "</font> &lt;&lt; std::boolalpha &lt;&lt; gregorian_calendar::is_leap_year(2004) &lt;&lt; std::endl; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  What is the day of the GPW begining?  Sunday <br>  And what is the number of this day?  2430168 <br>  And what is the number of this day?  2232400 <br>  What is the last day of February 1941?  28 <br>  What is the date of the 3333333 day from the epoch start?  4414-Apr-03 <br>  Is the 2004 year a leap year?  true </blockquote><br>  It was obtained empirically that for the day_number () and from_day_number () functions the minimum values ‚Äã‚Äãare 1400-Jan-1 and 2232400, respectively.  If you try to use a date earlier than 1400-Jan-1, then we get an exception.  The same is true for the number of days. <br><br><h1>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html">boost :: posix_time</a> </h1><br>  This component provides us with a convenient method of working with points in time, but unlike <strong>boost :: gregorian, boost :: posix_time</strong> provides the ability to work with lower resolution time points (up to nanoseconds), the high part of the resolution (date) is implemented with the help of <strong>boost: : gregorian</strong> .  The component is especially useful for tasks in which high accuracy of time acquisition is necessary (for example, a recording line in a log file).  It is divided into the following parts: <br><ul><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html">Ptime</a> <br></li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html">Time duration</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/gregorian.html">Date Period</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html">Time Period</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html">Time iterators</a> </li></ul><br>  Let us examine the purpose of each part: <br><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html"><strong>boost :: posix_time :: ptime</strong></a> - represents a point in the time continuum.  Very similar to <strong>boost :: gregorian: date</strong> but with a resolution of up to microseconds.  When creating an instance of a class only <b>gregorian: date</b> , the ‚Äúlow resolution‚Äù part is set at midnight (all zeros). <br>  Example of use: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">ptime xTime(date(1961, Apr, 12), hours(9) + minutes(7)); <br> std::cout &lt;&lt; <font color="#A31515">"Did you know that Gagrin said \"Poehali\" at "</font> &lt;&lt; xTime &lt;&lt; <font color="#A31515">"\n"</font> ; <br> ptime xTimeStr( time_from_string( <font color="#A31515">"1961-04-12 09.07.00.0000"</font> ) ); <br> std::cout &lt;&lt; <font color="#A31515">"And the same time point constructed from a string: "</font> &lt;&lt; xTimeStr &lt;&lt; <font color="#A31515">"\n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Current time with second resolution: "</font> &lt;&lt; second_clock::local_time() &lt;&lt; <font color="#A31515">"\nAnd with microsecond:"</font> &lt;&lt; microsec_clock::local_time(); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  Did you know that Gagrin said "Poehali" at 1961-Apr-12 09:07:00 <br>  And the same time point constructed from a string: 1961-Apr-12 09:07:00 <br>  Current time with second resolution: 2009-Jul-29 16:41:51 <br>  And with microsecond: 2009-Jul-29 16: 41: 51.087000 </blockquote><br><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html"><strong>boost :: posix_time :: time_duration</strong></a> - is a duration in time that is not tied to a specific date.  The maximum duration resolution is limited to nanoseconds if the library is compiled with the <strong>BOOST_DATE_TIME_POSIX_TIME_STD_CONFIG</strong> macro, and microseconds, by default.  Information about the number of seconds \ microseconds \ milliseconds \ nanoseconds (with the corresponding assembly) that are contained in the current time duration can be obtained from the object. <br>  Example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">time_duration xTime(1,2,3); <br> std::cout &lt;&lt; <font color="#A31515">"Print time: "</font> &lt;&lt; xTime &lt;&lt; <font color="#A31515">"\n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Print increased time: "</font> &lt;&lt; xTime + hours(3) + seconds(2) + minutes(6) + milliseconds(15) + microseconds(25) &lt;&lt; <font color="#A31515">"\n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Print total seconds: "</font> &lt;&lt; xTime.total_seconds() &lt;&lt; <font color="#A31515">" milliseconds: "</font> &lt;&lt; <br> xTime.total_milliseconds() &lt;&lt; <font color="#A31515">" microseconds: "</font> &lt;&lt; xTime.total_microseconds() &lt;&lt; <font color="#A31515">"\n"</font> ; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  Print time: 01:02:03 <br>  Print increased time: 04: 08: 05.015025 <br>  Print total seconds: 3723 milliseconds: 3723000 microseconds: 3723000000 </blockquote><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html"><strong>boost :: posix_time :: time_period</strong></a> - is a segment in time, the class is similar to <strong>gregorian :: date_period</strong> , but has a lower resolution.  The class functional allows you to define the occurrence (contains ()), the intersection (intersects ()) and the length (length ()) of the intervals.  There is also the possibility of expanding (expand), offset (shift ()) and merging (merge ()) intervals. <br>  Example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">ptime xDoomsday( date(2012, Jan, 1) ); <br> time_period xArmageddonLast(xDoomsday, hours(1)); <br> time_period xChakNorrisSmoke(xDoomsday, minutes(1)); <br> std::cout &lt;&lt; <font color="#A31515">"Doomsday was during: "</font> &lt;&lt; xArmageddonLast&lt;&lt; <font color="#A31515">"\n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Chak Norris was smoking at "</font> &lt;&lt; xChakNorrisSmoke &lt;&lt; <font color="#A31515">"\n"</font> ; <br> std::cout &lt;&lt; <font color="#A31515">"Did Chak Norris smoke during Doomsday breathtaking?"</font> &lt;&lt; std::boolalpha &lt;&lt;xArmageddonLast.contains(xChakNorrisSmoke);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  Doomsday was during: [2012-Jan-01 00: 00: 00/2012-Jan-01 00: 59: 59.999999] <br>  Chak Norris was smoking at [2012-Jan-01 00: 00: 00/2012-Jan-01 00: 00: 59.999999] <br>  Did Chak Norris smoke during Doomsday breathtaking? True </blockquote><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html"><strong>boost :: posix_time :: time_iterator</strong></a> - designed (as everyone probably guessed :)) to iterate over time.  A nice feature of this iterator is the ability to set the time interval to be used during the iteration, i.e.  how much and in what units the current point in the time continuum will change at each iteration.  As time units, all units from an hour to nanoseconds can be used (if assembled with the appropriate flag) <br>  I will give a small example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">ptime xTime(date(2012, Jan, 1)); <br> time_iterator xIt(xTime, hours(6)); <br> std::cout &lt;&lt; <font color="#A31515">"6 hours after Domsday has come!!!"</font> &lt;&lt; *++xIt; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  6 hours after Domsday has come !!! 2012-Jan-01 06:00:00 </blockquote><br><h1>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">Local time system</a> </h1><br>  This component gives us the opportunity to work with time, in different time zones and with different rules for the transition to summer time.  This is quite a powerful and necessary component, especially necessary for those applications where not just the current (local) time is important, but taking into account various time shifts, according to regional agreements regarding time (summer time, time zone, etc.).  So, here is a list of parts that are included in this component: <br><ul><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">Posix Time Zone</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">Time Zone Database</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">Custom time zone</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">Local Date Time</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">Local Time Period</a> </li></ul><br><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html"><strong>boost :: local_time :: posix_time_zone</strong></a> is a set of data and rules for representing time zones (offset relative to GMT, daylight saving time rules, the name of the time zone and its abbreviation).  An object of this type is created based on a string, the format of a string is the standardized POSIX format (IEEE Std 1003.1) for time zones. <br>  In general, this line looks like this: <br>  <em>std offset dst [offset], start [/ time], end [/ time]</em> <br>  <strong>std</strong> - time zone abbreviation. <br>  <strong>offset</strong> - Offset relative to GMT. <br>  <strong>dst</strong> - time zone abbreviation during summer time. <br>  <strong>[offset]</strong> - Shows how much the time changes (in hours) when switching to summer time.  Optional parameter. <br>  <strong>start and end</strong> - Set the interval of the summer time. <br>  <strong>[/ time]</strong> - Sets the exact time within the day at which the transition to summer time begins or the summer time ends. <br>  <strong>offset</strong> and <strong>time</strong> have the following format: [+ | -] hh [: mm [: ss]] {h = 0-23, m / s = 0-59} <br>  <strong>start</strong> and <strong>end</strong> can be presented in one of the following formats: <br><ul><li>  Mm.wd {month = 1-12, week = 1-5 (5 is always the last), day = 0-6} </li><li>  Jn {n = 1-365 February 29 - not considered} </li><li>  n {n = 0-365 Takes into account February 29 in leap years} </li></ul><br>  You can get each part of this string separately using the methods of this class.  I see no reason to give their names here, they are quite transparent and reflect the essence of their purpose, so refer to the documentation for their list. <br>  As an example, I used the time zone GMT + 3 (Moscow time): <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">posix_time_zone xZone( <font color="#A31515">"MSK+3MSD+01,M3.5.0/02:00,M10.5.0/02:00"</font> ); <br> std::cout &lt;&lt; <font color="#A31515">"Dailight period in 2009 started at "</font> &lt;&lt; xZone.dst_local_start_time(2009) &lt;&lt; <font color="#A31515">"\nAnd it will finish at "</font> &lt;&lt; xZone.dst_local_end_time(2009);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Conclusion: <br><blockquote>  Dailight period in 2009 started on 2009-Mar-29 02:00:00 <br>  And it will finish at 2009-Oct-25 02:00:00 </blockquote><br><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html"><strong>boost :: local_time :: tz_database</strong></a> is a convenient class for storing a variety of different time zones.  When creating an object, an empty database is created (loudly said of course :)), after which it can be manually filled in using the add_record () method or read from the csv (comma separated values) file, an example of such a file (with a lot of records ) is contained in <em>% boost% \ libs \ date_time \ data \ date_time_zonespec.csv</em> <br>  The format of the record inside this file must meet the following standard: <blockquote>  ‚ÄúID‚Äù, ‚ÄúSTD ABBR‚Äù, ‚ÄúSTD NAME‚Äù, ‚ÄúDST ABBR‚Äù, ‚ÄúDST NAME‚Äù, ‚ÄúGMT offset‚Äù, ‚ÄúDST adjustment‚Äù, ‚ÄúDST Start Date rule‚Äù, ‚ÄúStart time‚Äù, ‚ÄúDST End date rule "," End time " </blockquote><br>  Where: <br>  <strong>ID</strong> ‚Äî Contains a string that uniquely identifies a given time zone. <br>  <strong>STD ABBR, STD NAME, DST ABBR, DST NAME</strong> - These fields are filled with strings with standard and summer time names and abbreviations, often names and abbreviations are identical. <br>  <strong>GMT offset</strong> - The offset in time, relative to Greenwich.  Its format is: <em>{+ | -} hh: mm [: ss]</em> <br>  <strong>DST adjustment</strong> - Offset relative to <strong>GMT offset</strong> during the ‚Äúsummer time‚Äù action.  The format is the same as <strong>GMT offset</strong> . <br>  <strong>DST Start Date rule</strong> - A string describing the day of the year that heralds the start of the ‚Äúsummer time‚Äù period.  It also has its own format (how many different formats are possible?): <blockquote>  <strong>weekday; day-of-week; month</strong> <br>  Where: <br>  <strong>weekday</strong> - Ordinal number, indicating what the day of the month counts, interests us. <br>  <strong>day-of-week</strong> is the day of the week. <br>  <strong>month</strong> - month. <br>  Example: <br><blockquote>  <strong>-1; 0; 3</strong> - The beginning of "summer time" in Russia (the last Sunday of March) </blockquote></blockquote><br>  <strong>Start time</strong> - The time after midnight when summer time comes into effect.  The format is the same as <strong>GMT offset</strong> . <br>  <strong>DST End date rule</strong> - A string describing the day in the year that heralds the end of the ‚Äúsummer time‚Äù period.  The format is identical to the <strong>DST Start Date rule</strong> . <br>  <strong>End time</strong> - Analogous to <strong>Start time</strong> , only for the end of ‚Äúsummer time‚Äù. <br>  Example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">tz_database xDb; <br> xDb.load_from_file( <font color="#A31515">"G:\\Program files\\boost\\boost_1_39_0\\\libs\\date_time\\data\\date_time_zonespec.csv"</font> ); <br> <font color="#0000ff">const</font> std::vector&lt;std:: <font color="#0000ff">string</font> &gt;&amp; xAllRegions = xDb.region_list(); <br> std::cout &lt;&lt; <font color="#A31515">"Print first 10 zone IDs from the boost time zone file:"</font> &lt;&lt; std::endl; <br> <font color="#0000ff">for</font> (std::vector&lt;std:: <font color="#0000ff">string</font> &gt;::const_iterator it = xAllRegions.begin(); it != xAllRegions.begin() + 10; ++it) <br> std::cout &lt;&lt; *it &lt;&lt; std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"And time when daylight saving was started at 2009: "</font> &lt;&lt; xDb.time_zone_from_region( <font color="#A31515">"Europe/Moscow"</font> )-&gt;dst_local_start_time(2009) &lt;&lt; std::endl; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Conclusion: <br><blockquote>  Print first 10 zone IDs from the boost time zone file: <br>  Africa / Abidjan <br>  Africa / Accra <br>  Africa / Addis_Ababa <br>  Africa / Algiers <br>  Africa / Asmera <br>  Africa / Bamako <br>  Africa / Bangui <br>  Africa / Banjul <br>  Africa / Bissau <br>  Africa / Blantyre <br>  Daylight saving was started at 2009: 2009-mar-29 02:00:00 </blockquote><br><br>  <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html"><strong>boost :: local_time :: custom_time_zone</strong></a> is a class for creating a description of the time zone, but unlike the previously described <strong>boost :: local_time :: posix_time_zone</strong> , this class uses four other classes when constructing a time zone.  These classes are: <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/posix_time.html">time_duration</a> , <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">time_zone_names</a> , <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">dst_adjustment_offsets</a> and <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html">dst_calc_rule</a> .  Since the class does not stand out outstanding, just give an example of its use: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">time_zone_names xNames( <font color="#A31515">"Moscow Standart Time"</font> , <font color="#A31515">"MST"</font> , <font color="#A31515">"Moscow Daylight Time"</font> , <font color="#A31515">"MDT"</font> ); <br> time_duration xGMTOffset(3, 0, 0); <br> dst_adjustment_offsets xRulesOffsets( time_duration(1,0,0), time_duration(2,0,0), time_duration(3,0,0) ); <br> <font color="#008000">//Mak daylight's rule</font> <br> last_day_of_the_week_in_month xStartRule(Sunday, Mar); <br> last_day_of_the_week_in_month xEndRule(Sunday, Oct); <br> <br> boost::shared_ptr&lt;dst_calc_rule&gt; xRules( <font color="#0000ff">new</font> last_last_dst_rule(xStartRule, xEndRule) ); <br> custom_time_zone xCustomTimeZone(xNames, xGMTOffset, xRulesOffsets, xRules); <br> <br> std::cout &lt;&lt; <font color="#A31515">"The our time zone name is: "</font> &lt;&lt; xCustomTimeZone.std_zone_name() &lt;&lt; <font color="#A31515">"\n"</font> <br> &lt;&lt; <font color="#A31515">"It has an "</font> &lt;&lt; xCustomTimeZone.base_utc_offset() &lt;&lt; <font color="#A31515">" offset from GMT.\n"</font> <br> &lt;&lt; <font color="#A31515">"And daylight period will end at "</font> &lt;&lt; xCustomTimeZone.dst_local_end_time(2009) &lt;&lt;std::endl; <br> std::cout &lt;&lt; <font color="#A31515">"Posix string which represents our custom_time_zone object is:\n"</font> &lt;&lt; xCustomTimeZone.to_posix_string(); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Conclusion: <br><blockquote>  Our time zone name is: Moscow Standart Time <br>  It has an 03:00:00 offset from GMT. <br>  And daylight period will end at 2009-Oct-25 03:00:00 <br>  Posix string which represents our custom_time_zone object is: <br>  MST + 03MDT + 01, M3.5.0 / 02: 00, M10.5.0 / 03: 00 </blockquote><br>  Classes <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html"><strong>boost :: local_time :: local_date_time</strong></a> and <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/local_time.html"><strong>boost :: local_time :: local_time_period</strong></a> repeat similar classes from <strong>boost :: posix_time</strong> , with reference to the time zone, so I will not consider them. <br><br><h1>  Useful features and conclusion </h1><br>  In Boost.Data_time, in addition to the classes for creating dates, there are useful utilities, such as: <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/date_time_io.html">formatted input / output processing</a> and <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/date_time/serialization.html">serialization</a> .  Both mechanisms are fairly simple to use and I consider their description redundant because the article, so it turned out to be quite voluminous. <br>  As a conclusion, I would like to thank all those who have mastered reading this point, and also wish good luck in using Boost.Date_time in their projects, I hope those who have not used it before will be encouraged to use this article (I was already encouraged :)). <br>  PS I spent almost a month on this article, I will hope that I will continue to write more often.  If you find a mistake in the article, please let me know in a personal, do not clutter up these comments. <br><br></div><p>Source: <a href="https://habr.com/ru/post/66318/">https://habr.com/ru/post/66318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../66309/index.html">Storing the code in the database or collect the code brick by brick</a></li>
<li><a href="../66310/index.html">Timbild SIMPALS: Rubilovo and Myasko)</a></li>
<li><a href="../66311/index.html">What materials about Java you are interested in in Russian?</a></li>
<li><a href="../66314/index.html">CARGADOR DE CELULAR - charge mobile phone with your left foot</a></li>
<li><a href="../66317/index.html">Amateur radio, hackers, amateurs and models of railways</a></li>
<li><a href="../66320/index.html">Manager and programmer</a></li>
<li><a href="../66321/index.html">Yandex.Certificates: My tests</a></li>
<li><a href="../66322/index.html">"How to avoid unnecessary problems" or "how I turned out to be a bastard"</a></li>
<li><a href="../66324/index.html">Star Wars rest - comments</a></li>
<li><a href="../66326/index.html">GOOZZY and Opera. And quite a lot about PR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>