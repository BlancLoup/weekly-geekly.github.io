<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Siemens SGold: I / O sniffer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sniffer is a special program for analyzing and intercepting network traffic and transmitting data through interfaces 
 and much more. In this case, we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Siemens SGold: I / O sniffer</h1><div class="post__text post__text-html js-mediator-article">  <b>Sniffer</b> is a special program for analyzing and intercepting network traffic and transmitting data through interfaces <br>  and much more.  In this case, we will monitor operations (read and write) with I / O ports. <br>  using the example of the <b>Siemens SGold</b> line phone and I will try to explain how it all works. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/941/3bb/1f9/9413bb1f9b177406a5720ed4f99e071f.png" alt="image"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Foreword </h2><br>  Many immediately have a question about the feasibility and usefulness of this venture, because these phones are outdated long ago. <br>  First, let's consider the phone as just some kind of device that has a microcontroller based on <b>ARM926EJ-S</b> (without documentation) and we want to make our firmware for our needs using the data obtained.  Secondly, scientific interest! <br><br><h2>  Theory </h2><br>  So, what do we have?  And we have a <b>PMB 8875 S-GoldLite microcontroller</b> based on an <s>Intel processor</s> , that is, <b>ARM9</b> .  And like any normal microcontroller, there are devices and ready interfaces inside it, such as <b>USART</b> , <b>SSC</b> , <b>I2C</b> , <b>PLL</b> , <b>RTC</b> , timers, sorry for the expression, <b>EBU</b> (External Bus Unit), and other terrible bourgeois abbreviations. <br><br><h5>  I / O ports </h5><br>  As noted earlier, there are some devices and interfaces.  And in the 4-gigabyte (32-bit) address space they are assigned their own ranges.  Yes, the address space of our microcontroller is physically divided into: <br><br>  <b>0x00000000-0x00003FFF</b> - SRAM # 1 <br>  <b>0x00080000-0x00097FFF</b> - SRAM # 2 <br>  <b>0x00400000-0x0040FFFF</b> - BootROM <br>  <b>0xF0000000-0xFFFFFFFF</b> - I / O ports, embedded device registers <br><br>  And external RAM and ROM can be inserted into a free physical address using the notorious <b>EBU</b> . <br><br>  So, for example, for the device <b>USART0, the</b> range <b>F1000000-F1000084 is allocated</b> . <br>  It looks in working condition something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e7/102/daa/2e7102daa11b592b965da3edd8120d38.png" alt="image"><br><br>  Each <b>WORD</b> (in <b>ARM</b> is 4 bytes) in this range is a register for controlling this interface. <br>  That is, by recording certain values ‚Äã‚Äãin certain registers, we transmit commands or data to the device, <br>  and reading them, we get the data and check the states. <br><br>  I forgot to say that the <b>USART0</b> (Universal Synchronous Asynchronous Receiver and Transmitter) is used as a transmitter and a receiver over the cable, roughly speaking, a <b>COM port</b> , but with low voltage. <br>  And let's take a closer look at the process of transferring 1 byte in the simplest case: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART_REG(a) * ( (unsigned int *) ( a ) ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_BASE 0xF1000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_CLC USART0_BASE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Clock Control Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_ID USART0_BASE + 0x08 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Module Identification Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_CON USART0_BASE + 0x10 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Control Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_BG USART0_BASE + 0x14 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Baudrate Timer Reload Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_FDV USART0_BASE + 0x18 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Fractional Divider Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_TXB USART0_BASE + 0x20 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Transmit Buffer */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_RXB USART0_BASE + 0x24 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Receive Buffer */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_FCSTAT USART0_BASE + 0x68 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Flowcontrol status register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USART0_ICR USART0_BASE + 0x70 void USART0_InitAndTransmit() { unsigned char tx = 0xDD; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   USART_REG(USART0_CLC) = 0x200; //      USART_REG(USART0_BG) = 0x05; USART_REG(USART0_FDV) = 0xDA; //    USART_REG(USART0_CON) = 0x8811; //     USART_REG(USART0_TXB) = tx &amp; 0xFF; //         while(!(USART_REG(USART0_FCSTAT) &amp; 2)); //    USART_REG(USART0_ICR) = (USART_REG(USART0_ICR)) | 0x02; }</span></span></span></span></code> </pre> <br>  Well, that is, in order to transmit something to the device, you need to write them to these damn registers, and read them from them, and we will use this for interception. <br><br><h5>  MMU and Redirection Table </h5><br>  <b>MMU</b> is a device in a microcontroller for managing memory and address space.  It may or may not be included, but it works for us and sets access modes to different memory areas, and the most interesting is that it can redirect or mirror addresses. <br><br>  I started talking about physical addresses and all that, but there are still virtual ones that can be created using the <b>MMU</b> . <br>  All 4-gigabyte address space is written in a small redirect table. <br><br>  <b>The redirection table</b> is a section of memory, usually in <b>SRAM</b> , which describes <b>4096 MB of</b> address space.  And each cell the size of a <b>WORD</b> describes <b>1 MB</b> .  Simple calculations can find out its size - <b>16 KB</b> .  There is also a second level of tables, but we will not climb into the jungle, it is not necessary.  So, the position of the cell from the beginning tells MMU about the physical address <br>  which must be translated into a virtual one, the value of which is written in it.  The cell also describes the attributes of this space in <b>1 MB</b> - cached, buffered, access modes.  If the cell is empty, that is, it is equal to <b>0x00000000</b> (or at least the bits responsible for accessibility), then the address that it should describe does not exist, and the processor will not see it. <br><br>  For understanding, the example of such a table is: <br><table><tbody><tr><th>  Cell address </th><th>  Value </th><th>  Description </th></tr><tr><td>  0x0000 </td><td>  0x00000C12 </td><td>  Describes 0x00000000-0x000FFFFF / RW / Nekeshir.  Nebuf </td></tr><tr><td>  0x0004 </td><td>  0x00100C12 </td><td>  Describes 0x00100000-0x001FFFFF / RW / Nekeshir.  Nebuf </td></tr><tr><td>  0x0008 </td><td>  0x00200C12 </td><td>  Describes 0x00200000-0x002FFFFF / RW / Nekeshir.  Nebuf </td></tr><tr><td>  0x000C </td><td>  0x00300C12 </td><td>  Describes 0x00300000-0x003FFFFF / RW / Nekeshir.  Nebuf </td></tr><tr><td>  0x0010 </td><td>  0x00400C12 </td><td>  Describes 0x00400000-0x004FFFFF / RW / Nekeshir.  Nebuf </td></tr><tr><td>  ..... </td><td></td><td></td></tr><tr><td>  0x3840 </td><td>  0xF1000C12 </td><td>  Mirror with 0xF1000000-0xF10FFFFF at 0xE1000000-0xE10FFFFF </td></tr><tr><td>  ..... </td><td></td><td></td></tr><tr><td>  0x3C40 </td><td>  0xF1000C12 </td><td>  Describes 0xF1000000-0xF10FFFFF / RW / Nekeshir.  Nebuf </td></tr><tr><td>  ..... </td><td></td><td></td></tr><tr><td>  0xFFFC </td><td>  0x00000000 </td><td>  Addresses 0xFFF00000-0xFFFFFFFF processor does not see </td></tr></tbody></table><br>  And yes, we describe this table ourselves and wherever we want, in any part of <b>RAM</b> or <b>Flash</b> , and in order for the <b>MMU to</b> know about it, it is necessary to register the address in the <b>CP15</b> coprocessor <b>register</b> , but this is not important for us. <br><br><h5>  Interrupt vectors </h5><br>  Interruptions are iron (from devices), software (through special instructions <b>BKPT</b> and <b>SWI</b> ) and from errors (exceptions). <br>  As a result of an interrupt, the processor, oddly enough, interrupts the execution of instructions at the current address and goes to the so-called interrupt vector, that is, a specific address, depending on the type of interrupt.  And it usually contains an instruction for switching to the handler for this interrupt / exception. <br>  Consider these vectors: <br><table><tbody><tr><th>  Bottom address </th><th>  Top address </th><th>  Vector </th><th>  Description </th></tr><tr><td>  0x00000000 </td><td>  0xFFFF0000 </td><td>  Reset </td><td>  Reset </td></tr><tr><td>  0x00000004 </td><td>  0xFFFF0004 </td><td>  Undefined_Instruction </td><td>  Unknown instruction </td></tr><tr><td>  0x00000008 </td><td>  0xFFFF0008 </td><td>  Swi </td><td>  Software interrupt </td></tr><tr><td>  0x0000000C </td><td>  0xFFFF000C </td><td>  Prefetch_Abort </td><td>  Command Read Failure </td></tr><tr><td>  0x00000010 </td><td>  0xFFFF0010 </td><td>  Data_Abort </td><td>  Denied access to data </td></tr><tr><td>  0x00000014 </td><td>  0xFFFF0014 </td><td>  RESERVED </td><td>  Reserved </td></tr><tr><td>  0x00000018 </td><td>  0xFFFF0018 </td><td>  IRQ </td><td>  Iron interrupt </td></tr><tr><td>  0x0000001C </td><td>  0xFFFF001C </td><td>  FIQ </td><td>  Iron interrupt </td></tr></tbody></table><br>  In <b>Siemens SGold,</b> they look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/823/2d8/99e/8232d899eb20302f7c6d9cc331cfc323.png" alt="image"><br><br>  But we are only interested in one <b>Data Abort</b> vector.  This interrupt occurs when the processor tries to commit <br>  read / write operation from a nonexistent address or an address that is currently not accessible. <br>  The <b>Siemens SGold firmware</b> uses this vector simply as registering an error and shutting down the device with a characteristic sound. <br>  That is, a handler whose pointer is located at <b>0x00000030</b> can be safely replaced with its own. <br><br><h5>  Mechanism for tracking read / write operations </h5><br>  Now that we are up to date, we can also consider how this thing works. <br>  Let us look at the first picture in the article, I will not be afraid of this word, a flowchart. <br>  Take a look at the ARM code of the assembler (do not look for meaning or completeness in it): <br><br><pre> <code class="cpp hljs">LDR R1, =<span class="hljs-number"><span class="hljs-number">0xF4700000</span></span> ;    R1  <span class="hljs-number"><span class="hljs-number">0xF4700000</span></span> LDR R2, [R1, #<span class="hljs-number"><span class="hljs-number">0x14</span></span>] ;    R2     R1 + <span class="hljs-number"><span class="hljs-number">0x14</span></span> (    <span class="hljs-number"><span class="hljs-number">0xF4700014</span></span>) BIC R2, R2, #<span class="hljs-number"><span class="hljs-number">1</span></span> ;  <span class="hljs-number"><span class="hljs-number">0</span></span>-    R2 STR R2, [R1, #<span class="hljs-number"><span class="hljs-number">0x14</span></span>] ;    R2     R1 + <span class="hljs-number"><span class="hljs-number">0x14</span></span> (    <span class="hljs-number"><span class="hljs-number">0xF4700014</span></span>) MOV R2, #<span class="hljs-number"><span class="hljs-number">2</span></span> ;    R2  <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  The most interesting begins on the instructions: <br><br><pre> <code class="cpp hljs">LDR R2, [R1, #<span class="hljs-number"><span class="hljs-number">0x14</span></span>] ;    R2     R1 + <span class="hljs-number"><span class="hljs-number">0x14</span></span> (    <span class="hljs-number"><span class="hljs-number">0xF4700014</span></span>)</code> </pre><br>  Here, the processor first asks the <b>MMU</b> : ‚Äú <b>Is the</b> address <b>0xF4700014</b> there and is there access to it?‚Äù <br>  <b>The MMU</b> says that yes and the processor reads the content from the address and continues to work. <br><br>  We replace the <b>Data Abort</b> exception handler with our own, for this it is enough to change the pointer to the address <b>0x00000030</b> . <br>  Mirror the address space <b>0xF4700000-0xF47FFFFF</b> to 0xE4700000-0xE47FFFFF through the forwarding table, <br>  and we erase the original address there.  It turns out that <b>0xF4700014</b> - does not exist, that is, the processor does not see it, but there is <br>  <b>0xE4700014</b> - translated (mirrored) from the physical address <b>0xF4700014</b> . <br><br>  We repeat the code, the processor stumbles upon that very instruction, asks about the existence of the address and here you are, hello, no! <br>  Panic.  In such cases, the processor jumps to the interrupt vector and gets to where?  That's right, in our handler.  We carefully preserve the context of the interrupted program so that nothing is lost and not stuck. <br>  Next, there is an emulation of this instruction, but taking into account that there is no address and you should take <b>0xE4700014 instead</b> . <br>  There is an emulation: determining the location of the instruction, analyzing what it should do, actually doing all this, applying to the context (remember which one we saved), recording all the transaction data (instruction address, register address, value and type of operation) where somehow, calmly restore it and direct the processor to the next instruction. <br><br>  If the firmware will perform operations with addresses <b>0xF4700000-0xF47FFFFF</b> , then it will inevitably fall on the handler, and he, in turn, regularly keep a log of these operations.  Beauty is the same!  True, instead of one instruction, you need to execute a huge handler, but it has little effect on performance and performance. <br><br><h2>  Implementation mechanism </h2><br>  I think that the implementation of all this is highly dependent on the platform and this code will not give anyone anything, <br>  but it will still be strange without it.  Everything was developed in IAR 4.2. <br><br><div class="spoiler">  <b class="spoiler_title">arm_defs.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ARM_DEFS_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __ARM_DEFS_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WORD(a) * ( (unsigned int *) ( a ) ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HWRD(a) * ( (unsigned short *) ( a ) ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BYTE(a) * ( (unsigned char *) ( a ) ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INS_BIT(i,b) ( ( i &gt;&gt; b )&amp;1 ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> I32_FIELD(i,b,e) ( ( ( i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; ( 31 - b ) ) &gt;&gt; 31 - b ) &gt;&gt; ( e ) ) #define I32_FIELD_FAST(i,e,m) ( ( i &gt;&gt; e ) &amp; m ) #define IARM_COND(i) ( ( i &gt;&gt; 28 )&amp;0xF ) #define IARM_Rn(i) ( ( i &gt;&gt; 16 )&amp;0xF ) #define IARM_Rd(i) ( ( i &gt;&gt; 12 )&amp;0xF ) #define IARM_Rs(i) ( ( i &gt;&gt; 8 )&amp;0xF ) #define IARM_Rm(i) ( ( i &gt;&gt; 0 )&amp;0xF ) #define IARM_ImmHi(i) ( ( i &gt;&gt; 16 )&amp;0xF ) #define IARM_ImmLo(i) ( ( i &gt;&gt; 0 )&amp;0xF ) #define IARM_Imm12(i) ( ( i &gt;&gt; 0 )&amp;0xFFF ) #define IARM_ShiftImm(i) I32_FIELD_FAST(i,7,0x1F) #define IARM_Shift(i) I32_FIELD_FAST(i,5,3) #define IARM_Shift_LSL 0 #define IARM_Shift_LSR 1 #define PC_ALIGN(pc) (pc &amp; 0xFFFFFFFE) #define MAX_REGS 17 #define _R0 0 #define _R1 1 #define _R2 2 #define _R3 3 #define _R4 4 #define _R5 5 #define _R6 6 #define _R7 7 #define _R8 8 #define _R9 9 #define _R10 10 #define _R11 11 #define _R12 12 #define _SP 13 #define _LR 14 #define _PC 15 #define _CPSR 16 #define GET_PSR_N(cpsr) ((cpsr &gt;&gt; 31)&amp;1) #define GET_PSR_Z(cpsr) ((cpsr &gt;&gt; 30)&amp;1) #define GET_PSR_C(cpsr) ((cpsr &gt;&gt; 29)&amp;1) #define GET_PSR_V(cpsr) ((cpsr &gt;&gt; 28)&amp;1) #define GET_PSR_Q(cpsr) ((cpsr &gt;&gt; 27)&amp;1) #define GET_PSR_I(cpsr) ((cpsr &gt;&gt; 7)&amp;1) #define GET_PSR_F(cpsr) ((cpsr &gt;&gt; 6)&amp;1) #define GET_PSR_T(cpsr) ((cpsr &gt;&gt; 5)&amp;1) #define GET_PSR_M(cpsr) ((cpsr)&amp;0x1F) #define SET_PSR_T(cpsr, i) (cpsr |= ( i &lt;&lt; 5)) #define MUSR 0x10 // User Mode #define MFIQ 0x11 // FIQ Mode #define MIRQ 0x12 // IRQ Mode #define MSVC 0x13 // Supervisor Mode #define MABT 0x17 // Abort Mode #define MUND 0x1B // Undefined Mode #define MSYS 0x1F // System Mode #define MMSK 0x1F // Mask Mode #define CEQ 0 // : Z == 1 #define CNE 1 //  : Z == 0 #define CCS 2 // : C == 1 #define CHS 2 //    : C == 1 #define CCC 3 //  : C == 0 #define CLO 3 //  : C == 0 #define CMI 4 // /: N == 1 #define CPL 5 // /  : N == 0 #define CVS 6 // : V == 1 #define CVC 7 //  : V == 0 #define CHI 8 //  : C == 1 &amp;&amp; Z == 0 #define CLS 9 //    : C == 0 &amp;&amp; Z == 1 #define CGE 10 //   ,  : N == V #define CLT 11 //  ,  : N != V #define CGT 12 //  ,  : Z == 0 &amp;&amp; N == V #define CLE 13 //   ,  : Z == 1 &amp;&amp; N != V #define CAL 14 //   #define CMSK 15 //   // LDR / STR #define IARM_IS_LDR(i) \ ( I32_FIELD_FAST(i,26,3)==1 &amp;&amp; INS_BIT(i,22)==0 &amp;&amp; INS_BIT(i,20)==1 ) #define IARM_IS_STR(i) \ ( I32_FIELD_FAST(i,26,3)==1 &amp;&amp; INS_BIT(i,22)==0 &amp;&amp; INS_BIT(i,20)==0 ) #define IARM_LDR_I(i) INS_BIT(i,25) #define IARM_LDR_P(i) INS_BIT(i,24) #define IARM_LDR_U(i) INS_BIT(i,23) #define IARM_LDR_W(i) INS_BIT(i,21) // if Load and Store word or unsigned byte instructions #define IARM_IS_LDRHS(i) ( (i &gt;&gt; 25)&amp;7 == 0 &amp;&amp; (i &gt;&gt; 7)&amp;1 == 1 &amp;&amp; (i &gt;&gt; 4)&amp;1 == 1 ) #define IARM_LDRHS_P(i) INS_BIT(i,24) #define IARM_LDRHS_U(i) INS_BIT(i,23) #define IARM_LDRHS_I(i) INS_BIT(i,22) #define IARM_LDRHS_W(i) INS_BIT(i,21) #define IARM_LDRHS_L(i) INS_BIT(i,20) #define IARM_LDRHS_S(i) INS_BIT(i, 6) #define IARM_LDRHS_H(i) INS_BIT(i, 5) /* THUMBs command detector Load / Store */ // PC-relative load #define ITHUMB_LS_PCREL(i) (((i &gt;&gt; 11) &amp; 0x1F) == 0x09) #define ITHUMB_LS_PCREL_Rd(i) ((i &gt;&gt; 8) &amp; 0x07) #define ITHUMB_LS_PCREL_Offset(i) (i &amp; 0xF) // load/store with register offset #define ITHUMB_LS_WITHREGOFFSET(i) (((i &gt;&gt; 9) &amp;(~0x06)) == 0x28) #define ITHUMB_LS_WITHREGOFFSET_Ro(i) ((i &gt;&gt; 6) &amp; 0x07) #define ITHUMB_LS_WITHREGOFFSET_Rb(i) ((i &gt;&gt; 3) &amp; 0x07) #define ITHUMB_LS_WITHREGOFFSET_Rd(i) ((i &gt;&gt; 0) &amp; 0x07) #define ITHUMB_LS_WITHREGOFFSET_L(i) ((i &gt;&gt; 11) &amp; 0x01) #define ITHUMB_LS_WITHREGOFFSET_B(i) ((i &gt;&gt; 10) &amp; 0x01) // load/store sign-extended byte/halfword #define ITHUMB_LS_SIGNEXTBYTEHWRD(i) (((i &gt;&gt; 9) &amp;(~0x06)) == 0x29) #define ITHUMB_LS_SIGNEXTBYTEHWRD_Ro(i) ((i &gt;&gt; 6) &amp; 0x07) #define ITHUMB_LS_SIGNEXTBYTEHWRD_Rb(i) ((i &gt;&gt; 3) &amp; 0x07) #define ITHUMB_LS_SIGNEXTBYTEHWRD_Rd(i) ((i &gt;&gt; 0) &amp; 0x07) #define ITHUMB_LS_SIGNEXTBYTEHWRD_H(i) ((i &gt;&gt; 11) &amp; 0x01) #define ITHUMB_LS_SIGNEXTBYTEHWRD_S(i) ((i &gt;&gt; 10) &amp; 0x01) // load/store with immediate offset #define ITHUMB_LS_WITHIMMOFFSET(i) (((i &gt;&gt; 11) &amp;(~0x03)) == 0x0C) #define ITHUMB_LS_WITHIMMOFFSET_L(i) ((i &gt;&gt; 11) &amp; 0x01) #define ITHUMB_LS_WITHIMMOFFSET_B(i) ((i &gt;&gt; 12) &amp; 0x01) #define ITHUMB_LS_WITHIMMOFFSET_Rb(i) ((i &gt;&gt; 3) &amp; 0x07) #define ITHUMB_LS_WITHIMMOFFSET_Rd(i) ((i &gt;&gt; 0) &amp; 0x07) #define ITHUMB_LS_WITHIMMOFFSET_Offset(i) ((i &gt;&gt; 6) &amp; 0x1F) // load/store halfword #define ITHUMB_LS_HWRD(i) (((i &gt;&gt; 11) &amp; (~0x01)) == 0x10) #define ITHUMB_LS_HWRD_L(i) ((i &gt;&gt; 11) &amp; 0x01) #define ITHUMB_LS_HWRD_Rb(i) ((i &gt;&gt; 3) &amp; 0x07) #define ITHUMB_LS_HWRD_Rd(i) ((i &gt;&gt; 0) &amp; 0x07) #define ITHUMB_LS_HWRD_Offset(i) ((i &gt;&gt; 6) &amp; 0x1F) // SP-relative load/store #define ITHUMB_LS_SPREL(i) (((i &gt;&gt; 12) &amp; 0x0F) == 0x09) #define ITHUMB_LS_SPREL_L(i) ((i &gt;&gt; 11) &amp; 0x01) #define ITHUMB_LS_SPREL_Rd(i) ((i &gt;&gt; 8) &amp; 0x07) #define ITHUMB_LS_SPREL_Offset(i) (i &amp; 0xF) #endif // __ARM_DEFS_H__</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">sniffer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __SNIFFER_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __SNIFFER_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"arm_defs.h"</span></span></span><span class="hljs-meta"> extern void da_handler(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IO_ADDRESS 0xF0000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IO_ADDRESS_MIRROR 0xE0000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IO_ADDRESS_DIF 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VECTOR_DATAABORT_JUMPER 0xE59FF018 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VECTOR_DATAABORT_JUMPER_OFS 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VECTOR_DATAABORT_HANDLER_OFS 0x30 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_ATTR 0xC12 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_TABLE 0x00090000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_GRID(a) * ( (unsigned int *) ( (MMU_TABLE + ((a &gt;&gt; 20) &amp; 0xFFF) * 4) ) ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_GRID_MIRROR(a) MMU_GRID(a - IO_ADDRESS_DIF) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MMU_GRID_SETATTR(a) ((a &amp; 0xFFF00000) | MMU_ATTR) typedef struct { unsigned int r0; unsigned int r1; unsigned int r2; unsigned int r3; unsigned int r4; unsigned int r5; unsigned int r6; unsigned int r7; unsigned int r8; unsigned int r9; unsigned int r10; unsigned int r11; unsigned int r12; unsigned int sp; unsigned int lr; unsigned int pc; unsigned int cpsr; }REGISTERS; typedef struct { union regs { unsigned int a[MAX_REGS]; REGISTERS s; }; }CONTEXT; void io_sniffer_init(void (*sniff_prc)(unsigned int address, unsigned int value, unsigned int pc, char is_ldr)); void io_sniffer_deinit(); int io_sniffer_add(unsigned int io_address); int io_sniffer_remove(unsigned int io_address); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __SNIFFER_H__</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">system.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __SYSTEM_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __SYSTEM_H__ __arm void SetDomainAccess(unsigned int domains); __arm void SetMemoryAccess(unsigned int domains); __arm void UnlockAllMemoryAccess(); __arm void DisableInterrupt(); __arm void EnableInterrupt(); __arm void EnableModeForOSWork(); __arm void DisableModeForOSWork(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __SYSTEM_H__</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">da_handler.asm</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"arm_defs.h"</span></span></span><span class="hljs-meta"> EXTERN context EXTERN abt_stack EXTERN emualate_ldr_str CODE32 ARM RSEG CODE:CODE PUBLIC da_handler da_handler: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   R0 - R12   LDR SP, =context STMIA SP, {R0-R12} //     LDR SP, =abt_stack ADD SP, SP, #0x4000 //  CPSR   MRS R1, SPSR LDR R0, =context STR R1, [R0, #_CPSR*4] //  PC   SUB LR, LR, #0x08 STR LR, [R0, #_PC*4] //      AND R2, R1, #MMSK CMP R2, #MUSR //   USR,   SYS MOVEQ R2, #MSYS //     MRS R1, CPSR BIC R1, R1, #MMSK ORR R1, R1, R2 MSR CPSR_c, R1 //  SP  LR   STR SP, [R0, #_SP*4] STR LR, [R0, #_LR*4] //   , //     ABT BIC R1, R1, #MMSK ORR R1, R1, #MABT MSR CPSR_c, R1 BL emualate_ldr_str //  CPSR   LDR R0, =context LDR R1, [R0, #_CPSR*4] MSR SPSR_cxsf, R1 //      AND R2, R1, #MMSK CMP R2, #MUSR //   USR,   SYS MOVEQ R2, #MSYS //     MRS R1, CPSR BIC R1, R1, #MMSK ORR R1, R1, R2 MSR CPSR_c, R1 //  SP  LR   LDR SP, [R0, #_SP*4] LDR LR, [R0, #_LR*4] //    ABT BIC R1, R1, #MMSK ORR R1, R1, #MABT MSR CPSR_c, R1 //  PC LDR SP, =context LDR LR, [SP, #_PC*4] //   R0-R12 LDMIA SP, {R0-R12} //     //    MOVS PC, LR END</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">sniffer.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sniffer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"system.h"</span></span></span><span class="hljs-meta"> CONTEXT context; unsigned char abt_stack[0x4000]; unsigned char sniffer_map[0x100]; unsigned int da_jumper = 0; unsigned int da_address = 0; void (*sniff_p)(unsigned int address, unsigned int value, unsigned int pc, char is_ldr) = 0; __arm void sniff_proc(unsigned int address, unsigned int value, unsigned int pc, char is_ldr) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sniff_p) sniff_p(address, value, pc, is_ldr); } __arm int emualate_ldr_str_sub(CONTEXT *context) { unsigned int cpsr; unsigned int instruction; unsigned int address; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//unsigned char cond; char i, l, b, h, w, s, u, p; char rn, rd, rm; cpsr = context-&gt;s.cpsr; // ARM if (!GET_PSR_T(cpsr)) { //   instruction = WORD(context-&gt;s.pc); //   //cond = IARM_COND(instruction); //  (LDR) if (IARM_IS_LDR(instruction)) { p = IARM_LDR_P(instruction); i = IARM_LDR_I(instruction); u = IARM_LDR_U(instruction); w = IARM_LDR_W(instruction); rn = IARM_Rn(instruction); rd = IARM_Rd(instruction); rm = IARM_Rm(instruction); int sign; unsigned int index; //       if (!i) index = IARM_Imm12(instruction); //        else { //    if (!IARM_ShiftImm(instruction) &amp;&amp; !IARM_Shift(instruction)) index = context-&gt;a[rm]; //      else { //    unsigned short si = IARM_ShiftImm(instruction); //   unsigned short st = IARM_Shift(instruction); switch(st) { case IARM_Shift_LSL: index = context-&gt;a[rm] &lt;&lt; si; break; case IARM_Shift_LSR: if (si) { index = 0; break; } else { index = context-&gt;a[rm] &gt;&gt; si; break; } } } } //    if (u) sign = 1; //    else sign = -1; //  - if (!p) { address = context-&gt;a[rn]; context-&gt;a[rn] = address + index*sign; context-&gt;a[rd] = WORD(address - IO_ADDRESS_DIF); //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 1); } else { //  - if (w) { address = context-&gt;a[rn] + index*sign; context-&gt;a[rn] = address; context-&gt;a[rd] = WORD(address - IO_ADDRESS_DIF); //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 1); } //   /- else { address = context-&gt;a[rn] + index*sign; context-&gt;a[rd] = WORD(address - IO_ADDRESS_DIF); //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 1); } } } //  (STR) else if (IARM_IS_STR(instruction)) { p = IARM_LDR_P(instruction); i = IARM_LDR_I(instruction); u = IARM_LDR_U(instruction); w = IARM_LDR_W(instruction); rn = IARM_Rn(instruction); rd = IARM_Rd(instruction); rm = IARM_Rm(instruction); int sign; unsigned int index; //       if (!i) index = IARM_Imm12(instruction); //        else { //    if (!IARM_ShiftImm(instruction) &amp;&amp; !IARM_Shift(instruction)) index = context-&gt;a[rm]; //      else { //    unsigned short si = IARM_ShiftImm(instruction); //   unsigned short st = IARM_Shift(instruction); switch(st) { case IARM_Shift_LSL: index = context-&gt;a[rm] &lt;&lt; si; break; case IARM_Shift_LSR: if (si) { index = 0; break; } else { index = context-&gt;a[rm] &gt;&gt; si; break; } } } } //    if (u) sign = 1; //    else sign = -1; //  - if (!p) { address = context-&gt;a[rn]; context-&gt;a[rn] = address + index*sign; WORD(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 0); } else { //  - if (w) { address = context-&gt;a[rn] + index*sign; context-&gt;a[rn] = address; WORD(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 0); } //   /- else { address = context-&gt;a[rn] + index*sign;; WORD(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 0); } } } context-&gt;s.pc += 4; return 1; } else // THUMB { //   instruction = HWRD(context-&gt;s.pc); if (ITHUMB_LS_WITHREGOFFSET(instruction)) { rd = ITHUMB_LS_WITHREGOFFSET_Rd(instruction); l = ITHUMB_LS_WITHREGOFFSET_L(instruction); b = ITHUMB_LS_WITHREGOFFSET_B(instruction); //  if (l) { //   if (b) context-&gt;a[rd] = BYTE(address - IO_ADDRESS_DIF); else //   context-&gt;a[rd] = WORD(address - IO_ADDRESS_DIF); //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 1); } //  else { //   if (b) BYTE(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; else //   WORD(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 0); } } else if (ITHUMB_LS_SIGNEXTBYTEHWRD(instruction)) { address = context-&gt;a[ITHUMB_LS_SIGNEXTBYTEHWRD_Rb(instruction)] + context-&gt;a[ITHUMB_LS_SIGNEXTBYTEHWRD_Ro(instruction)]; rd = ITHUMB_LS_SIGNEXTBYTEHWRD_Rd(instruction); h = ITHUMB_LS_SIGNEXTBYTEHWRD_H(instruction); s = ITHUMB_LS_SIGNEXTBYTEHWRD_S(instruction); //   if (!h &amp;&amp; !s) { HWRD(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 0); //  } else if (h &amp;&amp; !s) { context-&gt;a[rd] = HWRD(address - IO_ADDRESS_DIF); //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 1); //      } else if (!h &amp;&amp; s) { context-&gt;a[rd] = BYTE(address - IO_ADDRESS_DIF); if (INS_BIT(context-&gt;a[rd], 7)) context-&gt;a[rd] |= 0xFFFFFF00; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 1); //      } else if (h &amp;&amp; s) { context-&gt;a[rd] = HWRD(address - IO_ADDRESS_DIF); if (INS_BIT(context-&gt;a[rd], 15)) context-&gt;a[rd] |= 0xFFFF0000; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 1); } } else if (ITHUMB_LS_WITHIMMOFFSET(instruction)) { rd = ITHUMB_LS_WITHIMMOFFSET_Rd(instruction); l = ITHUMB_LS_WITHIMMOFFSET_L(instruction); b = ITHUMB_LS_WITHIMMOFFSET_B(instruction); if (b) address = context-&gt;a[ITHUMB_LS_WITHIMMOFFSET_Rb(instruction)] + ITHUMB_LS_WITHIMMOFFSET_Offset(instruction); else address = context-&gt;a[ITHUMB_LS_WITHIMMOFFSET_Rb(instruction)] + (ITHUMB_LS_WITHIMMOFFSET_Offset(instruction) &lt;&lt; 2); //  if (l) { //   if (b) context-&gt;a[rd] = BYTE(address - IO_ADDRESS_DIF); else //   context-&gt;a[rd] = WORD(address - IO_ADDRESS_DIF); //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 1); } //  else { //   if (b) BYTE(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; else //   WORD(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, 0); } } else if (ITHUMB_LS_HWRD(instruction)) { rd = ITHUMB_LS_HWRD_Rd(instruction); l = ITHUMB_LS_HWRD_L(instruction); address = context-&gt;a[ITHUMB_LS_HWRD_Rb(instruction)] + (ITHUMB_LS_HWRD_Offset(instruction) &lt;&lt; 1); //  if (l) context-&gt;a[rd] = HWRD(address - IO_ADDRESS_DIF); //  else HWRD(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, l); } else if (ITHUMB_LS_SPREL(instruction)) { address = context-&gt;s.sp + (ITHUMB_LS_SPREL_Offset(instruction) &lt;&lt; 2); rd = ITHUMB_LS_SPREL_Rd(instruction); l = ITHUMB_LS_SPREL_L(instruction); //  if (l) context-&gt;a[rd] = WORD(address - IO_ADDRESS_DIF); else //  WORD(address - IO_ADDRESS_DIF) = context-&gt;a[rd]; //     sniff_proc(address, context-&gt;a[rd], context-&gt;s.pc, l); } context-&gt;s.pc += 2; return 1; } } __arm void emualate_ldr_str(CONTEXT *context) { SetDomainAccess(0xFFFFFFFF); emualate_ldr_str_sub(context); SetDomainAccess(1); } void io_sniffer_init(void (*sniff_prc)(unsigned int address, unsigned int value, unsigned int pc, char is_ldr)) { if (sniff_prc) { UnlockAllMemoryAccess(); da_jumper = WORD(VECTOR_DATAABORT_JUMPER_OFS); da_address = WORD(VECTOR_DATAABORT_HANDLER_OFS); WORD(VECTOR_DATAABORT_JUMPER_OFS) = VECTOR_DATAABORT_JUMPER; WORD(VECTOR_DATAABORT_HANDLER_OFS) = (int)&amp;da_handler; SetMemoryAccess(1); sniff_p = sniff_prc; for (int i = 0; i &lt; 0x100; i++) sniffer_map[i] = 0; } } void io_sniffer_deinit() { UnlockAllMemoryAccess(); da_jumper = WORD(VECTOR_DATAABORT_JUMPER_OFS); da_address = WORD(VECTOR_DATAABORT_HANDLER_OFS); WORD(VECTOR_DATAABORT_JUMPER_OFS) = (unsigned int)&amp;da_jumper; WORD(VECTOR_DATAABORT_HANDLER_OFS) = (unsigned int)&amp;da_address; for (int i = 0; i &lt; 0x100; i++) { if (sniffer_map[i]) { unsigned int io_address = IO_ADDRESS | (i &lt;&lt; 20) | MMU_ATTR; MMU_GRID(io_address) = MMU_GRID_SETATTR(io_address); MMU_GRID_MIRROR(io_address) = 0x00000000; } sniffer_map[i] = 0; } SetMemoryAccess(1); sniff_p = 0; } int io_sniffer_add(unsigned int io_address) { if ((io_address &gt;&gt; 28) == 0x0F) { unsigned char sm = (io_address &gt;&gt; 20) &amp; 0x0FF; if (!sniffer_map[sm]) { UnlockAllMemoryAccess(); MMU_GRID(io_address) = 0x00000000; MMU_GRID_MIRROR(io_address) = MMU_GRID_SETATTR(io_address); SetMemoryAccess(1); sniffer_map[sm] = 1; return 1; } } return 0; } int io_sniffer_remove(unsigned int io_address) { if ((io_address &gt;&gt; 28) == 0x0F) { unsigned char sm = (io_address &gt;&gt; 20) &amp; 0x0FF; if (sniffer_map[sm]) { UnlockAllMemoryAccess(); MMU_GRID(io_address) = MMU_GRID_SETATTR(io_address); MMU_GRID_MIRROR(io_address) = 0x00000000; SetMemoryAccess(1); sniffer_map[sm] = 0; return 1; } } return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">system.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"system.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"intrinsics.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> swi_number=0x00 __swi __arm void system_mode_sg(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> swi_number=0x04 __swi __arm void system_mode_nsg(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> swi_number=0x81B5 __swi __arm int is_nsg(); __arm void SetDomainAccess(unsigned int domains) { __MCR(15, 0, domains, 3, 0, 0); for (int i = 0; i &lt; 20; i++); } __arm void SetMemoryAccess(unsigned int domains) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (is_nsg()) system_mode_nsg(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> system_mode_sg(); __disable_interrupt(); SetDomainAccess(domains); __enable_interrupt(); } __arm void UnlockAllMemoryAccess() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (is_nsg()) system_mode_nsg(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> system_mode_sg(); __disable_interrupt(); SetDomainAccess(0xFFFFFFFF); __enable_interrupt(); } __arm void DisableInterrupt() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (is_nsg()) system_mode_nsg(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> system_mode_sg(); __disable_interrupt(); } __arm void EnableInterrupt() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (is_nsg()) system_mode_nsg(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> system_mode_sg(); __enable_interrupt(); } unsigned long cpsr = 0; __arm void EnableModeForOSWork() { cpsr = __get_CPSR(); cpsr &amp;= 0xC0; cpsr |= 0x1F; __set_CPSR(cpsr); } __arm void DisableModeForOSWork() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (cpsr) __set_CPSR(cpsr); cpsr = 0; }</span></span></code> </pre><br></div></div><br><h2>  Result </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, I‚Äôll tell you what it was that was finally achieved using this sniffer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The executable file </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">io_sniffer.elf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is downloaded to the </font><b><font style="vertical-align: inherit;">phone</font></b><font style="vertical-align: inherit;"> , it starts. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configure the sniffer so that it catches operations with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2C interface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xF4800000</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the handler, there is a special </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">task</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (thread, stream), which in real time transfers everything to the computer via cable, and there is a program that receives data and displays it in a window. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you click on the phone button, then its speaker will click (included in the phone settings), this is caused by the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dialog</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> device </font><font style="vertical-align: inherit;">, which is exchanged via the </font><b><font style="vertical-align: inherit;">I2C</font></b><font style="vertical-align: inherit;"> bus</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a microcontroller. </font><font style="vertical-align: inherit;">And in theory, we should see that the firmware does this, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that this device synthesizes sound like this:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2C: key click</font></font></b> <div class="spoiler_text"><pre> <code class="bash hljs">0xA07EE064|I2C |CLC |0xF4800000||0x00000100| 0xA07EE06C|I2C |BUSCON |0xF4800014||0xA0007E11| 0xA07EE070|I2C |SYSCON |0xF4800010||0x00880000| 0xA07EE07C|I2C |SYSCON |0xF4800010||0x00880000| 0xA089550C|I2C |ICR |0xF48000FC||0x00000000| 0xA0895514|I2C |ICR |0xF48000FC||0x00004000| 0xA0895518|I2C |ICR |0xF48000FC||0x00000000| 0xA0895520|I2C |ICR |0xF48000FC||0x00001000| 0xA0895868|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895878|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895888|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895938|I2C |RTB |0xF4800018||0x00001262| 0xA0895940|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895950|I2C |SYSCON |0xF4800010||0x04880000| 0xA0895964|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA0895970|I2C |WHBSYSCON|0xF4800020||0x00100000| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895388|I2C |SYSCON |0xF4800010||0x04980230| 0xA089539C|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895420|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895438|I2C |SYSCON |0xF4800010||0x00980230| 0xA0895444|I2C |RTB |0xF4800018||0x00000010| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895388|I2C |SYSCON |0xF4800010||0x00980130| 0xA089539C|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895590|I2C |SYSCON |0xF4800010||0x00980130| 0xA08955A8|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955B4|I2C |WHBSYSCON|0xF4800020||0x00080000| 0xA08955BC|I2C |SYSCON |0xF4800010||0x008800A0| 0xA08955DC|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955E8|I2C |WHBSYSCON|0xF4800020||0x00000080| 0xA08955F0|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955FC|I2C |WHBSYSCON|0xF4800020||0x00000020| 0xA0895530|I2C |ICR |0xF48000FC||0x00004000| 0xA07EDF94|I2C |BUSCON |0xF4800014||0x00000000| 0xA07EDF9C|I2C |CLC |0xF4800000||0x00000001| 0xA07EE064|I2C |CLC |0xF4800000||0x00000100| 0xA07EE06C|I2C |BUSCON |0xF4800014||0xA0007E11| 0xA07EE070|I2C |SYSCON |0xF4800010||0x00880000| 0xA07EE07C|I2C |SYSCON |0xF4800010||0x00880000| 0xA089550C|I2C |ICR |0xF48000FC||0x00000000| 0xA0895514|I2C |ICR |0xF48000FC||0x00004000| 0xA0895518|I2C |ICR |0xF48000FC||0x00000000| 0xA0895520|I2C |ICR |0xF48000FC||0x00001000| 0xA0895868|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895878|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895888|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895938|I2C |RTB |0xF4800018||0x00001362| 0xA0895940|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895950|I2C |SYSCON |0xF4800010||0x04880000| 0xA0895964|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA0895970|I2C |WHBSYSCON|0xF4800020||0x00100000| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895388|I2C |SYSCON |0xF4800010||0x04980230| 0xA089539C|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895420|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895438|I2C |SYSCON |0xF4800010||0x00980230| 0xA0895444|I2C |RTB |0xF4800018||0x00000010| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895388|I2C |SYSCON |0xF4800010||0x00980130| 0xA089539C|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895590|I2C |SYSCON |0xF4800010||0x00980130| 0xA08955A8|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955B4|I2C |WHBSYSCON|0xF4800020||0x00080000| 0xA08955BC|I2C |SYSCON |0xF4800010||0x008800A0| 0xA08955DC|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955E8|I2C |WHBSYSCON|0xF4800020||0x00000080| 0xA08955F0|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955FC|I2C |WHBSYSCON|0xF4800020||0x00000020| 0xA0895530|I2C |ICR |0xF48000FC||0x00004000| 0xA07EDF94|I2C |BUSCON |0xF4800014||0x00000000| 0xA07EDF9C|I2C |CLC |0xF4800000||0x00000001| 0xA07EE064|I2C |CLC |0xF4800000||0x00000100| 0xA07EE06C|I2C |BUSCON |0xF4800014||0xA0007E11| 0xA07EE070|I2C |SYSCON |0xF4800010||0x00880000| 0xA07EE07C|I2C |SYSCON |0xF4800010||0x00880000| 0xA089550C|I2C |ICR |0xF48000FC||0x00000000| 0xA0895514|I2C |ICR |0xF48000FC||0x00004000| 0xA0895518|I2C |ICR |0xF48000FC||0x00000000| 0xA0895520|I2C |ICR |0xF48000FC||0x00001000| 0xA0895868|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895878|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895888|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895938|I2C |RTB |0xF4800018||0x00004462| 0xA0895940|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895950|I2C |SYSCON |0xF4800010||0x04880000| 0xA0895964|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA0895970|I2C |WHBSYSCON|0xF4800020||0x00100000| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895388|I2C |SYSCON |0xF4800010||0x04980230| 0xA089539C|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895420|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895438|I2C |SYSCON |0xF4800010||0x00980230| 0xA0895444|I2C |RTB |0xF4800018||0x00000062| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895388|I2C |SYSCON |0xF4800010||0x00980130| 0xA089539C|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895590|I2C |SYSCON |0xF4800010||0x00980130| 0xA08955A8|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955B4|I2C |WHBSYSCON|0xF4800020||0x00080000| 0xA08955BC|I2C |SYSCON |0xF4800010||0x008800A0| 0xA08955DC|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955E8|I2C |WHBSYSCON|0xF4800020||0x00000080| 0xA08955F0|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955FC|I2C |WHBSYSCON|0xF4800020||0x00000020| 0xA0895530|I2C |ICR |0xF48000FC||0x00004000| 0xA07EDF94|I2C |BUSCON |0xF4800014||0x00000000| 0xA07EDF9C|I2C |CLC |0xF4800000||0x00000001| 0xA07EE064|I2C |CLC |0xF4800000||0x00000100| 0xA07EE06C|I2C |BUSCON |0xF4800014||0xA0007E11| 0xA07EE070|I2C |SYSCON |0xF4800010||0x00880000| 0xA07EE07C|I2C |SYSCON |0xF4800010||0x00880000| 0xA089550C|I2C |ICR |0xF48000FC||0x00000000| 0xA0895514|I2C |ICR |0xF48000FC||0x00004000| 0xA0895518|I2C |ICR |0xF48000FC||0x00000000| 0xA0895520|I2C |ICR |0xF48000FC||0x00001000| 0xA0895868|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895878|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895888|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895938|I2C |RTB |0xF4800018||0x00004662| 0xA0895940|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895950|I2C |SYSCON |0xF4800010||0x04880000| 0xA0895964|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA0895970|I2C |WHBSYSCON|0xF4800020||0x00100000| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895388|I2C |SYSCON |0xF4800010||0x04980230| 0xA089539C|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895420|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895438|I2C |SYSCON |0xF4800010||0x00980230| 0xA0895444|I2C |RTB |0xF4800018||0x00000067| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895388|I2C |SYSCON |0xF4800010||0x00980130| 0xA089539C|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895590|I2C |SYSCON |0xF4800010||0x00980130| 0xA08955A8|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955B4|I2C |WHBSYSCON|0xF4800020||0x00080000| 0xA08955BC|I2C |SYSCON |0xF4800010||0x008800A0| 0xA08955DC|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955E8|I2C |WHBSYSCON|0xF4800020||0x00000080| 0xA08955F0|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955FC|I2C |WHBSYSCON|0xF4800020||0x00000020| 0xA0895530|I2C |ICR |0xF48000FC||0x00004000| 0xA07EDF94|I2C |BUSCON |0xF4800014||0x00000000| 0xA07EDF9C|I2C |CLC |0xF4800000||0x00000001| 0xA07EE064|I2C |CLC |0xF4800000||0x00000100| 0xA07EE06C|I2C |BUSCON |0xF4800014||0xA0007E11| 0xA07EE070|I2C |SYSCON |0xF4800010||0x00880000| 0xA07EE07C|I2C |SYSCON |0xF4800010||0x00880000| 0xA089550C|I2C |ICR |0xF48000FC||0x00000000| 0xA0895514|I2C |ICR |0xF48000FC||0x00004000| 0xA0895518|I2C |ICR |0xF48000FC||0x00000000| 0xA0895520|I2C |ICR |0xF48000FC||0x00001000| 0xA0895868|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895878|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895888|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895938|I2C |RTB |0xF4800018||0x00004262| 0xA0895940|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895950|I2C |SYSCON |0xF4800010||0x04880000| 0xA0895964|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA0895970|I2C |WHBSYSCON|0xF4800020||0x00100000| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895388|I2C |SYSCON |0xF4800010||0x04980230| 0xA089539C|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895420|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895438|I2C |SYSCON |0xF4800010||0x00980230| 0xA0895444|I2C |RTB |0xF4800018||0x00000008| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895388|I2C |SYSCON |0xF4800010||0x00980130| 0xA089539C|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895590|I2C |SYSCON |0xF4800010||0x00980130| 0xA08955A8|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955B4|I2C |WHBSYSCON|0xF4800020||0x00080000| 0xA08955BC|I2C |SYSCON |0xF4800010||0x008800A0| 0xA08955DC|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955E8|I2C |WHBSYSCON|0xF4800020||0x00000080| 0xA08955F0|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955FC|I2C |WHBSYSCON|0xF4800020||0x00000020| 0xA0895530|I2C |ICR |0xF48000FC||0x00004000| 0xA07EDF94|I2C |BUSCON |0xF4800014||0x00000000| 0xA07EDF9C|I2C |CLC |0xF4800000||0x00000001| 0xA07EE064|I2C |CLC |0xF4800000||0x00000100| 0xA07EE06C|I2C |BUSCON |0xF4800014||0xA0007E11| 0xA07EE070|I2C |SYSCON |0xF4800010||0x00880000| 0xA07EE07C|I2C |SYSCON |0xF4800010||0x00880000| 0xA089550C|I2C |ICR |0xF48000FC||0x00000000| 0xA0895514|I2C |ICR |0xF48000FC||0x00004000| 0xA0895518|I2C |ICR |0xF48000FC||0x00000000| 0xA0895520|I2C |ICR |0xF48000FC||0x00001000| 0xA0895868|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895878|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895888|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895938|I2C |RTB |0xF4800018||0x00004462| 0xA0895940|I2C |SYSCON |0xF4800010||0x00880000| 0xA0895950|I2C |SYSCON |0xF4800010||0x04880000| 0xA0895964|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA0895970|I2C |WHBSYSCON|0xF4800020||0x00100000| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895388|I2C |SYSCON |0xF4800010||0x04980230| 0xA089539C|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895420|I2C |SYSCON |0xF4800010||0x04980230| 0xA0895438|I2C |SYSCON |0xF4800010||0x00980230| 0xA0895444|I2C |RTB |0xF4800018||0x00000062| 0xA0895540|I2C |ICR |0xF48000FC||0x00003000| 0xA0895548|I2C |ICR |0xF48000FC||0x00007000| 0xA0895374|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895388|I2C |SYSCON |0xF4800010||0x00980130| 0xA089539C|I2C |SYSCON |0xF4800010||0x00980130| 0xA0895590|I2C |SYSCON |0xF4800010||0x00980130| 0xA08955A8|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955B4|I2C |WHBSYSCON|0xF4800020||0x00080000| 0xA08955BC|I2C |SYSCON |0xF4800010||0x008800A0| 0xA08955DC|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955E8|I2C |WHBSYSCON|0xF4800020||0x00000080| 0xA08955F0|I2C |WHBSYSCON|0xF4800020||0x00000000| 0xA08955FC|I2C |WHBSYSCON|0xF4800020||0x00000020| 0xA0895530|I2C |ICR |0xF48000FC||0x00004000| 0xA07EDF94|I2C |BUSCON |0xF4800014||0x00000000| 0xA07EDF9C|I2C |CLC |0xF4800000||0x00000001|</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here is the transfer of an 8-byte file (guess the contents) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.txt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> via infrared </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siemens CF75</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> phone </font><font style="vertical-align: inherit;">(there is a sniffer on it) to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siemens CX75</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We catch only data registers:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USART1: IR transfer file habr.txt</font></font></b> <div class="spoiler_text"><pre> <code class="bash hljs">0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF C0 FF 3F 01 10 ?.. 64 77 01 FF FF FF FF 01 00 00 06 7C C1 C1 dw.....| 0xA07F1BC0|USART1 |RXB |0xF1800024|| C1 FF FF FF FF FF FF FF FF FF FF C0 FE BF 01 40 —ó.@ 90 81 09 10 64 77 01 01 00 00 B1 24 00 53 49 45 —í–É..dw....¬±$.SIE 4D 45 4E 53 20 43 58 37 35 3E 35 C1 MENS CX75&gt;5 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF C0 FF 3F 01 10 ?.. 64 77 01 FF FF FF FF 01 01 00 DE 65 C1 C1 dw....e 0xA07F1BC0|USART1 |RXB |0xF1800024|| C1  0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF C0 FF 3F 01 10 ?.. 64 77 01 FF FF FF FF 01 02 00 B6 4F C1 C1 FF FF dw....¬∂O FF FF FF FF FF FF FF FF FF C0 FF 3F 01 10 64 77 ?..dw 01 FF FF FF FF 01 03 00 6E 56 C1 C1 FF FF FF FF ....nV FF FF FF FF FF FF FF C0 FF 3F 01 10 64 77 01 FF ?..dw. FF FF FF 01 04 00 66 1B C1 C1 FF FF FF FF FF FF ...f. FF FF FF FF FF C0 FF 3F 01 10 64 77 01 FF FF FF ?..dw. FF 01 05 00 BE 02 C1 C1 FF FF FF FF FF FF FF FF ...—ï. FF FF FF C0 FF 3F 01 10 64 77 01 FF FF FF FF 01 ?..dw.. FF 00 B1 24 00 53 49 45 4D 45 4E 53 20 43 46 37 .¬±$.SIEMENS CF7 35 51 CD C1 C1 FF FF FF FF FF FF FF FF FF FF FF 5Q C0 FF 93 10 64 77 01 40 90 81 09 B4 01 01 3E 82 ‚Äú.dw.@—í–É.“ë..&gt;‚Äö 01 07 83 01 0F 84 01 01 85 01 04 86 01 07 08 01 ..—ì..‚Äû..‚Ä¶..‚Ä†.... FF 25 82 C1 C1 %‚Äö 0xA07F1BC0|USART1 |RXB |0xF1800024|| C1 FF FF FF FF FF FF FF FF FF FF C0 B4 73 40 90 “ës@—í 81 09 10 64 77 01 01 01 3E 82 01 07 83 01 0F 84 –É..dw...&gt;‚Äö..—ì..‚Äû 01 01 85 01 04 86 01 07 08 01 FF 60 18 C1 ..‚Ä¶..‚Ä†....`. 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 J C1 C1  0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 11 41 “ë.A 53 C1 S 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 10 ¬µ. 80 02 01 00 34 14 C1 C1 –Ç...4. 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 31 43 “ë1C 72 C1 r 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 30 82 “ë0‚Äö 00 81 00 8C 70 C1 .–É.–äp 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 32 ¬µ2 00 02 84 04 4F 42 45 58 13 49 72 44 41 3A 54 69 ..‚Äû.OBEX.IrDA:Ti 6E 79 54 50 3A 4C 73 61 70 53 65 6C 04 AF C1 C1 nyTP:LsapSel.–á 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 31 ¬µ1 9B 6B C1 C1 ‚Ä∫k 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 52 02 “ëR. 00 84 00 00 01 00 02 01 00 00 00 04 8D AF C1 .‚Äû..........–å–á 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 54 ¬µT 84 04 01 00 04 18 B5 C1 C1 ‚Äû.....¬µ 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 51 ¬µQ 9D 08 C1 C1 —ú. 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 74 84 “ët‚Äû 04 81 00 04 41 A3 C1 .–É..A–à 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 —ü) C1 C1  0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 71 47 “ëqG 30 C1 0 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 76 ¬µv 04 04 00 80 00 07 10 00 02 0B 92 AC C1 C1 ...–Ç......<span class="hljs-string"><span class="hljs-string">'¬¨ 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 91 49 “ë'</span></span>I D7 C1  0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 71 ¬µq 9F 29 C1 C1 —ü) 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 96 04 “ë‚Äì. 04 01 A0 00 07 10 00 02 0B 6F 76 C1 .. ......ov 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 98 ¬µÀú 04 04 01 02 00 1D 01 00 15 00 68 00 61 00 62 00 ..........hab 72 00 2E 00 74 00 78 00 74 00 00 C3 00 00 00 08 r...txt..... 8C 02 C1 C1 –ä. 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 B1 4B “ë¬±K F6 C1  0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 91 ¬µ<span class="hljs-string"><span class="hljs-string">' 91 CE C1 C1 '</span></span> 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 B8 04 “ë. 04 01 90 00 03 99 A7 C1 ..—í..¬ß 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 BA ¬µ—î 04 04 01 02 00 0E 48 00 0B 48 41 42 52 48 41 42 ......H..HABRHAB 52 96 88 C1 C1 R‚Äì‚Ç¨ 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 D1 4D “ëM 95 C1 ‚Ä¢ 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 B1 ¬µ¬± 93 EF C1 C1 ‚Äú 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 D1 4D “ëM 95 C1 ‚Ä¢ 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 B1 ¬µ¬± 93 EF C1 C1 ‚Äú 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 D1 4D “ëM 95 C1 ‚Ä¢ 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 B1 ¬µ¬± 93 EF C1 C1 ‚Äú 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 D1 4D “ëM 95 C1 ‚Ä¢ 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 B1 ¬µ¬± 93 EF C1 C1 ‚Äú 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 D1 4D “ëM 95 C1 ‚Ä¢ 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 B1 ¬µ¬± 93 EF C1 C1 ‚Äú 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 D1 4D “ëM 95 C1 ‚Ä¢ 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 B1 ¬µ¬± 93 EF C1 C1 ‚Äú 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 D1 4D “ëM 95 C1 ‚Ä¢ 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 B1 ¬µ¬± 93 EF C1 C1 ‚Äú 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 DA 04 “ë. 04 01 90 00 03 A7 34 C1 ..—í..¬ß4 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 DC ¬µ 04 04 01 82 00 06 49 00 03 DD A5 C1 C1 ...‚Äö..I..“ê 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 F1 4F “ëO B4 C1 “ë 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 D1 ¬µ 95 8C C1 C1 ‚Ä¢–ä 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 FC 04 “ë. 04 01 A0 00 03 47 89 C1 .. ..G‚Ä∞ 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 FE ¬µ 04 04 01 81 00 03 A4 66 C1 C1 ...–É..¬§f 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 11 41 “ë.A 53 C1 S 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 F1 ¬µ 97 AD C1 C1 ‚Äî 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 1E 04 “ë.. 04 01 A0 00 03 64 9C C1 .. ..d—ö 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 11 41 “ë.A 53 C1 S 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 11 41 “ë.A 53 C1 S 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 10 ¬µ. 84 04 02 01 E0 8B C1 C1 ‚Äû...‚Äπ 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 31 43 “ë1C 72 C1 r 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 31 43 “ë1C 72 C1 r 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 12 ¬µ. 80 02 02 01 5D 39 C1 C1 –Ç...]9 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 11 ¬µ. 99 4A C1 C1 J 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 51 45 “ëQE 11 C1 . 0xA0A3F3B0|USART1 |TXB |0xF1800020|| FF FF FF FF FF FF FF FF FF FF FF FF FF C0 B5 53 ¬µS 8F 2B C1 C1 –è+ 0xA07F1BC0|USART1 |RXB |0xF1800024|| FF FF FF FF FF FF FF FF FF FF FF FF C0 B4 73 40 “ës@ 90 81 09 10 64 77 01 3C 38 C1 —í–É..dw.&lt;8</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's go back to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Put the filter so that only data transfer is tracked. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When clicking, service sounds, changing the backlight, volume and vibration, we will see that something happens:</font></font><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/mrXty3rPfgc%3Ffeature%3Doembed&amp;xid=17259,15700002,15700023,15700186,15700191,15700253&amp;usg=ALkJrhgjqSN0gxyRnmqT6TdQx2vXljTpbQ" frameborder="0" allowfullscreen=""></iframe><br><br><h2>  Files </h2><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOSniffer_CPPBuilder_XE5.rar </font></font></a> <br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOSniffer_IAR42.rar </font></font></a> <br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOSniffer_I2C.avi</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/226575/">https://habr.com/ru/post/226575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226561/index.html">Everyone is equal, but some are more equal or is it possible to spam on Google Play</a></li>
<li><a href="../226563/index.html">MultiCAD.NET API: Saving non-graphic information in .dwg-drawings</a></li>
<li><a href="../226565/index.html">Textbook on programming language D. Part 2</a></li>
<li><a href="../226571/index.html">The story of creating a world map for the game ‚ÄúC & C Tiberium Alliances‚Äù. Postmortem</a></li>
<li><a href="../226573/index.html">Creating audio plugin, part 7</a></li>
<li><a href="../226581/index.html">‚ÄúIt still works!‚Äù: As two friends accidentally made a 3d revolution, inventing a doodler</a></li>
<li><a href="../226585/index.html">Posting a group of pictures with text using Vkontakte API</a></li>
<li><a href="../226591/index.html">Filmstrips on the barrel organ: rakes, cones and pitfalls</a></li>
<li><a href="../226593/index.html">OpenSSL CCS Vulnerability</a></li>
<li><a href="../226595/index.html">The second Russian conference "Wolfram Technologies": story and materials</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>