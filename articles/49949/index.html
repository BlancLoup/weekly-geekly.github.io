<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Use Python to process HTML forms.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I first started using django, the most enjoyable moment after ORM, for me, was the django.forms package. Now django is in the past - I use the We...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Use Python to process HTML forms.</h1><div class="post__text post__text-html js-mediator-article">  When I first started using django, the most enjoyable moment after ORM, for me, was the django.forms package.  Now django is in the past - I use the Werkzeug + SqlAlchemy + Jinja2 stack, and sometimes I even try to experiment with non-relational data stores instead of SqlAlchemy.  But I did not find a replacement for django.forms.  Therefore, I decided to sketch out something of my own. <br><a name="habracut"></a><br>  As a result, I came to about the following description.  At the input we have the data represented by the type dict, and the keys of this dictionary are strings, and the values ‚Äã‚Äãare strings or other dictionaries of the same structure.  For example: <br><br><pre> data = {
     "key1": "value1"
     "key2": {
         "key3": "value3"
     }
 }
</pre><br><br>  Next, we have some assumptions about this data - some set of rules, which we will call a schema.  Now we need a way to go through all the fields of the dictionary with the data and check their value for correctness, and also lead to the necessary types.  It's simple! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This leads to quite understandable implementation requirements: <br><br>  * A simple way to describe the schemes - I want it to be visual and convenient, that is, declarative. <br>  * Reuse code - quite tedious to describe the same schemes 10 times. <br>  * Defining schemas for nested data structures - and this may be needed. <br><br>  Basic principles of implementation <br>  Basic principles <br><br>  It is assumed that the data validation error will be described by the following exception: <br><br><pre> class SchemaValidationError (TypeError):
    def __init __ (self, error):
        self.error = error
</pre><br><br>  Data validation is practically an analysis of data types, so I consider it appropriate to inherit from the standard TypeError exception. <br><br>  The scheme will be defined as a class whose attributes will be objects describing the fields.  Since we want to describe nested constructions, we can have attributes of string fields as well as other schemes with attributes.  This is what happens in the first stage: <br><br><pre> class SchemaElement (object):
     u "" "
     Abstract class for the schema element.
     "" "
     def validate (self, data):
         raise NotImplementedError ()

 class Field (SchemaElement):
    u "" "
    The Field class describes a string field.
    "" "
    def validate (self, data):
        raise SchemaValidationError ("not valid value")

 class Schema (SchemaElement):
    u "" "
    The Schema class describes a validation scheme.
    "" "
    def validate (self, data):
        # Data validation code data
        return data
</pre><br><br>  Since the schema element can be either a field or another scheme, I inherited Field and Schema from the general class SchemaElement.  This is a composite design pattern; it is great for describing hierarchical data types. <br><br>  SchemaElement also defines an abstract interface for validation - the validate method.  The fact is that now, following this interface, we can not distinguish between Field and Schema objects from the point of view of validation, for us this is the same thing. <br><br>  Field class heirs will be used to describe schema fields, that is, to handle string values.  In order to implement the data validation algorithm for a specific field, you simply need to override the validate method, which will return the correct and provided data data or throw a SchemaValidationError exception in case of an error.  The default implementation will always throw an exception. <br><br>  The Schema class will be used to describe the structure consisting of fields and other schemas.  The code of the validate method will be presented a little later. <br>  Declarative schema description <br><br>  As I have already said, the most successful for me is the task of defining schemas in the form of a class whose attributes are other Field and Schema objects.  This is called a declarative description.  To implement this, we need a metaclass for the Schema container class: <br><br><pre> class SchemaMeta (type):
    def __new __ (mcs, name, bases, attrs):
        if not name == "Schema":
            fields = {}
            for base in reversed (bases):
                if issubclass (base, Schema) and not base is Schema:
                    fields.update (base .__ fields__)
            for field_name, field in attrs.items ():
                if isinstance (field, SchemaElement):
                    fields [field_name] = attrs [field_name]
            attrs ["__ fields__"] = fields
        cls = type .__ new __ (mcs, name, bases, attrs)
        return cls

    def __contains __ (cls, value):
        return value in cls .__ fields__

    def __iter __ (cls):
        return cls .__ fields __. items () .__ iter __ ()
</pre><br><br>  The main reason why I use this metaclass is to group all the fields of the scheme together and put it in the __fields__ attribute.  This will be useful when processing fields or introspecting the structure, since __fields__ does not contain unnecessary garbage, as if we bypass __dict__ every time. <br><br>  If we create a class with the name Schema, then the metaclass will not process it in any way, if it is another class inheriting from Schema, it will first collect all fields of superclasses in right-to-left order in __fields__ and then add fields of the current class there. <br><br>  I also added the __contains__ methods, which will check if the field with the given name is inside the schema, and the __iter__ method, which makes the class with the schema iterable.  Let me remind you that since we defined these methods at the metaclass, we get class methods, which is equivalent to applying the classmethod decorator to object methods. <br><br>  It remains to add the attribute __metaclass__ to the Schema class: <br><br><pre> class Schema (SchemaElement):
     ...
     __metaclass__ = SchemaMeta
     ...
</pre><br><br>  We can already define schemas as follows: <br><br><pre> &gt;&gt;&gt; class MySchema (Schema):
 ... my_field = Field ()

 &gt;&gt;&gt; class AnotherSchema (MySchema):
 ... another_field = Field ()

 &gt;&gt;&gt; "my_field" in MySchema
 True
 &gt;&gt;&gt; "another_field" in AnotherSchema
 True
 &gt;&gt;&gt; "my_field" in AnotherSchema
 True
</pre><br><br>  Inheritance of schemes works - the attribute My_field appeared in the scheme AnotherSchema.  To create a schema for validating hierarchical data structures, simply add another schema attribute with the schema attribute: <br><br><pre> &gt;&gt;&gt; class CompositeSchema (Schema):
         sub_schema = MySchema ()
         my_field = Field ()

 &gt;&gt;&gt; "my_field" in CompositeSchema
 True
 &gt;&gt;&gt; "sub_schema" in CompositeSchema
 True
 &gt;&gt;&gt; "my_field" in CompositeSchema.sub_schema
 True
</pre><br><br>  Data validation <br><br>  Validation is performed by the validate method, objects of the Field class should redefine it themselves, the implementation of the same validate method of the Schema class I quote here: <br><br><pre> class Schema (SchemaElement):
    ...
    def validate (self, data):
        errors = {}
        for field_name, field in self .__ fields __. items ():
            try:
                data [field_name] = field.validate (data.get (field_name, None))
            except SchemaValidationError, error:
                errors [field_name] = error.error
        if errors:
            raise SchemaValidationError (errors)
        return data
    ...
</pre><br><br>  First, each field of the scheme is called the validate method with the necessary parameter from the data dictionary.  If there is an error, it is caught and stored in the errors dictionary.  After we have bypassed all the fields, the errors dictionary is checked, and if it is not empty, the SchemaValidationError exception is thrown with this dictionary as a parameter.  This allows us to collect all the errors, starting from the lowest level in the hierarchy. <br><br>  Now you can try to define several basic fields and schemas and try validating the data in action: <br><br><pre> class NotEmptyField (Field):
     u "" "
     A class that describes a field that cannot be empty.
     "" "
     def validate (self, data):
         print "Validation fields"
         if not data:
             raise SchemaValidationError ("empty field")

 class CustomSchema (Schema):
     not_empty_field = NotEmptyField ()

     def validate (self, data):
         print "Validation of Scheme Fields"
         data = super (CustomSchema, self) .validate (data)
         print "Validation Code at Schema Level"
         return data
</pre><br><br>  Inside the validate method, we must call the validate method of the superclass.  Also, be sure to return the data or throw a SchemaValidationError exception.  Let's check our form in: <br><br><pre> &gt;&gt;&gt; schema = CustomSchema ()
 &gt;&gt;&gt; try:
 ... schema.validate ({"not_empty_field": "some value"})
 ... except SchemaValidationError, e:
 ... errors = e.error
 Validation of schema fields
 Field validation
 Validation code at schema level
 &gt;&gt;&gt; schema.errors
 {}
</pre><br><br>  Now we will try to provide invalid data for validation: <br><br><pre> &gt;&gt;&gt; try:
 ... schema.validate ({"not_empty_field": ""})
 ... except SchemaValidationError, e:
 ... errors = e.error
 First, let's validate the schema fields.
 Field validation
 &gt;&gt;&gt; errors
 {"not_empty_field": "empty field"}
</pre><br><br>  As expected, data validation failed. <br>  Conclusion <br><br>  And so, we have a small but already powerful enough library for data validation.  Of course, you must replenish it with the necessary fields (Field successor classes).  By the way, it turned out pretty compact - no more than 130 lines.  If you want to get the source code, you can write to me. </div><p>Source: <a href="https://habr.com/ru/post/49949/">https://habr.com/ru/post/49949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../49944/index.html">Web interface for Address Book in ldap, written in Django</a></li>
<li><a href="../49945/index.html">Let's help the Russian developer to win the competition for the Shorty Awards?</a></li>
<li><a href="../49946/index.html">Want to seduce a girl? Buy a laptop!</a></li>
<li><a href="../49947/index.html">Fresh Trojan for MacOS</a></li>
<li><a href="../49948/index.html">Performance Trick in Windows 7</a></li>
<li><a href="../49950/index.html">Official Comic Fallout 3</a></li>
<li><a href="../49951/index.html">1. Metaprogramming patterns - 25 kyu. Eval method</a></li>
<li><a href="../49953/index.html">I would go to Jabbers ...</a></li>
<li><a href="../49955/index.html">Dynamic creation of exCanvas</a></li>
<li><a href="../49956/index.html">Startup behind glass - minds are invited. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>