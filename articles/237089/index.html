<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Embedding into the Linux kernel: intercepting functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intercepting kernel functions is a basic method that allows you to redefine / supplement its various mechanisms. Based on the fact that the Linux kern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Embedding into the Linux kernel: intercepting functions</h1><div class="post__text post__text-html js-mediator-article">  Intercepting kernel functions is a basic method that allows you to redefine / supplement its various mechanisms.  Based on the fact that the Linux kernel is written almost entirely in C, with the exception of small architecture-specific parts, it can be argued that to implement embedding in most of the kernel components, it is enough to be able to intercept the corresponding functions. <br><br>  This article is a continuation of the <a href="http://habrahabr.ru/company/securitycode/blog/230697/">previously announced cycle</a> devoted to the particular issues of the implementation of the imposed remedies and, in particular, embedding into the software systems. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The purpose of intercepting any function is to get control at the time it is called.  Further actions depend on specific tasks.  In some cases, it is necessary to replace the system implementation of the algorithm with its own; in others, it should be supplemented.  In this case, it is important to leave the possibility of using the intercepted function for its own purposes. <br><br>  The traditional approach to intercepting is the use of the concept of ‚Äúwrappers‚Äù, which allows pre-and post-processing to be implemented while preserving the ability to access the original functionality of the intercepted function. <br><br>  The basis of most methods for intercepting functions is patching ‚Äî modifying the kernel code so that it can transfer control to the interceptor function when the target function is called.  At the same time, due to the developed command system of the x86 architecture, there may be a number of options for changing the flow of execution (yes, JMP is only one of them: <a href="http://jbremer.org/x86-api-hooking-demystified/">more</a> ). <br><br><h4>  Method of interception </h4><br><br>  The essence of the described method of intercepting will be to modify the prolog (beginning) of the objective function so that its execution by the processor will result in the transfer of control to the handler function. <br><br>  In other words, for each target function, we modify the prolog by writing a JMP command to its beginning.  This allows you to switch the execution flow from the target function to the corresponding handler. <br><br>  For example, if, before interception, the <a href="">inode_permission</a> function is: <br><br><pre><code class="cpp hljs">inode_permission: <span class="hljs-number"><span class="hljs-number">0xffffffff811c4530</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: nopl <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rax,%rax,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">0xffffffff811c4535</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;: push %rbp <span class="hljs-number"><span class="hljs-number">0xffffffff811c4536</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;: test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil <span class="hljs-number"><span class="hljs-number">0xffffffff811c453a</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x28</span></span>(%rdi),%rax <span class="hljs-number"><span class="hljs-number">0xffffffff811c453e</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;: mov %rsp,%rbp <span class="hljs-number"><span class="hljs-number">0xffffffff811c4541</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">17</span></span>&gt;: jne <span class="hljs-number"><span class="hljs-number">0xffffffff811c454a</span></span> &lt;inode_permission+<span class="hljs-number"><span class="hljs-number">26</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffffffff811c4543</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">19</span></span>&gt;: callq <span class="hljs-number"><span class="hljs-number">0xffffffff811c4470</span></span> &lt;__inode_permission&gt;</code> </pre> <br><br>  Then after the interception, the prologue of this function will be as follows: <br><br><pre> <code class="cpp hljs">inode_permission: <span class="hljs-number"><span class="hljs-number">0xffffffff811c4530</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: jmpq <span class="hljs-number"><span class="hljs-number">0xffffffffa05a60e0</span></span> =&gt;     <span class="hljs-number"><span class="hljs-number">0xffffffff811c4535</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;: push %rbp <span class="hljs-number"><span class="hljs-number">0xffffffff811c4536</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;: test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil <span class="hljs-number"><span class="hljs-number">0xffffffff811c453a</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x28</span></span>(%rdi),%rax <span class="hljs-number"><span class="hljs-number">0xffffffff811c453e</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;: mov %rsp,%rbp <span class="hljs-number"><span class="hljs-number">0xffffffff811c4541</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">17</span></span>&gt;: jne <span class="hljs-number"><span class="hljs-number">0xffffffff811c454a</span></span> &lt;inode_permission+<span class="hljs-number"><span class="hljs-number">26</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffffffff811c4543</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">19</span></span>&gt;: callq <span class="hljs-number"><span class="hljs-number">0xffffffff811c4470</span></span> &lt;__inode_permission&gt;</code> </pre><br><br>  It is a five-byte JMP command written over the original instructions with the code E9.XX.XX.XX.XX leading to the transfer of control.  This is the main essence of the described method of interception.  Next, we will consider some features of its implementation in the Linux kernel. <br><br><h4>  Features of the interception of functions </h4><br><br>  As noted, the essence of the patch is to modify the kernel code.  The main problem arising from this is that writing to memory pages containing the code is impossible because  in the x86 architecture, there is a special protection mechanism, according to which an attempt to write to write-protected memory areas can lead to an exception being thrown.  This mechanism is called ‚Äúpage protection‚Äù and is the basis for the implementation of many functions of the kernel, such as <a href="http://en.wikipedia.org/wiki/Copy-on-write">COW</a> .  The behavior of the processor in this situation is determined by the WP register's <a href="http://en.wikipedia.org/wiki/Control_register">CR0</a> bit, and page access permissions are described in the corresponding PTE descriptor structure.  When the WP register CR0 bit is set, an attempt to write to write-protected pages (the RW bit is reset in PTE) leads to the processor generating the corresponding exception ( <a href="http://en.wikipedia.org/wiki/General_protection_fault">#GP</a> ). <br><br>  Often, the solution to this problem is to temporarily turn off page protection by resetting the WP register CR0 bit.  This solution is the place to be, however, it should be used with caution, because, as noted, the page protection mechanism is the basis for many core mechanisms.  In addition, on SMP systems, a thread running on one of the processors and removing the WP bit in the same place can be interrupted and moved to another processor! <br><br>  A better and sufficiently universal way to create temporary mappings.  Due to the nature of the MMU, several descriptors referring to it with different attributes can be created for each physical memory frame.  This allows you to create a writeable mapping for the target memory area.  This method is used in the <a href="http://en.wikipedia.org/wiki/Ksplice">Ksplice</a> project (fork on <a href="https://github.com/jirislaby/ksplice">github</a> 'e).  Below is the map_writable function, which creates such a mapping: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * map_writable creates a shadow page mapping of the range * [addr, addr + len) so that we can write to code mapped read-only. * * It is similar to a generalized version of x86's text_poke. But * because one cannot use vmalloc/vfree() inside stop_machine, we use * map_writable to map the pages before stop_machine, then use the * mapping inside stop_machine, and unmap the pages afterwards. * * STOLEN from: https://github.com/jirislaby/ksplice */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_writable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *vaddr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nr_pages = DIV_ROUND_UP(offset_in_page(addr) + len, PAGE_SIZE); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">page</span></span></span><span class="hljs-class"> **</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pages</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kmalloc</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr_pages</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pages</span></span></span><span class="hljs-class">), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GFP_KERNEL</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *page_addr = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)addr &amp; PAGE_MASK); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pages == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nr_pages; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__module_address((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)page_addr) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { pages[i] = virt_to_page(page_addr); WARN_ON(!PageReserved(pages[i])); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pages[i] = vmalloc_to_page(page_addr); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pages[i] == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { kfree(pages); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } page_addr += PAGE_SIZE; } vaddr = vmap(pages, nr_pages, VM_MAP, PAGE_KERNEL); kfree(pages); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vaddr == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vaddr + offset_in_page(addr); }</code> </pre><br><br>  Using this function will create a recordable display for any area of ‚Äã‚Äãmemory.  The release of the region created in this way is performed using the <a href="">vfree</a> function, the argument of which should be the address value aligned to the page boundary.  Additional information regarding this method of modifying write-protected pages is presented in <a href="http://habrahabr.ru/post/207122/">this</a> article. <br><br>  The next important point is that during the modification by patching, one way or another, part of the prolog of the objective function is erased.  It is not worth paying attention to, if you do not intend to use this feature further.  However, if for some reason the algorithm implemented by the target function can be useful after patching, it is worthwhile to ensure the possibility of executing the ‚Äúold‚Äù code given the ‚Äúcorruption‚Äù of the existing prologue. <br><br>  The following is an illustration of which is a schematic representation of the process of intercepting a function while preserving the ability to access the original functionality. <br><br><div style="text-align:center;"><img src="http://habrastorage.org/files/eb3/cf9/41c/eb3cf941c5b14edfb041ad7a8871eb60.png" alt="image"></div><br><br>  In the example, numeral <b>1</b> marks the transfer of control from the target function to the interceptor function (JMP command), numeral <b>2</b> indicates a call to the original function using the saved part of the prologue (CALL command), numeral <b>3</b> returns control to the part of the original function that was not modified (command JMP), and finally, the number <b>4</b> - return control to complete the call to the original function from the interceptor (RET command).  Thus, it is possible to use the capabilities implemented by the function being intercepted. <br><br><h4>  Implementing Interception Functions </h4><br><br>  We will describe each intercepted function with the following <a href="">structure</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* tagret's name */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * name; <span class="hljs-comment"><span class="hljs-comment">/* target's insn length */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-comment"><span class="hljs-comment">/* target's handler address */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * handler; <span class="hljs-comment"><span class="hljs-comment">/* target's address and rw-mapping */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * target; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * target_map; <span class="hljs-comment"><span class="hljs-comment">/* origin's address and rw-mapping */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * origin; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * origin_map; <span class="hljs-keyword"><span class="hljs-keyword">atomic_t</span></span> usage; } <span class="hljs-keyword"><span class="hljs-keyword">khookstr_t</span></span>;</code> </pre><br><br>  Here, name is the name of the function being intercepted (symbol name), length is the length of the overwritten sequence of prolog instructions, handler is the address of the interceptor function, target is the address of the target function itself, target_map is the address available for recording the projection of the objective function, origin is the address of the adapter function , used to access the original functionality, origin_map is the address of the projection of the corresponding adapter available for recording, usage is the ‚Äústicking‚Äù counter, which takes into account the number of threads sleeping in the interception. <br><br>  Each intercepted function must be represented by such a structure.  To do this, in order to simplify the registration of interceptors, use the macro <a href="">DECLARE_KHOOK (...)</a> , represented as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"khook_"</span></span></span><span class="hljs-meta">#t))) khook_alias_##t(void) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void){\ asm volatile ( \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">".rept 0x20\n"</span></span></span><span class="hljs-meta"> \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">".byte 0x90\n"</span></span></span><span class="hljs-meta"> \ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">".endr\n"</span></span></span><span class="hljs-meta"> \ ); \ } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">".khook"</span></span></span><span class="hljs-meta">),aligned(1))) __khook_##t #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</span></span></code> </pre><br><br>  Auxiliary macros <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code> declare an interceptor and an adapter (32 nop'a).  The structure itself is declared by the macro <code>__DECLARE_TARGET_STRUCT(...)</code> , using the <code>section</code> attribute, defining it into a special section ( <b>.khook</b> ). <br><br>  When a kernel module is loaded, all registered interceptions are listed (see <a href="">khook_for_each</a> ) represented by structures in the section named <b>.khook.</b> Each of them is searched for the address of the corresponding symbol (see <a href="">get_symbol_address</a> ), as well as setting auxiliary elements, including creating mappings (see <a href="">map_witable</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_hooks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">khookstr_t</span></span> * s; khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { atomic_inc(&amp;s-&gt;usage); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook\n"</span></span>, s-&gt;name); } <span class="hljs-comment"><span class="hljs-comment">/* apply patches */</span></span> stop_machine(do_init_hooks, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  An important role is played by the function <a href="">init_origin_stub</a> , which initializes and builds the adapter used to call the original function after interception: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_origin_stub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">khookstr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ud_t</span></span> ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == UD_Ijmp || ud.mnemonic == UD_Iint3) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JMP_INSN_LEN (1 + 4) s-&gt;length += ud_insn_len(&amp;ud); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (s-&gt;length &gt;= JMP_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</span></span></code> </pre><br><br>  As you can see, the udis86 disassembler is used to determine the number of instructions that are erased when patching the prologue.  In principle, any disassembler with the function of determining the length of the instruction (the so-called Length-Disassembler Engine, LDE) is suitable for this purpose.  I use for this purpose the complete disassembler udis86, which has a BSD license and has proven itself well.  As soon as the number of instructions is determined, they are copied to the <code>origin_map</code> address, which corresponds to the RW projection of the 32-byte <code>origin</code> adapter.  <a href="">Finally</a> , after the saved commands using <a href="">x86_put_jmp,</a> a command is inserted that returns control to the original code of the objective function that has not been changed. <br><br>  The last element to make the modification of the kernel code safe is the <a href="">stop_machine</a> mechanism: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/stop_machine.h&gt; int stop_machine(int (*fn)(void *), void *data, const struct cpumask *cpus)</span></span></span></span></code> </pre><br><br>  The bottom line is that <code>stop_machine</code> executes the <code>fn</code> function with a given set of processors active at the time of execution, which is set by the corresponding cpumask mask.  This is exactly what allows using this mechanism for modifying the kernel code, since  setting the appropriate mask automatically eliminates the need to keep track of those kernel threads, the execution of which may affect the modified code. <br><br><h4>  Using </h4><br><br>  An example of use is illustrated by intercepting the function <code>inode_permission</code> .  Given the considered macros, the interception sequence of the function will be as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/fs.h&gt; DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); debug("%s(%pK,%08x) [%s]\n", __func__, inode, mode, current-&gt;comm); result = KHOOK_ORIGIN(inode_permission, inode, mode); debug("%s(%pK,%08x) [%s] = %d\n", __func__, inode, mode, current-&gt;comm, result); KHOOK_USAGE_DEC(inode_permission); return result; }</span></span></span></span></code> </pre><br><br>  To work out the <code>DECLARE_KHOOK(...)</code> macro, it is necessary that there is a prototype of the function being intercepted ( <code>linux/fs.h</code> for <code>inode_permission</code> ).  Further, in the implementation of the interceptor function (having the prefix <code>khook_</code> ), you can do anything.  For example, I display a debug message before and after calling the original <code>inode_permission</code> function. <br><br>  Thus, through interception, the possibility of replacing functions, as well as replacing the passed parameters and the execution result, is implemented, which corresponds to the concept of embedding, which declares the possibility of redefining / supplementing the OS kernel mechanisms. <br><br>  Traditionally, kernel module code that implements the necessary actions to intercept functions is available on <a href="https://github.com/milabs/kmod_hook_fn">github</a> . </div><p>Source: <a href="https://habr.com/ru/post/237089/">https://habr.com/ru/post/237089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237079/index.html">Makeblock Starter Robot Kit V2.0 Review. Part 1. Unpack</a></li>
<li><a href="../237081/index.html">Profession Data Scientist: how not to make a mistake</a></li>
<li><a href="../237083/index.html">BiMap, jQuery breakpoint</a></li>
<li><a href="../237085/index.html">How we implemented innovations in a large company using the example of Windows 8 Kiosks</a></li>
<li><a href="../237087/index.html">Using Vendor-Specific Attributes in Cisco ACS 5 using the example of APC and Supermicro</a></li>
<li><a href="../237091/index.html">How to finish the decree with benefit?</a></li>
<li><a href="../237095/index.html">A simple and convenient way to add social networks in Android application on the example of Vkontakte and Odnoklassniki</a></li>
<li><a href="../237099/index.html">Cynical solution of logical problems</a></li>
<li><a href="../237101/index.html">RecyclerView and CardView. New Widgets in Android L</a></li>
<li><a href="../237105/index.html">Windows 2012 R2 + IIS + MS SQL + PHP installation, configuration, pitfalls</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>