<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with JSON in SQL Server 2016</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JSON is now one of the most used data formats in development. Most modern services return information in the form of JSON. JSON is also the preferred ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with JSON in SQL Server 2016</h1><div class="post__text post__text-html js-mediator-article">  JSON is now one of the most used data formats in development.  Most modern services return information in the form of JSON.  JSON is also the preferred format for storing structured information in files, for example.  Since a lot of data is used in JSON format, JSON support in SQL Server especially becomes relevant in order to be able to exchange data with other services. <br><br>  JSON has become one of the most requested features added in SQL Server 2016. Next, we will look at the main mechanisms for working with JSON in this article. <br><a name="habracut"></a><br><h2>  Short review </h2><br>  Functions for working with JSON in SQL Server allow you to analyze and query JSON data, convert JSON to a relational view, and export the result of a SQL query as JSON. <br><br><img src="https://habrastorage.org/files/32c/290/6cd/32c2906cd22f4ae5b262198ddd392885.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you have JSON, you can get data from there or check it for validity using the built-in functions JSON_VALUE, JSON_QUERY and ISJSON.  To change the data, the JSON_MODIFY function can be used.  For more advanced use, the OPENJSON function allows you to convert an array of JSON objects into a set of strings.  Then you can run any SQL query on this set.  Finally, there is a FOR JSON construct that converts the result of the query to JSON. <br><br>  Let's look at some simple examples.  In the following code, we define a text variable in which there will be JSON: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">json</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">json</span></span> = N<span class="hljs-string"><span class="hljs-string">'{ "info":{ "type":1, "address":{ "town":"Bristol", "county":"Avon", "country":"England" }, "tags":["Sport", "Water polo"] }, "type":"Basic" }'</span></span></code> </pre> <br>  Now we can get individual values ‚Äã‚Äãor objects from JSON using JSON_VALUE and JSON_QUERY: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> JSON_VALUE(@<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'$.type'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, JSON_VALUE(@<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'$.info.address.town'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> town, JSON_QUERY(@<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'$.info.tags'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tags</code> </pre> <br>  This query will return ‚ÄúBasic‚Äù, ‚ÄúBristol‚Äù and [‚ÄúSport‚Äù, ‚ÄúWater polo‚Äù].  The JSON_VALUE function returns a scalar value from JSON (that is, a string, a number, a boolean value) that is located along the ‚Äúpath‚Äù specified by the second parameter.  JSON_QUERY returns an object or array (in our example, it is an array of tags) along a ‚Äúpath‚Äù.  The built-in JSON functions use JavaScript-like syntax to refer to values ‚Äã‚Äãand objects as the second parameter. <br><br>  The OPENJSON function allows you to access an array inside JSON and return the elements of this array: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> OPENJSON(@<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, <span class="hljs-string"><span class="hljs-string">'$.info.tags'</span></span>)</code> </pre> <br>  This example returns string values ‚Äã‚Äãfrom an array of tags.  In addition, OPENJSON can return any complex object. <br><br>  Finally, the FOR JSON construct can format any result of executing a SQL query in JSON: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> object_id, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.tables <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PATH</span></span></code> </pre> <br>  Consider these features in more detail. <br><br><h2>  JSON data storage in SQL Server </h2><br>  In SQL Server, JSON is stored as text.  You can use the NVARCHAR type for this.  In the following example, we will store JSON in the InfoJson field: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Person ( <span class="hljs-keyword"><span class="hljs-keyword">Id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> NONCLUSTERED, FirstName <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, LastName <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, InfoJson <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MEMORY_OPTIMIZED=<span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>)</code> </pre> <br>  In SQL Server 2016, you can combine regular columns (FirstName and LastName in the example) and columns with JSON (InfoJSON in the example) in the same table.  You can also combine JSON columns with columns with spatial data (spatial columns) and XML.  Unlike only relational or only document-oriented repositories, you can choose storage principles to achieve greater development flexibility. <br><br>  Although JSON is stored in text columns, it is not just plain text.  SQL Server has a mechanism for optimizing the storage of text columns using various compression mechanisms, such as UNICODE compression, which can save up to 50% of the size.  You can also store JSON in tables with columnstore indexes or compress them explicitly using the built-in COMPRESS function, which uses the GZip algorithm. <br><br>  JSON is fully compatible with any SQL Server component that works with the NVARCHAR type.  In the example above, JSON is stored in the OLTP (Hekaton) table in memory, which offers super-performance.  You can store JSON in regular tables, use columnstore indexes or FILESTREAM.  You can also load it from Hadoop using Polybase tables, read from the file system, work with it in Azure SQL, use replication, etc.  If you combine tables that store JSON with other SQL Server features, such as temporary table security or row-level security, you can discover powerful features that are not available in existing document-oriented DBMSs. <br><br>  If you want to ensure the validity of the stored JSON, you can add a validation check using the restrictions and ISJSON functions: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Content</span></span> should be formatted <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JSON</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">CHECK</span></span> ( ISJSON( InfoJSON )&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> )</code> </pre> <br>  At runtime, your requests will not work if JSON is formatted incorrectly. <br><br>  Since  JSON is represented as text, there is no need to change something in your applications.  You can work with JSON as with ordinary strings.  JSON can be loaded using ORM as a string and sent to a JavaScript client application.  Any data extraction utilities will also work. <br><br><h2>  Built-in JSON handling </h2><br>  SQL Server 2016 offers several functions for handling JSON: <br><br><ul><li>  <b>ISJSON</b> (jsonText) checks the validity of JSON for compliance with the specification.  With this function you can impose restrictions on columns containing JSON </li><li>  <b>JSON_VALUE</b> (jsonText, path) parses jsonText and highlights individual values ‚Äã‚Äãalong a specific ‚Äúpath‚Äù (see examples below) </li><li>  <b>JSON_QUERY</b> (jsonText, path) parses jsonText and highlights objects or arrays along a specific ‚Äúpath‚Äù (see examples below) </li><li>  <b>JSON_MODIFY</b> (jsonText, path, newValue) changes the value of a property by a certain ‚Äúpath (see examples below) </li></ul><br>  These functions use ‚Äúpaths‚Äù in JSON to refer to values ‚Äã‚Äãor objects.  Examples: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'$'</span></span> <span class="hljs-comment"><span class="hljs-comment">//     JSON    '$.property1' //   property1   JSON '$[4]' //   5-    (   0) '$.property1.property2.array1[5].property3.array2[15].property4' //     '$.info."first name"' //    "first name"  .      (,    ..),       </span></span></code> </pre> <br>  When using the JSON_MODIFY function, additional modifiers can be used in the path parameter.  In general, the ‚Äúpath‚Äù syntax looks like: <br><br><pre>  [append] [lax |  strict] $ .json_path </pre><br>  If you specify the append modifier, the new value will be added to the array referenced by json_path.  The lax modifier sets the mode of operation in which it does not matter whether a property exists or not.  If not, it will be added.  When using strict, if there is no property, an error will be generated. <br><br>  The dollar sign ($) refers to the entire JSON object (similar to the root node "/" in XPath).  You can add any property after the ‚Äú$‚Äù to refer to the elements of the object.  Consider a simple example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Id</span></span>, FirstName, LastName, JSON_VALUE(InfoJSON, <span class="hljs-string"><span class="hljs-string">'$.info."social security number"'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SSN, JSON_QUERY(InfoJSON, <span class="hljs-string"><span class="hljs-string">'$.skills'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Skills <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ISJSON( InfoJSON ) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> JSON_VALUE(InfoJSON, <span class="hljs-string"><span class="hljs-string">'$.Type'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Student'</span></span></code> </pre> <br>  This query returns the first and last names from the regular columns, the social number and the skills array from the JSON column.  The results are filtered by the condition that the InfoJSON column must contain valid JSON and the Type value in the JSON column is ‚ÄúStudent‚Äù.  As you already understood, you can use values ‚Äã‚Äãfrom JSON in any part of the request (sorting, grouping, etc.). <br><br><h2>  JSON conversion to relational view - OPENJSON </h2><br>  The OPENJSON function returns a table that defines an array of objects, iterates through the array, and displays each element of the array in a row. <br><br><h3>  Example </h3><br>  Input Data (JSON): <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"Orders"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Order"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Number"</span></span>: <span class="hljs-string"><span class="hljs-string">"S043659"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2011-05-31T00:00:00"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Account"</span></span>: <span class="hljs-string"><span class="hljs-string">"Microsoft"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Item"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Price"</span></span>: <span class="hljs-number"><span class="hljs-number">59.99</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"Order"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Number"</span></span>: <span class="hljs-string"><span class="hljs-string">"S043661"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2011-06-01T00:00:00"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Account"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nokia"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Item"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Price"</span></span>: <span class="hljs-number"><span class="hljs-number">24.99</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } } ] }</code> </pre> <br>  SQL query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> OPENJSON(@<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>, N<span class="hljs-string"><span class="hljs-string">'$.Orders'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>) N<span class="hljs-string"><span class="hljs-string">'$.Order.Number'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> DATETIME N<span class="hljs-string"><span class="hljs-string">'$.Order.Date'</span></span>, Customer <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>) N<span class="hljs-string"><span class="hljs-string">'$.Account'</span></span>, Quantity <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> N<span class="hljs-string"><span class="hljs-string">'$.Item.Quantity'</span></span> )</code> </pre> <br>  Result <br><br><pre> |  Number |  Date |  Customer |  Quantity
 -------------------------------------------------- --------
 |  S043659 |  2011-05-31 00: 00: 00.000 |  Microsoft |  one
 |  S043661 |  2011-06-01 00: 00: 00.000 |  Nokia |  3
</pre><br><br>  In the example above, we determined where we would look for an array of JSON that we process (that is, the $ .Orders path), which columns we return, and where in the JSON objects we find the values ‚Äã‚Äãthat we return as cells. <br><br>  OPENJSON can be used in any query when working with data.  As in the example, we can convert the JSON array from the orders variable to the rowset and then insert them into a regular table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Orders(<span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, Customer, Quantity) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, Customer, Quantity OPENJSON (@orders) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> datetime, Customer <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>), Quantity <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> OrdersArray</code> </pre> <br>  The 4 columns of the returned OPENJSON data set are defined using the WITH clause.  OPENJSON will try to find the Number, Date, Customer, and Quantity properties in each JSON object and convert the values ‚Äã‚Äãto columns in the resulting dataset.  By default, if the property is not found, NULL will be returned.  Suppose the orders variable contains the following JSON: <br><br><pre> <code class="hljs swift">'[ {<span class="hljs-string"><span class="hljs-string">"Number"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"8/10/2012"</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adventure works"</span></span>, <span class="hljs-string"><span class="hljs-string">"Quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1200</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Number"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"5/11/2012"</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adventure works"</span></span>, <span class="hljs-string"><span class="hljs-string">"Quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Number"</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"1/3/2012"</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adventure works"</span></span>, <span class="hljs-string"><span class="hljs-string">"Quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">250</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Number"</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"12/7/2012"</span></span>, <span class="hljs-string"><span class="hljs-string">"Customer"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adventure works"</span></span>, <span class="hljs-string"><span class="hljs-string">"Quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">2200</span></span>} ]'</code> </pre> <br>  As you can see, the conversion from JSON to the relational form is very simple.  All you need to do is define the column names and types, and OPENJSON will find the properties in JSON that correspond to the columns.  This example uses simple sibling JSON, but OPENJSON can work with complex nested objects. <br><br>  OPENJSON can also be used when you need to combine relational data and JSON in the same query.  Suppose that the JSON array from the previous example is stored in the OrdersJson column.  The following query returns the normal and JSON fields: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Id</span></span>, FirstName, LastName, <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, Customer, Quantity <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">CROSS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">APPLY</span></span> OPENJSON (OrdersJson) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> datetime, Customer <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>), Quantity <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> OrdersArray</code> </pre> <br>  OPENJSON processes the array in each cell and returns one row for each JSON object in the array.  The CROSS APPLY OPENJSON syntax is used to combine table rows with JSON data. <br><br><h2>  JSON data indexing </h2><br>  Although the values ‚Äã‚Äãin JSON are stored as text, you can index them as normal values ‚Äã‚Äãin columns.  You can use nonclustered or full text indexes. <br><br>  If you want to create an index on any JSON property that is often used in queries, you can create a calculated column that refers to the desired property, then create a regular index on this field.  In the following example, we optimize queries that filter rows using the $ .Company property from the InfoJSON column: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> vCompany <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> JSON_VALUE(InfoJSON, <span class="hljs-string"><span class="hljs-string">'$.Company'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> idx_Person_1 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Person(vCompany)</code> </pre> <br>  SQL Server provides a hybrid model in which you can combine regular columns and values ‚Äã‚Äãfrom JSON in a single index. <br><br>  Since  JSON is just text, you can use a full-text index.  Full-text indexes can be created on an array of values.  You create a full-text index on a column that contains an array of JSON, or you can create a calculated column that references the array and add a full-text index to this column: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> vEmailAddresses <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> JSON_QUERY(InfoJSON, <span class="hljs-string"><span class="hljs-string">'$.Contact.Emails'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> FULLTEXT <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> Person(vEmailAddresses) <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> PK_Person_ID <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> jsonFullTextCatalog;</code> </pre> <br>  A full-text index is useful if you need to optimize queries that look for any value in a JSON array: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> PersonID, FirstName,LastName,vEmailAddresses <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> CONTAINS(vEmailAddresses, <span class="hljs-string"><span class="hljs-string">'john@mail.microsoft.com'</span></span>)</code> </pre> <br>  This request will return lines from Person, where the email address array contains ‚Äûjohn@mail.microsoft.com‚Äú.  The full-text index has no special rules for parsing JSON.  It divides the array using delimiters (double quotes, commas, and square brackets) and indexes the values ‚Äã‚Äãin the array.  A full-text index applies to arrays of numbers or strings.  If you have more complex objects in JSON, the full-text index is not applicable, as it cannot distinguish keys from values. <br><br>  In general, the same principles for creating indexes can be applied to ordinary columns or JSON columns. <br><br><h2>  Export data to JSON - FOR JSON </h2><br>  In SQL Server, it is possible to convert relational data to JSON using the FOR JSON construct.  If you are familiar with the FOR XML construct, then you already practically know FOR JSON. <br><br><h3>  Example </h3><br>  Initial data <br><br><pre> |  Number |  Date |  Customer |  Price |  Quantity |
 -------------------------------------------------- ------------------
 |  S043659 |  2011-05-31 00: 00: 00.000 |  Microsoft |  59.99 |  1 |
 |  S043661 |  2011-06-01 00: 00: 00.000 |  Nokia |  24.99 |  3 |
</pre><br>  SQL query <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [Order.Number], <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [Order.Date], Customer <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Account</span></span>], Price <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'Item.UnitPrice'</span></span>, Quantity <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'Item.Qty'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> SalesOrder <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PATH</span></span>, ROOT(<span class="hljs-string"><span class="hljs-string">'Orders'</span></span>)</code> </pre><br>  Resulting json <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"Orders"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Order"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Number"</span></span>: <span class="hljs-string"><span class="hljs-string">"S043659"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2011-05-31T00:00:00"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Account"</span></span>: <span class="hljs-string"><span class="hljs-string">"Microsoft"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Item"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"UnitPrice"</span></span>: <span class="hljs-number"><span class="hljs-number">59.99</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Qty"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"Order"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Number"</span></span>: <span class="hljs-string"><span class="hljs-string">"S043661"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2011-06-01T00:00:00"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Account"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nokia"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Item"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"UnitPrice"</span></span>: <span class="hljs-number"><span class="hljs-number">24.99</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Qty"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } } ] }</code> </pre> <br>  When you add FOR JSON to the end of a SELECT query, SQL Server formats the result as JSON.  Each row will be represented as one JSON object, the values ‚Äã‚Äãfrom the cells will be JSON values, and the column names will be used as keys.  There are 2 types of FOR JSON constructs: <br><br><ul><li>  <b>FOR JSON PATH</b> allows you to define a JSON structure on output using column names.  If you use dot-separated names as synonyms for columns, the JSON properties will follow the naming conventions.  This is similar to FOR XML PATH where you can specify a path separated by slashes. <br><br></li><li>  <b>FOR JSON AUTO</b> automatically creates nested arrays based on the hierarchy of the tables in the query.  Looks like FOR XML AUTO. </li></ul><br><h2>  Conclusion </h2><br>  JSON functions in SQL Server allow you to query and analyze data as JSON, as well as convert it to a relational view and vice versa.  This allows SQL Server to be integrated into external systems that send or receive JSON without additional conversions. <br><br>  SQL Server also offers a hybrid storage model when you combine relational data and JSON data in one table.  This model allows for a trade-off between high speed data access and flexible application development. <br><br>  In addition, you can index values ‚Äã‚Äãin JSON as ordinary columns, and also convert relational data to JSON with FOR JSON and vice versa, using OPENJSON. </div><p>Source: <a href="https://habr.com/ru/post/317166/">https://habr.com/ru/post/317166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317156/index.html">GitLab 8.14 released</a></li>
<li><a href="../317158/index.html">Segment routing: how and why</a></li>
<li><a href="../317160/index.html">Interactive landing or how to blow up conversion with the help of instant messengers</a></li>
<li><a href="../317162/index.html">Magento 2: ObjectManager and Proxy Classes</a></li>
<li><a href="../317164/index.html">How to pay programmers less</a></li>
<li><a href="../317170/index.html">How the company is headed by a general director-programmer - opinions and experience of experts</a></li>
<li><a href="../317172/index.html">Inkscape: the beginning (translation)</a></li>
<li><a href="../317174/index.html">Recovering virtualized Active Directory deleted objects from tombstone objects</a></li>
<li><a href="../317176/index.html">Where is the Internet of Things going?</a></li>
<li><a href="../317178/index.html">Why not write bots for Skype</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>