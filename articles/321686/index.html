<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of transactional microservices using aggregates, Event Sourcing and CQRS (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We bring to your attention a translation of the first part of a useful article on how to develop transactional business applications using a microserv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of transactional microservices using aggregates, Event Sourcing and CQRS (Part 1)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/888/eec/62e/888eec62e9204cbf8d1a1cfead60455b.jpg"><br>  <i>We bring to your attention a translation of the first part of a useful article on how to develop transactional business applications using a microservice architecture.</i> <br><br>  <a href="http://microservices.io/patterns/microservices.html">Microservice architecture</a> is becoming increasingly popular.  This is a modular approach in which the application is functionally divided into separate services.  As a result, developers of large and complex applications can quickly produce high-quality software.  With this approach, it is easier for them to master new technologies, as it becomes possible to implement each individual service using the most appropriate and modern technology stack.  Microservice architecture also improves the scalability of applications due to the ability to deploy each individual service on the equipment that is optimal for it. <br><br>  However, microservices are not so simple and universal solution.  In particular, domain models, transactions, and queries are remarkably resistant to separation along a functional basis.  As a result, the development of transactional business applications using the microservice architecture is quite a challenge.  In this article, we will look at how to develop microservices, in which these problems are solved using a domain-based design pattern (Domain Driven Design), Event Sourcing, and CQRS. <br><a name="habracut"></a><br>  Key points: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Microservice architecture functionally divides the application into separate services, each of which corresponds to a specific business object or business process. </li><li>  One of the key problems in the development of microservice-oriented applications is that transactions, domain models (Domain models) and requests "resist" the division into separate services. </li><li>  A domain model can be decomposed into aggregates (Aggregates) within the framework of the Domain Driven Design design pattern. </li><li>  Each service is a domain model consisting of one or more DDD aggregates. </li><li>  As part of the service, each transaction creates or updates a single aggregate. </li><li>  Events are used to maintain consistency between the aggregates (and services). </li></ul><br>  Let's first look at the problems that developers face when creating microservices. <br><br><h2>  Problems of development of microservices </h2><br>  Modularity is important when developing large and complex applications. <br>  Most modern applications are too large to be created by one developer.  In addition, they are too complex to be fully understood by one person.  The application should be divided into modules that are developed by a whole team of developers.  In a monolithic application, modularity is determined by the constructs of the programming language used, for example, Java packages.  Such an approach, as a rule, does not work well in practice.  Long-lived monolithic applications usually degenerate into what is known as the <a href="https://en.wikipedia.org/wiki/Big_ball_of_mud">Big balls of mud anti-pattern</a> . <br><br>  Microservice architecture uses service as a unit of modularity.  Each service is a separate business process or business object that does something to produce a specific result.  For example, an online store using this architecture could consist of such microservices as the Order Service, Customer Service, Catalog Service, etc. <br><br><img src="https://habrastorage.org/files/6f3/3a2/c85/6f33a2c858d4434096637a300e0923fa.jpg"><br><br>  Each service has clear boundaries, due to which it is much easier to maintain the modularity of the application for a long time.  Microservice architecture has other advantages, including the ability to deploy and scale services independently. <br><br>  Unfortunately, dividing the application into services is not as easy as it seems.  As mentioned earlier, several different aspects of the applications ‚Äî domain models, transactions, and queries ‚Äî are difficult to break down.  Let's look at the causes of these difficulties. <br><br><h2>  Problem number 1: The separation of the domain model </h2><br>  The domain model pattern ( <a href="https://martinfowler.com/eaaCatalog/domainModel.html">Domain model</a> ) is a good way to implement complex business logic.  The domain model for the online store will include classes such as <i>Order</i> , <i>Order</i> <i>Item</i> , <i>Customer</i> , <i>Product</i> .  In the microservice architecture, the <i>Order</i> and <i>Order</i> <i>Position</i> classes are part of the <i>Order</i> service, the <i>Client</i> class is part of the <i>Client</i> service, and the <i>Goods</i> class belongs to the <i>Catalog</i> service. <br><br><img src="https://habrastorage.org/files/074/c43/012/074c4301260641158abeba76e61099ef.jpg"><br><br>  The problem with dividing the domain model into services is that classes often refer to each other.  For example, the <i>Order</i> refers to the <i>Client</i> who made it, and the <i>Order Items</i> refer to the <i>Goods</i> .  What to do with links that violate the boundaries of services?  Later we will see how the concept of aggregate (Aggregate) from DDD ( <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Domain Driven Design</a> ) solves this problem. <br><br><h2>  Microservices and databases </h2><br>  A distinctive feature of the microservice architecture is that the data belonging to the service is available only through the API of this service.  For example, in the online store, Service Orders has a database that includes the ORDERS table, and Customer Service has its own database, which includes the CUSTOMERS table.  Because of this encapsulation, services are loosely coupled, and the developer can change the scheme of his service without having to coordinate with developers working on other services.  During application execution, services are isolated from each other.  For example, a service will never wait for the end of blocking of a database belonging to another service.  On the other hand, the functional separation of the database makes it difficult to maintain the integrity of the data, as well as the implementation of many types of queries. <br><br><h2>  Problem number 2: Transactions </h2><br>  A traditional monolithic application can rely on <a href="https://ru.wikipedia.org/wiki/ACID">transactions</a> to enforce business rules.  Imagine, for example, that online store customers have a credit limit, which must be verified before creating a new order.  The application must ensure that several simultaneous attempts to place an order do not exceed the client's credit limit.  If orders and customers are in the same database, then a trivial solution is to use a transaction (with the appropriate isolation level): <br><br><pre><code class="bash hljs">BEGIN TRANSACTION ‚Ä¶ SELECT ORDER_TOTAL FROM ORDERS WHERE CUSTOMER_ID = ? ‚Ä¶ SELECT CREDIT_LIMIT FROM CUSTOMERS WHERE CUSTOMER_ID = ? ‚Ä¶ INSERT INTO ORDERS ‚Ä¶ ‚Ä¶ COMMIT TRANSACTION</code> </pre> <br>  Unfortunately, we cannot use such a simple approach to maintain data consistency with a microservice-oriented approach.  The ORDERS and CUSTOMERS tables belong to different services and can only be accessed via the API.  They may even be in different databases. <br><br>  In this case, the traditional solution will be <a href="https://en.wikipedia.org/wiki/Distributed_transaction">distributed transactions</a> , but for modern applications this is not the appropriate technology.  <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP">The CAP theorem</a> requires the developer to choose between availability (Availability) and data consistency (Consistency), and availability is usually the preferred choice.  In addition, many modern technologies, such as most NoSQL databases, do not even support ordinary transactions, let alone distributed ones.  Maintaining integrity is important, so we need another solution.  Below we will see that the solution is to use event-oriented (event-driven, message-driven) architecture based on event sourcing. <br><br><h2>  Problem number 3: Requests to the database </h2><br>  Along with maintaining data integrity, queries to the database are also a problem.  In traditional monolithic applications, queries using joins are extremely common.  For example, you can easily find newly registered customers and their large orders using the query: <br><br><pre> <code class="bash hljs">SELECT * FROM CUSTOMER c, ORDER o WHERE c.id = o.ID AND o.ORDER_TOTAL &gt; 100000 AND o.STATE = <span class="hljs-string"><span class="hljs-string">'SHIPPED'</span></span> AND c.CREATION_DATE &gt; ?</code> </pre> <br>  We cannot use this type of request in a microservice-based online store.  As mentioned earlier, the ORDERS and CUSTOMERS tables belong to different services and can only be accessed via the API.  Some services may not even use a SQL database.  But you can use an approach known as Event Sourcing, which makes finding information even more challenging. <br><br>  Next, we see that the solution is to preserve <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">materialized views</a> using an approach known as Command Query Responsibility Segregation (CQRS).  But first, let's consider the issue of Domain-Driven Design (DDD) when developing microservices. <br><br><h2>  DDD units as microservice building blocks </h2><br>  As you can see, there are several problems that need to be solved for the sake of successful application development using microservices.  A solution to some of these problems can be found in Eric Evans's ‚Äú <a href="http://domainlanguage.com/ddd/reference/">Domain-Driven Design</a> ‚Äù, a must-read book.  It describes the approach to the design of complex software, which is very useful in the development of microservices.  In particular, Domain-Driven Design allows you to create a modular domain model that can be distributed across services. <br><br><h3>  What are units? </h3><br>  In Domain-Driven Design, Evans defines several building blocks for domain models.  Many of them have become part of the everyday language of developers, including Entity, Value object, Service, Repository, etc.  However, one building block ‚Äî the unit ‚Äî was largely ignored by the developers, with the exception of DDD-purists.  But it turns out that aggregates are the key to the development of microservices. <br><br>  An aggregate is a cluster of domain objects that can be considered as a whole.  It consists of the root entity object (Entity) and, possibly, one or more other related entity objects and value objects (Value Object).  For example, the domain model for an online store contains such aggregates as <i>Order</i> and <i>Customer</i> .  <i>An Order</i> unit consists of the <i>Order</i> root entity, one or more value objects Order position along with other value objects, such as <i>Cost</i> , <i>Delivery Address,</i> and <i>Billing Details</i> .  The <i>Client</i> unit consists of a <i>Client</i> entity and several value objects, such as <i>Delivery</i> <i>Information and Payment Information</i> . <br><br><img src="https://habrastorage.org/files/c8e/edb/e65/c8eedbe65838414b9c2b7c2803d37794.jpg"><br><br>  The use of aggregates divides the domain model into pieces that are easier to understand separately.  It also defines a set of operations, such as load and delete.  An aggregate is usually loaded from the entire database.  Removing an aggregate deletes all objects.  The advantage of aggregates, however, goes far beyond the limits of the modularity of the domain model, because aggregates must obey certain rules. <br><br><h3>  Inter-unit communications should use primary keys. </h3><br>  The first rule is that aggregates always refer to each other through a unique identifier (for example, the primary key) instead of direct references to objects.  For example, an <i>Order</i> refers to its <i>Customer</i> using the CustomerId, and not a reference to a customer object.  Similarly, an <i>Order</i> <i>Item</i> refers to a <i>Product</i> using the ProductID. <br><br><img src="https://habrastorage.org/files/ee5/bb1/931/ee5bb193110046129070152eb0760b72.jpg"><br><br>  This approach is very different from the traditional, in which foreign keys in the domain model are considered bad practice.  Using an identifier, rather than an object reference, means that the aggregates are loosely coupled.  You can easily place different units in different services.  In fact, the business logic of a service consists of a domain model, which is a set of aggregates.  For example, OrderService contains the <i>Order</i> aggregate, and CustomerService contains the Customer aggregate. <br><br><h3>  One transaction creates or updates one aggregate. </h3><br>  The second rule is that a transaction can create or update only one aggregate.  When I first read about this rule many years ago, it made no sense!  At that time, I was developing traditional monolithic applications based on RDBMS, and therefore transactions could update arbitrary data.  Today, this restriction is ideal for microservice architecture.  This ensures that the transaction is contained within the service.  This restriction also corresponds to the transaction restrictions of most NoSQL databases. <br><br>  When developing a domain model, the key is to decide how large each specific unit needs to be made.  Ideally, the units should be small.  This improves modularity by sharing responsibility.  This is more efficient since the units are usually loaded completely.  In addition, since the update of each unit occurs sequentially, the use of smaller units will increase the number of simultaneous requests that the application can handle, and thereby improve scalability.  It also reduces the likelihood that two users will try to upgrade the same unit at the same time. <br><br>  On the other hand, since an aggregate is the business of a transaction, you may need to define an aggregate larger to make a specific update atomic. <br><br>  For example, the above states that in the domain model of the online store, <i>Order</i> and <i>Customer</i> are separate aggregates.  An alternative is to make the <i>Order</i> part of the <i>Customer</i> unit.  The advantage of a large aggregate <i>Client</i> is that the application will be able to atomically check the credit limit.  The disadvantage of the approach is that it combines the functionality of the <i>Order</i> and the <i>Client</i> in the same service.  This reduces scalability, since transactions that update different orders of the same customer cannot be executed in parallel.  In addition, two users may come into conflict if they try to edit different orders of the same customer.  With an increase in the number of orders, loading the machine will become more and more expensive.  Because of these problems, it is better to make the units as small as possible. <br><br>  Even complying with the requirement to create or update a transaction with only one aggregate, applications still need to maintain consistency between aggregations.  For example, the <i>Order</i> service must verify that the new <i>order</i> does not exceed the aggregate credit limit of the customer.  There are several different ways to maintain consistency.  One option is to trick the application and create / update multiple aggregates in a single transaction.  This is possible only when all units belong to the same service and are stored in the same RDBMS.  Another more correct option is to maintain consistency between the aggregates using an event-based approach. <br><br><h2>  Using events to maintain data consistency </h2><br>  In the modern application there are various restrictions on transactions that make it difficult to maintain the consistency of data in services.  Each service has its own data, but using distributed transactions is not a viable option.  In addition, many applications use NoSQL databases, which do not even support ordinary local transactions, not to mention distributed ones.  Therefore, a modern application must use an event-driven transaction model known as Eventually Consistent. <br><br><h3>  What is an event? </h3><br>  As the <a href="https://www.merriam-webster.com/dictionary/event">Merriam-Webster dictionary</a> (and Captain Obvious) says, an ‚Äúevent‚Äù is what happens (happens): <br><br><img src="https://habrastorage.org/files/5e2/d54/d8d/5e2d54d8d06547ddaf1ccc7496dd1d45.jpg"><br><br>  In this article, we define a Domain Event (Domain Event) as what happened to the aggregate.  An event is usually a state change.  Consider, for example, an <i>Order</i> unit.  Events that change its state include <i>Order created</i> , <i>Order canceled</i> , <i>Order sent</i> .  Events may constitute attempts to violate business rules, for example, the <i>Client‚Äôs</i> credit limit. <br><br><h3>  Using Event-Driven Architecture </h3><br>  Services use events to ensure consistency between the aggregates as follows: the aggregate publishes an event whenever something noticeable happens.  For example, its state is changing, or there is an attempt to violate a business rule.  Other aggregates subscribe to an event and respond to it by updating their own state. <br><br>  The online store checks the client's credit limit when creating an order using the following sequence of steps: <br><br><ol><li>  The <i>Order</i> aggregate, which is created with the NEW status, publishes an OrderCreated event. </li><li>  Aggregate The <i>client</i> receives notification of the OrderCreated event, reserves a loan for the order and publishes a CreditReserved event. </li><li>  The <i>Order</i> unit receives a CreditReserved event notification and changes its status to APPROVED. </li></ol><br>  If the credit check fails due to a lack of funds, the <i>client</i> unit posts a CreditLimitExceeded event.  This event does not reflect a state change, but is an unsuccessful attempt to violate business rules.  The <i>Order</i> unit receives notification of this event and changes its status to CANCELED. <br><br><h2>  Microservice architecture as a network of event-driven aggregates </h2><br>  In this architecture, the business logic of each service consists of one or more units.  Each transaction performed by the service updates or creates a single aggregate.  Services maintain consistency of data between aggregates through events. <br><br><img src="https://habrastorage.org/files/586/c51/2fc/586c512fc44d4bdd8a48852392964991.jpg"><br><br>  A distinctive feature of the approach is that the units are loosely connected building blocks.  They can be deployed as a monolithic application, and as a set of individual services.  At the beginning of the project you could use a monolithic architecture.  And later, with the growing size of the application and the development team, you can easily switch to the microservice architecture. <br><br><h2>  Summary </h2><br>  Microservice architecture functionally divides an application into services, each of which corresponds to a specific business object or business process.  One of the main problems in developing microservice business applications is that transactions, domain models and queries oppose the division into services.  You can separate the domain model by applying the ‚Äúaggregate‚Äù concept from Domain Driven Design.  The business logic of each service is a domain model consisting of one or more DDD aggregates. <br><br>  Within each service, a transaction creates or updates a single aggregate.  Since distributed transactions are not a viable technology for modern applications, events are used to maintain consistency between the aggregates (and services). <br><br>  In the second part of the article, we will look at how to implement a robust, event-driven architecture using Event Sourcing, as well as how to implement requests in the microservice architecture using CQRS. </div><p>Source: <a href="https://habr.com/ru/post/321686/">https://habr.com/ru/post/321686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321674/index.html">How does the FIFO work</a></li>
<li><a href="../321676/index.html">FPGA for the programmer, simple recipes</a></li>
<li><a href="../321678/index.html">Laravel 5. Hierarchical RBAC for the smallest</a></li>
<li><a href="../321682/index.html">Login to the site using Telegram</a></li>
<li><a href="../321684/index.html">Zeigarnik effect in practice</a></li>
<li><a href="../321688/index.html">‚ÄúLike an Iceberg in the Ocean‚Äù: Data Center Cooling Technologies</a></li>
<li><a href="../321690/index.html">Iterative Design and GitHub</a></li>
<li><a href="../321692/index.html">Distributed xargs, or Execution of Heterogeneous Applications on Hadoop Cluster</a></li>
<li><a href="../321694/index.html">Personal experience: Raiffeisen, Alfa-Bank and VTB24</a></li>
<li><a href="../321696/index.html">Remotely reinstalling Linux via ssh without accessing the console</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>