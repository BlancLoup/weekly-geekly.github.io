<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IL2CPP: P / Invoke wrappers for types and methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the sixth article in the IL2CPP series . This time we will see how il2cpp.exe generates wrappers for methods and types that are necessary for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IL2CPP: P / Invoke wrappers for types and methods</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/046/ae5/933/046ae59335e845abbfec4553d3ada106.jpg"><br><br>  This is the sixth article <a href="https://blogs.unity3d.com/ru/2015/05/06/an-introduction-to-ilcpp-internals/">in the IL2CPP series</a> .  This time we will see how il2cpp.exe generates wrappers for methods and types that are necessary for the interaction of managed and native code.  In particular, we will discuss the difference between non-convertible and convertible types, deal with the marshaling of strings and arrays and talk about the cost of marshaling. <br><a name="habracut"></a><br>  At one time, I wrote a lot of code for the interaction of managed and native code, but creating the right p / invoke ad in C # is still a daunting task for me, to put it mildly.  Understanding how the runtime marshaling objects marshals is even more difficult.  Since the IL2CPP technology does most of the marshaling in the generated C ++ code, we can view (and even debug) its behavior, providing ourselves with a better understanding of internal relationships for more efficient performance analysis and troubleshooting. <br><br>  I did not set out to provide in this article general information about marshaling and native interaction, since this is too broad a topic even for a separate publication.  The Unity documentation describes how <a href="https://docs.unity3d.com/Manual/NativePlugins.html">native plugins</a> interact with Unity.  But <a href="http://www.mono-project.com/docs/advanced/pinvoke/">Mono</a> and <a href="https://msdn.microsoft.com/en-us/library/aa446536.aspx">Microsoft</a> provide enough comprehensive information about p / invoke as a whole. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As in the previous articles of this series, we will again work with the code that may change in the future and, most likely, will really change in the newer version of Unity.  Anyway, the basic concepts of this will not change.  Please consider all the material in this series as implementation details.  We like to openly discuss such details when it is possible. <br><br><h2>  Preparation for work </h2><br>  I work in Unity version 5.0.2p4 on OSX and I will create an assembly for the iOS platform, using the Architecture value for Universal.  For this example, I created native code using Xcode 6.3.2 as a static library for ARMv7 and ARM64. <br><br>  Native code looks like this: <br><br><pre><code class="cpp hljs">[cpp] <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstring&gt; #include &lt;cmath&gt; extern "C" { int Increment(int i) { return i + 1; } bool StringsMatch(const char* l, const char* r) { return strcmp(l, r) == 0; } struct Vector { float x; float y; float z; }; float ComputeLength(Vector v) { return sqrt(vx*vx + vy*vy + vz*vz); } void SetX(Vector* v, float value) { v-&gt;x = value; } struct Boss { char* name; int health; }; bool IsBossDead(Boss b) { return b.health == 0; } int SumArrayElements(int* elements, int size) { int sum = 0; for (int i = 0; i &lt; size; ++i) { sum += elements[i]; } return sum; } int SumBossHealth(Boss* bosses, int size) { int sum = 0; for (int i = 0; i &lt; size; ++i) { sum += bosses[i].health; } return sum; } } [/cpp]</span></span></span></span></code> </pre> <br>  The script code in Unity is still contained in the HelloWorld.cs file.  It looks like this: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">csharp</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format (<span class="hljs-string"><span class="hljs-string">"Using a blittable argument: {0}"</span></span>, Increment (<span class="hljs-number"><span class="hljs-number">42</span></span>))); Debug.Log (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format (<span class="hljs-string"><span class="hljs-string">"Marshaling strings: {0}"</span></span>, StringsMatch (<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, <span class="hljs-string"><span class="hljs-string">"Goodbye"</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector (<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">3.0f</span></span>); Debug.Log (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format (<span class="hljs-string"><span class="hljs-string">"Marshaling a blittable struct: {0}"</span></span>, ComputeLength (vector))); SetX (<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> vector, <span class="hljs-number"><span class="hljs-number">42.0f</span></span>); Debug.Log (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format (<span class="hljs-string"><span class="hljs-string">"Marshaling a blittable struct by reference: {0}"</span></span>, vector.x)); Debug.Log (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format (<span class="hljs-string"><span class="hljs-string">"Marshaling a non-blittable struct: {0}"</span></span>, IsBossDead (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Boss(<span class="hljs-string"><span class="hljs-string">"Final Boss"</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)))); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] values = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; Debug.Log(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Marshaling an array: {0}"</span></span>, SumArrayElements(values, values.Length))); Boss[] bosses = {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Boss(<span class="hljs-string"><span class="hljs-string">"First Boss"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Boss(<span class="hljs-string"><span class="hljs-string">"Second Boss"</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>)}; Debug.Log(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Marshaling an array by reference: {0}"</span></span>, SumBossHealth(bosses, bosses.Length))); } [/csharp]</code> </pre><br>  Each of the method calls in this code is executed on the above native code.  Next we look at the declaration of the managed method for each method. <br><br><h2>  Why do I need to marshall? </h2><br>  If IL2CPP immediately generates C ++ code, then why marshall from C # to C ++?  Despite the fact that the code generated in C ++ is native code, the representation of types in C # differs in some cases from the representation in C ++.  The IL2CPP runtime must be able to convert type representations to both sides.  The il2cpp.exe utility does this for both types and methods. <br><br>  In managed code, all types can be divided into two categories: <a href="https://msdn.microsoft.com/ru-ru/library/75dwhxf7%2528v%3Dvs.100%2529.aspx">non-convertible and convertible</a> .  Non-convertible types have the same representation in both managed and native code (for example, byte, int, float).  In turn, the converted types are represented in both cases differently (for example, the types bool, string, array).  Non-translatable types as such can be passed to the native code directly, but for translatable types, this requires a prior conversion.  Often, such a conversion requires new memory allocation. <br><br>  To tell the managed code compiler that this method is implemented in native code, the extern keyword is used in C #.  This keyword, along with the DllImport attribute, allows the managed code runtime to find the definition of the native method and call it.  The il2cpp.exe utility generates a wrapper for the C ++ method for each extern method.  This wrapper performs several important tasks: <br><br><ul><li>  defines a typedef for a native method that is used to invoke a method through a function pointer; </li><li>  resolves the native method by name, passing a function pointer to this method; </li><li>  converts the arguments from their managed representation to the native representation (if necessary); </li><li>  calls the native method; </li><li>  converts the return value of a method from its native representation to a managed one (if necessary); </li><li>  converts any ref or out argument from their native representation to a managed one (if necessary). </li></ul><br>  Next we look at the generated method wrappers for some declarations of extern methods. <br><br><h2>  Non-convertible marshaling </h2><br>  The simplest type of extern wrapper deals only with non-convertible types. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">csharp</span></span>] [DllImport(<span class="hljs-string"><span class="hljs-string">"__Internal"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span>; [/csharp]</code> </pre><br>  In the Bulk_Assembly-CSharp_0.cpp file, find the string ‚ÄúHelloWorld_Increment_m3‚Äù.  The wrapper function for the Increment method looks like this: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> <span class="hljs-function"><span class="hljs-function">DEFAULT_CALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> HelloWorld_Increment_m3 (Object_t * __this <span class="hljs-comment"><span class="hljs-comment">/* static, unused */</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> ___value, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MethodInfo* method) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32_t</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEFAULT_CALL *PInvokeFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PInvokeFunc _il2cpp_pinvoke_func; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_il2cpp_pinvoke_func) { _il2cpp_pinvoke_func = (PInvokeFunc)Increment; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_il2cpp_pinvoke_func == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { il2cpp_codegen_raise_exception(il2cpp_codegen_get_not_supported_exception(<span class="hljs-string"><span class="hljs-string">"Unable to find method for p/invoke: 'Increment'"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> _return_value = _il2cpp_pinvoke_func(___value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _return_value; } [/cpp]</code> </pre><br>  First, specify a typedef for the native function signature: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32_t</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEFAULT_CALL *PInvokeFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; [/cpp]</code> </pre><br>  Something similar will appear in each wrapper function.  This native function takes a single int32_t value and returns an int32_t. <br><br>  The wrapper then finds the appropriate function pointer and stores it in a static variable: <br><br><pre> <code class="cpp hljs">[cpp] _il2cpp_pinvoke_func = (PInvokeFunc)Increment; [/cpp]</code> </pre><br>  Here, the Increment function comes from the extern operator (in C ++ code): <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> <span class="hljs-function"><span class="hljs-function">DEFAULT_CALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;} [/cpp]</code> </pre><br>  In iOS, native methods are statically bound to a single binary representation (indicated by the string ‚Äú__Internal‚Äù in the DllImport attribute), so the IL2CPP runtime does nothing to find a function pointer.  Instead, this extern operator notifies the linker in order to find a suitable function at the time of linking.  On other platforms, the IL2CPP runtime can search (if necessary) using the platform-dependent API method to find the pointer to this function. <br><br>  In practice, this means that <b>on iOS, the incorrect p / invoke signature in the managed code will appear as a linker error in the generated code</b> .  This error does not appear at run time.  Therefore, all p / invoke signatures must be correct, even if they are not used at run time. <br><br>  Finally, the native method is invoked through a function pointer, and the return value is returned.  Note that the argument is passed to the native function by value, therefore, it is clear that any changes to this value in the native code will not be available in the managed code. <br><br><h2>  Marshaling type convertible </h2><br>  With a convertible type, such as string, this is a bit more interesting.  As mentioned in <a href="https://blogs.unity3d.com/ru/2015/05/20/il2cpp-internals-debugging-tips-for-generated-code/">one</a> of the previous publications, strings in IL2CPP are represented as an array of two-byte characters, encrypted with UTF-16, and prefixed with a four-byte value.  This view does not match either the char * view or wchar_t * in C on iOS, so we will have to do the conversion.  Take a look at the StringsMatch method (HelloWorld_StringsMatch_m4 in the generated code): <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">csharp</span></span>] DllImport(<span class="hljs-string"><span class="hljs-string">"__Internal"</span></span>)] [<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: MarshalAs(UnmanagedType.U1)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringsMatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[MarshalAs(UnmanagedType.LPStr</span></span></span><span class="hljs-function">)]</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> l, [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MarshalAs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnmanagedType.LPStr</span></span></span><span class="hljs-function">)]</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> r)</span></span>; [/csharp]</code> </pre><br>  As you can see, each string argument will be converted to char * (due to the UnmangedType.LPStr directive). <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint8_t</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEFAULT_CALL *PInvokeFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; [/cpp]</code> </pre><br>  The conversion looks like this (for the first argument): <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ____l_marshaled = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; ____l_marshaled = il2cpp_codegen_marshal_string(___l); [/cpp]</code> </pre><br>  A new char buffer of suitable length is placed in memory, and the contents of the string are copied to the new buffer.  Of course, after calling the native method, we will need to clear these allocated buffers: <br><br><pre> <code class="cpp hljs">[cpp] il2cpp_codegen_marshal_free(____l_marshaled); ____l_marshaled = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; [/cpp]</code> </pre><br>  Therefore, marshaling such a convertible type as a string can be expensive. <br><br><h2>  Custom type marshaling </h2><br>  With simple types like int and string, everything is clear, but what about more complex, custom types?  Suppose we want to marshal the Vector structure from the example above, which contains three float values.  It turns out that a <b>user type is non-convertible only when all its fields are non-convertible</b> .  Therefore, we can call ComputeLength (HelloWorld_ComputeLength_m5 in the generated code) without the need to convert the argument: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEFAULT_CALL *PInvokeFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector_t1 )</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// I've omitted the function pointer code. float _return_value = _il2cpp_pinvoke_func(___v); return _return_value; [/cpp]</span></span></code> </pre><br>  Notice that the argument is passed by value - just as it was in the original example, when the argument type was int.  If we want to change the Vector instance and see these values ‚Äã‚Äãin the managed code, we need to pass it by reference, as in the SetX method (HelloWorld_SetX_m6): <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEFAULT_CALL *PInvokeFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vector_t1 *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Vector_t1 * ____v_marshaled = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; Vector_t1 ____v_marshaled_dereferenced = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; ____v_marshaled_dereferenced = *___v; ____v_marshaled = &amp;____v_marshaled_dereferenced; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _return_value = _il2cpp_pinvoke_func(____v_marshaled, ___value); Vector_t1 ____v_result_dereferenced = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; Vector_t1 * ____v_result = &amp;____v_result_dereferenced; *____v_result = *____v_marshaled; *___v = *____v_result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _return_value; [/cpp]</code> </pre><br>  Here, the Vector argument is passed as a pointer to the native code.  The generated code is a bit confused, but in essence it is the creation of a local variable of the same type, copying the value of the argument locally, then calling the native method with a pointer to this local variable.  After the native function returns, the value in the local variable is copied back into the argument, and this value is then available in the managed code. <br><br><h2>  Marshaling convertible user type </h2><br>  Marshaling a convertible custom type, such as the Boss type defined above, is also possible, but this will require a little more work.  To do this, you must marshal each field of a given type to their native representation.  In addition, the generated C ++ code must have a representation of a managed type that matches the representation in the native code. <br><br>  Consider the extern declaration of IsBossDead: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">csharp</span></span>] [DllImport(<span class="hljs-string"><span class="hljs-string">"__Internal"</span></span>)] [<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: MarshalAs(UnmanagedType.U1)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsBossDead</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Boss b</span></span></span><span class="hljs-function">)</span></span>; [/csharp]</code> </pre><br>  The wrapper for this method is called HelloWorld_IsBossDead_m7: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HelloWorld_IsBossDead_m7</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object_t * __this </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* static, unused */</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Boss_t2 ___b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodInfo* method)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint8_t</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEFAULT_CALL *PInvokeFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Boss_t2_marshaled)</span></span></span></span>; Boss_t2_marshaled ____b_marshaled = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; Boss_t2_marshal(___b, ____b_marshaled); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> _return_value = _il2cpp_pinvoke_func(____b_marshaled); Boss_t2_marshal_cleanup(____b_marshaled); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _return_value; } [/cpp]</code> </pre><br>  The argument is passed to the wrapper function as the type Boss_t2, which is the generated type for the Boss structure.  Please note that it is passed to a native function with a different type: Boss_t2_marshaled.  If we proceed to the definition of this type, we will see that it coincides with the definition of the Boss structure in our static C ++ library code: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Boss_t2_marshaled</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ___name_0; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> ___health_1; }; [/cpp]</code> </pre><br>  We again used the UnmanagedType.LPStr directive in C # to indicate that the string field should be marshaled as char *.  <b>If you are debugging a problem with a custom type being converted, it will be very useful for you to look at this _marshaled structure in the generated code.</b>  If the field layout does not match the native side, then the marshaling directive in the managed code may be incorrect. <br><br>  The Boss_t2_marshal function is a generated function that marshals each field, and Boss_t2_marshal_cleanup frees all memory allocated during this marshaling process. <br><br><h2>  Array marshaling </h2><br>  Finally, consider marshaling of arrays of translatable and non-translatable types.  The array of integers is passed to the SumArrayElements method: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">csharp</span></span>] [DllImport(<span class="hljs-string"><span class="hljs-string">"__Internal"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SumArrayElements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] elements, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span>; [/csharp]</code> </pre><br>  This is a marshalized array, but since the array element type (int) is non-convertible, the marshaling cost will be very small: <br><br><pre> <code class="cpp hljs">[cpp] <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span>* ____elements_marshaled = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; ____elements_marshaled = il2cpp_codegen_marshal_array&lt;<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span>&gt;((Il2CppCodeGenArray*)___elements); [/cpp]</code> </pre><br>  The il2cpp_codegen_marshal_array function simply returns a pointer to the memory of an existing managed array, that's all. <br><br>  However, marshaling an array of translatable types requires much more resources.  The SumBossHealth method passes an array of Boss instances: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">csharp</span></span>] [DllImport(<span class="hljs-string"><span class="hljs-string">"__Internal"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SumBossHealth</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Boss[] bosses, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span>; [/csharp]</code> </pre><br>  Its wrapper should allocate memory for the new array, and then perform the marshaling of each element separately: <br><br><pre> <code class="cpp hljs">[cpp] Boss_t2_marshaled* ____bosses_marshaled = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ____bosses_Length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (___bosses != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ____bosses_Length = ((Il2CppCodeGenArray*)___bosses)-&gt;max_length; ____bosses_marshaled = il2cpp_codegen_marshal_allocate_array&lt;Boss_t2_marshaled&gt;(____bosses_Length); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ____bosses_Length; i++) { Boss_t2 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; item = *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;Boss_t2 *&gt;(SZArrayLdElema((Il2CppCodeGenArray*)___bosses, i)); Boss_t2_marshal(item, (____bosses_marshaled)[i]); } [/cpp]</code> </pre><br>  Of course, all allocated memory is cleared after the call to the native method completes. <br><br><h2>  Conclusion </h2><br>  The IL2CPP scripting technology supports the same marshaling behavior as Mono scripting technology.  Since IL2CPP produces generated wrappers for types and extern methods, we have the opportunity to see the cost of calls from managed code to native.  As a rule, this cost is not very high for non-convertible types, but in the case of convertible types, the cost of interaction can be very high.  However, our review was rather superficial.  You can spend more time exploring the generated code and see how it is marshaled for return values ‚Äã‚Äãand output parameters, native function pointers and managed delegates, as well as custom pointer types. <br><br>  Next time we'll talk about integrating the IL2CPP with the garbage collector. </div><p>Source: <a href="https://habr.com/ru/post/323932/">https://habr.com/ru/post/323932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323922/index.html">The saga is about how Java developers should test their applications. Part 2</a></li>
<li><a href="../323924/index.html">Autism - programming geeks: the destruction of myths</a></li>
<li><a href="../323926/index.html">Prototype table in Axure</a></li>
<li><a href="../323928/index.html">All programmers get into # TAI</a></li>
<li><a href="../323930/index.html">On the market, a cow man sold</a></li>
<li><a href="../323934/index.html">How to make a sidebar in 5 lines of code</a></li>
<li><a href="../323936/index.html">Do hint services suggest well? We measure the usefulness of autocompletion web services</a></li>
<li><a href="../323938/index.html">No free lunch. Introduction to participation in data analysis competitions on the Kaggle platform</a></li>
<li><a href="../323940/index.html">Kanban in engineering product management</a></li>
<li><a href="../323942/index.html">Go digest Events, articles, interesting projects from the world of Go [March 1 - 14, 2017]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>