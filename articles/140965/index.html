<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization for CPU: how to find a black cat in a dark room</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Invalid operation method: 
 Divide the cat by zero, 
 after which it will become infinitely large, 
 so it will be impossible to miss it. 
 [Absurdope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization for CPU: how to find a black cat in a dark room</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/11e/e16/8c0/11ee168c01683a128f1e2cdd8f0fa604.jpg"><br>  <i>Invalid operation method:</i> <i><br></i>  <i>Divide the cat by zero,</i> <i><br></i>  <i>after which it will become infinitely large,</i> <i><br></i>  <i>so it will be impossible to miss it.</i> <br>  [Absurdopedia] <br><br>  Trying to find a performance problem with relatively simple code, I remembered several absurd methods of solution, described in <a href="http://absurdopedia.wikia.com/wiki/%25D0%259A%25D0%25B0%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE:%25D0%2598%25D1%2581%25D0%25BA%25D0%25B0%25D1%2582%25D1%258C_%25D1%2587%25D1%2591%25D1%2580%25D0%25BD%25D1%2583%25D1%258E_%25D0%25BA%25D0%25BE%25D1%2588%25D0%25BA%25D1%2583_%25D0%25B2_%25D1%2582%25D1%2591%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BD%25D0%25B0%25D1%2582%25D0%25B5">Absurdopedia</a> , for the task of finding a black cat in a dark room.  Oddly enough, the successive use of three methods, which can be found at the link: Pragmatism, the method of dichotomy and the method of spear, helped me a lot. <br><br>  So, we have the task of sequentially swapping bytes in each word of the array (big-endian &lt;-&gt; little-endian) and summing all the words into one (reduction).  Let us leave aside the task of parallelization for the time being, because its solution is close to the trivial one, and so far is of no interest to us. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/a32/4ca/c50/a324cac505e5a001912c082671f715ea.jpg" alt="image"><br><br><a name="habracut"></a><br>  Direct (in the forehead) implementation of the algorithm is usually called naive.  This is probably due to the fact that we, programmers, naively rely on a compiler that will generate, if not optimal, then code close to this, and there will be nothing left to optimize.  However, as we will see later in the disassembler, the compiler produces a fairly simple sequence of instructions, which, in theory, should not cause any special performance problems on the x86 platform. <br><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> init() { <span class="hljs-type"><span class="hljs-type">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1024</span></span>; i++) buf[i] = i; } unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> change_endianess(<span class="hljs-type"><span class="hljs-type">char</span></span> *big) { <span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span> = big[<span class="hljs-number"><span class="hljs-number">0</span></span>]; big[<span class="hljs-number"><span class="hljs-number">0</span></span>] = big[<span class="hljs-number"><span class="hljs-number">3</span></span>]; big[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span> = big[<span class="hljs-number"><span class="hljs-number">1</span></span>]; big[<span class="hljs-number"><span class="hljs-number">1</span></span>] = big[<span class="hljs-number"><span class="hljs-number">2</span></span>]; big[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> *)big; } <span class="hljs-type"><span class="hljs-type">void</span></span> reduce() { <span class="hljs-type"><span class="hljs-type">int</span></span> i, n; unsigned <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; init(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; ITER_NUM; n++){//repeat itarations <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1024</span></span>; i++){ sum += change_endianess((<span class="hljs-type"><span class="hljs-type">char</span></span> *)(buf+i));}} printf ("Sum is %d\n", sum); } main () { reduce(); }</code> </pre> <br><br>  As our witty marketers put it, ‚Äúperformance evaluation without profiling is a fortune telling.‚Äù  Therefore, we run the General Exploration profile in <a href="http://software.intel.com/en-us/articles/intel-vtune-amplifier-xe/">VTune Amplifier XE</a> in order to evaluate how effectively this code is executed on the Core i7 micro-architecture (codename Nehalem).  Do not forget to specify the -Zi and / debug options: inline-debug-info for Intel Compiler (Windows) to save debugging information and information about function lines that were ‚Äúinline‚Äù (how to say in Russian, ‚Äúinlined‚Äù?) .  The latter option is very useful, as it allows VTune Amplifier XE to attribute the values ‚Äã‚Äãof the counters directly along the lines of the nested function.  This is a new feature of VTune;  it can also be turned off so that the results are displayed only opposite the function call. <br><br><img src="http://habrastorage.org/storage3/c59/c7e/3c5/c59c7e3c57d739b5b30119d56b272068.jpg" alt="image"><br><br>  Since the test runs fairly quickly (despite the choice of a sufficiently large number of iterations), it is useful to enable the Allow Multiple Runs option in the VTune project settings, which will cause the tool to run the test several times, collecting the counters in groups.  Otherwise, the counters will be multiplexed, and accuracy may suffer if the test execution time is short. <br><br><img src="http://habrastorage.org/storage3/2a9/cb1/f2e/2a9cb1f2ebddf4a6f7e14bedd6dd8289.jpg" alt="image"><br><br>  From the results it is clear that nothing is clear.  It can be seen that the performance of the execution of the code in the reduce function is quite far from perfect, since CPI = 1.67 is more than 6 times the optimal 0.25.  No, this certainly does not mean that we have the potential to increase the code performance by 6 times, but it would be quite possible to achieve a lower CPI on such a simple cycle.  However, why CPI is high is hard to say.  The Retire Stalls metric is approximately equal to 0.7 and tells us that during the completion of the execution of instructions, there are downtime of the conveyor in 70% of cycles.  The remaining performance indicators, judging by the results of the collected profile, are normal.  Moreover, knowing that in most cases the memory subsystem is the cause of performance problems, you can specifically run Memory Access analysis.  But he will show the same thing - there are no problems with memory.  However, the code is so simple, and the access to memory is so consistent that it wasn‚Äôt even worth starting the memory analysis.  For the same reasons, Branch Analysis will not help us. <br><br>  We start looking for a black cat in a dark room, or rather the cause of a performance failure in the processor microarchitecture. <br><br>  Apply the improved cat search method ‚ÄúPragmatism‚Äù.  Initially, it is necessary to decide what we will get if we find this cat, and whether we should look for it because of this.  What exactly is our potential, help evaluate the metrics <b>Execution Stalls</b> and <b>Retire Stalls</b> . <br><br>  The first mertika of Execution Stalls is the ratio between the values ‚Äã‚Äãof the <b>UOPS_EXECUTED.CORE_STALL_CYCLES</b> counters and the <b>UOPS_EXECUTED.CORE_ACTIVE_CYCLES counters</b> . <br>  The UOPS_EXECUTED.CORE_STALL_CYCLES event counter measures the number of idle cycles in the computational part of the processor pipeline when the Reservation Station does not assign operations to any port. <br><br>  The UOPS_EXECUTED.CORE_ACTIVE_CYCLES event counter, respectively, counts cycles when at least one of the four computing ports and two read / write ports have a micro-op for execution. <br>  The ratio UOPS_EXECUTED.CORE_STALL_CYCLES / (UOPS_EXECUTED.CORE_ACTIVE_CYCLES + UOPS_EXECUTED.CORE_STALL_CYCLES) will allow us to judge how much of the execution time of the function corresponded to the calculator's downtime, and our needs, we need, and we need to be a part of us, we need, and we need to be a part of us, we need to be a part of us, we need to be a part of us, we need to be a part of us, we need to be a part of us, and we need to be a one of us, we need to be a part of us. <br><br>  By the way, the sum of these counters should give the value of the counter of all CPU_CLK_UNHALTED.THREAD cycles.  And VTune uses the UOPS_EXECUTED.CORE_STALL_CYCLES / CPU_CLK_UNHALTED.THREAD ratio to automatically calculate the Execution Stalls metric. <br>  In our case, the ratio is approximately equal to 0.24 (a quarter of the total number of idle cycles), and this means that if we eliminate the downtime, we can potentially increase the capacity of the calculator by at least a quarter - and this is only for one of the four slots. <br><br>  The second metric of Retire Stalls is the ratio between the <b>UOPS_RETIRED.STALL_CYCLES / CPU_CLK_UNHALTED.THREAD values</b> , showing how much of the total number of cycles corresponds to the state when no micro-operations are completed (retired), although theoretically, it could complete up to 4 operations per clock. <br>  This means that at 70% downtime, if we look good for a cat, eliminating the reason for waiting for the execution of operations, we can hope to speed up the program at least 2.3 times. <br>  Using common sense, we conclude that for the sake of such acceleration of the implementation of the algorithm, you can and try. <br><br>  To find where we have a problem, we use the second method of searching for the cat - ‚ÄúThe method of dichotomy‚Äù: we successively divide the room into equal parts, or rather divide the stages of the processor's pipeline into logical parts, where you can try to find the cause of the problem.  This method is well described in the <a href="http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html">Intel¬Æ 64 and IA-32 Architectures Optimization Reference Manual</a> , in the ‚ÄúUsing Performance Monitoring Events‚Äù section as ‚ÄúPerformance Events Drill-Down and Software Tuning Feedback Loop‚Äù.  Here is his somewhat simplified view: <br><br><img src="http://habrastorage.org/storage3/749/c6f/540/749c6f54049a289db2c8720b1bb8dd8a.jpg" alt="image"><br><br>  The essence of the method is to successively separate parts of the conveyor, finding with the help of appropriate counters a place where it is simple, that is, unemployment by the promotion of micro-operations (bottleneck).  Initially, it is necessary to determine whether microinstructions are executed in the pipeline.  If so, does their execution end with success (Retire).  In the case of performing operations that are not terminated by changing the state of the processor (Non-Retired), there is an erroneous prediction and execution of the wrong branch of the program (Bad Speculation).  In our case, we are dealing with downtime of the pipeline, and then it is necessary to measure whether there are problems with the allocation of processor resources (internal registers, buffers, etc.).  If not, it will mean that the processor lacks instructions for execution, and the problem in Frond-End, that is, where instructions are selected from the instruction cache, is decoded and queued for execution.  If so, then the problem is somewhere in the darkest part of the room, called the Back-End, where calculations are made, and where there may be problems with the calculators themselves, as well as with micro-instrumentation scheduling, buffer allocation, waiting for data from the memory, and so on . <br><br>  Determining whether Allocation Stalls is very simple.  It is necessary to look at the meter reading <b>RESOURCE_STALLS.ANY</b> .  Switching viewpoint VTune to Hardvare Event Count and looking at the readings of this counter (a value commensurate with the total number and CPU cycles), we understand that it is the lack of some resources, according to the counter, that can identify the problem in our code. <br><br>  According to Absurdopedia, the method of dichotomy should lead to the division of the room until the cat concentrates to a point.  However, for a processor microarchitecture, the possibilities of the method are not limitless and end at a certain stage.  And here, as well as possible, the ‚ÄúAt random method‚Äù is used - one of the most effective scientific methods, in cases where other, more rigorous and regular methods no longer help. <br>  We need to re-measure all possible counters that diagnose a lack of resources.  They are few, and you just need to replace the extension counter ANY, with specific resources.  For my Core i7 mobile version: RESOURCE_STALLS.LOAD, RESOURCE_STALLS.STORE, RESOURCE_STALLS.ROB_FULL, RESOURCE_STALLS.RS_FULL, RESOURCE_STALLS.OTHER this data can be collected separately, or you can find it in the results of the General Exploration profile.  The total figures hint to us that there is a problem in stopping the conveyor movement due to the filling of the ROB buffer, and the lack of a data recording buffer. <br><br><img src="http://habrastorage.org/storage3/6ab/bce/5b8/6abbce5b8ebb6b0ad1f646d5065966c0.jpg" alt="image"><br><br>  Store Buffer has data stored in memory.  Delays in performing operations will be observed if there are a lot of write instructions that are interspersed with reading.  Reorder Buffer (ROB) contains micro-operations that wait for the completion of the execution, as well as the operations that are performed, which change the state of the processor in the order of their execution (in-order).  It is important to determine when waiting for what instruction the buffer was overflowed by incoming micro-operations and blocked further work of the conveyor. <br><br>  This is where the Source View will help us, along with the Assembly View.  To save space, we will arrange them separately, although they are nearby in VTune. <br><br><img src="http://habrastorage.org/storage3/a48/0b1/2b7/a480b12b7c2a007643aa1d984e7b22be.jpg" alt="image"><br><br>  As can be seen from the value of the CPU_CLK_UNHALTED.TREAD counter, most of the ticks were in the cycle of performing the summation of words, and not on the permutation function.  The data offset to the line of the for loop is somewhat confusing, but it always happens with cycles.  Results related to the body of the cycle may shift to its title if the body of the cycle is small.  To see this, look at the disassembled version of the function. <br><br><img src="http://habrastorage.org/storage3/2a9/494/283/2a94942832872179c4f6de86db61b59d.jpg" alt="image"><br><br>  Basic Block 5 is interesting for us: it is a cycle of executing byte swapping and word summing operations - this is how the compiler generated instructions.  Starting with the address 0x4010d0 to 0x401105, there are instructions for permuting the bytes in the word.  At the address 0x40110s - just the sought instruction for summing the value of a word in the register edx.  Again, due to the skid, the results are displayed on the inc instructions below, which may not take as many ticks.  Interestingly, the same add add instruction collected the most readings from the Resource Stalls counters.  Looking ahead and applying the same Metot at random, we note that by removing the cat from the room, that is, this summing operation, we will know for sure that the room is empty and the problems with Resource Stalls and performance have disappeared. <br><br>  So what is the problem with this instruction, or rather with several micro-operations of which it consists (reading an address, reading data from memory and a summing operation in a register)?  Here, as always, there is one trick: you must either be well aware of the features of the implementation of unloading-loading data in the micro-architecture, or use a slightly different microprocessor.  Instead of our mobile Core i7 (code name Nehalem), we measure on a platform with a Xeon processor or on a processor with the codename Westmere (so to speak, take a room better equipped), in which you can additionally receive a counter <b>LOAD_BLOCK.OVERLAP_STORE</b> .  It will just roll over the add asm instructions.  In general, this counter signals blocked for various reasons micro-operations of data loading (load).  The most common reason for such an alarm is that the load micro-op is blocked by the previous micro-op (store): <br>  - Some bytes of read data were in a previous write operation, and some were not; <br>  - The bytes of the read words are the same as for the previous record, and the word of the record is aligned in size, while reading 1-2 bytes of words not written at the beginning of the record, or 4-8 bytes, and not aligned with the records; <br>  - The read word bytes are the same as for the previous record, but the word of the record is not aligned in size, and the reading is not aligned in the beginning of the word in the record. <br><br>  Now let's take a closer look at the sequence of asm instructions that implement the cycle of permutation of bytes and summation.  Here, nothing else happens than reading a word with the corresponding byte offset from memory to the ebx and ecx registers (time values) and byte writing data from the bottom of the bl and cl registers to memory.  As long as we read and write by memory by memory, there are no problems.  However, we should try to load the whole word from memory (load micro-operation in the add instruction) at the same address of the word as in the previous write operation, how this load operation will be blocked.  The processor cannot transfer the entire word to the read buffer immediately after writing the word in parts - you have to wait.  This problem is called Blocked Loads Due to No Store Forwarding.  Remember it, as it will often occur if you are actively working with bytes inside words. <br><br>  It should be noted that, investigating the problem on this mobile platform, I had to use the Modified At-A-Way Method, since the assembled counters did not explicitly indicate the presence of No Store Forwarding.  We pulled the shrink-version of Nehalem - Westmere microarchitecture or Xeon here;  and the General Exploration profile did not contain an event counter LOAD_BLOCK.OVERLAP_STORE.  The next generation of processors ‚Äî the 2nd generation Intel¬Æ Core ‚Ñ¢ processor codenamed SandyBridge (actually the current generation) ‚Äîcontains a special <b>LD_BLOCKS_STORE_FORWARD</b> counter, which is in the VTune profile of General Exploration for SandyBridge, and which directly points us to the problem. <br><br>  Now it remains to think about how to fix the code and solve the performance problem.  From the description of the reasons for its occurrence, it is clear that it is necessary to do so that the loading of a word from memory does not immediately follow after its byte-writing to the same address.  So, in order to avoid the tasks of searching for ‚Äúthis cat‚Äù in the future, you need to separate the room and the cat: we will carry out the operation of summing the words of the array into a separate cycle. <br><br><pre> <code class="hljs matlab">void reduce() { int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, n; unsigned int sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; init(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; ITER_NUM; n++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) change_endianess((char *)(buf+<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) sum += buf [<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; } printf (<span class="hljs-string"><span class="hljs-string">"Sum is %d\n"</span></span>, sum); }</code> </pre><br><br>  The difference in program execution time can be seen by comparing the results of the profiling. <br><br><img src="http://habrastorage.org/storage3/376/a5b/29e/376a5b29e3f2aec3c7ddc4591326e1b0.jpg" alt="image"><br><br>  One small question remains: why did the function accelerate more than 3 times, whereas in the beginning we determined that idle cycles are only 70 percent?  The fact is that such a number of cycles the processor is idle with this set of instructions used by the compiler.  By separating the byte permutation and summation cycles in the source code, we helped the compiler to automatically vectorize the last cycle, and it replaced the usual scalar summation and read / write instructions with vector SIMD instructions, which are 4 times faster for int32 data on the 32-bit platform. .  Remember the potential calculated by CPI? </div><p>Source: <a href="https://habr.com/ru/post/140965/">https://habr.com/ru/post/140965/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140959/index.html">Dynamic IP from the provider, and port forwarding in iptables</a></li>
<li><a href="../140960/index.html">JavaScript in charts (Part 1)</a></li>
<li><a href="../140962/index.html">MIT experts suggest folding accordion solar panel</a></li>
<li><a href="../140963/index.html">Business in the USA from Russia. Part III. Accounting and taxes</a></li>
<li><a href="../140964/index.html">An overview of the online service for working with accounts Tradeshift.com</a></li>
<li><a href="../140966/index.html">Banim someone else's account on Free-lance.ru</a></li>
<li><a href="../140970/index.html">Alcatel-Lucent's LightRadio: The Death of Traditional Base Stations?</a></li>
<li><a href="../140971/index.html">We will help the person to compare pictures, or about Testing Localization of the application</a></li>
<li><a href="../140973/index.html">Top Favorite Media Articles - Editor's Choice in Google News</a></li>
<li><a href="../140974/index.html">Getting photos from android-smartphone right in html form</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>