<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerating the multiplication of float 4x4 matrices using SIMD</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many years have passed since I met the instructions of MMX, SSE, and later AVX on Intel processors. At one time, they seemed to be some kind of magic ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerating the multiplication of float 4x4 matrices using SIMD</h1><div class="post__text post__text-html js-mediator-article">  Many years have passed since I met the instructions of MMX, SSE, and later AVX on Intel processors.  At one time, they seemed to be some kind of magic against the background of x86 assembler, which has long been something commonplace.  They hooked me so much that a couple of years ago I had the idea to write my own software renderer for one famous game.  What prompted me was the performance these instructions promised.  At some point I even thought about writing about it.  But writing the text turned out to be much more complicated than the code. <br><br>  At that time, I wanted to avoid problems with support on different processors.  I wanted to be able to check my renderer at the maximum available quantity.  I still have friends with old AMD processors, and their ceiling was SSE3.  Therefore, at that time I decided to limit myself to a maximum of SSE3.  This is how a vector mathematical library appeared, a little less than fully implemented on SSE, with a rare inclusion up to SSE3.  However, at some point I wondered what maximum performance I could squeeze out of the processor for a number of critical vector math operations.  One such operation is the multiplication of float 4 by 4 matrices. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/ii/cq/kgiicqemuc5agmypikedjioaogc.jpeg"></div><a name="habracut"></a><br>  Actually, this business decided to do more for fun.  It has long been written and I use matrix multiplication for my software render on SSE and it seems to be enough for me.  But then I decided to see how many clock cycles I can squeeze out in principle from the multiplication of 2 matrices of float4x4.  On my current SSE version it's 16 clocks.  True, the recent transition to <abbr title="Intel Architecture Code Analyzer">IACA</abbr> 3 began to show 19, since I began to write 1 * instead of 0 * on some instructions.  Apparently before it was just a flaw in the analyzer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Briefly about the utilities used </h3><br>  To analyze the code used the well-known utility <a href="https://software.intel.com/en-us/articles/intel-architecture-code-analyzer">Intel Architecture Code Analyzer</a> .  For analysis, I use Haswell (HSW) architecture, as minimal with AVX2 support.  For writing code, it is also very convenient to use: <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide">Intel Intrinsics Guide</a> and <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf">Intel optimization manual</a> . <br><br>  For assembly I use MSVS 2017 Community from the console.  I write the code in the version with intrinsiki.  You write once, and usually it works immediately on different platforms.  In addition, the x64 compiler on VC ++ does not support the inline assembler, but I want it to work under x64. <br><br>  Since this article is already somewhat beyond the beginner level in SIMD programming, I will not describe registers, instructions, draw (or tyrit) beautiful pictures and try to learn to program using SIMD instructions.  The Intel site is full of excellent, clear and detailed documentation. <br><br><h2>  I wanted to make everything easier. ... And it turned out as always </h2><br>  This is where the moment begins, which complicates the implementation as well as the article.  Therefore, a little stop on it.  I am not interested in writing matrix multiplication with standard line-by-line arrangement of elements.  Who was needed, and so studied in universities or independently.  Our goal is performance.  First, I have long moved to the arrangement of the columns.  My software renderer is based on the OpenGL API and therefore, in order to avoid unnecessary transpositions, I began to store elements in columns.  This is also important because matrix multiplication is not so critical.  Well multiplied 2-5-10 matrices.  And that's all.  And then multiply the finished matrix by thousands of millions of vertices.  And this operation is much more critical.  You can, of course, transpose each time.  But why, if this can be avoided. <br><br>  But back to the matrices only.  With storage by columns decided.  However, you can still complicate.  It is more convenient for me to store the highest elements of vectors and matrix rows in SIMD registers so that <strong>x is</strong> in the highest float (index 3), and <strong>w</strong> in the youngest (index 0).  Here, apparently, will have to again make a digression on why so. <br><br>  The fact is that in the software renderer in the vector, the component <strong>w</strong> has to be manipulated more often ( <strong>1 / z</strong> is stored there), and it is very convenient to do this through the <strong>_ss</strong> variant of the operation (operations exclusively with the component in the <em>xmm</em> <strong><nobr>y</nobr></strong> float register), without touching <strong><nobr>x, y, z</nobr></strong> .  Therefore, in the SSE register, the vector is stored in a clear order of <strong><nobr>x, y, z, w</nobr></strong> , and in memory in the opposite <strong><nobr>w, z, y, x</nobr></strong> . <br><br>  Further, all multiplication options are also implemented by separate functions.  This is done because I use them to substitute the necessary variant depending on the type of instructions supported.  <a href="http://www.agner.org/optimize/optimizing_cpp.pdf">Well described here.</a> <br><br><h2>  We implement basic functionality </h2><br><h3>  Multiplication with cycles, row ordered </h3><br><div class="spoiler">  <b class="spoiler_title">Option for line layout of elements</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[i][j] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[i][j] += m[i][k] * n[k][j]; } } }</code> </pre> <br></div></div><br>  Everything is simple and clear.  For each element we make 4 multiplications and 3 additions.  In total, this is 64 multiplications and 48 additions.  And this is without regard to reading the entry elements. <br><br>  Everything is sad, in short.  For this option for the internal cycle, IACA issued: <em>3.65 cycles for the x86 assembly and 2.97 for the x64 assembly</em> .  Do not ask why fractional numbers.  I do not know.  IACA 2.1 did not suffer from this.  In any case, these figures should be multiplied by about 4 * 4 * 4 = 64. Even if you take x64, the result is about 192 cycles.  It is clear that this is an approximate assessment.  I do not see any reason to evaluate the performance for this option more precisely. <br><br><h3>  Implementation with cycles, column ordered </h3><br><div class="spoiler">  <b class="spoiler_title">transpose matrix, swap row and column indexes</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][i] += m[k][i] * n[j][k]; } } }</code> </pre><br></div></div><br><h3>  Cycle multiplication, SIMD oriented storage </h3><br><div class="spoiler">  <b class="spoiler_title">add storage of lines in reverse order in memory</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] += m[k][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] * n[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-k]; } } }</code> </pre><br></div></div><br>  This implementation somewhat simplifies the understanding of what is happening inside, but it is clearly not enough. <br><br><h3>  Helper classes </h3><br>  For ease of understanding and writing reference and debugging code, it is convenient to implement a couple of auxiliary classes.  Nothing more, everything is just for understanding.  I will note that the implementation of full-fledged classes of a vector and a matrix is ‚Äã‚Äãa separate difficult question, and is not included in the topic of this article. <br><br><div class="spoiler">  <b class="spoiler_title">Classes of vector and matrix</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m128))</span></span></span><span class="hljs-function"> vec4 </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> w, z, y, x; }; __m128 fmm; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> arr[<span class="hljs-number"><span class="hljs-number">4</span></span>]; }; vec4() {} vec4(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d) : w(d), z(c), y(b), x(a) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.00001</span></span></span></span><span class="hljs-function"><span class="hljs-params">f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(ab) &lt; t; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (vec4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> equ(x, vx) &amp;&amp; equ(y, vy) &amp;&amp; equ(z, vz) &amp;&amp; equ(w, vw); } }; <span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m256))</span></span></span><span class="hljs-function"> mtx4 </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//           union { struct { float _30, _20, _10, _00, _31, _21, _11, _01, _32, _22, _12, _02, _33, _23, _13, _03; }; __m128 r[4]; __m256 s[2]; vec4 v[4]; }; //    mtx4() {} mtx4( float i00, float i01, float i02, float i03, float i10, float i11, float i12, float i13, float i20, float i21, float i22, float i23, float i30, float i31, float i32, float i33) : _00(i00), _01(i01), _02(i02), _03(i03) , _10(i10), _11(i11), _12(i12), _13(i13) , _20(i20), _21(i21), _22(i22), _23(i23) , _30(i30), _31(i31), _32(i32), _33(i33) {} //      operator __m128 const* () const { return r; } operator __m128* () { return r; } //   bool operator == (mtx4 const&amp; m) const { return v[0]==mv[0] &amp;&amp; v[1]==mv[1] &amp;&amp; v[2]==mv[2] &amp;&amp; v[3]==mv[3]; } //  static mtx4 identity() { return mtx4( 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f); } static mtx4 zero() { return mtx4( 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f); } };</span></span></code> </pre><br></div></div><br><h3>  Reference function for tests </h3><br>  Since the accepted order of elements in the matrix complicates understanding a lot, the reference <em>clear</em> function will also not prevent us, which will show in further implementations that everything works correctly.  We will compare the subsequent results with it. <br><br><div class="spoiler">  <b class="spoiler_title">To create it, just take and expand the loop.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_unroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; m = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_m); mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; n = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_n); mtx4&amp; r = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_r); r._00 = m._00*n._00 + m._01*n._10 + m._02*n._20 + m._03*n._30; r._01 = m._00*n._01 + m._01*n._11 + m._02*n._21 + m._03*n._31; r._02 = m._00*n._02 + m._01*n._12 + m._02*n._22 + m._03*n._32; r._03 = m._00*n._03 + m._01*n._13 + m._02*n._23 + m._03*n._33; r._10 = m._10*n._00 + m._11*n._10 + m._12*n._20 + m._13*n._30; r._11 = m._10*n._01 + m._11*n._11 + m._12*n._21 + m._13*n._31; r._12 = m._10*n._02 + m._11*n._12 + m._12*n._22 + m._13*n._32; r._13 = m._10*n._03 + m._11*n._13 + m._12*n._23 + m._13*n._33; r._20 = m._20*n._00 + m._21*n._10 + m._22*n._20 + m._23*n._30; r._21 = m._20*n._01 + m._21*n._11 + m._22*n._21 + m._23*n._31; r._22 = m._20*n._02 + m._21*n._12 + m._22*n._22 + m._23*n._32; r._23 = m._20*n._03 + m._21*n._13 + m._22*n._23 + m._23*n._33; r._30 = m._30*n._00 + m._31*n._10 + m._32*n._20 + m._33*n._30; r._31 = m._30*n._01 + m._31*n._11 + m._32*n._21 + m._33*n._31; r._32 = m._30*n._02 + m._31*n._12 + m._32*n._22 + m._33*n._32; r._33 = m._30*n._03 + m._31*n._13 + m._32*n._23 + m._33*n._33; }</code> </pre><br></div></div><br>  Here is a classic algorithm clearly painted, it is difficult to make a mistake (but you can :-)).  On it IACA issued: <em>x86 - 69.95 cycles, x64 - 64 cycles</em> .  Regarding 64 cycles, we will look at the acceleration of this operation in the future. <br><br><h2>  SSE implementation </h2><br><h3>  Classic SSE algorithm </h3><br>  Why classic?  Because it has long been in the implementation of <em>FVec</em> in the MSVS.  To begin with, we will write how we present the elements of the matrix in the SSE registers.  Here it already looks easier.  Just transposed matrix. <br><br><pre> <code class="plaintext hljs">//     00, 10, 20, 30 // m[0] -  SIMD /   01, 11, 21, 31 // m[1] 02, 12, 22, 32 // m[2] 03, 13, 23, 33 // m[3]</code> </pre><br>  We take the <em>unroll</em> code of the variant above.  Some kind of he is unfriendly for SSE.  The first group of rows consists of the results on the column of the resulting matrix: <em><nobr>r._00, r._01, r._02, r._03</nobr></em> .  We have a column, and we need a row.  Yes, and <strong>m</strong> , <strong>n</strong> look inconvenient for calculations.  Therefore, we rearrange the lines of the algorithm so that the result of <strong>r is</strong> line by line. <br><br><pre> <code class="plaintext hljs">//  ,     r[0] r00 = m00*n00 + m01*n10 + m02*n20 + m03*n30; r10 = m10*n00 + m11*n10 + m12*n20 + m13*n30; r20 = m20*n00 + m21*n10 + m22*n20 + m23*n30; r30 = m30*n00 + m31*n10 + m32*n20 + m33*n30; //  ,     r[1] r01 = m00*n01 + m01*n11 + m02*n21 + m03*n31; r11 = m10*n01 + m11*n11 + m12*n21 + m13*n31; r21 = m20*n01 + m21*n11 + m22*n21 + m23*n31; r31 = m30*n01 + m31*n11 + m32*n21 + m33*n31; //  ,     r[2] r02 = m00*n02 + m01*n12 + m02*n22 + m03*n32; r12 = m10*n02 + m11*n12 + m12*n22 + m13*n32; r22 = m20*n02 + m21*n12 + m22*n22 + m23*n32; r32 = m30*n02 + m31*n12 + m32*n22 + m33*n32; //  ,     r[3] r03 = m00*n03 + m01*n13 + m02*n23 + m03*n33; r13 = m10*n03 + m11*n13 + m12*n23 + m13*n33; r23 = m20*n03 + m21*n13 + m22*n23 + m23*n33; r33 = m30*n03 + m31*n13 + m32*n23 + m33*n33;</code> </pre><br>  But so much better.  What exactly do we see?  By the columns of the algorithm in each group, we use the rows of the matrix <strong>m</strong> : <br><pre> m [0] = {00,10,20,30}, m [1] = {01,11,21,31}, m [2] = {02,12,22,32}, m [3] = {03,13,23,33},
</pre>  which are multiplied by the same element of the matrix <strong>n</strong> .  For example, for the first group it is: <em>n._00, n._10, n._20, n._30</em> .  And the elements of the matrix <strong>n</strong> for each group of rows of the algorithm again lie in one row of the matrix. <br><br>  Then everything is simple: we simply take the rows of the matrix <strong>m</strong> by the index, but as for the elements <strong>n</strong> , we take its row and through the <em>shuffle</em> instruction we scatter it with all 4 register elements to multiply by the row of the matrix <strong>m</strong> in the register.  For example, for the element <em>n._00</em> (remember that its offset in the register has an index of 3) this would be: <pre>  _mm_shuffle_ps (n [0], n [0], _MM_SHUFFLE (3,3,3,3)) </pre><br>  In simplified form, the algorithm looks like this: <br><br><pre> <code class="plaintext hljs">//   n[0]={00,10,20,30} r[0] = m[0] * n00 + m[1] * n10 + m[2] * n20 + m[3] * n30; //   n[1]={01,11,21,31} r[1] = m[0] * n01 + m[1] * n11 + m[2] * n21 + m[3] * n31; //   n[2]={02,12,22,32} r[2] = m[0] * n02 + m[1] * n12 + m[2] * n22 + m[3] * n32; //   n[3]={03,13,23,33} r[3] = m[0] * n03 + m[1] * n13 + m[2] * n23 + m[3] * n33;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Basic SSE implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); }</code> </pre><br></div></div><br>  Now, in the algorithm, we change the elements <strong>n</strong> to the corresponding <em>shuffle</em> , multiplication by <em>_mm_mul_ps</em> , the amount by <em>_mm_add_ps</em> , and everything is ready.  It is working.  The code looks, however, much worse than the algorithm itself looked like.  IACA issued this code: <em>x86 - 18.89, x64 - 16 cycles</em> .  This is 4 times faster than the previous one.  In the SSE register, the 4th float.  Almost linear dependence. <br><br><h4>  We decorate SSE implementation </h4><br>  Still, in the code, it looks awful.  We will try to improve this by writing a little syntactic sugar. <br><br><div class="spoiler">  <b class="spoiler_title">Operators and Improvers</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ( -    namespace) __m128 operator + (__m128 const a, __m128 const b) { return _mm_add_ps(a, b); } __m128 operator - (__m128 const a, __m128 const b) { return _mm_sub_ps(a, b); } __m128 operator * (__m128 const a, __m128 const b) { return _mm_mul_ps(a, b); } __m128 operator / (__m128 const a, __m128 const b) { return _mm_div_ps(a, b); } //_mm_shuffle_ps(u, v, _MM_SHUFFLE(3,2,1,0))   shuf&lt;3,2,1,0&gt;(u, v) template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(a, b, c, d)); } template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(a, b, c, d)); } //    template &lt;int i&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(i, i, i, i)); } template &lt;int i&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(i, i, i, i)); } //  float       , //    ,    template &lt;int a, int b, int c, int d&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(a, b, c, d))); } template &lt;int i&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(i, i, i, i))); }</span></span></code> </pre><br></div></div><br>  These functions the compiler can perfectly inline (although sometimes without __forceinline in any way). <br><br><div class="spoiler">  <b class="spoiler_title">So the code turns ...</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]); }</code> </pre><br></div></div><br>  But this is already much better and more readable.  On this IACA produced approximately the expected result: <em>x86 - 19 (and why not fractional?), X64 - 16</em> .  In fact, the performance has not changed, but the code is much prettier and clearer. <br><br><h4>  Small contribution to future optimization </h4><br>  We introduce one more improvement at the function level, which appeared in the iron version not too long ago.  The operation <em>multiple-add (fma)</em> .  <em><nobr>fma (a, b, c) = a * b + c</nobr></em> . <br><br><div class="spoiler">  <b class="spoiler_title">Implement multiple-add</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm_add_ps(_mm_mul_ps(a, b), c); }</code> </pre><br></div></div><br>  Why is this necessary?  First of all, for future optimization.  For example, you can simply replace <em>mad</em> in the ready-made code with <em>fma</em> through the same macros as you like.  But we will lay the foundation for optimization now: <br><br><div class="spoiler">  <b class="spoiler_title">Option with multiple-add</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA: <em>x86 - 18.89, x64 - 16</em> .  Again fractional.  Still, IACA sometimes gives strange results.  The code has not changed so much.  Probably even a little bit worse.  But optimization sometimes requires such sacrifices. <br><br><h4>  Go to save through _mm_stream </h4><br>  Different optimization guides recommend once again not to pull the cache for mass save operations.  This is usually reasonable when you are processing vertices, which are thousands and more.  But for matrices this is probably not so important.  But still add. <br><br><div class="spoiler">  <b class="spoiler_title">Inline save option</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">1</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">3</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]))); }</code> </pre><br></div></div><br>  Nothing has changed in tact, from the word altogether.  But, according to the recommendations, now we don‚Äôt touch the cache. <br><br><h2>  AVX implementation </h2><br><h3>  Basic AVX option </h3><br><img src="https://habrastorage.org/webt/8d/l-/1r/8dl-1rgisfl2sqr0dhzmizkmawg.jpeg" align="right"><br>  Next, proceed to the next stage of optimization.  The 4th float is in the SSE register, and already 8 in the AVX. That is, there is a theoretical chance to reduce the number of operations performed and to increase performance, if not twice, then at least 1.5 times.  But something tells me that not everything will be so easy with the transition to AVX.  Will we be able to get the necessary data from the dual registers? <br><br>  Let's try to figure it out.  Again, write out our multiplication algorithm used above.  It would be possible not to do this, but it is more convenient to deal with the code when everything is close, and you do not have to scroll up half a page. <br><br><pre> <code class="plaintext hljs">//    : 00, 10, 20, 30, 01, 11, 21, 31, 02, 12, 22, 32, 03, 13, 23, 33 //   SSE: r0 = m0*n00 + m1*n10 + m2*n20 + m3*n30 r1 = m0*n01 + m1*n11 + m2*n21 + m3*n31 r2 = m0*n02 + m1*n12 + m2*n22 + m3*n32 r3 = m0*n03 + m1*n13 + m2*n23 + m3*n33</code> </pre><br>  At the output, we expect to get the result in <em><nobr>ymm = {r0: r1}</nobr></em> and <em><nobr>ymm = {r2: r3}</nobr></em> .  If, in the SSE version, our algorithm was generalized to columns, then now we need to generalize it to rows.  So to act as in the case of the SSE option will not work. <br><br>  If we take the matrix <strong>m</strong> into the registers <em>ymm</em> , we get <em><nobr>ymm = {m0: m1}</nobr></em> and <em><nobr>ymm = {m2: m3},</nobr></em> respectively.  Previously, we only had matrix columns in the register, and now both columns and rows. <br><br>  If you try to act as before, then <em><nobr>ymm = {m0: m1} should be</nobr></em> multiplied by the register <em><nobr>ymm = {n00, n00, n00, n00}: {n10, n10, n10, n10}</nobr></em> .  Since <em>n00</em> and <em>n01 are</em> in the same row of the matrix <strong>n</strong> , then, judging by the available set of AVX instructions, it will be expensive to <em>scatter</em> them by <em>ymm</em> .  Both <em>shuffle</em> and <em>permute</em> work separately for each of the two fours float ( <em>major</em> and minor <em>xmm</em> ) inside the <em>ymm</em> registers. <br><br>  If we take <em>ymm</em> from matrix <strong>n</strong> , then we get both elements <em>n00</em> and <em>n10</em> in the highest of 2 <em>xmm</em> inside the <em>ymm</em> register.  <em><nobr>{n00, n10, n20, n30}: {n01, n11, n21, n31}</nobr></em> .  Usually, the index of the existing instructions is from 0 to 3. And it addresses the float only within one <em>xmm</em> register from two inside the <em>ymm</em> register.  Throw <em>n10</em> from the older <em>xmm</em> to the younger <em>cheap</em> will not work.  And here also this trick should be repeated several times.  With such a loss of cycles, we can not accept.  We must come up with something else. <br><br>  We used to generalize the columns, and now the rows.  Therefore, try to go a little on the other side.  We need to get the result in <em>{r0: r1}</em> .  This means that the algorithm should be improved not by separate lines of the algorithm, but by two at once.  And here, what was a minus in the work of <em>shuffle</em> and <em>permute</em> will be a plus for us.  We look at what we will have in the registers <em>ymm</em> , when we consider the matrix <strong>n</strong> . <br><br><pre> <code class="plaintext hljs">n0n1 = {00, 10, 20, 30} : {01, 11, 21, 31} n2n3 = {02, 12, 22, 32} : {03, 13, 23, 33}</code> </pre><br>  Aha, we notice that in different <em>xmm</em> parts of the <em>ymm</em> register we have elements <em>00</em> and <em>01</em> .  They can be multiplied by case through the permute command in <em><nobr>{_00, _00, _00, _00}: {_ 01, _01, _01, _01}</nobr></em> , indicating only one index 3 for both <em>xmm</em> parts.  This is exactly what we need.  After all, the coefficients are also used in different lines.  Only now in the corresponding <em>ymm</em> register for multiplication you will need to keep <em>{m0: m0}</em> , that is, the duplicated first row of the matrix <strong>m</strong> . <br><br>  So, paint the algorithm in more detail.  We read in <em>ymm</em> registers the double rows of the matrix <strong>m</strong> : <br><br><pre> <code class="plaintext hljs">mm[0] = {m0:m0} mm[1] = {m1:m1} mm[2] = {m2:m2} mm[3] = {m3:m3}</code> </pre><br>  And then we will calculate the multiplication as: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0] * {n00,n00,n00,n00:n01,n01,n01,n01} + // permute&lt;3,3,3,3&gt;(n0n1) mm[1] * {n10,n10,n10,n10:n11,n11,n11,n11} + // permute&lt;2,2,2,2&gt;(n0n1) mm[2] * {n20,n20,n20,n20:n21,n21,n21,n21} + // permute&lt;1,1,1,1&gt;(n0n1) mm[3] * {n30,n30,n30,n30:n31,n31,n31,n31} // permute&lt;0,0,0,0&gt;(n0n1) r2r3 = mm[0] * {n02,n02,n02,n02:n03,n03,n03,n03} + // permute&lt;3,3,3,3&gt;(n2n3) mm[1] * {n12,n12,n12,n12:n13,n13,n13,n13} + // permute&lt;2,2,2,2&gt;(n2n3) mm[2] * {n22,n22,n22,n22:n23,n23,n23,n23} + // permute&lt;1,1,1,1&gt;(n2n3) mm[3] * {n32,n32,n32,n32:n33,n33,n33,n33} // permute&lt;0,0,0,0&gt;(n2n3)</code> </pre><br>  Rewrite more clearly: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3,3,3,3&gt;+mm[1]*n0n1&lt;2,2,2,2&gt;+mm[2]*n0n1&lt;1,1,1,1&gt;+mm[3]*n0n1&lt;0,0,0,0&gt; r2r3 = mm[0]*n2n3&lt;3,3,3,3&gt;+mm[1]*n2n3&lt;2,2,2,2&gt;+mm[2]*n2n3&lt;1,1,1,1&gt;+mm[3]*n2n3&lt;0,0,0,0&gt;</code> </pre><br>  Or in a simplified form: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3&gt; + mm[1]*n0n1&lt;2&gt; + mm[2]*n0n1&lt;1&gt; + mm[3]*n0n1&lt;0&gt; r2r3 = mm[0]*n2n3&lt;3&gt; + mm[1]*n2n3&lt;2&gt; + mm[2]*n2n3&lt;1&gt; + mm[3]*n2n3&lt;0&gt;</code> </pre><br>  It seems everything is clear. <br><br><div class="spoiler">  <b class="spoiler_title">It remains only to write the implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 mm0 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 mm1 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>]); __m256 mm2 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]); __m256 mm3 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], m[<span class="hljs-number"><span class="hljs-number">3</span></span>]); __m256 n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 y1 = _mm256_permute_ps(n0n1, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>);<span class="hljs-comment"><span class="hljs-comment">//3,3,3,3 __m256 y2 = _mm256_permute_ps(n0n1, 0xAA);//2,2,2,2 __m256 y3 = _mm256_permute_ps(n0n1, 0x55);//1,1,1,1 __m256 y4 = _mm256_permute_ps(n0n1, 0x00);//0,0,0,0 y1 = _mm256_mul_ps(y1, mm0); y2 = _mm256_mul_ps(y2, mm1); y3 = _mm256_mul_ps(y3, mm2); y4 = _mm256_mul_ps(y4, mm3); y1 = _mm256_add_ps(y1, y2); y3 = _mm256_add_ps(y3, y4); y1 = _mm256_add_ps(y1, y3); __m256 n2n3 = _mm256_load_ps(&amp;n[2].m128_f32[0]); __m256 y5 = _mm256_permute_ps(n2n3, 0xFF); __m256 y6 = _mm256_permute_ps(n2n3, 0xAA); __m256 y7 = _mm256_permute_ps(n2n3, 0x55); __m256 y8 = _mm256_permute_ps(n2n3, 0x00); y5 = _mm256_mul_ps(y5, mm0); y6 = _mm256_mul_ps(y6, mm1); y7 = _mm256_mul_ps(y7, mm2); y8 = _mm256_mul_ps(y8, mm3); y5 = _mm256_add_ps(y5, y6); y7 = _mm256_add_ps(y7, y8); y5 = _mm256_add_ps(y5, y7); _mm256_stream_ps(&amp;r[0].m128_f32[0], y1); _mm256_stream_ps(&amp;r[2].m128_f32[0], y5); }</span></span></code> </pre><br></div></div><br>  Here are the interesting numbers from IACA: <em>x86 - 12.53, x64 - 12</em> .  Although, of course, I wanted better.  Something missed. <br><br><h3>  AVX optimization plus ‚Äúsyntactic sugar‚Äù </h3><br>  It seems that in the code above AVX was not used to its full potential.  We find that instead of installing two identical lines in the <strong>ymm</strong> register, you can use <em>broadcast</em> , which can fill the <em>ymm</em> register with two identical <em>xmm</em> values.  Also along the way, add a little ‚Äúsyntactic sugar‚Äù for AVX functions. <br><br><div class="spoiler">  <b class="spoiler_title">Improved AVX implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_sub_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_mul_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(i, i, i, i, j, j, j, j)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(a, b, c, d, e, f, g, h)); } __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(_mm256_mul_ps(a, b), c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[] { _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  And here the results are more interesting.  IACA gives the numbers: <em>x86 - 10, x64 - 8.58</em> , which looks much better, but not 2 times. <br><br><h3>  AVX + FMA option (final) </h3><br>  We will make one more attempt.  Now it would be logical to recall the FMA instruction set again, since it was added to the processors after AVX.  Just change the individual <em>mul + add</em> for one operation.  Although we still use the multiplication instruction to give the compiler more possibilities for optimization, and the processor for parallel execution of multiplications.  I usually watch the generated code in assembler to see which option is better. <br><br>  In this case, we need to calculate <em><nobr>a * b + c * d + e * f + g * h</nobr></em> .  You can do it in the forehead: <em><nobr>fma (a, b, fma (c, d, fma (e, f, g * h)))</nobr></em> .  But, as we see, it is impossible to perform a single operation here without completing the previous one.  This means that we will not be able to use the ability to do paired multiplications, as this allows us to SIMD pipeline.  If we transform the calculations <em><nobr>fma (a, b, c * d) + fma (e, f, g * h) a</nobr></em> little, we will see that it is possible to parallelize the calculations.  First make two independent multiplications, and then two independent <em>fma</em> operations. <br><br><div class="spoiler">  <b class="spoiler_title">AVX + FMA implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA: <em>x86 - 9.21, x64 - 8</em> .  Now quite well.  Probably, someone will say that you can do even better, but I do not know how. <br><br><h2>  Benchmarks </h2><br>  Immediately, I note that these figures should not be taken as the ultimate truth.  Even with a fixed test, they swim within certain limits.  And even more so they behave differently on different platforms.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With any optimization, take measurements specifically for your case. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Table of contents </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Function: the name of the function. </font><font style="vertical-align: inherit;">The ending on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are functions with streaming, otherwise the usual mov (without streaming). </font><font style="vertical-align: inherit;">Added for clarity, as it is quite important.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IACA cycles: number of ticks per function calculated by IACA </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Measured cycles: the measured number of cycles (the smaller, the better) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IACA speedup: number of ticks in the zero line / number of ticks in the line </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Measured speedup: the number of ticks in the zero line / the number of ticks in the line (the more, the better) </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For loop_m, the clocks from the article were multiplied by 64. That is, this is a very approximate value. </font><font style="vertical-align: inherit;">In fact, it turned out.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i3-3770: </font></font></h3><br><div class="spoiler">  <b class="spoiler_title">x86</b> <div class="spoiler_text"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 70.00 </th><th> 50.75 </th><th>  1.00 </th><th>  1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 119.21 </th><th>  0.30 </th><th> 0.43 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 27.51 </th><th> 3.70 </th><th> 1.84 </th></tr><tr><th> sse_v2m </th><th>  19.00 </th><th> 27.61 </th><th> 3.68 </th><th> 1.84 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 27.22 </th><th> 3.70 </th><th> 1.86 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 27.18 </th><th> 3.70 </th><th> 1.87 </th></tr><tr><th> avx_v1m </th><th>  13.00 </th><th> 19.21 </th><th> 5.38 </th><th>  2.64 </th></tr><tr><th> avx_v1s </th><th>  13.00 </th><th>  20.03 </th><th> 5.38 </th><th> 2.53 </th></tr><tr><th> avx_v2m </th><th>  10.00 </th><th> 12.91 </th><th> 6.99 </th><th> 3.93 </th></tr><tr><th> avx_v2s </th><th>  10.00 </th><th> 17.34 </th><th> 6.99 </th><th> 2.93 </th></tr></tbody></table></div></div><br><div class="spoiler">  <b class="spoiler_title">x64</b> <div class="spoiler_text"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th>  70 </th><th> 68.60 </th><th>  1.00 </th><th>  1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 119.37 </th><th>  0.30 </th><th> 0.57 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 21.98 </th><th> 3.70 </th><th>  3.12 </th></tr><tr><th> sse_v2m </th><th>  19.00 </th><th> 21.09 </th><th> 3.68 </th><th> 3.25 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 22.19 </th><th> 3.70 </th><th> 3.09 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 22.39 </th><th> 3.70 </th><th> 3.06 </th></tr><tr><th> avx_v1m </th><th>  13.00 </th><th> 9.61 </th><th> 5.38 </th><th>  7.13 </th></tr><tr><th> avx_v1s </th><th>  13.00 </th><th> 16.90 </th><th> 5.38 </th><th>  4.06 </th></tr><tr><th> avx_v2m </th><th>  10.00 </th><th>  9.20 </th><th> 6.99 </th><th> 7.45 </th></tr><tr><th> avx_v2s </th><th>  10.00 </th><th> 14.64 </th><th> 6.99 </th><th> 4.68 </th></tr></tbody></table></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i7-8700K: </font></font></h3><br><div class="spoiler">  <b class="spoiler_title">x86</b> <div class="spoiler_text"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th>  40.25 </th><th>  1.00 </th><th>  1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 79.49 </th><th>  0.30 </th><th> 0.51 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 19.31 </th><th> 3.70 </th><th> 2.09 </th></tr><tr><th> sse_v2m </th><th>  19.00 </th><th> 19.98 </th><th> 3.68 </th><th> 2.01 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 19.69 </th><th> 3.70 </th><th> 2.04 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th>  19.67 </th><th> 3.70 </th><th> 2.05 </th></tr><tr><th> avx_v1m </th><th>  13.00 </th><th> 14.22 </th><th> 5.38 </th><th> 2.83 </th></tr><tr><th> avx_v1s </th><th>  13.00 </th><th> 14.13 </th><th> 5.38 </th><th> 2.85 </th></tr><tr><th> avx_v2m </th><th>  10.00 </th><th>  11.73 </th><th> 6.99 </th><th> 3.43 </th></tr><tr><th> avx_v2s </th><th>  10.00 </th><th> 11.81 </th><th> 6.99 </th><th> 3.41 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 10.38 </th><th> 7.60 </th><th> 3.88 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 10.32 </th><th> 7.60 </th><th> 3.90 </th></tr></tbody></table></div></div><br><div class="spoiler">  <b class="spoiler_title">x64</b> <div class="spoiler_text"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 57.11 </th><th>  1.00 </th><th>  1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 75.73 </th><th>  0.30 </th><th> 0.75 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 15.83 </th><th> 3.70 </th><th>  3.61 </th></tr><tr><th> sse_v2m </th><th>  19.00 </th><th> 17.22 </th><th> 3.68 </th><th> 3.32 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 15.92 </th><th> 3.70 </th><th> 3.59 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 16.18 </th><th> 3.70 </th><th> 3.53 </th></tr><tr><th> avx_v1m </th><th>  13.00 </th><th>  7.03 </th><th> 5.38 </th><th> 8.12 </th></tr><tr><th> avx_v1s </th><th>  13.00 </th><th> 12.98 </th><th> 5.38 </th><th> 4.40 </th></tr><tr><th> avx_v2m </th><th>  10.00 </th><th> 5.40 </th><th> 6.99 </th><th> 10.57 </th></tr><tr><th> avx_v2s </th><th>  10.00 </th><th> 11.39 </th><th> 6.99 </th><th> 5.01 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 9.73 </th><th> 7.60 </th><th> 5.87 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 9.81 </th><th> 7.60 </th><th> 5.82 </th></tr></tbody></table></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code of tests in the source. </font><font style="vertical-align: inherit;">If there are reasonable suggestions how to improve them, write in the comments.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BONUS from science fiction </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, from the realm of fantasy, it is because if I saw processors with support for AVX512, then perhaps in the pictures. </font><font style="vertical-align: inherit;">However, I tried to implement an algorithm. </font><font style="vertical-align: inherit;">Here I will not explain anything, a complete analogy with AVX + FMA. </font><font style="vertical-align: inherit;">The algorithm is the same, only operations are less.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As they say, I'll just leave it here.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_add_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_sub_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_mul_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx512</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">0</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">1</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">2</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">3</span></span>]) }; __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n = _mm512_load_ps(&amp;_n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm512_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The numbers are fantastic: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86 - 4.79, x64 - 5.42</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (IACA with SKX architecture). </font><font style="vertical-align: inherit;">This is despite the fact that the algorithm has 64 multiplications and 48 additions.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS Code from article </font></font></h2><br><div class="oembed"> <a href="https://github.com/truthfinder/mul_m4_m4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/truthfinder/mul_m4_m4</font></font></a> </div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is my first experience writing an article. </font><font style="vertical-align: inherit;">Thank you all for the comments. </font><font style="vertical-align: inherit;">They help make the code and article better.</font></font></div><p>Source: <a href="https://habr.com/ru/post/418247/">https://habr.com/ru/post/418247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418237/index.html">Development of multi-tenant applications on the SAP Cloud Platform in the Neo environment, part 2: authorization and authentication</a></li>
<li><a href="../418239/index.html">48 megapixel for smartphone</a></li>
<li><a href="../418241/index.html">Why gauss? (100 ways to solve an equation system)</a></li>
<li><a href="../418243/index.html">The popular history of astronomy is wrong</a></li>
<li><a href="../418245/index.html">How not to develop a project on Bitrix</a></li>
<li><a href="../418249/index.html">New Google Compute Engine VM Images for Deep Learning</a></li>
<li><a href="../418251/index.html">Computer vision: how AI is watching us</a></li>
<li><a href="../418253/index.html">There could be water, atmosphere and life on the early moon</a></li>
<li><a href="../418255/index.html">How traffic exchanges resell autosurfing and where from the network millions of bots</a></li>
<li><a href="../418257/index.html">Github.com refuses to use jQuery and switches to pure JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>