<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to java.util.concurrent.CompletableFuture class methods</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Appears in Java8 class CompletableFuture - a means for transferring information between parallel execution threads. In essence, it is a blocking queue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to java.util.concurrent.CompletableFuture class methods</h1><div class="post__text post__text-html js-mediator-article">  Appears in Java8 class <a href="http://download.java.net/lambda/b88/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a> - a means for transferring information between parallel execution threads.  In essence, it is a blocking queue, capable of transmitting only one reference value.  Unlike a normal queue, it also passes an exception, if it occurred during the calculation of the transmitted value. <br><br>  The class contains several dozen methods in which it is easy to get lost.  This article classifies these methods in several ways, so that they are easy to navigate. <br><a name="habracut"></a><br>  To warm up, we will introduce new interfaces from the java.util.Function package, which are used as parameter types in many methods. <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   BiFunction&lt;T, U,R&gt; { R apply(T t, U u); } //  ,    BiConsumer&lt;T,U&gt; { void accept(T t, U u) } //  ,   Function&lt;T, R&gt; { R apply(T t); } //  ,    Consumer&lt;T&gt; { void accept(T t); } //  ,   Supplier&lt;T&gt; { T get(); }</span></span></code> </pre> <br>  Recall also the good old Runnable: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    Runnable { void run(); }</span></span></code> </pre><br>  These interfaces are functional, that is, the values ‚Äã‚Äãof this type can be specified as references to objects, and references to methods or lambda expressions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a means of data transmission, the <code>CompletableFuture</code> class has two sub-interfaces - for writing and for reading, which in turn are divided into direct (synchronous) and mediated (asynchronous).  Only the sub-interface of direct reading ( <code>java.util.concurrent.Future</code> , existing since java 5) is programmatically highlighted, but for classification purposes it is useful to mentally select the others.  In addition to this separation by sub-interfaces, I will also try to separate the basic methods and methods that implement particular cases. <br><br>  For brevity, instead of ‚Äúan object of type CompletableFuture‚Äù we will say ‚Äúfutures‚Äù.  ‚ÄúThis futures‚Äù means futures to which the described method is applied. <br><br><h4>  1. Direct recording interface </h4><br>  It is clear that there are two basic methods - write the value and write the exception: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T value)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeExceptionally</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable ex)</span></span></span></span></code> </pre>  with obvious semantics. <br><br>  Other methods: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mayInterruptIfRunning)</span></span></span></span></code> </pre>  equivalent to <code>completeExceptionally(new CancellationException)</code> .  Introduced for compatibility with java.util.concurrent.Future. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completedFuture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U value)</span></span></span></span></code> </pre>  equivalent to <code>CompletableFuture res=new CompletableFuture(); res.complete(value)</code>  <code>CompletableFuture res=new CompletableFuture(); res.complete(value)</code> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">obtrudeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T value)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">obtrudeException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable ex)</span></span></span></span></code> </pre>  Forcibly overwrite the stored value.  A surefire way to shoot yourself in the foot. <br><br><h4>  2. Direct reading interface </h4><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre>  Checks whether the result has already been recorded in this futures. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre>  Waits if the result is not yet recorded, and returns a value.  If an exception was written, throws a ExecutionException. <br><br>  Other methods: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCancelled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre>  checks whether an exception was written using the cancel () method. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre>  Same as get (), but throws a CompletionException. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout, TimeUnit unit)</span></span></span></span></code> </pre>  <code>get()</code> with timeout. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T valueIfAbsent)</span></span></span></span></code> </pre>  returns the result immediately.  If the result has not yet been recorded, returns the value of the <code>valueIfAbsent</code> parameter. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNumberOfDependents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre>  approximate number of other CompletableFuture waiting to be filled. <br><br><h4>  3. Interface Recording </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span></span></span></span></code> </pre>  The task with the supplier function is started, and the result of the execution is written to the futures.  The task is run on a standard thread pool. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supplyAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span></span></code> </pre>  The same, but running on the thread pool specified by the executor parameter. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Runnable runnable)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Runnable runnable, Executor executor)</span></span></span></span></code> </pre>  The same as <code>supplyAsync</code> , but the action of the <code>Runnable</code> type and, accordingly, the result will be of the <code>Void</code> type. <br><br><h4>  4. Mediated Reading Interface </h4><br>  Instructs to perform the specified action (reaction) immediately to fill this (and / or other) futures.  The most extensive sub-interface.  We classify its components in two ways: <br><br>  a) the way to start the response to the filling: it is possible to start it synchronously as a method when filling the futures, or asynchronously as a task on the thread pool.  In the case of an asynchronous start, methods are used with the Async suffix (in two versions, the start is on the general stream <code>ForkJoinPool.commonPool()</code> , or on the stream indicated by the additional parameter).  Further only methods for synchronous start will be described. <br><br>  b) the topology of the relationship between this futures and the response to its filling: linear, type ‚Äúany‚Äú and type ‚Äùall‚Äù. <br><br>  - linear relationship: one futures supply one value per reaction <br><br>  - ‚Äúany‚Äù method - two or more futures are entered;  the first (in time) result that appeared in one of the futures is transferred to the reaction;  other results are ignored <br><br>  - ‚Äúall‚Äù method - two or more futures are entered;  the results of all futures are accumulated and then transferred to the reaction. <br><br><h5>  4.1 Perform a reaction to populate this futures (linear relationship) </h5><br>  These methods have names that begin with the then prefix, have one parameter, the reaction, and return a new futures type <code>CompletableFuture</code> for accessing the result of the reaction execution.  They differ in the type of reaction. <br><br><pre> <code class="java hljs">&lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenApply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? extends U&gt; fn)</span></span></span></span></code> </pre>  The main method in which the reaction gets the value from the futures and the return value is transferred to the resulting futures. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenAccept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; block)</span></span></span></span></code> </pre>  The reaction retrieves the value from the futures, but does not return the value, so <br>  The resultant futures value is of type <code>Void</code> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenRun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Runnable action)</span></span></span></span></code> </pre>  The reaction does not receive or return a value. <br><br>  Let compute1..compute4 be references to methods.  A linear chain with the transfer of values ‚Äã‚Äãfrom step to step may look like this: <br><pre> <code class="java hljs">supplyAsync(compute1) .thenApply(compute2) .thenApply(compute3) .thenAccept(compute4);</code> </pre><br>  equivalent to a simple call <br><pre> <code class="java hljs">compute4(compute3(compute2(compute1())));</code> </pre><br><pre> <code class="java hljs">&lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenCompose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T, CompletableFuture&lt;U&gt;&gt; fn)</span></span></span></span></code> </pre>  Same as <code>thenApply</code> , but the reaction itself returns futures instead of the finished value.  This may be necessary if you want to use a complex topology reaction. <br><br><h5>  4.2 Perform a reaction to fill out any of the many futures. </h5><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CompletableFuture&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span></span></code> </pre>  Returns a new futures contract that is filled in when any of the futures <code>cfs</code> parameter is <code>cfs</code> .  The result is the same as the result of the completed futures. <br><br><h5>  4.3 Perform a reaction to fill in any of the two futures. </h5><br>  The main method: <br><br><pre> <code class="java hljs">&lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyToEither</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;? extends T&gt; other, Function&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,U&gt; fn)</span></span></span></span></code> </pre>  Returns a new futures, which is filled when this futures or futures, transmitted by the parameter <code>other</code> .  The result is the same as the result of the completed futures. <br><br>  The method is equivalent to the expression: <br><pre> <code class="java hljs">CompletableFuture.anyOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other).thenApply(fn);</code> </pre><br>  The remaining two methods differ only in the type of reaction: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptEither</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;? extends T&gt; other, Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; block)</span></span></span><span class="hljs-function"> CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runAfterEither</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;?&gt; other, Runnable action)</span></span></span></span></code> </pre><br>  It is not clear why there were 3 methods to do * Either (9 with * Async options), when one would be enough: <br><pre> <code class="java hljs">&lt;T&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">either</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;? extends T&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.anyOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other); }</code> </pre> <br>  then all these methods could be expressed as: <br><br><pre> <code class="java hljs">f1.applyToEither(other, fn) == f1.either(other).thenApply(fn); f1.applyToEitherAsync(other, fn) == f1.either(other).thenApplyAsync(fn); f1.applyToEitherAsync(other, fn, executor) == f1.either(other).thenApplyAsync(fn, executor); f1.acceptEither(other, block) == f1.either(other).thenAccept(other); f1.runAfterEither(other, action) == f1.either(other).thenRun(action);</code> </pre><br>  etc.  In addition, the method either could be used in other combinations. <br><br><h5>  4.4 Perform a reaction to fill two futures </h5><br><pre> <code class="java hljs">&lt;U,V&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;V&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenCombine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> U,? extends V&gt; fn)</span></span></span></span></code> </pre>  The main method.  It has two futures input, the results of which are accumulated and then transferred to the reaction, which is a function of two parameters. <br><br>  Other methods differ in the type of reaction: <br><br><pre> <code class="java hljs">&lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thenAcceptBoth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;? extends U&gt; other, BiConsumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> U&gt; block)</span></span></span></span></code> </pre>  reaction does not return value <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runAfterBoth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;?&gt; other, Runnable action)</span></span></span></span></code> </pre>  the reaction takes no parameters and does not return a value <br><br><h5>  4.5 Perform a reaction to fill many futures. </h5><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CompletableFuture&lt;Void&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CompletableFuture&lt;?&gt;... cfs)</span></span></span></span></code> </pre>  Returns a CompletableFuture ending on completion of all futures in the parameter list.  The obvious disadvantage of this method is that the resulting futures do not transfer the values ‚Äã‚Äãobtained in the futures parameters, so that if they are needed, they must be transferred in some other way. <br><br><h5>  4.6.  Interception of execution errors </h5><br>  If at some point the futures fails, the exception is passed down the futures chain.  To react to an error and return to normal execution, you can use the exception interception method. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exceptionally</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&lt;Throwable,? extends T&gt; fn)</span></span></span></span></code> </pre>  If this futures failed, the resulting futures will end with the result produced by the function <code>fn</code> .  If the futures finished normally, then the resulting futures will end normally with the same result. <br><br><pre> <code class="java hljs">&lt;U&gt; <span class="hljs-function"><span class="hljs-function">CompletableFuture&lt;U&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BiFunction&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T,Throwable,? extends U&gt; fn)</span></span></span></span></code> </pre>  In this method, the reaction is always invoked, regardless of whether the given futures fail normally or abnormally.  If the futures ended normally with the result <code>r</code> , then the parameters <code>(r, null)</code> will be passed to the reaction, if it crashes with the exception of ex, the parameters <code>(null, ex)</code> will be passed to the reaction.  The result of the reaction may be of a different type than the result of the futures. <br><br>  The following example is taken from <a href="http://nurkiewicz.blogspot.ru/2013/05/java-8-definitive-guide-to.html">http://nurkiewicz.blogspot.ru/2013/05/java-8-definitive-guide-to.html</a> : <br><br><pre> <code class="java hljs">CompletableFuture&lt;Integer&gt; safe = future.handle((r, ex) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer.parseInt(r); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.warn(<span class="hljs-string"><span class="hljs-string">"Problem"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } });</code> </pre><br>  Here, the <code>future</code> produces a <code>String</code> result or an error, the reaction translates the result into an integer, and in case of an error, it returns -1.  Note that, in general, the test should start with <code>if (ex!=null)</code> , since <code>r==null</code> can be both at abnormal and normal termination, but in this example, the case of <code>r==null</code> treated as an error. <br><br>  If there is an interest in the form of proposals to solve certain problems, there will be a continuation. <br></div><p>Source: <a href="https://habr.com/ru/post/213319/">https://habr.com/ru/post/213319/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213309/index.html">Hooks are easy (part 2)</a></li>
<li><a href="../213311/index.html">‚ÄúThe worse the better‚Äù, or the Startup in 6 hours</a></li>
<li><a href="../213313/index.html">How to get a good layout from typesetter</a></li>
<li><a href="../213315/index.html">Management tools: How to unwittingly zaprolit the interlocutor and get a minus in karma</a></li>
<li><a href="../213317/index.html">Biathlon 2014. How to earn $ 1000 on one title</a></li>
<li><a href="../213323/index.html">MeteoPhone: accurate weather information</a></li>
<li><a href="../213325/index.html">How not to test software for business</a></li>
<li><a href="../213327/index.html">Automation of online store warehouse processes: Audiomania experience - Part 2</a></li>
<li><a href="../213331/index.html">Payment for the result and guarantee</a></li>
<li><a href="../213333/index.html">How to test software for business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>