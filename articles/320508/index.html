<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerate data transfer to localhost</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the fastest way interprocess communication is implemented using shared memory (Shared Memory). But it seemed to me not logical that in the algo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerate data transfer to localhost</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/post/320508"><img src="https://habrastorage.org/files/fbf/b2c/539/fbfb2c5395b447b28c285717a1497aa9.jpg" alt="Made in Russia"></a> <br><br>  One of the fastest way interprocess communication is implemented using shared memory (Shared Memory).  But it seemed to me not logical that in the algorithms I found, the memory still needs to be copied, and after restarting the client (and it was allowed only one), the server must also be restarted.  Taking the will into a fist, I decided to develop a full-fledged client-server using shared memory. <br><a name="habracut"></a><br>  And so, first you need to determine the functional requirements for the client-server being developed.  The first and main requirement: the data should not be copied.  Secondly, "multi-client" - several clients can connect to the server.  Third, customers can reconnect.  And fourth, whenever possible, the software should be cross-platform.  From the requirements imposed, we can distinguish the components of the architecture: <br><br><ul><li>  component that encapsulates work with shared memory; </li><li>  memory manager (allocator); </li><li>  a component that encapsulates work with a forwarding data buffer and <br>  implementing the ideology of "copy on write" (hereinafter CBuffer); </li><li>  interprocess mutex; </li><li>  interprocess conditional variable or its analogue; </li><li>  and directly the client and server. </li></ul><br>  There <a href="http://www.boost.org/doc/libs/1_60_0/doc/html/interprocess/sharedmemorybetweenprocesses.html">are a lot of</a> problems with shared memory.  Therefore, we will not reinvent the wheel and take the boost.interprocess to the maximum.  First, let's take the classes shared_memory_object, mapped_region, which make it easier for us to work with shared memory in linux and windows.  From there, you can take the implementation of IPC semaphore - which will perform the functions of both mutex and conditional variable.  We also take as a model for CBuffer, a boost implementation of std :: vector (When working with shared memory, you cannot use pointers, only offsets. Therefore, std :: vector + allocator will not work for us).  Even in boost, you can find an implementation of interprocess deque, but I did not find how to use it when developing a client server.  And there was only a question with the memory manager (allocator) for shared memory.  Naturally, he is in boost, but he is focused on solving other problems.  Thus, from boost, libraries that do not need to be compiled (header only) will be taken.  Although the boost under MSVC may not agree with this point of view, so do not forget about the cudgel - the BOOST_ALL_NO_LIB preprocessor prohibits the use of ‚Äúpragma comment". (Memories from the night monologue: ‚ÄúWhat the hell are linked to the boost!‚Äù) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Client and server implementation </h2><br>  Implementing data transfer between clients and servers is rather trivial.  It is similar to the implementation of a supplier-consumer model (producer-customer) using semaphores, where the ‚Äútransmitted‚Äù message is the offset (address) of the transmitted buffer, and the synchronization objects are replaced with their interprocess counterparts.  Each client and server has its own displacement queue, which plays the role of a receive buffer and a semaphore, which is responsible for notification of a change in queue.  Accordingly, when the buffer is sent to another process, the buffer offset is put in the queue, and the semaphore is released (post).  Then another process reads the data and captures the semaphore (wait).  By default, the process does not wait for data to be received by another process (nonblock).  An example implementation can be taken <a href="https://docs.oracle.com/cd/E19455-01/806-5257/sync-15907/index.html">from here</a> .  In practice, in addition to the transfer of the buffer itself, it is often necessary to also transmit identifying information.  This is usually an integer.  Therefore, the ability to transfer a number has been added to the Send method. <br><br><h4>  How do clients connect to the server? </h4><br>  The algorithm is quite simple, server data is strictly on a certain offset in the shared memory.  When the client ‚Äúopens‚Äù the shared memory, it reads the structure at the specified address, if it does not exist, then the server does not exist, if it does, it allocates memory for the client data structure, fills it, and raises an event on the server indicating the offset to the structure.  Next, the server adds a new client to the linked list of clients and raises a ‚Äúconnected‚Äù event in the client.  Disconnection is done in a similar way. <br><br><h4>  Connection state evaluation </h4><br>  Checking the status of the connection between the client and the server is built like TCP.  With a time interval, a packet of life is sent.  If it is not delivered, it means that the client has collapsed.  Also, to avoid possible deadlocks due to a ‚Äúcollapsed‚Äù client that did not release the synchronization object, the memory for the life packet is allocated from its own server reserve. <br><br><h2>  Memory manager implementation </h2><br>  As it turned out, the most difficult task in implementation like IPC is the implementation of a memory manager.  After all, he should not only implement the malloc and free methods on one of the known algorithms, but also prevent leakage when the client crashes, provide the ability to ‚Äúreserve‚Äù memory, allocate a memory block at a particular offset, prevent fragmentation, be thread-safe, and cases of absence of free blocks of the required size, expect it to appear. <br><br><h4>  Basic algorithm </h4><br>  The basis of the implementation of the memory manager was taken Free List algorithm.  According to this algorithm, all unallocated blocks of memory are combined into a one-way linked list.  Accordingly, when allocating a block of memory (malloc), the first free block is searched, the size of which is not less than the required one, and is removed from the linked list.  If the size of the requested block is less than the size of the free, then the free block is divided into two, the first is equal to the requested size, and the second is ‚Äúextra‚Äù.  The first block is a dedicated block of memory, and the second is added to the list of free blocks.  When freeing a block of memory (free), the block to be released is added to the free list.  Next, the adjacent free memory blocks are combined into one.  The network has a set implementation of a memory manager with the Free List algorithm.  I used the <a href="http://www.freertos.org/a00111.html">heap_5</a> algorithm from FreeRTOS. <br><br><h4>  Algorithmic features </h4><br>  From the point of view of developing a memory manager, a distinctive feature of working with shared memory is the lack of "help" from the OS.  Therefore, in addition to the list of free memory blocks, the manager is also obliged to save information about the owner of the memory block.  This can be done in several ways: to be stored in each allocated block of PID process memory, to create a table ‚Äúoffset of allocated block of memory - PID‚Äù, to create an array of allocated blocks of memory for each PID separately.  Since the number of processes is usually small (no more than 10), a hybrid decision was made, an index (2 bytes) of the displacement array of allocated memory blocks was stored in each allocated memory block, each PID has its own array, which is located at the end of the ‚Äúprocess block‚Äù (in this block contains information about the process) and is dynamic. <br><br>  The array is cleverly organized; if a memory block is allocated by a process, then the cell stores the offset of the allocated memory block; if the memory block is not allocated, then the cell contains the index of the next ‚Äúnot allocated‚Äù cell (in fact, a simply connected list of ‚Äúfree‚Äù cells of the array is organized, as in the algorithm Free List).  Such an algorithm of the array, allows you to delete and add the address in constant time.  Moreover, when allocating a new block, it is not necessary to look for the table corresponding to the current PID, its offset is always known in advance.  And if you keep the offset of the "process block" in the allocated memory block, then when you release the block, you also do not need to look for the table.  Due to the accepted assumption about the smallness of the number of processes, the ‚Äúprocess blocks‚Äù are combined into a one-way linked list.  Thus, when allocating a new memory block (malloc), the complexity of adding information about the owner is O (1), and when freeing (free) the memory block O (n), where n is the number of processes using shared memory.  Why not use a tree or hash tables to quickly find the offset of the "process box"?  The array of allocated blocks is dynamic, therefore, the offset at the ‚Äúprocess block‚Äù may change. <br><br>  As stated above, for the operation of the ‚Äúclient-server‚Äù it is necessary to add the ability to ‚Äúreserve‚Äù memory blocks.  This is implemented quite simply, the backup memory block is ‚Äúallocated‚Äù for the process.  Accordingly, when it is necessary to allocate a block of memory from the reserve, the backup block of the process is released, and then the operations are similar to the usual allocation.  Further, allocating a block of memory at a given address is also easy, because  Information about the cast blocks is stored in the "process block". <br><br>  With such a large amount of constantly stored service information, memory fragmentation may occur due to different ‚Äúlife‚Äù of blocks, therefore in the memory manager all service information (long lifetime) is allocated from the end of the area, and the allocation of ‚Äúuser‚Äù blocks (short lifetime) at first.  Thus, service information will fragment the memory only in the absence of free blocks. <br><br>  The memory structure is shown in the figure below. <br><br><div class="spoiler">  <b class="spoiler_title">Memory structure</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/183/97c/587/18397c58792d4067b9349c9012571292.png" alt="Memory structure"><br></div></div><br><h4>  And what happens if one of the processes using shared memory crashes? </h4><br>  Unfortunately, I did not find a way to get an event from the OS ‚Äúprocess ended‚Äù.  But it is possible to check whether the process exists or not.  Accordingly, when an error occurs in the memory manager, for example, the memory has run out, the memory manager checks the status of the processes.  If the process does not exist, then on the basis of the data stored in the ‚Äúprocess unit‚Äù, the leaked memory returns to the turnover.  Unfortunately, due to the lack of an event ‚Äúprocess ended‚Äù, a situation may arise when the process collapsed at the time of owning the interprocess mutex, which naturally leads to the lock of the memory manager and the inability to start the ‚Äúwipe‚Äù.  To avoid this, the header of the mutex is added to the header.  Therefore, if necessary, the user can call the test forcibly, say every 2 seconds.  (watch dog method) <br><br>  Due to the use of ‚Äúcopy-on-write‚Äù, a situation may occur when several processes simultaneously own the buffer, and according to the law of meanness, one of them collapsed.  In this case, there may be two problems.  First, if the failed process was the owner of the buffer, it will be deleted, which will lead to SIGNSEV in other processes.  The second, due to the fact that the collapsed process did not reduce the counter in the buffer, it will never be deleted, i.e.  there will be a leak.  I didn‚Äôt find a simple and productive solution to this problem, but, fortunately, this situation is rare, so I made a strong-willed decision, if there is another owner besides the fallen process, then to hell with it, let the memory leak, the buffer moves to the process that started the cleanup. <br><br>  Usually the memory manager returns NULL or throws an exception if there is no free block of memory.  But we are ‚Äúnot interested‚Äù in the allocation of a memory block, but in its transfer, i.e.  the absence of a free block, does not mean an error, but about the need to wait until another process releases the block.  Waiting in a loop, it usually smells bad.  Therefore, the manager has two selection modes: classic, if there is no free block, returns NULL and waiting, if there is no free block, the process is blocked. <br><br><h2>  Implementation of the remaining components </h2><br>  The basis of the implementation of the remaining components is boost, so I‚Äôll only focus on their features.  A feature of the component that encapsulates the work with shared memory (hereinafter CSharedMemory) is the presence of a header with an interprocess mutex for synchronizing the methods of working with shared memory.  As practice has shown, one cannot do without it.  Since usually the size of the data buffer does not change or only changes from the beginning (for example, inserting a header into data buffers for transmission over the network.) The memory reservation algorithm in CBuffer is different from the memory reservation coefficient algorithm in std :: vector.  Firstly, in the CBuffer implementation, the ability to set the reserve first is added, by default it is 0. Secondly, the memory reservation algorithm is as follows: if the size of the allocated block is less than 128 bytes, then 256 bytes are reserved, if the data buffer size is less than 65536, then it is reserved buffer size plus 256 bytes, otherwise buffer size plus 512 bytes is reserved. <br><br><h4>  A few words about using sem_init in Linux </h4><br>  The main sources give a not entirely correct version of the program code for using sem_init between processes.  In Linux, you need to align the memory for the sem_t structure, like this: <br><br><pre><code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">_sem_t*</span></span>)(((<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)mem+__alignof(<span class="hljs-name"><span class="hljs-name">sem_t</span></span>))&amp;~(<span class="hljs-name"><span class="hljs-name">__alignof</span></span>(<span class="hljs-name"><span class="hljs-name">sem_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br>  Therefore, if your sem_post (sem_wait) returns EINVAL, try to align the memory for the sem_t structure.  <a href="">An example of working with sem_init</a> . <br><br><h2>  Total </h2><br>  The result is a client-server, the transfer rate of which does not depend on the amount of data, it depends only on the size of the transmitted buffer.  The price of this - some restrictions.  In Linux, the most significant of these is the ‚Äúleakage‚Äù of memory after the ‚Äúcompletion‚Äù process.  You can delete it manually or restart the OS.  When used in windows, the problem is different; there, the shared memory on the hard drive ‚Äúleaks‚Äù if it has not been deleted by calling the server class method.  This problem is not fixed by restarting the OS, only by manually deleting the files in the boost_interprocess folder.  Since I sometimes have to work with old compilers, the boost version 1.47 is in the repository, although with the latest versions, the library works faster. <br><br>  The test results are presented on the graph below (Linux and QNX were tested in the VMBox virtual machine) <br><br><img src="https://habrastorage.org/files/87b/591/ed8/87b591ed84794d67a86b0c4de107b2a9.png" alt="Tests"><h2>  Where to get the source? </h2><br>  The source code for the stable version is <a href="https://github.com/CrazyLauren/sm_lib">here</a> .  There are also <a href="https://github.com/CrazyLauren/sm_lib/releases">binaries</a> (+ VC redistributable) for quick launch of the test.  For fans of QNX, the source has a toolchain for CMake.  I remind you, if CMake does not compile the source, clean the environment variables, leaving only the directories of the target compiler. <br><br>  And finally, a <a href="http://yurovsky.github.io/2015/06/04/lockfree-ipc">link</a> to the implementation of LookFree IPC using shared memory. </div><p>Source: <a href="https://habr.com/ru/post/320508/">https://habr.com/ru/post/320508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320496/index.html">Open online courses from ITMO University</a></li>
<li><a href="../320498/index.html">Data models for user authentication in web applications</a></li>
<li><a href="../320500/index.html">Review Knime Analytics Platform - open source data analysis systems</a></li>
<li><a href="../320504/index.html">Using SVG to draw outline diagrams</a></li>
<li><a href="../320506/index.html">Halves of a square</a></li>
<li><a href="../320510/index.html">About data open, shared and delegated</a></li>
<li><a href="../320514/index.html">Why do we need even more data centers: today and tomorrow big data analysts</a></li>
<li><a href="../320516/index.html">Do you stick to social networks and how to deal with it</a></li>
<li><a href="../320518/index.html">Informatization of business is not IT companies - current realities and prospects, opinions and experience of experts</a></li>
<li><a href="../320522/index.html">How to forge the process yourself. 2GIS Company Experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>