<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Failover Evolution in PostgreSQL: Time Travel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Friends, today we bring to your attention the translation of the third part of a series of articles by one of the reporters of PG Day'17 Russia Gulcin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Failover Evolution in PostgreSQL: Time Travel</h1><div class="post__text post__text-html js-mediator-article">  <i>Friends, today we bring to your attention the translation of the third part of a series of articles by one of the reporters of PG Day'17 Russia <b><a href="https://pgday.ru/ru/2017/speakers/148">Gulcin Yildirim</a></b> on <b>PostgreSQL resiliency</b> .</i> <br><br>  <b>PostgreSQL</b> is a terrific project that is evolving with amazing speed.  In this series of articles, we will focus on the evolution of fault tolerance capabilities in PostgreSQL throughout its versions.  This is the third article in the series, and we‚Äôll talk about the timelines problems and their impact on the resiliency and reliability of PostgreSQL. <br><br><img src="https://habrastorage.org/files/04f/366/d18/04f366d18ab7414d8b2d54c4bb7ff477.jpg"><br><a name="habracut"></a><br>  If you want to trace the evolution of Postgres from the very beginning, read the first two articles in this series: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/317132/">Failover Evolution in PostgreSQL</a> </li><li>  <a href="https://habrahabr.ru/company/pgdayrussia/blog/326440/">Failover Evolution in PostgreSQL: Replication Phase</a> </li></ol><br>  <b>Timelines</b> <br>  The ability to roll back the database to any of the previous states creates certain difficulties.  We will examine some of them by examining <b>failover</b> situations (Fig. 1), <b>switchover</b> (Fig. 2), and <b>pg_rewind</b> (Fig. 3). <br><br>  For example, suppose that in the original database history you deleted a critical table at 5:15 pm on Tuesday evening, but realized your mistake only at noon on Wednesday.  Without batting an eye, you get a backup copy and roll back to the state at 5:14 pm Tuesday, and everything works again.  In the history of this database universe, you have never deleted a table.  But suppose you later realized that the idea was not so good, and you would like to return to the state on Wednesday morning from the original story.  It won't work for you if, after the database started working again, it rewrote some of the WAL segments that led to the point in time you would like to return to. <br><br>  Thus, to avoid this, you need to separate the series of WAL records generated after you performed a point-in-time recovery from those made in the original database history. <br><br>  To solve this problem in PostgreSQL, there is the concept of timeline.  Whenever an archive restore is completed, a new timeline is created to identify the series of WAL records generated after this recovery.  The timeline identification number is part of the file names of the WAL segments, so the new timeline does not overwrite the WAL data generated by the previous timeline.  That is, you can archive many different timelines. <br><br>  Consider a situation where you are not sure at what point in time you need to recover, and you have to do several restorations in order by trial and error to find the best place to branch from the old story.  Without timelines, this process would soon create an uncontrollable mess.  And with them you can recover to any previous state, including the states in the timelines branches that you previously abandoned. <br><br>  Each time a new timeline is created, PostgreSQL creates a ‚Äútimeline history‚Äù file, which shows from which timeline it originated and when.  These history files are required to enable the system to select the correct WAL segment files when restoring from an archive containing several timelines.  That is, they are stored in the WAL archive as well as the WAL segment files.  History files are just small text files, so they are cheap and expedient to store for an indefinite time (unlike large segment files).  If you want, you can add comments to the history file to record your own notes on how and why this particular timeline was created.  Such comments are especially valuable when, as a result of experiments, you have a tangle of different timelines. <br><br>  By default, recovery occurs at the same timeline, which was current at the time of creating the basic backup.  If you want to recover in some child timeline (that is, you want to return to the state that was generated after the recovery attempt), you need to specify the timeline ID in recovery.conf.  You cannot restore to timelines that branched out before the basic backup was created. <br><br>  To simplify the timelines concept in PostgreSQL, related issues in the <b>failover</b> , <b>switchover,</b> and <b>pg_rewind cases are</b> summarized and explained in Figures 1, 2, and 3. <br><br>  <b>Failover script</b> : <br><img src="https://habrastorage.org/files/091/eaf/25f/091eaf25faf9498899135502cddf2711.png"><br><ul><li>  on the old master there are changes not applied to standby (TL1); </li><li>  growth timelin reflects a new change history (TL2); </li><li>  changes from the old timeline cannot be reproduced on servers that have switched to the new timeline; </li><li>  The old master cannot become a replica of the new. </li></ul><br>  <b>Switchover script</b> : <br><img src="https://habrastorage.org/files/058/788/976/05878897621e471e9376ae2baf079373.png"><br><ul><li>  in the old master there are no changes that are not applied to standby (TL1); </li><li>  the growth timeline reflects the new change history (TL2); </li><li>  the old master can standby for the new. </li></ul><br>  <b>Script pg_rewind</b> : <br><img src="https://habrastorage.org/files/41e/df5/01a/41edf501a65d4100bf17ca9da0812492.png"><br><ul><li>  uncommitted changes will be deleted using data from the new master (TL1); </li><li>  The old master can become standby for the new (TL2). </li></ul><br>  <b>pg_rewind</b> <br><br>  pg_rewind is a tool to synchronize a PostgreSQL cluster with another copy of the same cluster after the timelines of the clusters have diverged.  A typical scenario: after a failover, the old primary server again rises as standby to the new primary. <br><br>  The result is equivalent to replacing the target data directory with the original one.  All files are copied, including configuration.  The advantage of pg_rewind over the removal of a new basic backup or with tools like rsync is that pg_rewind does not require reading all the unchanged files in the cluster.  Therefore, this method is much faster, especially in cases where the database is large, and only small parts of it differ between clusters. <br><br>  <b>How it works?</b> <br><br>  The basic idea is to copy everything from the new cluster to the old one, except for the blocks that are known to have not changed. <br><br><ol><li>  The WAL list of the old cluster is scanned, starting with the last checkpoint before the moment when the timeline history of the new cluster was branched off from the old one.  For each WAL entry, a note is made about which data blocks have been affected.  This creates a list of all the data blocks that were changed in the old cluster after the new cluster branched off. </li><li>  All these modified blocks are copied from the new cluster to the old one. </li><li>  All other files, such as clog and configuration files, are copied from the new cluster to the old one.  Everything except the relation files. </li><li>  WALs from the new cluster are applied, starting at the checkpoint created at the time of the failover.  (Strictly speaking, pg_rewind does not apply WAL, but simply creates a backup shortcut file, indicating that when you start PostgreSQL it will start playing from this point of reference and will apply all the required WALs.) </li></ol><br>  <i>Note</i> : The <a href="https://www.postgresql.org/docs/9.5/static/runtime-config-wal.html">wal_log_hints</a> parameter must be configured in postgresql.conf for pg_rewind to work.  This parameter can only be configured at server startup.  The default is <i>off</i> . <br><br>  <b>Conclusion</b> <br><br>  In this article, we discussed the <b>timelines</b> in Postgrese and how we handle <b>failover</b> and <b>switchover situations</b> .  We also talked about how pg_rewind works and its contribution to the resiliency and reliability of Postgres.  In the next article, we will continue the discussion of synchronous commits. <br><br><img src="https://habrastorage.org/files/a61/060/56f/a6106056fcce49a29cd997efd8bc97b9.png"><br><br>  Gulcin will arrive at <b><a href="http://pgday.ru/ru/2017%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dgulcin3">PG Day'17</a></b> and personally answer the questions of the participants, as well as tell in more detail about the <b><a href="http://pgday.ru/ru/2017/papers/184%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dgulcin3">automation of Postgres upgrades in the cloud</a></b> .  How to solve the problem of upgrading to major versions using the logic decoding functionality available in versions 9.4+?  The answer lies in the use of <b>pglogical</b> .  And, as a bonus, automate the proposed solution with <b>Ansible</b> .  <b><a href="http://pgday.ru/ru/2017/request/registration%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dgulcin3">Register</a></b> and prepare your questions! </div><p>Source: <a href="https://habr.com/ru/post/327750/">https://habr.com/ru/post/327750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327740/index.html">Computer forensics (forsensik) - a review of the tools and training sites</a></li>
<li><a href="../327742/index.html">Cry of the Soul - ‚ÄúHacking‚Äù the LiteManager Infrastructure</a></li>
<li><a href="../327744/index.html">Jubilee PYCON RUSSIA will be held July 16-17</a></li>
<li><a href="../327746/index.html">Building flexible PHP applications</a></li>
<li><a href="../327748/index.html">Forecasting in the supply chain: in search of the philosopher's stone</a></li>
<li><a href="../327752/index.html">System engineering and management 2.0: how to get the profession of the future</a></li>
<li><a href="../327754/index.html">Bash scripts, part 8: awk data processing language</a></li>
<li><a href="../327760/index.html">Data security in the development of mobile applications</a></li>
<li><a href="../327762/index.html">Biometric authentication technology - a European perspective</a></li>
<li><a href="../327766/index.html">Cultural Embedded at IT Global Meetup In St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>