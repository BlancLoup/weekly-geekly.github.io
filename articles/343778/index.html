<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Entity-Component-System Design Pattern - implementation and sample game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to discuss the entity-component-system design pattern (Entity-Component-System, ECS ). On this topic, you can find a lot of inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Entity-Component-System Design Pattern - implementation and sample game</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db6/486/421/db6486421d2282d555d5ac5af577aafc.png" alt="image"></div><br><br>  In this article I want to discuss the entity-component-system design pattern (Entity-Component-System, <strong>ECS</strong> ).  On this topic, you can find a lot of information on the Internet, so I will not go deep into the explanations, but I‚Äôll tell you more about my own implementation. <br><br><h2>  Part 1: Implementing the C ++ Entity-Component-System Template </h2><br>  Start over.  The complete source code for my ECS implementation can be found in the <a href="https://github.com/tobias-stein/EntityComponentSystem" rel="noopener">github</a> repository. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The Entity-Component-System, mainly used in games, is a design pattern that provides tremendous flexibility in designing a common software architecture <sup>[1]</sup> .  Large companies such as Unity, Epic or Crytek use this template in their frameworks to provide developers with a very rich tool with which they can develop their own software.  You can read a wider discussion on this topic in these posts <sup>[2,3,4,5]</sup> . <br><a name="habracut"></a><br>  If you study these articles, you will notice that they all have a common goal: the distribution of various problems and tasks between entities (Entities), components (Components) and systems (Systems).  These are the three basic concepts of this pattern, and they are connected quite loosely among themselves.  <strong>Entities</strong> are typically used to create a unique identifier, to provide the environment with information about the existence of a single element and function as a kind of root object that combines many components.  <strong>Components</strong> are nothing but container objects that have no complicated logic.  Ideally, they are objects with a simple data structure (plain old data objects, POD).  Each type of component can be attached to an entity to give it something like a property.  Suppose you can attach an ‚ÄúHealth Component‚Äù to an entity, which will make it mortal, giving it <em>health</em> , which is the usual integer or fractional value in memory. <br><br>  Most of the articles that I came across are consistent with each other regarding the use of entities and components, but opinions on systems differ.  Some people think that only components are known.  Moreover, some say that for each type of component there must be its own system, for example, for ‚ÄúCollision-Components‚Äù there should be a ‚ÄúCollision-System‚Äù, for ‚ÄúHealth-Components‚Äù - ‚ÄúHealth-System‚Äù, etc.  This approach is quite strict and does not take into account the interaction of various components.  A less rigorous approach is that different systems deal with components that they should be aware of.  For example, Physics-Systems should know about Collision-Components and Rigidbody-Components, because both of them most likely contain the information necessary for the simulation of physics.  In my humble opinion, <strong>systems</strong> are ‚Äúclosed environments‚Äù.  That is, they do not own any entities or components.  They have access to them through independent dispatcher objects, which in turn control the life cycle of entities and components. <br><br>  This poses an interesting question for us: how do entities, components and systems exchange information if they are more or less independent of each other?  The answer may be different and depends on the implementation.  In my implementation, the answer is event sourcing <sup>[6]</sup> .  Events are distributed through an ‚Äúevent manager‚Äù (‚ÄúEvent-Manager‚Äù) and anyone who is interested in events can receive information transmitted by the dispatcher.  If an entity, system, or even a component has an important state change that needs to be reported, for example, ‚Äúthe position has changed‚Äù or ‚Äúthe player has died‚Äù, they can transmit information to the ‚Äúevent dispatcher‚Äù.  He will transmit the event and all those who are subscribed to this event will learn about it.  In this way everything can be tied together. <br><br>  It seems that the introduction was longer than I had planned, well, what can you do.  Before we delve into the study of <a href="https://github.com/tobias-stein/EntityComponentSystem" rel="noopener">code</a> , which, by the way, is written in C ++ 11, I will tell you in general about the main characteristics of my architecture: <br><br><ul><li>  <strong>memory efficiency</strong> ‚Äî to quickly create and delete entities, components, and systems, as well as events, I cannot rely on standard dynamic memory management.  The solution in this case, of course, is its own memory allocator. </li><li>  <strong>logging</strong> - to keep track of what is happening, I used log4cplus for logging <sup>[7]</sup> . </li><li>  <strong>scalability</strong> - convenient implementation of new types of entities, components, systems and events is possible without any specified upper limits, with the exception of system memory </li><li>  <strong>flexibility</strong> - between entities, components and systems there are no dependencies (of course, entities and components have a kind of dependency, but they do not contain logic of pointers on each other) </li><li>  <strong>simple object search / access to them</strong> - simple retrieval of entity objects and their components via an <em>EntityId</em> or component iterator for iterating all components of a certain type </li><li>  <strong>performance monitoring</strong> - systems have priorities and can depend on each other, so you can set the topological order of the implementation </li><li>  <strong>ease of use</strong> - the library can easily be used with other software, just one include. </li></ul><br>  The image below shows the general architecture of my Entity-Component-System implementation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8da/8fd/bbc/8da8fdbbc5568237ae5450a90a835799.png"></div><br>  <i>Figure 01: ECS architecture diagram ( <strong><em>ECS.dll</em></strong> ).</i> <br><br>  As you can see, this diagram has four areas of different colors.  Each area denotes a modular part of the architecture.  At the very bottom - in fact, on the diagram at the very top, it is turned upside down - we have memory management and journaling (the yellow area).  These first-level modules work with very low-level tasks.  They use second-level modules in the Entity-Component-System (blue area) and event sourcing (red area).  These modules mainly deal with object management tasks.  Above them is the third level module ECS_Engine (green area).  This global top-level engine object controls all second-level modules and is engaged in initialization and destruction.  Well, it was a brief and very abstract review, now let's look at the architecture in more detail. <br><br><h4>  Memory manager </h4><br>  Let's start with the <a href="https://github.com/tobias-stein/EntityComponentSystem/tree/master/EntityComponentSystem/include/ECS/Memory" rel="noopener">Memory-Manager</a> .  Its implementation is based on article <sup>[8]</sup> , which I found on <em><a href="https://www.gamedev.net/" rel="noopener">gamedev.net</a></em> .  The idea is to reduce to the absolute minimum the allocation and release of dynamic memory.  Therefore, only when starting the application using <a href="http://en.cppreference.com/w/cpp/memory/c/malloc" rel="noopener"><em>malloc</em></a> is allocated a large area of ‚Äã‚Äãmemory.  This memory will now be controlled by one or more distributors.  There are many types of distributors <sup>[9]</sup> (linear, stack, free list) and each of them has its own pros and cons (here I will not consider them).  But despite the fact that inside they work differently, they all have a common open interface: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  The above code snippet is incomplete, but it shows two basic general methods that each distributor must provide: <br><br><ol><li>  <strong>allocate</strong> - allocates a certain number of bytes and returns the memory address of this area. </li><li>  <strong>free</strong> - frees a previously allocated area of ‚Äã‚Äãmemory with the specified address. </li></ol><br>  With that said, we can do interesting things, for example, chain up several distributors, like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/c95/574/337c95574903fbebe3d34908c381eafa.png" alt="image"></div><br>  <i>Figure 02: Span-Managed Memory.</i> <br><br>  As you can see, one allocator can get its memory, which it will manage, from another (parent) allocator, which, in turn, can get its memory from another allocator, and so on.  In this way, various memory management strategies can be built. <br><br>  To implement my ECS, I created a root stack allocator that receives an initial selection of 1 GB of system memory.  Modules of the second level allocate the necessary amount of memory from the root allocator, and release it only after the application is completed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/3e4/79b/4ff3e479b1cb32a422d08125e9d7953f.png" alt="image"></div><br>  <i>Figure 03: Possible global memory allocation.</i> <br><br>  Figure 03 shows how memory can be distributed between second-level modules: <em>‚ÄúGlobal-Memory-User A‚Äù</em> can be an entity manager, <em>‚ÄúGlobal-Memory-User B‚Äù</em> can be a component manager, and <em>Global-Memory-User C can</em> be a manager. systems. <br><br><h4>  Journaling </h4><br>  I won't talk much about logging, because I just used log4cplus <sup>[7]</sup> , which does all the work for me.  All I did was set the base class <a href="" rel="noopener">Logger</a> , which defines the object <em>log4cplus :: Logger</em> and several wrapper methods that transmit simple logging calls like ‚ÄúLogInfo ()‚Äù, ‚ÄúLogWarning ()‚Äù, etc. <br><br><h4>  Entity-Manager, IEntity, Entity &lt;T&gt; </h4><br>  Ok, now let's talk about the very ‚Äúmeat‚Äù of architecture: the blue area in Figure 01. You might have noticed a similar structure of all dispatcher objects and their corresponding classes.  For example, take a look at the <em><a href="" rel="noopener">EntityManager</a></em> , <a href="" rel="noopener"><em>IEntity,</em></a> and <em><a href="" rel="noopener">Entity &lt;T&gt;</a></em> classes.  The <em>EntityManger</em> class must manage <u>all</u> entity objects at run time.  Its tasks include creating, deleting, and accessing existing entity objects.  <em>IEntity</em> is an interface class that provides the simplest characteristics of an entity object, such as an object identifier and an (static) type identifier.  It is static because it does not change after initializing the program.  This class identifier is constant each time you start the application and can change only when the source code changes. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEntity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ! EntityId m_Id; public: IEntity(); virtual ~IEntity(); virtual const EntityTypeId GetStaticEntityTypeID() const = 0; inline const EntityId GetEntityID() const { return this-&gt;m_Id; } };</span></span></code> </pre> <br>  A type identifier is an integer value that varies for each particular class of entity.  This allows you to check the type of an <em>IEntity</em> object at run time.  Last but not least, is the <em>Entity</em> &lt;T&gt; template class. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Entity</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEntity { <span class="hljs-comment"><span class="hljs-comment">//  ! void operator delete(void*) = delete; void operator delete[](void*) = delete; public: static const EntityTypeId STATIC_ENTITY_TYPE_ID; Entity() {} virtual ~Entity() {} virtual const EntityTypeId GetStaticEntityTypeID() const override { return STATIC_ENTITY_TYPE_ID; } }; //      template const EntityTypeId Entity::STATIC_ENTITY_TYPE_ID = util::Internal::FamilyTypeID::Get();</span></span></code> </pre> <br>  The main purpose of this class is to initialize the unique identifier of the type of a particular entity class.  Here I used two facts: first, the initialization of the constant <sup>[10] of</sup> static variables;  secondly, the nature of the work of template classes.  Each version of the <em>Entity &lt;T&gt;</em> template class will have its own static variable <em>STATIC_ENTITY_TYPE_ID</em> .  It, in turn, guaranteed to be initialized to perform all dynamic initializations.  The fragment " <em>util :: Internal :: FamilyTypeID :: Get ()</em> " is used to implement something like a type counter mechanism.  It increments the counter every time it is called with another <em>T</em> , but it always returns one value when called again with one <em>T.</em>  Not sure if such a template has its name, but it is quite convenient.  At this stage, I also got rid of the operator delete and delete [].  So I made it impossible for them to randomly call.  In addition, because of this (if your compiler is smart enough), you will get a warning when you try to use the new or new [] operator for entity objects, because there is no longer any opposite operator.  These operators should not be used, because the <em>EntityManager</em> class will be responsible for all of their tasks.  So let's summarize what we have already learned.  The dispatcher class provides the simplest functions, such as creating, deleting, and accessing objects.  The class-interface is used as the most root base class and provides a unique identifier of the object and a type identifier.  The template class ensures the correct initialization of the type identifier and eliminates the delete / delete [] operator.  The same template classes dispatcher, interface and template are used for components, systems and events.  The only, but important, difference between these groups is how the dispatcher classes store their objects and access them. <br><br>  Let's first take a look at the EntityManager class.  Figure 04 shows the overall storage structure of the elements. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/206/fc4/567/206fc456770c4c07298d4f3c157a833a.png" alt="image"></div><br>  <i>Figure 04: Abstract scheme of the class EntityManager and storage of its objects.</i> <br><br>  When creating a new entity object, use the <em>EntityManager :: CreateEntity &lt; <strong>T</strong> &gt;</em> method <em>(arguments ...)</em> .  This generic method first gets the template parameter, which is the type of the particular entity being created.  Then this method gets optional parameters (they may not be), which are passed to the constructor <strong>T.</strong>  These parameters are passed through a template with a variable number of arguments <sup>[11]</sup> .  During creation, the following actions occur inside: <br><br><ol><li>  Obtained <em>ObjectPool <sup>[12]</sup></em> for entity objects of type <strong>T</strong> ;  if this pool does not exist, then a new one is created </li><li>  Memory is allocated from this pool;  exactly as needed to store the object <strong>T</strong> </li><li>  Before calling the constructor <strong>T</strong> from the dispatcher, a new <em>EntityId is obtained</em> .  This identifier with previously allocated memory will be saved to the lookup table;  this way we can search for an instance of the entity with the desired identifier </li><li>  Then the replacement of the C ++ new operator <em><sup>[13]</sup></em> with the <em>arguments</em> passed as input is called to create a new instance of <strong>T</strong> </li><li>  finally, the method returns the identity of the entity. </li></ol><br>  After creating a new instance of an entity object, you can access it using its unique <strong>object</strong> identifier ( <em>EntityId</em> ) and <em>EntityManager :: GetEntity (EntityId id)</em> .  To destroy an instance of an entity object, call the <em>EntityManager :: DestroyEntity (EntityId id)</em> method. <br><br>  The ComponentManager class works in the same way, plus another extension.  In addition to the pools of objects for storing all sorts of objects, it must provide an additional mechanism for linking components to the entities objects that own them.  This restriction leads to the second stage of the search: first we check whether an entity exists with a given <em>EntityId</em> , and if so, we check whether a particular type of component is attached to this entity by performing a search in the list of its components. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4d/4e8/505/f4d4e850588b44bf32d7fd41c61ec4ff.png" alt="image"></div><br>  <i>Figure 05: Storage scheme of the Component-Manager object.</i> <br><br>  The <em>ComponentManager :: CreateComponent &lt;T&gt; method (EntityId id, arguments ...)</em> allows us to add a specific component to the entity.  With the help of <em>ComponentManager :: GetComponent &lt;T&gt; (EntityId id),</em> we can access the components of an entity, where T defines the type of component we want to access.  If the component is missing, then <em>nullptr is</em> returned.  To remove a component from an entity, use the <em>ComponentManager :: RemoveComponent &lt;T&gt; (EntityId id) method</em> .  But wait, there's more.  Another way to access components is to use <em>ComponentIterator &lt;T&gt;</em> .  In this way, it is possible to iterate over all existing components of a certain type T. This can be convenient, for example, if a system such as the ‚ÄúPhysics-System‚Äù has to apply gravity to all components of solids. <br><br>  The SystemManager class does not have any special add-ons for storing systems and accessing them.  To store the system, a simple memory allocation is used with the type identifier as the key. <br><br>  The EventManager class uses a linear allocator that manages the memory region.  This memory is used as an event buffer.  Events are stored in this buffer and later transmitted.  When an event is transmitted, the buffer is cleared and new events can be stored in it.  This happens at least once per frame. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b9/1b3/8b8/0b91b38b82d5a16556ceb39616b43a0f.png" alt="image"><br>  <i>Figure 06: Revised ECS Architecture Diagram</i> <br><br>  I hope you now have some idea of ‚Äã‚Äãhow the structure of my ECS works.  If not, then do not worry, look at Figure 06 and briefly repeat it.  As you can see, <em>EntityId is</em> quite important, because we will use it to access a specific instance of an entity object and all its components.  All components know their owner, that is, having a component object, you can easily get an entity by querying the EntityManager class with the specified identifier of the owner of this component.  To pass an entity, we never pass a pointer directly, but use events in conjunction with an <em>EntityId</em> .  You can create a specific event, say <em>EntityDied</em> , and this event (which should be an object with a simple data structure) has an element of type <em>EntityId</em> .  Now to notify all event recipients ( <em>IEventListener</em> ), which can be entities, components, or systems, we use <em>EventManager :: SendEvent &lt;EntityDied&gt; (entityId)</em> .  An event receiver on the other hand can now use the passed <em>EntityId</em> and query the EntityManager class to get an entity object or the ComponentManager class to get a specific component of that entity.  The reason for this circumferential path is simple ‚Äî at any point in the execution of an application, you can, by any logic, delete an entity or one of its components.  Since we will not clutter up the code with additional cleanup actions, we will use <em>EntityId</em> .  If the dispatcher returns a <em>nullptr</em> for this <em>EntityId</em> , then we will know that the entity or component no longer exists.  By the way, the red square corresponds to the same in Figure 01 and denotes the boundaries of ECS. <br><br><h4>  Engine object </h4><br>  To make everything a little more convenient, I created an engine object.  The object engine provides easy integration and use of client software.  On the client side, it is enough to add the header file "ECS / ECS.h" and call the <em>ECS :: Initialize ()</em> method.  Now the static global engine object will be initialized ( <em>ECS :: ECS_Engine</em> ) and can be used on the client side to gain access to the dispatcher classes.  Moreover, it provides the <em>SendEvent &lt;T&gt;</em> method for sending messages and the Update method, which automatically transmits all events and updates all systems.  <em>ECS :: Terminate ()</em> must be called before exiting the main program.  This ensures that all received resources will be released.  The following code snippet demonstrates the simplest use of a global engine object. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ECS/ECS.h&gt; int main(int argc,char* argv[]) { //    'ECS_Engine' ECS::Initialize(); const float DELTA_TIME_STEP = 1.0f / 60.0f; // 60  bool bQuit = false; //      while(bQuit == false) { //   ,     , //      ... ECS::ECS_Engine-&gt;(DELTA_TIME_STEP); /* ECS::ECS_Engine-&gt;GetEntityManager()-&gt;...; ECS::ECS_Engine-&gt;GetComponentManager()-&gt;...; ECS::ECS_Engine-&gt;GetSystemManager()-&gt;...; ECS::ECS_Engine-&gt;SendEvent&lt;T&gt;(...); */ //   ... } //    'ECS_Engine' ECS::Terminate(); return 0; }</span></span></span></span></code> </pre> <br><h4>  Conclusion </h4><br>  The ‚Äúentity-component-system‚Äù architecture described in this part of the article is fully functional and ready for use.  But as usual, there are always ideas for improvement.  Here are just some of the ideas that came to my mind: <br><br><ul><li>  Make the architecture thread safe </li><li>  Execute each system or group of systems in streams, taking into account their topological order, </li><li>  Perform event-sourcing and memory management refactoring to use as modules, </li><li>  Serialization </li><li>  Profiling </li><li>  ... </li></ul><br>  I prepared a demo so you can see my ECS in action: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/idYdpPCUsyg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The <em>BountyHunter</em> demo makes extensive use of ECS and demonstrates the power of this template.  In the second part of the post I will talk about it. <br><br><h4>  Reference materials </h4><br>  <sup>[1]</sup> <a href="https://en.wikipedia.org/wiki/Entity%25E2%2580%2593component%25E2%2580%2593system" rel="noopener">https://en.wikipedia.org/wiki/Entity-component-system</a> <br><br>  <sup>[2]</sup> <a href="http://gameprogrammingpatterns.com/component.html" rel="noopener">http://gameprogrammingpatterns.com/component.html</a> <br><br>  <sup>[3]</sup> <a href="https://www.gamedev.net/articles/programming/general-and-gameplay-programming/understanding-component-entity-systems-r3013/" rel="noopener">https://www.gamedev.net/articles/programming/general-and-gameplay-programming/understanding-component-entity-systems-r3013/</a> <br><br>  <sup>[4]</sup> <a href="https://github.com/junkdog/artemis-odb/wiki/Introduction-to-Entity-Systems" rel="noopener">https://github.com/junkdog/artemis-odb/wiki/Introduction-to-Entity-Systems</a> <br><br>  <sup>[5]</sup> <a href="http://scottbilas.com/files/2002/gdc_san_jose/game_objects_slides.pdf" rel="noopener">http://scottbilas.com/files/2002/gdc_san_jose/game_objects_slides.pdf</a> <br><br>  <sup>[6]</sup> <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing" rel="noopener">https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing</a> <br><br>  <sup>[7]</sup> <a href="https://sourceforge.net/p/log4cplus/wiki/Home/" rel="noopener">https://sourceforge.net/p/log4cplus/wiki/Home/</a> <br><br>  <sup>[8]</sup> <a href="https://www.gamedev.net/articles/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/" rel="noopener">https://www.gamedev.net/articles/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/</a> <br><br>  <sup>[9]</sup> <a href="https://www.gamedev.net/articles/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/" rel="noopener">https://github.com/mtrebi/memory-allocatorshttps://www.gamedev.net/articles/programming/general-and-gameplay-programming/c-custom-memory-allocation-r3010/</a> <br><br>  <sup>[10]</sup> <a href="http://en.cppreference.com/w/cpp/language/constant_initialization" rel="noopener">http://en.cppreference.com/w/cpp/language/constant_initialization</a> <br><br>  <sup>[11]</sup> <a href="https://en.wikipedia.org/wiki/Variadic_template" rel="noopener">https://en.wikipedia.org/wiki/Variadic_template</a> <br><br>  <sup>[12]</sup> <a href="http://gameprogrammingpatterns.com/object-pool.html" rel="noopener">http://gameprogrammingpatterns.com/object-pool.html</a> <br><br>  <sup>[13]</sup> <a href="http://en.cppreference.com/w/cpp/language/new" rel="noopener">http://en.cppreference.com/w/cpp/language/new</a> <br><br><h2>  Part 2: BountyHunter Game </h2><br>  Now I want to show you how to actually use architecture to create games on it.  I admit that my game does not look very complicated, but if you decide to use my implementation to create your own game instead of a large and complex game engine like <a href="https://unity3d.com/" rel="noopener">Unity</a> or <a href="http://unrealengine.com/" rel="noopener">Unreal</a> , you can mention my authorship.  To demonstrate the capabilities of my ECS, this game was enough for me.  If you do not understand its rules, the following picture will help you: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c4/fd3/8e8/6c4fd38e8d700ce208a873299571770b.png" alt="image"></div><br>  <i>Figure 01: Purpose and rules of the game BountyHunter.</i>  <i>Purpose: each player seeks to replenish their own supplies as quickly as possible.</i>  <i>Rules: 1. The game has a time limit.</i>  <i>After the time the game ends.</i>  <i>2. Touching the loot, the picker picks it up.</i>  <i>3. Pickers can carry a limited amount of loot.</i>  <i>If the limit is reached, the collector can no longer collect the prey, and when it touches the prey, it is destroyed.</i>  <i>4. If the picker touches his own or enemy supplies, then all the collected booty is dumped into the supplies and the picker can pick up the booty again.</i>  <i>5. When a collector collides, they are destroyed and after some time they are revived at the point of their supplies.</i>  <i>Collected loot is lost.</i>  <i>6. Mining appears at a random point in the central part of the world and exists during its lifespan, or until it is collected.</i>  <i>7. When the collector crosses the borders of the world, it appears from the other edge of the screen.</i> <br><br>  The image on the left looks familiar, because it is a more abstract scheme of the game that you saw in the video.  The rules are clear enough and speak for themselves.  As you can see, we have many types of entities living in the game world.  You might be wondering what they are actually made of?  Of the components, of course.  Some types of components are common to all entities, while others are unique to others.  Look at the picture below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db6/486/421/db6486421d2282d555d5ac5af577aafc.png" alt="image"></div><br>  <i>Figure 02: Essence and its components.</i> <br><br>  Looking at this picture, you can easily see the relationship between the entities and their components (not everything is reflected in the picture!).  All game entities have <em>Transform-Component</em> .  Since the game entities must be located somewhere in the world, they have a transform that describes the position, rotation, and scale of the entities.  This may be the only component attached to the entity.  For example, the camera object requires more components, but it does not need the <em>Material Component</em> , because it will never be visible to the player (which may be wrong if you use post-effects).  On the other hand, the objects of the <em>Bounty</em> (mining) and <em>Collector</em> (collection) entities must be visible, so they need a <em>Material-Component</em> to display.  They can also collide with other objects of the game, and therefore the <em>Collision-Component</em> is attached to them, which describes their physical form.  Another component is attached to the <em>Bounty</em> entity - <em>Lifetime-Component</em> .  This component determines the remaining life of the <em>Bounty</em> object, when its life ends, then the prey is destroyed. <br><br>  So what next?  Having created all these different entities with their own sets of components, we did not complete the game itself.  We also need someone who knows how to manage each of them.  Of course, I'm talking about systems.  Systems are a great thing, they can be used to divide the whole logic of the game into smaller elements.  Each element works with its own aspect of the game.  We can have, or even should have, an <em>Input-System</em> that processes all data entered by the player.  <em>Render-System</em> , carrying all shapes and colors on the screen.  <em>Respawn-System</em> for the revival of the dead objects of the game.  Well, I think you get the idea.  The figure below shows the complete diagram of the classes of all specific types of entities, components and systems in <em>BountyHunter</em> . <br><br><div style="text-align:center;"> <a href="https://www.gamedev.net/applications/core/interface/imageproxy/ximageproxy.php,qimg="><img src="https://habrastorage.org/getpro/habr/post_images/e58/818/3eb/e588183eb0e95a0225ca34a957f16480.png" alt="image"></a> </div><br>  <i>Figure 03: ECS BountyHunter Class Diagram (click on image to enlarge).</i> <br><br>  Now we have entities, components and a system (ECS), but we lack ... events!  So that systems and entities can exchange data, I created a collection of 38 events: <br><br><pre>  GameInitializedEvent GameRestartedEvent GameStartedEvent 
 GamePausedEvent GameResumedEvent GameoverEvent GameQuitEvent 
 PauseGameEvent ResumeGameEvent RestartGameEvent QuitGameEvent 
 LeftButtonDownEvent LeftButtonUpEvent LeftButtonPressedEvent 
 RightButtonDownEvent RightButtonUpEvent RightButtonPressedEvent
 KeyDownEvent KeyUpEvent KeyPressedEvent ToggleFullscreenEvent
 EnterFullscreenModeEvent StashFull EnterWindowModeEvent 
 GameObjectCreated GameObjectDestroyed PlayerLeft GameObjectSpawned
 GameObjectKilled CameraCreated, CameraDestroyed ToggleDebugDrawEvent
 WindowMinimizedEvent WindowRestoredEvent WindowResizedEvent 
 PlayerJoined CollisionBeginEvent CollisionEndEvent </pre><br>  And there is still a lot that I needed to implement <em>BountyHunter</em> : <br><br><ul><li>  <strong>general application framework</strong> - <a href="https://www.libsdl.org/index.php" rel="noopener">SDL2</a> for receiving player input and setting up the main application window. </li><li>  <strong>graphics</strong> - I used my own OpenGL renderer so that I could render to this application window. </li><li>  <strong>math</strong> - for linear algebra I used <a href="https://glm.g-truc.net/0.9.8/index.html" rel="noopener">glm</a> . </li><li>  <b>collision detection</b> - for it I used <a href="http://box2d.org/" rel="noopener">box2d</a> physics. </li><li>  <strong>State machine</strong> - used for simple AI and game states. </li></ul><br>  Of course, I will not consider all these mechanics, because they deserve their own article, which I may write later.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if you still want to know about them, then I will not bother you and give this </font></font><a href="https://github.com/tobias-stein/EntityComponentSystem/tree/master/BountyHunterDemo" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">After reviewing all the characteristics I mentioned, you can decide that this can be a good start for your own game engine. </font><font style="vertical-align: inherit;">There are a few more items on my list that I actually didn‚Äôt realize, simply because I wanted to complete the prototype.</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for managing entities, components, systems and more.</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saving the game</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - saving entities and their components to the database using some ORM library (for example, </font></font><a href="https://www.codesynthesis.com/products/odb/" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codesynthesis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replay playback</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - recording events at runtime and replaying them later</font></font></li><li> <strong>GUI</strong> ‚Äî  GUI- (, <a href="https://github.com/libRocket/libRocket" rel="noopener">librocket</a> )      </li><li> <strong> </strong> ‚Äî      (, ,   ..)      </li><li> <strong>  </strong> ‚Äî         </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will leave these points as a task for you so that you can prove how cool you are a programmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also need to show you the code that demonstrates the use of my ECS. Remember the essence of the game </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bounty</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? Mining is small yellow, large red and intermediate squares randomly created in the center of the world. The following is a code snippet for the definition of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bounty</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entity class </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Bounty.h class Bounty : public GameObject&lt;Bounty&gt; { private: //   TransformComponent* m_ThisTransform; RigidbodyComponent* m_ThisRigidbody; CollisionComponent2D* m_ThisCollision; MaterialComponent* m_ThisMaterial; LifetimeComponent* m_ThisLifetime; //   bounty float m_Value; public: Bounty(GameObjectId spawnId); virtual ~Bounty(); virtual void OnEnable() override; virtual void OnDisable() override; inline float GetBounty() const { return this-&gt;m_Value; } //  OnEnable,      void ShuffleBounty(); };</span></span></code> </pre> <br>     .     ,   <em>GameObject&lt; <strong>T</strong> &gt;</em> (   <em>ECS::Entity&lt; <strong>T</strong> &gt;)</em>    ( <em>Bounty</em> )   <strong>T</strong> .  ECS           () .        <em>AddComponent&lt; <strong>U</strong> &gt;</em> , <em>GetComponent&lt; <strong>U</strong> &gt;</em> , <em>RemoveComponent&lt; <strong>U</strong> &gt;</em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In addition to the components that I will show soon, there is another property - the value of production. I don‚Äôt remember exactly why I didn‚Äôt select this property in a separate component, for example, in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BountyComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because it would be so. Instead, I made the value property of a booty a member of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bounty</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">, sprinkling my head with ashes. But in fact it only shows the enormous flexibility of this template, doesn‚Äôt it? More precisely, its components ...</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Bounty.cpp Bounty::Bounty(GameObjectId spawnId) { Shape shape = ShapeGenerator::CreateShape&lt;QuadShape&gt;(); AddComponent&lt;ShapeComponent&gt;(shape); AddComponent&lt;RespawnComponent&gt;(BOUNTY_RESPAWNTIME, spawnId, true); //    this-&gt;m_ThisTransform = GetComponent&lt;TransformComponent&gt;(); this-&gt;m_ThisMaterial = AddComponent&lt;MaterialComponent&gt;(MaterialGenerator::CreateMaterial&lt;defaultmaterial&gt;()); this-&gt;m_ThisRigidbody = AddComponent&lt;RigidbodyComponent&gt;(0.0f, 0.0f, 0.0f, 0.0f, 0.0001f); this-&gt;m_ThisCollision = AddComponent&lt;CollisionComponent2d&gt;(shape, this-&gt;m_ThisTransform-&gt;AsTransform()-&gt;GetScale(), CollisionCategory::Bounty_Category, CollisionMask::Bounty_Collision); this-&gt;m_ThisLifetime = AddComponent&lt;LifetimeComponent&gt;(BOUNTY_MIN_LIFETIME, BOUNTY_MAX_LIFETIME); } //   ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I used the designer to connect all the components necessary essence </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bounty</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Notice that with this approach, an object blank is created and it is not flexible, that is, you always get a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bounty</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">with the same components attached to it. Although this is a fairly good solution for my game, for more complex it may be erroneous. In this case, you need to implement a ‚Äúfactory‚Äù template that creates mutable entity objects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As can be seen from the code above, </font><font style="vertical-align: inherit;">quite a few components are attached </font><font style="vertical-align: inherit;">to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bounty</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entity </font><font style="vertical-align: inherit;">. We have a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShapeComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MaterialComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for visual display. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RigidbodyComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CollisionComponent2D</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for physical behavior and reaction to collisions. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RespawnComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so that the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bounty</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has the opportunity to be reborn after death. Last but not </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">least</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><em><font style="vertical-align: inherit;">LifetimeComponent</font></em><font style="vertical-align: inherit;"> binds the existence of an entity to a specific period of time. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TransformComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> automatically binds to any entity derived from </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject &lt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt;</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> That's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We just added a new entity to the game. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you may want to know how to use all these components. Let me give you two examples. The first is </font></font><em><a href="" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RigidbodyComponent</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This component contains information about physical characteristics, such as friction, density, and linear attenuation. Moreover, it is used as an adapter class used for embedding box2d physics into the game. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RigidbodyComponent is</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quite important because it is used to synchronize the transform of a physically simulated body (owned by box2d) and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TransformComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entities (owned by the game). This synchronization process is performed by the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PhysicsSystem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// PhysicsEngine.h class PhysicsSystem : public ECS::System&lt;PhysicsSystem&gt;, public b2ContactListener { public: PhysicsSystem(); virtual ~PhysicsSystem(); virtual void PreUpdate(float dt) override; virtual void Update(float dt) override; virtual void PostUpdate(float dt) override; //      box2d     virtual void BeginContact(b2Contact* contact) override; virtual void EndContact(b2Contact* contact) override; }; // class PhysicsSystem</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// PhysicsEngine.cpp void PhysicsSystem::PreUpdate(float dt) { //       TransformComponent for (auto RB = ECS::ECS_Engine-&gt;GetComponentManager()-&gt;begin&lt;RigidbodyComponent&gt;(); RB != ECS::ECS_Engine-&gt;GetComponentManager()-&gt;end&lt;RigidbodyComponent&gt;(); ++RB) { if ((RB-&gt;m_Box2DBody-&gt;IsAwake() == true) &amp;&amp; (RB-&gt;m_Box2DBody-&gt;IsActive() == true)) { TransformComponent* TFC = ECS::ECS_Engine-&gt;GetComponentManager()-&gt;GetComponent&lt;TransformComponent&gt;(RB-&gt;GetOwner()); const b2Vec2&amp; pos = RB-&gt;m_Box2DBody-&gt;GetPosition(); const float rot = RB-&gt;m_Box2DBody-&gt;GetAngle(); TFC-&gt;SetTransform(glm::translate(glm::mat4(1.0f), Position(pos.x, pos.y, 0.0f)) * glm::yawPitchRoll(0.0f, 0.0f, rot) * glm::scale(TFC-&gt;AsTransform()-&gt;GetScale())); } } } //   ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the above implementation, you can see three different update functions. When updating systems, all </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PreUpdate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> methods of </font><font style="vertical-align: inherit;">all systems </font><font style="vertical-align: inherit;">are called first </font><font style="vertical-align: inherit;">, then </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostUpdate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> methods after them </font><font style="vertical-align: inherit;">. Since the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PhysicsSystem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is called before all </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TransformComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> system-related, the above code provides transform synchronization. Here you can also see the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComponentIterator</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> action </font><font style="vertical-align: inherit;">. Instead of asking every entity in the world whether it has a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RigidbodyComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we ask the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComponentManager to</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provide us with a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComponentIterator</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the </font><em><font style="vertical-align: inherit;">RigidbodyComponent</font></em><font style="vertical-align: inherit;"> type</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Having received </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RigidbodyComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we can easily get the entity identifier and once again ask the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ComponentManager</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to give us the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TransformComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for this identifier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I promised, let's consider the second example. </font></font><a href="" rel="noopener"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RespawnComponent is</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used for entities that must be regenerated after death. This component provides five properties that you can use to customize the rebirth behavior of an entity. You can choose an automatic revival of the entity after death, set the time after which it will be revived, as well as the position and orientation of the revival. The rebirth logic itself is implemented in the </font></font><a href=""><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RespawnSystem</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// RespawnSystem.h class RespawnSystem : public ECS::System&lt;RespawnSystem&gt;, protected ECS::Event::IEventListener { private: // ...   Spawns m_Spawns; RespawnQueue m_RespawnQueue; //    void OnGameObjectKilled(const GameObjectKilled* event); public: RespawnSystem(); virtual ~RespawnSystem(); virtual void Update(float dt) override; //  ... }; // class RespawnSystem</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// RespawnSystem.cpp // :   ! voidRespawnSystem::OnGameObjectKilled(const GameObjectKilled * event) { // ,      RespawnComponent* entityRespawnComponent = ECS::ECS_Engine-&gt;GetComponentManager()-&gt;GetComponent&lt;RespawnComponent&gt;(event-&gt;m_EntityID); if(entityRespawnComponent == nullptr || (entityRespawnComponent-&gt;IsActive() == false) || (entityRespawnComponent-&gt;m_AutoRespawn == false)) return; AddToRespawnQeueue(event-&gt;m_EntityID, entityRespawnComponent); } void RespawnSystem::Update(float dt) { foreach(spawnable in this-&gt;m_RespawnQueue) { spawnable.m_RemainingDeathTime -= dt; if(spawnable.m_RemainingDeathTime &lt;= 0.0f) { DoSpawn(spawnable); RemoveFromSpawnQueue(spawnable); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above code is incomplete, but gives an idea of ‚Äã‚Äãthe important lines of code. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RespawnSystem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contains and updates the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EntityId queue</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> along with their </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RespawnComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . New entities are queued when systems receive a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObjectKilled</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event </font><font style="vertical-align: inherit;">. The system checks whether the killed entity has a revival capability, that is, if the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RespawnComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is attached to it </font><font style="vertical-align: inherit;">. If so, then the entity is queued for revival, otherwise ignored. In the update method </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RespawnSystem</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is called every frame, the system reduces the initial recovery time </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RespawnComponent</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queued entities. If the revival time is reduced to zero, then the entity is revived and removed from the revival queue.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know the article was rather short. but I hope she gave you a rough idea of ‚Äã‚Äãhow everything works in the ECS world. Before you finish the post, I want to share with you my own experience. Working with ECS is a great pleasure. It's amazing to just add new features to the game even with the help of third-party libraries. I just added new components and systems that connect new features with the game, and I never had the feeling that I was stumped. Dividing the entire game logic into several systems is intuitive and does not cause any difficulties when working with ECS. The code looks much clearer and becomes more convenient in support, because we got rid of all the ‚Äúspaghetti dependencies‚Äù of pointers. Event sourcing is a very powerful and useful data exchange technique between systems / entities, but it is a double-edged blade,and may cause problems over time. I'm talking about the conditions of the call event. If you have ever worked with Unity or Unreal Engine, then you will be satisfied with the implementation of such an editor. These editors greatly increase productivity, because it takes much less time to create new ECS objects than to write all these lines of code manually. But when you create a powerful foundation of entity objects, components, systems, and events, then combining them and creating something qualitative based on them will be a simple task.than writing all these lines of code manually. But when you create a powerful foundation of entity objects, components, systems, and events, then combining them and creating something qualitative based on them will be a simple task.than writing all these lines of code manually. But when you create a powerful foundation of entity objects, components, systems, and events, then combining them and creating something qualitative based on them will be a simple task.</font></font></div><p>Source: <a href="https://habr.com/ru/post/343778/">https://habr.com/ru/post/343778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343766/index.html">When you start a startup and find out that it is not a startup at all</a></li>
<li><a href="../343770/index.html">Lecture Yandex: Advanced UI, Part One</a></li>
<li><a href="../343772/index.html">‚ÄúI am watching you‚Äù or how to make SCADA from CADa (MultiCAD.NET API)</a></li>
<li><a href="../343774/index.html">Hole from a hosting provider or how to get access to a remote (not active) account</a></li>
<li><a href="../343776/index.html">Ideal catalog, data sample optimization</a></li>
<li><a href="../343780/index.html">Virtual Pentest Laboratory</a></li>
<li><a href="../343782/index.html">Two years of successful use of Edition-Based Redefiniton in Oracle databases</a></li>
<li><a href="../343784/index.html">C ++ crashes in WebAssembly on different browsers</a></li>
<li><a href="../343788/index.html">Patties in go</a></li>
<li><a href="../343790/index.html">Configuring Authentication in SAP Netweaver AS Java (Part 3 of 3)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>