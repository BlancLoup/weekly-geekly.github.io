<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The subtleties of Scala: we study CanBuildFrom</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the standard Scala library, the collection methods ( map , flatMap , scan , etc.) take an instance of CanBuildFrom type as an implicit parameter. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The subtleties of Scala: we study CanBuildFrom</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/2b5/196/924/2b51969243104de48426a74fe9e6b2c2.jpg" alt="image"></p><br><p>  In the standard Scala library, the collection methods ( <em>map</em> , <em>flatMap</em> , <em>scan</em> , etc.) take an instance of <em>CanBuildFrom</em> type as an implicit parameter.  In this article we will examine in detail what this treit is for, how it works and how it can be useful for the developer. </p><br><a name="habracut"></a><br><h1 id="kak-eto-rabotaet">  How it works </h1><br><p>  The main purpose served by <em>CanBuildFrom</em> is to provide the compiler with the result type for the <em>map</em> , <em>flatMap,</em> and the like methods, for example, the definition of the <em>map</em> in the <em>TraversableLike</em> wizard: </p><br><pre><code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>, <span class="hljs-type"><span class="hljs-type">That</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> bf: <span class="hljs-type"><span class="hljs-type">CanBuildFrom</span></span>[<span class="hljs-type"><span class="hljs-type">Repr</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>, <span class="hljs-type"><span class="hljs-type">That</span></span>]): <span class="hljs-type"><span class="hljs-type">That</span></span></code> </pre> <br><p>  The method returns an object of type <em>That</em> , which appears in the description only as a parameter for <em>CanBuildFrom</em> .  The appropriate <em>CanBuildFrom</em> instance <em>is</em> selected by the compiler based on the type of the original <em>Repr</em> collection and the type of result of the user-defined function <em>B.</em>  The choice is made from the set of values ‚Äã‚Äãdeclared in the <em>Predef</em> object and companions of collections (the rules for choosing implicit values ‚Äã‚Äãdeserve a separate article and are described in detail in <a href="http://www.scala-lang.org/files/archive/spec/2.12/07-implicits.html">the language specification</a> ). </p><br><p>  In fact, using <em>CanBuildFrom</em> results in the same type of result as in the case of the simplest parameterized method: </p><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](x: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">T</span></span> = x.head f: [<span class="hljs-type"><span class="hljs-type">T</span></span>](x: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>])<span class="hljs-type"><span class="hljs-type">T</span></span> scala&gt; f(<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) res0: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> scala&gt; f(<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-number"><span class="hljs-number">3.14</span></span>)) res1: <span class="hljs-type"><span class="hljs-type">Double</span></span> = <span class="hljs-number"><span class="hljs-number">3.14</span></span> scala&gt; f(<span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-string"><span class="hljs-string">"Pi"</span></span>)) res2: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-type"><span class="hljs-type">Pi</span></span></code> </pre> <br><p>  That is, when you call </p><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>).map(_ * <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  the compiler will select an instance of <em>CanBuildFrom</em> from the <em>GenTraversableFactory</em> class, which is described as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericCanBuildFrom</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanBuildFrom</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CC</span></span></span><span class="hljs-class">[_], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CC</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">]]</span></span></code> </pre> <br><p>  and returns a collection of the same type but with elements received from the user function: <em>CC [A]</em> .  In other cases, the compiler may choose a more suitable type of result, for example, for strings: </p><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-string"><span class="hljs-string">"abc"</span></span>.map(_.toUpper) <span class="hljs-comment"><span class="hljs-comment">// Predef.StringCanBuildFrom res3: String = ABC scala&gt; "abc".map(_ + "*") // Predef.fallbackStringCanBuildFrom[String] res4: scala.collection.immutable.IndexedSeq[String] = Vector(a*, b*, c*) scala&gt; "abc".map(_.toInt) // Predef.fallbackStringCanBuildFrom[Int] res5: scala.collection.immutable.IndexedSeq[Int] = Vector(97, 98, 99)</span></span></code> </pre> <br><p>  In the first case, <em>StringCanBuildFrom is</em> selected, the result is <em>String</em> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">StringCanBuildFrom</span></span>: <span class="hljs-type"><span class="hljs-type">CanBuildFrom</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Char</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre> <br><p>  In the second and third - the <em>fallbackStringCanBuildFrom</em> method, the result is <em>IndexedSeq</em> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fallbackStringCanBuildFrom</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]: <span class="hljs-type"><span class="hljs-type">CanBuildFrom</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>, immutable.<span class="hljs-type"><span class="hljs-type">IndexedSeq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]]</code> </pre> <br><h1 id="ispolzovanie-breakout">  Using breakOut </h1><br><p>  Consider using the <em>Map</em> class.  This type of collection is easy to convert to <em>Iterable</em> , if you return from the conversion function not a pair, but a single value: </p><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"c"</span></span>).map(_._2) res6: scala.collection.immutable.<span class="hljs-type"><span class="hljs-type">Iterable</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">List</span></span>(a, b, c)</code> </pre> <br><p>  But to get the <em>Map</em> from the list of pairs you need to call the <em>toMap</em> method: </p><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>('a', 'b', 'c').map(x =&gt; x.toInt -&gt; x) res7: <span class="hljs-type"><span class="hljs-type">List</span></span>[(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Char</span></span>)] = <span class="hljs-type"><span class="hljs-type">List</span></span>((<span class="hljs-number"><span class="hljs-number">97</span></span>,a), (<span class="hljs-number"><span class="hljs-number">98</span></span>,b), (<span class="hljs-number"><span class="hljs-number">99</span></span>,c)) scala&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>('a', 'b', 'c').map(x =&gt; x.toInt -&gt; x).toMap res8: scala.collection.immutable.<span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>,<span class="hljs-type"><span class="hljs-type">Char</span></span>] = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-number"><span class="hljs-number">97</span></span> -&gt; a, <span class="hljs-number"><span class="hljs-number">98</span></span> -&gt; b, <span class="hljs-number"><span class="hljs-number">99</span></span> -&gt; c)</code> </pre> <br><p>  Or use the <em>breakOut</em> method instead of an implicit parameter: </p><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> collection.breakOut <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> collection.breakOut scala&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>('a', 'b', 'c').map(x =&gt; x.toInt -&gt; x)(breakOut) res9: scala.collection.immutable.<span class="hljs-type"><span class="hljs-type">IndexedSeq</span></span>[(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Char</span></span>)] = <span class="hljs-type"><span class="hljs-type">Vector</span></span>((<span class="hljs-number"><span class="hljs-number">97</span></span>,a), (<span class="hljs-number"><span class="hljs-number">98</span></span>,b), (<span class="hljs-number"><span class="hljs-number">99</span></span>,c))</code> </pre> <br><p>  The method, as the name suggests, allows you to "break out" of the boundaries of the type of the original collection and give the compiler more freedom to choose the <em>CanBuildFrom</em> instance: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">breakOut</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">From</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">To</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> b: <span class="hljs-type"><span class="hljs-type">CanBuildFrom</span></span>[<span class="hljs-type"><span class="hljs-type">Nothing</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">To</span></span>]): <span class="hljs-type"><span class="hljs-type">CanBuildFrom</span></span>[<span class="hljs-type"><span class="hljs-type">From</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">To</span></span>]</code> </pre> <br><p>  From the description it can be seen that <em>breakOut</em> does not specialize any of the three parameters, which means it can be used instead of any <em>CanBuildFrom</em> instance.  <em>BreakOut</em> itself implicitly accepts a <em>CanBuildFrom</em> object, but the <em>From</em> parameter in this case is replaced with <em>Nothing</em> , which allows the compiler to use any available <em>CanBuildFrom</em> instance (this happens because the <em>From</em> parameter is declared as contravariant, and the <em>Nothing</em> type is a descendant of any type.) </p><br><p>  In other words, <em>breakOut</em> provides an additional ‚Äúlayer‚Äù that allows the compiler to choose from all the available implementations of <em>CanBuildFrom</em> , and not just those that are valid for the type of the original collection.  In the example above, this makes it possible to use <em>CanBuildFrom</em> from the <em>Map</em> companion, despite the fact that we initially worked with the <em>List</em> .  Another example is getting a string from a list of characters: </p><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>('a', 'b', 'c').map(_.toUpper) res10: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Char</span></span>] = <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>, <span class="hljs-type"><span class="hljs-type">C</span></span>) scala&gt; <span class="hljs-type"><span class="hljs-type">List</span></span>('a', 'b', 'c').map(_.toUpper)(breakOut) res11: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-type"><span class="hljs-type">ABC</span></span></code> </pre> <br><p>  The implementation of <em>CanBuildFrom [String, Char, String] is</em> declared in <em>Predef</em> and therefore takes precedence over declarations in the companion collections. </p><br><h1 id="primer-ispolzovaniya-so-spiskom-_future_">  An example of using the <em>Future</em> list </h1><br><p>  As a small example of using <em>CanBuildFrom,</em> we will write an implementation that will automatically compile the <em>Future</em> list into one object, as <em>Future.sequence</em> does: </p><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]] -&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]]</code> </pre> <br><p>  First, let's take a look inside <em>CanBuildFrom</em> .  Trait declares two abstract <em>apply</em> methods that return a new collection builder based on the results of a user-defined function: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Builder</span></span>[<span class="hljs-type"><span class="hljs-type">Elem</span></span>, <span class="hljs-type"><span class="hljs-type">To</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(from: <span class="hljs-type"><span class="hljs-type">From</span></span>): <span class="hljs-type"><span class="hljs-type">Builder</span></span>[<span class="hljs-type"><span class="hljs-type">Elem</span></span>, <span class="hljs-type"><span class="hljs-type">To</span></span>]</code> </pre> <br><p>  Therefore, to provide your own implementation of <em>CanBuildFrom</em> , you need to prepare and <em>Builder</em> , in which you implement methods for adding an element, clearing the buffer, and getting the result: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FutureBuilder</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Builder</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Future</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Future</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">]]] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> buff = <span class="hljs-type"><span class="hljs-type">ListBuffer</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">+=</span></span></span></span>(elem: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]) = { buff += elem; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-function"> </span></span>= buff.clear <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Future</span></span>.sequence(buff.toSeq) }</code> </pre> <br><p>  The implementation of <em>CanBuildFrom itself is</em> trivial: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FutureCanBuildFrom</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanBuildFrom</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Any</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Future</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Future</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">]]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FutureBuilder</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(from: <span class="hljs-type"><span class="hljs-type">Any</span></span>) = apply } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">futureCanBuildFrom</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FutureCanBuildFrom</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]</code> </pre> <br><p>  Checking: </p><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-type"><span class="hljs-type">Range</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>).map(x =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span>(x * x)) res12: scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Iterable</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]] = scala.concurrent.impl.<span class="hljs-type"><span class="hljs-type">Promise</span></span>$<span class="hljs-type"><span class="hljs-type">DefaultPromise</span></span>@<span class="hljs-number"><span class="hljs-number">360e2</span></span>cfb</code> </pre> <br><p>  Everything is working!  Thanks to the <em>futureCanBuildFrom</em> method <em>,</em> we got directly <em>Future [Iterable [Int]]</em> , i.e.  the transient collection was converted automatically. </p><br><p>  <strong>Warning:</strong> this is just an example of using <em>CanBuildFrom</em> , I‚Äôm not saying that such a solution should be used in your combat code or that it is better than normal wrapping in <em>Future.sequence</em> .  Be careful and do not copy the code into your project without first analyzing the consequences! </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Using <em>CanBuildFrom</em> is closely related to implicit parameters, so a clear understanding of the logic of choice of values ‚Äã‚Äãwill save you from losing time during debugging - do not be lazy to look into the specification of the language or the <a href="http://docs.scala-lang.org/tutorials/FAQ/finding-implicits">Scala FAQ</a> .  The compiler can also help to show which implicit values ‚Äã‚Äãwere chosen if you build a program with the <em>-Xprint</em> flag <em>: typer</em> - this saves a <em>lot of</em> time. </p><br><p>  <em>CanBuildFrom</em> is a very specific thing and you will most likely not have to work closely with it unless you are developing new data structures.  However, an understanding of the principles of its work will not be superfluous and will allow a better understanding of the internal structure of the standard library. </p><br><p>  That's all, thanks and success in learning Scala! </p><br><p>  Corrections and additions to the article, as always, are welcome. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326116/">https://habr.com/ru/post/326116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326106/index.html">PostgreSQL indexes - 2</a></li>
<li><a href="../326108/index.html">A little about the lines in C, or several options to optimize non-optimizable</a></li>
<li><a href="../326110/index.html">It's very simple</a></li>
<li><a href="../326112/index.html">IP KVM DIY 2.0</a></li>
<li><a href="../326114/index.html">Primitives for implementing 1-Wire master using PWM and ICP for STM8L and STM32</a></li>
<li><a href="../326118/index.html">Editors ONLYOFFICE v.4.3: yes, we added footnotes</a></li>
<li><a href="../326120/index.html">5 courses that will help start your way in the design of games</a></li>
<li><a href="../326122/index.html">Test Lossless Image Optimizers (PNG and JPG)</a></li>
<li><a href="../326124/index.html">One-dimensional linear regression, SQL and machine learning</a></li>
<li><a href="../326126/index.html">Lectures Tehnotreka. Designing a DBMS (Fall 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>