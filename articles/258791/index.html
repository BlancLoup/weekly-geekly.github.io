<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The forecast of the execution time of typical consecutive "heavy" calculations in a multiprocessor system in conditions of unpredictable receipt of applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The idea of ‚Äã‚Äãwriting the first article on Habr arose in the process of ‚Äúcollecting stones‚Äù to create a server system, the main tasks of which are: 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The forecast of the execution time of typical consecutive "heavy" calculations in a multiprocessor system in conditions of unpredictable receipt of applications</h1><div class="post__text post__text-html js-mediator-article">  The idea of ‚Äã‚Äãwriting the first article on Habr arose in the process of ‚Äúcollecting stones‚Äù to create a server system, the main tasks of which are: <br><br><ul><li>  receiving requests from users for some typical sequential "heavy" calculations; </li><li>  implementation of calculations; </li><li>  issuing information (on request) about the remaining computation time; </li><li>  issuing the results of calculations on their completion. </li></ul><br><img src="https://habrastorage.org/files/a63/495/3f9/a634953f9e5c417ba9a5ba2d49dd17b0.png"><br>  A number of circumstances should be clarified: <br><br><ul><li>  By sequential calculation, we mean a calculation that is carried out by no more than one processor core (non-parallelizable process), since  At this stage of creating the system, the task of parallelizing the calculations themselves is not worth it.  In the future, the word "consistent" will be omitted; </li><li>  calculations are typical, i.e.  the same algorithm is used for calculations, the execution time of which for a given computing system mainly depends on the dimension of the source data (the dimension is denoted by the number N), and not on their actual values; </li><li>  calculations are assumed to be predominantly ‚Äúheavy‚Äù, which requires substantial time to complete (from seconds to hours and, possibly, more); </li><li>  It is assumed that the nature of the change in the intensity of applications for calculations and the corresponding values ‚Äã‚Äãof the dimensions N are unknown. </li></ul><br><a name="habracut"></a><br>  The author‚Äôs initial attempts to predict the computation time had poor accuracy.  For the "by eye" algorithm, the dependence of time on N was selected using power coefficients so as to minimize the average deviation.  As a result of such test calculations, not very pleasant results were obtained: <br><table><tbody><tr><td>  <b>N</b> </td><td>  <b>Real time (s)</b> </td><td>  <b>Estimated time (sec)</b> </td></tr><tr><td>  417 </td><td>  9.60 </td><td>  5.04 ¬± 0.96 </td></tr><tr><td>  689 </td><td>  26.20 </td><td>  18.33 ¬± 3.50 </td></tr><tr><td>  1165 </td><td>  78.40 </td><td>  70.56 ¬± 13.48 </td></tr><tr><td>  2049 </td><td>  264.60 </td><td>  300.34 ¬± 57.40 </td></tr><tr><td>  3001 </td><td>  654.20 </td><td>  799.24 ¬± 152.74 </td></tr><tr><td>  3341 </td><td>  875.80 </td><td>  1,052.50 ¬± 201.13 </td></tr><tr><td>  4769 </td><td>  2323.60 </td><td>  2,621.69 ¬± 501.01 </td></tr><tr><td>  5449 </td><td>  3424,10 </td><td>  3,690.10 ¬± 705.18 </td></tr><tr><td>  6129 </td><td>  4811.80 </td><td>  4,988.97 ¬± 953.40 </td></tr></tbody></table><br>  To help, as often happens, came the classics.  The words ‚Äúinterpolation‚Äù and ‚Äúextrapolation‚Äù, long forgotten, were recalled, and searches on the Internet began in suspicion of the correctness of the chosen direction.  A number of posts, articles and other resources were re-read.  The main conclusion is as follows: to solve the problem of predicting the values ‚Äã‚Äãof a certain unknown function of one variable, the Chebyshev or Lagrange polynomials are most often used.  It turned out that it makes sense to use the Chebyshev polynomials (in principle, they could be replaced by the OLS) in cases where there is no confidence in the existing ‚Äúargument-value‚Äù set, and Lagrange polynomials are good in the opposite case.  The second looked like what was needed.  Indeed, why not create ‚Äúideal‚Äù conditions for testing the computation algorithm on a specific system (select the core with a load of 100%) and not collect enough statistics to construct the Lagrange polynomial? <br><div class="spoiler">  <b class="spoiler_title">Graphic example of the construction of the Lagrange polynomial</b> <div class="spoiler_text"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/571/0cb/b62/5710cbb6243ab121599340bc4d0a0b1b.png" alt="Lagrange polynomial.svg"></a> <br>  <a href="https://commons.wikimedia.org/wiki/User:Acdx" title="User: Acdx">User</a> <a href="">Lagrange polynomial</a> <a href="https://commons.wikimedia.org/wiki/User:Acdx" title="User: Acdx">User: Acdx</a> - Self-made, based on <a href="" title="File: Lagrangepolys.png">Image: Lagrangepolys.png</a> .  Under the license <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a> from <a href="https://commons.wikimedia.org/wiki/">Wikimedia Commons</a> . </div></div><br>  Meanwhile, there are already implemented algorithms for constructing the Lagrange polynomial, for example, <a href="http://blog.egrachev.com/2014/03/sympy.html">here</a> .  The algorithm adapted for the task began to show similar (modulo deviations) results when extrapolating on an increasing set of statistics (for the forecast with N = 1165 real time was used with N = 417 and N = 689, for the forecast with N = 2049: N = 417, N = 689 and N = 1165, etc.): <br><table><tbody><tr><td>  <b>N</b> </td><td>  <b>Real time (s)</b> </td><td>  <b>Estimated time (sec)</b> </td></tr><tr><td>  417 </td><td>  9.60 </td><td>  - </td></tr><tr><td>  689 </td><td>  26.20 </td><td>  - </td></tr><tr><td>  1165 </td><td>  78.40 </td><td>  55.25 </td></tr><tr><td>  2049 </td><td>  264.60 </td><td>  253.51 </td></tr><tr><td>  3001 </td><td>  654.20 </td><td>  617.72 </td></tr><tr><td>  3341 </td><td>  875.80 </td><td>  863.74 </td></tr><tr><td>  4769 </td><td>  2323.60 </td><td>  2899.77 </td></tr><tr><td>  5449 </td><td>  3424,10 </td><td>  2700.96 </td></tr><tr><td>  6129 </td><td>  4811.80 </td><td>  5862.79 </td></tr></tbody></table><br>  When interpolating with the Lagrange polynomial, the results turned out to be impressive starting with N = 2049 (one sample was successively excluded from the sample and the calculation of the excluded measurement was made): <br><table><tbody><tr><td>  <b>N</b> </td><td>  <b>Real time (s)</b> </td><td>  <b>Estimated time (sec)</b> </td></tr><tr><td>  417 </td><td>  9.60 </td><td>  - </td></tr><tr><td>  689 </td><td>  26.20 </td><td>  <font color="red">2.58</font> </td></tr><tr><td>  1165 </td><td>  78.40 </td><td>  <font color="red">98.35</font> </td></tr><tr><td>  2049 </td><td>  264.60 </td><td>  245.74 </td></tr><tr><td>  3001 </td><td>  654.20 </td><td>  664.15 </td></tr><tr><td>  3341 </td><td>  875.80 </td><td>  862.91 </td></tr><tr><td>  4769 </td><td>  2323.60 </td><td>  2407.75 </td></tr><tr><td>  5449 </td><td>  3424,10 </td><td>  3251.71 </td></tr><tr><td>  6129 </td><td>  4811.80 </td><td>  - </td></tr></tbody></table><br>  Indeed, at N = 689 and N = 1165, the deviation of the predicted value from the real value was, respectively, about <font color="red">90% and 25%</font> , which is unacceptable, however, starting from N = 2049 and further the deviation was in the range of <font color="green"><b>1.5-7%</b></font> , which can treat as a good result. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Polynomial:</b> F (x) = -5.35771746746065e-22 * x ^ 7 + 1.23182612519573e-17 * x ^ 6 - 1.14069960055193e-13 * x ^ 5 + 5.44407657742344e-10 * x ^ 4 - 1.39944148088413e-6 * x ^ 3 + 0.00196094886960409 * x ^ 2 - 1.22001773413031 * x + 263.749105425487 <br>  The degree of the polynomial, if necessary, can be reduced to the desired one by easily changing the algorithm (in principle, for the author‚Äôs task it was possible to manage with the 3rd degree) <br><div class="spoiler">  <b class="spoiler_title">Graphs of this polynomial</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a6a/5ca/5b5/a6a5ca5b50094d0b831021c7c77c915f.png"><br>  It is important to note that the polynomial is interpolation, and therefore, for values ‚Äã‚Äãoutside the [N <sub>min</sub> ; N <sub>max</sub> ] range, the quality of the forecast leaves much to be desired: <br><img src="https://habrastorage.org/files/6ec/10d/2fd/6ec10d2fd2284b64b006fb340e56ab97.png"><br></div></div><br><br>  <b>Conclusion:</b> <i>it makes sense to collect enough statistics in advance in ‚Äúideal‚Äù conditions (especially for large N values), to build the Lagrange polynomial and, upon receipt of applications, to obtain the forecast of the time of their calculations by substituting N <sub>i</sub> into the finished polynomial.</i> <br><br>  This approach is extremely understandable, however, when we speak about a pro-processor (multi-core) system, the situation becomes more complicated: <br><br><ul><li>  Firstly, the above approach is suitable for cases where the number of applications (tasks) X &lt;= Y, where Y is the number of cores.  In other words, the system does nothing except calculations, and each task is provided with a 100% resource of the corresponding core. </li><li>  Secondly, when X&gt; Y, the OS should divide the computational resource between tasks (for example, when manually launching tasks in Ubuntu server 14.04 through the screen, the computational resource is divided between tasks evenly according to the X / Y formula * 100%). </li><li>  Thirdly, the nature of the receipt of applications and the corresponding N values ‚Äã‚Äãis not known in advance, which makes it impossible to predict the time for any distribution formula of the computing resource (for example, for the same X / Y * 100%). </li></ul><br>  Analysis of these aspects showed that it is impossible to predict the execution time of the application in advance, but this value can be adjusted upon the occurrence of certain events affecting the current computing resource allocated for the calculations, followed by the issuance to the user.  These events are: the <font color="green"><b>arrival of a new task</b></font> and the <font color="red"><b>completion of the task being performed</b></font> .  It is upon the occurrence of these events that it is proposed to carry out a forecast correction. <br><br><img src="https://habrastorage.org/files/e91/315/2be/e913152bed3a44eca141b894403db36c.png" alt="image"><br><br>  It becomes clear that if any of these events occur, it is necessary to recalculate the allocated resource for each task (in cases with a known distribution of resources between tasks) or obtain this value in any way using the built-in (language or operating) tools, then recalculate the remaining time taking into account the allocated resource.  But for this we need to know how much work has already been done by the process.  Therefore, it is proposed to organize some storage (possibly a table in a DBMS), which will contain the necessary information, for example: <br><table><tbody><tr><td>  <b>Task id</b> </td><td>  <b>Start</b> </td><td>  <b>the end</b> </td><td>  <b>Lagrange (N)</b> </td><td>  <b>Done</b> </td><td>  <b>Last request</b> </td><td>  <b>Last correction</b> </td><td>  <b>Current CPU</b> </td></tr><tr><td>  2457 </td><td>  12:46:11 </td><td>  ... </td><td>  Lagrange (N) </td><td>  0.45324 </td><td>  ... </td><td>  12:46:45 </td><td>  1.00 </td></tr><tr><td>  6574 </td><td>  12:46:40 </td><td>  ... </td><td>  Lagrange (N) </td><td>  0.08399 </td><td>  ... </td><td>  12:46:45 </td><td>  1.00 </td></tr><tr><td>  2623 </td><td>  12:44:23 </td><td>  12:46:45 </td><td>  Lagrange (N) </td><td>  1.00 </td><td>  ... </td><td>  12:46:45 </td><td>  0 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr></tbody></table><br>  It is supposed to implement the following algorithm (metacode): <br><br><ul><li>  <b>When a user has received a request about the status of the task:</b> <ul><li>  &lt;Done&gt; + = (&lt;Request Time&gt; - MAX (&lt;Last Request&gt;, &lt;Last Correction&gt;)) * &lt;Current CPU&gt; / &lt;Lagrange (N)&gt;; </li><li>  &lt;Last request&gt; = &lt;Request moment&gt;; </li><li>  Return to user &lt;Done&gt; and &lt;Current CPU&gt;. </li></ul></li><li>  <b>When a new task arrives:</b> <ul><li>  Create a new &lt;task ID&gt;; </li><li>  Record the start time at &lt;Start&gt;; </li><li>  Calculate and record the runtime forecast in ‚Äúideal‚Äù conditions in &lt;Lagrange (N)&gt;; </li><li>  &lt;Done&gt; = 0; </li><li>  &lt;Last Request&gt; = 00:00:00; </li><li>  Call the correction procedure. </li></ul></li><li>  <b>When the task</b> is completed, you can delete the record altogether, but in any case, call the correction procedure. </li><li>  <b>Correction procedure:</b> <ul><li>  For all records: &lt;Last correction&gt; = &lt;Current time&gt; (it makes sense to keep this value somewhere separate); </li><li>  Receive and record for each task the corresponding &lt;Current CPU&gt;. </li></ul></li></ul><br>  <b>Conclusion:</b> <i>having an advance forecast for ‚Äúideal‚Äù conditions, we can practically ‚Äúon the fly‚Äù correct the predicted percentage of ‚Äúheavy‚Äù consecutive calculations when the load on the system changes and give the user these values ‚Äã‚Äãupon request.</i> <br><br>  Specific implementations may have their own characteristics that complicate or simplify life, but the purpose of the article is not to analyze delicate cases, but only to offer the above approach to a fair trial of the reader (primarily on the subject of viability). </div><p>Source: <a href="https://habr.com/ru/post/258791/">https://habr.com/ru/post/258791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258775/index.html">How to make a video with a UFO</a></li>
<li><a href="../258777/index.html">The digest of interesting materials from the world of Drupal # 9</a></li>
<li><a href="../258779/index.html">Reach: GPS accurate to centimeter</a></li>
<li><a href="../258785/index.html">Java: 20 years of innovation</a></li>
<li><a href="../258789/index.html">Search associative rules in the survey results</a></li>
<li><a href="../258793/index.html">Problems of weak gaming ecosystems</a></li>
<li><a href="../258797/index.html">Geek approach to a simple browser game</a></li>
<li><a href="../258799/index.html">Reboot the brain to Tabtabus 2015 Summer Fest</a></li>
<li><a href="../258801/index.html">Dismantling the tutorial cult, trends in mobile development outsourcing and adult VR content - and other news of the week for a mobile developer</a></li>
<li><a href="../258803/index.html">Through hardship to the stars. How we stuffed bumps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>