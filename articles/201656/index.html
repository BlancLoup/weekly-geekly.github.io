<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Shortest Common Superstring Problem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The problem of the shortest common superline is formulated as follows: to find the shortest line such that each line from the given set would be its s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Shortest Common Superstring Problem</h1><div class="post__text post__text-html js-mediator-article">  <b>The problem of the shortest common superline is</b> formulated as follows: to find the shortest line such that each line from the given set would be its substring.  This problem occurs both in bioinformatics (the task of assembling the genome in general) and in compressing data (instead of data, store their superline and a sequence of pairs, species (index of occurrence, length)). <br><br>  When I searched the network for information on this issue and its solution in Russian, there were only a couple of posts about bioinformatics, where these words are mentioned in passing.  The code (except for the greedy algorithm), of course, was not there either.  Having understood the problem, this fact was inspired by the article here. <br><br>  Be careful, 4 megabytes! <br><a name="habracut"></a><br>  For the most part, the article is an attempt to translate into understandable language, illustrate, spice up with an example, and, of course, implement a 4-approximate algorithm for constructing superstructures from Dan Gasfield's book (see the used literature).  But first, a small introduction and a 2-approximate, greedy algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>In the simplest case</b> (if the name of the problem did not include the word ‚Äúshortest‚Äù), the solution of the problem would be a simple concatenation of the input strings in an arbitrary order.  But in this formulation of the problem, we are dealing with NP-completeness, which means that at present there is no algorithm by which one could solve this problem on a Turing machine in a time that does not exceed the polynomial of the data size. <br><br>  <b>Input:</b> S <sub>1</sub> , S <sub>2</sub> , ..., S <sub>n</sub> - the set of lines of a finite alphabet E *. <br>  <b>Output:</b> X is the string of the alphabet E * containing each string S <sub>1..n</sub> as a substring, where the length | X |  minimized. <br><br>  <b>Example.</b>  Take the set of lines S = {abc, cde, eab}.  In the case of concatenation, the length of the output superline will be 9 (X = abccdeeab), which is obviously not the best option, since the lines can have a suffix-prefix match.  We will call the length of this coincidence <b>overlap</b> .  (The choice of an English word is not accidental, since it does not have a specific and unambiguous translation into Russian. In the Russian-language literature, the terms overlay, intersection, overlap, and suffix-prefix coincidence are commonly used). <br><br>  <b>Retreat.</b>  The concept of overlap is one of the most important in the implementation process of the construction of superstructures.  Calculating overlap for an ordered pair of strings (S <sub>i</sub> , S <sub>j</sub> ) is reduced to finding the length of the maximum match of the suffix string S <sub>i</sub> with the prefix string S <sub>j</sub> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/d8d/6c4/d78d8d6c40cb88e61b7898cbe0372f4b.jpg" alt="image"></div><br><br>  One way to program the overlap location is presented in the following listing. <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* *       s1 *     s2 (  s1  s2) */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">overlap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s1, String s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s1last = s1.length() - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s2len = s2.length(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> overlap = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = s1last, j = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; s2len; i--, j++) { String suff = s1.substring(i); String pref = s2.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, j); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (suff.equals(pref)) overlap = j; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> overlap; }</code> </pre> <br><br>  <b>Return for example.</b>  If we concatenate the strings S = {abc, cde, eab} with their overlaps, we get the string X = abcdeab with a length of 7, which is shorter than the previous one, but not the shortest.  The shortest line is obtained when concatenating strings with overlaps in the order of 3-1-2, then the resulting string X = eabcde will have length 6. Thus, we reduced the problem to finding the optimal order of concatenated strings taking into account their overlaps. <br><br>  <b>Limitation</b>  All existing algorithms for finding the shortest superstructures assume that no string in the input set is a substring of any other string.  Deletion of such lines can be made, for example, with the help of a suffix tree and, obviously, does not detract from the generality. <br><br><h2>  Greedy algorithm </h2><br>  In this algorithm, at each iteration we try to find the maximum overlap of any two lines and merge them into one.  We hope that the result of this algorithm will be close to the actual optimal one. <br><br>  1. While S contains more than one line, we find two lines with the maximum overlap and merge them into one (for example, ABCD + CDEFG = ABCDEFG). <br>  2. We return one line remaining in S. <br><br>  An example of the implementation of this algorithm is presented in the following listing. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/* *         , *      ( ). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSuperString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;String&gt; strings)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (strings.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxoverlap = <span class="hljs-number"><span class="hljs-number">0</span></span>; String msi = strings.get(<span class="hljs-number"><span class="hljs-number">0</span></span>), msj = strings.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String si : strings) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String sj : strings) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (si.equals(sj)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curoverlap = overlap(si, sj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curoverlap &gt; maxoverlap) { maxoverlap = curoverlap; msi = si; msj = sj; } } strings.add(merge(msi, msj, maxoverlap)); strings.remove(msi); strings.remove(msj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><br>  In this listing, another simple function, merge, appeared, which merges two lines into one, taking into account their overlap.  Since the latter has already been computed, it is logical to simply pass it as a parameter. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/* *    s1  s2   len,   *   overlap(s1, s2) */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s1, String s2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ s2 = s2.substring(len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1 + s2; }</code> </pre><br><br>  One example ( <b>worst case</b> ): <br>  ‚óè <b>Input</b> : S = {"ab <sup>k</sup> ", "b <sup>k</sup> c", "b <sup>k + 1</sup> "} <br>  ‚óè <b>The output of the</b> greedy algorithm: "ab <sup>k</sup> cb <sup>k + 1</sup> " with a length of 4 + 4k <br>  ‚óè <b>Conclusion of the</b> optimal algorithm: ‚Äúab <sup>k + 1</sup> c‚Äù with a length of 4 + 2k <br><br>  Worst case <b>ratio</b> <img src="http://habrastorage.org/storage3/827/313/b45/827313b45285b2a0456aad5a128734c4.gif" alt="image"><br><br><h2>  Blum-Yang-Lee-Tromp-Yannakakis 4-approximation algorithm </h2><br>  Generally speaking, this algorithm does not have a name and no one calls it as I do.  It is called simply a 4-approximate algorithm for constructing the shortest superstructure.  But since Blum, Young, Lee, Tromp and Yannakakis invented it, why not give this title? <br><br>  <b>For clarity</b> , during the analysis of the algorithm, I will give an example of constructing an overlay for the set <b>S = {S <sub>0</sub> : ‚Äúcde‚Äù, S <sub>1</sub> : ‚Äúabc‚Äù, S <sub>2</sub> : ‚Äúeab‚Äù, S <sub>3</sub> : ‚Äúfgh‚Äù, S <sub>4</sub> : ‚Äú ghf ‚Äù, S <sub>5</sub> :‚Äú hed ‚Äù}</b> . <br><br>  <b>The main idea of ‚Äã‚Äãthe</b> algorithm is to find a covering with cycles of minimum full length for a complete directed weighted graph, the vertices of which are rows of a given set, and the weight of the edge from S <sub>i</sub> to S <sub>j</sub> is equal to overlap (S <sub>i</sub> , S <sub>j</sub> ) for all i, j. <br><br>  The graph for our example (the vertices for visibility are signed i instead of S <sub>i</sub> ): <br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/01f/3d4/800/01f3d4800a37c23fd858d34b526b727a.jpg" alt="image"></div><br><br>  In my implementation, I will present this graph as an <b>adjacency matrix</b> , which will be formed in a banal way, shown in the following listing (in section 16.17 [1] D. Gasfield argues that the matrix can be formed more efficiently, but the method of forming this matrix does not affect consideration of this algorithm). <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = strings.size(); <span class="hljs-comment"><span class="hljs-comment">//   overlap'   //   (Si, Sj). int[][] overlaps = new int[n][n]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) overlaps[i][j] = overlap(strings.get(i), strings.get(j));</span></span></code> </pre><br><br>  For our example, the adjacency matrix will look like this: <br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/a92/516/879/a9251687992964bba3243edbc9c700ac.jpg" alt="image"></div><br><br>  After the adjacency matrix is ‚Äã‚Äãconstructed, there is a need to find coverage with cycles of minimum full length.  Such coverage can be found by reducing this task to the ‚Äúassignment problem‚Äù.  So, the task was to find the full purpose of the maximum weight (as it turned out, this step of the algorithm takes dominant time).  Faster and easier ([1] p.16.19.13) this appointment can be found by the greedy method. <br><br>  <b>Greedy appointment</b> ([1] p.16.19.13) <br><br>  Baseline: k √ó k matrix A. <br>  Result: full appointment M. <br><br><ol><li>  Put M = √ò and declare all cells A available. </li><li>  while in A there are available cells do begin <br><ol><li>  Among the available cells A, choose the cell (i, j) of the greatest weight. </li><li>  Place the cell (i, j) in M ‚Äã‚Äãand make the cells in row i and column j inaccessible. </li><li>  end; </li></ol></li><li>  Issue full M. appointment. </li></ol><br><br>  M can be represented in the code as an array (int [] M = new int [k]) and the first part of instruction 2.2 can be treated as M [i] = j;  since in the full assignment each number from 0 to k occurs exactly once as the index of the row and exactly once as the index of the column. <br><br>  An example of the implementation of the full assignment calculation is presented in the following listing. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/* * ,     *   .  - O(k*k*log(k)) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] assignment(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = a.length; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[][] notallow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>[n][n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max = -<span class="hljs-number"><span class="hljs-number">1</span></span>, maxi = -<span class="hljs-number"><span class="hljs-number">1</span></span>, maxj = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; n; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notallow[i][j]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i][j] &gt; max) { max = a[i][j]; maxi = i; maxj = j; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max == -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; m[maxi] = maxj; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { notallow[maxi][i] = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; notallow[i][maxj] = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m; }</code> </pre><br><br>  Step-by-step calculation of the full assignment of the maximum weight by the greedy method for our example: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/f9a/9c9/b01/f9a9c9b01ab27ca78033b0311bc5c98d.gif" alt="image"></div><br><br>  Now that the full assignment of the maximum weight is calculated, it is necessary to calculate the <b>coverage with cycles of the</b> minimum full length.  For this you need: <br><br>  taking the beginning of any (logical - zero) index of the full assignment, put it in a cycle, mark it used and see if its value equals the index of the beginning of the cycle?  If yes, finish the cycle, put it in the cycle covering and start a new cycle, taking the first unlabeled element as the start.  If not, take this value as an index and repeat the procedure until all items are marked. <br><br>  The view of the cycle coverage in memory can be organized as <b>a list of indexes of rows.</b> <br><br>  Algorithm listing (assign - full assignment): <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//       //    assign ArrayList&lt;ArrayList&lt;Integer&gt;&gt; cycles = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; cycle = new ArrayList&lt;Integer&gt;(); boolean[] mark = new boolean[assign.length]; for (int i = 0; i &lt; assign.length; i++) { if (mark[i]) continue; cycle.add(i); mark[i] = true; if (assign[i] == cycle.get(0)) { cycles.add(cycle); cycle = new ArrayList&lt;Integer&gt;(); i = 0; } else { i = assign[i] - 1; } }</span></span></code> </pre><br><br>  For our example, finding the coverage in cycles will look like this: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/437/7f1/12a/4377f112a405a3eda016dc6a13adf965.gif" alt="image"></div><br><br>  The resulting covering by cycles can be displayed on the initial graph, leaving only those edges that fall into the covering on it. <br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/28f/dea/aae/28fdeaaae06443779239b0c71b7cffa9.jpg" alt="image"></div><br><br>  <b>Assembly.</b>  Now that all the cycles in the coverage have been calculated, you can proceed to the assembly, directly, of the superline. <br><br>  For this, we need the function prefix, which accepts the strings S <sub>1</sub> and S <sub>2</sub> and returns the string S <sub>1</sub> , truncated to the right of the overlap (S <sub>1</sub> , S <sub>2</sub> ) characters.  But since all the overlaps have been calculated by us for a long time, the function can be written so that it accepts only one line and the number of characters it needs to be shortened by. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/* *    s1,   *  ov  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ov)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, s1.length() - ov); }</code> </pre><br><br>  Now, for each cycle C <sub>i</sub> = {S <sub>1</sub> , S <sub>2</sub> , ..., S <sub>k-1</sub> , S <sub>k</sub> }, it is necessary to make up the superscript X <sub>Ci</sub> = prefix (S <sub>1</sub> , overlap (S <sub>1</sub> , S <sub>2</sub> )) ++ prefix (S <sub>2</sub> , overlap (S <sub>2</sub> , S ...)) ++ prefix (S ..., overlap (S ..., S <sub>k-1</sub> )) ++ S <sub>k</sub> . <br><br>  The problem is that, since the cycles in the coverage are <b>cycles</b> , it means that we can cycle them and it is not clear from which line to start designing the X <sub>Ci superline</sub> .  The answer is simple - you need to move the loop so as to <b>minimize the</b> overlap of the last and first line <br><br>  Consider the first cycle of cyclic coverage from the example. <br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/170/a0b/6ef/170a0b6ef18b75dac1e453f4713a3232.jpg" alt="image"></div><br><br>  If you do not minimize the overlap of the last and first lines, but take C <sub>0</sub> = {1, 0, 2}, then the superscript is X <sub>C0</sub> = abc ++ cde ++ eab = abcdeab, obviously, not the shortest possible one.  The minimum overlap in this loop is 1, which means that any of the sequences {0, 2, 1} (cde ++ eab ++ abc = cdeabc) or {2, 1, 0} (eab ++ abc ++ cde = eabcde). <br>  The following is the code that cyclically shifts each cycle in the coverage so as to minimize the overlaps of the first and last lines of each cycle, and constructs superscripts for each cycle. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//       ,  //  overlap       //      . ArrayList&lt;String&gt; superstrings = new ArrayList&lt;String&gt;(); for (ArrayList&lt;Integer&gt; c : cycles) { String str = ""; ArrayList&lt;Integer&gt; ovs = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; c.size() - 1; i++) ovs.add(overlaps[c.get(i)][c.get(i+1)]); int min = overlaps[c.get(c.size()-1)][c.get(0)]; int shift = 0; for (int i = 0; i &lt; ovs.size(); i++) if (ovs.get(i) &lt; min) { min = ovs.get(i); shift = i + 1; } Collections.rotate(c, -shift); for (int i = 0; i &lt; c.size() - 1; i++) str += prefix(strings.get(c.get(i)), overlaps[c.get(i)][c.get(i+1)]); str += strings.get(c.get(c.size()-1)); superstrings.add(str); }</span></span></code> </pre><br><br>  Now we have the shortest sutures for each cycle in the coverage.  The considered algorithm with factor 4 assumes a simple concatenation of these lines. <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//     superstrings StringBuilder superstring = new StringBuilder(); for (String str : superstrings) superstring.append(str); return superstring.toString();</span></span></code> </pre><br><br><h2>  Source codes and testing </h2><br>  The source code for the greedy (Greedy.java) and Blum-Yang-Lee-Tromp-Yannakakis (Assign.java) algorithms are available in the git repository at <a href="https://bitbucket.org/andkorsh/scss/src">bitbucket.org/andkorsh/scss/src</a> .  Also, there is the executable class Main.java, which when launched asks for the number of launches for measuring the speed of the algorithms and the path to the input file.  Also, the Main class is able to generate input data itself, for this, instead of the file name, you must enter ‚Äúrandom‚Äù, after which the number of lines, the maximum line length, the fixed length or not, and the number of characters in the alphabet will be requested.  The report will be written to the file output.txt. <br><br>  Source codes are guaranteed to be compiled by javac, starting with version ‚Äú1.6.0_05‚Äù. <br><br>  Testing is performed using the test function of the Main class. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;String&gt; substrings, String superstring)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String substring : substrings) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (superstring.indexOf(substring) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) errors++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors; }</code> </pre><br><br><h2>  References </h2><br>  <b>[1]</b> : Dan Gasfield.  Strings, trees and sequences in algorithms.  Computer science and computational biology.  Nevsky Dialect, BHW-Petersburg, 2003.  - 656 pp .: ISBN 5-7940-0103-8, 5-94157-321-9, 0-521-58519-8. <br>  <a href="http://www.ozon.ru/context/detail/id/1393109/">www.ozon.ru/context/detail/id/1393109</a> <br><br>  <b>[2]</b> : Dan Gusfield.  Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology.  THE PRESS SYNDICATE OF THE UNIVERSITY OF CAMBRIDGE, 1997  - 534 pp .: ISBN-10: 0521585198, ISBN-13: 978-0521585194. <br>  <a href="http://www.amazon.com/Algorithms-Strings-Trees-Sequences-Computational/dp/0521585198">www.amazon.com/Algorithms-Strings-Trees-Sequences-Computational/dp/0521585198</a> <br><br>  <b>[3]</b> : Shunji Li, Wenzheng Chi.  Lecture # 3: Shortest Common Superstring - CS 352 (Advanced Algorithms), Spring 2011. <br>  <a href="http://cs.carleton.edu/faculty/dlibenno/old/cs352-spring11/L03-shortest-superstring.pdf">cs.carleton.edu/faculty/dlibenno/old/cs352-spring11/L03-shortest-superstring.pdf</a> </div><p>Source: <a href="https://habr.com/ru/post/201656/">https://habr.com/ru/post/201656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201646/index.html">Mooha - node interface for PHP</a></li>
<li><a href="../201648/index.html">Easy way to add geolocation to your Android project</a></li>
<li><a href="../201650/index.html">Geopolitical simulator - the history of creation and development</a></li>
<li><a href="../201652/index.html">How to quickly and accurately assess the project without TK</a></li>
<li><a href="../201654/index.html">What does it mean to be a junior developer</a></li>
<li><a href="../201658/index.html">PubSub in a browser using webboxes and the WAMP protocol</a></li>
<li><a href="../201660/index.html">Java and iCalendar work</a></li>
<li><a href="../201662/index.html">Oracle Certification Manual</a></li>
<li><a href="../201666/index.html">AMD hell or how I was tormented with a graphics card from AMD on Linux</a></li>
<li><a href="../201668/index.html">Use external Windows Azure Mobile Services authentication in a WPF desktop application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>