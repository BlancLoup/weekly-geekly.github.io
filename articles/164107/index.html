<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>3D live wallpaper and OpenGL ES</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, Habr! 

 I am a member of a small company (of two people) that makes live wallpapers (live wallpapers) for Android devices. This article wil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>3D live wallpaper and OpenGL ES</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/10b/828/c41/10b828c414114e67fad98d026fae72a1.png"><br><br>  Good day, Habr! <br><br>  I am a member of a small company (of two people) that makes live wallpapers (live wallpapers) for Android devices.  This article will cover the development of our applications, from relatively simple to more complex, applied technologies, tricks and problems solved - all with specific examples, in (almost) chronological order.  All our wallpapers are fully 3D, written using OpenGL ES. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a bonus - a small collection of shaders, use them as you wish.  Suggestions for their improvement or correction will only be welcome - we do not claim to be a guru in this area. <br><a name="habracut"></a><br><h1>  ‚ÄúWatch‚Äù and ‚ÄúHTC‚Äù - the first joy </h1><br><img src="https://habrastorage.org/storage2/c46/d45/e2a/c46d45e2a0a7394901b9976f05becea7.png"><br><br>  Used <a href="http://www.jpct.net/jpct-ae/">JPCT-AE</a> engine, still old, which uses OpenGL ES 1.0.  Loading models came from the format of 3DS.  There were no shaders, compressed textures, render-to-texture, and other fashionable stuff.  However, here it was possible to do without all of this. <br><br><h1>  ‚ÄúChristmas tree‚Äù - disadvantages of OpenGL ES 1.0 </h1><br><img src="https://habrastorage.org/storage2/e92/913/c72/e92913c72ca59c229945a962c36279c5.png"><br><br>  It turned out 2 things: the emulator disgusting draws three-dimensional graphics and JPCT-AE devours a lot of memory on textures. <br><br>  The then emulator did not just poorly draw the three-dimensional graphics of OpenGL ES 1.0, but drew it too clearly and slowly.  From now on, development has gone only on a real device. <br><br>  The JPCT-AE version used at the time allocated memory for each texture, and the program could suddenly close due to lack of memory.  Hopefully this bug has already been fixed in new versions of the engine.  It is known that Android applications do not accept OpenGL resources in the calculation of the allocated Dalvik memory, but here the engine had problems with the non-release of memory after loading the texture into the video memory.  It was necessary to reduce the size of the textures not because the video card could not cope with the drawing, but because they were all stuck in the memory and the program was falling. <br><br>  Also, when using the then version of JPCT-AE, there was a nasty bug when recreating the OpenGL context - the textures could get lost or be misled.  Solutions to this problem have not been found.  Again, we hope that this bug has been fixed in the current version of JPCT-AE. <br><br>  In fairness, we add that the latest versions of JPCT-AE have added support for OpenGL ES 2.0 and their own shaders, so that novice developers can try to use it. <br><br><h1>  ‚ÄúRose‚Äù - OpenGL ES 2.0 and alpha testing </h1><br><img src="https://habrastorage.org/storage2/75a/4a5/a39/75a4a5a3962618aac0b65f97b53eb660.png"><br><br>  Here we switched to using pure OpenGL ES 2.0, without using any frameworks and engines. <br><br>  The reason for switching to OpenGL ES 2.0 was that, to display roses in OpenGL ES 1.0, you had to use alpha-blending, with sorting polygons, of course.  That all the same would lead to poor performance due to excessive redrawing (depth-testing because it turns off). <br><br>  Naturally, these problems are easily solved using alpha testing, and OpenGL ES 2.0 allowed us to implement it elementary.  However, there are some difficulties with this.  Alpha testing itself is implemented elementarily: <br><br><pre><code class="hljs cs">vec4 <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> = texture2D(sTexture, vTextureCoord); gl_FragColor = <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.a &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { discard; }</code> </pre> <br><br>  However, this obvious implementation has some drawbacks related to loading a texture from a PNG file. <br>  First, the edges of the petals get a thin black face, which is especially noticeable on the light petals: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/46c/365/215/46c3652155e94557e763afec97388565.png" alt="image"></div><br><br>  This happens if you use the standard texture loading method, which multiplies the color by the alpha channel.  Artifacts can be avoided by implementing your own texture loading. <br><br>  Secondly, the texture is uncompressed, takes a lot of video memory, and therefore is drawn more slowly.  Believe me, compressed textures do immediately give a performance boost.  The problem here is that the only standardized texture compression algorithm for OpenGL ES 2.0 is ETC1.  And he does not support the alpha channel.  So you have to make two textures - for color (diffuse), and opacity.  Two compressed textures still occupy less memory than one uncompressed one of the same size (and, accordingly, work faster).  You can also decide that for specific cases, the transparency texture can be made smaller than the color texture, or vice versa. <br>  But all these problems were solved later when the following live wallpapers were developed - Turbines. <br><br><h1>  ‚ÄúTurbines‚Äù - shaders, shaders, shaders ... </h1><br><img src="http://habrastorage.org/storage2/553/e27/126/553e27126e8e82d5c5d2e1bed52f81b8.png"><br><br>  Here we began to really use the capabilities of OpenGL ES 2.0 shaders.  Of the new shaders, here is the fog (still pixelated) and the landscape shader, over which the shadows from the clouds run. <br><br>  The fog chose linear, although they immediately tried a more realistic exponential.  The exponential fog on mobile devices slowed down so that we immediately abandoned it. <br><br>  The landscape shader uses two textures - a repeating grass texture with a size of 512 * 512 and a second texture, which combines a static landscape lightmap and a cloud shadow texture (just 64 * 128).  Here you can perform various operations on colors - lightmap is multiplied, shadows and fog are combined using mix (). <br>  Then it turned out that these shaders were damn non-optimized, since everything was written in the code of the pixel shader. <br><br><h1>  ‚ÄúPumpkin‚Äù - new shaders, loading acceleration </h1><br><img src="http://habrastorage.org/storage2/e53/98a/820/e5398a820f19e4fc9b481480ddcd5a3b.png"><br><br>  Here we implemented fast loading of models in a ready binary format, and then VBO, and for the first time applied compression of textures ETC1 (compressed textures were already mentioned earlier using the example of a rose). <br><br>  It so happened that the new model loading, implemented in these live wallpapers, brought more benefits when the roses were applied on the wallpapers.  Initially, the models were loaded from the OBJ format, which was rather slow and caused complaints from Roza users.  After all, the model here is really rather big, a little more than 1000 triangles, and the OBJ file has been parsed for a long time.  A utility was written that created data files ready for transfer to glDrawArrays ().  The performance gain is difficult to describe - before the rose was loaded for 10 or more seconds, now the download can be described only as ‚Äúinstantly‚Äù. <br><br>  I want to note that mobile devices greatly surprised us in their ability to draw a large number of polygons - as it was just said, 1000 triangles in a rose were not a problem for any device, and in our other tests and wallpapers we already use much more.  But VBO was disappointing - absolutely no performance gain was noticed. <br><br>  The pumpkin shader is based on some example of RenderMonkey cloth, a bit simplified and refined. <br><br><h1>  ‚ÄúFading candle‚Äù - animation, simple sorting </h1><br><img src="http://habrastorage.org/storage2/7df/53e/b69/7df53eb69534d943d902e02136d0906e.png"><br><br>  For these wallpapers, we developed a simple vertex animation algorithm, with simple linear interpolation between frames.  Software animation, i.e.  on the CPU.  It is used for two purposes - animation of a candle (several frames of animation) and animation of shadows.  Yes, there is no shadow map here, shadows are separate models with a texture calculated in 3ds max.  Model shadows have 2 frames of animation - the normal state and slightly stretched in the direction from the light source.  Between these frames a smooth animation is made, synchronously with the scaling of the candle flame: <br><br><img src="http://habrastorage.org/storage2/970/bd1/080/970bd10803ee795a5af5090d0f5f1b4a.gif"><br><br>  Also, the development of vertex animation allowed us to add birds to the ‚ÄúTurbines‚Äù wallpaper. <br><br>  Well, as you can imagine, here we have been training with the blending and depth-testing switching.  There are 2 transparent objects that need to be sorted - this is a candle flame and a feather.  Instead of accurate sorting by distance to the camera, we check the current position of the camera.  The camera moves in a circle, on a separate sector of which you need to draw first the flame, then the pen, on the rest - on the contrary. <br><br><h1>  ‚ÄúLantern Festival‚Äù - vertex shaders, drawing order </h1><br><img src="http://habrastorage.org/storage2/657/8bc/448/6578bc4481f66a1fc51c3235cbac2e66.png"><br><br>  As you can see from the picture, here we will talk about the shader of water and fog.  What you might have missed is the fact that the sky shader also has something to tell. <br><br>  The water shader is taken from the PowerVR example, and simplified (they threw out the refraction, maybe somewhere the calculations have simplified).  The reflection is rendered in a small texture - only 256 * 256. <br><br>  For the landscape, a rather complicated fog shader is used: the density of the fog depends on the distance and height, and the color of the fog depends on the position of the moon (the fog around the moon is highlighted).  All this was possible to implement with sufficient performance only in the vertex shader.  After that, we rewrote the fog shader in Wind Turbines vertex, which gave a noticeable increase in performance. <br><br>  Now, about the sky shader.  The sky is drawn from 3 layers: the actual sky texture with the moon, a layer of stars (stored in the alpha channel of the color texture) and moving clouds.  Stars are not merged with the sky texture because they need great brightness.  Initially, the shader was written something like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> CLOUDS_COVERAGE = <span class="hljs-number"><span class="hljs-number">12.0</span></span>; vec4 <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> = texture2D(sTexture, vTextureCoord); vec4 clouds = texture2D(sClouds, vec2(vTextureCoord.x + fOffset, vTextureCoord.y)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stars = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.a) * starsCoeff; stars *= pow(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - clouds.r, CLOUDS_COVERAGE); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> + stars; gl_FragColor = <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> * clouds * <span class="hljs-number"><span class="hljs-number">5.0</span></span>;</code> </pre> <br><br>  It would seem that the code is a bit but still the performance was low, something needed to be optimized.  As you can see, to obscure the stars with clouds, the rather oily function pow () is used, and an additional enhancement of the brightness of the clouds (clouds * 5.0) is also performed.  The darkening of the stars with clouds was replaced with a linear clamp (), and we managed to get rid of the gain (clouds * 5.0) altogether, making the texture of the clouds brighter in Photoshop.  The final shader began to work a little faster: <br><br><pre> <code class="hljs cs">vec4 <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> = texture2D(sTexture, vTextureCoord); vec4 clouds = texture2D(sClouds, vec2(vTextureCoord.x + fOffset, vTextureCoord.y)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stars = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.a) * starsCoeff; stars *= clamp(<span class="hljs-number"><span class="hljs-number">0.75</span></span> - clouds.r, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> + stars; gl_FragColor = <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">base</span></span> * clouds;</code> </pre> <br><br>  However, this performance is still not enough.  Attempts to render a simplified sky into the texture of the reflection did not give anything - the texture is only 256 * 256, even if it does not draw the sky at all, nothing has changed.  The problem turned out to be quite different - that the sky was painted <i>first</i> , not last.  Those.  the resources of the video map were spent on drawing the whole hemisphere of the sky, and then still wiping it with landscape and other objects.  We carefully reviewed the rendering order in our program, built the objects in the optimal order and thus achieved the necessary performance.  So even when it seems to you that you have completed your OpenGL application and everything is working fine, finally reconsider your rendering order - by rearranging a couple of lines of code in places, you can improve performance quite well. <br><br><h1>  ‚ÄúTulip‚Äù - sorting objects </h1><br><img src="http://habrastorage.org/storage2/6b7/81e/3f6/6b781e3f6bd9f34002575458637e548f.png"><br><br>  We made these live wallpapers fairly quickly - there is little modeling here, no new shaders are needed, the only thing that had to be implemented is the sorting. <br><br>  Sort the need, of course, transparent "defocused" tulips.  Each of them is a separate object, we calculate the square of the distance from it to the camera and sort by this value (there is enough square distance, because the value is needed only for comparison). <br><br>  The performance of these wallpapers was not as big as that of Rosa, which was quite expected - many transparent polygons were added here, but they are not optimized in any way, everything that is drawn on the screen is drawn.  To achieve acceptable performance, I had to pick FOV and the number of ‚Äúblurry‚Äù colors on the screen - the smaller, the better. <br><br><h1>  ‚ÄúJelly Bean‚Äù - glare, blending </h1><br><img src="http://habrastorage.org/storage2/b39/22c/e47/b3922ce47c82c6938fef947ce7e63117.png"><br><br>  For glare on glass and ‚Äúbeans,‚Äù we used simplified calculations.  Usually the vector of the direction of light is involved in the glare calculations, and if we assume that it is equal to some simple constant like (0; 0; 1), then the calculations are much simpler - the dot () operation is thrown, etc.  The result is obtained as if the light source is in the same place as the camera, and for such a simple scene this is more than enough. <br><br>  The glass shader selects the color and alpha depending on the screen normal and flare.  It works together with the correctly selected blending, naturally. <br><br><h1>  ‚ÄúLotus‚Äù - dragonflies and interpolation </h1><br><img src="http://habrastorage.org/storage2/989/a77/645/989a776454b7e351d0a4ff77555f24a5.png"><br><br>  Let's start with shaders.  The water here is the same as in the ‚Äúlanterns‚Äù, only with modified parameters.  For the change of day and night, multiplication by ambient-color is added to all objects: <br><br><pre> <code class="hljs python"><span class="hljs-meta"><span class="hljs-meta">... </span></span>gl_FragColor *= ambientColor;</code> </pre> <br><br>  The animation of dragonfly wings is implemented unusually - the geometry of the wings is not animated.  Such a flapping of the wings is impossible to convey with the animation of geometry.  The wings here are akin to the blades of a helicopter - they move very quickly and, for the naked eye, merge into a single slowly iridescent, rotating plane.  So we made a model of wings from several intersecting planes, and the effect of fast swinging is created by a shader, performing a simple shift of the UV-coordinates. <br><br>  Static geometry of the wings: <br><br><img src="http://habrastorage.org/storage2/604/34e/fb1/60434efb1b7e9e469fe7be4aa1c02a7c.png"><br><br>  In these wallpapers you can observe a variety of objects moving along smooth paths - dragonflies, butterflies, fish under water and a camera.  All of them move along splines, and for smooth movement, bicubic interpolation is implemented based on the Catmull-Rom algorithm.  Note that interpolation is slightly different from that with which splines are smoothed in 3ds max with Smooth vertices.  A hundred percent accuracy for most of the objects we did not need here.  Also, the disadvantage of the applied algorithm is that for a uniform motion, the segments between the spline vertices must be of the same length - otherwise the motion on short segments will slow down, and on long segments - to accelerate.  And for the movement of the camera is already important. <br><br>  Note that you can use the ‚ÄúNormalize Spline‚Äù modifier in 3ds max to create a spline with uniform segments. <br><br>  But in our case, the lack of long segments was eliminated by the way in which we exported the animation from 3ds max to a text format (in order to extract values ‚Äã‚Äãfrom it into an array).  To export the animation, we used the ‚ÄúExport Animation‚Äù command, which generates an XML file (* .xaf) with animation.  It is possible to find in it not only all the vertices of the curve along which the object moves, but also its position <i>for each position</i> on the track bar.  Thus, you can animate your object as you please - with any controllers, keyframe animation, paths and even all of this at the same time, and at the output you can get its position coordinates in space depending on time. <br><br>  For the halo effect of fireflies, a vertex shader was made, which positions and scales the halo sprite: <br><br><img src="http://habrastorage.org/storage2/8ea/887/45f/8ea88745f401be48283f22c941eb081a.png"><br><br><h1>  Shader Collection </h1><br>  The shader collection can be downloaded here: <a href="">dl.dropbox.com/u/20585920/shaders.zip</a> <br><br>  All shaders are made in the program RenderMonkey, you can download it from the site AMD: <a href="http://developer.amd.com/resources/archive/archived-tools/gpu-tools-archive/rendermonkey-toolsuite/">developer.amd.com/resources/archive/archived-tools/gpu-tools-archive/rendermonkey-toolsuite/#download</a> <br><br>  If you are the owner of a GeForce video card, then RenderMonkey may not start.  You will need to use the 'nvemulate' utility.  Download here: <a href="http://developer.nvidia.com/nvemulate">developer.nvidia.com/nvemulate</a> .  Run it and change the setting of 'GLSL Compiler Device Support' to 'NV40': <br><br><img src="http://habrastorage.org/storage2/636/193/2b3/6361932b3cbfecb955d7675c819b09fa.gif"><br><br><h1>  UPD: Where to start yourself </h1><br>  Want to write your live wallpaper with opengl?  You do not know what to do with GLWallpaperService and other cleverness?  Everything has been written for a long time, take the code of examples and change it to your needs: <br>  OpenGL ES 2.0 example from Google: <a href="http://code.google.com/p/gdc2011-android-opengl/">code.google.com/p/gdc2011-android-opengl</a> <br>  OpenGL Desktop Live Wallpaper Example: <a href="https://github.com/markfguerra/GLWallpaperService">github.com/markfguerra/GLWallpaperService</a> </div><p>Source: <a href="https://habr.com/ru/post/164107/">https://habr.com/ru/post/164107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164093/index.html">Warm lamp phone</a></li>
<li><a href="../164095/index.html">Installing mercurial-server over ssh from source</a></li>
<li><a href="../164101/index.html">Java weather for beginners and older</a></li>
<li><a href="../164103/index.html">Google plans to attract 90% of MS Office users to Google Apps</a></li>
<li><a href="../164105/index.html">Electric Imp - Making a WiFi Thermometer</a></li>
<li><a href="../164109/index.html">US authorities retain the right to read "abandoned" e-mail without a court order</a></li>
<li><a href="../164111/index.html">Commentary of the day: Christmas leapfrog</a></li>
<li><a href="../164113/index.html">Aruba Networks - Part 2: Building a secure wireless infrastructure</a></li>
<li><a href="../164115/index.html">Nodal accounting in the treatise "Kotso-Pets" (Chincha Indians, 4th century AD)</a></li>
<li><a href="../164117/index.html">The collection of donations for the development of the FreeType project has been announced.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>