<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The Java Language Specification. Chapter 17. Threads and Locks (Translation. Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the translation of the article "The Java Language Specification ( Chapter 17. Threads and Locks )" Original. 

 Chapter 17....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The Java Language Specification. Chapter 17. Threads and Locks (Translation. Part 1)</h1><div class="post__text post__text-html js-mediator-article">  <i>Hi, Habr!</i>  <i>I present to you the translation of the article "The Java Language Specification ( <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Chapter 17. Threads and Locks</a> )" <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Original.</a></i> <br><br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Chapter 17. Threads and Locks (Chapter 17. Threads and Locks)</a> <br><br>  While most of the discussions in previous chapters concerned only the behavior of code executed simultaneously and as a single statement or expression at the same time, i.e.  in one thread, a JVM (Java virtual machine) can simultaneously support multiple execution threads.  These threads independently of each other use code that acts on values ‚Äã‚Äãand objects that are in shared memory.  Threads can be supported by using multiple hardware processors, temporal separation of a single hardware processor, or temporal separation of multiple hardware processors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Threads are represented by the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a> class.  The only way a user can create a thread is to create an object of this class;  each thread is associated with some object.  The thread will begin its execution when the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html"><i>start ()</i></a> method is called on the corresponding <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a> object. <br>  The behavior of threads, especially when synchronization is incorrect, may be incomprehensible and not in line with expectations.  This chapter describes the semantics of multi-threaded programming;  it contains the rules according to which values ‚Äã‚Äãcan be seen for reading in shared memory, which is updated by many threads.  Since the specification is similar to <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Memory Models</a> for different architectures, this semantics is known as the <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Memory Model</a> of the Java programming language.  When there is no confusion, we will simply call these rules the " <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Memory Model</a> ". <br><br>  This semanika does not prescribe how a multi-threaded program should be executed.  Rather, it describes the possible behavior that multi-threaded programs can demonstrate.  Any implementation strategy that generates possible behaviors is acceptable. <br><br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">17.1 Synchronization (17.1. Synchronization)</a> <br><a name="habracut"></a><br>  The Java programming language provides many mechanisms for inter-thread communication.  The most fundamental of them are synchronization methods (synchronization), which is performed using monitors.  Each object in Java is associated with a monitor, which a thread can lock or unlock (lock / unlock).  At the same time, only one thread can hold a monitor.  Any other threads that attempt to capture this monitor are blocked until they can capture it.  Thread <b>t</b> can block a specific monitor multiple times;  when the monitor is released (unlock), the effect of a single lock operation is canceled. <br><br>  The synchronized ( <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html">¬ß14.19</a> ) <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html">statement</a> computes a reference to an object, and then it tries to capture (lock) the monitor of this object and nothing happens until the capture is successful.  After a successful lock, the body of the synchronized statement is executed.  If the body of the synchronized statement is executed completely or in an abbreviated version, then this monitor is automatically released (unlock). <br><br>  The synchronized method ( <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html">¬ß8.4.3.6</a> ) automatically performs a lock (lock) on a call, its body is not executed until the lock (lock) is successfully executed.  If we are dealing with an instance method, then it captures the monitor associated with the instance for which it was invoked (that is, an object that will be known as this during the execution of the method body).  If the method is static, it captures the monitor associated with the Class object that represents the class in which the method is defined.  If the execution of the method body is completed completely or in an abbreviated version, this monitor is automatically released. <br>  The Java programming language does not prevent and does not require the definition of a deadlock condition.  Programs where threads hold (directly or indirectly) seizure on multiple objects should use common tricks to avoid deadlocking.  Create high-level locking primitives that do not have deadlocks, if necessary. <br><br>  Other mechanisms, such as reading and writing volatile variables, and using classes from the java.util.concurrent package provide alternative ways to synchronize. <br><br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">17.2 A set of expectations and notifications (17.2. Wait Sets and Notification)</a> <br><br>  Each object, in addition to what is associated with the monitor, is also associated with a set of expectations (Wait Sets).  A set of expectations is a set of threads. <br>  When an object is first created, its wait set is empty.  Elementary actions that add or remove threads to / from the set of expectations are atomic.  The set of expectations is managed exclusively through the <i>Object.wait</i> , <i>Object.notify</i> , and <i>Object.notifyAll methods</i> . <br><br>  The manipulation of the set of expectations can also be affected by the static interruption of the thread and the methods of the class <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a> associated with the interruption.  In addition, the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a> class methods for <i>sleeping</i> and <i>joining</i> other threads have properties obtained from the action properties of the <i>wait</i> and <i>notification</i> methods. <br><br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">17.2.1.</a>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Waiting (17.2.1. Wait)</a> <br><br>  The wait action occurs when the <i>wait ()</i> method is called or with the <i>wait (long millisecs)</i> and <i>wait (long millisecs, int nanosecs)</i> time signatures. <br><br>  A call to <i>wait (long millisecs)</i> with a parameter of zero or a call to <i>wait (long millisecs, int nanosecs)</i> with the two parameters specified is equal to zero equivalent to a call to <i>wait ()</i> . <br><br>  The thread returns and waits if it does not throw an <i>InterruptedException</i> exception. <br>  Suppose the thread <b>t</b> performs the <i>wait</i> method on the object <b>m</b> , and let <b>n</b> be the number of blocking actions on <b>t</b> by <b>m</b> that were not associated with unblocking actions.  One of the following actions will occur: <br><br><ul><li>  If <b>n is</b> zero (ie, the thread <b>t</b> has not yet captured the lock (lock) on the target <b>m</b> object), then an <i>IllegalMonitorStateException</i> will be thrown. </li><li>  If this <i>wait</i> with the given time signature <i>nanosecs</i> argument is not in the range of <i>0-999999</i> or the <i>millisecs</i> argument is specified with a negative number, then the <i>IllegalArgumentException</i> exception will be thrown </li><li>  If the thread <b>t</b> is interrupted, then the <i>InterruptedException</i> exception will be thrown and the state of interruption (interruption status) <b>t is</b> set to false. </li><li>  Otherwise, the following sequence occurs. <br><ol><li>  The thread <b>t is</b> added to the wait set of object <b>m</b> , and performs <b>n</b> unlocks (unlock) on M. </li><li>  The thread <b>t</b> does not perform any more instructions until it is removed from the set of expectations of the object <b>m</b> .  A thread can be removed from the wait set for any of the following reasons and will be restored sometime later: <br><br><ul><li>  The <i>notify</i> action was performed on <b>m</b> , in which <b>t is</b> selected to be removed from the <i>wait</i> set. </li><li>  The <i>notifyAll</i> action <i>is</i> performed on <b>m</b> . </li><li>  The <i>interrupt</i> action is performed on <b>t</b> . </li><li>  If <i>wait</i> with a given time signature, an internal action removes <b>t</b> from the set of expectations <b>m</b> , which occurs after at least <i>millisecs</i> plus <i>nanosecs</i> after the start of this wait action. </li><li>  Internal action through implementation.  The implementation is allowed, although not desirable, to perform ‚Äúspurious wake-ups‚Äù, that is, remove the thread from the set of expectations and thus allow the renewal of actions without additional instructions for this. <br>  <i>Note that this provision requires coding practice in Java, using <i>wait</i> only inside loops, which end only by the logical condition that the thread holds the lock.</i> <br></li></ul><br>  Each thread is required to determine the order of events that can cause it (ie, this thread) to remove from the set of expectations.  This order should not be consistent with other arrangements, but the thread should behave as if these events occurred in that order. <br><br>  For example, if the thread <b>t is</b> in the set of expectations for <b>m</b> , then the interrupt <b>t</b> and the notification occur.  These events must occur in some order.  If we assume that an interrupt occurred first, then <b>t</b> is eventually returned from <i>wait</i> with an exception throw <i>InterruptedException</i> and some other threads in the expectation set <b>m</b> (if they exist at the time of the notification) should receive a notification.  If we assume that a notification first occurred, then <b>t in the</b> usual way will eventually return from <i>wait</i> and the interrupt will be in standby mode. <br></li><li>  Thread <b>t</b> execute <b>n</b> locks per <b>m</b> . </li><li>  If the thread <b>t</b> was removed from the set of expectations <b>m</b> in step 2 due to an interrupt, then the interrupt status <b>t is</b> set to false and the <i>wait</i> method asks for <i>InterruptedException</i> . </li></ol></li></ul><br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">17.2.2.</a>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Notification (17.2.2. Notification)</a> <br>  Notification (notification) occurs when calling the method <i>notify</i> and <i>notifyAll</i> . <br>  Let's imagine that the thread <b>t</b> will use any of these methods on the object <b>m</b> , and let <b>n</b> be the number of locks captured by <b>t</b> by <b>m</b> , which did not correspond to the number of execution of monitor release (unlock) actions. <br>  One of the following actions will occur: <br><br><ul><li>  If <b>n</b> is zero, an <i>IllegalMonitorStateException</i> will be thrown. <br>  This is the case when the thread <b>t</b> no longer has a lock for the target <b>m-</b> object. </li><li>  If <b>n is</b> greater than zero and this is a <i>notify</i> action, then if the <i>wait</i> set <b>m is</b> not empty, thread <b>u</b> is selected that is a member of the current wait set <b>m</b> and is removed from the wait set. <br>  There is no guarantee which thread from the set of expectations will be selected.  Deleting a thread <b>u</b> from a set of waits resumes <b>u</b> in a wait-action.  Note, however, that the capture action <b>u</b> , when resuming, will be performed some time after <b>t</b> completely unlocks the monitor for <b>m</b> . </li><li>  If <b>n is</b> greater than zero and a <i>notifyAll</i> action is performed, then all threads are removed from the set of expectations <b>m</b> and thus resume. <br>  Notice, however, that at the same time, only one of them will capture the required monitor while resuming the wait. </li></ul><br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">17.2.3.</a>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Interrupts (17.2.3. Interruptions)</a> <br>  Interruptions occur when <i>Thread.interrupt is</i> called, as well as methods intended to call in turn, such as <i>ThreadGroup.interrupt</i> . <br>  Let <b>t</b> be called <b>u.interrupt</b> , for some thread <b>u</b> , where <b>t</b> and <b>u</b> can be the same.  These actions set the interrupt status <b>u</b> to true. <br><br>  Additionally, if there exists an object <b>m</b> whose set of expectations contains <b>u</b> , then <b>u</b> is removed from the set of expectations <b>m</b> .  This includes <b>u</b> for resuming in a wait-action; in this case, after re-capturing the monitor <b>m, an</b> <i>InterruptedException</i> will be thrown. <br>  Calls to <i>Thread.isInterrupted</i> can determine thread interruption statuses.  The static method <i>Thread.interrupted</i> can be called in a thread to monitor and clear its own interrupt status. <br><br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">17.2.4.</a>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Interaction of Expectations, Notifications, and Interruptions (17.2.4. Interactions of Waits, Notification, and Interruption)</a> <br><br>  The above specifications allow us to define some properties related to the interaction of expectations, notifications and interrupts. <br><br>  If the thread is notified and interrupted during the wait, it can either: <br><br><ul><li>  Return normally to wait, while still in the interrupt standby mode (in other words, calling <i>Thread.interrupted</i> will return true) </li><li>  Will return from waiting with an exception throw <i>InterruptedException</i> </li></ul><br>  A thread may not reset this stats interrupt and return normally from a wait call. <br>  Similarly, notifications can not be lost due to interrupts.  Suppose that the set of <b>s</b> threads in the set of expectations of the object <b>m</b> , and the other thread performs a <i>notify</i> on <b>m</b> .  Then either: <br><br><ul><li>  At least one thread and <b>s</b> should return normally and wait, or </li><li>  all threads from <b>s</b> should exit and throw <i>InterruptedException</i> </li></ul><br>  Notice that if the thread is both interrupted and woken through notify, and that this thread is returned from waiting by throwing <i>InterruptedException</i> , then any other thread in the expectation set should be notified. <br><br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">17.3.</a>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html">Sleep and Leap (17.3. Sleep and Yield)</a> <br><br>  <i>Thread.sleep</i> puts the working thread into sleep mode (temporary cessation of execution) for a certain period, depending on the accuracy of timers (system timers) and system schedulers (schedulers).  A thread does not lose control over monitors and its action resumes depending on the scheduling and availability of processors on which threads can be executed. <br>  It is important to mention that neither <i>Thread.sleep</i> nor <i>Thread.yield</i> have any synchronization semantics.  In particular, the compiler should not write to the cache on registers outside of shared memory before calling <i>Thread.sleep</i> or <i>Thread.yield</i> , the compiler also should not overload the values ‚Äã‚Äãof cache registers after calling <i>Thread.sleep</i> or <i>Thread.yield</i> . <br>  <i>For example, the following (not correct) code segment, suppose that this.done is a non-volatile boolean field.</i> <i><br><br></i> <pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done) Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  The compiler reads this.done only once in the cache, and after that uses the values ‚Äã‚Äãfrom the cache for each iteration of the loop.  This means that the loop will never end, even if another thread changes the value of this.done. <br><br>  The following parts will be presented: <br><br>  Part 2) Memory Model; <br>  Part 3) Semantics of final fields;  Word Tearing on some processors (x32);  not atomic support for <i>double</i> and <i>long</i> . <br><br>  Thanks for attention!:) </div><p>Source: <a href="https://habr.com/ru/post/358880/">https://habr.com/ru/post/358880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358866/index.html">And again: do not use public WiFi</a></li>
<li><a href="../358870/index.html">Saga of options</a></li>
<li><a href="../358872/index.html">Compact serializer for cache using System.Reflection.Emit</a></li>
<li><a href="../358874/index.html">Magic link or story about how we simplified the life of the user</a></li>
<li><a href="../358878/index.html">PHDays 8 Summary: Games Over</a></li>
<li><a href="../358882/index.html">Less management, more success: the ‚Äúinverted‚Äù structure of Supercell</a></li>
<li><a href="../358886/index.html">Spring mitap (and one summer) from Alfa-Bank</a></li>
<li><a href="../358888/index.html">How we at Tinkoff used Windows Hello to authenticate the user</a></li>
<li><a href="../358892/index.html">Express Moscow - San Jose: co-viewing WWDC 2018 in the Avito office on June 4</a></li>
<li><a href="../358896/index.html">Javascript We work with exceptions and data in async / await constructs without try-catch blocks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>