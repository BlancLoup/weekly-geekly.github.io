<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Text editor - this is not your highest mathematics, you need to think</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern text editors are able not only to bibikat and not to give out of the program. It turns out that a very complex metabolism is boiling inside the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Text editor - this is not your highest mathematics, you need to think</h1><div class="post__text post__text-html js-mediator-article">  Modern text editors are able not only to bibikat and not to give out of the program.  It turns out that a very complex metabolism is boiling inside them.  Want to find out what tricks are being taken to quickly recalculate coordinates, how styles, foldings and softwraps are attached to the text and how it is all updated, what‚Äôs the functional data structures and priority queues, and how to trick the user - welcome under the cat! <br><br><img src="https://habrastorage.org/webt/sr/i0/vg/sri0vg3jog_-mc16jc5zz-wjxw0.jpeg"><br><br>  The article is based on the <a href="http://2017.jokerconf.com/2017/talks/1n9frd7wtiu6qkgwu8oas0/">report by</a> Alexey Kudryavtsev with Joker 2017. Alexey has been writing Intellij IDEA in JetBrains for 10 years already.  Under the cut you will find the video and text transcript of the report. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YzWr9CN6cGQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Data structures within text editors </h1><br>  To understand how the editor works, let's write it. <br><br><img src="https://habrastorage.org/webt/q9/nb/-n/q9nb-nr675yuu19v6loydkq3nrm.png"><br><br>  Everything, our elementary editor is ready. <br><br>  Inside the editor, the text is easiest to store in an array of characters, or, equivalently (in terms of memory organization), in the Java class StringBuffer.  To get any character by offset, we call the StringBuffer.charAt (i) method.  And in order to insert into it the character that we typed on the keyboard, call the StringBuffer.insert () method, which will insert the character somewhere in the middle. <br><br>  What is most interesting, despite the simplicity and idiocy of this editor, is the best presentation that you can imagine.  It is simple and almost always fast. <br><br>  Unfortunately, there is a scale problem with this editor.  Imagine that we typed a lot of text in it and are going to insert another letter in the middle.  The following will happen.  We urgently need to free up some space for this letter by moving all the other letters one character forward.  To do this, we move this letter one position, then the next, and so on, until the very end of the text. <br><br>  Here is how it will look in memory: <br><br><img src="https://habrastorage.org/webt/ec/uk/r4/ecukr4oxdmj0tlxojojwuf9k8i4.gif"><br><br>  Shifting all these numerous megabytes is not very good: it is slow.  Of course, for a modern computer this is a trivial matter - move some miserable megabytes back and forth.  But for a very active text change this can be noticeable. <br><br>  In order to solve this problem of inserting a symbol in the middle, a bypass maneuver called ‚ÄúGap Buffer‚Äù was invented long ago. <br><br><h3>  Gap buffer </h3><br>  Gap is a gap.  Buffer is, as you might guess, a buffer.  The ‚ÄúGap Buffer‚Äù data structure is such an empty buffer that we store in the middle of our text, just in case.  If we needed to print something, we use this text small buffer for quick typing. <br><br><img src="https://habrastorage.org/webt/vc/ca/v4/vccav4jbt0zboaf_fuo985dzerc.png"><br><br>  The data structure has changed a little bit - the array remained in place, but two pointers appeared: at the beginning of the buffer and at its end.  To take a character from the editor at some offset, we need to understand whether it is before or after this buffer and correct the offset a little.  To insert a symbol, we first need to push the Gap Buffer to this place and fill it with these symbols.  And, of course, if we went beyond our buffer, it would somehow be re-created.  Here is how it looks in the picture. <br><br><img src="https://habrastorage.org/webt/bu/4a/gs/bu4ags_jk9vobq_9rxegbww01nw.gif"><br><br>  As you can see, we first move a long time to a small gap-buffer (a blue rectangle) to the editing site (simply swapping characters from its left and right edges in turns).  Then we use this buffer, typing in the characters there. <br><br>  As you can see, there is no movement of megabytes of characters, insertion happens very quickly, at a time constant, and everyone seems happy.  Everything seems to be fine, but if we have a very slow processor, then the gap-buffer and the text are spent quite noticeably moving back and forth.  This was especially noticeable in times of very small megahertz. <br><br><h3>  Piece table </h3><br>  Just at this time, a corporation called Microsoft was writing a text editor Word.  They decided to apply another idea to speed up editing under the name ‚ÄúPiece Table‚Äù, that is, ‚ÄúPiece Table‚Äù.  And they proposed to save the text of the editor in the same simplest array of characters, which will not change, and add all its changes into a separate table of these most edited pieces. <br><br><img src="https://habrastorage.org/webt/gf/gt/gu/gfgtgutww7ymm-bx-4v7tytyjt4.png"><br><br>  Thus, if we need to find some symbol by offset, we need to find this piece, which we have edited, and extract this symbol from it, and if it is not there, then go to the original text.  Inserting a symbol becomes easier; we just need to create and add this new piece to the table.  Here is how it looks in the picture: <br><br><img src="https://habrastorage.org/webt/94/8w/3u/948w3uylg_cuxh8mywws-owxs_i.gif"><br><br>  Here we wanted to remove the space at offset 5. To do this, we add two new pieces to the table of pieces: one points to the first fragment (‚ÄúBummer‚Äù), and the second points to the fragment after editing (‚Äúsheep‚Äù).  It turns out that the space of them disappears, these two pieces are glued together, and we get a new text without a space: ‚ÄúOblomovtsy‚Äù.  Then we add a new text (‚Äúthose suffering from oblomovism‚Äù) to the end.  We use an additional buffer and add a new piece to the table of pieces (piece table), which points to this newest added text. <br><br>  As you can see, there is no movement back and forth, the whole text remains in place.  The bad thing is that it becomes harder to get to the character, because sorting through all these pieces is pretty hard. <br><br>  Let's sum up. <br><br>  What is good in the <b>Piece Table</b> : <br><br><ul><li>  Quickly insert; </li><li>  Easy to do undo; </li><li>  Append-only. </li></ul><br>  What is wrong: <br><br><ul><li>  Terribly difficult to access the document; </li><li>  Terribly difficult to implement. </li></ul><br>  Let's see who generally uses what we have. <br><br>  NetBeans, Eclipse and Emacs use Gap Buffer - well done!  Vi doesn't bother and just uses the list of lines.  Word uses the Piece Table (they recently laid out their ancient sorcerers and there they could even understand something). <br><br>  With Atom more interesting.  Until recently, they did not bother and used a JavaScript list of lines.  And then we decided to rewrite everything in C ++ and fiddled with a rather complex structure, which seems to be similar to the Piece Table.  But these pieces they have are not stored in the list, but in a tree, and in the so-called splay tree, this is a tree that self-regulates when inserted into it so that recent insertions are faster.  They are very complicated stuff. <br><br>  What does Intellij IDEA use? <br>  No, not gap-buffer.  No, you're wrong, too, not a piece table. <br>  Yes, that's right, your own bike. <br><br>  The fact is that the IDE's requirements for storing text are slightly different than in a regular text editor.  IDE needs support for various tricky things like competitiveness, that is, parallel access to text from the editor.  For example, so that many different questions could be read and done.  (Inspection is a small piece of code that analyzes the program in some way or another ‚Äî for example, looking for places that throw a NullPointerException).  The IDE also needs support for editable text versions.  Several versions are simultaneously stored in memory while you are working with a document so that these long processes continue to analyze the old version. <br><br><h1>  Problems </h1><br><h3>  Competitiveness / Versioning </h3><br>  In order to maintain parallelism, text operations are usually wrapped in ‚Äúsynchronized‚Äù, or in Read- / Write-locks.  Unfortunately, this is not very well scaled.  Another approach is Immutable Text, that is, an unchangeable text repository. <br><br><img src="https://habrastorage.org/webt/ov/ia/sa/oviasaeniuwmhiaebpsic_mxm88.png"><br><br>  This is what an editor looks like with an immutable document as a supporting data structure. <br><br>  How is the data structure itself? <br><br>  Instead of an array of characters, we will have a new ImmutableText object that stores text in the form of a tree, where sheets are stored in small podstrochki.  When addressing by some kind of displacement, he tries to reach the lowest leaf in this tree, and he already has to ask the symbol to which we addressed.  And when inserting text, it creates a new tree and saves it in the old place. <br><br><img src="https://habrastorage.org/webt/_2/xx/rh/_2xxrh9kohjwodn3ub-gyt2z8la.gif"><br><br>  For example, we have a document with the text "Calorie-free".  It is implemented as a tree with two sheets of pods "Demon" and "high-calorie."  When we want to insert the ‚Äúpretty‚Äù line in the middle, a new version of our document is created.  And precisely, a new root is being created, to which three sheets are already attached: "Bes", "enough" and "high-calorie".  Moreover, two of these new sheets can refer to the first version of our document.  And for the sheet, in which we inserted the line ‚Äúpretty‚Äù, a new vertex is assigned.  Here both the first version and the second version are available at the same time and they are all immutable, unchangeable.  Everything looks good. <br><br>  Who uses what tricky structures? <br><br><img src="https://habrastorage.org/webt/yf/mt/eh/yfmtehxbzlale_95bblpk2msh2k.jpeg"><br><br>  For example, in GNOME, some standard widget uses a structure called Rope.  Xi-Editor is a brilliant new editor from <a href="https://en.wikipedia.org/wiki/Raph_Levien">Rafa Levien</a> - it uses Persistent Rope.  And Intellij IDEA uses this same Immutable Tree.  Behind all these names, in fact, hides more or less the same data structure with a tree view of the text.  Except that GtkTextBuffer uses Mutable Rope, that is, a tree with variable vertices, and Intellij IDEA and Xi-Editor - Immutable. <br><br>  The next thing to consider when developing a symbol repository in modern IDEs is called ‚Äúmulticaret‚Äù.  This feature allows you to print in several places at once, using several carriages. <br><br><img src="https://habrastorage.org/webt/qb/ak/9t/qbak9tqjnu7v_iiciaouw-qqeug.gif"><br><br>  We can print something and at the same time in several places of the document we insert what we typed there.  If we look at how our data structures that we reviewed react to multicaret, we will see something interesting. <br><br><img src="https://habrastorage.org/webt/ty/4p/8k/ty4p8kuqs1rgeanxr9y3n9i8wz4.jpeg"><br><br>  If we insert a character into our very first primitive editor, it will take, naturally, a linear amount of time to move a bunch of characters back and forth.  This is written as O (N).  For the editor based on Gap Buffer, in turn, it takes already constant time, for this he was invented. <br><br>  For an immutable tree, time depends logarithmically on the size, because you must first go from the top of the tree to its leaf ‚Äî this is the logarithm, and then for all the vertices on the way, create new vertices for the new tree ‚Äî this is again the logarithm.  Piece Table also requires a constant. <br>  But everything changes a little bit, if we try to measure the time of inserting a symbol into the editor with multi-carriages, that is, inserts simultaneously in several places.  At first glance, time seems to increase proportionally by C times - the number of places where the symbol is inserted.  Everything is happening, with the exception of Gap Buffer.  In his case, the time, instead of C times, is unexpectedly increased by some incomprehensible C * L time, where L is the average distance between carriages.  Why it happens? <br><br>  Imagine that we need to insert the line ", to" in two places in our document. <br><br><img src="https://habrastorage.org/webt/ec/n3/jd/ecn3jdpnsvqscfbvjxivopbs5uq.gif"><br><br>  This is what happens in the editor at this time. <br><br><ul><li>  Create a gap-buffer editor (a blue rectangle in the figure); </li><li>  We get two carriages (black fat vertical lines); </li><li>  We try to print; </li><li>  Insert a comma in our Gap Buffer; </li><li>  Must now insert it in place of the second carriage; </li><li>  To do this, we need to push our Gap Buffer to the position of the next carriage; </li><li>  Type comma in second place; </li><li>  Now you need to insert the next character in the position of the first carriage; </li><li>  And we have to push our Gap Buffer back; </li><li>  Insert the letter "n"; </li><li>  And we move our long-suffering buffer to the place of the second carriage; </li><li>  We insert there our "n"; </li><li>  Move the buffer back to insert the next character. </li></ul><br>  Feel what all goes? <br><br>  Yes, it turns out that because of these numerous buffer movements back and forth, our total time increases.  Honestly, it‚Äôs not that horror as straightforwardly increased - it‚Äôs not a problem to move miserable mega-gigabytes back and forth for a modern computer, but it‚Äôs still interesting that this data structure works radically differently in the case of multicarets. <br><br><h3>  Too many lines?  LineSet! </h3><br>  What other problems are there in a regular text editor?  The most difficult problem is scrolling, that is, redrawing the editor while moving the carriage to the next line. <br><br><img src="https://habrastorage.org/webt/yt/0d/rn/yt0drnu1rsxyciwb4pruefmufyu.gif"><br><br>  When the editor scrolls, we need to understand from which line, from which character we need to start drawing the text in our little window.  To do this, we need to quickly understand which line corresponds to which offset. <br><br><img src="https://habrastorage.org/webt/kn/ak/gm/knakgm1aq7-wnjwbruefxeyouh0.png"><br><br>  There is an obvious interface for this, when we need to understand its offset in the text by the line number.  Conversely, by the offset in the text to understand in which line it is.  How can this be done quickly? <br><br>  For example: <br><br>  Arrange these lines into a tree and mark each vertex of this tree with the offset of the beginning of the line and the offset of the end of the line.  And then, in order to understand by offset, what line it is in, just need to run a logarithmic search in this tree and find it. <br><br><img src="https://habrastorage.org/webt/x1/jq/3w/x1jq3w1gwiytzsrdytznnltc_l0.png"><br><br>  Another way is even easier. <br><br>  Write in the table the offset of the beginning of the lines and the end of the lines.  And then, in order to find the offset of the beginning and end by the line number, you will need to refer to the index. <br><br><img src="https://habrastorage.org/webt/wq/ls/wy/wqlswyl-k5brg4fsbgoxaqxkj1u.png"><br><br>  Interestingly, in the real world, both are used. <br><br><img src="https://habrastorage.org/webt/ii/w6/qu/iiw6quo2j0clh8xnovh0mfn5ow0.jpeg"><br><br>  For example, Eclipse uses a wooden structure that, as you can see, works in logarithmic time for both reading and updating.  And IDEA uses a table structure, for which reading is a fast constant, is an index call in the table, but rebuilding is rather slow, because you need to rebuild the entire table when you change the length of a line. <br><br><h3>  Still too many lines?  Foldings! </h3><br>  What else is bad, what stumble on in text editors?  For example, folding.  These are pieces of text that can be ‚Äúcollapsed‚Äù and show something else instead. <br><br><img src="https://habrastorage.org/webt/tp/g1/fc/tpg1fcoak4ahpzd1mbf9wex_jvi.png"><br><br>  These ellipses on a green background in the picture hide many symbols behind us, but if we don‚Äôt look at them interestingly (as in the case of, for example, the most boring Java docs or import sheets), we hide them, collapse them into this dots. <br><br>  And here again you need to understand when the region ends and when the region begins, which we need to show, and how to update all this quickly?  How it is organized, I will tell you later. <br><br><h3>  Too long lines?  Soft wrap! </h3><br><img src="https://habrastorage.org/webt/yu/lb/hg/yulbhgos7wf3ilx0gqtxg2lrkpq.jpeg"><br><br>  Also, modern editors can not live without Soft wrap.  The picture shows that the developer opened the JavaScript file after minimization and immediately regretted it.  This huge JavaScript line, when we try to show it in the editor, will not fit into any screen.  Therefore, soft wrap it forcibly breaks into several lines and cram into the screen. <br>  How it is organized - later. <br><br><h3>  Too little beauty </h3><br><img src="https://habrastorage.org/webt/md/yh/d0/mdyhd06genl8kiaehxjectze9g4.jpeg"><br><br>  And finally, I still want to bring beauty in text editors.  For example, highlight some words.  In the picture above, the keywords are highlighted in bold blue, some static methods by the Italian, some annotations are also in a different color. <br><br>  So how do you still keep and handle foldings, soft wraps and highlighting? <br>  It turns out that all this, in principle, is one and the same task. <br><br><h3>  Too little beauty?  Range highlighters! </h3><br><img src="https://habrastorage.org/webt/jj/rl/t7/jjrlt7sisz9curcqa5lotpzjfya.jpeg"><br><br>  To support all these features, all we need to be able to do is to stick some text attributes on the given offset in the text, for example, color, font or text for folding.  Moreover, these text attributes need to be updated all the time in this place, so that they experience all sorts of insertions and deletions. <br><br>  How is this usually implemented?  Naturally, in the form of a tree. <br><br><h3>  Problem: too much beauty?  Interval tree! </h3><br><img src="https://habrastorage.org/webt/0e/ux/le/0euxleajuom5pdsa02kwxuudyny.jpeg"><br><br>  For example, here we have some yellow highlights that we want to keep in the text.  We add these highlight intervals to the search tree, the so-called interval tree.  This is the same search tree, but a bit trickier, because we need to store intervals instead of numbers. <br><br>  And since there are both healthy and small intervals, then how to sort them, comparing with one another and putting them into a tree is a rather trivial task.  Although very widely known in computer science.  Look then somehow at your leisure, as it is arranged.  So, we take and put all our intervals into a tree, and then each text change somewhere in the middle leads to a logarithmic change of this tree.  For example, inserting a character should result in updating all intervals to the right of that character.  To do this, we find all the dominant vertices for this symbol and indicate that all their sub-bushes must be moved one character to the right. <br><br><h3>  Still want beauty?  Ligatures! </h3><br><img src="https://habrastorage.org/webt/iv/j-/tb/ivj-tb9_w2ata-tiwclrmqfjs_a.jpeg"><br><br>  There is also such a terrible thing - ligatures, which I would also like to support.  These are different beauties like how the ‚Äú! =‚Äù Sign is drawn as a large ‚Äúnot equal‚Äù glyph and so on.  Fortunately, here we look forward to a swing mechanism supporting these ligatures.  And, in our experience, he apparently works in the simplest way.  Inside the font is a list of all these pairs of characters, which, when joined together, form some kind of clever ligature.  Then, when drawing a line, Swing simply iterates over all these pairs, finds the necessary ones and draws them accordingly.  If you have a lot of ligatures in the font, then, apparently, its display will proportionally slow down. <br><br><h3>  Brakes typing </h3><br>  And most importantly, another problem that occurs in modern complex editors is the optimization of taiping, that is, pressing the keys and displaying the result. <br><br><img src="https://habrastorage.org/webt/fq/yb/wi/fqybwipttxn9pvl3phzc5qts6_k.jpeg"><br><br>  If you get inside Intellij IDEA and see what happens when you press a button, the next horror happens there: <br><br><ul><li>  When we press the button, we have to see if we are in the completion popup to close the menu for the completion, if we, for example, type in some ‚ÄúEnter‚Äù. </li><li>  You need to see if the file is under some tricky version control system, like Perforce, which has to do some actions to start editing. </li><li>  Check if there is any special region in the document that cannot be printed, such as some autogenerated texts. </li><li>  If the document is blocked by an operation that has not ended, you need to complete the formatting, and then continue. </li><li>  Find an injected-document, if it is in this place, because the language in it will be different, you need to type everything out completely differently. </li><li>  Call all plug-ins auto popup handler, so that they can type, for example, the closing and opening quotes in the right place. </li><li>  For info parameters, update the window so that it shows the necessary parameters if we moved there.  For these plugins, call selection remove, so that they remove the selection as appropriate, depending on the language.  And remove this selection physically by removing it from the document. </li><li>  Select from all plug-ins typed handler, so that they process the desired character in order to print a bracket on top of another bracket. </li><li>  Closing structural bracket handle. </li><li>  Run undo, count virtual spaces and start write action. </li><li>  Finally, insert a character in our document. </li></ul><br>  Hooray! <br><br>  Hell no, that's not all.  Delete character if our buffer is full.  For example, in the console, call a listener so that everyone knows that something has changed.  Scroll editor view.  Call some more stupid listeners. <br><br>  And what happens now in the editor when he found out that the document had changed and DocumentListener had volunteered to us? <br><br>  In Editor.documentChanged (), this is what happens: <br><br><ul><li>  Update error stripe; </li><li>  Recalculate gutter size, redraw; </li><li>  Recount editor component size, send events when changing; </li><li>  Calculate the modified lines and their coordinates; </li><li>  recount soft wrap if the change affected it; </li><li>  Call repaint (). </li></ul><br>  This repaint () is just an indication for Swing that the region on the screen should be redrawn.  A real redraw will occur when the Repaint event is processed by a Swing message queue. <br><br>  That is, somewhere in half an hour, the queue of processing our event will come up, the repaint method of the corresponding component will be called, which will do the following: <br><br><img src="https://habrastorage.org/webt/je/qh/cy/jeqhcytdxkun3ft_r7azwrby2eu.jpeg"><br><br>  Called a bunch of different paint-methods that paint everything that is possible in the world in this case. <br><br>  Well, can we optimize this all? <br><br><img src="https://habrastorage.org/webt/sm/mo/xq/smmoxqrmfayyfodciwe75svwdzw.jpeg"><br><br>  This is all, to put it mildly, quite difficult.  Therefore, we at Intellij IDEA decided to deceive the user. <br><br><img src="https://habrastorage.org/webt/5u/x8/as/5ux8ashfsenwboudd_u07ubtjmk.jpeg"><br><br>  Before all these horrors that count something and write something down, we call a small method that draws this unfortunate letter right on the place where the user imprints it.  And that's it!  The user is happy, because he thinks that everything has already changed, but in actual fact - no!  Everything is just beginning under the hood, but the little letter is already burning in front of it.  And so everyone is happy.  This feature is called Zero latency typing. <br><br><h1>  Collaborative editors </h1><br>  Now there is such a fashionable thing - the so-called collaborative editors. <br><br>  What it is?  This is when one user is sitting in India, another - in Japan, they are trying to type something into the same Google Docs and want some predictable result. <br><br>  What is special: <br><br><ul><li>  Thousands of users; </li><li>  Big delay. </li></ul><br>  The peculiarity here is that a huge number of users can do this at the same time, and the signal can go from India to Japan for a very long time. <br><br>  And because of this, usually in collaborative editors they use newfangled things like immobility.  And they came up with different things, how to make sure that everything works as it should.  These are a few criteria.  The first criterion is the preservation of intention, the intention preservation.  This means that if someone imprinted a symbol, then sooner or later the symbol from India will come to Japan, and the Japanese will see exactly what the Indian intended.  And the second criterion is convergence.  This means that symbols from India and Japan will sooner or later be transformed into something the same for Japan and for India. <br><br><h3>  Operation transformation </h3><br><img src="https://habrastorage.org/webt/h9/e8/pq/h9e8pqu3ljnoh4y70_759peizn0.jpeg"><br><br>  The first algorithm that was invented to support this thing is called the ‚Äúoperation transformation‚Äù.  It works like this.  An Indian and a Japanese are sitting, typing something: one deletes a letter from the end, another draws a letter to the beginning.  The Operation transformation framework sends these operations to all other places.  He must understand how to surmount the operations that come to him in order to get at least something sensible.  For example, when you simultaneously have a letter deleted and appeared.  He should work there more consistently and come to the same line there.  Unfortunately, as can be seen from my confused explanation, this is a rather complicated matter. <br><br>  When the first implementations of this framework began to appear, astonished developers discovered that there is a universal example that breaks everything.  This unfortunate example was called the ‚ÄúTP2 puzzle‚Äù. <br><br><img src="https://habrastorage.org/webt/c1/5i/cs/c15icsdnqbjqykloe_pfbxahz-e.jpeg"><br><br>  One user draws some characters to the beginning of the line, another one removes all this, and the third draws to the end.  After all this Operation transformation tries to merge into one and the same, then this line should, in theory, turn out to be this line ("DANA").  However, some implementations did this (‚ÄúNADA‚Äù).  Because it is not clear where to insert it.  In the picture above you can see at what level this whole science is about the Operation transformation, if because of such a primitive example, everything broke. <br><br>  But despite this, some people still do it, like Google Docs, Google Wave and some distributed editor of Etherpad.  They use the Operation transformation despite the problems listed. <br><br><h3>  Conflict-free replicated data type </h3><br>  The people here had their heads brained and decided: ‚ÄúLet's make it easier than OT!‚Äù The number of any tricky combinations of operations that need to be processed and merged together grows quadratically.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, instead of processing all the combinations, we will simply send our status along with the operation to all other hosts so that it can be merged into the same text with a 100% guarantee. This is called a ‚ÄúCRDT‚Äù (Conflict-free replicated data type). </font></font><br><br><img src="https://habrastorage.org/webt/kn/82/9n/kn829n91st7gpykcp905spuy_ki.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this to work, you need a state and a function, which of the two states together with the operation makes a new state. Moreover, this function should be commutative, associative, idempotent and monotone. And then it is clear that everything will work simply and reinforced. Because of these draconian restrictions on the function, we are no longer afraid of order violations (the function is commutative), priority (associative), and packet loss in the network (idempotency and monotony). </font></font><br><br><img src="https://habrastorage.org/webt/vs/9-/i7/vs9-i7bdfpjonh_z1cgie6qj4kk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Are there such functions in nature and how can they be applied?</font></font><br><br>  Yes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, for the case of so-called G-counter'ov, that is, counters that are only growing. You can write a function for this counter that is truly monotonous, and so on. Because if we have the operation ‚Äú+1‚Äù from Japan, the other ‚Äú+1‚Äù from India, it is clear how to make a new state out of them - just add ‚Äú2.‚Äù But it turns out that in the same way, you can also make an arbitrary counter that can be incremented and decremented. To do this, it is enough to take one G-counter, which grows up all the time, and apply all increment operations to it. And all decrements are applied to another G-counter, which will grow downwards. To get the current state, you just need to subtract their contents, and we get the same monotony. This is all possible to extend to arbitrary sets.But the most important thing is for arbitrary strings. Yes, editing arbitrary strings can also be made CRDT. Turns out it's pretty easy.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflict-free replicated inserts </font></font></h3><br><img src="https://habrastorage.org/webt/pz/bg/ta/pzbgta8bteajr0embilmbnpxifc.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let's name all the characters in the document so that they are always uniquely identifiable, even after any edits. </font><font style="vertical-align: inherit;">Well, for example, together with each letter we will store a unique number. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, instead of sending all people the information that we insert a symbol at some offset, we will instead say between exactly which symbols we insert it. </font><font style="vertical-align: inherit;">And then it is clear that there can be no discrepancies, no matter where we insert, we will definitely know the place, even after all other operations. </font><font style="vertical-align: inherit;">For example, instead of sending an operation that we want to insert ‚ÄúRLU‚Äù at offset 2, we will send information that we insert ‚ÄúRLU‚Äù between this ‚ÄúY‚Äù and this ‚ÄúH‚Äù.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflict-free replicated deletes </font></font></h3><br><img src="https://habrastorage.org/webt/jt/w1/fb/jtw1fbphe5mjcyhbye4ua-mjf7s.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also implement and delete characters. </font><font style="vertical-align: inherit;">Since all of our characters are uniquely renamed, we simply say exactly which character needs to be removed, instead of some kind of offsets. </font><font style="vertical-align: inherit;">But instead of physically deleting these characters, we‚Äôll mark them as deleted. </font><font style="vertical-align: inherit;">In order for subsequent parallel inserts or deletions to know, if they affect these deleted characters, exactly where they should go. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And it turns out that this whole new-fangled science works.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflict-free replicated edits </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, in fact, CRDT is even implemented somewhere, for example, in Xi-Editor, which will be inserted into their newfangled Fuchsia secret operating system. </font><font style="vertical-align: inherit;">Honestly, I don‚Äôt know other examples, but it definitely works.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zipper </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would also like to tell you about the thing that is used in this new, immutable world called ‚ÄúZipper‚Äù. After we made our structures immutable, some nuances of working with them appeared. Here, for example, we have our immotable tree with text. We want to change it, (by ‚Äúchange‚Äù here, as you understand, I mean ‚Äúcreate a new version‚Äù). Moreover, we want to change it in some particular place and quite actively. In editors, it is quite common when we constantly print, insert and delete something at the cursor. To do this, the functionaries came up with a structure called Zipper. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It has the concept of the so-called cursor or the current place for editing, while maintaining full immunity. Here is how it is done.</font></font><br><br><img src="https://habrastorage.org/webt/ap/ne/p2/apnep2miklsburr5xhtqgcwbzri.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a Zipper for our document, which contains a line for editing (‚ÄúWell, have to be the same‚Äù). Call the operation on this Zipper to move along the line to the editing place. In our case - go down to the top right down. To do this, we create a new vertex (red) corresponding to the current vertex, attach to it links to the child vertices from our tree. Now, to move the Zipper cursor, we go down and down and create a new vertex instead of the one on which we stood. At the same time, add a link to the top up, so as not to forget where you came from (red arrows). Having thus reached the place of editing, we create a new sheet instead of the edited text (red rectangle). Now go back, going along the red arrows upwards and replacing them on the way to the correct links to the child vertices.When we reach the top, we will have a new tree with an edited sheet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice how the cursor helps us edit the current piece of wood. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What conclusions did I want to convey to you? </font><font style="vertical-align: inherit;">First, oddly enough, in the topic of text editors, despite its stuffiness, there are all sorts of interesting things. </font><font style="vertical-align: inherit;">Moreover, sometimes new, sometimes unexpected discoveries appear in the same topic. </font><font style="vertical-align: inherit;">And thirdly, sometimes they are so new that they do not work the first time. </font><font style="vertical-align: inherit;">But interesting and you can warm up.</font></font> Thank. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://github.com/JetBrains/intellij-community"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail</font></font></a> <br><br><h1>  Links </h1><br> <a href="https://en.wikipedia.org/wiki/Zipper_(data_structure)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zipper data structure </font></font></a> <br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does the CRDT in Xi Editor work </font></font></a> <font style="vertical-align: inherit;"><a href="http://blog.atom.io/2017/10/12/atoms-new-buffer-implementation.html"><font style="vertical-align: inherit;">? In </font></a></font><br> <a href="http://xi-editor.github.io/xi-editor/docs.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">general, the tree data structures for text </font></font></a> <br> <a href="http://blog.atom.io/2017/10/12/atoms-new-buffer-implementation.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What has been done in the Atom</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After the report, a lot of time has passed, and Microsoft managed to recall its roots and </font></font><a href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rewrite the Visual Studio Code editor to the Piece Table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in general, for some reason, many people were drawn to </font></font><a href="http://www.averylaird.com/programming/piece-table/2018/05/10/insertions-piece-table/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">experiments</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Want even more powerful reports, including Java 11? </font><font style="vertical-align: inherit;">Then we are waiting for you on </font></font><a href="https://jokerconf.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joker 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This year Josh Long, John McClean, Marcus Hirt, Robert Scholte and other equally cool speakers will perform. </font><font style="vertical-align: inherit;">17 days left before the conference. </font></font><a href="https://jokerconf.com/registration/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tickets</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on site.</font></font></blockquote></div><p>Source: <a href="https://habr.com/ru/post/424763/">https://habr.com/ru/post/424763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424751/index.html">How does the Unified Biometric System work?</a></li>
<li><a href="../424753/index.html">What's new in YouTrack 2018.3</a></li>
<li><a href="../424755/index.html">Money loves the bill: how cars sort bills</a></li>
<li><a href="../424757/index.html">Event Digest for HR-specialists in IT in October 2018</a></li>
<li><a href="../424761/index.html">Introduction to the Linux kernel bootup and startup processes</a></li>
<li><a href="../424765/index.html">Status Management in Flutter Applications</a></li>
<li><a href="../424767/index.html">We make from Habr cake. Again</a></li>
<li><a href="../424771/index.html">Personal experience: from the idea and a clean slate to a draft version of the site</a></li>
<li><a href="../424773/index.html">Biopharma and numerical modeling: Amgen's experience and practice</a></li>
<li><a href="../424777/index.html">Using Consul to scale stateful services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>