<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing microservices: a reasonable approach</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Driving force of microservices 
 The ability to develop, deploy and scale various business functions independently of each other is one of the most pu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing microservices: a reasonable approach</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9a5/517/37d/9a551737ddea82563cb802cb2107e27b.png"><br><br><h2>  Driving force of microservices </h2><br>  The ability to develop, deploy and scale various business functions independently of each other is one of the most publicized advantages of switching to a microservice architecture. <br><br>  While the rulers of thoughts are still unable to decide whether this statement is true or not, microservices have already managed to get into fashion - and to such an extent that for most startups they de facto have become the default architecture. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, when it comes to <em>testing</em> (or, worse, <em>developing</em> ) microservices, it turns out that most companies still have an attachment to the antediluvian method of testing all the components <em>together</em> .  Creating a complex infrastructure is considered a prerequisite for <em>end-to-end</em> testing, in which a test suite for <em>each</em> service must be performed ‚Äî this is done to make sure that no regressions or incompatible changes appear in the services. <a name="habracut"></a><br><br>  <strong>From translators.</strong>  AT <a href="https://medium.com/%40copyconstruct/testing-microservices-the-sane-way-9bb31d158c16%3Fimm_mid%3D0fa713%26amp%3Bcmp%3Dem-webops-na-na-newsltr_20180112"></a>  <a href="https://medium.com/%40copyconstruct">The original article by Cindy Sridharan</a> uses a large number of terminology for which there are no well-established Russian counterparts.  In some cases, used Anglicisms are used, it seems reasonable to us to write them in Russian, and in disputable cases, in order to avoid misinterpretation, we will write the original term. <br><br>  Today, the world has no shortage of books and articles on best software testing practices.  However, in our today's article we will focus solely on the topic of testing backend services and will not cover testing of desktop applications, systems with special technical security requirements, tools with a graphical interface and other types of software. <br><br>  It is worth noting that different specialists put different meanings into the concept of a ‚Äúdistributed system‚Äù. <br><br>  In our today's article, a ‚Äúdistributed system‚Äù refers to a system consisting of multiple moving parts, each of which has different guarantees and types of failures, these parts working together in unison to implement a specific business function.  My description may be very remotely similar to the classical definition of distributed systems, but it applies to the systems I regularly come across with - and I‚Äôm ready to argue that it is the very <em>majority</em> of us that develop and support such systems.  Further in the article we are talking about distributed systems, which are now called ‚Äúmicroservice architecture‚Äù. <br><br><h2>  "Full stack in a box": a cautionary tale </h2><br>  I often have to deal with companies that are trying to <em>fully</em> reproduce the topology of services locally on developers' laptops.  I had to face this delusion in person at the previous place of work, where we tried to deploy our entire stack in a Vagrant box.  The Vagrant repository was called the ‚Äúfull stack in a box‚Äù;  As you might have guessed, the idea was that one simple vagrant up team should have allowed any engineer in our company (even front-end and mobile developers) to deploy <em>absolutely the entire</em> stack on their working laptops. <br><br>  As a matter of fact, it was not a full-fledged <a href="https://twitter.com/Werner/status/741673514567143424">micro</a> - <a href="https://twitter.com/Werner/status/741673514567143424">service architecture of Amazon scale</a> , containing thousands of services.  We had two backend services: a gevent-based API server and background asynchronous Python asynchronous workers who had a whole tangle of native dependencies that included a <a href="http://www.boost.org/">boost to C ++</a> - and, if the memory keeps me, it was compiled from scratch every time a new box is launched on Vagrant. <br><br>  My first working week in this company was entirely devoted only to locally raising a virtual machine and defeating a great many mistakes.  Finally, by the evening of Friday, I managed to get Vagrant to work, and all the tests worked successfully on my PC.  Finally, I decided to document all the problems I had to face, so that other developers would have less such problems. <br><br>  And what do you think, when the new arrival of the developer began to customize Vagrant, then he ran into very different errors - and I could not even reproduce them on my machine.  Truthfully, this whole fragile design also breathed its last incense on my laptop - I was afraid to even update the library for Python, since the <em>pip install</em> once executed managed to break the Vagrant settings, and stopped running the tests when it started locally. <br><br>  In the process of debriefing, it turned out that Vagrant had similar business with programmers from mobile and web development teams;  troubleshooting Vagrant has become a frequent source of requests coming to the support team, where I worked then.  Of course, someone can declare that we just had to spend more time on fixing Vagrant settings once and for all, so that everything ‚Äújust worked‚Äù, in my defense I would say that the described story took place in a startup where and engineering cycles forever are not enough. <br><br>  <a href="https://ferd.ca/">Fred Hebert</a> wrote a wonderful review of this article, and made a remark that describes my feelings exactly: <br><br><blockquote>  ... please start the cloud on the developer's machine is equivalent to the need to support the new cloud provider, and the worst of all possible, with what you just had to face. </blockquote><br>  Even under the condition that you follow the most modern methods of operation - ‚Äúinfrastructure as a code‚Äù, immutable infrastructure - an attempt to deploy a cloudy environment locally will not do you any good, commensurate with the efforts that you take to raise it and provide long-term support. <br><br>  After talking with my friends, I found out that the problem described poisons life not only for those who work in startups, but also for those who work in large organizations.  Over the past few years I have been able to hear a lot of jokes about how easily such a structure falls apart and how expensive it is to exploit its support.  Now I firmly believe that the idea of ‚Äã‚Äãdeploying the entire stack on developers laptops is <em>flawed</em> no matter what size your company has. <br><br>  In fact, a similar approach to microservices is equivalent to creating a distributed monolith. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="940259898331238402"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  <sup>Prediction for 2020: monolithic applications are back in fashion after people have become familiar with the shortcomings of distributed monoliths.</sup> <br><br>  As <a href="https://twitter.com/tyler_treat">blogger</a> <a href="http://bravenewgeek.com/">Tyler Trit</a> notes: <br><br><blockquote>  He laughed heartily over the <a href="https://twitter.com/tyler_treat/status/846100896228544514">discussion of microservices on Hacker News</a> .  "Developers should be able to deploy the environment locally, everything else is a sign of bad tools."  Well, yes, of course, wise guy, try running 20 microservice units with different databases and dependencies on your MacBook.  Oh yeah, I forgot that docker compose will solve all your problems. <br><br>  Everywhere the same thing.  People begin to create microservices without changing their ‚Äúmonolithic‚Äù mentality, and this always ends in a real theater of the absurd.  "I need to run all this on my machine with the selected configuration of services in order to test a single change."  What happened to us ... <br><br>  If anybody, God forbid, accidentally sneezes, then my code will immediately become not testable.  Well, good luck to you with a similar approach.  Even despite the fact that large-scale integration tests affecting a significant number of services are an anti-pattern, it is still hard to convince others.  Switching to microservices means using the right tools and methods.  Stop using old approaches in a new context. </blockquote><br>  On the scale of the whole industry, we are still tied to the testing methodologies invented in an era far from us, which is strikingly different from the reality in which we are today.  People are still passionate about ideas like <em>full test coverage</em> (so much so that in some companies merge will be blocked if a patch or brunch with a new feature reduces the coverage of the code base with tests by more than a certain percentage), <a href="https://en.wikipedia.org/wiki/Test-driven_development">development through testing</a> and complete end-to-end system-level testing. <br><br>  In turn, such beliefs lead to the fact that large engineering resources are invested in the construction of complex CI pipelines and intricate local development environments.  Quickly enough, the support of such an expanded system turns into the need to contain a team that will create, maintain, troubleshoot and develop the infrastructure.  And if <a href="https://medium.com/netflix-techblog/towards-true-continuous-integration-distributed-repositories-and-dependencies-2a2e3108c051">big</a> <a href="https://engineeringblog.yelp.com/2017/04/how-yelp-runs-millions-of-tests-every-day.html">companies</a> <a href="https://medium.com/netflix-techblog/product-integration-testing-at-the-speed-of-netflix-72e4117734a7">can afford</a> such a deep level of sophistication, then all the rest is better to just perceive the testing as it is: this is the best possible verification of the system.  If we are wise in assessing the value of our choice and making compromises, this will be the best option. <br><br><h2>  Spectrum Testing </h2><br>  Traditionally, it is assumed that testing is done before release.  In some companies, there have been - and still exist - separate teams of testers (QA), whose main responsibility is to perform manual or automated tests for software created by development teams.  As soon as the software component passes through QA, it is handed over to the operation team for launch (in the case of services), or released as a product (in the case of desktop applications and games). <br><br>  This model is slowly but surely becoming a thing of the past - at least in relation to <em>services;</em>  as far as I can tell from startups in San Francisco.  Now the development teams are responsible for testing and for the operation of the services they create.  I find this new approach to creating services <em>incredibly</em> powerful ‚Äî it truly allows development teams to think about scale, goals, trade-offs and compensations across the <em>whole range</em> of testing methods ‚Äî and in a realistic manner.  In order to fully understand how our services function and to verify the correctness of their work, we obviously need the opportunity to choose the right subset of test methods and tools, taking into account the required parameters of availability, reliability and correctness of the service. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: absolute; visibility: hidden; display: block; transform: rotate(0deg);"></twitter-widget><blockquote class="twitter-tweet twitter-tweet-error" align="center" data-twitter-extracted-i1552382991497604066="true"><p lang="en" dir="ltr">  So many amens.  Testing pre-deploy is partially prep for testing in production.  It is a fact that it is not a problem. </p>  - Baron Schwartz (@xaprb) <a href="https://twitter.com/xaprb/status/942407784804638720%3Fref_src%3Dtwsrc%255Etfw">December 17, 2017</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  <sup>Just like with the language removed.</sup>  <sup>Testing before deployment is a partial preparation for testing in production.</sup>  <sup>To paraphrase your statement: testing before the deploem can teach, help to rehearse and strengthen the biased mental models of the system, and actually works against you in the lead, making you immune to reality.</sup> <br><br>  By and large, the concept of "testing" can cover several activities that traditionally belong to the areas of "release engineering", operation or QA.  Some of the methods listed in the table below are not strictly considered forms of testing ‚Äî for example, <a href="http://principlesofchaos.org/">the official definition of</a> <em>chaos engineering is</em> classified as an <em>experiment</em> form;  In addition, the above list is by no means exhaustive - it does not include vulnerability scanning ( <em>penetrability testing</em> ), <em>penetration testing</em> , <em>threat modeling</em> (simulation <em>modeling</em> ), and other testing methods.  However, the table includes all the most popular testing methods that we encounter daily. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd1/26d/f75/dd126df75911f817a53bd7cfca818ffc.png"><br><br>  Of course, the taxonomy of testing methods in the table below does not quite reflect reality: as practice shows, some testing methods can fall into both categories at once.  So, for example, ‚Äúprofiling‚Äù in it is referred to testing in production - however, it is often resorted to during development, so it can be attributed to testing in pre-production.  Similarly, shadowing - a method in which a small amount of production traffic is driven through a small number of test instances - can be considered as testing in production (we use real traffic) and testing in pre-production (it does not affect real users). <br><br>  Different programming languages ‚Äã‚Äãhave varying degrees of support for testing application in production.  If you are writing to Erlang, then it is quite possible that you are familiar with the <a href="http://erlang-in-anger.com/">leadership of Fred Hebert</a> on using virtual machine primitives for debugging production systems while they continue to work.  Languages ‚Äã‚Äãlike Go come with built-in support for profiling heaps, locks, CPU and gorutin for any of the running processes (testing in production) or when running unit tests (this can be qualified as testing in pre-production). <br><br><h2>  Production Testing - Replacing Pre-Production Testing? </h2><br>  <a href="https://medium.com/%40copyconstruct/monitoring-in-the-time-of-cloud-native-c87c7a5bfa3e">In my last article</a> I paid a lot of attention to testing in post-production, mainly in terms of observability.  Such forms of testing include monitoring, alerts, research, and dynamic instrumentation (inserting analyzing procedures into executable code).  It is possible that such techniques as <em>gating</em> and the use of function flags can also be included in production testing ( <em>feature flags</em> , with which you can enable / disable functionality in code using configuration).  User interaction and user experience evaluation ‚Äî for example, A / B testing and <a href="https://en.wikipedia.org/wiki/Real_user_monitoring">real user monitoring</a> also apply to production testing. <br><br>  In narrow circles, there is a discussion that such testing methods can replace traditional testing in pre-production.  Recently, a similar <a href="https://twitter.com/sarahmei/status/868928631157870592">provocative discussion</a> launched on Twitter by <a href="https://twitter.com/sarahmei">Sarah May</a> .  Of course, she immediately brings up several difficult topics in her, and I do not agree with everything in everything, but many of her comments correspond exactly to my feelings.  Sarah states the following: <br><br><blockquote>  Popular wisdom states the following: before releasing a code, the full set of regression tests should turn green.  You need to be sure that the changes do not break anything else else in the application.  But there are ways to verify this without resorting to a set of regression tests.  Especially now, with the flourishing of complex monitoring systems and understanding of the error rate on the operational side. <br><br>  With sufficiently advanced monitoring and large scale, writing a code becomes his realistic strategy, his ‚Äúpush‚Äù in the prod and monitoring the number of errors.  If as a result something in another part of the application breaks down, it will become very quickly understandable by the increased number of errors.  You can fix a problem or roll back.  Simply put, you allow your monitoring system to perform the same role as regression tests and continuous integration in other teams. </blockquote><br>  Many people perceived it as if it was worth removing testing before production as unclaimed, but I think the idea was not the point.  Behind these words is a fact that many software developers and professional testers cannot accept - only manual or automated testing can often be insufficient measures - to the extent that sometimes they <em>do not help us at all</em> . <br><br>  In the book " <a href="https://www.amazon.com/Lessons-Learned-Software-Testing-Context-Driven/dp/0471081124">Lessons Learned in Software Testing</a> " (there is no official translation into Russian, but there is an amateur one) there is a chapter called " <em>Automated Testing</em> ", in which the authors state that only a minority of bugs are found by automatic regression tests. <br><br><blockquote>  According to unofficial polls, the percentage of bugs that are detected by automated tests is surprisingly low.  Projects with a significant number of successfully designed automated tests report that regression tests are capable of detecting 15 percent of the total number of bugs. <br><br>  Automated regression tests usually help to detect more bugs during the development of the tests themselves than when performing tests at subsequent stages.  However, if you take your regression tests and find a way to reuse them in different environments (for example, on a different platform or with other drivers), then your tests are more likely to detect problems.  In fact, in this case they are no longer regression tests, since they are used to test configurations that have not been tested before.  Testers report that this kind of automated tests can find from 30 to 80 percent of errors. </blockquote><br>  The book certainly has become a bit out of date, and I have not managed to find any recent research on the effectiveness of regression tests, but the fact that we are so accustomed to the fact that the best testing practices and disciplines are based on the absolute superiority of automated testing, and any attempt to doubt leads to the fact that you are considered a heretic.  If I‚Äôve understood something for myself from several years of observing how services fail, then this is what testing before production is the best possible verification of some small set of system guarantees, but at the same time, it alone will not be enough for checks of systems that will work for a long time and with frequently changing load. <br><br>  Returning to what Sarah wrote about: <br><br><blockquote>  This strategy is based on numerous assumptions;  it is based on the fact that the team has a complex operating system, which most development teams do not have.  And that's not it.  It is assumed that we can segment users, display each developer‚Äôs change-in-process on a different segment, and also determine the error rate for each segment.  <strong>In addition, this strategy involves a grocery organization that feels comfortable when experimenting with "live" traffic.</strong>  Again, if the team is already producing A / B testing for changes in the product on live traffic, this simply extends the idea to changes made by the developers.  If you manage to do all this and get feedback on changes in real time - it will be just great. </blockquote><br>  Selection is mine, it seems to me, the largest block in the way of gaining greater confidence in the systems created.  For the most part, the biggest obstacle to moving to a more integrated approach to testing is the necessary shift in thinking.  The idea of ‚Äã‚Äãhabitual testing in pre-production is imparted to programmers from the very beginning of their career, while the idea of ‚Äã‚Äãexperimenting with live traffic is seen by them either as the prerogative of the operating engineers or as a meeting with something terrible like an alarm. <br><br>  All of us are accustomed from childhood to inviolable holiness of production, with which we are not supposed to play, even if it makes it impossible for us to check our services, and all that remains to our lot are other environments that are only pale production shadows.  Testing services in environments that are ‚Äúas similar as possible‚Äù to production is akin to a dress rehearsal - it seems to be <em>some</em> benefit from this, but there is a huge difference between the performance in the full hall and the empty room. <br><br>  Not surprisingly, this opinion was shared by many of the interlocutors of Sarah.  Her answer to them was as follows: <br><br><blockquote>  They write to me here: ‚Äúbut your users will see more errors!‚Äù This statement is straightforwardly composed of unobvious delusions - I don‚Äôt even know where to start ... <br><br>  Shifting responsibility for finding regressions from monitoring tests in production will result in users most likely generating more errors in your system.  This means that you cannot afford to take a similar approach without a corresponding change in your code base - everything should work in such a way that errors are less noticeable (and have a smaller effect) on your users.  In fact, this is a useful pressure that can help make your users' experience much better.  Some people write to me that ‚Äúusers will generate more errors‚Äù -&gt; ‚Äúusers will see more errors‚Äù -&gt; ‚Äúyou don't care about your users!‚Äù No, this is absolutely not true, you just think wrong. </blockquote><br>  Here it hits the very point.  If we transfer regression testing to post-production monitoring, then such a change will require not just a change of mindset, but also a willingness to take risks.  More importantly, a complete revision of the system design is required, as well as serious investments in advanced release engineering practices and tools.  In other words, here we are talking more than just about <em>architecture with regard to failures</em> - in fact, there is <strong><em>programming with regard to failures</em></strong> .  While the gold standard has always been programming software that runs smoothly.  And here the overwhelming majority of developers will definitely feel uncomfortable. <br><br><h2>  What to test in production, and what - in pre-production? </h2><br>  Since service testing is represented by a whole spectrum, <em>both</em> forms of testing should be taken into account during system design (and this implies both architecture and code).  This will make it possible to understand what system functionality will definitely need to be tested before production, and which characteristics of it, more like a long tail of <em>features</em> , should be investigated in production using appropriate tools and instruments. <br><br>  How to determine where these boundaries lie, and what testing method is suitable for a particular system functionality?  This must be decided together by development and operation, and, again, this <em>must be</em> done at the system design stage.  The top-down approach as applied to testing and monitoring after this stage has managed to prove its inconsistency. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-2" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="940421497666936832"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  <sup>Hiring a ‚ÄúSRE team‚Äù will not give additional reliability to your services.</sup>  <sup>The top-down approach to reliability and stability does not work ‚Äî a bottom-up approach is needed here.</sup>  <sup>To achieve these goals, you must believe in SWE instead of continuing to flirt with exploitation.</sup> <br><br>  <a href="https://twitter.com/mipsytipsy">Charity Majors</a> made a report last year at <a href="https://www.youtube.com/watch%3Fv%3D1wjovFSCGhE">Strangeloop</a> , where she said that the distinction between observability and monitoring comes down to ‚Äúknown unknowns‚Äù and ‚Äúunknown unknowns‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f40/014/ba6/f40014ba61047e63b9801d4bcb0d7261.png" alt="Report on Strangeloop in 2017"><br>  <em>Slide from Charity Majors report on Strangeloop in 2017</em> <br><br>  Charity rights - the problems listed on the slide are not what you would ideally want to monitor.  Similarly, these are not the problems that you would like to test in pre-production.  Distributed systems are pathologically unpredictable, and it is impossible to envisage all the possible quagmires of the swamp, which may contain various services and subsystems.  The sooner we reconcile with the fact that the very attempt to predict each way that a service can be performed, followed by writing a regression test case, is a foolish venture, the sooner we begin to engage in less dysfunctional testing. <br><br>  As Fred Hebert noted in his review of this article: <br><br><blockquote>  ... as a large service using many machines grows, the chances that the system will never be 100% efficient will increase.  There will always be a partial failure in it somewhere.  <strong>If tests require 100% performance, then please note - you have a problem.</strong> </blockquote><br>  In the past, I argued that ‚Äúmonitoring everything‚Äù is an anti-pattern.  Now it seems to me that a similar statement applies to testing.  You can not, and therefore <em>should not</em> try to test <em>absolutely everything</em> .  <a href="https://medium.com/%40copyconstruct/testing-microservices-the-sane-way-9bb31d158c16">The SRE book</a> states that: <br><br><blockquote>  It turns out that after a certain point, an increase in reliability affects the service (and its users), instead of making life better!  Extreme reliability has its price: maximizing stability limits the speed at which new functions are developed and the speed at which they are provided to users, and significantly increases their cost, which in turn reduces the number of functions that a team can implement and offer to users. <br><br>  Our goal is to find obvious boundaries between the risk that the service will take on and the risk that the business is ready to bear.  We strive to make the service reliable enough, but not more than what is required of us. </blockquote><br>  If you replace ‚Äúreliability‚Äù with ‚Äútesting‚Äù in the quote above, the advice from this will not cease to be less useful. <br><br>  However, it is time to ask the following question: <em>what is</em> better for testing before production, and what after? <br><br><h2>  Exploratory testing is not intended to be tested prior to production. </h2><br>  <a href="https://en.wikipedia.org/wiki/Exploratory_testing">Exploratory testing</a> is an approach to testing that has been applied since the 80s.  It is practiced mainly by professional testers;  This approach requires less training from the tester, allows you to find critical bugs and has shown itself <a href="https://en.wikipedia.org/wiki/Exploratory_testing">"more stimulating at the intellectual level than the execution of script tests</a> . <a href="https://en.wikipedia.org/wiki/Exploratory_testing">"</a>  I have never been a professional tester and have not worked in an organization that has a separate testing team, and therefore I learned about this type of testing only recently. <br><br>  In the already mentioned book ‚Äú <a href="https://www.amazon.com/Lessons-Learned-Software-Testing-Context-Driven/dp/0471081124">Lessons Learned in Software Testing</a> ‚Äù in the chapter ‚Äú <em>Think like a tester</em> ‚Äù there is one very sensible piece of advice that sounds like this: <strong>to test, you must research</strong> . <br><br><blockquote>  To test something properly, you need to work with it.  You have to figure it out.  This is a research process, even if you have the perfect description of the product.  As long as you do not explore this specification, scrolling through your head or working with the product itself, the <strong>tests you decide to write will be superficial.</strong>  Even after you study the product at a sufficiently deep level, you will have to continue the study for the sake of finding problems.       ,       ,         . <br><br>       ‚Äî      ,    .       ;   ,    ,        . </blockquote><br>          ¬´¬ª  ¬´¬ª, ,   ,    ,           ‚Äî  ,  <strong>     -   </strong> . <br><br>  ,          ,   ,            .       ,      : <br><br><blockquote>  ‚Äî   .   .        .   ,    .         .          . <br><br> <strong> </strong> :     ,    ,  ,    . <br><br> <strong> </strong> :    ,        ,    ,   ,      . <br><br> <strong> </strong> :       ,     ,  ,    ¬´ ¬ª,      . </blockquote><br> ,           ,     , ,    ,  ,   . ,    <em></em>             ;               . <br><br>    ,             ,    <em></em>  ,       - ,     .   ,           ,        ,          ,    ,        / . <br><br><blockquote>    ,            .      .        ,      ¬´¬ª     .     ,   ,       ,      . <br><br> <em> </em> </blockquote><br>                ,           .         ,        ‚Äî    ,         ‚Äî   ,         . <br><br> <a href="https://medium.com/%40copyconstruct/the-death-of-ops-is-greatly-exaggerated-ff3bd4a67f24">  ,     ‚Äî  </a> .       ,    ,   ‚Äî   .   , <a href="https://mechanical-sympathy.blogspot.com/">  ¬´¬ª</a> ,        ‚Äî     ,     . <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-3" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="945143593508904962"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br> <sup> 1000%,      .  ,  ,          (    , S3zure).       ‚Äî   .       ¬´¬ª,       Ops.     .</sup> <br><br>     ( !)   . ,     ;  - ,       ¬´   ¬ª. <br><br>   ,      : <br><br><ul><li>   <em></em> ; </li><li>   <em></em> ; </li><li>   . </li></ul><br><h2>    </h2><br>     ,       : <br><br><ul><li>    ,    ; </li><li>     0    ? </li><li>    ? </li><li>      ; </li><li>     <em>service discovery</em> ? </li><li>    ? </li><li>    ,    ; </li><li>    <em>graceful restart</em>  ; </li><li>   ‚Äî    ‚Äî  ; </li><li>    (,   , <em>event driven</em> ,   ,   ); </li><li>   -      (-    ). </li></ul><br>     ,               .   ,         -      . <br><br><h2>    </h2><br>          (    )     .   ,         , : <br><br><ul><li>         Consul (    ¬´ ¬ª,     ,       ); </li><li>  ,  RPC-   TTL; </li><li>     Confluent Python Kafka         Python; </li><li>       <a href="https://pgbouncer.github.io/config.html">pgbouncer</a> ,   (   LIFO)   ,         Postgres. </li></ul><br><h2>   </h2><br>  <em></em>         ,     : <br><br><ul><li>   <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)"> </a> ; </li><li>     ‚Äî , ,  ,    , ‚Äî      ; </li><li>     ,    ,       . </li></ul><br>     ,   ¬´   ¬ª (,   , ¬´ <em></em>  ¬ª)      . <br><br><h1>   - </h1><br> ,         ,        ‚Äî    . <br><br><blockquote> <strong>       .</strong>         .         ,    ,      ‚Äî        . <br><br> <em> </em> </blockquote><br>      ,  <em></em>      (   , ,       );  ,     ,    .      ,  ‚Äî   ,     ,           . <br><br> ,   ‚Äî , , ,  ‚Äî       ,         . <br><br><h3>     </h3><br>   ,      ‚Äî  <em>  </em>  ,     ‚Äî <em>  </em>   . <em></em>   -,  ,      ( , ,      ,     ),   ,  ¬´-¬ª   ,   ¬´-¬ª   . <br><br><h3>     </h3><br>         ,         ,       .    ,     ,   ,     ,     . <br><br>         ,    .   -     ,          .  ,     - ,       ,       ,      . <br><br>     ,              ,       . <br><br><h3> - </h3><br>       -   ,     ,         -   .             RPC-,       . <br><br>            ,              ,        ,       . <br><br>  ,   ()                ,         , -    . ,       (     JSON,       ,   ),           ,        -   . -            . <br><br>            ,       ¬´ <em>Succeeding with Agile</em> ¬ª (    ¬´Scrum.   ¬ª),       <a href="https://twitter.com/samnewman"> </a>    ¬´ <em>Building Microservices: Designing Fine-Grained Systems</em> ¬ª.      -,        ,      (  ),      UI (  end-to-end ).   ,      ,    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/821/d7e/172/821d7e172a8f00c8242ab0cebe294d9c.png" alt="Mike Cohn's Test Automation Pyramid"><br> <em>    </em> <br><br>       ,          .     ,       ,   . <br><br>   ,   ( ,  ,  )     - (  -),     stateful-     .   ,  ‚Äî   <em></em> ‚Äî        I/O ( <a href="https://medium.com/%40copyconstruct/nonblocking-i-o-99948ad7c957"> ,  </a> ),           . <br><br><h3>   I/O  </h3><br>  At PyCon 2016, <a href="https://twitter.com/Lukasaoz">Cory Bandfield</a> presented a <a href="https://www.youtube.com/watch%3Fv%3D7cC3_jGwl_U">wonderful report</a> where he argued that most libraries make the mistake of not separating protocol parsing from I / O ‚Äî which ultimately makes both testing and code reuse difficult.  This is indeed an extremely important idea, with which I absolutely agree. <br><br>  However, I believe that not all types of I / O can be considered equal.  Protocol development libraries, RPC clients, database drivers, AMQP clients, and others all perform I / O, but they all use different forms of I / O with different <em>rates</em> , which are determined by the limited microservice context. <br><br>  For example, let's take testing microservice, which is responsible for managing users.  In this case, it is more important for us to be able to check whether users have been successfully created in the database, rather than testing whether HTTP parsing works as it should.  Of course, a bug in the HTTP parsing library can be a single point of failure for this service, but at the same time HTTP parsing plays only a supporting role in the general scheme, and it is <em>secondary</em> to the main duty of the service.  In addition, the library for working with HTTP is the part that will be reused by all services (and therefore in this case, <em>fuzzing</em> can be of great benefit), it should become a <em>common abstraction</em> .  As you know, the best method to find a balance when working with abstractions (even the most "full of holes") is, albeit reluctantly, to trust the promised service contract.  Let such a decision be difficult to call an ideal way out, as for me, this compromise has every right to exist, if we are going to release at least something. <br><br>  However, when it comes to microservice itself, the abstraction, which it is in relation to the rest of the system, includes state transitions that are directly mapped to a certain part of the business or infrastructure logic, and therefore <em>this functionality</em> must be tested at the level of a sealed unit. <br><br>  Similarly, imagine that we have a network proxy server that uses Zookeper and service discovery to balance requests to dynamic backends;  in this case, it is much more important to be able to test whether the proxy can correctly respond to the watch trigger and, if possible, set a new control value.  This <em>is</em> exactly <em>what</em> unit is to be tested here. <br><br>  The meaning of all the above is that the <em>most important</em> unit of functionality of microservice is the abstraction underlying I / O, which is used to interact with the backend, and therefore should be <em>the same</em> sealed unit of basic functionality that we will test. <br><br>  The most interesting thing is that despite all this, the overwhelming majority of the ‚Äúbest practices‚Äù of testing such systems refers to the underlying I / O microservice not as an inseparable part, which also needs to be tested, but as an obstacle that needs to be eliminated with the help of .  Up to the point that <em>all</em> unit testing in our days has become synonymous with the active use of mocks. <br><br>  Unit testing of such a critical service for I / O with mocks is in essence a ‚Äúblocking‚Äù of testing services, because it sacrifices speed for accuracy and teaches us to think about the systems we create, the <em>opposite of</em> how they actually work. .  Here I would go further and say that unit testing with mocks (we can denote it by the term <em>‚Äúmock testing‚Äù</em> ) is for the most part a test of our incomplete, and most likely erroneous, mental model of the operation of critical business components of the system, on which we work, as a result of which we become hostages of one of the most insidious forms of bias. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-4" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="945830580029140992"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  <sup>I like the idea that mocking affects our thinking.</sup>  <sup>Moki behave predictably, but networks and databases do not.</sup> <br><br>  The biggest drawback of mocks as a <strong><em>testing</em></strong> tool is that when simulating a successful execution, as well as a failure, the mocks remain a programmer's mirage, never reflecting at least an approximate picture of the real world of production. <br><br>  Here, some will say that it is better to cope with this problem in another way: track <em>all possible failures</em> at the network level and add them to the test set with additional mocks, which will cover <em>all these test cases</em> that we previously ignored.  Well, besides the fact that considering all possible problems seems to be poorly possible, this approach is likely to lead to a bloated set of tests with a large number of different mocks that perform similar functions.  And in the end, all this in turn will lay a heavy burden on the shoulders of those who in the future will be engaged in supporting this good. <br><br>  If we are talking about support for tests, another weakness of mocks actively manifests itself here: they make the test code too detailed and difficult to understand.  From my experience, this is especially true when whole classes are converted into mocks, and the implementation of mocks is embedded in the test as a dependency only so that the mock can confirm that a particular class method has been called the nth number of times or with certain parameters.  This form of mocks is now actively used when writing tests to test the behavior of services. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-5" style="position: absolute; visibility: hidden; display: block; transform: rotate(0deg);"></twitter-widget><blockquote class="twitter-tweet twitter-tweet-error" align="center" data-twitter-extracted-i1552382991497604066="true"><p lang="en" dir="ltr">  It seems that it‚Äôs not a problem, it‚Äôs not so good.  This is the first rule of tautology club. <br><br>  Secondly, you multiply your codebase horribly.  Result: much harder to change. </p>  - Baron Schwartz (@xaprb) <a href="https://twitter.com/xaprb/status/946031837327036416%3Fref_src%3Dtwsrc%255Etfw">December 27, 2017</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  <sup>My synopsis of using mock objects in tests is that you‚Äôll end up testing implementation, not behavior, in almost all test cases.</sup>  <sup>This is stupid: the first rule of a tautology club is the first rule of a tautology club.</sup> <sup><br><br></sup>  <sup>In addition, you increase the size of your code base at times.</sup>  <sup>In the end, you will be much harder to make changes.</sup> <br><br><h3>  Reconcile with mocking </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8e4/af9/750/8e4af9750a00ebfb9526fde76ef89a65.png" alt="From the Google blog about testing, post about double objects"><br>  <em>From the Google blog about testing, post about double objects</em> <br><br>  Moki, stubs and fakes are all kinds of so-called " <em>test doubles</em> ."  Practically everything that I wrote before about moki is applicable to other forms of test twins.  However, let's not go to extremes and argue that moki (and their variants) do not contain any advantages;  similarly, not every unit test <em>should always</em> include I / O testing.  In unit tests, it makes sense to include I / O only when the test involves a <em>single</em> I / O operation without any further side effects that we should prepare for (this is the main reason why I don‚Äôt see much point in testing the subscription publications in a similar way). <br><br>  Consider the following topology of a very plausible example of microservice architecture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a5/517/37d/9a551737ddea82563cb802cb2107e27b.png"><br><br>  The interaction of service A with service B includes the communication of service B with Redis and service C. However, the smallest <em>unit</em> tested here is the <strong><em>interaction of service A with service B</em></strong> , and the easiest way to test this interaction is to deploy a fake for service B and test the interaction of service A with a fake .  <a href="https://docs.pact.io/">Contract testing</a> can be especially useful for testing such integrations.  Soundcloud <a href="https://speakerdeck.com/alonpeer/move-fast-and-consumer-driven-contract-test-things">is known for using contract tests</a> to test all of its 300+ microservices. <br><br>  Service A also communicates with Riak.  The minimum test unit in this case includes the <strong><em>actual message between service A and Riak</em></strong> , so it makes sense to deploy a local Riak instance for the duration of the test. <br><br>  When it comes to integration with third-party services like GCP, AWS, Dropbox or Twilio, ideally, the bindings or SDKs provided by vendors already have some good fakes that we can use in our test suite.  Even better, vendors offer the ability to make real API calls, but in test mode or in the sandbox, as this allows developers to test services in a more realistic manner.  These services include Stripe, which provides test tokens. <br><br>  So, we found out that test ‚Äútwins‚Äù deserve their place in our testing spectrum, but don‚Äôt dwell on them as the only means of unit testing or overdoing them. <br><br><h3>  The inconspicuous advantages of unit tests </h3><br>  Unit testing is not limited to the methods we discussed with you.  It would be an omission to start discussing unit tests and not talk about <a href="https://eax.me/scalacheck/">property-based testing</a> and fuzzing.  Popular with Haskell‚Äôs <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library (which was later ported to Scala and other languages) and the Python <a href="https://hypothesis.readthedocs.io/en/latest/">Hypothesis</a> library, <em>property-based</em> testing allows you to run the same test several times with different inputs without the need for a programmer to generate a fixed set of input data test case.  <a href="https://twitter.com/jessitron">Jessica Kerr</a> made an <a href="https://www.infoq.com/presentations/property-based-testing">excellent report</a> on this topic, and <a href="https://twitter.com/mononcqc%3Flang%3Den">Fred Hebert</a> even <a href="http://propertesting.com/">wrote a whole book on this topic</a> .  In his review of this article, Fred mentions various types of approaches to various tools for property-based testing: <br><br><blockquote>  Regarding property-based testing, I will say the following: most of the tools bring it closer to fuzzing, but if you try a little, you can conduct it in the manner of a white-box test with a more subtle approach.  In other words, if fuzzing consists in finding out whether a given part of the system ‚Äúfalls‚Äù or not, then property-based testing helps to check whether a certain set of rules or properties is always observed in the system.  There are 3 large families of property tests: <br><br>  - The <strong>Haskell QuickCheck family</strong> .  This variation is based on using type information to generate the data on which the test will be performed.  The main advantage: tests become less, and their coverage and usefulness - higher.  Disadvantage: hard to scale. <br><br>  - <strong>Erlang QuickCheck family</strong> .  This variation is based on dynamic data generators, which are composite functions.  In addition to the functionality of the previous type, stateful modeling primitives are available in such frameworks.  They look more like model checking, because instead of searching through a search, probabilistic searches are performed.  Accordingly, here we move away from fuzzing to the ‚Äúmodel checking‚Äù zone, which is a completely different family of testing methods.  I used to listen to the reports, the authors of which drove such tests to different cloud providers and used them to detect ‚Äúiron‚Äù errors. <br><br>  - <strong>Hypothesis</strong> : a unique approach to business.  It is based on a mechanism similar to fuzz ing, in which data is generated on the basis of a stream of bytes, which can become lighter / heavier on a scale of complexity.  It has a unique device and is the most applicable tool among those listed.  I'm not very familiar with the way the Hypothesis works under the hood, but this tool can do much more than its Haskell counterparts. </blockquote><br>  Fuzzing, on the other hand, allows you to feed in advance invalid and garbage input data to the application in order to make sure that the application terminates with a crash as planned. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d97/9e2/5c8/d979e25c86b2d4eeaf5b24106d16be8e.png"><br><br>  For fuzzing, there are a large number of different tools: there are fuzzers that are based on coverage, such as <a href="http://lcamtuf.coredump.cx/afl/">afl</a> , as well as the <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">address sanitizer</a> , <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm">thread sanitizer</a> , <a href="https://github.com/google/sanitizers/wiki/MemorySanitizer">memory sanitizer</a> , <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">undefined behavior sanitizer</a> and <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer">leak sanitizer</a> tools, and others. <br><br>  Unit testing can provide other benefits besides the usual verification that something works as intended for a particular input dataset.  Tests can act as excellent documentation for the API exposed by the application.  Languages ‚Äã‚Äãlike Go allow you to create <em>example tests</em> , in which functions that begin with Example instead of Test live alongside normal tests in the _test.go file in any of the selected packages.  These sample functions are compiled (and optionally executed) as part of the test suite of the package, and then displayed as part of the package documentation and allow them to run as tests.  The meaning of this, <a href="https://blog.golang.org/examples">according to the documentation</a> , is as follows: <br><br><blockquote>  This approach ensures that when the API changes, the package documentation will not become obsolete. </blockquote><br>  Another advantage of unit tests is that they put some pressure on programmers and designers in terms of API structuring, which would be easy for third-party services to work with.  A remarkable post ‚Äú <a href="https://testing.googleblog.com/2017/02/discomfort-as-tool-for-change.html">Discomfort as a means of motivating changes</a> ‚Äù was published on the Google blog about testing, which sheds light on the fact that the requirement from the authors of the API to provide its implementation in the form of fakes allows them to better understand those who will work with this API and reduce the number of pain in this world. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-6" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="939753801551978497"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  In 2016, I was a class organizing <a href="https://www.meetup.com/SFTwisted/events/past">Python Twisted</a> mitaps in San Francisco.  One popular topic for discussion was that it was a mistake to make the event loop in Twisted global (which Python 3 would later reproduce in the <a href="https://github.com/python/cpython/tree/3.6/Lib/asyncio/">asyncio</a> implementation, which would terrify the Twisted community) and how much easier testing and use would be if <a href="https://twistedmatrix.com/documents/10.1.0/core/howto/reactor-basics.html">Reactor</a> ( which provides basic interfaces for all types of services, including network interaction, flows, event scheduling, and so on) was transmitted to consumers as an explicit dependency. <br><br>  However, a reservation is required here.  As a rule, a good API design and good testing are two completely independent goals, and in reality (however, this is <em>not recommended</em> ) it is not difficult to design an incredibly convenient and intuitive API that lacks testing.  However, <em>much more often,</em> people design an API that tries to achieve 100% test coverage (no matter how you measure it, by code lines or otherwise), but it turns out to be a prematurely abstracted <a href="https://medium.com/%40copyconstruct/small-functions-considered-harmful-91035d316c29">DRY artifact</a> .  Although mock-based unit testing is the <em>way</em> to a good API design, it <em>does not guarantee</em> that your code will run properly. <br><br><h3>  VCR - we cache or repeat test responses </h3><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-7" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="944447330899521536"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  <sup>Excessive use of mocks / fakes / test twins / stubs is not the most reliable choice of testing techniques (although sometimes this does not go away), but when VCR-style caching comes into play, debugging non-passing tests becomes even harder.</sup> <br><br>  Given the general insecurity of mocks, I find it absolutely ridiculous for <a href="https://github.com/vcr/vcr">some individuals</a> to go even further to <em>write</em> answers as fixtures ( <em>test fixture</em> ).  I find this method ineffective, both as a way to accelerate integration tests (although they are integrational if such testing techniques are used) and in terms of accelerating <em>unit tests</em> .  Excessive overload of your brain while debugging failed tests with a heap of extra layers is not worth the time spent on it. <br><br><h2>  Integration testing </h2><br>  If unit testing with mocks is so unreliable and implausible, does this mean that integration testing is in a hurry for us to help and save us? <br><br>  Here is what I wrote on this issue in the past: <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-8" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="932406472444592128"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  <sup>This may sound too radical, but good (and fast) integration testing (local and remote) for a couple with good instrumentation often works better than the desire to achieve 100% test coverage.</sup> <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-9" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="932411403742228480"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  <sup>At the same time, large integration tests for each available service that interacts with ours do not scale very well.</sup>  <sup>It will be slow by default, and integration tests bring maximum benefit only when feedback from them can be obtained quickly.</sup> <sup><br></sup>  <sup>We need the best test patterns for distributed systems.</sup> <br><br>  Some readers of my Twitter have pointed out to me that these two statements of mine are in conflict with each other;  on the one hand, I urge to write more integration tests instead of unit tests, on the other hand I assert that integration tests do not scale well in the case of distributed systems.  These points of view are not mutually exclusive, and perhaps my first statement really requires a detailed explanation. <br><br>  The point here is not at all that unit-testing is <em>replaced</em> in this case by <em>end-to-end end-to-end</em> tests;   ,     ¬´¬ª,  ,          -  ,     ¬´ ¬ª,      . <br><br>          .   ,  ,   , <em></em>      I/O.   ,  <a href="https://en.wikipedia.org/w/index.php%3Ftitle%3DDistributed_transaction%26amp%3Boldid%3D808432393">  </a> ,       .    ,       Uber, , ,     ,  ,   ,    , ,   c  , : ¬´    ¬ª. ,          ,   <em></em>    ,  ,          ,     . <em></em> ,   ,  -. <br><br> <a href="https://www.confluent.io/blog/event-sourcing-cqrs-stream-processing-apache-kafka-whats-connection/">Event Sourcing</a> ‚Äî  ,       Kafka.       ( <em>Command and Query Responsibility Segregation</em> ) <a href="https://www.infoq.com/news/2016/04/event-sourcing-anti-pattern">    -</a>      10 .        ( <em>writes</em> )    ( <em>reads</em> ).              ,   ,      <em></em>  ,            . <br><br>              ,           ,      ,   ,          (,  ,   ). <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-10" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="942302741451259905"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br> <sup>        ;       ,      .</sup> <br><br>                 ,  / .           ¬´¬ª   ,      ¬´¬ª  (   )     ,        .   ,             . <br><br> ,          ,     ,   .    ¬´  ¬ª. <br><br><h3>    </h3><br>      ,        ,   .   , -      (  I/O      <a href="https://martinfowler.com/bliki/BoundedContext.html"> </a> ),         ,      ‚Äî   .           : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5e/08a/230/b5e08a23078231b538a71296c65dfae9.png" alt="    "><br> <em>    </em> <br><br>  ,        ,       ,           (       ,   observability      ). ,    ‚Äî       ;  ,   ,     <em> </em> ‚Äî     ,    ,  <a href="https://stackshare.io/imgix/how-imgix-built-a-stack-to-serve-100000-images-per-second"> </a> . ,                ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/f8d/a79/7eef8da7916d204f95ab5c1b8c248dcf.png"><br><br>     ,      ,    ,    ,         .    Consul   .        ‚Äî  API- (  )     ,      G      <em></em> . <br><br>   ,  <em></em>        Macbook     API,    ( ,    ).                   .  ,  ,      ,     ,    ,     . <br><br><h3> -     </h3><br>  80%    API      MongoDB,    -       MongoDB.  E ‚Äî     LuaJIT,   ,     ,      API.       E  ,       <a href="https://www.consul.io/docs/agent/watches.html"> (watch)  Consul</a> ,     -     Consul,    ,   ¬´¬ª ,   .             -,     . <br><br><h3>        </h3><br>    G, H, I  K (   ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb0/a84/b4d/bb0a84b4d54af58fb3182a6f39f33e71.png"><br><br>  G ‚Äî    Python,      Kafka   ,   ,      H, I  K.  G      ,   H, I  K,       - 15-20   G (    7).    G ‚Äî    ,  ,      Kafka,    H, K  I. <br><br> H, K  I ‚Äî   .  H ‚Äî   nginx ( , <a href="https://openresty.org/en/">Openresty</a> )     (    ),       ,    LevelDB   <em>write through cache (          )</em> ,   MySQL,  , <a href=""></a>  <a href=""></a>   Go.  K ‚Äî  HAProxy,   I ‚Äî  HTTP- LuaJIT.   ,   H, I  K     Kafka.   ,       <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25BE%25D0%25B3%25D0%25B0%25D1%258F_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C"> </a> . <br><br>      :      <em></em>  (eventual consistency)  ? <br><br> ,    ,  <strong><em></em></strong>  ,   <em></em>     end-to-end ,          Kafka   G,       H, I  K   .  ,    ¬´ ¬ª,         ,    , : <br><br><ul><li>  K ‚Äî  HAProxy ( <a href="https://www.haproxy.com/blog/truly-seamless-reloads-with-haproxy-no-more-hacks/">        HAProxy      </a> ) </li><li>  H     ( )    <em> </em> ,   -             .  ,      ,    - nginx  H       .     H    ,   - nginx <em> </em>   ¬´¬ª   , -           ,  <a href="https://habrahabr.ru/post/260065/"></a>       ¬´ ¬ª: </li></ul><br><blockquote>      ,       NGINX   ,    . </blockquote><br>  ,     HTTP2,   ¬´¬ª        , ,    ,            nginx    .  ,       H, I  K ‚Äî  ,         . <br><br>       ,        ,        <em></em>  .   ,      <em></em>      ,  -  ,                  . <br><br><h3>     Service Meshes </h3><br>   ,          <em>service meshes</em> ‚Äî  ,        ,    ¬´¬ª  .          staging   staging  (     ,    HTTP-      ,    IP-  ),         <em></em>    <em> </em> ,   .         -        . <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-11" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="946515427676397568"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br> <sup> ,     ¬´¬ª       ‚Äî    .   ,  Facebook      . <a href="https://t.co/zMrt1YXaB1">https://t.co/zMrt1YXaB1</a> <br>  Service Meshes      .</sup> <br><br> ,      ,    . .,    ,    ¬´¬ª         ‚Äî        . <br><br>        ,            .               ,        .  ,     <em>  </em>    ,        ,            ,         . <br><br><h2>  Conclusion </h2><br>                 .        ,           ,     ,        ,     ( ,       ),      .  ,                . <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-12" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="942945824937459712"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br> <sup>    ¬´¬ª,     . ¬´¬ª     .       !</sup> <br><br> ,    ,  ,     ¬´ ¬ª     .         . <br><br>   ,   ‚Äî       ,    ‚Äî   ,     . <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We love such large-scale conceptual discussions, especially seasoned with our own examples, because not only individual developers, but almost all project teams are involved in solving such issues. </font><font style="vertical-align: inherit;">We invite experts, whose experience already allows us to discuss philosophical questions of software development, </font></font><a href="http://speakers.ritfest.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to speak</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at </font></font><a href="http://ritfest.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RIT ++ 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/349632/">https://habr.com/ru/post/349632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349622/index.html">Five reasons to like Flutter.</a></li>
<li><a href="../349624/index.html">Python, Delphi and C ++ through the eyes of a scientist</a></li>
<li><a href="../349626/index.html">From small to large: How to choose a trade scales for the store</a></li>
<li><a href="../349628/index.html">Nvidia shares rose by 1150% over three years: why is this not the limit</a></li>
<li><a href="../349630/index.html">Vulnerabilities in your application</a></li>
<li><a href="../349634/index.html">Community help needed. "Peace, friendship, chewing gum"</a></li>
<li><a href="../349636/index.html">Manage application state without template code and magic</a></li>
<li><a href="../349638/index.html">‚ÄúOf course, it‚Äôs risky, but you can use it with proper precautions‚Äù: Chris Talinger on Graal</a></li>
<li><a href="../349640/index.html">Mosdroid Avito - Announcement</a></li>
<li><a href="../349642/index.html">DEV Labs 2018. Online conference for Java developers. March, 3rd</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>