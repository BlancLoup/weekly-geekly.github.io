<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a driver for a homemade USB device</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The purpose of this article is a step-by-step demonstration of the process of developing the entire set of software necessary for organizing the conne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a driver for a homemade USB device</h1><div class="post__text post__text-html js-mediator-article">  The purpose of this article is a step-by-step demonstration of the process of developing the entire set of software necessary for organizing the connection of an improvised device with a computer via USB. <br><br>  At the moment, most radio amateurs implement this type of connection using USB to RS232 adapter chips, thus organizing communication with their device through the virtual COM port driver supplied with the adapter chip.  I think the drawbacks of this approach are clear.  This is at least an extra chip on the board and the limitations imposed by this chip and its driver. <br>  I would like to highlight the whole process of organizing such an interaction, as it should be done, and how it is done in all serious devices. <br>  In the end, now the 21st century, the USB module is in almost all microcontrollers.  This article will be about how to quickly use this module. <br><a name="habracut"></a><br>  Since we need the device itself to demonstrate the process of writing a USB device driver, we‚Äôll select one of the most popular debugging boards available in Russia.  I have this board manufactured by OLIMEX model LPC-P2148.  The board is based on the NXP ARM7TDMI microcontroller LPC2148 microcontroller.  All information on the board can be obtained on the manufacturer's website at the following <a href="http://olimex.com/dev/lpc-p2148.html">link.</a>  This is how it looks. <br><br><img src="http://olimex.com/dev/images/ARM/LPC/LPC-P2148.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The choice of the controller and the debug board is absolutely not important.  the process of developing the interaction between the OS on a personal computer and the board itself does not depend on it.  The microcontroller firmware development environment will be using KEIL version 4.23, which is also not critical.  As a result, it is planned to implement only BULK transfer type.  We will read the data array from the device to the computer, and we will transfer the state of the LEDs to the device so that it can be seen that the board responds to our commands. <br><br>  For convenience of understanding, we will divide further actions into stages and we will go through them in order. <br><br>  1. Adaptation of a ready-made example of a USB device under our board in order to make sure that the board is working and the USB channel is also operational.  It will be like our starting point. <br>  2. Change the firmware of the board so that it becomes an unknown device for Windows, requiring the manufacturer's driver. <br>  3. Adaptation of the basic template, the empty driver so that Windows can correctly install it, to service our device. <br>  4. Implementation of driver interaction with the user application. <br>  5. Writing a Windows console application to work with our driver, and therefore a connected USB device. <br>  6. Filling the entire system with necessary functions. <br><br>  That in this article will not be.  I will not describe the mechanisms of the OS, allowing you to find and install the correct driver.  There will be no description of how to assemble the firmware in the KEIL environment.  There will be no description of the parameters of the USB descriptors and in general there will be practically nothing to say about how the firmware works.  At the end, I will provide links to all sources of information, my source codes and compiled binary files.  Thus, the description of any moment not covered by this article can be easily found from the indicated sources.  Understand correctly, it is impossible to fit in one article detailed information on all these topics.  Moreover, there are more competent sources. <br><br><h5>  1. Adaptation of the RTX_Memory example to the OLIMEX LPC-P2148 board </h5><br>  The basis of the firmware to our project, we take the example of RTX_Memory supplied with KEIL.  This example, when it is successfully launched, will allow us to connect our board to a computer and it will be visible there as a regular USB flash drive.  In this way, we will get the firmware that deliberately correctly configures the USB module and all the peripherals necessary for the processor. <br><br>  The project is located in the folder ARM \ Boards \ Keil \ MCB2140 \ RL \ USB \.  The paths hereinafter I will indicate relative to the main folder where the KEIL environment is installed. <br><br>  Copy the project to a separate place, load it into KEIL and collect it.  Gathering without mistakes.  As a result, we received a HEX file that we can flash using the FlashMagic utility. <br>  True, you can not flash it yet, as it is obvious that it will not work on our board. <br>  If we compare the scheme of our board and the board for which the example is written, and this is the model MCB2140 made by KEIL, then we can see differences in the connection of the D + pull-up line. <br>  On the MCB2140 board, it is always pulled up to 3.3V, and on the LPC-P2148 this microcontroller controls this pull-up through a transistor. <br><br>  Schemes of both boards are available on <a href="http://www.olimex.com/">www.olimex.com</a> and <a href="http://www.keil.com/">www.keil.com,</a> respectively. <br><br>  For simplicity, we will slightly change the initialization code so that our board always turns on the D + line pull-up, which will be reported by the USB_LINK LED. <br>  In the USB_Init () procedure, we disconnect the CONNECT line from the USB module and manage it ourselves.  And since there is also a USB_LINK LED on the same transistor, when we turn it on, the D + line pull-up will automatically turn on. <br><br>  In addition, our board has fewer LEDs than the MCB2140.  Therefore, their purpose also needs to be redefined.  At this stage, I reassigned them simply to indicate read / write processes. <br>  Since we do not have LED_CFG and LED_SUSP indicators, we comment out their use everywhere according to the project code. <br>  Now you can build a project and flash it into the controller.  By connecting the board to the computer, it can be seen that it recognizes it as an external drive and another disk with a size of only about 25 KB appears in the system and with the readme.txt file. <br><br>  At this stage can be considered complete. <br><br><h5>  2. Transition from a USB drive to a unique device. </h5><br>  At the moment we have a device that on any computer with any OS will be recognized as an external USB drive.  But we need Windows not to know how to work with our device and require a driver.  The fact that the connected device belongs to the class of drives is indicated by the Interface class parameter located in the interface descriptor. <br><br>  If you open the file usbdesc.c and find there this parameter, then it will be seen that it has the value USB_DEVICE_CLASS_STORAGE. <br><br>  Replace it with USB_DEVICE_CLASS_VENDOR_SPECIFIC, and replace the two fields with zeros. <br>  Now, after rebuilding the project and flashing the board, we will see that Windows no longer knows that our device is a drive and needs to provide a suitable driver. <br><br>  There may be a problem.  The fact is that Windows, having remembered the VID and PID of our device the previous time, as related to an external storage device, can continue to install its driver on it without paying attention to the fact that the device class has changed.  The solution is simple.  If the board is still detected as a drive, locate it in the USB branch of the device manager and remove the driver manually.  After that, the OS should start asking for the driver. <br><br><h5>  3. Create a basic driver. </h5> <br>  So, we have a working USB device for which you need to provide a driver. <br>  To begin, we will write the simplest driver that will not do anything useful, except to boot into the system when our device appears on the USB bus.  The driver will have a minimum code to just correctly boot and unload the system. <br><br>  To write the driver we will be the most minimalist method.  The code itself will be edited in Notepad, and will be collected on the command line. <br><br>  First, you need to download the driver development kit from the Microsoft website.  It is called Windows Driver Kit.  I am using the WDK version 7600.16385.1. <br><br>  After installation, we get a lot of examples, the environment for the assembly and documentation.  In the start menu, you need to find the WDK section and there Build Environments.  This is the so-called environment for the assembly.  In fact, they provide us with a console that is already configured to assemble drivers for the desired system. <br><br>  You can see that there is a separate folder for each OS, where there is a pair of Checked and Free environments.  The first for the so-called Checked systems, collects the driver with additional information useful for debugging. <br>  The second collects the driver release, which is then used. <br><br>  I will use further the x86 Checked Build Environment from windows XP.  This will give me a universal driver that works correctly on systems from Windows XP and later. <br><br>  Now let's look for a template with which it would be most convenient to start. <br><br>  The most suitable candidate was an example of a certain OSR USB-FX2 learning kit.  I absolutely have no idea what kind of board this is, but the example we need is in the WDK along the path src \ usb \ osrusbfx2 \.  The most interesting thing is that this is not just an example, but step-by-step training on how to make a driver for this board.  Just what we need.  Let's go deeper into the kmdf \ sys directory and see that there are all the steps and are in daddies.  You can read more about them in the example description in the osrusbfx2.htm file. <br><br>  Here I will make a small digression to make the following actions more understandable. <br>  The fact is that since the advent of Windows NT, something has changed in the process of writing a driver.  In those days, we had to directly use the functions of the OS kernel and often, just to make a dummy able to load, unload, respond to PNP events, etc.  basic functions, it was necessary to study a lot of things and more than once fly out to BSOD.  Then Microsoft made a model that Windows Driver called and which introduced some kind of standard or something, what the driver should look like.  Much relief, I personally did not feel this.  And the next step was a framework called the Windows Driver Framework.  And thanks to this, life has become much easier.  Now the framework assumes the implementation of all the basic actions necessary to serve the main events, and we will only have to add the functions we need in the right way.  This is the technology that we will use. <br><br>  We start with the first step.  Launch x86 Checked Build Environment and use the ‚Äúcd‚Äù command to move to the WinDDK \ 7600.16385.1 \ src \ usb \ osrusbfx2 \ kmdf \ sys \ step1 \ folder. <br><br>  Run the build -ceZ command. <br><br>  The build process takes place, and as a result, the objchk_wxp_x86 folder is created (its name depends on the selected environment), where we find the file with the sys extension.  This is our driver.  To install it, we need an INF file.  Find it in the final folder of the same project.  It is called osrusbfx2.inf.  The only problem is that it is designed for a fee from the example.  In order for this file to be able to install the driver for our board, we simply change the VID and PID values ‚Äã‚Äãfor those that are written in the USB device descriptor in the usbdesc.c file.  After looking through the INF file, you will notice that the WdfCoInstaller01009.dll file is still required to install the driver.  It is also in the WDK delivery. <br><br>  So, we copy three files into a separate folder: compiled SYS, INF, WdfCoInstaller01009.dll. <br><br>  We connect our board to the computer, and when we ask Windows about the path to the driver, we indicate this folder. <br><br>  We observe the usual process of copying driver files and our device appears under the Sample Device class in the device manager.  Everything, the operating system is satisfied! <br><br>  And here a question may arise, and how do we even know that our code is executed.  In other words, I would like to get some kind of feedback from the driver.  That's right, the time has come to add debug information to the driver in order to understand what is happening. <br><br>  In kernel mode, the KdPrint () function displays debug information.  Its use is the same as the well-known printf ().  To see its output, you need to install the DbgView program.  It is available on the Microsoft website at <a href="http://technet.microsoft.com/en-us/sysinternals/bb896647">http://technet.microsoft.com/en-us/sysinternals/bb896647</a> .  Just keep it running and you will see the output of all debug information from the kernel mode of the OS.  I usually set up a filter to display only the messages of the module I need.  In my version of Step_1, I added the output to the DeviceEntry () and DeviceAdd () procedures so that it simply writes which function was invoked.  By connecting and disconnecting the board, in the DbgView window you can clearly see in what order this happens. <br><img src="https://habrastorage.org/storage2/57e/da3/375/57eda33750d6f5020c6dcdfd88c67dc9.jpg"><br><br><h5>  4. Interaction between kernel and user modes. </h5><br>  As you know, device drivers work in kernel mode (with some exceptions), and our applications are in user mode.  For interaction, the same mechanism is used as for working with files.  In other words, for each connected device in the system there is a symbolic name by which it can be opened as a regular file.  Well, then use the usual procedures for working with files of type ReadFile () and WriteFile ().  In this part, we will add functionality to our driver that allows it to open, close, write and read data from it. <br><br>  We will save the recorded data so that we can later give them away during a read operation. <br><br>  The first thing to do is register your callback function for the EvtDevicePrepareHardware event, which the PnP manager will call after the device goes into the uninitialized D0 state and before it is available to the driver.  In essence, this means a very simple thing, we stuck the device, the driver booted up, but maybe your device requires some setup before it becomes possible to work with it.  This is the kind of setup we will do in this event.  When applied to USB, at least you need to select the desired configuration.  So, we register our function.  To do this, add the following code to the DriverEntry: <br><br> <code>WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&amp;pnpPowerCallbacks); <br> pnpPowerCallbacks.EvtDevicePrepareHardware = EvtDevicePrepareHardware; <br> WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &amp;pnpPowerCallbacks); <br></code> <br><br>  The second.  If you pay attention to the call to the WdfDeviceCreate procedure from the driver code of the previous paragraph, you will notice that the second parameter of this procedure is passed to the constant WDF_NO_OBJECT_ATTRIBUTES.  This means that the device object has no attributes.  But in real life we ‚Äã‚Äãneed at least one attribute.  This is the so-called device context.  Simply put, this is some kind of structure that refers to a specific instance of the device supported by the driver, and will be further available to us almost anywhere in the driver.  For example, it may contain some kind of buffer.  And it binds to the device object, not the driver.  Several identical devices may be connected to the computer, which will be served by the same driver, but they will all have their own device object. <br><br>  So, we will create a context structure, and initialize it, the attribute parameter, which is passed on to WdfDeviceCreate: <br><br> <code>typedef struct _DEVICE_CONTEXT { <br> WDFUSBDEVICE UsbDevice; <br> WDFUSBINTERFACE UsbInterface; <br> WDFUSBPIPE BulkReadPipe; <br> WDFUSBPIPE BulkWritePipe; <br> } DEVICE_CONTEXT, *PDEVICE_CONTEXT; <br> WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(DEVICE_CONTEXT, GetDeviceContext) <br> <br> WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&amp;attributes, DEVICE_CONTEXT); <br></code> <br><br>  Third.  Now you need to create an interface through which the driver will be available to user-mode programs.  Previously, the programmer himself had to hard-write the name by which access to the device could be opened through the procedure CreateFile.  Now everything is easier.  We only need to create an interface by calling one procedure, and to identify it we use the generated GUID.  Next, in user mode, we will use the same GUID to get the name of the device file.  So, here is our GUID and code linking it to the interface: <br><br> <code>DEFINE_GUID(GUID_DEVINTERFACE_OSRUSBFX2, // Generated using guidgen.exe <br> 0x573e8c73, 0xcb4, 0x4471, 0xa1, 0xbf, 0xfa, 0xb2, 0x6c, 0x31, 0xd3, 0x84); <br> // {573E8C73-0CB4-4471-A1BF-FAB26C31D384} <br> <br> status = WdfDeviceCreateDeviceInterface(device, <br> (LPGUID) &amp;GUID_DEVINTERFACE_OSRUSBFX2, <br> NULL);// Reference String <br></code> <br><br>  Last thing.  In the first paragraph, we registered the procedure that handles the EvtDevicePrepareHardware event.  Now you need to write it.  I will not rewrite its text in the article, I think it will be easier to look at the source code.  I can only say that in this procedure, we prepare everything that is needed for the subsequent work of the driver with the connected device.  Specifically, we create a USB device object, select the desired configuration, and save in the context of the device the channel identifiers related to the BULK endpoints of the interface implemented in the device.  We will need these identifiers later to implement the data transfer.  For clarity, I added the output of the parameters of the channels in DbgView.  It can be noted that their parameters are nothing but the same values ‚Äã‚Äãthat we entered in the endpoint descriptors in the usbdesc.h file of the firmware. <br>  So, now you can rebuild the driver again, and update it in the system.  At the moment, our driver can no longer just be loaded.  He is already able to configure the connected device, and, most importantly, has become available for programs from user mode. <br><img src="https://habrastorage.org/storage2/b95/5a5/e7b/b955a5e7b7e7f9289d5c869a60c788e9.jpg"><br><br>  5. We work with the driver from user mode. <br><br>  Now we will write a simple console program that will only try to access our driver.  As you remember, at the moment our driver is not able to do anything else, except to give an opportunity to gain access to himself. <br><br>  Working with devices reduces to opening them as a regular file, and writing and reading data using the usual WriteFile and ReadFile procedures.  There is also a very useful procedure DeviceIoControl for organizing interaction with the driver, which is beyond the format of working with files, but we will not use it.  The file opens with a normal call to CreateFile, only we need the file name.  And here we have the GUID that we tied to the driver interface.  I will not describe the entire procedure for obtaining a name via the GUID, and I honestly admit that I completely took it from the examples of the WDK.  The GetDevicePath procedure gets the GUID and returns the full path to it. <br><br>  The file is open.  Add a couple of calls that will write and count from the file a dozen bytes. <br><br>  But back to our driver.  In the user program, we already write to the driver and read from it, but the driver code itself knows nothing about it.  Correct the situation. <br><br>  The logic here is the same as with EvtDevicePrepareHardware.  We need to register callback functions that will be called when the procedures for reading from the driver or writing to it occur.  This is done in EvtDeviceAdd.  It is necessary to initialize the I / O queue, fill its fields with pointers to our callback functions and create it by hooking it to the device object.  Go: <br><br> <code>WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&amp;ioQueueConfig, <br> WdfIoQueueDispatchParallel); <br> <br> ioQueueConfig.EvtIoRead = EvtIoRead; <br> ioQueueConfig.EvtIoWrite = EvtIoWrite; <br> <br> status = WdfIoQueueCreate(device, <br> &amp;ioQueueConfig, <br> WDF_NO_OBJECT_ATTRIBUTES, <br> WDF_NO_HANDLE); <br></code> <br><br>  In addition to declaring read and write procedures, you need to remember to implement them.  At this stage, I just put the stubs that display the transferred data in DbgView and give an array of 10 bytes when reading.  You can see their code in the source code.  There is nothing interesting, but I advise you to pay attention to working with memory.  It is necessary to receive buffers according to certain rules.  Our data moves between the kernel and user modes.  The screenshot clearly shows how we send data to the driver and it appears in the DbgView window.  Then we read the package from the driver and get it in the output of the console application. <br><img src="https://habrastorage.org/storage2/776/532/a16/776532a16fff3ecfb0a917fcc2301dcd.jpg"><br><br>  6. Making the driver useful. <br><br>  So it's time to make our driver useful.  At the moment it is communicating with the user mode but does not work with the real device.  And all that remains for us to do is to add a code in the procedure for recording, which sends data to the device, and in a reading procedure, a code that receives data from the device.  In the source code, you can see how the procedures serving I / O in the driver have changed very slightly.  We just transfer our buffers further to the USB kernel subsystem, and it will do everything as it should. <br>  Before we begin the actual transfer of data between the PC and the device, we still need to change the firmware of the device so that it somehow reacts to our data. <br><br>  Let's change a little the code in processing the data reception event so that if the first received byte is 0x01, then we turn on LED_1, and if it is 0x02, then we turn on LED_2.  And since  After writing to the device, we immediately read 10 bytes from it, then add this code too.  Please note that we send the packet for transmission in the event of processing the incoming packet.  This is a feature of the USB module.  We need to give him the data for transmission in advance so that he can execute the IN transaction.  And for clarity, we will pass two different arrays.  Change the contents of MSC_BulkOut () as follows: <br><br> <code>void MSC_BulkOut (void) { <br> <br> BulkLen = USB_ReadEP(MSC_EP_OUT, BulkBuf); <br> <br> LED_Off( LED_RD | LED_WR ); <br> if( BulkBuf[ 0 ] == 0x01 ) <br> { <br> USB_WriteEP( MSC_EP_IN, (unsigned char*)aBuff_1, sizeof( aBuff_1 ) ); <br> LED_On( LED_RD ); <br> } <br> else <br> if( BulkBuf[ 0 ] == 0x02 ) <br> { <br> USB_WriteEP( MSC_EP_IN, (unsigned char*)aBuff_2, sizeof( aBuff_1 ) ); <br> LED_On( LED_WR ); <br> } <br> } <br></code> <br><br>  And in the MSC_BulkIn () procedure, we will comment out all the code, leaving it completely empty. <br><br>  The result of the entire bundle you see in the screenshot. <br>  In this case, the board itself blinks with two LEDs. <br><img src="https://habrastorage.org/storage2/19b/e70/dc0/19be70dc0b94323b4f90b82728ba3aea.jpg"><br><br>  That's all.  We wrote a firmware and a full-fledged driver for our own USB device.  If you start the transfer in blocks of 4kb, you can achieve a speed of 800 KB / s. <br>  As you can see, the driver text is quite simple and contains only about 250 lines. <br><br>  In the article I described only the main steps that need to be taken to get a workable driver.  More information on the procedures used must be read in the WDK.  Moreover, now this documentation has become quite pleasant to read and they are replete with examples. <br><br>  The full archive with source codes can be downloaded <a href="https://drive.google.com/open%3Fid%3D0B2HsaihVA2zMVGoyYmFuNGF3Ync">here.</a> <br>  The archive contains folders named for items, each containing the final result, which we achieved in the corresponding item. <br><br>  I hope the article turned out to be unlike the ‚Äúhow to draw an owl‚Äù guide, and someone will be useful. </div><p>Source: <a href="https://habr.com/ru/post/139593/">https://habr.com/ru/post/139593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139588/index.html">How to choose a moment to send a letter</a></li>
<li><a href="../139589/index.html">The whole truth about vertical scaling in PaaS and why you are overpaying for regular hosting</a></li>
<li><a href="../139590/index.html">How to convert Debian Wheezy (or newer) system to btrfs</a></li>
<li><a href="../139591/index.html">Creating a DAG Cluster on Mailbox Exchange Servers</a></li>
<li><a href="../139592/index.html">How I assembled my dd-wrt mod for ASUS RT-N13U</a></li>
<li><a href="../139594/index.html">Cebit 2012. Day Two - Blackberry, Archos, MSI, Gigabyte</a></li>
<li><a href="../139596/index.html">Workshop on using Schuhart control charts</a></li>
<li><a href="../139597/index.html">Published a stop list of zones. RF and .RU</a></li>
<li><a href="../139598/index.html">Apple event March 7, 2012 - New iPad and new Apple TV, iOS 5.1, iPhoto</a></li>
<li><a href="../139601/index.html">STM32F1xx - Developer Tools and FreeRTOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>