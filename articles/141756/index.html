<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing Python code using Flex and Bison</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 For about two years I have been participating in the SourceAnalyzer OpenSource project, and now I have to write a parser for the Python...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing Python code using Flex and Bison</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  For about two years I have been participating in the <a href="http://sourceanalyzer.org/">SourceAnalyzer</a> OpenSource project, and now I have to write a parser for the Python language, which should be able to build a call graph (Call Graph) and a class dependency graph (Class Graph Dependency).  More precisely, the graph is constructed using other tools, and the parser only needs to prepare data for these tools. <br><br>  The process of working on the parser was quite entertaining and I would like to share with you the experience gained, as well as tell about some of the pitfalls that met during the development phase. <br><a name="habracut"></a><br><h2>  Terminology </h2><br>  If you have already worked with grammars and know how the compiler works, feel free to step into the next paragraph, the rest is Welcome. <br><br>  The parser development process was divided into two main components: <br><ul><li>  Analysis of the input stream and splitting it into tokens (Lexical analysis) </li><li>  Parsing tokens by a set of syntax rules (Parsing) </li></ul><br>  Let's look at a little example.  Let there is an expression (or input data stream): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre> <br><br>  Construct the rules for converting the input stream: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-9</span></span>]* -&gt; NUMBER + -&gt; PLUS * -&gt; MULT</code> </pre> <br><br>  Thus, after lexical analysis we get: <br><pre> <code class="cpp hljs">NUMBER(<span class="hljs-number"><span class="hljs-number">3</span></span>) PLUS(+) NUMBER(<span class="hljs-number"><span class="hljs-number">4</span></span>) MULT(*) NUMBER(<span class="hljs-number"><span class="hljs-number">15</span></span>) EQUAL(=)</code> </pre> <br><br>  The following is an example of a grammar, with the help of which you can later parse the expression using the rules: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>: NUMBER | <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> sign <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> sign: PLUS | MULT * / \ + <span class="hljs-number"><span class="hljs-number">15</span></span> / \ <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><br>  In this example, <code>NUMBER, MULT, PLUS</code> - by definition, terminals, or tokens, defined at the lexical analysis stage.  <code>expr, sign</code> are not terminals, since they are constituent units. <br><br>  This introduction is not in any way exhaustive, therefore the theory should be addressed to the book Flex &amp; Bison O'Relly. <br><br><h2>  Grammar </h2><br>  The full grammar for the Python language (version 2.5.2) can be found here: <br>  <a href="http://docs.python.org/release/2.5.2/ref/grammar.txt">http://docs.python.org/release/2.5.2/ref/grammar.txt</a> <br><br>  My task was only to identify the definition of classes, functions, and function calls. <br><br>  To begin, let us describe the necessary part of the grammar using the extended Backus-Naur form (RBNF) ( <a href="http://goo.gl/HMwMp">wiki</a> ). <br><br><pre> <code class="cpp hljs">class_def = CLASS classname [inheritance] COLON suite classname = ID inheritance = LBRACE class_args_list RBRACE class_args_list = [class_arg] class_arg = dotted_name {COMMA dotted_name} dotted_name = ID {DOT ID}</code> </pre><br>  Here <code>[X]</code> is 0 or 1 occurrences of <code>X</code> , <code>{Y}</code> - 0 or more occurrences of <code>Y</code> <br><br>  To determine the class name and its dependencies is enough.  Now for the functions. <br><br><pre> <code class="cpp hljs">func_def = DEF funcname LBRACE [func_args_list] RBRACE COLON suite funcname = ID func_args_list = [func_arg] func_arg = (dotted_name | star_arg) {OTHER | COMMA | dotted_name | star_arg | MESSAGE} star_arg = [STAR] STAR ID</code> </pre><br>  By the way, it is assumed that the user code will be correct (from the point of view of the interpreter), otherwise the rules of grammar must be defined more strictly. <br><br>  Well, let's finish with the grammar and go to the lexer (lexical analyzer), since the source python code should be divided into tokens before parsing the grammar. <br><br><h2>  Lexical analyzer </h2><br>  Lexer is generated by the Flex program.  The simplest example is: <br><pre> <code class="cpp hljs">%{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; %} %% start printf("START\n"); stop printf("STOP\n"); . ; /*    */ %%</span></span></span></span></code> </pre> <br>  How to compile this example: <br><br><pre> <code class="bash hljs">% flex lexer.l &amp;&amp; gcc lex.yy.c -o lexer -lfl</code> </pre> <br><br>  Learn to describe grammar for lexer: <br>  <a href="http://rus-linux.net/lib.php%3Fname%3D/MyLDP/algol/lex-yacc-howto.html">http://rus-linux.net/lib.php?name=/MyLDP/algol/lex-yacc-howto.html</a> <br><br>  OK, now we will define tokens.  In grammar, we have already used the following: <br> <code>CLASS, COLON, COMMA, DEF, DOT, ID, LBRACE, MESSAGE, RBRACE, OTHER, STAR</code> <br>  We also need <code>DEFINED</code> - reserved Python words. <br><br>  We make lexer. <br>  Code: <a href="https://gist.github.com/2158334">https://gist.github.com/2158334</a> <br><br>  A brief analysis: comments, blank lines and spaces are ignored.  All the rest (the so-called stream of tokens) is given to the input Bison. <br><br>  A character set that finds a pattern (for example, following the <code>[ \t]+</code> pattern) is placed in <code>yytext</code> .  By default, <code>yytext</code> is a char pointer, but if you add the <code>-l</code> <code>yytext</code> when compiling, then <code>yytext</code> will be interpreted as a char array.  Before returning the token to the bison, we write the value determined from the template into the <code>yylval</code> (for more details, see below). <br><br>  It's time to go to the description of grammar for bison. <br><br><h2>  Bison </h2><br>  Learn to describe the grammar for bison: <a href="http://rus-linux.net/lib.php%3Fname%3D/MyLDP/algol/lex-yacc-howto.html">http://rus-linux.net/lib.php?name=/MyLDP/algol/lex-yacc-howto.html</a> <br><br>  I refer you again to this article, because those who cannot compose a grammar for a bison will easily learn through the material on this link.  Well, who knows how - well, go ahead. <br><br>  So, looking at the point of the Grammar article, let's try to make a grammar for the bison: <br><br>  Code: <a href="https://gist.github.com/2158315">https://gist.github.com/2158315</a> <br><br>  In the Bison rule, each lexeme has a meaning.  The value of the group collected by the current rule is stored in <code>$</code> , the values ‚Äã‚Äãof the other tokens are stored in <code>$1, $2, ‚Ä¶</code> <br><pre> <code class="cpp hljs">test_rule: token1, token2, token3; $$ $<span class="hljs-number"><span class="hljs-number">1</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span> $<span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  The value stored in <code>$n</code> is nothing more than the value of the <code>yylval</code> at the time the lexer returns a token. <br><br>  Starting Bison with the <code>-d</code> parameter, the file <code>.tab.h</code> generated, it contains the macro definitions of the types of tokens that are used in the lexer.  Each token corresponds to a number <code>&gt; 257</code> .  This file should be included in the lexer, which we did: <code>#include "pyparser.tab.h"</code> . <br><br>  How does the analyzer.  The <code>yyparse</code> function is <code>yyparse</code> from <code>main</code> , which starts the analysis ‚Äî reads the tokens, performs some actions, and exits if it encounters the end of the input text ( <code>return 0</code> ) or a syntax error ( <code>return 1</code> ). <br><br>  Learn more about the work of Bison: <a href="http://www.linux.org.ru/books/GNU/bison/bison_7.html">http://www.linux.org.ru/books/GNU/bison/bison_7.html</a> <br><br>  We try to compile and test what we have: <br><pre> <code class="bash hljs">% bison -d pyparser.y --verbose &amp;&amp; flex lexer.l &amp;&amp; g++ -c lex.yy.c pyparser.tab.c &amp;&amp; g++ -o parser lex.yy.o pyparser.tab.o -ll -ly</code> </pre> <br>  Test example: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Foo)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test2</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br>  Result: <br><pre> <code class="python hljs"> &gt;&gt; CLASS: Foo() &gt;&gt; CLASS: Test(Foo) &gt;&gt; CLASS: Test2() &gt;&gt; FUNC: __init__(self) &gt;&gt; FUNC: foo()</code> </pre> <br>  In principle, it is true, although not quite.  I would like to see the ‚Äúfull name‚Äù in the function definition, that is: <br><pre> <code class="python hljs">&gt;&gt; CLASS: Foo() &gt;&gt; CLASS: Test(Foo) &gt;&gt; CLASS: Test2() &gt;&gt; FUNC: Test.Test2.__init__(self) &gt;&gt; FUNC: Test.Test2.foo()</code> </pre><br>  To do this, we proceed as follows: we will start a stack to which we will add the name of the current class.  As soon as the definition of a function is encountered, we gradually pull out the class names from the stack, concatenating with the function name.  If a new class is found deeper in the level, we add to the stack, otherwise we remove elements from the stack until we reach the current level of nesting (and another one less), and add a new class to the stack. <br><br>  The idea and implementation below. <br><br><h2>  Python Features </h2><br>  The obvious problem is to find out the level of nesting.  As you know, in Python, tabulation (or spaces) is used for this.  Therefore, it is necessary to store the current indent in some global variable that is accessible to both the analyzer and the lexer.  The Bison guide says that the yyparse function expects that the position of the just-parsed token in the text is in the global variable <code>yylloc</code> . <br><br>  <code>yylloc</code> is a structure of four elements: <code>first_line, first_column, last_line  last_column</code> .  In <code>first_line</code> we will store the current line number (useful for debugging, and included in my task), in <code>last_column</code> we will keep an indent. <br><br>  Make changes to the code.  In the lexer, we define the type of the variable yylloc and the default value for the line number: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> YYLTYPE yylloc; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> YY_USER_INIT yylloc.first_line=1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// =0</span></span></span></span></code> </pre><br>  When we meet a new line: <br><pre> <code class="cpp hljs">yylloc.first_line++; yylloc.last_column = <span class="hljs-number"><span class="hljs-number">0</span></span>; isNewLine = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  If the line starts with spaces: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNewLine == <span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; <span class="hljs-number"><span class="hljs-number">0</span></span> == yyleng % SPACES_PER_INDENT) yylloc.last_column = yyleng / SPACES_PER_INDENT; isNewLine = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre><br>  <code>yyleng</code> - the length of the pattern to be found.  <code>SPACES_PER_INDENT</code> is set to 4 by default (standard). <br><br>  If the line starts with a tab character: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNewLine == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) yylloc.last_column = yyleng; isNewLine = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre><br>  Now adjust the row count.  There are triple quotes in python, usually used for long commentary documentation.  To ignore write the function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _ch)</span></span></span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ch; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = _ch; _ch = _ch[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> skip = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;ch = yyinput()) { str += ch; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == _ch){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> count++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"\n"</span></span> == ch || <span class="hljs-string"><span class="hljs-string">"\r"</span></span> == ch) yylloc.first_line++; } }</code> </pre> <br>  Here, in fact, it was possible to get by with a regular expression, but then it would not be possible to determine the line number correctly - we will not be able to find out the number of lines eaten by the reexex (or can we? If yes, write a way). <br><br>  Also do not forget to ignore the comment line: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = yyinput();;ch = yyinput()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'\0'</span></span> == ch || <span class="hljs-string"><span class="hljs-string">'\n'</span></span> == ch || <span class="hljs-string"><span class="hljs-string">'\r'</span></span> == ch) { yylloc.first_line++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre> <br><br>  Go to the stack algorithm. <br><br><h2>  Determine the nesting function </h2><br>  We act according to the algorithm I described above. <br><br>  For convenience, we define types: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> pair &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; meta_data; <span class="hljs-comment"><span class="hljs-comment">// &lt;_, &gt; typedef stack &lt;meta_data&gt; meta_stack; static meta_stack class_st;</span></span></code> </pre><br>  We put on the stack a pair of <code>&lt;__, &gt;</code> <br><pre> <code class="cpp hljs">class_def: CLASS classname inheritance COLON suite { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indent = @<span class="hljs-number"><span class="hljs-number">1.l</span></span>ast_column; <span class="hljs-comment"><span class="hljs-comment">//    meta_data new_class($2, indent); clean_stack( class_st, indent ); class_st.push( new_class ); } ;</span></span></code> </pre> <br>  The function of cleansing the stack to the current indent: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_stack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( meta_stack&amp; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">stack</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indent )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( indent &gt; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.top().second ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(); } }</code> </pre><br>  Well, we determine the full name of the function: <br><pre> <code class="cpp hljs">func_def: DEF funcname LBRACE func_args_list RBRACE COLON suite { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> fnc_name = $<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indent = @<span class="hljs-number"><span class="hljs-number">1.l</span></span>ast_column; clean_stack( class_st, indent ); <span class="hljs-function"><span class="hljs-function">meta_stack </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp_class_st</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(class_st)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!tmp_class_st.empty()) { fnc_name = tmp_class_st.top().first + <span class="hljs-string"><span class="hljs-string">"."</span></span> + fnc_name; tmp_class_st.pop(); } }</code> </pre> <br><br><h2>  Conclusion </h2><br>  I did not describe in the article the definition of a function call, since it is actually similar to finding a function declaration, although there are difficulties there.  If there is interest, here is my repository on github: <a href="https://github.com/sagod/pyparser">https://github.com/sagod/pyparser</a> .  Comments, comments and pull requests are welcome. <br><br><h2>  Literature </h2><br><ul><li>  Flex &amp; Bison by John Levine: <a href="http://shop.oreilly.com/product/9780596155988.do">shop.oreilly.com/product/9780596155988.do</a> </li><li>  Bison: <a href="http://www.linux.org.ru/books/GNU/bison/bison_7.html">www.linux.org.ru/books/GNU/bison/bison_7.html</a> </li><li>  Flex: <a href="http://www.delorie.com/gnu/docs/flex/flex_1.html">www.delorie.com/gnu/docs/flex/flex_1.html</a> </li><li>  <a href="http://rus-linux.net/lib.php%3Fname%3D/MyLDP/algol/lex-yacc-howto.html">One year's</a> article on rus-linux: <a href="http://rus-linux.net/lib.php%3Fname%3D/MyLDP/algol/lex-yacc-howto.html">rus-linux.net/lib.php?name=/MyLDP/algol/lex-yacc-howto.html</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/141756/">https://habr.com/ru/post/141756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141750/index.html">Cisco CLI in BASH</a></li>
<li><a href="../141751/index.html">The most popular games and applications for Ubuntu for March 2012 (repository UALinux)</a></li>
<li><a href="../141753/index.html">Invitation to get acquainted with IBM's smart cloud</a></li>
<li><a href="../141754/index.html">SaaS & Workflow - Making workflow in Axxerion</a></li>
<li><a href="../141755/index.html">Contest results</a></li>
<li><a href="../141757/index.html">Smart Redirects for Nuclear Pack</a></li>
<li><a href="../141759/index.html">PRUFFI Friends - how to sell a friend to make him like</a></li>
<li><a href="../141761/index.html">Quadcopter for 1 day and $ 120</a></li>
<li><a href="../141762/index.html">Rules for a startup during an investment boom</a></li>
<li><a href="../141765/index.html">Facebook has announced an Instagram acquisition agreement. Issue price - $ 1 billion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>