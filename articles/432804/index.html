<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 24. Queues: helper services and data structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will continue to consider the queue. 

 Queuing support services 
 Nucleus RTOS has four API calls that provide support functions ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 24. Queues: helper services and data structures</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/j7/rf/kj/j7rfkj7abgipgl8ohotufkmukwa.jpeg"><br><br>  In this article, we will continue to consider the queue. <br><br><h2>  Queuing support services </h2><br>  Nucleus RTOS has four API calls that provide support functions related to queues: resetting a queue, obtaining queue information, obtaining the number of queues in an application, and receiving pointers to all queues in an application.  The first three functions are implemented in the Nucleus SE. <br><a name="habracut"></a><br>  Previous articles in the series: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habr.com/post/431378/">Article # 23.</a>  <a href="https://habr.com/post/431378/">Queues: introduction and basic services</a> <br>  <a href="https://habr.com/post/431118/">Article # 22.</a>  <a href="https://habr.com/post/431118/">Mailboxes: ancillary services and data structures</a> <br>  <a href="https://habr.com/post/430856/">Article # 21.</a>  <a href="https://habr.com/post/430856/">Mailboxes: Introduction and Basic Services</a> <br>  <a href="https://habr.com/post/429588/">Article # 20.</a>  <a href="https://habr.com/post/429588/">Semaphores: helper services and data structures</a> <br>  <a href="https://habr.com/post/429156/">Article # 19.</a>  <a href="https://habr.com/post/429156/">Semaphores: introduction and basic services</a> <br>  <a href="https://habr.com/post/428890/">Article # 18.</a>  <a href="https://habr.com/post/428890/">Event flag groups: helper services and data structures</a> <br>  <a href="https://habr.com/post/428131/">Article # 17.</a>  <a href="https://habr.com/post/428131/">Event flag groups: introduction and basic services</a> <br>  <a href="https://habr.com/post/427439/">Article # 16.</a>  <a href="https://habr.com/post/427439/">Signals</a> <br>  <a href="https://habr.com/post/426477/">Article # 15.</a>  <a href="https://habr.com/post/426477/">Memory sections: services and data structures</a> <br>  <a href="https://habr.com/post/426425/">Article # 14.</a>  <a href="https://habr.com/post/426425/">Memory sections: introduction and basic services</a> <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <br><br><h3>  Queue reset </h3><br>  This API call resets the queue to its original, unused state.  Any messages that are stored in the queue will be lost.  Any queued tasks will resume with the return code <b>NUSE_QUEUE_WAS_RESET</b> . <br><br>  <b><i>Call to reset the queue at the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br>  <b>STATUS NU_Reset_Queue (NU_QUEUE * queue);</b> <br><br>  Options: <br>  <b>queue</b> is a pointer to a queue control block provided by the user. <br><br>  Return value: <br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_QUEUE</b> - invalid pointer to the queue. <br><br>  <b><i>Call to reset the queue in the Nucleus SE</i></b> <br>  This service call supports the core functionality of the Nucleus RTOS API. <br><br>  Service Call Prototype: <br>  <b>STATUS NUSE_Queue_Reset (NUSE_QUEUE queue);</b> <br><br>  Options: <br>  <b>queue</b> - the index (ID) of the queue to be reset. <br><br>  Return value: <br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_QUEUE</b> is an invalid queue index. <br><br>  <b><i>Implement Queue Reset in Nucleus SE</i></b> <br>  The function code <b>NUSE_Queue_Reset</b> (after checking the parameters) is quite simple.  The indexes of the head and tail of the queue, as well as the message counter in the queue, are assigned a zero value. <br><br>  If task lock is activated, the additional code is responsible for restoring suspended tasks: <br><br><pre><code class="plaintext hljs">while (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this queue */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_QUEUE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Queue_Blocking_Count[queue]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Each suspended task in the queue is assigned the status ‚Äúready‚Äù with the return code <b>NUSE_QUEUE_WAS_RESET</b> .  After this process is completed, if the Priority Scheduler is used, the <b>NUSE_Reschedule ()</b> function is <b>called</b> , since one or more high-priority tasks may be ready to be executed. <br><br><h3>  Getting Queue Information </h3><br>  This service call provides queue information.  The implementation of this call in the Nucleus SE differs from the Nucleus RTOS in that it returns less information, since the naming of objects, the variable length of the message and the order of pausing tasks are not supported, and the blocking of tasks can be disabled. <br><br>  <b><i>Call to get queue information at Nucleus RTOS</i></b> <br>  Service Call Prototype: <br><br>  <b>STATUS NU_Queue_Information (NU_QUEUE * queue, CHAR * name, VOID ** start_address, UNSIGNED * queue_size, UNSIGNED * available, UNSIGNED * messages, OPTION * message_type, UNSIGNED * message_size, OPTION * suspend_type, UNSIGNED * tasks_shawning * UNAIGNED, UNSIGNED * message_size, OPTION * suspend_type, UNSIGNED * UNIIGNED * messages, UNSIGNED * message_size, UNSIGNED *</b> <br><br>  Options: <br><br>  <b>queue</b> - a pointer to the queue control block provided by the user; <br>  <b>name</b> - pointer to the 8-character field for the name of the message in the queue; <br>  <b>start_address</b> - a pointer to a pointer, in which the start address of the queue data area will be written; <br>  <b>queue_size</b> is a pointer to a variable for storing the total number of <b>UNSIGNED</b> elements in the queue; <br>  <b>available</b> - a pointer to a variable to store the number of available <b>UNSIGNED</b> elements in the queue; <br>  messages - a pointer to a variable to store the current number of messages in the queue; <br>  <b>message_type</b> is a pointer to a variable to store the type of messages supported by the queue.  Valid values ‚Äã‚Äãare <b>NU_FIXED_SIZE</b> and <b>NU_VARIABLE</b> ; <br>  <b>message_size</b> is a pointer to a variable for storing the number of data elements of type <b>UNSIGNED</b> in each message in the queue.  If the queue supports variable length messages, this number indicates the maximum message length; <br>  <b>suspend_type</b> - a pointer to a variable to store the type of task suspension.  Valid values ‚Äã‚Äãare <b>NU_FIFO</b> and <b>NU_PRIORITY</b> ; <br>  <b>tasks_waiting</b> - pointer to a variable to store the number of tasks suspended on this queue; <br>  <b>first_task</b> - pointer to the task pointer, into which the pointer of the first suspended task is placed. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_QUEUE</b> - invalid pointer to the queue. <br><br>  <b><i>Call to get queue information in Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NUSE_Queue_Information (NUSE_QUEUE queue, ADDR * start_address, U8 * queue_size, U8 * available, U8 * messages, U8 * tasks_waiting, NUSE_TASK * first_task);</b> <br><br>  Options: <br><br>  <b>queue</b> - the index of the queue about which information is requested; <br>  <b>start_address</b> - a pointer to a variable of the type <b>ADDR</b> , in which the address of the beginning of the queue data area will be stored; <br>  <b>queue_size</b> is a pointer to a variable of type <b>U8</b> , which will store the total number of messages that can fit in the queue; <br>  <b>available</b> - a pointer to a variable of type <b>U8</b> , in which the number of free places in the queue will be stored; <br>  <b>messages</b> - a pointer to a variable of type <b>U8</b> , in which the current number of messages in the queue will be stored; <br>  <b>tasks_waiting</b> - pointer to the variable in which the number of tasks suspended on this queue will be stored (nothing is returned if the task lock is disabled); <br>  <b>first_task</b> - a pointer to a variable of type <b>NUSE_TASK</b> , in which the index of the first suspended task will be stored (nothing is returned if the blocking of tasks is disabled). <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_QUEUE</b> - invalid queue index; <br>  <b>NUSE_INVALID_POINTER</b> - one or more pointer parameters is incorrect. <br><br>  <b><i>Implementing the display of queue information in the Nucleus SE</i></b> <br><br>  The implementation of this API call is quite simple: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Queue_Data[queue]; *queue_size = NUSE_Queue_Size[queue]; *available = NUSE_Queue_Size[queue] - NUSE_Queue_Items[queue]; *messages = NUSE_Queue_Items[queue]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Queue_Blocking_Count[queue]; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  The function returns the status of the queue.  Then, if the task lock is activated, the number of waiting tasks and the index of the first one are returned (otherwise, both parameters are assigned the value 0). <br><br><h3>  Getting the number of queues </h3><br>  This service call returns the number of queues configured in the application.  In Nucleus RTOS, their number may change over time, and the return value will show the current number of queues.  In Nucleus SE, the return value is set at the build stage and cannot change. <br><br>  <b><i>Call to Nucleus RTOS Queue Counter</i></b> <br>  Service Call Prototype: <br>  <b>UNSIGNED NU_Established_Queues (VOID);</b> <br><br>  Options: <br>  None. <br><br>  Return value: <br>  The number of queues created in the system. <br><br>  <b><i>Call to Queue Counter in Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br>  <b>U8 NUSE_Queue_Count (void);</b> <br><br>  Options: <br>  None. <br><br>  Return value: <br>  The number of queues configured in the application. <br><br>  <b><i>Implementing a Queue Counter in the Nucleus SE</i></b> <br>  The implementation of this API call is very simple: the value of the <b>#define</b> <b>NUSE_QUEUE_NUMBER</b> symbol is <b>returned</b> . <br><br><h2>  Data structures </h2><br>  The queues use five or six data structures (which are either in RAM or ROM), which are sets of tables (like other Nucleus SE objects), the number and size of which corresponds to the number of queues in the application and the selected parameters. <br><br><h3>  Kernel data in ram </h3><br>  This data has the following structure: <br><br>  <b>NUSE_Queue_Head []</b> is an array of <b>U8</b> type pointers, has one entry for each configured queue and points to the head of the message queue.  Used as an index of addresses in <b>NUSE_Queue_Data []</b> (see below); <br>  <b>NUSE_Queue_Tail []</b> is an array of type <b>U8</b> , has one entry for each queue configured in the application, and points to the tail of the message queue.  Used as an index of addresses in <b>NUSE_Queue_Data []</b> (see below); <br>  <b>NUSE_Queue_Items []</b> is an array of type <b>U8</b> , has one entry for each configured queue, and is the count of messages in the queue.  This data can be considered redundant, since these values ‚Äã‚Äãcan be obtained through the indices of the beginning and end of the queue, but keeping the counter simplifies the code; <br>  <b>NUSE_Queue_Blocking_Count []</b> - this array of type <b>U8</b> contains counters of the number of tasks suspended on each queue.  This array is created only if task lock support is activated. <br><br>  These data structures are initialized with zeros by the <b>NUSE_Init_Queue ()</b> function when Nucleus SE is started.  This is logical, since all queues are created empty (not used). <br><br>  The following are the definitions of these structures in the <b>nuse_init.c</b> file: <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Queue_Head[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Tail[NUSE_QUEUE_NUMBER]; RAM U8 NUSE_Queue_Items[NUSE_QUEUE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Queue_Blocking_Count[NUSE_QUEUE_NUMBER]; #endif</code> </pre><br><h3>  User data in RAM </h3><br>  The user is responsible for providing an area of ‚Äã‚ÄãRAM for storing each queue.  The size of this area must contain an array of type <b>ADDR</b> , in which each record corresponds to one message in the queue <br><br><h3>  ROM data </h3><br>  This data has the following structure: <br><br>  <b>NUSE_Queue_Data []</b> is an array of type <b>ADDR</b> , has one entry for each configured queue and points to the queue data area (see User RAM Data); <br>  <b>NUSE_Queue_Size []</b> is an array of type <b>U8</b> , has one entry for each configured queue, and shows the maximum number of messages each queue can receive. <br><br>  These data structures are declared and initialized (statically) in the <b>nuse_config.c</b> file: <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Queue_Data[NUSE_QUEUE_NUMBER] = { /* addresses of queue data areas ------ */ }; ROM U8 NUSE_Queue_Size[NUSE_QUEUE_NUMBER] = { /* queue sizes ------ */ };</code> </pre><br><h3>  The amount of memory for the queues </h3><br>  As with all Nucleus SE core objects, the amount of memory required for queues is easily predictable. <br><br>  The amount of data in the ROM (in bytes) for all queues in the application can be calculated as follows: <br>  <b>NUSE_QUEUE_NUMBER * (sizeof (ADDR) + 1)</b> <br><br>  The amount of kernel data in RAM (in bytes) for all the queues in the application when the task lock is activated is calculated as follows: <br>  <b>NUSE_QUEUE_NUMBER * 3</b> <br><br>  If the lock is disabled: <br>  <b>NUSE_QUEUE_NUMBER * 4</b> <br><br>  The amount of user data in RAM (in bytes) for a queue with an index <b>queue</b> : <br>  <b>NUSE_Queue_Size [queue] * sizeof (ADDR)</b> <br><br><h2>  Unrealized API calls </h2><br>  The four API calls that can be found in the Nucleus RTOS are not implemented in the Nucleus SE: <br><br><h3>  Creating a queue </h3><br>  This API call creates a queue, in Nucleus SE this is not necessary, since the queues are created statically. <br><br>  Service Call Prototype: <br>  <b>STATUS NU_Create_Queue (NU_QUEUE * queue, char * name, VOID * start_address, UNSIGNED queue_size, OPTION message_type, UNSIGNED message_size, OPTION suspend_type);</b> <br><br>  Options: <br><br>  <b>queue</b> - a pointer to the user-supplied control unit, used to manage queues in other API calls; <br>  <b>name</b> - pointer to the 7-character queue name with zero terminating byte; <br>  <b>start_address</b> - address of the beginning of the queue; <br>  <b>message_type</b> is the message type supported by the queue.  It can be <b>NU_FIXED_SIZE</b> or <b>NU_VARIABLE_SIZE</b> ; <br>  <b>message_size</b> ‚Äî If the queue supports fixed-length messages, this parameter specifies the exact length of each message, otherwise, if the queue supports variable-length messages, this value is the maximum message length; <br>  <b>suspend_type</b> - defines the type of suspension of tasks in the queue.  It can take the values <b>NU_FIFO</b> and <b>NU_PRIORITY</b> , which means the principle of FIFO (First-In-First-Out) or the principle of priority of task suspension, respectively. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_QUEUE</b> - null pointer to the queue management block ( <b>NULL</b> ), or the pointer is already in use; <br>  <b>NU_INVALID_MEMORY</b> - invalid memory location specified in <b>start_address</b> ; <br>  <b>NU_INVALID_MESSAGE</b> - incorrect <b>message_type</b> parameter; <br>  <b>NU_INVALID_SIZE</b> ‚Äî the queue does not support messages of this length, or the queue size and / or message length is 0; <br>  <b>NU_INVALID_SUSPEND</b> is an invalid <b>suspend_type</b> parameter. <br><br><h3>  Deleting a queue </h3><br>  This API call deletes the queue created earlier.  This is not necessary in the Nucleus SE, since the queues are created statically and cannot be deleted. <br><br>  Service Call Prototype: <br>  <b>STATUS NU_Delete_Queue (NU_QUEUE * queue);</b> <br><br>  Options: <br>  <b>queue</b> - pointer to the queue management block. <br><br>  Return value: <br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_QUEUE</b> - invalid pointer to the queue. <br><br><h3>  Queue pointers </h3><br>  This API call builds a sequential list of pointers to all queues in the system.  In the Nucleus SE, this is not necessary, as the queues are identified using a simple index, not a pointer. <br><br>  Service Call Prototype: <br>  <b>UNSIGNED NU_Queue_Pointers (NU_QUEUE ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Options: <br>  <b>pointer_list</b> is a pointer to an array of pointers <b>NU_QUEUE</b> .  This array will be filled with pointers to the queues created in the system; <br>  <b>maximum_pointers</b> - the maximum number of pointers in the array. <br><br>  Return value: <br>  The number of <b>NU_QUEUE</b> pointers in the array. <br><br><h3>  Broadcast to Queue </h3><br>  This API call sends a message to all tasks suspended in the queue that are waiting for messages from the specified queue.  This feature is not implemented in the Nucleus SE because it adds excessive complexity. <br><br>  Service Call Prototype: <br>  <b>STATUS NU_Broadcast_To_Queue (NU_QUEUE * queue, VOID * message, UNSIGNED size, UNSIGNED suspend);</b> <br><br>  Options: <br><br>  <b>queue</b> - a pointer to the queue management block; <br>  <b>message</b> - pointer to the message being sent; <br>  <b>size</b> - the number of elements of type <b>UNSIGNED</b> in the message.  If the queue supports variable length messages, this parameter must be equal to or less than the length of the message supported by the queue.  If the queue supports fixed-length messages, this parameter must be equal to the length of the message supported by the queue; <br>  <b>suspen</b> - indicates whether the calling task should be suspended if the queue is already full.  It can be <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND,</b> or timeout value. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_QUEUE</b> - invalid pointer to the queue; <br>  <b>NU_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - the specified message length is not compatible with the length specified when creating the queue; <br>  <b>NU_INVALID_SUSPEND</b> - an attempt to pause a task from a <b>thread that</b> is not associated with a task; <br>  <b>NU_QUEUE_FULL</b> - there is not enough space in the queue for a message; <br>  <b>NU_TIMEOUT</b> ‚Äî the queue is still full after the timeout expires; <br>  <b>NU_QUEUE_DELETED</b> - the queue was deleted while the task was suspended; <br>  <b>NU_QUEUE_RESET</b> ‚Äî The queue was reset while the task was suspended. <br><br><h2>  Nucleus RTOS Compatibility </h2><br>  As with all other Nucleus SE objects, my goal was to ensure maximum compatibility of application code with Nucleus RTOS.  Queues are no exception and, from the user's point of view, they are implemented in the same way as in the Nucleus RTOS.  There is a certain incompatibility, which I considered acceptable, given that as a result, the code will become more understandable and more efficient in terms of the amount of memory required.  Otherwise, Nucleus RTOS API calls can be almost directly transferred to the Nucleus SE. <br><br><h3>  Object IDs </h3><br>  In Nucleus RTOS, all objects are described by a data structure (control units) that has a specific data type.  A pointer to this control unit serves as a queue identifier.  I decided that in the Nucleus SE, a different approach is needed for effective memory use: all kernel objects are described by a set of tables in RAM and / or ROM.  The size of these tables is determined by the number of configured objects of each type.  The identifier of a particular object is the index in this table.  Thus, I have defined <b>NUSE_QUEUE</b> as equivalent to <b>U8</b> , a variable (not a pointer) of this type serves as a queue identifier.  This small incompatibility is easy to handle if the code is ported from the Nucleus SE to the Nucleus RTOS and vice versa.  Usually no operations are performed on object identifiers, except for moving and storing. <br><br>  Nucleus RTOS also supports naming queues.  These names are used only when debugging.  I excluded them from the Nucleus SE to save memory. <br><br><h3>  Message size and type </h3><br>  In Nucleus RTOS, the queue can be configured to process messages consisting of any number of <b>unsigned</b> elements.  In Nucleus SE, Queues are simplified and only support single <b>ADDR</b> messages.  Data channels in the Nucleus SE are a bit more flexible and can be a useful alternative to queuing in some cases.  Channels will be reviewed in the next two articles of this series. <br><br>  Nucleus SE also supports variable-length queues in which only the maximum message length is specified when creating.  Variable length messages are not supported by Nucleus SE <br><br><h3>  Queue size </h3><br>  In Nucleus SE, the maximum number of messages in a queue is 256, since all variables and constants are of type <b>U8</b> .  Nucleus RTOS has no such restrictions. <br><br><h3>  Unrealized API calls </h3><br>  Nucleus RTOS supports ten service calls for queuing.  Of these, four are not implemented in the Nucleus SE.  The details of these calls, as well as the reasons for this decision, can be found in this article above, in the section "Unrealized API calls". <br><br>  The following article will discuss data transfer channels. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. </div><p>Source: <a href="https://habr.com/ru/post/432804/">https://habr.com/ru/post/432804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432794/index.html">Bret Victor: A few words about Douglas Engelbart</a></li>
<li><a href="../432796/index.html">Compute Module, 2019 models</a></li>
<li><a href="../432798/index.html">Best OS for Security: Comparing Titans</a></li>
<li><a href="../432800/index.html">Investigation of security incidents with StaffCop Enterprise 4.4</a></li>
<li><a href="../432802/index.html">Six free automated platforms for learning programming</a></li>
<li><a href="../432806/index.html">Sverhintelekt: an idea that does not give rest to intelligent people</a></li>
<li><a href="../432808/index.html">Salaries in AI: where more money and who are looking for in Russia</a></li>
<li><a href="../432810/index.html">First GDPR penalties: who has already been punished</a></li>
<li><a href="../432812/index.html">We write trading robots using the StockSharp graphic framework. Part 1</a></li>
<li><a href="../432814/index.html">Cake and TeamCity integration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>