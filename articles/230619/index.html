<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Meta-Object Protocol Common Lisp on the example of the implementation of the prototype object system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Common Lisp, more specifically, its object system, CLOS , provides the user with a language with a completely wonderful mechanism, name...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Meta-Object Protocol Common Lisp on the example of the implementation of the prototype object system</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction </h1><br>  Common Lisp, more specifically, its object system, <abbr title="Common Lisp Object System">CLOS</abbr> , provides the user with a language with a completely wonderful mechanism, namely, the meta-object protocol. <br><br>  Unfortunately, very often this component of the language is undeservedly left without proper attention, and in this article I will try to compensate for this somewhat. <br><br>  In general, what is a metaobject protocol?  Obviously, this is a layer of the object system, which, judging by the name, in some way operates on it and controls it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is it for?  In fact, depending on the language and the object system, the list of applications can be almost limitless.  This includes adding declarative code (annotations in Java and attributes in C #), as well as various code and class generation in runtime (here you can recall various persistance and ORM frameworks), and much more. <br><br>  From my personal point of view, the best meta-object protocols have recommended themselves to consolidate design patterns at the object system level.  Patterns like, say, singleton, which in languages ‚Äã‚Äãwithout a sufficiently developed OOP have to be implemented again and again using the copy-n-paste method, in my favorite Common Lisp are created literally from a couple dozen lines of code and are reused later on by indicating the metaclass <sup><a href="https://habr.com/ru/post/230619/">[1]</a></sup> . <br><br>  Nevertheless, in the following text I want to focus on something more interesting, namely, on changing the rules of operation of the object system itself, its very foundations.  It was the addition of opportunities for such a change that was the key goal of the developers of the meta-object protocol for Common Lisp. <br><br>  So, the following text will be devoted to creating a prototype object system, similar to JavaScript, in Common Lisp, using the meta-object protocol and integrating it into CLOS.  The full project code is available on github <sup><a href="https://habr.com/ru/post/230619/">[2]</a></sup> . <br><a name="habracut"></a><br><h1>  Go </h1><br>  Actually the first thing to do is create a metaclass for all classes participating in our prototype system. <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defclass</span></span> prototype-class (<span class="hljs-name"><span class="hljs-name">standard-class</span></span>) () (<span class="hljs-symbol"><span class="hljs-symbol">:documentation</span></span> <span class="hljs-string"><span class="hljs-string">"Metaclass for all prototype classes"</span></span>))</code> </pre> <br><br>  This is how simple it is.  In fact, we need the class of classes only to redefine the standard mechanisms for working with slots (that is, class fields) in our objects, and more on that. <br><br>  In the CLOS <abbr title="Metaobject protocol">MOP,</abbr> each slot of an object in a class is represented by so-called slot-definition.  Slot-definition, as the name implies, determines the meta-information about the class fields, but they are of two types: <br><br><ul><li>  <strong>direct-slot-definiton</strong> Actually, as may be understood from the name, they represent what we directly specified when defining the class, say using the form <i>defclass</i> . </li><li>  <strong>effective-slot-definition</strong> - "Definition of the actual slot."  They describe slots that exist, roughly speaking, in the objects of our class. </li></ul><br><br>  To make the difference clear, it is worthwhile to describe the class initialization protocol in more detail. <br><br>  In CLOS, when creating (defining) a class, up to a certain time, only the information we specified (say, in <i>defclass</i> ) is stored in it (in its metaobject).  This is some information about the fields defined in it ( <i>direct-slot-definition</i> ), this is a list of classes from which it is inherited, and various other things that we, I repeat, directly indicated during creation.  After creating the class, we can edit it some time later. <br><br>  At a certain point, a certain thing happens with the metaobject of a class, called finalization.  Usually it happens automatically, mainly when creating the first class object, but it can also be called by hand. <br><br>  In principle, you can draw some parallels with static class constructors in languages ‚Äã‚Äãlike C #.  The finalization, roughly speaking, completes the creation of the class.  At this moment, the so-called <i>Class Precedence List is</i> calculated (and if in Russian, a ‚Äúlist of the order of inheritance‚Äù of a class, roughly the topological sorting of all classes from which our inheritance), and based on this information, the ‚Äúactual‚Äù slots that our objects class will be stored. <br><br>  So, the ‚Äúdefinition of the direct slot‚Äù stores only the most general information about the slot, while the definition of ‚Äúactual‚Äù stores including information about the slot index in the object memory, which cannot be calculated until the finalization of the class. <br><br>  In principle, all the described mechanisms can be redefined via the meta-object protocol, but we will limit ourselves to just a few. <br><br>  Create our slot definition classes. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defclass</span></span> direct-hash-slot-definition (<span class="hljs-name"><span class="hljs-name">standard-direct-slot-definition</span></span>) () (<span class="hljs-symbol"><span class="hljs-symbol">:default-initargs</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:allocation</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span>)) (<span class="hljs-name"><span class="hljs-name">defclass</span></span> effective-hash-slot-definition (<span class="hljs-name"><span class="hljs-name">standard-effective-slot-definition</span></span>) () (<span class="hljs-symbol"><span class="hljs-symbol">:default-initargs</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:allocation</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span>))</code> </pre><br><br>  Now we will redefine two generalized functions from MOP, which indicate which classes of definitions of slots our metaclass should use when defining slots, creation. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmethod</span></span> direct-slot-definition-class ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> initargs) (<span class="hljs-name"><span class="hljs-name">declare</span></span> (<span class="hljs-name"><span class="hljs-name">ignore</span></span> initargs)) (<span class="hljs-name"><span class="hljs-name">find-class</span></span> 'direct-hash-slot-definition)) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> effective-slot-definition-class ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> initargs) (<span class="hljs-name"><span class="hljs-name">declare</span></span> (<span class="hljs-name"><span class="hljs-name">ignore</span></span> initargs)) (<span class="hljs-name"><span class="hljs-name">find-class</span></span> 'effective-hash-slot-definition))</code> </pre><br><br>  As seen above, the metaobjects of slot definitions accept an argument <i>: allocation</i> .  What is it?  This is a specifier that indicates where space is allocated for the object fields.  The CL standard mentions two kinds of such specifiers.  The first is <i>: class</i> , which means that space will be allocated in the class itself, i.e.  this is an analogue of static fields from other languages, and the second is <i>:: instance</i> ‚Äî space will be allocated for each class object, usually in some array associated with it.  We specified our specifier - <i>: hash</i> .  What for?  And then, by default, the fields will be stored in some hash label associated with the object, just like it is done in JavaScript. <br><br>  Where do we define a slot with a hash label?  And we still want to store the prototype of the object somewhere.  We will proceed as follows - we will define a <i>prototype-object</i> class, which will be our top of the hierarchy of all classes that work with our system.  As you can see below, we will define slots with a prototype and fields with <i>instance allocation</i> . <br><br>  Before we create this class, we must allow our classes of the type <i>prototype-class to</i> inherit from standard classes and back.  The <i>validate-superclass function</i> is called during the finalization process, which is described above.  In the event that at least one of the variants, the heir-parent, for any of the inherited classes, returns <i>nil</i> , the standard CLOS mechanism signals an exception. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmethod</span></span> validate-superclass ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) (<span class="hljs-name"><span class="hljs-name">super</span></span> standard-class)) <span class="hljs-literal"><span class="hljs-literal">t</span></span>) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> validate-superclass ((<span class="hljs-name"><span class="hljs-name">class</span></span> standard-class) (<span class="hljs-name"><span class="hljs-name">super</span></span> prototype-class)) <span class="hljs-literal"><span class="hljs-literal">t</span></span>) (<span class="hljs-name"><span class="hljs-name">defclass</span></span> prototype-object () ((<span class="hljs-name"><span class="hljs-name">hash</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:initform</span></span> (<span class="hljs-name"><span class="hljs-name">make-hash-table</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:test</span></span> #'eq) <span class="hljs-symbol"><span class="hljs-symbol">:reader</span></span> hash <span class="hljs-symbol"><span class="hljs-symbol">:allocation</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:instance</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:documentation</span></span> <span class="hljs-string"><span class="hljs-string">"Hash table holding :HASH object slots"</span></span>) (<span class="hljs-name"><span class="hljs-name">prototype</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:initarg</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:prototype</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> prototype <span class="hljs-symbol"><span class="hljs-symbol">:allocation</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:instance</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:documentation</span></span> <span class="hljs-string"><span class="hljs-string">"Object prototype or NIL."</span></span>)) (<span class="hljs-symbol"><span class="hljs-symbol">:metaclass</span></span> prototype-class) (<span class="hljs-symbol"><span class="hljs-symbol">:default-initargs</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:prototype</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-symbol"><span class="hljs-symbol">:documentation</span></span> <span class="hljs-string"><span class="hljs-string">"Base class for all prototype objects"</span></span>))</code> </pre><br><br>  Let's further define two functions similar to those of the standard CLOS.  What they do, I think it is clear: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> prototype-of (<span class="hljs-name"><span class="hljs-name">object</span></span>) <span class="hljs-string"><span class="hljs-string">"Retrieves prototype of an OBJECT"</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">class</span></span> (<span class="hljs-name"><span class="hljs-name">class-of</span></span> object))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">typep</span></span> class 'prototype-class) (<span class="hljs-name"><span class="hljs-name">prototype</span></span> object)))) (<span class="hljs-name"><span class="hljs-name">defgeneric</span></span> change-prototype (<span class="hljs-name"><span class="hljs-name">object</span></span> new-prototype) (<span class="hljs-symbol"><span class="hljs-symbol">:documentation</span></span> <span class="hljs-string"><span class="hljs-string">"Changes prototype of OBJECT to NEW-PROTOTYPE"</span></span>) (<span class="hljs-symbol"><span class="hljs-symbol">:method</span></span> ((<span class="hljs-name"><span class="hljs-name">object</span></span> prototype-object) new-prototype) (<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">prototype</span></span> object) new-prototype)))</code> </pre><br><br>  Now a small hack.  In the standard CLOS, if we did not specify a single parent class that is <i>standard-object</i> in <i>defclass</i> , and the metaclass of our class is the usual <i>standard-class</i> , then such a class, the <i>standard-object itself</i> , is injected into the list of classes from which we inherited.  We will do the same with our <i>prototype-class</i> and <i>prototype-object</i> .  To do this, override the standard functions used by the object constructor. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> fix-class-initargs (<span class="hljs-name"><span class="hljs-name">class</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> args <span class="hljs-symbol"><span class="hljs-symbol">&amp;key</span></span> ((<span class="hljs-symbol"><span class="hljs-symbol">:direct-superclasses</span></span> dscs) '()) <span class="hljs-symbol"><span class="hljs-symbol">&amp;allow-other-keys</span></span>) <span class="hljs-string"><span class="hljs-string">"Fixup :DIRECT-SUPERCLASSES argument for [RE]INITIALIZE-INSTANCE gf specialized on prototype classes to include PROTOTYPE-OBJECT in superclass list"</span></span> (<span class="hljs-name"><span class="hljs-name">remf</span></span> args <span class="hljs-symbol"><span class="hljs-symbol">:direct-superclasses</span></span>) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> class (<span class="hljs-name"><span class="hljs-name">find-class</span></span> 'prototype-object)) (<span class="hljs-name"><span class="hljs-name">find-if</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">c</span></span>) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">symbolp</span></span> c) (<span class="hljs-name"><span class="hljs-name">setf</span></span> c (<span class="hljs-name"><span class="hljs-name">class-name</span></span> c))) (<span class="hljs-name"><span class="hljs-name">subtypep</span></span> c 'prototype-object)) dscs)) (<span class="hljs-name"><span class="hljs-name">setf</span></span> dscs (<span class="hljs-name"><span class="hljs-name">append</span></span> dscs (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">find-class</span></span> 'prototype-object))))) (<span class="hljs-name"><span class="hljs-name">list*</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:direct-superclasses</span></span> dscs args)) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> initialize-instance <span class="hljs-symbol"><span class="hljs-symbol">:around</span></span> ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> args <span class="hljs-symbol"><span class="hljs-symbol">&amp;key</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;allow-other-keys</span></span>) (<span class="hljs-name"><span class="hljs-name">apply</span></span> #'call-next-method class (<span class="hljs-name"><span class="hljs-name">apply</span></span> #'fix-class-initargs class args))) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> reinitialize-instance <span class="hljs-symbol"><span class="hljs-symbol">:around</span></span> ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> args <span class="hljs-symbol"><span class="hljs-symbol">&amp;key</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;allow-other-keys</span></span>) (<span class="hljs-name"><span class="hljs-name">apply</span></span> #'call-next-method class (<span class="hljs-name"><span class="hljs-name">apply</span></span> #'fix-class-initargs class args)))</code> </pre><br><br>  Now the fun part. <br><br>  The first is that in order to work with object slots go through a hash label stored in our objects, we need to redefine four standard operations for working with slots for our classes - namely, taking the slot value, setting it, checking the slot for connectivity with the value, and deleting such a connection.  All these operations are perfectly implemented by a hash table;  inside these operations, we check whether the <i>: allocation</i> slot <i>: hash</i> , which indicates that our slot is stored in it, and if not - then use the standard CLOS object access mechanism. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmethod</span></span> slot-boundp-using-class ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) (<span class="hljs-name"><span class="hljs-name">object</span></span> prototype-object) slotd) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span> (<span class="hljs-name"><span class="hljs-name">slot-definition-allocation</span></span> slotd)) (<span class="hljs-name"><span class="hljs-name">nth-value</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">gethash</span></span> (<span class="hljs-name"><span class="hljs-name">slot-definition-name</span></span> slotd) (<span class="hljs-name"><span class="hljs-name">hash</span></span> object))) (<span class="hljs-name"><span class="hljs-name">call-next-method</span></span>))) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> slot-makunbound-using-class ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) (<span class="hljs-name"><span class="hljs-name">object</span></span> prototype-object) slotd) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span> (<span class="hljs-name"><span class="hljs-name">slot-definition-allocation</span></span> slotd)) (<span class="hljs-name"><span class="hljs-name">remhash</span></span> (<span class="hljs-name"><span class="hljs-name">slot-definition-name</span></span> slotd) (<span class="hljs-name"><span class="hljs-name">hash</span></span> object)) (<span class="hljs-name"><span class="hljs-name">call-next-method</span></span>))) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> slot-value-using-class ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) (<span class="hljs-name"><span class="hljs-name">object</span></span> prototype-object) slotd) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span> (<span class="hljs-name"><span class="hljs-name">slot-definition-allocation</span></span> slotd)) (<span class="hljs-name"><span class="hljs-name">values</span></span> (<span class="hljs-name"><span class="hljs-name">gethash</span></span> (<span class="hljs-name"><span class="hljs-name">slot-definition-name</span></span> slotd) (<span class="hljs-name"><span class="hljs-name">hash</span></span> object))) (<span class="hljs-name"><span class="hljs-name">standard-instance-access</span></span> object (<span class="hljs-name"><span class="hljs-name">slot-definition-location</span></span> slotd)))) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> (<span class="hljs-name"><span class="hljs-name">setf</span></span> slot-value-using-class) (<span class="hljs-name"><span class="hljs-name">new-value</span></span> (<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) (<span class="hljs-name"><span class="hljs-name">object</span></span> prototype-object) slotd) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span> (<span class="hljs-name"><span class="hljs-name">slot-definition-allocation</span></span> slotd)) (<span class="hljs-name"><span class="hljs-name">values</span></span> (<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">gethash</span></span> (<span class="hljs-name"><span class="hljs-name">slot-definition-name</span></span> slotd) (<span class="hljs-name"><span class="hljs-name">hash</span></span> object)) new-value)) (<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">standard-instance-access</span></span> object (<span class="hljs-name"><span class="hljs-name">slot-definition-location</span></span> slotd)) new-value)))</code> </pre><br><br>  Now the prototypes.  As you know, in JavaScript, the value of the field is searched by a chain of prototypes.  If there is no field in the object, the entire hierarchy is recursively bypassed, and in the absence of a field for any of the objects, undefined is returned.  At the same time, in JS there is a mechanism for "overlapping" of fields.  This means that if an object is set / determined with a name similar to the field name of any of the objects in the prototype hierarchy, then the next time you access this field, the value will be taken from it, without any following the hierarchy. <br><br>  We implement the same functionality.  To do this, we need to override the generic function <i>slot-missing</i> .  It is called when the <i>slot</i> function ( <i>slot-value, (setf slot-value), slot-boundp, slot-makunbound</i> ) detects the absence of a field with the requested name in the class of the object.  This generic function takes an extremely convenient set of arguments ‚Äî the object's meta-object, the object itself, the name of the field, the name of the ‚Äúfailed‚Äù operation, and, for the setting operation, the new value of the field. <br><br>  We proceed as follows.  Prior to redefining this function, we will create an additional class of signals (including Common Lisp inclusions) whose objects will be thrown out if there is a lack of a prototype for the object.  Also, create an additional analog of the <i>prototype-of</i> function defined above. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-condition</span></span> prototype-missing (<span class="hljs-name"><span class="hljs-name">condition</span></span>) () (<span class="hljs-symbol"><span class="hljs-symbol">:documentation</span></span> <span class="hljs-string"><span class="hljs-string">"Signalled when an object is not associated with a prototype."</span></span>)) (<span class="hljs-name"><span class="hljs-name">defun</span></span> %prototype-of (<span class="hljs-name"><span class="hljs-name">class</span></span> instance) <span class="hljs-string"><span class="hljs-string">"Internal function used to retreive prototype of an object"</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">typep</span></span> class 'prototype-class) (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">prototype</span></span> instance) (<span class="hljs-name"><span class="hljs-name">signal</span></span> 'prototype-missing)) (<span class="hljs-name"><span class="hljs-name">signal</span></span> 'prototype-missing)))</code> </pre><br><br>  Now we define our method.  The scheme of work is as follows: for two of the four operations, we recursively go around the prototype hierarchy, and eventually throw out the <i>prototype-missing</i> exception.  At the top of the call stack, we install a handler, which, intercepting the signal, returns us some default value - in this case <i>nil</i> .  Two other operations, as explained above, do not need recursive traversal of prototypes. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defvar</span></span> *prototype-handler* <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-string"><span class="hljs-string">"Non-NIL when PROTOTYPE-MISSING handler is already installed on call stack."</span></span>) (<span class="hljs-name"><span class="hljs-name">defun</span></span> %slot-missing (<span class="hljs-name"><span class="hljs-name">class</span></span> instance slot op new-value) <span class="hljs-string"><span class="hljs-string">"Internal function for performing hash-based slot lookup in case of it is missing from class definition."</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">hash</span></span> (<span class="hljs-name"><span class="hljs-name">hash</span></span> instance))) (<span class="hljs-name"><span class="hljs-name">symbol-macrolet</span></span> ((<span class="hljs-name"><span class="hljs-name">prototype</span></span> (%prototype-of class instance))) (<span class="hljs-name"><span class="hljs-name">case</span></span> op (<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">gethash</span></span> slot hash) new-value)) (<span class="hljs-name"><span class="hljs-name">slot-makunbound</span></span> (<span class="hljs-name"><span class="hljs-name">remhash</span></span> slot hash)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">multiple-value-bind</span></span> (<span class="hljs-name"><span class="hljs-name">value</span></span> present) (<span class="hljs-name"><span class="hljs-name">gethash</span></span> slot hash) (<span class="hljs-name"><span class="hljs-name">ecase</span></span> op (<span class="hljs-name"><span class="hljs-name">slot-value</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> present value (<span class="hljs-name"><span class="hljs-name">slot-value</span></span> prototype slot))) (<span class="hljs-name"><span class="hljs-name">slot-boundp</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> present <span class="hljs-literal"><span class="hljs-literal">t</span></span> (<span class="hljs-name"><span class="hljs-name">slot-boundp</span></span> prototype slot)))))))))) (<span class="hljs-name"><span class="hljs-name">defmethod</span></span> slot-missing ((<span class="hljs-name"><span class="hljs-name">class</span></span> prototype-class) (<span class="hljs-name"><span class="hljs-name">instance</span></span> prototype-object) slot op <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> new-value) (<span class="hljs-name"><span class="hljs-name">if</span></span> *prototype-handler* (%slot-missing class instance slot op new-value) (<span class="hljs-name"><span class="hljs-name">handler-case</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">*prototype-handler*</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (%slot-missing class instance slot op new-value)) (<span class="hljs-name"><span class="hljs-name">prototype-missing</span></span> () <span class="hljs-literal"><span class="hljs-literal">nil</span></span>))))</code> </pre><br><br>  Done!  Actually, no more than 150 lines of code, we got a working prototype object-oriented system, similar to that in JavaScript.  Moreover, this system is fully integrated with standard CLOS, and allows, say, the participation of ‚Äúordinary‚Äù objects in the prototype hierarchy.  Another peculiarity is that we can not create our own classes of objects at all, but manage with only one <i>prototype-object</i> , in case we want a behavior from it that is completely identical to JS. <br><br>  What can I add?  Probably, on top of such a system with the help of <i>reader macros</i> you can make a JSON-like syntax.  But this is a topic for a separate article. <br><br>  Finally, a few examples: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defvar</span></span> *proto* (<span class="hljs-name"><span class="hljs-name">make-instance</span></span> 'prototype-object)) (<span class="hljs-name"><span class="hljs-name">defclass</span></span> foo () ((<span class="hljs-name"><span class="hljs-name">a</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:accessor</span></span> foo-a)) (<span class="hljs-symbol"><span class="hljs-symbol">:metaclass</span></span> prototype-class)) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *foo* (<span class="hljs-name"><span class="hljs-name">make-instance</span></span> 'foo <span class="hljs-symbol"><span class="hljs-symbol">:prototype</span></span> *proto*)) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> *bar* (<span class="hljs-name"><span class="hljs-name">make-instance</span></span> 'prototype-object <span class="hljs-symbol"><span class="hljs-symbol">:prototype</span></span> *foo*)) (<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">slot-value</span></span> *proto* 'x) <span class="hljs-number"><span class="hljs-number">123</span></span>) (<span class="hljs-name"><span class="hljs-name">slot-value</span></span> *bar* 'x) <span class="hljs-comment"><span class="hljs-comment">;;; ==&gt; 123 (setf (foo-a *foo*) 456) (slot-value *bar* 'a) ;;; ==&gt; 456 (setf (slot-value *bar* 'a) 789) (setf (foo-a *foo*) 'abc) (slot-value *bar* 'a) ;;; ==&gt; 789 ;;; because we've introduced new property for *bar* (defclass quux () ((the-slot :initform 'the-value)) (:documentation "Simple standard class")) (defvar *quux* (make-instance 'quux)) (change-prototype *bar* *quux*) (slot-value *bar* 'the-slot) ;;; ==&gt; THE-VALUE (slot-value *bar* 'x) ;;; When attempting to read the slot's value (slot-value), the slot ;;; X is missing from the object #&lt;QUUX {255A4C89}&gt;. ;;; [Condition of type SIMPLE-ERROR]</span></span></code> </pre><br><br>  [ <a name="1"></a>  1] <a href="http://love5an.livejournal.com/306670.html">http://love5an.livejournal.com/306670.html</a> <br>  [ <a name="2"></a>  2] <a href="https://github.com/Lovesan/Prototype">https://github.com/Lovesan/Prototype</a> </div><p>Source: <a href="https://habr.com/ru/post/230619/">https://habr.com/ru/post/230619/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230605/index.html">Controls of CIA</a></li>
<li><a href="../230607/index.html">Modern Tornado: distributed image hosting in 30 lines of code</a></li>
<li><a href="../230613/index.html">What must a startup do to survive?</a></li>
<li><a href="../230615/index.html">RNAInSpace and folding of tRNA - season closing, new season - Structural alignment</a></li>
<li><a href="../230617/index.html">Interview with the demostsener - kb ^ Farbrausch</a></li>
<li><a href="../230623/index.html">7 myths about Linq to Database</a></li>
<li><a href="../230625/index.html">View DOM events in Firefox Developer Tools</a></li>
<li><a href="../230627/index.html">Google uses machine learning to improve data center efficiency</a></li>
<li><a href="../230631/index.html">Soap: all-in-one router for smart home</a></li>
<li><a href="../230633/index.html">Phalcon amazing framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>