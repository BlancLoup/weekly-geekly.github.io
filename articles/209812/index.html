<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why are there so many Pythons?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python is amazing. 

 Surprisingly, this is a rather ambiguous statement. What do I mean by ‚ÄúPython‚Äù? Maybe an abstract Python interface? Or CPython, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why are there so many Pythons?</h1><div class="post__text post__text-html js-mediator-article">  Python is amazing. <br><br>  Surprisingly, this is a rather ambiguous statement.  What do I mean by ‚ÄúPython‚Äù?  Maybe an abstract Python interface?  Or CPython, a common implementation of Python (not to be confused with a similar Cython name)?  Or do I mean something completely different?  Maybe I indirectly refer to Jython, or IronPython, or PyPy.  Or maybe I digress so much that I‚Äôm talking about RPython or RubyPython (which are very different). <br><br>  Despite the similarity in the names of the above technologies, some of them have completely different tasks (or, at least, work in completely different ways) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When working with Python, I encountered a bunch of such technologies.  * Ython tools.  But only recently I took the time to figure out what they are, how they work and why they (each in its own way) are necessary. <br><br>  In this post, I'll start from scratch and go through the different implementations of Python, and finish with a detailed introduction to PyPy, which, in my opinion, is the future of the language. <br><br>  It all starts with an understanding of what ‚ÄúPython‚Äù really is. <a name="habracut"></a><br><br>  If you have a good understanding of machine code, virtual machines, and so on, you can skip this section. <br><br><h4>  Python interpretable or compiled? </h4><br><br>  This is a common source of misunderstanding among newcomers Python. <br><br>  The first thing you need to understand: ‚ÄúPython‚Äù is an interface.  There is a <a href="http://docs.python.org/2/reference/index.html">specification</a> that describes what Python should do and how it should behave (which is true for any interface).  And there are several implementations (which is also true for any interface). <br><br>  Second: ‚Äúinterpretable‚Äù and ‚Äúcompiled‚Äù are implementation properties, but not interface. <br><br>  So the question itself is not entirely correct. <br><br>  In the case of the most common implementation (CPython: written in C, often simply called ‚ÄúPython‚Äù, and, of course, the one that you use if you have no idea what I'm talking about) the answer: interpreted, with some compilation.  CPython compiles * source code on Python into bytecode, and then interprets this bytecode by running it in the process. <br><br>  <i>* Note: this is not exactly ‚Äúcompilation‚Äù in the traditional sense.</i>  <i>Usually, we think that ‚Äúcompilation‚Äù is a conversion from a high-level language to machine code.</i>  <i>However, in some way it is ‚Äúcompilation‚Äù.</i> <br><br>  Let's explore this answer better, as it will help us understand some of the concepts that await us in this article. <br><br><h4>  Bytecode or machine code </h4><br><br>  It is very important to understand the difference between bytecode and machine (or native) code.  Perhaps the easiest way to understand it is by example: <br><br>  - C is compiled into machine code, which is subsequently run directly by the processor.  Each instruction causes the processor to perform different actions. <br>  - Java is compiled into bytecode, which subsequently runs on a Java Virtual Machine (JVM), an abstract computer that runs programs.  Each instruction is processed by a JVM that interacts with the computer. <br><br>  Strongly simplifying: <b>machine code is much faster, but bytecode is better portable and protected.</b> <br><br>  The machine code may vary depending on the machine, while the bytecode is the same on all machines.  We can say that the machine code is optimized for your configuration. <br><br>  Returning to CPython, the chain of operations looks like this: <br><br>  1. CPython compiles your Python source code into bytecode. <br>  2. This bytecode runs on the CPython virtual machine. <br><br><blockquote>  Newbies often assume that Python is compiled due to the presence of .pyc files.  This is partly true: .pyc files are compiled bytecode, which is subsequently interpreted.  So if you run your code on Python, and you have a .pyc file, then it will work faster the second time, because it won't need to be recompiled into bytecode again. </blockquote><br><br><h4>  Alternative virtual machines: Jython, IronPython, and others </h4><br><br>  As I said above, Python has several implementations.  Again, as mentioned above, CPython is the most popular.  This version of Python is written in C and is considered the default implementation. <br><br>  But what about alternatives?  One of the most prominent is <a href="http://www.jython.org/archive/21/docs/whatis.html">Jython</a> , a Java Python implementation that uses the JVM.  While CPython generates bytecode to run on a CPython VM, Jython generates Java bytecode to run on a JVM (this is the same that is generated when compiling a Java program). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8d/3ff/ab7/a8d3ffab74108d33d3feed2e2c196d11.png"><br><br>  ‚ÄúWhy might you need to use an alternative implementation?‚Äù, You ask.  Well, for starters, <b>different implementations get along well with different sets of technologies</b> . <br><br>  CPython makes it easier to write C extensions for Python code because at the end it is started by the C interpreter.  Jython, in turn, makes it easy to work with other Java programs: you can import any Java classes without any extra effort by invoking and using your Java classes from Jython programs.  (Note: if you haven‚Äôt seriously thought about it yet, it‚Äôs pretty crazy. We have lived up to the time when you can mix different languages ‚Äã‚Äãand compile them into one entity. As <a href="http://www.reddit.com/user/Rostin">Rostin</a> noted, programs mixing code in Fortran with C appeared a long time ago, so it's not entirely new. But it's still cool.) <br><br>  As an example, here is the correct jython code: <br><br> <code>[Java HotSpot(TM) 64-Bit Server VM (Apple Inc.)] on java1.6.0_51 <br> &gt;&gt;&gt; from java.util import HashSet <br> &gt;&gt;&gt; s = HashSet(5) <br> &gt;&gt;&gt; s.add("Foo") <br> &gt;&gt;&gt; s.add("Bar") <br> &gt;&gt;&gt; s <br> [Foo, Bar]</code> <br> <br>  <a href="http://ironpython.net/">IronPython</a> is another popular Python implementation, written entirely in C # and intended for .NET.  In particular, it runs on a .NET virtual machine, if you can call it that, on Microsoft's <a href="http://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime (CLR)</a> , comparable to the JVM. <br><br>  Jython can be said to be: Java :: IronPython: C #.  They run on the appropriate virtual machines, it is possible to import C # classes into IronPython code and Java classes into Jython code, and so on. <br><br>  Quite really survive without touching anything except CPython.  But, moving to other implementations, you get an advantage, mainly because of the stack of technologies used.  Do you use many languages ‚Äã‚Äãbased on JVM?  Jython might suit you.  All on .NET?  Perhaps you should try IronPython (and, perhaps, you already did). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29e/2ab/f88/29e2abf8809b486658fb09922c2fe9f5.png"><br><br>  By the way, although this will not be a reason for switching to another implementation, it is worth mentioning that these implementations are actually different in behavior.  This concerns not only the methods of interpreting Python code.  However, these differences are usually not-significant, they disappear and appear over time due to active development.  For example, IronPython uses <a href="http://ironpython.codeplex.com/wikipage%3Ftitle%3DIPy1.0.xCPyDifferences%26referringTitle%3DHome">Unicode strings by default</a> ;  however, CPython <a href="http://docs.python.org/2/howto/unicode.html">uses ASCII</a> in versions 2.x (yielding a UnicodeEncodeError error for non-ASCII characters), and <a href="http://docs.python.org/3/howto/unicode.html">supports default Unicode characters in versions 3.x.</a> <br><br><h4>  Just-in-Time Compilation: PyPy and the Future </h4><br><br>  So, we have a Python implementation written in C, another one in Java, and a third in C #.  The next logical step: the implementation of Python, written in ... Python.  (A prepared reader will notice that this statement is a bit deceptive). <br><br>  That is why it can be confusing.  To begin with, let's discuss on-the-fly compilation (just-in-time or JIT). <br><br><h5>  Jit  Why and how </h5><br><br>  Let me remind you that native native code is much faster than bytecode.  Well, what if it were possible to compile part of the bytecode and run it as native code?  I would have to ‚Äúpay‚Äù some price (in other words: time) for compiling the bytecode, but if the result is faster, then this is great!  This is what motivates JIT compilation, a hybrid technique that combines the advantages of interpreters and compilers.  In a nutshell, JIT tries to use compilation to speed up the interpretation system. <br><br>  For example, here‚Äôs a common JIT approach: <br><br><ol><li>  Determine the bytecode that runs frequently. </li><li>  Compile it into native machine code. </li><li>  Cache the result. </li><li>  Whenever it is necessary to run the same bytecode, use the already compiled machine code and reap the rewards (in particular, the speed increase). </li></ol><br><br>  This is the whole point of PyPy: use JIT in Python (in addition, you can find previous attempts).  Of course, there are other goals: PyPy aims to be cross-platform, work with a small amount of memory and support for stackless (abandoning the stack of C calls in favor of its own stack).  But JIT is a major advantage.  On average, based on time tests, the acceleration factor is <a href="http://speed.pypy.org/">6.27</a> .  More detailed data can be obtained from the <a href="http://speed.pypy.org/">PyPy Speed ‚Äã‚ÄãCenter</a> scheme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e09/b86/80b/e09b8680b17b1fb72f6b8e75e49a154f.png"><br><br><h5>  PyPy is hard to figure out </h5><br><br>  PyPy has a huge potential, and at the moment it is <a href="http://doc.pypy.org/en/latest/faq.html">well compatible</a> with CPython (so you <a href="http://pypy.org/compat.html">can run Flask, Django</a> , etc. on it). <br><br>  But with PyPy there is a lot of confusion.  (appreciate, for example, this meaningless suggestion to create PyPyPy ...).  In my opinion, the main reason is that PyPy is also: <br><br>  1. The Python interpreter written in <a href="http://doc.pypy.org/en/latest/coding-guide.html">RPython</a> (not Python (I lied to you before)).  RPython is a subset of Python with static typing.  In Python, having a thorough conversation about types is ‚Äú <a href="http://doc.pypy.org/en/latest/faq.html">generally impossible</a> ‚Äù why is it so difficult?  Consider the following: <br><br> <code>x = random.choice([1, "foo"])</code> <br> <br>  This is the correct Python code (thanks to <a href="http://www.reddit.com/user/Ademan">Ademan</a> 's).  What type of x?  How can we discuss variable types when types are not even forced?).  In RPython, we sacrifice some flexibility, but in return we can make it much easier to manage memory and much more, which helps with optimization. <br><br>  2. A compiler that compiles RPython code into different formats and supports JIT.  The default platform is C, that is, the RPython-in-C compiler, but you can also choose JVM and others as the target platform. <br><br>  For ease of description, I will call them PyPy (1) and PyPy (2). <br><br>  Why may need these two things, and why - in one set?  Think of it this way: PyPy (1) is an interpreter written in RPython.  That is, it takes the user code on Python and compiles it into bytecode.  But for the interpreter itself (written in RPython) to work, it must be interpreted by another implementation of Piton, right? <br><br>  So, you can just use <a href="http://www.stavros.io/posts/what-is-pypy/">CPython</a> to run the interpreter.  But it will not be too fast. <br><br>  Instead, we use PyPy (2) (called the <a href="http://doc.pypy.org/en/latest/translation.html">RPython Toolchain</a> ) to compile the PyPy interpreter into code for another platform (for example, C, JVM, or CLI) to run on the target machine, with the addition of JIT.  It's magical: PyPy dynamically adds JIT to the interpreter, generating its own compiler!  (Again, this is insane: we compile the interpreter by adding another separate, independent compiler). <br><br>  In the end, the result will be a standalone executable file that interprets the source code on Python and uses JIT optimization.  Exactly what is needed!  It‚Äôs hard to understand, but perhaps this scheme will help: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a60/643/547/a60643547ead4246eedc7874173b15e0.png"><br><br>  To repeat: the real beauty of PyPy is that we can write a bunch of different Python interpreters in RPython without worrying about JIT (not counting a <a href="http://doc.pypy.org/en/latest/jit/pyjitpl5.html">couple of details</a> ).  PyPy then implements JIT for us using the RPython Toolchain / PyPy (2). <br><br>  In fact, if you dig deeper into the abstraction, you can theoretically write an interpreter of any language, send it to PyPy and get a JIT for that language.  This is possible because PyPy concentrates on optimizing the interpreter itself, rather than the details of the language that it interprets. <br><br>  As a digression, I would like to point out that JIT itself is absolutely amazing.  He uses a technique called ‚Äútracing‚Äù, which works <a href="http://morepypy.blogspot.com/2009/03/applying-tracing-jit-to-interpreter.html">as follows</a> : <br><br><ol><li>  Run the interpreter and interpret everything (without adding a JIT). </li><li>  Perform easy profiling of the interpreted code. </li><li>  Identify operations that have already been performed. </li><li>  Compile these pieces of code into machine code. </li></ol><br><br>  You can learn more from this easily accessible and very interesting <a href="https://bitbucket.org/pypy/extradoc/src/tip/talk/icooolps2009/bolz-tracing-jit-final.pdf">publication</a> . <br><br>  To summarize, we use the RPython-in-C PyPy compiler (or another target plat form) to compile the PyP interpreter implemented in RPython. <br><br><h4>  Conclusion </h4><br><br>  Why is it all so amazing?  Why is it worth chasing this crazy idea?  In my opinion, <a href="http://pypy.org/people.html">Alex Gaynor</a> explained it very well on his <a href="http://alexgaynor.net/2010/may/15/pypy-future-python/">blog</a> : ‚Äú[For the PyPy future] because [he] is faster, more flexible and is the best platform for Python development‚Äù. <br><br>  In short: <br><br><ul><li>  It is fast because it compiles the source code into native code (using JIT). </li><li>  It is flexible - because it adds JIT to the interpreter effortlessly. </li><li>  It is flexible (again) - because you can write interpreters in RPython, which subsequently simplifies the extension compared to the same C (in fact, it simplifies so much that even there is an instruction for writing your own interpreters). </li></ul><br><br><h4>  Addition: other names you may have heard </h4><br><br>  <a href="http://www.python.org/dev/peps/pep-3000/">Python 3000 (Py3k)</a> : the alternative name for Python 3.0, the main release of Python with <a href="http://www.python.org/dev/peps/pep-3000/">backward compatibility</a> , which appeared in <a href="http://python.org/download/releases/3.0/">2008</a> .  year  The Py3k team predicted that it would take about <a href="http://programmers.stackexchange.com/questions/63859/why-do-people-hesitate-to-use-python-3">five years</a> for the new version to take root completely.  And while most (attention: far-fetched statement) Python developers continue to use Python 2.x, people are increasingly thinking about Py3k. <br><br>  <a href="http://cython.org/">Cython</a> : a Python superset that includes the ability to call C functions. <br><ul><li>  Task: allow writing C extensions for Python programs. </li><li>  It also allows you to add <a href="http://docs.cython.org/src/quickstart/cythonize.html">static typing</a> to existing Python code, which, after recompiling, can help achieve C-like performance. </li><li>  Reminds PyPy, but it is not the same.  In the case of Cython, you force typing in user code before serving to the compiler.  In PyPy, you write good old Python, and the compiler is responsible for any optimization. </li></ul><br><br>  <a href="http://numba.pydata.org/">Numba</a> : ‚Äúa specialized just-in-time compiler,‚Äù which adds JIT to the annotated Python code.  Simply put, you give him clues, and he speeds up some parts of your code.  Numba is part of the <a href="http://docs.continuum.io/anaconda/index.html">Anaconda</a> distribution of a set of packages for analyzing and managing data. <br><br>  <a href="http://ipython.org/index.html">IPython</a> : is very different from everything we discussed.  Computing environment for Python.  Interactive, with support for GUI packages, browsers, and so on. <br><br>  <a href="http://psyco.sourceforge.net/">Psyco</a> : <a href="http://rayli.net/blog/2010/04/what-is-the-purpose-of-pypy/">Python expansion module</a> , one of the first attempts of Python in the JIT area.  Long marked as <a href="http://psyco.sourceforge.net/">‚Äúunsupported and dead‚Äù</a> .  Psyco's lead developer <a href="http://pypy.org/people.html">Armin Rigo is currently working on PyPy</a> . <br><br><h5>  Language bindings </h5><br><br><ul><li>  <a href="http://rubypython.rubyforge.org/">RubyPython</a> : a bridge between Ruby and Python virtual machines.  Allows you to embed Python code into Ruby code.  You designate where Python begins and ends, and RubyPython provides data transfer between virtual machines. <br></li><li>  <a href="http://pythonhosted.org/pyobjc/">PyObjc</a> : a language connection between Python and Objective-C that behaves like a bridge between them.  In practice, this means that you can use Objective-C libraries (including everything you need to create an application under OS X) in Python code, and Python modules in Objective-C code.  This is convenient because CPython is written in C, which is a subset of Objective-C. <br></li><li>  <a href="http://www.riverbankcomputing.com/software/pyqt/intro">PyQt</a> : while PyObjc allows you to associate Python with OS X GUI components, PyQt does the same for the Qt framework.  This makes it possible to create full-fledged graphical interfaces, access SQL databases, and so on.  Another tool aimed at porting the simplicity of Python to other frameworks. <br></li></ul><br><br><h5>  Javascript frameworks </h5><br><br><ul><li>  <a href="http://pyjs.org/">pyjs (Pajamas)</a> : a framework for creating web and desktop applications on Python.  Includes a Python-to-JavaScript compiler, a set of widgets and some other tools. <br></li><li>  <a href="http://www.brython.info/">Brython</a> : a Python virtual machine written in Javascript.  Allows you to run Py3k code in a web browser. <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/209812/">https://habr.com/ru/post/209812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209794/index.html">Whatsapp: "We will always have time to earn money"</a></li>
<li><a href="../209796/index.html">Music Box on PIC16F753</a></li>
<li><a href="../209800/index.html">Clash of Clans traffic scandal, Zynga sad results of the year and other news of the week for a mobile developer</a></li>
<li><a href="../209808/index.html">Tablet Lenovo Yoga Tablet 10: tested in humans</a></li>
<li><a href="../209810/index.html">Stock Market Tools: Derivatives</a></li>
<li><a href="../209814/index.html">New payment method: Bitcoin and Litecoin</a></li>
<li><a href="../209816/index.html">Day-to-Day Service Plan - Part 2: Automatic Update of Statistics</a></li>
<li><a href="../209818/index.html">FORTH: nano-servers and nanoclients. Part 1</a></li>
<li><a href="../209820/index.html">Validating Forms in a Declarative Style (C #)</a></li>
<li><a href="../209822/index.html">Testers - a supporting role?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>