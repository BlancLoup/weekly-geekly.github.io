<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Urban legends about slow calls to virtual functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traditionally, compilers implement virtual function calls via dual indirect addressing - if a class contains at least one virtual function, then the a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Urban legends about slow calls to virtual functions</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/7eb/65b/430/7eb65b43013a4e6fac9fbc149552ca0e.jpg" align="right">  Traditionally, compilers implement virtual function calls via dual indirect addressing - if a class contains at least one virtual function, then the address of the virtual function table is stored at the beginning of each object of this class.  If the compiler does not know the specific type of object pointed to by the pointer, then to call a virtual function, you must first take a pointer to the object, read the address of the beginning of the table, then read the address where the function implementation is stored, then call the function. <br><br>  The process of searching for a specific function by a pointer to an object is called late binding and is performed while the program is running.  Late binding not only increases the call overhead, but also prevents the compiler from optimizing the code.  Because of this, the virtual functions themselves are considered to be slowing down the work. <br><br>  In the text above, the ‚Äúif‚Äù keyword.  What if the compiler knows which function to actually call? <br><a name="habracut"></a><br>  In the Standard (hereinafter referred to as C ++ 03 Standard Reference), nothing is said about virtual method tables.  Instead, 5.2.2 / 1 ([expr.call], ‚Äúfunction call‚Äù) states that if a program contains a virtual function call, the corresponding function must be called, selected according to the rules of 10.3 / 2 ([class.virtual ], ‚ÄúVirtual functions‚Äù), and it says that TL; DR;  A function must be selected from the derived class itself, in which the function is defined or redefined. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Accordingly, if the compiler can, having parsed the code, find out the exact type of the object, it does not have to use late binding - and it does not matter if the method is called from a specific object, by reference or by pointer to the object. <br><br>  From meaningless reasoning, let's move on to the code that we will try on <a href="http://gcc.godbolt.org/">gcc.godbolt.org</a> <br><br>  We need these two classes: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Magic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">9000</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Magic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100500</span></span>; } };</code> </pre> <br><br>  To begin with such code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Derived derived; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> derived.Magic(); }</code> </pre><br>  clang 3.4.1 with -O2 responds to this like this: <br><pre> <code class="hljs mel">main: # @main movl $100500, %eax # imm = <span class="hljs-number"><span class="hljs-number">0x18894</span></span> ret</code> </pre><br>  It is easy to see that the machine code corresponds to a program containing only <i>return 100500;</i>  This is not particularly interesting - because there are no pointers and links. <br><br>  Okay, slowly stirring, add pointers and links: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Base&amp; object )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object.Magic(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base* base = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Derived(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = magic( *base ); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> base; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  clang 3.4.1 with -O2 responds to this like this: <br><pre> <code class="hljs mel">magic(Base&amp;): # @magic(Base&amp;) movq (%rdi), %rax jmpq *(%rax) # TAILCALL main: # @main movl $100500, %eax # imm = <span class="hljs-number"><span class="hljs-number">0x18894</span></span> ret</code> </pre><br><br>  <s>OX YEARS COMPILER ERROR</s> No, the compiler is fine, but the aggressiveness of optimization cannot be denied.  Again <i>return 100500;</i> <br><br>  For comparison, gcc 4.9.0 with -O2: <br><br><pre> <code class="hljs perl">main: subq $8, %rsp movl $8, %edi call operator new(unsigned long) movq vtable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Derived+<span class="hljs-number"><span class="hljs-number">16</span></span>, (%rax) movq %rax, %rdi call Derived::~Derived() movl $10050<span class="hljs-number"><span class="hljs-number">0</span></span>, %eax addq $8, %rsp ret</code> </pre><br><br>  <i>call Derived :: ~ Derived ()</i> - because of the virtual destructor, gcc in such cases puts the call <i>:: operator delete ()</i> inside the destructor: <br><br><pre> <code class="hljs pgsql">Derived::~Derived(): jmp <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-type"><span class="hljs-type">void</span></span>*)</code> </pre><br>  although it could and place in place.  Like this: <br><pre> <code class="hljs pgsql"> movq %rax, %rdi <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-type"><span class="hljs-type">void</span></span>*)</code> </pre><br>  Could, but did not.  At the same time, the body of the <i>Derived :: Magic ()</i> method is substituted into the place of the call and optimized along with the surrounding code. <br><br>  A small digression ... If you like to talk at length about how well the compiler can in principle optimize the code, the example above is for you.  Both the call to <i>Derived :: Magic ()</i> , and the compiler could optimize the removal of the object with equal success, but one of them was optimized, and the second was not.  Retreat is over. <br><br>  For comparison, gcc 4.9.0 with -O1 <br><br><pre> <code class="hljs perl">magic(Base&amp;): subq $8, %rsp mov<span class="hljs-string"><span class="hljs-string">q (%rdi)</span></span>, %rax call *(%rax) addq $8, %rsp ret main: pushq %rbp pushq %rbx subq $8, %rsp movl $8, %edi call operator new(unsigned long) movq %rax, %rbx movq vtable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Derived+<span class="hljs-number"><span class="hljs-number">16</span></span>, (%rax) movq %rax, %rdi call magic(Base&amp;) movl %eax, %ebp testq %rbx, %rbx je .L12 mov<span class="hljs-string"><span class="hljs-string">q (%rbx)</span></span>, %rax movq %rbx, %rdi call *<span class="hljs-number"><span class="hljs-number">16</span></span>(%rax) .L12: movl %ebp, %eax addq $8, %rsp popq %rbx popq %rbp ret</code> </pre><br><br>  Here, maybe because, if you ask well.  In this code, ‚Äúeverything is in order‚Äù is a bunch of memory accesses and method invocation by a call instruction with indirect addressing ( <i>call * 16 (% rax)</i> ). <br><br>  However, success examples with -O2 look far-fetched - all the code is in one translation unit, and this greatly simplifies optimization. <br><br>  <a href="https://gcc.gnu.org/wiki/LinkTimeOptimization">LTO is</a> in a hurry to help (or whatever it is called optimization of several translation units in your compiler). <br><br>  We divide the code into several translation units ... <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Classes.h class Base { public: virtual int Magic(); virtual ~Base(); }; class Derived : public Base { public: virtual int Magic(); }; //Classes.cpp #include &lt;Classes.h&gt; #include &lt;stdio.h&gt; Base::~Base() { } int Base::Magic() { return 9000; } int Derived::Magic() { return 100500; } //main.cpp #include &lt;Classes.h&gt; int magic( Base&amp; object ) { return object.Magic(); } int main() { Base* base = new Derived(); int result = magic( *base ); delete base; return result; }</span></span></code> </pre><br><br>  Hereinafter we will use MinGW with gcc 4.9.0 <br><br><pre> <code class="bash hljs">g++ -flto -g -O3 main.cpp Classes.cpp objdump -d -M intel -S --no-show-raw-insn a.exe &gt;a.txt</code> </pre><br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-number"><span class="hljs-number">402830</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp <span class="hljs-number"><span class="hljs-number">402831</span></span>: mov ebp,esp <span class="hljs-number"><span class="hljs-number">402833</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> esp,<span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span> <span class="hljs-number"><span class="hljs-number">402836</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span><span class="hljs-function">,0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x10</span></span></span><span class="hljs-function"> 402839: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> 402050 &lt;___</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Base</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derived</span></span></span></span>(); <span class="hljs-number"><span class="hljs-number">40283</span></span>e: mov DWORD PTR [esp],<span class="hljs-number"><span class="hljs-number">0x4</span></span>  ::operator new() <span class="hljs-number"><span class="hljs-number">402845</span></span>: call <span class="hljs-number"><span class="hljs-number">4015</span></span>d8 &lt;__Znwj&gt;    vtable <span class="hljs-number"><span class="hljs-number">40284</span></span>a: mov DWORD PTR [eax],<span class="hljs-number"><span class="hljs-number">0x404058</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = magic( *base ); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> base; <span class="hljs-number"><span class="hljs-number">402850</span></span>: mov ecx,eax <span class="hljs-number"><span class="hljs-number">402852</span></span>: call <span class="hljs-number"><span class="hljs-number">4015</span></span>c<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;__ZN7DerivedD0Ev&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }       <span class="hljs-number"><span class="hljs-number">402857</span></span>: mov eax,<span class="hljs-number"><span class="hljs-number">0x18894</span></span> <span class="hljs-number"><span class="hljs-number">40285</span></span>c: leave <span class="hljs-number"><span class="hljs-number">40285</span></span>d: ret</code> </pre><br>  Here we are interested in the instruction <i>mov eax, 0x18894</i> (100500 in hexadecimal notation) - again the compiler chose the necessary function, substituted its body into the place of the call and optimized the surrounding code. <br><br>  Too easy, so we add a factory (Derived and Base are the same) ... <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Factory.h #include &lt;Classes.h&gt; class Factory { public: static Base* CreateInstance(); }; //Factory.cpp #include &lt;Factory.h&gt; Base* Factory::CreateInstance() { return new Derived(); } //main.cpp #include &lt;Factory.h&gt; int magic( Base&amp; object ) { return object.Magic(); } int main() { Base* base = Factory::CreateInstance(); int result = magic( *base ); delete base; return result; }</span></span></code> </pre><br>  Compile, disassemble ... Initially, the result does not look very clear - due to aggressive optimization, the machine code and source code were not matched in the most convenient way to read, the machine code below is left as is, and some source code lines are placed as close as possible to the corresponding machine code. <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-number"><span class="hljs-number">402830</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp <span class="hljs-number"><span class="hljs-number">402831</span></span>: mov ebp,esp <span class="hljs-number"><span class="hljs-number">402833</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi <span class="hljs-number"><span class="hljs-number">402834</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx <span class="hljs-number"><span class="hljs-number">402835</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> esp,<span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span> <span class="hljs-number"><span class="hljs-number">402838</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span><span class="hljs-function">,0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x10</span></span></span><span class="hljs-function"> 40283</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> 402050 &lt;___</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derived</span></span></span></span>(); <span class="hljs-number"><span class="hljs-number">402840</span></span>: mov DWORD PTR [esp],<span class="hljs-number"><span class="hljs-number">0x4</span></span>  ::operator new() <span class="hljs-number"><span class="hljs-number">402847</span></span>: call <span class="hljs-number"><span class="hljs-number">4015</span></span>d8 &lt;__Znwj&gt; <span class="hljs-number"><span class="hljs-number">40284</span></span>c: mov ebx,eax <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> magic( Base&amp; object ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object.Magic(); <span class="hljs-number"><span class="hljs-number">40284</span></span>e: mov ecx,eax    vtable <span class="hljs-number"><span class="hljs-number">402850</span></span>: mov DWORD PTR [eax],<span class="hljs-number"><span class="hljs-number">0x404058</span></span>   Derived::Magic() <span class="hljs-number"><span class="hljs-number">402856</span></span>: call <span class="hljs-number"><span class="hljs-number">401580</span></span> &lt;__ZN7Derived5MagicEv&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> base; <span class="hljs-number"><span class="hljs-number">40285</span></span>b: mov ecx,ebx <span class="hljs-number"><span class="hljs-number">40285</span></span>d: mov esi,eax <span class="hljs-number"><span class="hljs-number">40285</span></span>f: call <span class="hljs-number"><span class="hljs-number">4015</span></span>b<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;__ZN7DerivedD0Ev&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-number"><span class="hljs-number">402864</span></span>: lea esp,[ebp-<span class="hljs-number"><span class="hljs-number">0x8</span></span>] <span class="hljs-number"><span class="hljs-number">402867</span></span>: mov eax,esi <span class="hljs-number"><span class="hljs-number">402869</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx <span class="hljs-number"><span class="hljs-number">40286</span></span>a: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> esi <span class="hljs-number"><span class="hljs-number">40286</span></span>b: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp <span class="hljs-number"><span class="hljs-number">40286</span></span>c: ret ( )</code> </pre><br><br>  Here we are interested in the string <br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">402856</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-number"><span class="hljs-number">401580</span></span> &lt;__ZN7Derived5MagicEv&gt;</code> </pre><br><br>  This is a direct call to <i>Derived :: Magic ()</i> : <br><pre> <code class="hljs cpp"> <span class="hljs-number"><span class="hljs-number">00401580</span></span> &lt;__ZN7Derived5MagicEv&gt;: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Derived::Magic() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100500</span></span>; } <span class="hljs-number"><span class="hljs-number">401580</span></span>: mov eax,<span class="hljs-number"><span class="hljs-number">0x18894</span></span> <span class="hljs-number"><span class="hljs-number">401585</span></span>: ret</code> </pre><br><br>  The compiler correctly determined which function to call, but did not substitute the body of the function in the place of the call. <br><br>  Parameterize the factory (Base and Derived are the same) ... <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Factory.h #include &lt;Classes.h&gt; enum ClassType { BaseType, DerivedType }; class Factory { public: static Base* CreateInstance(ClassType classType); }; //Factory.cpp #include &lt;Factory.h&gt; Base* Factory::CreateInstance(ClassType classType) { switch( classType ) { case BaseType: return new Base(); case DerivedType: return new Derived(); } } //main.cpp #include &lt;Factory.h&gt; int magic( Base&amp; object ) { return object.Magic(); } int main() { Base* base = Factory::CreateInstance(DerivedType); int result = magic( *base ); delete base; return result; }</span></span></code> </pre><br>  We get ... the same code as in the previous attempt. <br><br>  Now <s>party hard</s> will calculate the factory parameter when the program runs ... <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Factory.h&gt; #include &lt;cstdlib&gt; int magic( Base&amp; object ) { return object.Magic(); } int main() { Base* base = Factory::CreateInstance(rand() ? BaseType : DerivedType); int result = magic( *base ); delete base; return result; }</span></span></span></span></code> </pre><br>  We get ... (the result again does not look very clear) <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-number"><span class="hljs-number">402830</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp <span class="hljs-number"><span class="hljs-number">402831</span></span>: mov ebp,esp <span class="hljs-number"><span class="hljs-number">402833</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> esi <span class="hljs-number"><span class="hljs-number">402834</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx <span class="hljs-number"><span class="hljs-number">402835</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> esp,<span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span> <span class="hljs-number"><span class="hljs-number">402838</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span><span class="hljs-function">,0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x10</span></span></span><span class="hljs-function"> 40283</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> 402050 &lt;___</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Base</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Factory</span></span></span><span class="hljs-function">::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateInstance</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>() ? BaseType : DerivedType);  <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>() <span class="hljs-number"><span class="hljs-number">402840</span></span>: call <span class="hljs-number"><span class="hljs-number">4027</span></span>c8 &lt;_rand&gt; Base* Factory::CreateInstance(ClassType classType) { switch( classType ) {        switch <span class="hljs-number"><span class="hljs-number">402845</span></span>: test eax,eax <span class="hljs-number"><span class="hljs-number">402847</span></span>: mov DWORD PTR [esp],<span class="hljs-number"><span class="hljs-number">0x4</span></span>  <span class="hljs-number"><span class="hljs-number">40284</span></span>e: jne <span class="hljs-number"><span class="hljs-number">402875</span></span> &lt;_main+<span class="hljs-number"><span class="hljs-number">0x45</span></span>&gt;  <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>()   ,      <span class="hljs-number"><span class="hljs-number">402875</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>()  ,    ... case DerivedType: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Derived();  ::operator new() <span class="hljs-number"><span class="hljs-number">402850</span></span>: call <span class="hljs-number"><span class="hljs-number">4015</span></span>d8 &lt;__Znwj&gt;    vtable  Derived <span class="hljs-number"><span class="hljs-number">402855</span></span>: mov DWORD PTR [eax],<span class="hljs-number"><span class="hljs-number">0x404070</span></span> <span class="hljs-number"><span class="hljs-number">40285</span></span>b: mov ebx,eax <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> magic( Base&amp; object ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object.Magic();      -   <span class="hljs-string"><span class="hljs-string">""</span></span> ,     ,    <span class="hljs-number"><span class="hljs-number">402875</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>() != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">40285</span></span>d: mov eax,DWORD PTR [ebx] <span class="hljs-number"><span class="hljs-number">40285</span></span>f: mov ecx,ebx   Magic() <span class="hljs-number"><span class="hljs-number">402861</span></span>: call DWORD PTR [eax] <span class="hljs-number"><span class="hljs-number">402863</span></span>: mov esi,eax <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> base; <span class="hljs-number"><span class="hljs-number">402865</span></span>: mov eax,DWORD PTR [ebx] <span class="hljs-number"><span class="hljs-number">402867</span></span>: mov ecx,ebx     <span class="hljs-number"><span class="hljs-number">402869</span></span>: call DWORD PTR [eax+<span class="hljs-number"><span class="hljs-number">0x8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-number"><span class="hljs-number">40286</span></span>c: lea esp,[ebp-<span class="hljs-number"><span class="hljs-number">0x8</span></span>] <span class="hljs-number"><span class="hljs-number">40286</span></span>f: mov eax,esi <span class="hljs-number"><span class="hljs-number">402871</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx <span class="hljs-number"><span class="hljs-number">402872</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> esi <span class="hljs-number"><span class="hljs-number">402873</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp <span class="hljs-number"><span class="hljs-number">402874</span></span>: ret Base* Factory::CreateInstance(ClassType classType) { switch( classType ) { case BaseType: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Base();        <span class="hljs-number"><span class="hljs-number">40284</span></span>e  <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>() != <span class="hljs-number"><span class="hljs-number">0</span></span>  ::operator new() <span class="hljs-number"><span class="hljs-number">402875</span></span>: call <span class="hljs-number"><span class="hljs-number">4015</span></span>d8 &lt;__Znwj&gt;    vtable  Base <span class="hljs-number"><span class="hljs-number">40287</span></span>a: mov DWORD PTR [eax],<span class="hljs-number"><span class="hljs-number">0x404058</span></span> <span class="hljs-number"><span class="hljs-number">402880</span></span>: mov ebx,eax         <span class="hljs-number"><span class="hljs-number">402882</span></span>: jmp <span class="hljs-number"><span class="hljs-number">40285</span></span>d &lt;_main+<span class="hljs-number"><span class="hljs-number">0x2d</span></span>&gt;</code> </pre><br><br>  Quite a curious result.  The factory method code is completely in place.  Depending on the result of the <i>rand ()</i> function call, right inside <i>main ()</i> , branching and creation of instances of the corresponding classes are performed.  The compiler could have placed further direct calls in each branch, but did not cope with the optimization and slipped into two indirect calls ‚Äî one to call the <i>Magic ()</i> method with late binding, and the second to remove the object, also with late binding. <br><br>  As you can see, calls to virtual functions do not require the use of late binding, and what happens in the real world depends on the compiler, its settings, and the specific code. <br><br>  <i>Dmitry Mescheryakov,</i> <i><br></i>  <i>product department for developers</i> </div><p>Source: <a href="https://habr.com/ru/post/248429/">https://habr.com/ru/post/248429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248419/index.html">We build the backdoor in Bitcoin (ECDSA) or again on kleptography</a></li>
<li><a href="../248421/index.html">Manchester United has become a partner of KamaGames, Kabam continues to buy studios, Samsung has released a smartphone under its own OS - and other news of the week for a mobile developer</a></li>
<li><a href="../248423/index.html">Why SCADA when there is .NET?</a></li>
<li><a href="../248425/index.html">Firewood, electricity and SMS - continued</a></li>
<li><a href="../248427/index.html">Divine authentication approach</a></li>
<li><a href="../248431/index.html">New game development bugs</a></li>
<li><a href="../248435/index.html">NSA Curious Look: What is the War for Internet Security (Part 1)</a></li>
<li><a href="../248439/index.html">Mobile App Distribution Services for iOS. Part 1: TestFlight</a></li>
<li><a href="../248441/index.html">8 varieties of muda in your web studio</a></li>
<li><a href="../248443/index.html">Simple solutions. We pump pictures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>