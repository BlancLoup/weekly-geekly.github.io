<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Future OpenSIPS Design</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 OpenSIPS is a signaling SIP switch. If you really want to handle a lot of SIP-calls, then, most likely, you will not pass by OpenSIPS. 
 Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Future OpenSIPS Design</h1><div class="post__text post__text-html js-mediator-article"><h6>  Foreword </h6><br>  OpenSIPS is a signaling SIP switch.  If you really want to handle a lot of SIP-calls, then, most likely, you will not pass by OpenSIPS. <br>  The system is really "mature", tested in battle and, over time, overgrown with many useful (and not very) modules. <br><br>  At the same time, it is obvious that the architecture, laid back in 2001, does not meet modern requirements. <br>  Therefore, the developers of OpenSIPS said that version 2.0 will be maintained "from scratch". <br><br>  The following is a translation of the <a href="http://goo.gl/9vNz">OpenSIPS 2.0 Design</a> document.  I wonder what the habrasoobschestvo thinks about this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Comments on the merits, I will try to convey to the developers. <br><br><h5>  Why do we need a new architecture </h5><br>  The current OpenSIPS architecture (prior to version 2.0) is based on concepts that are over 7 years old.  At that time, the requirements were simple (a simple stateless SIP proxy, only UDP) and decisions were made in accordance with these requirements.  But with all the additions, both in SIP and functionality (such as TCP / TLS, script manipulation, dialog support, integration with external systems, etc.), the existing architecture can no longer meet the requirements and actual usage scenarios. <br><br>  Attention!  Inside a large and structured text with pictures. <br><a name="habracut"></a><br><br>  The problems that the new architecture is designed to solve: <br><ul><li>  I / O locks (transport, DB, applications) </li><li>  Scaling with hardware resources (I / O and synchronization of parallel processes are a bottleneck in the current architecture) </li><li>  When designing a configuration, one has to deal with low-level functions (TM, dialogs, NAT) instead of focusing on the logic of service provision. </li><li>  Horizontal scaling (both kernel and routing logic) </li><li>  The routing mechanism (in the form of a specialized programming language) has a very limited set of non-SIP capabilities (integration with other applications, complex logic of the routing script, working with arrays and lists, support for complex operations and data types) and requires additional skills from the administrator. </li><li>  The routing mechanism is too closely tied to the SIP stack, which makes it impossible to change it on the fly without restarting OpenSIPS. </li><li>  Unable to do distributed routing between multiple systems (to improve scalability). </li></ul><br><h5>  Overview of the new architecture </h5><br>  The new architecture was developed taking into account the problems and successful solutions in the current architecture, and also takes into account the development directions of SIP and OpenSIPS. <br>  At the top level, OpenSIPS will consist of two completely independent parts: <br><ul><li>  SIP core (SIP-core) - provides support for low-level operations with SIP </li><li>  Routing Engine (Routing Engine) - is responsible for high-level routing logic </li></ul><br>  It is assumed that several routing servers will be able to connect to the same core in order to implement different functionalities, or simply to increase the capacity of the system as a whole. <br><br><h5>  SIP core </h5><br>  The kernel is a low-level component that provides the functionality associated with SIP.  They can run automatically and do not require complex configuration.  Core will be responsible for the transport layer, packet analysis, transactions and dialogs, automatic support for passing through NAT, SIP registrations and online statuses (presences), functions that are clearly defined in the RFC and do not require any intervention from the high-level Subsystem routing. <br><br>  The kernel is divided into several horizontal levels, each of which performs certain functions: <br><ul><li>  L <sub>0</sub> - Transport layer.  Implements support for UDP, TCP, TLS, SCTP and hides all the specific features for transport </li><li>  L <sub>1</sub> - SIP parser layer (SIP parser layer).  Responsible for parsing SIP messages </li><li>  L <sub>2</sub> - Transaction Level - implements support for SIP transactions.  Each incoming SIP message is associated with a SIP transaction. </li><li>  L <sub>3</sub> - Dialog Level - implements support for SIP dialogs.  SIP message can be associated with SIP dialogue </li><li>  L <sub>4</sub> - Pass through NAT level - automatic handler for passing through NAT (support at the level of SIP signaling and transport) </li><li>  L <sub>5</sub> - Level of support of online statuses (presence) - implements the SIP Presence Agent.  Automatic processing of messages related to online statuses. </li><li>  L <sub>6</sub> and up ... as needed, other levels can be added (such as user location). </li><li>  L <sub>p</sub> - the last level is the level that provides interaction with the Routing Engine (via API or socket) </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/86c/01a/706/86c01a70620ba325b6f82c5ea0fe1e11.png" alt="image"><br><br><h5>  Core structure </h5><br>  SIP message arrives at the lower level L <sub>0</sub> .  Each level processes the message and either passes it to the next level or returns it to the level below.  If a return occurs, it means that the message processing is finished at this level (for example, this is how automatic responses to KeepAlive messages or resending packets work).  When a message reaches the layer that provides interaction with the routing server, the message is transmitted (with all the changes that were made at each level) to the routing server, which continues further processing of the message.  Then the message is returned back along the path that goes from top to bottom from level to level until it reaches the transport level (L <sub>0</sub> ) and is not sent to the network. <br><br>  The kernel has two message flows: <br><ul><li>  Incoming flow (from bottom to top) - the incoming message is sent up, being subjected to changes at each level, until it reaches a place where a decision can be made about what to do with the message (this can be either in one of the Kernel levels or in the Routing Subsystem ). </li><li>  Outgoing flow (from top to bottom) - when the decision about what to do with the message is made, the message goes back through all the layers that it passed until it is sent to the network. </li></ul><br>  In both flows, each level can perform different actions (for example, the SIP analyzer level parses messages from the incoming stream and collects them back, putting them into the outgoing stream). <br><br>  SIP messages are read from the network to the network by the L <sub>0</sub> level (transport layer), and then they are transmitted to higher levels.  Each layer performs the appropriate actions: for example, the SIP analyzer level will add parsed data to the message, the transaction level will add the transaction identifier, the dialog level will add the dialogue identifier, etc.  After completing its task, a level can: (a) send a message to a higher level for processing (if the current level cannot complete processing) or (b) decide what to do with the message and transfer the message to the outgoing stream for sending (in this case , all higher levels will be skipped). <br><br>  This algorithm provides the most efficient processing of messages at each level.  It is not necessary to pass all messages through all levels up to the Routing Subsystem if the message can be processed automatically using lower levels.  For example, responses to keepalive messages can be automatically processed by the Kernel at the L4 level (passing through NAT).  Another example is when the Routing Subsystem is only interested in receiving and processing initial requests.  In this case, subsequent requests will be automatically processed and routed using the level of the dialogs without the need to pass them further along the chain. <br><br>  In addition to the tiers, the Kernel also implements several database backends.  They are used to save between restarts of internal data that each of the levels of the Kernel stores in memory (dialogs, online statuses, registrations, information for passing through NAT). <br><br>  Inside the Core, levels can be divided by importance: <br><ul><li>  Base core - includes mandatory levels (L <sub>0</sub> -L <sub>3</sub> and L <sub>n</sub> ).  They provide the features that are always required. </li><li>  Additional levels (L <sub>4</sub> - L <sub>n-1</sub> ), which provide optional functions.  They can be connected or disconnected during operation. </li></ul><br>  The kernel has its own configuration file, which contains parameters for the main levels and backends of the databases: what network interfaces to listen on, transaction parameters, dialog parameters, etc. <br><br>  The kernel is implemented as an asynchronous reactor that supports non-blocking I / O.  For efficient use of resources on machines with multi-core processors, the Kernel uses several threads (by the number of CPU cores). <br><br><h4>  Routing Engine </h4><br>  The routing subsystem performs routing, for which the configuration script is responsible for the current version of OpenSIPS, and provides the functionality of most of the currently existing modules. <br><br>  The routing subsystem runs on top of the kernel as a separate component.  As mentioned earlier, several Routing Subsystems can be connected to a single Core, either for implementing various services or to increase system capacity by distributing the load across several physical machines. <br><br>  The new design allows you to use two approaches to connect the kernel with the routing subsystem: <br><ul><li>  The routing logic is in the form of a library, which is closely related to the Core, and implements several additional levels and modules on top of the Core.  They are interconnected within a single executable file. </li><li>  Routing logic in the form of an external application that communicates with the kernel using a socket.  This application can be written in a high level language such as Python or Java. </li></ul><br>  Why use two approaches?  These two options do not exclude, but complement each other - the internal Routing Server is more efficient in terms of performance and manageability (due to tight integration with the Core directly at the C level), while the external Routing Subsystem will be much more universal and easier to implement ( application in high level language), which is much easier to control. <br><br><h5>  Internal Routing Module </h5><br>  The routing module is a set of additional levels represented as a library that will be connected to the Core, forming a single application.  The routing module includes: <br><ul><li>  Script interpreter - for logic implementation </li><li>  Additional modules - to support ready-made functionality in the script </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/bb5/971/35bbb597177c9e419e730180e1b3ba73.png" alt="image"><br><br><h5>  Internal routing subsystem </h5><br>  The script interpreter is based on an existing specialized language with the ability to directly insert blocks in a high-level language (for example, embedded Perl).  Depending on the degree of impact on performance, you can completely replace a specialized script with a high-level language (for example, all the logic of the Routing Module should be written in Perl from which the functions of the Kernel or modules in C are called). <br><br>  In the new architecture, it remains possible to use the existing native script, because its interpreter is very fast, and it is perfect for configurations with simple logic and copes well with high loads. <br><br>  Embedding scripts in high-level languages ‚Äã‚Äãalso looks useful, as this solution greatly simplifies the implementation of scripts that require complex routing logic required, which can be implemented using high-level language features.  In addition to reducing the complexity of writing complex scripts, this opportunity eliminates the need to learn a specialized built-in scripting language.  However, in this case, there will be some performance degradation, since the interpreters of high-level languages ‚Äã‚Äãare heavier and slower.  On the other hand, the use of high-level languages ‚Äã‚Äãwill allow for horizontal scaling.  Imagine an OpenSIPS cluster (on several servers), where all the Routing Subsystems (using the features of the high-level language and data storage technology) are connected to the network and behave as a single entity - like a global Routing Server that uses several OpenSIPS cores. <br><br>  Routing subsystem modules that provide predefined functions (dialplan, LCR, QoS, B2BUA, etc.) can be used from a script, regardless of its format. <br><br>  It is possible to reload the script during operation. <br><br><h5>  External routing subsystem </h5><br>  As well as the built-in, external Routing Subsystem (or application) is implemented as a set of levels through which messages pass in two directions (bottom to top and top to bottom).  These layers are completed with a layer that implements the routing logic for a particular SIP service.  The last layer is equivalent to the script used in the old architecture. <br><br>  Some of the levels are active - this means that they change the messages during the transfer and may decide to stop relaying the messages to the top, complete processing and return the message to the bottom.  This is done either by analyzing the content of the message, or based on instructions from the previous level of routing.  Some other levels are passive.  This means that they only provide classes and functions that implement certain capabilities (for example, LCR or call control), but they are not used for end-to-end transmission of messages between levels upward.  They are called explicitly from the routing logic and change the message. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5bb/825/f53/5bb825f53a328ee88783ffbbe207951c.png" alt="image"><br><br><h5>  Routing subsystem as an application </h5><br>  An application registers with a specific Kernel (or on several Kernels, if necessary) and reports its capabilities to the Kernel.  Features include messages that the Routing Subsystem and Restrictions are interested in.  This allows the Kernel to filter which messages and how many to pass to this application.  In addition, an application can request the kernel to dynamically enable / disable some of the optional levels of the kernel when the kernel decides that a message should be sent to this application.  This allows you to create flexible configurations in which a particular application can, for example, tell the Kernel that for all messages that are sent to a particular application, disable the level of NAT passing.  As a result, when the Kernel sends a message to this application, it will pass the level of access through NAT.  This means that the application wants to deal with passing through NAT on its own.  This also means that the application will receive keepalive messages.  Other applications, if they have not disabled this level, will not see keepalive messages and will not solve the problem of passing through NAT, because the level of passing through NAT will be used.  This allows you to get a very flexible configuration, where some of the optional Kernel levels can be turned on or off during runtime without having to change the Core configuration or reboot the Core. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a40/34e/4df/a4034e4df9807b02bb7d91969174be95.png" alt="image"><br><br><h5>  Multiple applications with one core </h5><br>  The entire application can be written in a high level language such as Python.  The implementation in OpenSIPS will provide all the necessary functions that will allow the user to write high-level routing logic.  This corresponds to the last level in the application diagram.  This will resemble the existing script, only it will be written in the same language (Python in this case) as the rest of the application.  Of course, the application can be implemented in other languages, such as Java, Ruby or Perl. <br><br>  Each of us <a href="http://www.opensips.org/Development/Contributing">can help</a> the OpenSIPS project. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/106719/">https://habr.com/ru/post/106719/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../106713/index.html">RusTalk speaks and explains!</a></li>
<li><a href="../106714/index.html">The leaders of Tvzavr.ru, Zoomby.ru and Tvigle.ru urged search engines to stop indexing sites with illegal content.</a></li>
<li><a href="../106716/index.html">Chromeless: do-it-yourself browser interface (HTML, CSS and JS)</a></li>
<li><a href="../106717/index.html">Why gradle?</a></li>
<li><a href="../106718/index.html">Where is my button?</a></li>
<li><a href="../106720/index.html">Foursquare social geoservice stepped into space</a></li>
<li><a href="../106721/index.html">For developers on PS3, a normal EA web browser is available.</a></li>
<li><a href="../106722/index.html">What's new in Quest vWorkspace 7.2 Beta 2?</a></li>
<li><a href="../106726/index.html">Silverlight Migration Applications from Prism 2.2 to Prism 4 MEF edition</a></li>
<li><a href="../106729/index.html">C # for beginners. Lecture 1 - Introduction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>