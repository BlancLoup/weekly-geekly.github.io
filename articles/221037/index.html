<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the DiagnosticSource in .NET Core: Practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, I talked about the DiagnosticSource mechanism and, using a simple example, showed how to use it to intercept queries into the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the DiagnosticSource in .NET Core: Practice</h1><div class="post__text post__text-html js-mediator-article"><p> In the <a href="https://habr.com/ru/company/ozontech/blog/435896/">previous article,</a> I talked about the DiagnosticSource mechanism and, using a simple example, showed how to use it to intercept queries into the database through the <code>SqlConnection</code> and <code>SqlCommand</code> classes and measure their execution time. </p><br><p>  Currently, the DiagnosticSource is already used in AspNetCore, EntityFrameworkCore, HttpClient and SqlClient - each of them sends its own events that can be intercepted and processed. </p><br><p>  In this article I want to look at a few examples of how the DiagnosticSource can be used in practice in ASP.NET Core applications. </p><br><ul><li>  CorrelationID and header forwarding between services </li><li>  Collecting metrics and traces </li><li>  Logging </li></ul><br><p>  In addition, in this article I decided to compile a list of events that are available for processing and can be used in your applications, as well as talk about some of the pitfalls that you may encounter if you decide to use the DiagnosticSource mechanism in your project. </p><a name="habracut"></a><br><h2 id="suschestvuyuschie-sobytiya">  Existing events </h2><br><p>  Before moving on to the examples, we need to understand which components send events through the DiagnosticSource, and what these events are called.  Unfortunately, nowhere in the documentation is the complete list of events described, and you can only find it in the source code on GitHub. </p><br><p>  Therefore, the easiest way to understand what events exist is to create a class that implements <code>IObserver&lt;DiagnosticListener&gt;</code> and <code>IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;</code> interfaces, subscribe to any <code>DiagnosticListener</code> instances and see which events will be intercepted in the application.  In the same way, you can determine the parameters that are transmitted with each event. </p><br><p>  To simplify your task, I have already collected some of the most useful events (this is not a complete list) for the four components: </p><br><div class="spoiler">  <b class="spoiler_title">Microsoft.AspNetCore</b> <div class="spoiler_text"><p>  The events of the <code>Microsoft.AspNetCore</code> component allow you to intercept the events of the http processing request life cycle in an ASP.NET Core. </p><br><ul><li>  Microsoft.AspNetCore.Hosting.HttpRequestIn.Start </li><li>  Microsoft.AspNetCore.Hosting.HttpRequestIn.Stop </li></ul><br><p>  These events occur at the very beginning and at the very end of processing the http request. </p><br><ul><li>  Microsoft.AspNetCore.Diagnostics.UnhandledException </li></ul><br><p>  Occur with unhandled exceptions.  This is the only place where you can handle exceptions for this component. </p><br><ul><li>  Microsoft.AspNetCore.Mvc.BeforeAction </li><li>  Microsoft.AspNetCore.Mvc.AfterAction </li></ul><br><p>  Occur before and after processing the http request in the middleware, which are added when using <code>UseMvc</code> .  Virtually all of the following events occur between these two. </p><br><ul><li>  Microsoft.AspNetCore.Mvc.BeforeOnAuthorization </li><li>  Microsoft.AspNetCore.Mvc.AfterOnAuthorization </li></ul><br><p>  Occur before and after authorization. </p><br><ul><li>  Microsoft.AspNetCore.Mvc.BeforeActionMethod </li><li>  Microsoft.AspNetCore.Mvc.AfterActionMethod </li></ul><br><p>  Occur before and after the execution of the controller method. </p><br><ul><li>  Microsoft.AspNetCore.Mvc.BeforeActionResult </li><li>  Microsoft.AspNetCore.Mvc.AfterActionResult </li></ul><br><p>  Occur before and after the <code>ExecuteResultAsync</code> call on the <code>ExecuteResultAsync</code> instance that was returned from the controller method.  This, for example, may include the serialization of the result in json. </p><br><ul><li>  Microsoft.AspNetCore.Mvc.BeforeHandlerMethod </li><li>  Microsoft.AspNetCore.Mvc.AfterHandlerMethod </li></ul><br><p>  Used in ASP.NET Pages.  Occur before and after performing the page model method. </p><br><ul><li>  Microsoft.AspNetCore.Mvc.BeforeView </li><li>  Microsoft.AspNetCore.Mvc.AfterView </li></ul><br><p>  Occur before and after rendering the view. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Microsoft.EntityFrameworkCore</b> <div class="spoiler_text"><p>  The events of the <code>Microsoft.EntityFrameworkCore</code> component allow you to intercept database access events via EntityFrameworkCore. </p><br><ul><li>  Microsoft.EntityFrameworkCore.Infrastructure.ContextInitialized </li><li>  Microsoft.EntityFrameworkCore.Infrastructure.ContextDisposed </li></ul><br><p>  Occur before and after using the <code>DbContext</code> instance <code>DbContext</code> </p><br><ul><li>  Microsoft.EntityFrameworkCore.Database.Connection.ConnectionOpening </li><li>  Microsoft.EntityFrameworkCore.Database.Connection.ConnectionOpened </li><li>  Microsoft.EntityFrameworkCore.Database.Connection.ConnectionError </li></ul><br><p>  Occur before and after opening a connection to the database.  If the connection was successfully opened, the <code>ConnectionOpened</code> event occurs.  If an error occurs while opening a connection, a <code>ConnectionError</code> event occurs. </p><br><ul><li>  Microsoft.EntityFrameworkCore.Database.Connection.ConnectionClosing </li><li>  Microsoft.EntityFrameworkCore.Database.Connection.ConnectionClosed </li><li>  Microsoft.EntityFrameworkCore.Database.Connection.ConnectionError </li></ul><br><p>  Similarly, occur before and after closing the connection to the database. </p><br><ul><li>  Microsoft.EntityFrameworkCore.Database.Command.CommandExecuting </li><li>  Microsoft.EntityFrameworkCore.Database.Command.CommandExecuted </li><li>  Microsoft.EntityFrameworkCore.Database.Command.CommandError </li></ul><br><p>  Similarly, occur before and after the query to the database. </p><br><ul><li>  Microsoft.EntityFrameworkCore.Database.Command.DataReaderDisposing </li></ul><br><p>  Occurs after completion of reading from the <code>DbDataReader</code> instance. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">SqlClientDiagnosticListener</b> <div class="spoiler_text"><p>  Events of the <code>SqlClientDiagnosticListener</code> component allow to intercept events of access to the SQL Server database through the corresponding ADO.NET provider. </p><br><ul><li>  System.Data.SqlClient.WriteConnectionOpenBefore </li><li>  System.Data.SqlClient.WriteConnectionOpenAfter </li><li>  System.Data.SqlClient.WriteConnectionOpenError </li></ul><br><p>  Occur before and after opening a connection to the database.  If the connection was successfully opened, the <code>WriteConnectionOpenAfter</code> event <code>WriteConnectionOpenAfter</code> .  If an error occurs while opening a connection, the <code>WriteConnectionOpenError</code> event <code>WriteConnectionOpenError</code> . </p><br><ul><li>  System.Data.SqlClient.WriteConnectionCloseBefore </li><li>  System.Data.SqlClient.WriteConnectionCloseAfter </li><li>  System.Data.SqlClient.WriteConnectionCloseError </li></ul><br><p>  Similarly, occur before and after closing the connection to the database. </p><br><ul><li>  System.Data.SqlClient.WriteCommandBefore </li><li>  System.Data.SqlClient.WriteCommandAfter </li><li>  System.Data.SqlClient.WriteCommandError </li></ul><br><p>  Similarly, occur before and after the query to the database. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">HttpHandlerDiagnosticListener</b> <div class="spoiler_text"><p>  Events of the <code>HttpHandlerDiagnosticListener</code> component <code>HttpHandlerDiagnosticListener</code> you to intercept outgoing http requests, for example, when using the <code>HttpClient</code> class. </p><br><ul><li>  System.Net.Http.HttpRequestOut.Start </li><li>  System.Net.Http.HttpRequestOut.Stop </li></ul><br><p>  Occur before and after outgoing http request. </p><br><ul><li>  System.Net.Http.Exception </li></ul><br><p>  Occurs when an outgoing http request fails. </p></div></div><br><p>  By the way, there is even a <a href="">DiagnosticSource User's Guide</a> , which describes recommendations and conventions for naming events for the DiagnosticSource. </p><br><p>  As you can easily guess, Microsoft doesn‚Äôt follow these recommendations and does the opposite =) (Ok, I‚Äôm exaggerating. It‚Äôs just that the DiagnosticSource was used in the .NET Core components before the DiagnosticSource User's Guide appeared) </p><br><h2 id="obschiy-kod">  Common code </h2><br><p>  It is assumed that all the examples that I will discuss below will be used in an ASP.NET Core application (although this is not necessary) and will use the <code>DiagnosticObserverBase</code> base class to subscribe to and process events from the DiagnosticSource. </p><br><p>  This class is based on the <code>ExampleDiagnosticObserver</code> class from my <a href="https://habr.com/ru/company/ozontech/blog/435896/">previous article</a> where you can find a description of its work.  This class will use the <code>SubscribeWithAdapter</code> method from the <a href="https://www.nuget.org/packages/Microsoft.Extensions.DiagnosticAdapter/">Microsoft.Extensions.DiagnosticAdapter</a> NuGet package to subscribe and handle events. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DiagnosticObserverBase</span></span> : <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">DiagnosticListener</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;IDisposable&gt; _subscriptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IDisposable&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsMatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnNext(DiagnosticListener diagnosticListener) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsMatch(diagnosticListener.Name)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscription = diagnosticListener.SubscribeWithAdapter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _subscriptions.Add(subscription); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnError(Exception error) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IObserver&lt;DiagnosticListener&gt;.OnCompleted() { _subscriptions.ForEach(x =&gt; x.Dispose()); _subscriptions.Clear(); } }</code> </pre> <br><p>  To subscribe to events from certain components, you need to create a new class, inherit it from the <code>DiagnosticObserverBase</code> , override the <code>IsMatch</code> method <code>IsMatch</code> that it returns <code>true</code> for those components that we want to subscribe to, add methods to handle the events and mark them with the <code>DiagnosticNameAttribute</code> attributes, where you can enter the name processed event.  For example: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeDiagnosticObserver</span></span> : <span class="hljs-title"><span class="hljs-title">DiagnosticObserverBase</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsMatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == <span class="hljs-string"><span class="hljs-string">"SomeComponent"</span></span>; } [DiagnosticName(<span class="hljs-string"><span class="hljs-string">"SomeEvent"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSomeEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* EventParameters */</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><p>  In order to register handlers based on the <code>DiagnosticObserverBase</code> class in the DI container, we will use the <code>AddDiagnosticObserver</code> extension <code>AddDiagnosticObserver</code> , which will be used in the <code>ConfigureServices</code> method in the Startup.cs file: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DiagnosticServiceCollectionExtensions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AddDiagnosticObserver&lt;TDiagnosticObserver&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IServiceCollection services) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TDiagnosticObserver : DiagnosticObserverBase { services.TryAddEnumerable(ServiceDescriptor .Transient&lt;DiagnosticObserverBase, TDiagnosticObserver&gt;()); } }</code> </pre> <br><p>  And in order to subscribe to events from the DiagnosticSource, add the following lines to the <code>Configure</code> method: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app, IHostingEnvironment env</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diagnosticObservers = app .ApplicationServices.GetServices&lt;DiagnosticObserverBase&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> diagnosticObserver <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> diagnosticObservers) { DiagnosticListener.AllListeners.Subscribe(diagnosticObserver); } <span class="hljs-comment"><span class="hljs-comment">// ... app.UseMvc(); }</span></span></code> </pre> <br><p>  Perhaps this is not the best way to register and in practice we usually use the <code>IHostedService</code> interface for such purposes, but our examples will be quite enough. </p><br><h2 id="nekotorye-podvodnye-kamni">  Some pitfalls </h2><br><p>  If you decide to use the DiagnosticSource in your projects, you may encounter some unobvious points that I would like to dwell on. </p><br><h3 id="inogda-mogut-potrebovatsya-fiktivnye-obrabotchiki-dlya-nesuschestvuyuschih-sobytiy">  Sometimes dummy handlers may be required for non-existent events. </h3><br><p>  Usually, if a component sends events about its work, the code for sending an event is as follows: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_diagnosticSource.IsEnabled(<span class="hljs-string"><span class="hljs-string">"SomeEvent"</span></span>)) _diagnosticSource.Write(<span class="hljs-string"><span class="hljs-string">"SomeEvent"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* parameters */</span></span> });</code> </pre> <br><p>  This allows you not to create an object with parameters if no one is going to process the event, and save a little on garbage collection. </p><br><p>  However, in some cases there are paired events with the suffixes <code>.Start</code> and <code>.Stop</code> , both of which must either work or not.  The code for sending such events might look something like this: </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  ,     . var someEventIsEnabled = _diagnosticSource.IsEnabled("SomeEvent"); if (someEventIsEnabled &amp;&amp; _diagnosticSource.IsEnabled("SomeEvent.Start")) _diagnosticSource.Write("SomeEvent.Start", new { /* parameters */ }); // ... if (someEventIsEnabled &amp;&amp; _diagnosticSource.IsEnabled("SomeEvent.Stop")) _diagnosticSource.Write("SomeEvent.Stop", new { /* parameters */ });</span></span></code> </pre> <br><p>  Therefore, to subscribe to the <code>SomeEvent.Start</code> and <code>SomeEvent.Stop</code> events, <code>SomeEvent.Stop</code> must also add a dummy handler for the <code>SomeEvent</code> event, which will never be called, but its presence will be checked. </p><br><h3 id="nekotorye-sobytiya-parnye-a-nekotorye-troynye">  Some events are paired and some are triple. </h3><br><p>  Some events are paired, for example <code>System.Net.Http.HttpRequestOut.Start</code> and <code>System.Net.Http.HttpRequestOut.Stop</code> .  This means that the event with the suffix <code>.Start</code> will be triggered before the start of some operation, and the event with the suffix <code>.Stop</code> - at the end.  In this case, the last event will be guaranteed to be called (if there are corresponding handlers), regardless of whether the operation ended with an error or not. </p><br><p>  However, some events are triple, for example <code>System.Data.SqlClient.WriteCommandBefore</code> , <code>System.Data.SqlClient.WriteCommandAfter</code> and <code>System.Data.SqlClient.WriteCommandError</code> , where the last event depends on the result of the operation.  In this case, if the operation was completed successfully, only the <code>System.Data.SqlClient.WriteCommandAfter</code> event will be triggered, and if an error occurred during the operation, only the <code>System.Data.SqlClient.WriteCommandError</code> event occurred. </p><br><p>  This should be taken into account if, for example, you use events to measure the time of operations.  For example, if you start a stopwatch at the beginning of an operation, then you need to stop it in two places in order not to lose data. </p><br><h2 id="primery-ispolzovaniya-diagnosticsource">  Examples of using the DiagnosticSource </h2><br><p>  Now we are ready to consider how the DiagnosticSource mechanism can be put into practice in real-world applications. </p><br><h3 id="correlationid-i-probrasyvanie-zagolovkov-mezhdu-servisami">  CorrelationID and header forwarding between services </h3><br><p>  In the world of microservices you can often find the term CorrelationID.  This is some identifier that is generated each time any service is accessed and then is transferred from the service to the service via http headers.  This identifier is usually written to the logs, allowing you to link messages from several services received as part of a single transaction. </p><br><p>  For ASP.NET Core, there is the NuGet <a href="https://github.com/stevejgordon/CorrelationId">CorrelationId</a> package, but it requires that developers manually add the appropriate header to all outgoing requests, and therefore is not very convenient to use. </p><br><p>  We implement CorrelationId through DiagnosticSource.  To begin with, let's add the <code>CorrelationId</code> class which will be responsible for storing our identifier: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CorrelationId</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AsyncLocal&lt;Guid?&gt; _current = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncLocal&lt;Guid?&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Guid Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = _current.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"CorrelationId isn't assigned."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Value; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _current.Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br><p>  This class uses an instance of the <a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.asynclocal-1%3Fview%3Dnetcore-2.2">AsyncLocal &lt;T&gt; type</a> to store the current CorrelationId value, which will be unique for each request, but will be correctly transferred from one thread from ThreadPool to another when working with asynchronous code. </p><br><p>  The next step is to add an event handler from the DiagnosticSource, which will intercept incoming and outgoing http requests.  In incoming requests, we will check for the presence of the <code>X-Correlation-ID</code> header and, if it is not there, we will generate a new identifier via <code>Guid.NewGuid()</code> .  In outgoing requests, we will simply add a header using <code>CorrelationId.Current</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CorrelationIdHandler</span></span> : <span class="hljs-title"><span class="hljs-title">DiagnosticObserverBase</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsMatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == <span class="hljs-string"><span class="hljs-string">"Microsoft.AspNetCore"</span></span> || name == <span class="hljs-string"><span class="hljs-string">"HttpHandlerDiagnosticListener"</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   http  [DiagnosticName("Microsoft.AspNetCore.Hosting.HttpRequestIn")] public void OnHttpRequestIn() { } [DiagnosticName("Microsoft.AspNetCore.Hosting.HttpRequestIn.Start")] public void OnHttpRequestInStart(HttpContext httpContext) { //    CorrelationId    http . var headers = httpContext.Request.Headers; if (headers.TryGetValue("X-Correlation-ID", out var header)) { if (Guid.TryParse(header, out var correlationId)) { CorrelationId.Current = correlationId; return; } } //    CorrelationId. CorrelationId.Current = Guid.NewGuid(); } //   http  [DiagnosticName("System.Net.Http.HttpRequestOut")] public void OnHttpRequestOut() { } [DiagnosticName("System.Net.Http.HttpRequestOut.Start")] public void OnHttpRequestOutStart(HttpRequestMessage request) { //     http    CorrelationId var correlationId = CorrelationId.Current.ToString(); request.Headers.Add("X-Correlation-ID", correlationId); } }</span></span></code> </pre> <br><p>  In this class, in the <code>IsMatch</code> method <code>IsMatch</code> we report that we want to handle events from <code>Microsoft.AspNetCore</code> components (responsible for incoming http requests) and <code>HttpHandlerDiagnosticListener</code> (responsible for outgoing http requests).  Direct handling of headers occurs in the <code>OnHttpRequestInStart</code> and <code>OnHttpRequestOutStart</code> . </p><br><p>  In addition, we had to add two dummy methods <code>OnHttpRequestIn</code> and <code>OnHttpRequestOut</code> .  They will not be called during processing, but are used to determine whether to call the <code>Start</code> and <code>Stop</code> handlers.  Without them, these events will not be triggered. </p><br><p>  It remains only to register our handler in the Startup.cs file: </p><br><pre> <code class="cs hljs">services.AddDiagnosticObserver&lt;CorrelationIdHandler&gt;();</code> </pre> <br><p>  In practice, it is also useful to forward not one, but several headers with a certain prefix (for example, "X-Api-"), thereby realizing the so-called Context Propagation.  This mechanism allows you to set a value with a specific key in one service and read it in another, without transferring this value explicitly through the request body.  Such a mechanism can be easily implemented based on the <code>CorrelationIdHandler</code> class described above. </p><br><h3 id="sbor-metrik-i-trassirovok">  Collecting metrics and traces </h3><br><p>  Metrics and traces are an important part of any application.  Metrics allow you to customize monitoring and dashboards for applications, and traces to find bottlenecks in them. </p><br><p>  We at OZON.ru use <a href="https://prometheus.io/">Prometheus</a> to collect metrics and, for ASP.NET Core services, NuGet <a href="https://github.com/PrometheusClientNet/Prometheus.Client.AspNetCore">Prometheus.Client.AspNetCore</a> package. </p><br><p>  We use <a href="https://opentracing.io/">OpenTracing</a> and <a href="https://www.jaegertracing.io/">Jaeger</a> to collect traces.  (If you wish, you can view <a href="https://www.youtube.com/watch%3Fv%3D-siZv8TZoMg">my report</a> ‚ÄúUsing OpenTracing in .NET‚Äù with DotNetMsk Meetut # 30) </p><br><p>  However, many developers do not really want to cover their applications with metrics and traces, since this often requires the writing of additional uniform code and is not very consistent with the ‚Äúbusiness objectives‚Äù. </p><br><p>  Fortunately, most of the components that send events through the DiagnosticSource give out pairwise events, the first of which indicates the beginning of a certain operation, and the second - its completion.  This allows, for example, to start the stopwatch first, and then stop it and give a certain metric. </p><br><p>  For example, if we go to collect a metric based on the execution time of all controller actions, we can use the following class: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AspNetCoreMetricsHandler</span></span> : <span class="hljs-title"><span class="hljs-title">DiagnosticObserverBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Histogram requestDurationSeconds; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MetricsHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MetricFactory metricFactory</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,  NuGet  Prometheus.Client. //        . requestDurationSeconds = metricFactory.CreateHistogram( "request_duration_seconds", "", labelNames: new[] {"action_name"}); } protected override bool IsMatch(string name) { return name == "Microsoft.AspNetCore"; } [DiagnosticName("Microsoft.AspNetCore.Hosting.HttpRequestIn")] public void OnHttpRequestIn() { } [DiagnosticName("Microsoft.AspNetCore.Hosting.HttpRequestIn.Start")] public void OnHttpRequestInStart(HttpContext httpContext) { //     http   . httpContext.Items["Stopwatch"] = Stopwatch.StartNew(); } [DiagnosticName("Microsoft.AspNetCore.Mvc.BeforeAction")] public void OnBeforeAction(HttpContext httpContext, ActionDescriptor actionDescriptor) { //    , //     . httpContext.Items["ActionName"] = actionDescriptor.DisplayName; } [DiagnosticName("Microsoft.AspNetCore.Hosting.HttpRequestIn.Stop")] public void OnHttpRequestInStop(HttpContext httpContext) { //     http    //      . if (!httpContext.Items.TryGetValue("Stopwatch", out object stopwatch)) return; if (!httpContext.Items.TryGetValue("ActionName", out object actionName)) actionName = "Unknown"; var duration = ((Stopwatch) stopwatch).Elapsed.TotalSeconds; requestDurationSeconds .WithLabels(actionName.ToString()) .Observe(duration); } }</span></span></code> </pre> <br><p>  Here we declare a Histogram type metric from NuGet of the <a href="https://github.com/PrometheusClientNet/Prometheus.Client">Prometheus.Client</a> package in the constructor.  To this metric we add the label "action_name", which will allow us to distinguish metrics collected in different actions of the controllers. </p><br><p>  At the beginning of event processing ( <code>OnHttpRequestInStart</code> method), we start a stopwatch to measure the time of the request.  We also remember the name of the action being processed ( <code>OnBeforeAction</code> method).  Finally, after processing the request (the <code>OnHttpRequestInStop</code> method), we again obtain all the data from the <code>httpContext.Items</code> collection and write them into the metric. </p><br><p>  It remains only to register our handler and the <code>MetricFactory</code> instance in the <code>MetricFactory</code> file: </p><br><pre> <code class="cs hljs">services.AddSingleton(Prometheus.Client.Metrics.DefaultFactory); services.AddDiagnosticObserver&lt;AspNetCoreMetricsHandler&gt;();</code> </pre> <br><p>  A similar technique can also be used when collecting traces using NuGet <a href="https://github.com/opentracing/opentracing-csharp">OpenTracing</a> package. </p><br><h3 id="logirovanie">  Logging </h3><br><p>  Another very useful application of DiagnosticSource is logging exceptions.  But the question may arise: "Why is this needed?".  After all, you can simply wrap your code in a try-catch block or even configure one global handler for all unhandled exceptions. </p><br><p>  The point is that exception handling through DiagnosticSource events occurs at a very early stage, when various objects are still available that can help us understand the reason for the exception.  (It should be noted that DiagnosticSource allows only to handle the exception, but will not prevent its further spreading) </p><br><p>  Suppose we want to centrally handle all exceptions when accessing the database, while recording the query text and its parameters in the log.  Using the DiagnosticSource we can do this as follows: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SqlClientLoggingHandler</span></span> : <span class="hljs-title"><span class="hljs-title">DiagnosticObserverBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ILogger&lt;SqlClientLoggingHandler&gt; _logger; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SqlClientLoggingHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ILogger&lt;SqlClientLoggingHandler&gt; logger</span></span></span><span class="hljs-function">)</span></span> { _logger = logger; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsMatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == <span class="hljs-string"><span class="hljs-string">"SqlClientDiagnosticListener"</span></span>; } [DiagnosticName(<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient.WriteCommandError"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCommandError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DbCommand command, Exception exception</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.AppendLine(<span class="hljs-string"><span class="hljs-string">"Command: "</span></span> + command.CommandText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command.Parameters.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { sb.AppendLine(<span class="hljs-string"><span class="hljs-string">"Parameters: "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (DbParameter parameter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> command.Parameters) { sb.AppendLine(<span class="hljs-string"><span class="hljs-string">$"\t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{parameter.ParameterName}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{parameter.Value}</span></span></span><span class="hljs-string">"</span></span>); } } _logger.LogError(exception, sb.ToString()); } }</code> </pre> <br><p>   <code>IsMatch</code>  ,       <code>SqlClientDiagnosticListener</code> ,    <code>OnCommandError</code>            . </p><br><p>       Startup.cs   : </p><br><pre> <code class="cs hljs">services.AddDiagnosticObserver&lt;SqlClientLoggingHandler&gt;();</code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>         DiagnosticSource. ,  ,       ,    DiagnosticSource,              ASP.NET Core. </p><br><p>   OZON.ru           .  ,    NuGet      ,      ,    . </p><br><p>  ,    <a href="https://habr.com/ru/company/ozontech/blog/435896/"></a>    ,     DiagnosticSource   . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/221037/">https://habr.com/ru/post/221037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221027/index.html">Learning Derby 0.6, example # 1</a></li>
<li><a href="../221029/index.html">Useful materials for mobile developer # 50 (April 21-27)</a></li>
<li><a href="../221031/index.html">The creator of the cartoon "Fortress" will release a sequel</a></li>
<li><a href="../221033/index.html">"Rule of zero"</a></li>
<li><a href="../221035/index.html">If you decide to switch from PHP to Python, then what should you prepare for?</a></li>
<li><a href="../221041/index.html">Controlling a quadcopter with a virtual reality helmet</a></li>
<li><a href="../221043/index.html">The history of the Blade Runner</a></li>
<li><a href="../221045/index.html">Updated Azure Web Sites cloud service for hosting PHP, Java, .NET, Node.js and Python sites</a></li>
<li><a href="../221049/index.html">Spy on the throwing of the neural network</a></li>
<li><a href="../221051/index.html">Bracelet for a healthy lifestyle: Jawbone UP24</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>