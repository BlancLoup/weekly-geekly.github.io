<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúUniversal‚Äù links in C ++ 11 or T && do not always mean ‚ÄúRvalue Reference‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, Scott Meyers (C Sc ++ Meyers), an expert in the C ++ programming language, author of many well-known books, published an article desc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúUniversal‚Äù links in C ++ 11 or T && do not always mean ‚ÄúRvalue Reference‚Äù</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, Scott Meyers (C Sc ++ Meyers), an expert in the C ++ programming language, author of many well-known books, published an article describing the details of using rvalue links in C ++ 11. <br>  On Habr√©, this topic has not yet been raised, and it seems to me that the article will be of interest to the community. <br>  Original article: <a href="http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">‚ÄúUniversal References in C ++ 11 ‚Äî Scott Meyers‚Äù</a> <br><br><h4>  "Universal" links in C ++ 11 </h4><br><h6>  T &amp;&amp; does not always mean ‚ÄúRvalue Reference‚Äù </h6><br>  By: <a href="http://www.aristeia.com/">Scott Meyers</a> <br><br>  Perhaps the most important innovation in C ++ 11 are the rvalue links.  They serve as the foundation on which ‚Äúmove semantics‚Äù and ‚Äúperfect forwarding‚Äù are built.  (You can get acquainted with the basics of these mechanisms in the <a href="http://thbecker.net/articles/rvalue_references/section_01.html">review of Thomas Becker</a> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Syntactically, the rvalue links are declared in the same way as ‚Äúnormal‚Äù links (now called lvalue links), except that you use two ampersands instead of one.  Thus, this function takes a parameter of type rvalue-reference-to-Widget: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget&amp;&amp; param)</span></span></span></span>;</code> </pre> <br>  Given that the rvalue links are declared using the ‚Äú&amp;&amp;‚Äù, it would be reasonable to assume that the presence of the ‚Äú&amp;&amp;‚Äù in the type declaration points to the rvalue link.  <b>But this is not the case:</b> <br><pre> <code class="cpp hljs">Widget&amp;&amp; var1 = someWidget; <span class="hljs-comment"><span class="hljs-comment">//  ‚Äú&amp;&amp;‚Äù  rvalue  auto&amp;&amp; var2 = var1; //  ‚Äú&amp;&amp;‚Äù   rvalue  template&lt;typename T&gt; void f(std::vector&lt;T&gt;&amp;&amp; param); //  ‚Äú&amp;&amp;‚Äù  rvalue  template&lt;typename T&gt; void f(T&amp;&amp; param); //  ‚Äú&amp;&amp;‚Äù   rvalue </span></span></code> </pre><a name="habracut"></a><br>  In this article, I will describe two ‚Äú&amp;&amp;‚Äù values ‚Äã‚Äãin the type declaration, explain how to distinguish them from each other, and introduce a new terminology that will uniquely determine what value ‚Äú&amp;&amp;‚Äù is used.  Selecting different values ‚Äã‚Äãis important, because if you think about the ‚Äúrvalue link‚Äù when you see the ‚Äú&amp;&amp;‚Äù in the type declaration, you will misunderstand a lot of C ++ 11 code. <br><br>  The essence of the question is that ‚Äú&amp;&amp;‚Äù in a type declaration means a rvalue reference, but sometimes it can mean either an rvalue reference or an lvalue reference.  Thus, in some cases, ‚Äú&amp;&amp;‚Äù in the source code may have the value ‚Äú&amp;‚Äù, i.e.  syntactically have the form of an rvalue reference (‚Äú&amp;&amp;‚Äù), and in reality be an lvalue reference (‚Äú&amp;‚Äù). <br><br>  Links are a more flexible concept than lvalue links or rvalue links.  So the rvalue links can only be associated with the rvalue, and the lvalue links, in addition to the ability to bind to the lvalue, can be associated with the rvalue under limited conditions (restrictions on linking the lvalue of links and rvalue is that such a link is valid only when A lvalue reference is declared as a reference to a constant, that is, const T &amp;.) Links that are declared with ‚Äú&amp;&amp;‚Äù, which can be either lvalue references or rvalue references, can be associated with anything.  Such unusually flexible links deserve their name.  I called them <b>"universal" links</b> . <br><br>  The details when ‚Äú&amp;&amp;‚Äù means a universal link (that is, when ‚Äú&amp;&amp;‚Äù in the source code can really mean ‚Äú&amp;‚Äù) are quite complex, so I‚Äôll postpone their description.  And now let's focus on the following rule, because this is something that you should remember in daily programming: <br><br>  If a variable or parameter is declared with type <b>T &amp;&amp;</b> for some <b>output type</b> T, such variable or parameter is a universal reference. <br><br>  The type inference requirement limits the range of situations where universal references can be.  Practically, almost all universal links are parameters of function templates.  And since the type inference rules for auto-declared variables are basically the same as for templates, auto-declared universal references are possible.  They are not often found in production code, but I will give some in this article, since they are less verbose with examples of patterns.  In the ‚ÄúSmall Details‚Äù section of this article, I will show the possibility of the emergence of universal links in connection with the use of typedef and decltype, but so far we have not reached the ‚ÄúMinor Details‚Äù, I will assume that universal links refer only to function templates and auto declared variables. <br><br>  The T &amp;&amp; universal link declaration form is a more significant requirement than it may seem, but I will come back to this question later.  For now, just keep in mind this requirement. <br><br>  Like all references, universal references must be initialized, and it is the universal reference initializer that determines whether it will be a lvalue reference or an rvalue reference: <br><ul><li>  If the expression that initializes the universal reference is an lvalue, then the universal reference becomes the lvalue reference. </li><li>  If the expression that initializes the universal reference is an rvalue, then the universal reference becomes the rvalue reference. </li></ul><br>  This information is only useful if you are able to distinguish lvalue from rvalue.  The exact definition of these terms is difficult to work out (C ++ 11 standard gives a general definition of whether the expression lvalue or rvalue is case-by-case), but in practice the following is enough: <br><ul><li>  If you can take the address of an expression, then this is an lvalue expression. </li><li>  If the type of the expression is an lvalue reference (i.e. T &amp; or const T &amp;, etc.), then this is an lvalue expression. </li><li>  Otherwise, the expression is an rvalue.  Conceptually (and, as a rule, in fact), rvalues ‚Äã‚Äãcorrespond to temporary objects, such as those returned from functions or created by implicit type conversion.  Most literals (for example, 10 and 5.3) are also rvalue. </li></ul><br>  Let's look again at the code from the beginning of the article: <br><pre> <code class="cpp hljs">Widget&amp;&amp; var1 = someWidget; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; var2 = var1;</code> </pre><br>  You can take the address var1, respectively var1 is lvalue.  Declaring the type var2 as auto &amp;&amp; makes var2 a universal reference, and since it is initialized by var1 (lvalue), var2 becomes an lvalue reference. <br><br>  Careless reading of the source code may make you believe that var2 is an rvalue reference;  ‚Äú&amp;&amp;‚Äù in the ad, of course, leads to this thought.  But since var2 is a generic link initialized by lvalue, it is a lvalue link.  It is as if var2 were declared as follows: <br><pre> <code class="cpp hljs">Widget&amp; var2 = var1;</code> </pre><br>  As noted above, if an expression is of type lvalue reference, it is an lvalue.  Consider this example: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; ... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; val = v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// val  lvalue  (. )</span></span></code> </pre><br>  val is a universal reference and initialized by v [0], i.e.  result of calling std :: vector &lt;int&gt; :: operator [].  This function returns a lvalue reference to the vector element (I ignore going outside the array, which will lead to undefined behavior). <br><br>  Since all lvalue references are lvalue, and since this lvalue is used to initialize val, val becomes an lvalue reference, although a declaration of type val looks like an rvalue reference. <br><br>  I noted that universal links are most common in the parameters of function templates.  Consider again the pattern from the beginning of this article. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; param)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Äú&amp;&amp;‚Äù   rvalue </span></span></code> </pre><br>  With this call f, <br><pre> <code class="cpp hljs">f(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 10  rvalue</span></span></code> </pre><br>  param is initialized with literal 10, which, for the reason that you cannot take its address, is an rvalue.  This means that in the f call, the universal reference param is initialized to the rvalue and thus becomes the rvalue reference ‚Äî in particular, int &amp;&amp;. <br><br>  On the other hand, if f is called something like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; f(x); <span class="hljs-comment"><span class="hljs-comment">// x  lvalue</span></span></code> </pre><br>  param is initialized to the variable x, which, for the reason that you can take its address, is an lvalue.  This means that in this call to f, the universal reference param is initialized by the lvalue, and param therefore becomes the lvalue reference ‚Äì‚Äì int &amp;, to be precise. <br><br>  The comment next to the f declaration should now be clear: the type of param lvalue will be a reference or the rvalue reference will depend on what was passed to f in the call.  Sometimes param becomes an lvalue reference, and sometimes an rvalue reference.  That is, param is truly a universal link. <br><br>  Remember that ‚Äú&amp;&amp;‚Äù denotes a universal reference only when type inference takes place.  Where there is no type inference, there is no universal reference.  In such cases, the ‚Äú&amp;&amp;‚Äù in the type declaration always means the rvalue reference.  Consequently: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; param)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ‚áí  ; &amp;&amp; ‚â°   template&lt;typename T&gt; class Widget { ... Widget(Widget&amp;&amp; rhs); //     ‚áí   ; ... // &amp;&amp; ‚â° rvalue  }; template&lt;typename T1&gt; class Gadget { ... template&lt;typename T2&gt; Gadget(T2&amp;&amp; rhs); //    ‚áí  ; &amp;&amp; ‚â°   }; void f(Widget&amp;&amp; param); //     ‚áí   ; // &amp;&amp; ‚â° rvalue </span></span></code> </pre><br>  There is nothing surprising in these examples.  In any case, if you see T &amp;&amp; (where T is a template parameter), type inference is present, so you look at the universal link.  And if you see ‚Äú&amp;&amp;‚Äù after a specific type name (for example, Widget &amp;&amp;), you look at the rvalue link. <br><br>  I stated that the link declaration form should be ‚ÄúT &amp;&amp;‚Äù in order for the link to be universal.  This is an important nuance.  Look again at the declaration from the beginning of this article: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt;&amp;&amp; param)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Äú&amp;&amp;‚Äù  rvalue </span></span></code> </pre><br>  Here we have both type inference and ‚Äú&amp;&amp;‚Äù - the described parameter of the function, but the form of the parameter declaration is not ‚ÄúT &amp;&amp;‚Äù, but ‚Äústd :: vector &lt;T&gt; &amp;&amp;‚Äù.  As a result, the parameter is a normal rvalue reference, and not a universal reference.  A universal link ad can only be in the form of ‚ÄúT &amp;&amp;‚Äù!  Even the simple addition of the const qualifier is enough to not interpret ‚Äú&amp;&amp;‚Äù as a universal reference. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp;&amp; param)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Äú&amp;&amp;‚Äù  rvalue </span></span></code> </pre><br>  ‚ÄúT &amp;&amp;‚Äù is simply a necessary form for the declaration of universal links.  This does not mean that you must use the name T for the template parameters. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> MyTemplateParamType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyTemplateParamType&amp;&amp; param)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ‚Äú&amp;&amp;‚Äù   </span></span></code> </pre><br>  Sometimes you can see T &amp;&amp; in the template function declaration, where T is a template parameter, but there is no type inference yet.  Consider the push_back function in std :: vector (only the version of interest is shown <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>::push_back): <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">allocator</span></span></span><span class="hljs-class">&lt;T&gt; &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; x)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ‚áí   ; ... // &amp;&amp; ‚â° rvalue  };</span></span></code> </pre><br>  Here T is the template parameter, and push_back accepts T &amp;&amp;.  However, the parameter is not a universal link!  How can it be? <br><br>  The answer becomes obvious if we look at how push_back will be declared outside the class.  I will pretend that the Allocator parameter is missing so as not to clutter up the code.  Given this, the following is the declaration of this version. <br>  std :: vector :: push_back: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:push_back(T&amp;&amp; x);</code> </pre><br>  push_back cannot exist without the std :: vector &lt;T&gt; class that contains it.  But if we have a class std :: vector &lt;T&gt;, then we already know what T is, and thus, there is no need to output this type. <br><br>  Let's see an example.  If I write, <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeWidget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    Widget std::vector&lt;Widget&gt; vw; ... Widget w; vw.push_back(makeWidget()); //  Widget    vw</span></span></code> </pre><br>  then my use of push_pack will tell the compiler to instantiate this function for the class std :: vector &lt;Widget&gt;.  Its declaration outside the class will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt;::push_back(Widget&amp;&amp; x);</code> </pre><br>  Do you understand?  As soon as we know that the class is std :: vector &lt;Widget&gt;, the type of the push_back parameter is fully defined.  Type inference is not performed. <br>  Compare this with the emplace_back std :: vector method, which is declared as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Allocator</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">allocator</span></span></span><span class="hljs-class">&lt;T&gt; &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emplace_back</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-comment"><span class="hljs-comment">//    ‚áí  ; ... // &amp;&amp; ‚â°   };</span></span></code> </pre><br>  Disregard the fact that emplace_back accepts a variable number of arguments (as indicated in the Args and args declaration).  The important thing here is that the types for each of the arguments must be inferred.  The template parameter of the Args function does not depend on the template parameter of the class T, so even if the class is completely known, say std :: vector &lt;Widget&gt;, it says nothing about the type (s) of the emplace_back arguments.  The emplace_back declaration outside the class for std :: vector &lt;Widget&gt; clearly shows this (I continue to ignore the existence of the Allocator parameter): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt;::emplace_back(Args&amp;&amp;... args);</code> </pre><br>  Obviously, knowing that a class is std :: vector &lt;Widget&gt; does not eliminate the need to infer the type (s) that are passed to emplace_back.  As a result, the std :: vector :: emplace_back parameters are universal references, unlike the version parameter of std :: vector :: push_back, which, as we have seen, is an rvalue reference. <br><br>  It should be borne in mind that whether the expression lvalue or rvalue does not depend on its type.  Consider the int type.  There is an int type lvalue (for example, variables declared as int) and there is an int rvalue (for example, literals, for example, 10).  This is true for custom types, like Widget.  A Widget object can be an lvalue (for example, a Widget variable) or rvalue (for example, a factory function returns a created Widget object).  The type of expression will not tell you whether it is an lvalue or an rvalue. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeWidget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    Widget Widget&amp;&amp; var1 = makeWidget(); // var1  lvalue,   // var1 ‚Äì  rvalue  ( Widget) Widget var2 = static_cast&lt; Widget&amp;&amp; &gt;(var1); // cast   rvalue,  //   -  rvalue  ( Widget)</span></span></code> </pre><br>  The common way to turn an lvalue (for example, var1) into an rvalue is to use std :: move, so var2 can be defined as follows: <br><pre> <code class="cpp hljs">Widget var2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(var1); <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><br>  I initially cited the code using static_cast only to explicitly show that the type of the expression is the rvalue reference (Widget &amp;&amp;). <br><br>  Named variables and parameters of type rvalue reference are lvalue.  (You can get their address.) Consider the Widget and Gadget templates again: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> ... Widget(Widget&amp;&amp; rhs); <span class="hljs-comment"><span class="hljs-comment">//  rhs - rvalue , ... //  rhs  lvalue }; template&lt;typename T1&gt; class Gadget { ... template &lt;typename T2&gt; Gadget(T2&amp;&amp; rhs);// rhs      ... //     rvalue   }; // lvalue ,  rhs  lvalue</span></span></code> </pre><br>  In the Widget constructor, rhs is an rvalue reference, so we know that it is associated with an rvalue (i.e. passed to rvalue), but rhs itself is an lvalue, so we have to convert it back to rvalue if we want to take advantage of that rhs is associated with rvalue.  Our desire, as a rule, is caused by the requirement to use rhs as a source of transfer, therefore, std :: move is used to convert lvalue to rvalue.  Similarly, rhs in the Gadget constructor is a universal reference, and therefore it can be associated with an lvalue or an rvalue, but in any case, rhs itself is an lvalue.  If it is associated with an rvalue and we want to take advantage of it, we need to convert rhs back to rvalue.  However, if it is associated with an lvalue, we certainly do not want to interpret it as an rvalue.  Such a dependency on what the universal link is connected with is the reason for using std :: forward: take a universal link and convert it to rvalue only if it is associated with an rvalue expression.  The name of the function (‚Äúforward‚Äù) confirms our expectation that it will perform the transfer to another function, always preserving the type of the reference argument (lvalue or rvalue). <br><br>  But std :: move and std :: forward are not the subject of this article.  The article focuses on the fact that "&amp;&amp;" in type declarations may or may not describe a rvalue reference.  In order not to be distracted, I refer you to the links in the ‚ÄúAdditional Information‚Äù section for a detailed description of std :: move and std :: forward. <br><br><h5>  Small parts </h5><br>  The essence of the question is that some constructions in C ++ 11 generate references to references, and references to references are not allowed in C ++.  If the source code explicitly contains a link to the link - the code is not correct: <br><pre> <code class="cpp hljs">Widget w1; ... Widget&amp; &amp; w2 = w1; <span class="hljs-comment"><span class="hljs-comment">// !     ‚Äú  ‚Äù</span></span></code> </pre><br>  However, there are cases where references to links arise as a result of manipulations with types that occur during compilation, and in such cases, rejecting this code will be problematic.  We know this from the experience of the original standard for C ++, that is, C ++ 98 / C ++ 03. <br><br>  During type inference for template parameters, which is a universal reference, lvalues ‚Äã‚Äãand rvalues ‚Äã‚Äãof the same type are displayed in several different types.  In particular, lvalues ‚Äã‚Äãof type T are output as type T &amp; (i.e. lvalue reference to T), and rvalue of type T are output simply as type T. (Note that lvalue is output as lvalue reference, rvalue is not output as rvalue reference!) Consider what happens when you call a template function that accepts a universal reference with rvalue and lvalue: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; param)</span></span></span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; ... f(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  f  rvalue f(x); //  f  lvalue</span></span></code> </pre><br>  In a call to f with rvalue 10 T, it is output as int, and the instantiation of f looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;&amp; param)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// f   rvalue</span></span></code> </pre><br>  It's good.  However, in a call to f with lvalue x, T is outputted as int &amp;, and the instantiation of f contains a link to the link: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; &amp;&amp; param)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//   f  lvalue</span></span></code> </pre><br>  Because of the link to the link, this instance code looks seemingly wrong, but the source code ‚Äúf (x)‚Äù is quite reasonable.  In order not to reject this code, C ++ performs ‚Äúlink folding‚Äù when a link reference appears in contexts, such as template instantiation. <br><br>  Since there are two types of links (lvalue links and rvalue links), there are four possible combinations of link references: lvalue link to lvalue link, lvalue link to rvalue link, rvalue link to lvalue link, and rvalue link to rvalue link.  There are only two rules for folding links: <br><ul><li>  The rvalue link to the rvalue link becomes (‚Äúminimized to‚Äù) the rvalue link. </li><li>  All other links to links (i.e., all combinations involving lvalue links) are collapsed into a lvalue link. </li></ul><br>  Applying these rules to instantiating f with lvalue gives the following correct code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; param)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  f  lvalue   </span></span></code> </pre><br>  This gives the exact mechanism by which a universal link can (after deducing a type and folding links) be turned into an lvalue link.  In reality, a universal link is simply a rvalue link in the context of link folding. <br><br>  A special situation is when a type is displayed for variables that are references.  In this case, the part of the type denoting the link is ignored.  For example, if <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r1 = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  r1 - int&amp;&amp; int&amp; r2 = x; //  r2 - int&amp;</span></span></code> </pre><br>  then the type for both r1 and r2 when calling the template f is considered to be int.  This behavior of dropping links does not depend on the type inference rules for generic types, lvalues ‚Äã‚Äãare output as type T &amp;, and rvalue as type T, and thus in these calls, <br><pre> <code class="cpp hljs">f(r1); f(r2);</code> </pre><br>  the inferred type for both r1 and r2 is int &amp;.  Why?  First, the reference part of types r1 and r2 is discarded (int is obtained in both cases), then, since it is an lvalue, both are treated as int &amp; during type inference for the universal reference parameter in the call to f. <br><br>  Link collapsing occurs, as I noted, in ‚Äúcontexts such as template instantiation‚Äù.  The second such context is the definition of ‚Äúauto‚Äù variables.  Type inference for auto variables that are universal references is essentially identical to type inference for function template parameters that are universal references, so type T lvalue is output as T &amp; type, and type T rvalue is output as T &amp; type.  Consider again the example from the beginning of the article: <br><pre> <code class="cpp hljs">Widget&amp;&amp; var1 = someWidget; <span class="hljs-comment"><span class="hljs-comment">// var1   Widget&amp;&amp; (auto  ) auto&amp;&amp; var2 = var1; // var2   Widget&amp; (. )</span></span></code> </pre><br>  The var1 type is Widget &amp;&amp;, but its ‚Äúreference part‚Äù is ignored during type inference during var2 initialization;  it is considered a widget type.  Since this is the lvalue that is used to initialize the universal reference (var2), the inferred type will be Widget &amp;.  Substituting Widget &amp; instead of auto in the definition of var2, we get the following invalid code, <br><pre> <code class="cpp hljs">Widget&amp; &amp;&amp; var2 = var1; <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  which after collapsing links will be <br><pre> <code class="cpp hljs">Widget&amp; var2 = var1; <span class="hljs-comment"><span class="hljs-comment">// var2   Widget&amp;</span></span></code> </pre><br>  The third context of link folding is the formation and use of typedef.  Given this class pattern <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T&amp; LvalueRefType; ... };</code> </pre><br>  and such use of this pattern, <br><pre> <code class="cpp hljs">Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&gt; w;</code> </pre><br>  the instantiated class will contain the following (invalid) typedef: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; &amp; LvalueRefType;</code> </pre><br>  Collapsing links results in the following valid code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; LvalueRefType;</code> </pre><br>  If we then use this typedef in context using references to it, for example, <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;&gt;::LvalueRefType&amp;&amp; param)</span></span></span></span>;</code> </pre><br>  after typedef deployment, the following invalid code will be generated, <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; &amp;&amp; param)</span></span></span></span>;</code> </pre><br>  but minimizing the links will cut it down and the final declaration f will be: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; param)</span></span></span></span>;</code> </pre><br>  The final context where link folding is applied is the use of decltype.  As with templates and auto, decltype performs an expression type deduction that gives either T or T &amp; types, and decltype then applies C ++ 11 reference folding rules. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, the rules for folding links used by decltype are not the same as those used in inferring a type for a template or an auto type. The details are too complicated to discuss here (the ‚ÄúMore Information‚Äù section provides links for details), but the noticeable difference is that decltype for a named variable of a non-reference type displays type T (that is, not a reference type) when under certain conditions templates and auto-types output type T &amp;. Another important difference is that decltype inference depends only on the decltype of the expression; The type of initialization expression (if any) is ignored. Consequently:</font></font><br><pre> <code class="cpp hljs">Widget w1, w2; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; v1 = w1; <span class="hljs-comment"><span class="hljs-comment">// v1   , //  lvalue,  v1 //  lvalue   w1. decltype(w1)&amp;&amp; v2 = w2; // v2   ,  decltype(w1)  Widget, //   v2  rvalue . // w2  lvalue,    // rvalue  lvalue,      .</span></span></code> </pre><br><br><h5>  Conclusion </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the description of the type ‚Äú&amp;&amp;‚Äù means either a rvalue reference, or a universal reference ‚Äî a reference that is either an lvalue reference or an rvalue reference. Universal links always have the form T &amp;&amp; for some derived type T. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link folding is a mechanism for casting universal links (which are just rvalue links in situations where link folding is applied) sometimes to lvalue links, and sometimes to rvalue links. It is used in special contexts in which links to links may appear as a result of compilation. These are contexts for the deduction of the type of a template, the deduction of an auto-type, the generation and use of a typedef and a decltype expression.</font></font><br><br><h5>  Acknowledgments </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The draft versions of this article were reviewed by Cassio Neri, Michal Mocny, Howard Hinnant, Andrei Alexandrescu, Stephan T. Lavavej, Roger Orr, Chris Oldwood, Jonathan Wakely and Anthony Williams. </font><font style="vertical-align: inherit;">Their comments contributed to significant improvements in the article, as well as its presentation.</font></font><br><br><h5>  Additional Information </h5><br> <a href="http://en.wikipedia.org/wiki/C%252B%252B11"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11, Wikipedia. </font></font></a> <br><br> <a href="http://www.artima.com/shop/overview_of_the_new_cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overview of the New C ++ (C ++ 11), Scott Meyers, Artima Press, last updated January 2012. </font></font></a> <br><br> <a href="http://thbecker.net/articles/rvalue_references/section_01.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Rvalue References Explained, Thomas Becker, last updated September 2011. </font></font></a> <br><br> <a href="http://en.wikipedia.org/wiki/Decltype"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decltype, Wikipedia. </font></font></a> <br><br> <a href="http://drdobbs.com/blogs/cpp/231002789"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúA Note About decltype,‚Äù Andrew Koenig, Dr. </font><font style="vertical-align: inherit;">Dobb's, July 27, 2011.</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/157961/">https://habr.com/ru/post/157961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157945/index.html">Domain Controller Migration and Team Foundation Server Creation on a Virtual Machine in Windows Azure</a></li>
<li><a href="../157947/index.html">Stop twisting!</a></li>
<li><a href="../157953/index.html">Microsoft patents a new type of DRM protection - tracking users who view content</a></li>
<li><a href="../157957/index.html">Why em?</a></li>
<li><a href="../157959/index.html">The Russian-speaking community MODX goes into the lead!</a></li>
<li><a href="../157965/index.html">Styling SVG graphics</a></li>
<li><a href="../157967/index.html">20 largest domain sales in history</a></li>
<li><a href="../157969/index.html">Be careful when buying a MacBook. High-tech offline fraud</a></li>
<li><a href="../157973/index.html">Microsoft Seed Fund in Russia - the next cycle for receiving applications for grants ends on November 18</a></li>
<li><a href="../157975/index.html">Working with GPS in WinCE (C #)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>