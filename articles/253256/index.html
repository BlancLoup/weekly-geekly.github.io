<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding the installation and booting of Linux on the example of ArchLinux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="First we install Archlinux and turn it into a boot server. Right from there we will prepare a new compact system, to which we will add a minimal graph...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding the installation and booting of Linux on the example of ArchLinux</h1><div class="post__text post__text-html js-mediator-article">  First we install Archlinux and turn it into a boot server.  Right from there we will prepare a new compact system, to which we will add a minimal graphical environment and the most necessary functionality (for example, Firefox).  We will teach our system to boot over the network even on computers with UEFI.  Then we will fully translate it into a ‚Äúread only‚Äù mode (let's make it ‚Äúlive‚Äù), which will allow us to use the system at the same time on the floor of a hundred unsuited computers with one single boot server.  All this will work even inside a cheap 100-MB network, which we will additionally ‚Äúoverclock‚Äù a couple of times. <br><br>  No bookmarks in hard disks will be terrible for you, because we will not have disks.  No crazy users handles will break anything, since after a reboot, the system will return to its original state.  Of course, you will learn and be able to independently modify the boot system so that it contains only the functionality you need and nothing extra.  In between, we will figure out how and in what order Linux boots, and what it is made of.  Knowledge, as we know, is priceless, so I share them with a gift. <br><br>  I will try, without much deliberation, to explain what is happening, sometimes looking a little ahead, but afterwards, be sure to sort it all out.  So that you do not have any problems with understanding, I assume that you have already worked with some ready-made Linux distribution, tried to write simple scripts using nano or another text editor.  If you are new to ArchLinux, then you will learn a lot of new things, and if you are ‚Äúold man‚Äù you will learn less, but I hope that in any case you will love Linux even more. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There was a lot of information.  And according to the established Hollywood tradition, the series awaits you in several parts: <br>  <a href="http://habrahabr.ru/post/253573/">continuation</a> ; <br>  <a href="http://habrahabr.ru/post/254415/">ending</a> <br><br>  Now we will install Archlinux in VirtualBox, which can be cloned and run on almost any computer with legacy BIOS without any additional settings.  In the meantime, we will learn about the basic techniques for working with systemd, as well as how to use it to run arbitrary services and programs at boot time.  We will also see what stages Linux is going through when booting, and write our own handler (hook), which we put in the initramfs.  Don't know what initramfs is?  Then go under the cat. <br><a name="habracut"></a><br>  There are many reasons why the choice fell on Archlinux.  First reason: he is my long-time shrewd friend and loyal assistant.  Gentoo, as they say on the Internet, is even more resourceful, but I don‚Äôt want to build a system from source.  The second reason: ready-made assemblies always contain a lot of excess, and pumping large amounts of data can critically affect network performance, and nothing can be seen behind the wide back of the ‚Äúautomatic installer‚Äù - this is the third reason.  Fourth: systemd gradually penetrates all distributions and <a href="http//habrahabr.ru/post/240839/">even Debian</a> , so that we can thoroughly delve into the future ready distributions using the example of Archlinux.  With all this, the system that we will later prepare can be downloaded over the network not only by a server running in a virtual machine, but also from a regular computer, for example, with Raspberry Pi, and even with Western Digital My Cloud (verified) Works under Debian. <br><br><h2>  Preparatory work </h2><br>  Download the latest image from the link from the <a href="https://www.archlinux.org/download/">official site</a> .  In Moscow, from Yandex servers, for example, the download happens very quickly, and if your process has been delayed - just try downloading it elsewhere.  I recommend to remember in what, because this information is still useful to us. <br><br>  In VirtualBox we create a new virtual machine (for example, with 1 GB of RAM and 8 GB of storage).  In the network settings, you must select the type of connection "network bridge" and the appropriate network adapter with Internet access.  We connect the downloaded image to the CD-ROM.  If you can‚Äôt wait to start working with hardware, then take a flash drive and burn an image using <a href="http://sourceforge.net/projects/win32diskimager">Win32 Disk Imager</a> (if you work under Windows), and then load the future server directly from it. <br><br>  We turn on the machine, wait for the command line to appear and set a password, without which SSH will not work: <br><br><pre><code class="bash hljs">passwd</code> </pre> <br>  Start the SSH server with the command: <br><br><pre> <code class="bash hljs">systemctl start sshd</code> </pre> <br>  It remains to find the IP address of the machine, examining the output of the command: <br><br><pre> <code class="bash hljs">ip addr | grep <span class="hljs-string"><span class="hljs-string">"scope global"</span></span></code> </pre> <br>  The address will be indicated immediately after the ‚Äúinet‚Äù. <br><br>  Now Windows users will be able to connect to the machine using <a href="http://www.putty.org/">putty</a> , and then they will copy the commands from here and paste them in and right-click. <br><br><h2>  Basic setup </h2><br>  Next, I will briefly describe the standard Archlinux installation.  If you have questions, you will probably find the answers to them in the <a href="https://wiki.archlinux.org/index.php/Beginners%2527_guide">Detailed Installation Description for beginners</a> .  The wiki is simply wonderful, and the English-language wiki is even relevant, so try to use it. <br><br>  Prepare the media using cfdisk (this is a console utility with a simple and intuitive interface).  One section is enough for us, just do not forget to mark it as bootable: <br><br><pre> <code class="bash hljs">cfdisk /dev/sda</code> </pre> <br>  We formatted in ext4 and set a label, for example HABR: <br><br><pre> <code class="bash hljs">mkfs.ext4 /dev/sda1 -L <span class="hljs-string"><span class="hljs-string">"HABR"</span></span></code> </pre> <br>  The future root partition is mounted in / mnt: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> root=/mnt mount /dev/sda1 <span class="hljs-variable"><span class="hljs-variable">$root</span></span></code> </pre> <br>  Archlinux is usually installed via the Internet, so immediately after installation you will have the newest and most current version.  The list of repositories is in the file /etc/pacman.d/mirrorlist.  Try to remember where you downloaded the distribution and move these servers to the very top of the list - this will save you a lot of time in the next step.  Usually these are servers geographically located in the same place where you are now. <br><br><pre> <code class="bash hljs">nano /etc/pacman.d/mirrorlist</code> </pre> <br>  Install the basic set of packages and the set for developers: <br><br><pre> <code class="bash hljs">pacstrap -i <span class="hljs-variable"><span class="hljs-variable">$root</span></span> base base-devel</code> </pre> <br>  Now we use the arch-chroot command, which allows you to temporarily change the root directory to any other one that has the structure of the Linux root file system.  At the same time, the programs that we launch from there will not know that something else exists outside.  We will practically find ourselves in our new system with administrator rights: <br><br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span></code> </pre> <br>  Notice how the command prompt has changed. <br><br>  Choose the languages ‚Äã‚Äãthat we plan to use.  I propose to leave en_US.UTF-8 UTF-8 and ru_RU.UTF-8 UTF-8.  In a text editor, you just need to remove comments in front of them: <br><br><pre> <code class="bash hljs">nano /etc/locale.gen</code> </pre> <br>  Now we generate the selected localizations: <br><br><pre> <code class="bash hljs">locale-gen</code> </pre> <br><br>  If everything went well, then you will see something like this: <br><br><pre> <code class="bash hljs">Generating locales... en_US.UTF-8... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> ru_RU.UTF-8... <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Generation complete.</code> </pre> <br>  Set the language to be used by default: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> LANG=ru_RU.UTF-8 &gt; /etc/locale.conf</code> </pre> <br>  As well as the layout and font in the console: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -e <span class="hljs-string"><span class="hljs-string">"KEYMAP=ru\nFONT=cyr-sun16\nFONT_MAP="</span></span> &gt; /etc/vconsole.conf</code> </pre> <br><br>  Specify the time zone (I use Moscow time): <br><br><pre> <code class="bash hljs">ln -s /usr/share/zoneinfo/Europe/Moscow /etc/localtime</code> </pre> <br>  We make a name for our future server: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"HabraBoot"</span></span> &gt; /etc/hostname</code> </pre> <br>  Now set the admin password.  We do this primarily because SSH will not allow us to connect to the system without a password.  The theme of the unreasonable use of the system, unprotected with a password, we will not develop here. <br><br><pre> <code class="bash hljs">passwd</code> </pre> <br>  Twice we enter the password and we are convinced that <b>password updated successfully</b> . <br><br>  Add a new user named <i>username</i> (you can choose any), give him administrator rights and give him a password for the same reasons, but also because under root in the current version of Arch we will not be able to build packages from AUR (Arch User Repository is a repository from the Arch Linux user community with programs that are not in the main repository): <br><br><pre> <code class="bash hljs">useradd -m username</code> </pre> <br>  Edit the / etc / sudoers settings file using nano: <br><br><pre> <code class="bash hljs">EDITOR=nano visudo</code> </pre> <br>  Adding to it immediately after the line ‚Äúroot ALL = (ALL) ALL‚Äù one more line: <br><br><pre> <code class="bash hljs">username ALL=(ALL) ALL</code> </pre> <br>  And set the password for the username: <br><br><pre> <code class="bash hljs">passwd username</code> </pre> <br>  Now you need to install the bootloader on the internal drive so that the system can boot from it.  As a bootloader, I suggest using GRUB, because later it will come in handy again.  Install packages using the standard Archlinux package manager pacman: <br><br><pre> <code class="bash hljs">pacman -S grub</code> </pre> <br>  Write the bootloader to the MBR (Master Boot Record) of our internal drive. <br><br><pre> <code class="bash hljs">grub-install --target=i386-pc --force --recheck /dev/sda</code> </pre> <br>  If everything went well, then you will see <b>Installation finished.</b>  <b>No error reported</b> . <br><br>  Exit the chroot: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> <br>  And we notice how the command line prompt has changed. <br><br>  We will use disk labels, a detailed explanation of this statement will follow later. <br><br>  Remove the comment from the line <b>GRUB_DISABLE_LINUX_UUID = true</b> so that the UUIDs of the drives are not used: <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/default/grub</code> </pre> <br>  We generate the boot loader configuration file again using the arch-chroot.  A single command will be logged in, and an automatic logout will follow: <br><br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> grub-mkconfig --output=/boot/grub/grub.cfg</code> </pre> <br>  We need to replace all references to <b>/ dev / sda1</b> with <b>LABEL = HABR</b> in the configuration file: <br><br><pre> <code class="bash hljs">mv <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/boot/grub/grub.cfg <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/boot/grub/grub.cfg.autoconf &amp;&amp; cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/boot/grub/grub.cfg.autoconf | sed <span class="hljs-string"><span class="hljs-string">'s/\(root=\)\/dev\/sda1/\1LABEL=HABR/g'</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/boot/grub/grub.cfg</code> </pre> <br>  If you change the line <b>set lang = en_US</b> to <b>set lang = ru_RU</b> in the same file, the bootloader will communicate with us on the great and mighty. <br><br>  We generate the fstab file with the -L key, which will force the generator to use disk labels: <br><br><pre> <code class="bash hljs">genfstab -p -L <span class="hljs-variable"><span class="hljs-variable">$root</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/fstab</code> </pre> <br>  This completes the basic ArchLinux installation.  The system will boot on its own and will meet you with a friendly Russian-language command line interface.  If after this we enter the dhcpcd command, then most likely even the Internet will work.  But we will not rush to reboot. <br><br><h2>  Run at boot using systemd using NTP and SSH as an example </h2><br>  Since our system will communicate with other computers, we will need to synchronize time.  If the time on the server and the client is different, then there is a high probability that they will not be able to connect with each other at all.  In turn, sudo can start asking for a password after each action, thinking that the authorization timeout has expired long ago.  And who knows what we still have to face?  Reinsured. <br><br>  To synchronize time with servers over the Internet using the NTP protocol, we need to install the missing packets.  You can use arch-root, but we‚Äôll manage with keys that tell a new place to install the package manager: <br><br><pre> <code class="bash hljs">pacman --root <span class="hljs-variable"><span class="hljs-variable">$root</span></span> --dbpath <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/var/lib/pacman -S ntp</code> </pre> <br>  Let's configure getting the exact time from Russian servers: <br><br><pre> <code class="bash hljs">mv <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/ntp.conf <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/ntp.conf.old &amp;&amp; cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/ntp.conf.old | sed <span class="hljs-string"><span class="hljs-string">'s/\([0-9]\).*\(.pool.ntp.org\)/\1.ru\2/g'</span></span> | tee <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/ntp.conf</code> </pre> <br><br>  We just need to synchronize the time once at boot.  Previously, we would have recorded the start of the exact time service in the rc.local file, but now a system manager and systemd services manager appear, who are trying to start the services (in the original, they are called unit) in parallel to reduce the system load time.  Naturally, the performance of one service may depend on the operation of another.  For example, it is useless for us to try to synchronize time via the Internet before the network is running on our computer.  To describe all these relationships, simply specifying the name of the executable file is no longer enough; therefore, running via systemd has become a very non-trivial exercise.  For this purpose, special files were created with the extension ".service".  They indicate dependencies, executable file names and other parameters that must be considered for a successful launch.  In particular, to control the stages of loading in systemd, targets (target) are used, which, according to the tasks assigned to them, are similar to launch levels (runlevel).  Read more on the <a href="https://wiki.archlinux.org/index.php/systemd">wiki</a> . <br><br>  To the delight of beginners, along with the ntp package comes already ready ntpdate.service.  All files describing the launch of services are located in the $ root / usr / lib / systemd / system / folder, and they can be opened in any text editor or viewed in the usual way.  For example, $ root / usr / lib / systemd / system / ntpdate.service: <br><br><pre> <code class="bash hljs">[Unit] Description=One-Shot Network Time Service After=network.target nss-lookup.target Before=ntpd.service [Service] Type=oneshot PrivateTmp=<span class="hljs-literal"><span class="hljs-literal">true</span></span> ExecStart=/usr/bin/ntpd -q -n -g -u ntp:ntp [Install] WantedBy=multi-user.target</code> </pre> <br>  In the [Unit] block, the Description line indicates a brief description of the service, and under what conditions it should be started (in this case, after starting the network, but before the start of the NTP server, which we do not plan to start at all).  The exact time request occurs only once during the download, and the Type = oneshot line from the [Service] block is responsible for this.  In the same block, the ExecStart line contains the actions that must be performed to start the service.  In the [Install] block in our case, it is indicated that the launch of our service is necessary to achieve the goal of multi-user.target.  It is recommended to use the same content of the [Install] block to run self-made services. <br><br>  As a first practical example, we will slightly expand the functionality of ntpdate.service, asking it to additionally fix the time on the hardware clock.  If after this, on the same computer, you boot Windows, then you will see GMT, so do not be intimidated. <br><br>  Changing the standard behavior of any systemd service is done as follows: first, a new directory with the full service name and the extension ".d" is created in the / etc / systemd / system / folder, where the file with an arbitrary name and the extension ".conf" is added, and there necessary modifications are made.  Let's start: <br><br><pre> <code class="bash hljs">mkdir -p <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/systemd/system/ntpdate.service.d &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -e <span class="hljs-string"><span class="hljs-string">'[Service]\nExecStart=/usr/bin/hwclock -w'</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/systemd/system/ntpdate.service.d/hwclock.conf</code> </pre> <br>  It simply says that immediately after starting the service, execute the command "/ usr / bin / hwclock -w", which will translate the hardware clock. <br><br>  Add the ntpdate service to autoload (syntax is standard for all services): <br><br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> ntpdate Created symlink from /etc/systemd/system/multi-user.target.wants/ntpdate.service to /usr/lib/systemd/system/ntpdate.service.</code> </pre><br>  As you can see, an ordinary symbolic link to the ntpdate.service file was created in the multi-user.target.wants directory, and we saw the mention of the multi-user.target target in the [Install] block of this file itself.  It turns out that in order for the system to reach the goal of multi-user.target, all services from the multi-user.target.wants directory must be running. <br><br>  Now install the SSH package in a similar way (in ArchLinux it is called openssh): <br><br><pre> <code class="bash hljs">pacman --root <span class="hljs-variable"><span class="hljs-variable">$root</span></span> --dbpath <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/var/lib/pacman -S openssh</code> </pre> <br>  But this time for autorun, we will use a socket so that the SSH server starts only after a connection request is received, and does not hang as a dead load in the RAM: <br><br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> sshd.socket</code> </pre> <br>  We did not change the standard port 22 and did not include the forced use of Protocol 2 - let it remain on my conscience. <br><br><h2>  Looking ahead or getting acquainted with handlers (hooks) </h2><br>  So that we can connect to our future server without looking, we need to know its IP address.  It will be much easier if this address is static.  The usual methods mentioned in the wiki do not suit us.  The problem is that network adapters in the modern world are named according to their physical location on the motherboard.  For example, the device name enp0s3 means that it is an ethernet network adapter, which is located on PCI bus zero in the third slot (see details <a href="http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/">here</a> ).  Made so that when replacing one adapter with another, the device name in the system does not change.  This behavior is not desirable for us, since on different motherboard models the position of the network card may be different, and when we try to transfer our boot server from VirtualBox to real hardware, we will most likely have to boot with the keyboard and monitor in order to properly configure the network. .  We need to make the name of the network adapter more predictable, for example, eth0 (this place is reserved by an emoticon). <br><br><div class="spoiler">  <b class="spoiler_title">Why do we do this?</b> <div class="spoiler_text">  I have no doubt that there are more elegant solutions to the problem of device names, but the following version turned out to be very suitable to demonstrate the general principle of booting Linux.  Please do not forget to acquaint the community with the methods you have verified in the comments. </div></div><br>  Install the mkinitcpio-nfs-utils package, and we will have a hook (called ‚Äúnet‚Äù): <br><br><pre> <code class="bash hljs">pacman --root <span class="hljs-variable"><span class="hljs-variable">$root</span></span> --dbpath <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/var/lib/pacman -S mkinitcpio-nfs-utils</code> </pre> <br><br>  By default, all handler files fall into / usr / lib / initcpio /.  These are usually paired files with the same name, one of which will be in the install subdirectory and the other in hooks.  The files themselves are ordinary scripts.  The file from the hooks folder usually gets inside the initramfs file (we will find out about it later) and runs when the system boots.  The second file of the pair is in the install folder.  Inside it is the build () function, which contains information about what actions need to be performed during the generation of the initramfs file, as well as the help () function with a description of what this handler is intended for.  If you are confused, then just read on, and everything said in this paragraph will fall into place. <br><br>  The initcpio folder is also present in the / etc directory, and it also has install and hook subdirectories.  However, it has unconditional priority over / usr / lib / initcpio, i.e., if both folders contain files with the same name, then when generating initcpio, files from / etc / initcpio will be used, not from / usr / lib / initcpio . <br><br>  We need to slightly change the functionality of the net handler, so just copy the files from / usr / lib / initcpio to / etc / initcpio: <br><br><pre> <code class="bash hljs">cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/usr/lib/initcpio/hooks/net <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/hooks/ &amp;&amp; cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/usr/lib/initcpio/install/net <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/install/</code> </pre> <br>  We bring the hooks / net file to the following form: <br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/hooks/net <span class="hljs-comment"><span class="hljs-comment"># vim: set ft=sh: run_hook() { if [ -n "$ip" ] then ipconfig "ip=${ip}" fi } # vim: set ft=sh ts=4 sw=4 et:</span></span></code> </pre> <br><br>  Now open the $ root / etc / initcpio / install / net file and see that the help () function says well what the ‚Äúip‚Äù variable should be: <br><pre> <code class="bash hljs">ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;</code> </pre> <br>  It remains to simply set the value of the variable to set the static IP address and the name of the network device, for example, ‚Äú192.168.1.100::192.168.1.1:255.255.255.0::eth0:none‚Äù (hereinafter use the appropriate network settings for yourself).  In the next section, you will learn exactly where the value is set. <br><br>  In the meantime, remove all unnecessary from the file $ root / etc / initcpio / install / net.  We leave the download of the modules of network devices, the ipconfig program that was used above, and, of course, the script itself from the hooks folder, which does all the basic work.  It turns out about the following: <br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/install/net <span class="hljs-comment"><span class="hljs-comment">#!/bin/bash build() { add_checked_modules '/drivers/net/' add_binary "/usr/lib/initcpio/ipconfig" "/bin/ipconfig" add_runscript } help() { cat &lt;&lt;HELPEOF This hook loads necessary modules for a network device. Manually configures network and freezes network device name. HELPEOF } # vim: set ft=sh ts=4 sw=4 et:</span></span></code> </pre> <br>  When the systemd-udevd device manager tries to rename our network device to its usual predictable network interface name, for example, enp0s3, at boot time, it will fail.  Why - read on. <br><br><h2>  How does the system boot? </h2><br>  For simplicity, consider the usual BIOS.  After power up and initialization, the BIOS starts to go through the list of boot devices in order, until it finds a boot loader, to which it will transfer further boot control. <br><br>  Just such a bootloader we recorded in the MBR of our drive.  We used GRUB, in the settings of which (the grub.cfg file) indicated that the root partition is on a disk labeled HABR.  Here is the entire line: <br><br><pre> <code class="bash hljs">linux /boot/vmlinuz-linux root=LABEL=HABR rw quiet</code> </pre> <br>  The vmlinuz-linux file, which is the kernel of the system, is mentioned here, and the pointer to the root system is its parameter.  We ask to look for the root system on the device labeled HABR.  It could also be unique for each drive UUID, but in this case, when transferring the system to another drive, we would undoubtedly have to change it.  If we specified the position of the root system in the usual way for Linux users: / dev / sda1, we would not be able to boot from the USB drive, because this USB drive would only get being the only drive in the computer.  It is unlikely that the computer will be another drive labeled HABR, but do not forget about it. <br><br>  It also sets the value of the global variable ‚Äúip‚Äù for our handler ‚Äúnet‚Äù (do not forget to change the addresses for those used in your network): <br><br><pre> <code class="bash hljs">linux /boot/vmlinuz-linux root=LABEL=HABR rw quiet ip=192.168.1.100::192.168.1.1:255.255.255.0::eth0:none</code> </pre> <br><br>  In the next line there is a mention of the initramfs file, which I promised to deal with: <br><br><pre> <code class="bash hljs">initrd /boot/initramfs-linux.img</code> </pre> <br>  Then, when booting, the following happens: the GRUB loader receives the vmlinuz and initramfs files, tells them where to look for the root file system and gives them control of the further boot. <br><br>  The name initramfs is derived from the initial ram file system.  This is actually the usual Linux root filesystem, packaged in an archive.  It is deployed in RAM at boot time and is designed to find and prepare the root file system of our linux, which we are trying to load as a result.  In initramfs there is everything you need for these purposes, because it is a real ‚Äúlittle Linux‚Äù that can execute many ordinary commands.  Its capabilities are extended with the help of handlers (hooks), which help to create a new root filesystem of our linux. <br><br>  After the programs from the initramfs have done their work, further loading control is transferred to the init process of the prepared root file system.  Archlinux uses systemd as the init process. <br><br>  The systemd-udevd device manager is part of systemd.  He, like his older brother, tries to detect and configure all devices in the system in parallel.  It starts its work one of the first, but already after our net handler initializes the network card at the initramfs stage of operation.  Thus, systemd-udevd cannot rename the device being used, and the name eth0 remains behind the network card for the entire duration of its operation. <br><br><h2>  Cooking initramfs </h2><br>  To create an initramfs file, use the mkinitcpio program, which is included in the base package that we installed at the very beginning.  The settings are in the $ root / etc / mkinitcpio.conf file, and the presets are in the /etc/mkinitcpio.d folder.  We are required to make initramfs such that it can find and prepare the root file system, from which systemd will start working later.  We absolutely do not need to take into account all possible options, only the most necessary is enough to not increase the size of the initramfs file.  More information is available here <a href="https://wiki.archlinux.org/index.php/Mkinitcpio">wiki.archlinux.org/index.php/Mkinitcpio</a> <br><br>  Be sure to remove the autodetect handler.  It checks the devices installed in this particular computer, and leaves only the modules necessary for them in the initramfs.  We do not need this, since we initially consider the possibility of further transferring the system to another computer, which is hardware most likely to be different from the virtual machine being used. <br><br>  A list of handlers, sufficient for our purposes, including the net we created, is as follows: <br><pre> <code class="bash hljs">HOOKS=<span class="hljs-string"><span class="hljs-string">"base udev net block filesystems"</span></span></code> </pre> <br>  We insert this line into the mkinitcpio.conf file, and comment on the old one: <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.conf</code> </pre> <br><br>  Based on the standard linux preset, we create our own habr preset: <br><br><pre> <code class="bash hljs">cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.d/linux.preset <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.d/habr.preset</code> </pre> <br><br>  And we bring it to this form: <br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.d/habr.preset ALL_config=<span class="hljs-string"><span class="hljs-string">"/etc/mkinitcpio.conf"</span></span> ALL_kver=<span class="hljs-string"><span class="hljs-string">"/boot/vmlinuz-linux"</span></span> PRESETS=(<span class="hljs-string"><span class="hljs-string">'default'</span></span> ) default_image=<span class="hljs-string"><span class="hljs-string">"/boot/initramfs-linux.img"</span></span></code> </pre> <br><br>  We do not need the 'fallback' branch, which removes autodetect from the handlers, because we have already removed it ourselves, and we don‚Äôt need to generate the same initramfs file with different names twice. <br><br>  Generating new initramfs using the habr preset: <br><br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> mkinitcpio -p habr</code> </pre> <br><h2>  Writing DNS update service for use with systemd </h2><br>  Our network card receives all the settings for the network and the Internet to work.  But site names will not be translated into IP addresses, since our system does not know which DNS servers to use for this.  We will write our own service for this purpose, which, when loaded, will be run by systemd.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in order to learn something new and not get bored of the monotony, let us transfer the information about the name of the network device as a parameter, and save the list of DNS servers in an external file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DNS server information is updated by resolvconf. </font><font style="vertical-align: inherit;">We are ideally suited syntax:</font></font><br><br><pre> <code class="bash hljs">resolvconf [-m metric] [-p] -a interface &lt;file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the file imported here, the IP address of each server is indicated in the new line after the nameserver keyword. </font><font style="vertical-align: inherit;">You can specify as many servers as you like, but only the first 3 of them will be used. </font><font style="vertical-align: inherit;">As an example, we use Yandex servers. </font><font style="vertical-align: inherit;">In this case, the file passed to resolvconf should look like this:</font></font><br><br><pre> <code class="bash hljs">nameserver 77.88.8.8 nameserver 77.88.8.1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to obtain information about DNS servers before the system is confident that the network is fully operational, that is, before reaching the goal of network.target. We assume that we only need to update the server information once during the download. And standardly, we say that our service is required by the goal of multi-user.target. Create a service startup file in the directory with the following content:</font></font><br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/systemd/system/update_dns@.service [Unit] Description=Manual resolvconf update (%i) Before=network.target [Service] Type=oneshot EnvironmentFile=/etc/default/dns@%i ExecStart=/usr/bin/sh -c <span class="hljs-string"><span class="hljs-string">'echo -e "nameserver ${DNS0}\nnameserver ${DNS1}" | resolvconf -a %i'</span></span> [Install] WantedBy=multi-user.target</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the ExecStart line, we execute the echo command, which generates a file with a list of servers on the fly, which passes the resolvconf through the pipeline. In general, you cannot use several commands in the ExecStart line, much less pipelines, but we again deceived everyone by passing these commands as the -c parameter for / usr / bin / sh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that the name of the update_dns @ .service file uses the @ symbol, after which you can specify a variable, and it will fall inside the file, replacing "% i". Thus, the string EnvironmentFile = / etc / default / dns @% i turns into EnvironmentFile = / etc / default / dns @ eth0 - this is the name of the external file, we will use to store the values ‚Äã‚Äãof the variables DNS0 and DNS1. The syntax is like in ordinary scripts: ‚Äúvariable name = variable value‚Äù. Create a file:</font></font><br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/default/dns@eth0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And add the following lines: </font></font><br><br><pre> <code class="bash hljs">DNS0=77.88.8.8 DNS1=77.88.8.1</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we add the service to autoload without forgetting to specify the name of the network card after @: </font></font><br><br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> update_dns@eth0.service</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have just written a universal file that provides the launch of the service. </font><font style="vertical-align: inherit;">The versatility is that if there are several network adapters in our system, then for each of them we will be able to specify our own DNS servers. </font><font style="vertical-align: inherit;">You will need to simply prepare a set of files with a list of servers for each of the devices and start the service for each adapter separately, specifying its name after @.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Before the first launch </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This completes the initial setup. </font><font style="vertical-align: inherit;">We need to load the installed ArchLinux from the internal drive so that the changes we make take effect. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turning off the finished root system:</font></font><br><br><pre> <code class="bash hljs">umount <span class="hljs-variable"><span class="hljs-variable">$root</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And turn off the virtual machine: </font></font><br><br><pre> <code class="bash hljs">poweroff</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you can disable the boot image from the CD-ROM or get a flash drive, then turn on the machine and make sure that everything works. </font></font><br><br> <a href="http://habrahabr.ru/post/253573/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://habrahabr.ru/post/254415/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ending</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/253256/">https://habr.com/ru/post/253256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253238/index.html">Installing and running Android applications on Linux</a></li>
<li><a href="../253240/index.html">Self assembly or purchase of ready equipment for design. 3d printer. Part 1</a></li>
<li><a href="../253246/index.html">The power of minimalism: how we changed the design of Yelp</a></li>
<li><a href="../253248/index.html">Cognitoys: IBM's Intelligent Intelligent Intelligent Toy</a></li>
<li><a href="../253250/index.html">Richard Stallman: Why we need free digital iron circuits</a></li>
<li><a href="../253260/index.html">Installing the grub4dos bootloader on a USB flash drive from a linux console</a></li>
<li><a href="../253262/index.html">About making sustainable decisions or a case club on Habr√©</a></li>
<li><a href="../253264/index.html">About highway</a></li>
<li><a href="../253266/index.html">Gson cheat sheet for Map, List and Array</a></li>
<li><a href="../253268/index.html">How we spent 1 year and 3 months to develop a browser game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>