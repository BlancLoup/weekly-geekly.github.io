<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a plugin for logical replication in PostgreSQL 9.4+</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As many who are interested, they know that in PostgreSQL in version 9.4 there appeared (finally) logical decoding. Now, to make your replication, you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a plugin for logical replication in PostgreSQL 9.4+</h1><div class="post__text post__text-html js-mediator-article"> As many who are interested, they know that in PostgreSQL in version 9.4 there appeared (finally) logical decoding.  Now, to make your replication, you do not have to deal with the format of binary wal files or write triggers (maybe there were other ways), and convert the data into a format that is convenient for you.  To do this, just write a plug-in to PostgreSQL, which will do this.  This article describes a plugin that converts data to JSON. <br><a name="habracut"></a><br><br>  The plugin code is on github - <a href="https://github.com/ildus/decoder_json">github.com/ildus/decoder_json</a> .  Pull requests with improvements (especially in terms of improving support for types), bugfixes and simply cosmetic improvements are welcomed.  JSON was chosen for simplicity.  This is not the final version, perhaps after testing on real data it will turn out that a more productive format is needed, and you will have to redo it.  In the article I will not give all the code for the plugin, but only parts about which I think I need to tell. <br><br>  Requirements for creating a plugin: knowledge C, installed build tools (gcc, cmake), installed packages (on debian-systems) postgresql-9.4, postgresql-server-dev-9.4 and similar on other systems.  After installing postgresql, in postgresql.conf, you must set the value max_replication_slots = 1 (or more) and wal_level = logical. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The plugin itself is a plug-in library in C, from which callback functions to postgresql events are called.  During initialization, the <code>_PG_output_plugin_init</code> function is <code>_PG_output_plugin_init</code> with a structure whose fields need to be assigned their own functions: <br><br><ul><li>  startup_cb - a function called when the plugin is initialized </li><li>  begin_cb - start transaction </li><li>  change_cb - write data </li><li>  commit_cb - transaction approval </li><li>  shutdown_cb - plugin deinitialization </li></ul><br>  The function that fills the structure: <br><br><pre> <code class="hljs erlang-repl">void _PG_output_plugin_init(OutputPluginCallbacks *cb) { cb-&gt;startup_cb = decoder_json_startup; cb-&gt;begin_cb = decoder_json_begin_txn; cb-&gt;change_cb = decoder_json_change; cb-&gt;commit_cb = decoder_json_commit_txn; cb-&gt;shutdown_cb = decoder_json_shutdown; }</code> </pre> <br>  It now remains to define these five functions.  <code>decoder_json_startup</code> is called at the beginning of the decoding and is used to set the decoding options and create its own memory context: <br><br><div class="spoiler">  <b class="spoiler_title">Decoder_json_startup function</b> <div class="spoiler_text"><pre> <code class="hljs php"><span class="hljs-comment"><span class="hljs-comment">/* initialize this plugin */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void decoder_json_startup(LogicalDecodingContext *ctx, OutputPluginOptions *opt, bool is_init) { ListCell *option; DecoderRawData *data; data = palloc(sizeof(DecoderRawData)); data-&gt;context = AllocSetContextCreate(ctx-&gt;context, <span class="hljs-string"><span class="hljs-string">"Raw decoder context"</span></span>, ALLOCSET_DEFAULT_MINSIZE, ALLOCSET_DEFAULT_INITSIZE, ALLOCSET_DEFAULT_MAXSIZE); data-&gt;include_transaction = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; data-&gt;sort_keys = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ctx-&gt;output_plugin_private = data; <span class="hljs-comment"><span class="hljs-comment">/* Default output format */</span></span> opt-&gt;output_type = OUTPUT_PLUGIN_TEXTUAL_OUTPUT; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(option, ctx-&gt;output_plugin_options) { DefElem *elem = lfirst(option); Assert(elem-&gt;arg == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> || IsA(elem-&gt;arg, String)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strcmp(elem-&gt;defname, <span class="hljs-string"><span class="hljs-string">"include_transaction"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* if option does not provide a value, it means its value is true */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elem-&gt;arg == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) data-&gt;include_transaction = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parse_bool(strVal(elem-&gt;arg), &amp;data-&gt;include_transaction)) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(<span class="hljs-string"><span class="hljs-string">"could not parse value \"%s\" for parameter \"%s\""</span></span>, strVal(elem-&gt;arg), elem-&gt;defname))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strcmp(elem-&gt;defname, <span class="hljs-string"><span class="hljs-string">"sort_keys"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* if option does not provide a value, it means its value is true */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elem-&gt;arg == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) data-&gt;sort_keys = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!parse_bool(strVal(elem-&gt;arg), &amp;data-&gt;sort_keys)) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(<span class="hljs-string"><span class="hljs-string">"could not parse value \"%s\" for parameter \"%s\""</span></span>, strVal(elem-&gt;arg), elem-&gt;defname))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(<span class="hljs-string"><span class="hljs-string">"option \"%s\" = \"%s\" is unknown"</span></span>, elem-&gt;defname, elem-&gt;arg ? strVal(elem-&gt;arg) : <span class="hljs-string"><span class="hljs-string">"(null)"</span></span>))); } } }</code> </pre> </div></div><br>  Here the parameters passed to the plugin are parsed and saved to the structure.  The created memory context is used later in <code>decoder_json_change</code> to properly clean the resources used.  Important points: <br><br><ul><li>  your data is stored in ctx-&gt; output_plugin_private </li><li>  <code>opt-&gt;output_type = OUTPUT_PLUGIN_TEXTUAL_OUTPUT</code> - this is how the output of the plugin is set to text </li></ul><br>  <code>decoder_json_shutdown</code> is called at the end of decoding, and is used to clean up resources. <br><br><div class="spoiler">  <b class="spoiler_title">Decoder_json_shutdown function</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/* cleanup this plugin's resources */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decoder_json_shutdown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LogicalDecodingContext *ctx</span></span></span><span class="hljs-function">)</span></span> { DecoderRawData *data = ctx-&gt;output_plugin_private; <span class="hljs-comment"><span class="hljs-comment">/* cleanup our own resources via memory context reset */</span></span> MemoryContextDelete(data-&gt;context); }</code> </pre><br></div></div><br>  Next is the most interesting.  It is necessary to define the <code>decoder_json_begin_txn</code> , <code>decoder_json_commit_txn</code> and <code>decoder_json_change</code> which actually generate the lines received by the <code>pg_logical_slot_peek_changes</code> and <code>pg_logical_slot_get_changes</code> .  The generated string must be added to the slot, this is done with the commands: <br><br><pre> <code class="hljs objectivec">OutputPluginPrepareWrite(ctx, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); appendStringInfoString(ctx-&gt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>, <span class="hljs-string"><span class="hljs-string">"some string"</span></span>); OutputPluginWrite(ctx, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  The <code>decoder_json_begin_txn</code> and <code>decoder_json_commit_txn</code> write (or just skip, if there is such a condition) the commands of the beginning and end of the transaction in the slot - the lines 'begin' and 'commit', respectively. <br><br>  The <code>decoder_json_change</code> function <code>decoder_json_change</code> called on a data change event.  This function determines which event occurred (INSERT, UPDATE, DELETE) and creates its own structure for each of them.  For UPDATE and DELETE, it is important to have a unique (not null) or primary key in the table, otherwise it is simply impossible to determine the row to be changed (deleted).  This depends on the value of the REPLICA IDENTITY parameter for the table. <br><br>  This function takes 4 parameters: <br><br><ul><li>  LogicalDecodingContext * ctx - context </li><li>  ReorderBufferTXN * txn </li><li>  Relation relation - information about the table being changed </li><li>  ReorderBufferChange * change - data details </li></ul><br>  Briefly about the function, we can say that the type of operation is defined through <code>change-&gt;action</code> .  Then, according to the data in <code>change</code> ( <code>change-&gt;data.tp.newtuple</code> and <code>change-&gt;data.tp.oldtuple</code> ), a JSON structure is created.  JSON is generated using the libjansson library. <br><br>  This is where the difficulties begin.  If REPLICA IDENTITY for a table is set to NOTHING or DEFAULT with a missing primary key, it is impossible to determine the rows to be changed and only the addition records will be included in the log.  When updating or deleting data from a table with DEFAULT, FULL, INDEX and if there is a unique key, its value is taken from the newtuple or from the oldtuple (if the key value is changed by the query).  If there is no unique key and if FULL, then all values ‚Äã‚Äãfrom oldtuple are used for identification. <br><br>  As a result, a JSON structure is constructed, of the form <code>{"a": 0, "r": "public.some_table", "c": {"id": 1}, "d": {"a": 2}}</code> , where a is the type of action, r is the name of the table, c is the value to identify the row, d is the data itself. <br><br>  Check the work.  Building the plugin and running the tests: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/ildus/decoder_json.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> decoder_json <span class="hljs-comment"><span class="hljs-comment">#         -         sudo chmod a+rw `pg_config --pkglibdir` chmod a+rwx ./ #    libjansson,   JSON make deps #    postgres sudo su postgres make make test</span></span></code> </pre><br>  Testing the plugin manually: <br><br><pre> <code class="hljs pgsql">#    postgres,          sudo su postgres <span class="hljs-keyword"><span class="hljs-keyword">createdb</span></span> test_db psql test_db # psql  test_db=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> test1 (id <span class="hljs-type"><span class="hljs-type">serial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">varchar</span></span>); test_db=# <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_create_logical_replication_slot(<span class="hljs-string"><span class="hljs-string">'custom_slot'</span></span>, <span class="hljs-string"><span class="hljs-string">'decoder_json'</span></span>); slot_name | xlog_position <span class="hljs-comment"><span class="hljs-comment">-------------+--------------- custom_slot | 0/4D9F870 (1 row)</span></span></code> </pre><br>  Here we specify the name of the slot and the plug-in.  In response, we see the name of the slot, and the place (xlog position) from which the data is actually written to the slot.  The fact that we have specified our plugin does not mean that it is already working, the decoding itself begins only when we take the data.  To do this, use the <code>pg_logical_slot_peek_changes</code> and <code>pg_logical_slot_get_changes</code> .  They differ in that the get function cleans the queue after receiving the data. <br><br>  Adding data: <br><br><pre> <code class="hljs pgsql">test_db=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> test1 <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'bb'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> test_db=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> test1 <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'bb'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> test_db=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_logical_slot_get_changes(<span class="hljs-string"><span class="hljs-string">'custom_slot'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'include_transaction'</span></span>, <span class="hljs-string"><span class="hljs-string">'on'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">location</span></span> | xid | data <span class="hljs-comment"><span class="hljs-comment">-----------+-------+----------------------------------------------------- 0/BAB0968 | 48328 | begin 0/BAB0968 | 48328 | {"a":0,"r":"public.test1","d":{"id":1,"name":"bb"}} 0/BAB09F0 | 48328 | commit 0/BAB09F0 | 48329 | begin 0/BAB09F0 | 48329 | {"a":0,"r":"public.test1","d":{"id":2,"name":"bb"}} 0/BAB0A78 | 48329 | commit (6 rows)</span></span></code> </pre> <br>  Data change <br><br><pre> <code class="hljs pgsql">test_db=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> test1 <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'dd'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id=<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> test_db=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_logical_slot_get_changes(<span class="hljs-string"><span class="hljs-string">'custom_slot'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'include_transaction'</span></span>, <span class="hljs-string"><span class="hljs-string">'on'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">location</span></span> | xid | data <span class="hljs-comment"><span class="hljs-comment">-----------+-------+------------------------------------------------------------------ 0/BB4C700 | 48338 | begin 0/BB4C700 | 48338 | {"c":{"id":2},"a":1,"r":"public.test1","d":{"id":2,"name":"dd"}} 0/BB4C798 | 48338 | commit (3 rows)</span></span></code> </pre> <br>  Deletion of data: <br><br><pre> <code class="hljs pgsql">test_db=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test1 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id=<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> test_db=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_logical_slot_get_changes(<span class="hljs-string"><span class="hljs-string">'custom_slot'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'include_transaction'</span></span>, <span class="hljs-string"><span class="hljs-string">'on'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">location</span></span> | xid | data <span class="hljs-comment"><span class="hljs-comment">-----------+-------+----------------------------------------- 0/BB4C8A8 | 48339 | begin 0/BB4C8A8 | 48339 | {"c":{"id":2},"a":2,"r":"public.test1"} 0/BB4C9C8 | 48339 | commit (3 rows)</span></span></code> </pre><br>  Used and useful resources: <br><br><ul><li>  PostgreSQL documentation - <a href="http://www.postgresql.org/docs/9.4/static/logicaldecoding.html">www.postgresql.org/docs/9.4/static/logicaldecoding.html</a> </li><li>  PostgreSQL plugin example (https://github.com/postgres/postgres/tree/master/contrib/test_decoding) </li><li>  <a href="http://michael.otacoo.com/">michael.otacoo.com</a> is a very useful blog; the decoder_raw plugin of this blog was used as the basis for my plugin. </li><li>  <a href="https://github.com/xstevens/decoderbufs">github.com/xstevens/decoderbufs</a> - a plugin that uses google protocol buffers as the output format. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/254263/">https://habr.com/ru/post/254263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254251/index.html">Reverse engineering of USB device drivers on the example of a radio-controlled car</a></li>
<li><a href="../254255/index.html">Authorization through Chinese social networks</a></li>
<li><a href="../254257/index.html">We make payments iOS AppStore with checking on the server</a></li>
<li><a href="../254259/index.html">Remote control of the Lego Mindstorms robot via JMX and IP Video</a></li>
<li><a href="../254261/index.html">Trinity computer in browser</a></li>
<li><a href="../254267/index.html">Evolution of web injects, part 1</a></li>
<li><a href="../254273/index.html">Optimization of ISPmanager for projects on Bitrix or how I crossed ISPmanager and VMBitrix (Bitrix environment)</a></li>
<li><a href="../254275/index.html">The ratio of abstraction and complexity in modeling</a></li>
<li><a href="../254277/index.html">The results of a survey of the popularity of PHP frameworks from Sitepoint</a></li>
<li><a href="../254279/index.html">MVC on the server does not happen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>