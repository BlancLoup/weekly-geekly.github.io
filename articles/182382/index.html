<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Boid's, Birds and Unity3D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Second part: We optimize Boid's on Unity 

 Have you ever thought about why birds flying in large flocks never collide and collapse into a huge feathe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Boid's, Birds and Unity3D</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/f8c/268/1a1/f8c2681a18cf9cd6e5265f4fa2aca240.gif"><br><br>  <i>Second part: We <a href="http://habrahabr.ru/post/182690/">optimize Boid's on Unity</a></i> <br><br>  Have you ever thought about why birds flying in large flocks never collide and collapse into a huge feather ball?  Hmm, if you think about it, that would be awesome.  In any case, one day in 1986, a man named <a href="http://www.red3d.com/cwr/index.html">Craig Reynolds</a> was found who decided to create a <a href="http://www.red3d.com/cwr/boids/">simple model of bird behavior in flocks and called it Boids</a> .  In the model, each boat has three basic rules: Separation, Alignment and Cohesion.  The first is to avoid collisions with neighbors, the second makes you fly about in the same direction as the neighbors, and the third says not to fly alone and keep the group.  These simple rules allow you to create believable flocks of birds, fish and other living creatures, which is used in the film and gaming industry. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the article I will tell you how to implement this model in practice.  For development, I use <a href="http://unity3d.com/">Unity</a> and C #, but most things are true for other engines and languages.  In this tutorial, I do not chew the basics of working with Unity, it is assumed that you know the effect of the Ctrl + Shift + N combination on the stage, know how to work with the inspector, duplicate and move objects.  If not, I advise you to start <a href="http://habrahabr.ru/post/167509/">with this article</a> .  Or you can just look at the pictures. <br><a name="habracut"></a><br><h4>  Basic preparations </h4><br><img src="https://habrastorage.org/storage2/61c/d1c/856/61cd1c856d04f7add4d49b99f570cf04.jpg"><br><br>  Let's create a new project in Unity and immediately build several daddies for the future: Materials, Prefabs, Scenes, Scripts. <br>  We throw on the stage Directional Light and one sphere called Boid.  We turn the sphere into a prefab.  At the same time we will immediately save the scene, so that later not to think about it.  Now we will start scripting. <br><br>  For the model, we need to calculate three parameters: Separation, Alignment and Cohesion.  Let's start with the last, it's the easiest.  Let me remind you, this is a vector directed towards the center of the neighboring boids.  To find it, you need to add the coordinates of the boids and divide the amount by their number.  How does a Boid find out that he has neighbors?  For this useful <a href="http://docs.unity3d.com/Documentation/ScriptReference/Physics.OverlapSphere.html">Physics.OverlapSphere</a> .  This function will return to us all colliders in a given cohesionRadius, including our Boid, if it falls into the sphere. <br><pre><code class="cs hljs">boids = Physics.OverlapSphere(transform.position, cohesionRadius);</code> </pre> <br>  We zero out the variable, add, divide, and then draw a decorated line from the transformer to the center using the super- <a href="http://docs.unity3d.com/Documentation/ScriptReference/Debug.DrawLine.html">useful Debug.DrawLine</a> and <a href="http://docs.unity3d.com/Documentation/ScriptReference/Color-magenta.html">Color.magenta</a> .  <a href="http://docs.unity3d.com/Documentation/ScriptReference/Debug.DrawLine.html">Debug.DrawLine</a> on the input accepts the coordinates of the beginning and end of the line, as well as an optional parameter for the color of the line.  The results of the performance of all debugging functions are visible only during development, they just do not fall into the build. <br><pre> <code class="cs hljs">Debug.DrawLine(transform.position, cohesion, Color.magenta);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Boid.cs center</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Boid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 cohesion; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collider[] boids; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cohesion = Vector3.zero; boids = Physics.OverlapSphere(transform.position, cohesionRadius); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> boids) { cohesion += boid.transform.position; } cohesion = cohesion / boids.Length; Debug.DrawLine(transform.position, cohesion, Color.magenta); } }</code> </pre></div></div><br>  We throw the script on the prefab, copy the boyd a couple of times and click Play.  Don't forget to turn on the Gizmos display otherwise you won't see the line. <br><br><img src="https://habrastorage.org/storage2/a18/493/2e7/a184932e7ed1cff2caa0d930daf4cee3.jpg"><br><br><h4>  We collect boida in a bunch </h4><br>  So it seems to work.  Now we need to turn the resulting point into motion.  It‚Äôs not good to keep everything in one heap, so we‚Äôll move the previous code into a separate function.  The function will be run on a timer using <a href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.InvokeRepeating.html">InvokeRepeating</a> .  The first argument is the name of the function, the second is the start time, the third is the repetition interval.  This feature is very useful for delaying the launch of various scripts. <br><pre> <code class="cs hljs">InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  To calculate the vector, we use school mathematics and subtract the coordinates of the boida from the coordinates of the center.  Add a public variable (I‚Äôll say why) later to the script, reset it at the beginning of the function, and add a new cohesion vector to it at the end.  In Update, we attach the result to the coordinates of the transform, taking into account the past time.  <a href="http://docs.unity3d.com/Documentation/ScriptReference/Time-deltaTime.html">Time.deltaTime is</a> needed to ensure that the movement does not depend on the FPS and goes with the same speed on all processors. <br><pre> <code class="cs hljs">transform.position += velocity * Time.deltaTime;</code> </pre><br>  In addition, since our center has become a vector, then we will change our <a href="http://docs.unity3d.com/Documentation/ScriptReference/Debug.DrawLine.html">Debug.DrawLine</a> to another equally fantastic <a href="http://docs.unity3d.com/Documentation/ScriptReference/Debug.DrawRay.html">Debug.DrawRay</a> .  No difference, just the second argument should be in relative coordinates, just like ours. <br><br><div class="spoiler">  <b class="spoiler_title">Boid.cs cohesion</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Boid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 velocity; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collider[] boids; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 cohesion; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateVelocity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { velocity = Vector3.zero; cohesion = Vector3.zero; boids = Physics.OverlapSphere(transform.position, cohesionRadius); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> boids) { cohesion += boid.transform.position; } cohesion = cohesion / boids.Length; cohesion = cohesion - transform.position; velocity += cohesion; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.position += velocity * Time.deltaTime; Debug.DrawRay(transform.position, cohesion, Color.magenta); } }</code> </pre></div></div><br><img src="https://habrastorage.org/storage2/fcb/6da/1d9/fcb6da1d971dc3ac77ae39dce057cc42.gif"><br><br><h4>  We divide the boids </h4><br>  The separation calculation is a bit more complicated.  It is necessary to calculate the most useful direction of exit from the pile of neighbors.  To do this, we can find the weighted sum of the vectors from each neighbor.  We divide a vector from a neighbor by the distance to it, which is obtained using <a href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3-magnitude.html">Vector3.magnitude</a> .  In the resulting amount, the nearest neighbors will have the greatest weight. <br><pre> <code class="cs hljs">separation += (transform.position - boid.transform.position) / (transform.position - boid.transform.position).magnitude;</code> </pre><br>  It makes sense to limit the number of considered neighbors to a certain distance, for this we add one variable for the counter and one for the separation radius. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((transform.position - boid.transform.position).magnitude &lt; separationDistance)</code> </pre><br>  In addition, we do not need to get a zero vector in the amount due to the collider of the Boida itself.  Do not forget that <a href="http://docs.unity3d.com/Documentation/ScriptReference/Physics.OverlapSphere.html">Physics.OverlapSphere</a> covers all colliders, including the Boid collider.  Therefore, we slightly change the condition. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boid != collider &amp;&amp; (transform.position - boid.transform.position).magnitude &lt; separationDistance)</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Boid.cs separation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Boid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 velocity; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationDistance = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collider[] boids; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 cohesion; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 separation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> separationCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateVelocity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { velocity = Vector3.zero; cohesion = Vector3.zero; separation = Vector3.zero; separationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; boids = Physics.OverlapSphere(transform.position, cohesionRadius); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> boids) { cohesion += boid.transform.position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boid != collider &amp;&amp; (transform.position - boid.transform.position).magnitude &lt; separationDistance) { separation += (transform.position - boid.transform.position) / (transform.position - boid.transform.position).magnitude; separationCount++; } } cohesion = cohesion / boids.Length; cohesion = cohesion - transform.position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (separationCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { separation = separation / separationCount; } velocity += cohesion + separation; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.position += velocity * Time.deltaTime; Debug.DrawRay(transform.position, separation, Color.green); Debug.DrawRay(transform.position, cohesion, Color.magenta); } }</code> </pre></div></div><br><img src="http://habrastorage.org/storage2/bf3/3f5/627/bf33f56276f0822bc65f79f2df7adfd0.gif"><br><br><h4>  We organize boids </h4><br>  In order for boids not just thoughtlessly to form even piles, we need them to repeat the behavior of their neighbors.  The alignment calculation is very simple, we summarize the public velocity variables (aha!) From each neighbor and divide by their number.  Attached scripts can be accessed using <a href="http://docs.unity3d.com/Documentation/ScriptReference/GameObject.GetComponent.html">GameObject.GetComponent</a> .  He can find not only scripts, but in general any components.  Wonderful stuff. <br><pre> <code class="cs hljs">alignment += boid.GetComponent&lt;Boid&gt;().velocity;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Boid.cs alignment</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Boid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 velocity; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationDistance = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collider[] boids; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 cohesion; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 separation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> separationCount; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 alignment; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateVelocity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { velocity = Vector3.zero; cohesion = Vector3.zero; separation = Vector3.zero; separationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; alignment = Vector3.zero; boids = Physics.OverlapSphere(transform.position, cohesionRadius); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> boids) { cohesion += boid.transform.position; alignment += boid.GetComponent&lt;Boid&gt;().velocity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boid != collider &amp;&amp; (transform.position - boid.transform.position).magnitude &lt; separationDistance) { separation += (transform.position - boid.transform.position) / (transform.position - boid.transform.position).magnitude; separationCount++; } } cohesion = cohesion / boids.Length; cohesion = cohesion - transform.position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (separationCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { separation = separation / separationCount; } alignment = alignment / boids.Length; velocity += cohesion + separation + alignment; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.position += velocity * Time.deltaTime; Debug.DrawRay(transform.position, separation, Color.green); Debug.DrawRay(transform.position, cohesion, Color.magenta); Debug.DrawRay(transform.position, alignment, Color.blue); } }</code> </pre></div></div><br>  We start and ... zero reaction, everything is the same.  Add a two to the velocity calculation formula. <br><pre> <code class="cs hljs">velocity += cohesion + separation + alignment*<span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  And then‚Ä¶ <br><br> <a href="http://fotki.yandex.ru/users/mihtimak/view/648284/%3Fpage%3D1"><img src="http://habrastorage.org/storage2/b35/acd/555/b35acd555e4dcc2f413d634da75e9268.gif"></a> <br><br><h4>  We cut vectors </h4><br>  Vsuuum!  Well, quite predictable.  We increased the alignment vector, which increased the velocity vector, which increased the alignment vector, which ... Well, you understand.  We need to make a maximum speed limit.  Moreover, the restriction should be put on all components of the vector, otherwise in some situations the behavior of the boat becomes somewhat strange.  You can try it yourself. <br><br>  For clipping vectors in Unity, there is a <a href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.ClampMagnitude.html">Vector3.ClampMagnitude</a> function.  After adding each vector, we simply add the following construction: <br><pre> <code class="cs hljs">velocity = Vector3.ClampMagnitude(velocity, maxSpeed);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Boid.cs clamp</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Boid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 velocity; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationDistance = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collider[] boids; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 cohesion; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 separation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> separationCount; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 alignment; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxSpeed = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateVelocity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { velocity = Vector3.zero; cohesion = Vector3.zero; separation = Vector3.zero; separationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; alignment = Vector3.zero; boids = Physics.OverlapSphere(transform.position, cohesionRadius); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> boids) { cohesion += boid.transform.position; alignment += boid.GetComponent&lt;Boid&gt;().velocity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boid != collider &amp;&amp; (transform.position - boid.transform.position).magnitude &lt; separationDistance) { separation += (transform.position - boid.transform.position) / (transform.position - boid.transform.position).magnitude; separationCount++; } } cohesion = cohesion / boids.Length; cohesion = cohesion - transform.position; cohesion = Vector3.ClampMagnitude(cohesion, maxSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (separationCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { separation = separation / separationCount; separation = Vector3.ClampMagnitude(separation, maxSpeed); } alignment = alignment / boids.Length; alignment = Vector3.ClampMagnitude(alignment, maxSpeed); velocity += cohesion + separation * <span class="hljs-number"><span class="hljs-number">10</span></span> + alignment * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>; velocity = Vector3.ClampMagnitude(velocity, maxSpeed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.position.magnitude &gt; <span class="hljs-number"><span class="hljs-number">25</span></span>) { velocity += -transform.position.normalized; } transform.position += velocity * Time.deltaTime; Debug.DrawRay(transform.position, separation, Color.green); Debug.DrawRay(transform.position, cohesion, Color.magenta); Debug.DrawRay(transform.position, alignment, Color.blue); } }</code> </pre></div></div><br>  We check the work of pacified vectors. <br><br><img src="http://habrastorage.org/storage2/eb4/0c3/269/eb40c32691c2293d2d932ddafe17916c.gif"><br><br><h4>  Automating </h4><br>  It is not at all interesting to arrange boids by hand.  For software placement there is an <a href="http://docs.unity3d.com/Documentation/ScriptReference/Object.Instantiate.html">Instantiate</a> function.  At the entrance she needs to submit a link to the object to copy, the new coordinates of the object and its rotation.  For the copied prefab, we make a separate public variable, which we will fill in the inspector.  It is convenient to take random coordinates from <a href="http://docs.unity3d.com/Documentation/ScriptReference/Random-insideUnitSphere.html">Random.insideUnitSphere</a> , simply multiply it by the radius of the required sphere.  You can rotate our boids as much as you want, the result will be the same, so we use <a href="http://docs.unity3d.com/Documentation/ScriptReference/Quaternion-identity.html">Quaternion.identity</a> , which means no rotation. <br><pre> <code class="cs hljs">Instantiate(boidPrefab, Random.insideUnitSphere * <span class="hljs-number"><span class="hljs-number">25</span></span>, Quaternion.identity);</code> </pre><br>  In the cycle, repeat the action above and get any desired number of boids.  We throw a new script on an empty object in the center of the scene and fill in the link to the prefab. <br><br><div class="spoiler">  <b class="spoiler_title">HeartOfTheSwarm.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HeartOfTheSwarm</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform boidPrefab; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> swarmCount = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; swarmCount; i++) { Instantiate(boidPrefab, Random.insideUnitSphere * <span class="hljs-number"><span class="hljs-number">25</span></span>, Quaternion.identity); } } }</code> </pre></div></div><br>  It is not very convenient to observe a rapidly moving flight of boids, it would be good to put them on a chain.  To do this, add a small condition to Update: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.position.magnitude &gt; <span class="hljs-number"><span class="hljs-number">25</span></span>) { velocity += -transform.position.normalized; }</code> </pre><br>  With it, boids, whose coordinates are located outside the virtual sphere, will turn towards the center.  Finally, let's play a bit with vector multipliers and other parameters, otherwise the desired effect will not work.  See the final code under the spoiler below. <br><pre> <code class="cs hljs">velocity += cohesion + separation * <span class="hljs-number"><span class="hljs-number">10</span></span> + alignment * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre><br>  Run, admire. <br><br><div class="spoiler">  <b class="spoiler_title">Boid.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Boid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 velocity; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationDistance = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collider[] boids; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 cohesion; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 separation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> separationCount; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 alignment; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxSpeed = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateVelocity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { velocity = Vector3.zero; cohesion = Vector3.zero; separation = Vector3.zero; separationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; alignment = Vector3.zero; boids = Physics.OverlapSphere(transform.position, cohesionRadius); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> boids) { cohesion += boid.transform.position; alignment += boid.GetComponent&lt;Boid&gt;().velocity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boid != collider &amp;&amp; (transform.position - boid.transform.position).magnitude &lt; separationDistance) { separation += (transform.position - boid.transform.position) / (transform.position - boid.transform.position).magnitude; separationCount++; } } cohesion = cohesion / boids.Length; cohesion = cohesion - transform.position; cohesion = Vector3.ClampMagnitude(cohesion, maxSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (separationCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { separation = separation / separationCount; separation = Vector3.ClampMagnitude(separation, maxSpeed); } alignment = alignment / boids.Length; alignment = Vector3.ClampMagnitude(alignment, maxSpeed); velocity += cohesion + separation * <span class="hljs-number"><span class="hljs-number">10</span></span> + alignment * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>; velocity = Vector3.ClampMagnitude(velocity, maxSpeed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.position.magnitude &gt; <span class="hljs-number"><span class="hljs-number">25</span></span>) { velocity += -transform.position.normalized; } transform.position += velocity * Time.deltaTime; Debug.DrawRay(transform.position, separation, Color.green); Debug.DrawRay(transform.position, cohesion, Color.magenta); Debug.DrawRay(transform.position, alignment, Color.blue); } }</code> </pre></div></div><br><img src="http://habrastorage.org/storage2/07d/2a0/3af/07d2a03af6a23ca359741583ef58b013.gif"><br><br>  That's all, boids fly in their cage.  However, there are so few of them!  With the amount of more than a hundred, everything starts to slow down significantly.  No wonder, because we have not done a single optimization.  In the next part, I will discuss how to optimize our code so that it can hold 60 FPS on a much larger number of boids.  In the meantime, you can offer your options in the comments. <br><br>  <i>Second part: We <a href="http://habrahabr.ru/post/182690/">optimize Boid's on Unity</a></i> <br><br>  <b>Note: The code for the links below is outdated; see the <a href="https://github.com/Syomus/ProceduralToolkit">Procedural Toolkit for the</a> latest version.</b> <br><br>  <a href="https://github.com/BasmanovDaniil/Boids">Sources on GitHub</a> |  <a href="http://basmanovdaniil.github.io/Boids/">Online version for owners of Unity Web Player</a> <br><br>  Mini bonus for those who are interested in how I did the animation. <br><div class="spoiler">  <b class="spoiler_title">Screenshot.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Screenshot</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetButtonDown(<span class="hljs-string"><span class="hljs-string">"Jump"</span></span>)) { InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"Capture"</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Capture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Application.CaptureScreenshot(Application.dataPath + <span class="hljs-string"><span class="hljs-string">"/Screenshot"</span></span> + count + <span class="hljs-string"><span class="hljs-string">".png"</span></span>); count++; } }</code> </pre></div></div></div><p>Source: <a href="https://habr.com/ru/post/182382/">https://habr.com/ru/post/182382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182366/index.html">Why it is not necessary to develop applications for VK.com</a></li>
<li><a href="../182368/index.html">DevCon 2013: how it was (+ a lot of photos)</a></li>
<li><a href="../182370/index.html">MASHA - the formation of the daily menu in preschool</a></li>
<li><a href="../182376/index.html">Google has added the relevant images to the Adwords ad on the search results page.</a></li>
<li><a href="../182380/index.html">Google's Android 4.2 keyboard is now available on the Play Store as a standalone application.</a></li>
<li><a href="../182384/index.html">Usability Testing. Perfect Moderator - Sophisticated Innocence</a></li>
<li><a href="../182386/index.html">MIT builds Silk Pavilion with a robot and 6,500 silkworm caterpillars</a></li>
<li><a href="../182388/index.html">Voting and likes</a></li>
<li><a href="../182390/index.html">WeCanTrust - draft RosKomNadzor to discuss the list of blocked sites</a></li>
<li><a href="../182392/index.html">Upper middle class - a review of Sony Xperia SP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>