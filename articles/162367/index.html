<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We get acquainted with Fabric.js. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I want to introduce you to Fabric.js - a powerful Javascript library for working with HTML5 <canvas> . Fabric includes an object model that is s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We get acquainted with Fabric.js. Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/3a6/aa2/ad53a6aa23a4e47b51cd61cfc14bafef.png"><br><br><a name="habracut"></a>  Today I want to introduce you to <a href="http://fabricjs.com/">Fabric.js</a> - a powerful Javascript library for working with <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html">HTML5 &lt;canvas&gt;</a> .  Fabric includes an object model that is so lacking when working with &lt;canvas&gt;, as well as an SVG parser, an interactive layer, and many other irreplaceable tools.  This is a fully open library with an MIT license and many developer contributions over the past few years. <br><br>  I started working on Fabric 3 years ago, when I realized how hard it was to work with the usual canvas API.  At that moment I created an interactive editor - my startup, where we give the opportunity to create a design and print it on clothes or other products.  Editor wanted to make it convenient and super interactive.  At that time, such functionality could be created only in Flash.  But I did not want to use Flash.  I prefer Javascript, and I was sure that with him you can achieve a lot.  It turned out pretty good.  Even now, very few visual editors can do what can be achieved with Fabric. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Why do you need it? </h2><br>  Recently, the popularity of <a href="http//www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html">Canvas is</a> growing and people are doing <a href="http://net.tutsplus.com/articles/web-roundups/21-ridiculously-impressive-html5-canvas-experiments/">quite</a> <a href="http://speckyboy.com/2011/12/07/20-amazing-implementations-of-html5-canvas/">amazing</a> <a href="http://artatm.com/2012/01/23-truly-amazing-and-unbelievable-html5-canvas-and-javascript-experiments/">things</a> on it.  The problem is that the native canvas API is <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html">terribly low-level</a> .  It's one thing to draw a few simple shapes or graphs, and forget about them.  The other is interactivity, changing the picture at some point, or drawing more complex shapes. <br><br>  That's exactly what Fabric.js is for. <br><br>  The fact is that conventional canvas methods allow us to call only very simple graphic commands, blindly changing the whole canvas bitmap.  Need to draw a rectangle?  Use <code>fillRect(left, top, width, height)</code> .  Draw a line?  Use the <code>moveTo(left, top)</code> and <code>lineTo(x, y)</code> combination.  It‚Äôs as if we paint with a <strong>brush on a canvas</strong> , putting more and more paint, almost without any control. <br><br>  Fabric gives us an object model on top of low canvas methods, stores the state of the canvas, and allows you to work with objects directly. <br><br>  Let's look at the difference between canvas and Fabric.  Suppose you need to draw a red rectangle.  Using the canvas API, it does something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  canvas  (id="c") var canvasEl = document.getElementById('c'); //  2d ,    ("bitmap"  ) var ctx = canvasEl.getContext('2d'); //  fill ()   ctx.fillStyle = 'red'; //     100,100   20x20 ctx.fillRect(100, 100, 20, 20);</span></span></code> </pre><br>  But the same with Fabric: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ""  canvas  (id="c") var canvas = new fabric.Canvas('c'); //   var rect = new fabric.Rect({ left: 100, top: 100, fill: 'red', width: 20, height: 20 }); //  ,    canvas.add(rect);</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/17a/fdb/51a/17afdb51a1daad5d32cd81f7b4a73486.png"><br><br>  The difference in the size of the code is not yet visible.  However, it can be seen that the way of working with canvas is completely different.  In the usual canvas API, we work with the context.  A context is an object that is essentially a canvas bitmap.  With Fabric, we manage exactly the objects - we create, change the parameters, add them to the canvas.  As you can see, these objects are full-fledged residents in Fabric (first-class objects). <br><br>  Drawing a red box is certainly not serious.  Let's at least do something interesting with him.  For example, rotate 45 degrees. <br><br>  First, using the usual methods: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvasEl = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ctx = canvasEl.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>); ctx.fillStyle = <span class="hljs-string"><span class="hljs-string">'red'</span></span>; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">ctx.translate(100, 100); ctx.rotate(Math.PI / 180 * 45); ctx.fillRect(-10, -10, 20, 20);</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  and now using Fabric: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Canvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      45  var rect = new fabric.Rect({ left: 100, top: 100, fill: 'red', width: 20, height: 20, &lt;b&gt;angle: 45&lt;/b&gt; }); canvas.add(rect);</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/226/ee8/7ea/226ee87ead22e39f8f87b64bf0430d0a.png"><br><br>  What's going on here? <br><br>  Using Fabric, all you had to do was change the angle value to <code>45</code> .  But with the usual methods, it's not so simple.  First, we cannot manage objects directly.  Instead, you have to change the position and angle of the bitmap itself ( <code>ctx.translate</code> , <code>ctx.rotate</code> ).  Then we draw a rectangle, while not forgetting to move the bitmap accordingly (-10, -10), so that the rectangle appears at 100,100.  You also need to remember to convert the angle from degrees to radians when you turn the bitmap. <br><br>  Now you probably understand why Fabric exists. <br><br>  Let's look at another example - storing the state of the canvas. <br><br>  Imagine that at some point we need to move this red rectangle to another place.  How to do this without having the ability to manage objects?  Call <code>fillRect</code> again? <br><br>  Not really.  Calling another <code>fillRect</code> command, the rectangle is drawn directly on top of the entire bitmap.  That is why I brought an analog brush with paint.  To move the figure, we need to first erase the previous result, and then draw in a new place. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvasEl = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); ... ctx.strokRect(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); ... <span class="hljs-comment"><span class="hljs-comment">//   canvas &lt;b&gt;ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); ctx.fillRect(20, 50, 20, 20);&lt;/b&gt;</span></span></code> </pre><br>  And now with Fabric <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Canvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); ... canvas.add(rect); ... &lt;b&gt;rect.set({ <span class="hljs-attr"><span class="hljs-attr">left</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">top</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span> }); canvas.renderAll();<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/ca7/cb1/3ac/ca7cb13ac3472a7f8e4dc4f3763ae010.png"><br><br>  Notice the very important difference.  We didn't have to wash anything before drawing.  Just continue to work with objects, changing their attributes, and then redraw the canvas to see the changes.  Thus you can change dozens of objects, and at the end of a single command to update the screen. <br><br><h2>  Objects </h2>  We have already seen how to work with rectangles using the <code>fabric.Rect</code> constructor.  But, of course, Fabric provides many other simple shapes: circles, triangles, ellipses, etc.  All of them are accessible from <code>fabric</code> objects, respectively, <code>fabric.Circle</code> , <code>fabric.Triangle</code> , <code>fabric.Ellipse</code> , etc. <br><br>  7 basic shapes available in Fabric: <br><br><ul><li>  <a href="http://fabricjs.com/docs/symbols/fabric.Circle.html">fabric.Circle</a> </li><li>  <a href="http://fabricjs.com/docs/symbols/fabric.Ellipse.html">fabric.Ellipse</a> </li><li>  <a href="http://fabricjs.com/docs/symbols/fabric.Line.html">fabric.Line</a> </li><li>  <a href="http://fabricjs.com/docs/symbols/fabric.Polygon.html">fabric.Polygon</a> </li><li>  <a href="http://fabricjs.com/docs/symbols/fabric.Polyline.html">fabric.Polyline</a> </li><li>  <a href="http://fabricjs.com/docs/symbols/fabric.Rect.html">fabric.Rect</a> </li><li>  <a href="http://fabricjs.com/docs/symbols/fabric.Triangle.html">fabric.Triangle</a> </li></ul><br>  Need to draw a circle?  Simply create the appropriate object and add it to the canvas.  Same with other forms: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Circle({ <span class="hljs-attr"><span class="hljs-attr">radius</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: <span class="hljs-string"><span class="hljs-string">'green'</span></span>, <span class="hljs-attr"><span class="hljs-attr">left</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">top</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Triangle({ <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>, <span class="hljs-attr"><span class="hljs-attr">left</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">top</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span> }); canvas.add(circle, triangle);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a8b/838/bda/a8b838bda830f8bd2aa56034910c17da.png"><br><br>  ... and now on the canvas there is a green circle at point 100, 100 and a blue triangle at point 50, 50. <br><br><h4>  Manage objects </h4><br>  Creating visual shapes is just flowers.  At some point you will probably need to change them.  Perhaps some user actions should affect the state of the picture (canvas), or the animation should be running.  Or you need to change the attributes of objects (color, transparency, size, position) depending on the mouse movements. <br><br>  Fabric takes care of the state of the canvas and redrawing.  We are only required to change the objects themselves. <br><br>  In the previous example, it was seen how the <code>set</code> method moved the object to a new position <code>set({ left: 20, top: 50 })</code> .  Similarly, you can change any other attributes that are available several. <br><br>  First, there are attributes that change position - <strong>left</strong> , <strong>top</strong> ;  size - <strong>width</strong> , <strong>height</strong> ;  rendering itself (object mapping) - <strong>fill</strong> , <strong>opacity</strong> , <strong>stroke</strong> , <strong>strokeWidth</strong> ;  scale and rotation - <strong>scaleX</strong> , <strong>scaleY</strong> , <strong>angle</strong> ;  and even a coup (180 degrees) - <strong>flipX</strong> , <strong>flipY</strong> . <br><br>  Yes, it is surprisingly easy to display a mirror-rotated image in Fabric - just assign <code>true</code> to the flip * attribute. <br><br>  Attributes are read using the <code>get</code> method, assignment is done using <code>set</code> .  Let's change our rectangle somehow. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Canvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); ... canvas.add(rect); rect.set(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, <span class="hljs-string"><span class="hljs-string">'red'</span></span>); rect.set({ <span class="hljs-attr"><span class="hljs-attr">strokeWidth</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">stroke</span></span>: <span class="hljs-string"><span class="hljs-string">'rgba(100,200,200,0.5)'</span></span> }); rect.set(<span class="hljs-string"><span class="hljs-string">'angle'</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>).set(<span class="hljs-string"><span class="hljs-string">'flipY'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/53c/142/b19/53c142b19bc1cdd220739ddd35a458c0.png"><br><br>  We set ‚Äúfill‚Äù to ‚Äúred‚Äù, changing the color of the object to red.  Then ‚ÄústrokeWidth‚Äù and ‚Äústroke‚Äù were changed, which adds to the rectangle a 5-pixel frame in light green.  Finally, we change the ‚Äúangle‚Äù and ‚ÄúflipY‚Äù attributes.  Notice how the three expressions use slightly different syntax. <br><br>  This shows that <code>set()</code> is a fairly universal method.  It is intended for frequent use, so it is sharpened for convenience. <br><br>  Well, what about reading?  I already mentioned that there is a generic <code>get()</code> , as well as a set of specific <code>get*()</code> methods.  For example, to get the ‚Äúwidth‚Äù of an object, you can use <code>get('width')</code> or <code>getWidth()</code> .  For scaleX, <code>get('scaleX')</code> or <code>getScaleX()</code> , etc.  Special methods such as <code>getWidth()</code> and <code>getScaleX()</code> exist for all the ‚Äúpublic‚Äù attributes of the object (‚Äústroke‚Äù, ‚ÄústrokeWidth‚Äù, ‚Äúangle‚Äù, etc.) <br><br>  You probably noticed that in the previous examples we used configuration hashes, which looked exactly the same as those we just used in the <code>set</code> method.  This is because they are really the same.  An object can be ‚Äúconfigured‚Äù at the time of creation, or later, using the <code>set</code> method.  The syntax is absolutely the same: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Rect({ <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: <span class="hljs-string"><span class="hljs-string">'#f55'</span></span>, <span class="hljs-attr"><span class="hljs-attr">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0.7</span></span> }); <span class="hljs-comment"><span class="hljs-comment">//   var rect = new fabric.Rect(); rect.set({ width: 10, height: 20, fill: '#f55', opacity: 0.7 });</span></span></code> </pre><br><h4>  Default Attributes </h4><br>  All objects in Fabric have a set of default values.  They are used when we do not specify other values ‚Äã‚Äãduring creation.  I give an example. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Rect(); <span class="hljs-comment"><span class="hljs-comment">//     rect.getWidth(); // 0 rect.getHeight(); // 0 rect.getLeft(); // 0 rect.getTop(); // 0 rect.getFill(); // rgb(0,0,0) rect.getStroke(); // null rect.getOpacity(); // 1</span></span></code> </pre><br>  Rectangle received default values.  It is located at position 0.0, black, opaque, and has neither frames nor dimensions (width and height are equal to zero).  Because of this, we do not see it.  As soon as we set the positive width / height, a black rectangle appears in the upper left corner. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ada/1df/b0b/ada1dfb0bf33a3eef199a1c26afae73b.png"><br><br><h4>  Hierarchy and Inheritance </h4><br>  Fabric objects do not exist by themselves.  They form a clear hierarchy. <br><br>  Most objects inherit from <code>fabric.Object</code> .  <code>fabric.Object</code> is an abstract 2-dimensional figure on a plane.  It has left / top and width / height attributes, as well as a set of other visual parameters.  The attributes we saw earlier (fill, stroke, angle, opacity, flip *, etc.) belong to all Fabric objects that inherit from <code>fabric.Object</code> . <br><br>  Such inheritance is very convenient.  It allows us to define methods on <code>fabric.Object</code> , thus making it available in all ‚Äúclasses‚Äù of descendants.  For example, if you need a <code>getAngleInRadians</code> method on all objects, simply create it on <code>fabric.Object.prototype</code> : <br><br><pre> <code class="javascript hljs">fabric.Object.prototype.getAngleInRadians = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAngle() / <span class="hljs-number"><span class="hljs-number">180</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Rect({ <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: <span class="hljs-number"><span class="hljs-number">45</span></span> }); rect.getAngleInRadians(); <span class="hljs-comment"><span class="hljs-comment">// 0.785... var circle = new fabric.Circle({ angle: 30, radius: 10 }); circle.getAngleInRadians(); // 0.523... circle instanceof fabric.Circle; // true circle instanceof fabric.Object; // true</span></span></code> </pre><br>  As you can see, the method is now available to all objects. <br><br>  Of course, descendant classes can not only inherit from <code>fabric.Object</code> , but also define their own methods and parameters.  For example, in <code>fabric.Circle</code> there is an additional attribute ‚Äúradius‚Äù.  Or take for example <code>fabric.Image</code> , with which we will learn more later.  It contains <code>getElement</code> / <code>setElement</code> methods for reading / writing HTML &lt;img&gt; element, on which the object of the type <code>fabric.Image</code> . <br><br><h3>  Canvas </h3><br>  We looked at the objects in detail;  let's go back to canvas again. <br><br>  As you can see from the examples, the first is to create the canvas for drawing ‚Äî <code>new fabric.Canvas('...')</code> .  fabric.Canvas is, in fact, a wrapper around the &lt;canvas&gt; element, responsible for managing all the objects it contains.  The constructor takes the id of the element, and returns an object of type <code>fabric.Canvas</code> . <br><br>  Now you can add ( <code>add()</code> ) objects to it, as well as read them ( <code>item()</code> , <code>getObjects()</code> ), or <code>remove()</code> ( <code>remove()</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Canvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Rect(); canvas.add(rect); <span class="hljs-comment"><span class="hljs-comment">//  canvas.item(0); //  fabric.Rect,   ( ) canvas.getObjects(); //    (    ) canvas.remove(rect); //  </span></span></code> </pre><br>  As we already found out, the main task of <code>fabric.Canvas</code> is to manage the objects that are on it.  Also, it can be <strong>configured</strong> through a set of parameters.  Settings such as changing the background of the canvas, hiding objects by mask, changing the overall length / width, turning on / off interactivity - these and other options can be set directly to the <code>fabric.Canvas</code> both during creation and later: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Canvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">backgroundColor</span></span>: <span class="hljs-string"><span class="hljs-string">'rgb(100,100,200)'</span></span>, <span class="hljs-attr"><span class="hljs-attr">selectionColor</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>, <span class="hljs-attr"><span class="hljs-attr">selectionLineWidth</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }); //  var canvas = new fabric.Canvas('c'); canvas.backgroundImage = 'http://...'; canvas.onFpsUpdate = function(){ /* ... */ }; // ...</span></span></code> </pre><br><h4>  Interactivity </h4><br>  One of the most unique features of Fabric, built right into the kernel, is a layer of interactivity.  It allows the user to manipulate the object model with which we have just become familiar. <br><br>  An object model exists for software access.  And what is needed to control objects with a mouse (or touchpad, on mobile devices)?  For this, Fabric has user access functionality.  As soon as we create a canvas through <code>new fabric.Canvas('...')</code> , the objects located on it can immediately be selected, moved, scaled, rotated and even <strong>grouped together</strong> , controlling them as one! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42f/a5b/57e/42fa5b57e42a9d071a3f2305ea170f60.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/017/59c/5b8/01759c5b899401492ecf86d5c92ea9ae.png"><br><br>  If we want to enable the user to manage objects on the canvas - say, a picture - we just need to create the canvas and add an object to it.  No need for any additional settings. <br><br>  Managing this interactivity is easy.  For this, there is a ‚Äúselection‚Äù flag on the canvas, as well as a ‚Äúselectable‚Äù flag on individual objects. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Canvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); ... canvas.selection = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   rect.set('selectable', false); //   </span></span></code> </pre><br>  And what to do if interactivity is not needed at all?  Then just change the <code>fabric.Canvas</code> to <code>fabric.StaticCanvas</code> .  The syntax (configuration, methods) is absolutely identical, just use the word <code>StaticCanvas</code> instead of <code>Canvas</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticCanvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.StaticCanvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); staticCanvas.add( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Rect({ <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">left</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">top</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: <span class="hljs-string"><span class="hljs-string">'yellow'</span></span>, <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> }));</code> </pre><br>  This creates a lightweight version of the canvas, without too much logic for interactivity and event management.  Everything else is the same.  We get the full object model, we can add, delete and change objects, and, of course, change the options of the canvas itself.  Only external event management disappears. <br><br>  In the future, when we get acquainted with the possibility of custom build Fabric (custom build), you will see that you can create an easier version of the library for your needs.  This can be useful if, for example, you just need to display a static graph, SVG figure, or images with filters. <br><br><h3>  Pictures </h3><br>  By the way, about the pictures ... <br><br>  Still, the work with simple figures is not as interesting as with more graphically rich pictures.  As you probably already guess, in Fabric it is very simple.  Create a <code>fabric.Image</code> object, add it to the canvas: <br><br>  (html) <br><pre> <code class="javascript hljs">&lt;canvas id=<span class="hljs-string"><span class="hljs-string">"c"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;img src=<span class="hljs-string"><span class="hljs-string">"my_image.png"</span></span> id=<span class="hljs-string"><span class="hljs-string">"my-image"</span></span>&gt;</code> </pre><br>  (js) <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Canvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'my-img'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgInstance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Image(imgElement, { <span class="hljs-attr"><span class="hljs-attr">left</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">top</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-attr"><span class="hljs-attr">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0.85</span></span> }); canvas.add(imgInstance);</code> </pre><br>  Notice how we pass the &lt;image&gt; element to the <code>fabric.Image</code> constructor.  Thus, we create an object of the type <code>fabric.Image</code> , which is a picture of this element.  We also set the left / top values ‚Äã‚Äãto 100/100, the angle to 30, and the transparency to 0.85.  Once added to the canvas, the picture is rendered at position 100,100, rotated 30 degrees, and slightly transparent!  Not bad... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/342/303/d0e/342303d0ec1c88309ffe36400fc2faaf.png"><br><br>  And what to do if the element of the picture in the document does not exist, if there is only its address?  It's not scary.  In this case, you can use <code>fabric.Image.fromURL</code> : <br><br><pre> <code class="javascript hljs">fabric.Image.fromURL(<span class="hljs-string"><span class="hljs-string">'my_image.png'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">oImg</span></span></span><span class="hljs-function">) </span></span>{ canvas.add(oImg); });</code> </pre><br>  There are no surprises here.  Call <code>fabric.Image.fromURL</code> passing the address of the image, as well as the function (callback), which should be called when the picture is loaded.  The callback receives the <code>fabric.Image</code> object <code>fabric.Image</code> first argument.  At the time of the call, you can do anything with it ‚Äî change it, or immediately add it to the canvas for display. <br><br><pre> <code class="javascript hljs">fabric.Image.fromURL(<span class="hljs-string"><span class="hljs-string">'my_image.png'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">oImg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       oImg.scale(0.5).setFlipX(true); canvas.add(oImg); });</span></span></code> </pre><br><h3>  Path and PathGroup </h3><br>  We got acquainted with simple figures and pictures.  We now turn to more complex content. <br><br>  Meet the powerful and irreplaceable pair: Path and PathGroup. <br><br>  Path (literally translated "path") in Fabric is a curved figure that can be filled with color, have an outline, be modified in any way.  It is depicted as a set of commands that can be compared to drawing with a pen from one point to another.  With the help of such commands as ‚Äúmove‚Äù, ‚Äúline‚Äù (line), ‚Äúcurve‚Äù (curve), or ‚Äúarc‚Äù (arch), Path can reproduce surprisingly complex shapes.  And with the help of Path Groups (PathGroup), everything becomes possible. <br><br>  Fabric paths have similarities with <a href="http://www.w3.org/TR/SVG/paths.html">SVG &lt;path&gt; elements</a> .  They use the same set of commands, can be created from &lt;path&gt; elements and serialized into them.  We will talk about serialization and SVG parsing later.  Now it is worth saying that you will hardly be able to work with Path objects manually.  Instead, it makes sense to use the SVG parser built into Fabric.  To understand what these Path objects are, let's create one of them. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Canvas(<span class="hljs-string"><span class="hljs-string">'c'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Path(<span class="hljs-string"><span class="hljs-string">'M 0 0 L 200 100 L 170 200 z'</span></span>); path.set({ <span class="hljs-attr"><span class="hljs-attr">left</span></span>: <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-attr"><span class="hljs-attr">top</span></span>: <span class="hljs-number"><span class="hljs-number">120</span></span> }); canvas.add(path);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a0d/3a5/657/a0d3a5657f3f2aa95fc254b03898a219.png"><br><br>  When creating a <code>fabric.Path</code> object, we pass a string with instructions for ‚Äúdrawing‚Äù the curve.  This instruction looks, of course, very mysterious, but to understand it is actually quite easy.  ‚ÄúM‚Äù means ‚Äúmove‚Äù, and tells the invisible pen to move to point 0, 0. ‚ÄúL‚Äù means ‚Äúline‚Äù (line) and draws a line to point 200, 100. Then the ‚ÄúL‚Äù command draws a line to 170 , 200. Finally, ‚Äúz‚Äù causes the invisible handle to close the current path and complete the shape.  As a result, this triangular shape is obtained. <br><br>  The <code>fabric.Path</code> object is the same as the other objects in Fabric, so we easily changed its parameters (left, top).  But you can change more: <br><br><pre> <code class="javascript hljs">... var path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Path(<span class="hljs-string"><span class="hljs-string">'M 0 0 L 300 100 L 200 300 z'</span></span>); ... path.set({ <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: <span class="hljs-string"><span class="hljs-string">'red'</span></span>, <span class="hljs-attr"><span class="hljs-attr">stroke</span></span>: <span class="hljs-string"><span class="hljs-string">'green'</span></span>, <span class="hljs-attr"><span class="hljs-attr">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span> }); canvas.add(path);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/987/047/538/987047538069cc39794dd7a041f5f7b0.png"><br><br>  For the sake of interest, let's look at another circuit, this time more complex.  You will understand why creating contours manually is not the most fun. <br><br><pre> <code class="javascript hljs">... var path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> fabric.Path(<span class="hljs-string"><span class="hljs-string">'M121.32,0L44.58,0C36.67,0,29.5,3.22,24.31,8.41\ c-5.19,5.19-8.41,12.37-8.41,20.28c0,15.82,12.87,28.69,28.69,28.69c0,0,4.4,\ 0,7.48,0C36.66,72.78,8.4,101.04,8.4,101.04C2.98,106.45,0,113.66,0,121.32\ c0,7.66,2.98,14.87,8.4,20.29l0,0c5.42,5.42,12.62,8.4,20.28,8.4c7.66,0,14.87\ -2.98,20.29-8.4c0,0,28.26-28.25,43.66-43.66c0,3.08,0,7.48,0,7.48c0,15.82,\ 12.87,28.69,28.69,28.69c7.66,0,14.87-2.99,20.29-8.4c5.42-5.42,8.4-12.62,8.4\ -20.28l0-76.74c0-7.66-2.98-14.87-8.4-20.29C136.19,2.98,128.98,0,121.32,0z'</span></span>); canvas.add(path.set({ <span class="hljs-attr"><span class="hljs-attr">left</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">top</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }));</code> </pre><br>  Ogogo, what's going on here ?!  Let's figure it out. <br><br>  ‚ÄúM‚Äù still means ‚Äúmove‚Äù the command, and here the invisible pen begins its journey from the point ‚Äú121.32, 0‚Äù.  Then comes the ‚ÄúL‚Äù command, which leads it to the point ‚Äú44.58, 0‚Äù.  So far, everything is simple.  What next?  The ‚ÄúC‚Äù command means ‚Äúcubic bezier‚Äù (bezier <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%2591%25D0%25B5%25D0%25B7%25D1%258C%25D0%25B5">curve</a> ).  It forces the pen to draw a curve to the point ‚Äú36.67, 0‚Äù.  The curve uses ‚Äú29.5, 3.22‚Äù as the control point at the beginning of the line and ‚Äú24.31, 8.41‚Äù as the control point at the end of the line.  This is followed by a whole myriad of the remaining bezier curves, which ultimately creates the final figure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/11b/3ad/b2b11b3ad5995970cbe4d0dd5077d8d8.png"><br><br>  You probably will not work with such ‚Äúmonsters‚Äù manually.  Instead, you can use the very convenient method <code>fabric.loadSVGFromString</code> or <code>fabric.loadSVGFromURL</code> , which loads an entire SVG file.  Everything else will be done by the Fabric parser, passing through all SVG elements and creating the corresponding Path objects. <br><br>  By the way, as for SVG documents, Path in Fabric usually represents the SVG &lt;path&gt; element, but the sets of such elements, which can often be found in SVG documents, are usually represented through PathGroup ( <code>fabric.PathGroup</code> objects).  PathGroup is just a group of Path objects.  Since <code>fabric.PathGroup</code> inherits from <code>fabric.Object</code> , such objects can be added to the canvas like any other Fabric objects.  Of course, they can be controlled, like everything else. <br><br>  Directly to work with them is likely not necessary.  If you find them while working with Fabric, just keep in mind what you are dealing with and why they are needed at all. <br><br><h3>  Afterword </h3><br>  We have covered only the most basic aspects of the Fabric.  Having dealt with them, you can easily create both simple and complex shapes or pictures.  You can show them on canvas, change them (through the attributes of position, scale, angle, color, outline, transparency), and do whatever they wish with them. <br><br>  In the next part, we will talk about working with groups, animation, text, SVG parsing, rendering and serialization, event management, image filters and other interesting things. <br><br>     <a href="http://fabricjs.com/demos/">   </a>  <a href="http://fabricjs.com/benchmarks/"></a> ,     <a href="https://groups.google.com/forum/%3Ffromgroups">google group</a>  <a href="http://stackoverflow.com/questions/tagged/fabricjs">Stackoverflow</a> ,   <a href="http://fabricjs.com/docs/"></a> , <a href="https://github.com/kangax/fabric.js/wiki">wiki</a> ,  <a href=""></a> . <br><br>       Fabric! <br><br>   <a href="http://twitter.com/hakunin"> </a>      <a href="http://fabricjs.com/fabric-intro-part-1/"> </a> . <br></div><p>Source: <a href="https://habr.com/ru/post/162367/">https://habr.com/ru/post/162367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162355/index.html">Retention, or why the user will return to the game? Continuation</a></li>
<li><a href="../162357/index.html">Translation of "ANSI Common Lisp" in electronic form</a></li>
<li><a href="../162359/index.html">Salary Survey Testers</a></li>
<li><a href="../162363/index.html">Mail.Ru rating: right on target</a></li>
<li><a href="../162365/index.html">As we celebrated "Halloween" '2012!</a></li>
<li><a href="../162369/index.html">Using unused Google Apps accounts</a></li>
<li><a href="../162371/index.html">Yandeks.Pochta - is controlled from the keyboard</a></li>
<li><a href="../162373/index.html">Social media aggregator Meople.net united in one place 10 basic social programs</a></li>
<li><a href="../162375/index.html">Copyright history. Part 7: Raid seizure by Pfizer</a></li>
<li><a href="../162377/index.html">Promotion for startups</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>