<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We bypass the commercial protection using the black box method and write packet hack for lineage 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 
 It all started a year ago, when one of my comrades from the forum T proposed to rewrite the l2phx program known to the whole cheat world fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We bypass the commercial protection using the black box method and write packet hack for lineage 2</h1><div class="post__text post__text-html js-mediator-article"><h2>  Prologue </h2><br>  It all started a year ago, when one of my comrades from the forum T proposed to rewrite the l2phx program known to the whole cheat world for the authorship of the highly respected xkor. <br>  The l2phx itself (l2 packet hack, packet bag, hlapa) is a sniffer of incoming and outgoing packets (all implemented via LSP) of the client lineage 2 (there are versions for other mmorpg), with the ability to send / replace individual packets.  Xkor tried as followed: implemented encryption bypass methods, nice gui and so on.  But the malicious administrators of the freezers did not like this application: it substantially killed their income at the start of the next one-day packages.  Yes, there were times when any noname could go to any server and arrange a complete orgy with this tool.  At the same time, all sorts of commercial protections appeared, which <s>unsuccessfully</s> blocked the use of the sachet, and the most cunning ones still encrypted traffic.  One of these protections lives <s>on its last gasp</s> and to this day: meet, protection S. Today, protection S stands on all top lineage 2 servers. By the way, xkor provided such an outcome and realized the ability to write a packet decryption module (newxor.dll) on its own.  Yes, just write it was not rational: new server == new newxor.  The cheating on l2 gradually began to die, because the newbies were not able to send packets using the client memory modification methods (HxD, cheat engine, etc.). <br><br>  Then I took this undertaking not very seriously: I wrote a client -&gt; server packet interception module and abandoned it.  Why?  Because.  But just 3 days ago, I decided to resume work on this project and publish this article.  Why?  The cheater l2 community is currently dead.  All the bugs and laundering to them are in the hands of 10 people who communicate with each other on Skype and on the T forum. I also decided to leave.  And if you leave, it is only beautiful)) Two years ago I dreamed of a working bag, and today I do not need it. <br><a name="habracut"></a><br><h2>  Disclaimer </h2><br>  <s>September burns</s> in view of my age very soon, namely on September 1, I will meet my last year in one of Moscow schools.  The list of school literature did not even open, and books to prepare for the exam are gathering dust in the closet.  There is no time at all.  Part of the code is whipped in a hurry, not quite pleasant news was found out only after the work was completed, but more on that later.  The article is also written not entirely in literary language.  But what is, that is. <br><br><h2>  Server Capture Server ‚Üí Client </h2><br>  All the packets that the client receives from the server can eventually be caught by calling the exported <code>UNetworkHandler::AddNetworkQueue</code> inside engine.dll: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/aa2/025/a0c/aa2025a0cb57e08ea7eafeaec4446d14.jpg" alt="image"><br><br>  It is a wrapper, inside which is a jump to the original function: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/730/3e4/6a1/7303e46a180123c9f4c5a5d3958f997b.png" alt="image"><br><br>  It is quite obvious that somewhere around here the tricky S protection and decrypts packets that were additionally encrypted on the server.  If you look at how this code looks in memory, we will see the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e2/5ef/1dd/4e25ef1dd460dbc39be88a903730a285.png" alt="image"><br><br>  As corny, this is the most common jmp near to some handler.  The handler itself is not interesting to us, let it work for itself.  We just put the hook after this hook and get the packet in the decoded form.  Then there was the first problem.  Using a scientific method, it was revealed that functions like <code>VirtualProtect</code> and <code>VirtualAlloc</code> worked out with an error, and without them, the ray cannot be climbed into protected memory.  Why is this happening?  I never found out, there was no time.  But I can say that S protection intercepts <code>NtProtectVirtualMemory</code> and does something there.  Then I began to build an ingenious plan to deceive the defense, but my laziness got the better of it and I stupidly did this: <br><br><pre> <code class="cpp hljs">HANDLE hMain = OpenProcess(PROCESS_VM_OPERATION, FALSE, GetCurrentProcessId()); VirtualProtectEx(hMain, ... );</code> </pre><br>  Of course, it is not beautiful, considering that we are inside the process (I forgot to mention, we are writing exactly the dll);  but it works.  We return to the hook ... and the second problem pops up: the protection checks the first 10-20 bytes of this function.  It turns out right away, because the nk comes out of the window where we are scolded with obscenities.  What to do?  That's right, put the hook further.  I chose the offset 0x14 (see picture above).  jmp near takes 5 bytes, we will overwrite those <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> esi, <span class="hljs-number"><span class="hljs-number">0x3c</span></span> push <span class="hljs-number"><span class="hljs-number">0x1</span></span></code> </pre><br>  On <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jmp</span></span> ...</code> </pre><br>  Do not forget this, at the end of our handler you will have to restore them.  By the way.  The hook can be placed inside the imported <code>EnterCriticalSection</code> or elsewhere.  We go further.  The structure of the package, which is passed to the <code>AddNetworkQueue</code> function, back in 2010, was published by the respected GoldFinch: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkPacket</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> id, _padding1, exid, _padding2; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> size, _padding3; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data; }</code> </pre><br>  We are interested in the <code>id</code> and <code>data</code> fields.  As well as the contents of the <code>ecx</code> .  Why <code>ecx</code> ?  Everything is simple: we are dealing with the <code>__thiscall</code> and to call any function of the <code>UNetworkHandler</code> class <code>UNetworkHandler</code> we must have a pointer to our object with us.  It is transmitted exactly in <code>ecx</code> .  Why do we have to call something?  Next, you will understand everything, but for now I am providing the ready code: <br><br><pre> <code class="cpp hljs">BYTE *AddNetworkQueue = (BYTE *)GetProcAddress(hEngine, <span class="hljs-string"><span class="hljs-string">"?AddNetworkQueue@UNetworkHandler@@UAEHPAUNetworkPacket@@@Z"</span></span>); AddNetworkQueue += *(DWORD *)(AddNetworkQueue + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span>; retAddr_AddNetworkQueue = (DWORD)AddNetworkQueue + <span class="hljs-number"><span class="hljs-number">0x19</span></span>; trmpAddr = (DWORD)wrapper_AddNetworkQueue - ((DWORD)AddNetworkQueue + <span class="hljs-number"><span class="hljs-number">0x14</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span>); VirtualProtectEx(hMain, AddNetworkQueue + <span class="hljs-number"><span class="hljs-number">0x14</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, PAGE_EXECUTE_READWRITE, &amp;tmpProtect); *(AddNetworkQueue + <span class="hljs-number"><span class="hljs-number">0x14</span></span>) = <span class="hljs-number"><span class="hljs-number">0xE9</span></span>; *(DWORD *)(AddNetworkQueue + +<span class="hljs-number"><span class="hljs-number">0x14</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) = trmpAddr; VirtualProtectEx(hMain, AddNetworkQueue + <span class="hljs-number"><span class="hljs-number">0x14</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, PAGE_EXECUTE, &amp;tmpProtect); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!unh) Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  An unprepared person will want to die at this moment.  In fact, everything is simple.  I‚Äôll just point out that <code>AddNetworkQueue += *(DWORD *)(AddNetworkQueue + 1) + 5;</code>  just transitions from the jmp wrapper to the real AddNetworkQueue function.  What is <code>unh</code> ?  This is the same <code>ecx</code> value that we push into a variable in our handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __declspec(naked) wrapper_AddNetworkQueue() { __asm { pushad pushfd sub [unh], <span class="hljs-number"><span class="hljs-number">0</span></span> jnz L1 mov [unh], ecx L1: lea eax, [esp + <span class="hljs-number"><span class="hljs-number">44</span></span>] <span class="hljs-comment"><span class="hljs-comment">//32 (pushad) + 4 (pushfd) + 4 (push 4) + 4 (ret addr) push eax call [handler_AddNetworkQueue] popfd popad add esi, 0x3c //see disasm push 0x1 jmp [retAddr_AddNetworkQueue] } } void __stdcall handler_AddNetworkQueue(DWORD *stack) { NetworkPacket_t *pck = (NetworkPacket_t *)*stack; if (ShowServerPck) { printf("s -&gt; c | %02hhX ", pck-&gt;id); for (int i = 0; i &lt; pck-&gt;size; i++) printf("%02hhX ", pck-&gt;data[i]); printf("\n"); } }</span></span></code> </pre><br>  Here the naked <code>wrapper_AddNetworkQueue</code> function saves the values ‚Äã‚Äãof all registers, gets the value <code>unh</code> and calls our handler.  In it, we comfortably process the packet without fear for the stack, and return control back to the wrapper.  He, in turn, restores the jammed instructions and jumps to the place where we interrupted the original code.  Nous, one problem less. <br><br><h2>  Capturing client ‚Üí server packets </h2><br>  Honestly, these are the most delicious packages.  70% of all dups are based on them.  For sending these packages is responsible non-exported function, which is called <code>SendPacket</code> : <br><br><pre> <code class="cpp hljs">UNetworkHandler::SendPacket(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* msk, ...)</code> </pre> <br>  The function has a variable number of parameters that come from the stack based on the first argument (mask).  How to receive the address of this here, nor exported?  It's simple, just look at how it is called.  The article does not claim to be a tutorial on api lineage 2, so I‚Äôll just give you a specific example of a call: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/09d/c39/0ed/09dc390ed1bff23cde03e7d9d8cfe9a4.png" alt="image"><br><br>  Now it should be clear why we needed the register value. <br><br>  <code>ecx</code> : <br><br><pre> <code class="cpp hljs">SendPacket = (BYTE *)*(DWORD *)(**(DWORD **)(unh + <span class="hljs-number"><span class="hljs-number">0x48</span></span>) + <span class="hljs-number"><span class="hljs-number">0x68</span></span>); SendPacket += *(DWORD *)(SendPacket + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  SendPacket is also a wrapper and inside it is the usual jmp on the main function.  Her beginning looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/275/9b7/d4c/2759b7d4ce378ad6b65d964140110ec0.png" alt="image"><br><br>  And in memory, by analogy with <code>AddNetworkQueue</code> , like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae6/7b3/3df/ae67b33df4e26254b4a3587a008d8ec4.png" alt="image"><br><br>  Again, a banal leap for a certain handler, but in this case we cannot ignore it - it performs packet encryption.  What to do?  If you try to overwrite it on your jump - the protection of S swears.  And if you go through this jump? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ccd/74a/b3e/ccd74ab3e69b1e67a2f13df9dd596c5f.png" alt="image"><br><br>  Eee, one more jump.  I'll spoil: there will be 5 more of them (jmp / call near alternation).  We are dealing with obfuscation, cool.  What if we are too lazy to restore the flow of control? <br><br><h4>  Method in the forehead </h4><br>  Why not to overwrite one of these 5 jmp / near on your own?  At first, I did, and it was my fatal mistake.  As it turned out, S protection checks the integrity of the code in these places and, if it does not coincide with the original, it swears.  But!  not right away, Carl!  Only 15 minutes later.  Of course, at the development stage, I couldn‚Äôt afford to test performance for such a time.  At the end of the work on the whole project, I was pleasantly surprised.  But I did not wilt, but ... made the second fatal mistake.  Having tried the technique of the inline patch over the obfuscated code aka the self-erasing hooks (unfortunately, the source code of that option was not left to the question of the gita).  How it works: we are looking for any garbage instructions and overwrite it on the jmp near to our handler.  In it, we quickly restore the original bytes (we write them into memory, where we put jmp, and not just perform overwritten bytes in the handler), do our own thing, return control to the original function.  But this option will work only once?  That is, until we set the hook again.  We recall that the protection S only checks the first bytes of the function and if we put the hook at the end, then it will not say a word.  We put the second hook at the end of <code>SendPacket</code> , the most common hook in which we spawn a jmp near entry at the address of the garbage instruction obfuscated code.  To understand this, in my words, is not very simple, but the scheme is as follows: <br><br><ol><li>  Set the hook at the place of the garbage instructions of the protection processor S. In it, at the end, we restore these garbage instructions in memory and jump on them.  This way we erase our hook. </li><li>  Security handler S executes and transfers control to the original <code>SendPacket</code> function. </li><li>  At the end of it we put the second hook, which reinstalls the first one. </li></ol><br>  Why did I make this scheme a fatal error # 2?  The fact is that this approach will work only if the protection checks the integrity of the code from the current thread.  Those, if we have somewhere a second thread weighs, which checks the bytes of the first, then such a trick will not work.  So it happened, I just spent time.  What to do?  We can not change bytes in memory!  How to live?!  <s>Get out the window?</s> <br><br><h4>  Method behind </h4><br>  In fact, in such a situation there are a couple of options for installing a hook.  I chose one of them: the hook method of changing the rights of the memory page.  Yes, this is not the best option, but the terms were burning (I remind you that this was done at the very end, right before writing this article).  Here it is worth making a reference to the remarkable series of articles from Broken Sword "Intel processor in protected mode."  Read, do not be lazy.  As well as a reference to the series of articles by Matt Pietrek  ªa "Win32 SEH from the inside".  Googling is quite simple.  Now, I hope you understand what the whole point is.  We will change the attribute of the page where our <code>SendPacket</code> procedure <code>SendPacket</code> (in fact, I decided to change the attribute of the memory page where the protection handler S is located, more on that later).  It sounds difficult, but in fact we will need to execute the following code: <br><br><pre> <code class="cpp hljs">VirtualProtectEx(hMain, SendPacket, <span class="hljs-number"><span class="hljs-number">1</span></span>, PAGE_EXECUTE | PAGE_GUARD, &amp;tmpProtect);</code> </pre><br>  Now, after the client calls the <code>SendPacket</code> function, an exception will be generated that we have to handle.  I really don't want to write about tib, so we‚Äôll do everything quite simply <s>and not aesthetically</s> <br><br><pre> <code class="cpp hljs">AddVectoredExceptionHandler(<span class="hljs-number"><span class="hljs-number">1</span></span>, wrapper_SendPacket);</code> </pre><br>  Ok, now when we call <code>SendPacket</code> we‚Äôll go to <code>wrapper_SendPacket</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper_SendPacket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PEXCEPTION_POINTERS exInfo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exInfo-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_GUARD_PAGE_VIOLATION) { VirtualProtectEx(hMain, SendPacket, <span class="hljs-number"><span class="hljs-number">1</span></span>, PAGE_EXECUTE, &amp;tmpProtect); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exInfo-&gt;ContextRecord-&gt;Eip == (DWORD)SendPacket) { handler_SendPacket((DWORD *)exInfo-&gt;ContextRecord-&gt;Esp + <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//4 (ret addr) + 4 (ret addr) + 4 (1 arg) } return EXCEPTION_CONTINUE_EXECUTION; } return EXCEPTION_CONTINUE_SEARCH; }</span></span></code> </pre><br>  As you can see, in the <code>wrapper_SendPacket</code> function, <code>wrapper_SendPacket</code> is called, which normalizes the page attributes and returns control back.  But normalize page attributes == remove the hook.  We will use the second method above, described under the heading ‚ÄúHead-on‚Äù, and reinstall it by intercepting the end of the <code>SendPacket</code> function (the function has two ret, so we will install two hooks): <br><br><pre> <code class="cpp hljs">trmpAddr = (DWORD)wrapper_SendPacketEnd - ((DWORD)SendPacket + <span class="hljs-number"><span class="hljs-number">0xb5</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//first ret inside SendPacket VirtualProtectEx(hMain, SendPacket + 0xb5, 1, PAGE_EXECUTE_READWRITE, &amp;tmpProtect); *(SendPacket + 0xb5) = 0xE9; *(DWORD *)(SendPacket + 0xb5 + 1) = trmpAddr; trmpAddr = (DWORD)wrapper_SendPacketEnd - ((DWORD)SendPacket + 0xc5 + 5); //second ret inside SendPacket *(SendPacket + 0xc5) = 0xE9; *(DWORD *)(SendPacket + 0xc5 + 1) = trmpAddr; VirtualProtectEx(hMain, SendPacket + 0xc5, 1, PAGE_EXECUTE, &amp;tmpProtect);</span></span></code> </pre><br>  Himself <code>wrapper_SendPacketEnd</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __declspec(naked) wrapper_SendPacketEnd() { __asm { pushad pushfd call [handler_SendPacketEnd] popfd popad add esp, <span class="hljs-number"><span class="hljs-number">0x2000</span></span> <span class="hljs-comment"><span class="hljs-comment">//see disasm ret } } void __stdcall handler_SendPacketEnd() { if (ShowClientPck) VirtualProtectEx(hMain, SendPacket, 1, PAGE_EXECUTE | PAGE_GUARD, &amp;tmpProtect); }</span></span></code> </pre><br>  There is nothing complicated here, just set the <code>PAGE_GUARD</code> attribute and return, not to the end of SendPacket, but to its calling function. <br><br>  Let's go back to <code>wrapper_SendPacket</code> .  Do not forget?  Pay attention to the check. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exInfo-&gt;ContextRecord-&gt;Eip == (DWORD)SendPacket)) { ... }</code> </pre><br>  Could it be otherwise?  Fortunately, but in our case, unfortunately, yes.  When we execute <code>VirtualProtectEx</code> , we change the attribute of at least a whole page of memory.  Those at least 4 kilobytes of code are not available.  And there may be, and they are there, other procedures.  Those exceptions are not necessarily generated when calling SendPacket.  This is the main drawback of this method (the handler removes the hook when calling any procedures, at the end of which the hook is not restored), but it is solved.  There are several options to fix it.  We will use the fastest and not the highest quality.  We will stupidly spawn <code>VirtualProtectEx</code> with the argument <code>PAGE_GUARD</code> .  For this purpose (spoiler: not only for it), the exported function <code>FPlayerSceneNode::Render(FRenderInterface *)</code> was selected, which is called by the main thread in the loop <br><br><img src="https://habrastorage.org/getpro/habr/post_images/121/5ce/ade/1215ceade9839f563c0fb3328671b462.png" alt="image"><br><br>  Protection S does not swear if you intercept it at the very beginning.  We intercept and spawn <code>VirtualProtectEx</code> .  Does this give a 100% guarantee of how our hook works?  Of course not.  Only 95%.  That was enough for me.  I did not bother and roll crutches.  Above, I wrote that I set the hook not in the <code>engine.dll</code> address space, but at the address of the S protection handler. Why?  Just there, the percentage of response <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exInfo-&gt;ContextRecord-&gt;Eip == (DWORD)SendPacket)) { ... }</code> </pre><br>  much more (empirically tested).  If we add to the hook that we installed at the end of <code>SendPacket</code> , the output of a certain indicator line that will be displayed 100% after the package has been sent, we will see the following picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a3/b06/4cd/6a3b064cd76332e07df324982b7a399a.png" alt="image"><br><br>  The consecutive <code>#pck</code> lines tell us that the hook did not work (the same 5%).  Summarize the above porridge: <br><br><ol><li>  Change the attributes of the memory page and set an exception handler. </li><li>  Inside it, we restore the original attributes and, if an exception occurred at our <code>SendPacket</code> address, we can call our own handler </li><li>  Ultimately, control returns to the original <code>SendPacket</code> function, at the end of which is our second hook. </li><li>  He, in turn, re-sets the attributes of the memory page and transfers control to the code that caused <code>SendPacket</code> </li><li>  And at this time, in the <code>Render</code> procedure, the installation of the same attributes on the same memory will spawn. </li></ol><br><h2>  Sending packages to the server </h2><br>  The most delicious, but after all the dances with a tambourine around packet interception the client -&gt; server is quite simple.  We learned how to receive the SendPacket address above, we also saw an example of passing arguments to this function.  What to do?  Try to call!  And quite a lot.  We are trying to slip the arguments not from the <code>engine.dll</code> address space - we get it in the forehead.  We are trying to slip the return address not from the <code>engine.dll</code> address space - we get it in the ear.  We are trying to call the function not from the main thread, but directly from our dll`ki - we get through the liver.  In the end, the recipe is: <br><br><ol><li>  S protection do not care where one of the exported <code>engine.dll</code> functions is <code>engine.dll</code> , which calls <code>SendPacket</code> (but in vain!) </li><li>  Protection S does not care about where <code>SendPacket</code> called from (the return address must be inside <code>engine.dll</code> , the call must come from the main thread </li><li>  Protection S does not spit on the address space of the <code>SendPacket</code> function </li></ol><br>  And here is the medicine: <br><br><ol><li>  Forge return address when calling the <code>SendPacket</code> function </li><li>  Forge the address space of the arguments passed to it </li><li>  Make a call from the main thread </li></ol><br>  How to do it?  Very simple!  It is enough to find a free space inside the <code>engine.dll</code> (it will fit perfectly from alignment) and place one springboard + small buffer there.  Let's move from words to deeds: <br><br><pre> <code class="cpp hljs">BYTE *Remove = (BYTE *)GetProcAddress(hEngine, <span class="hljs-string"><span class="hljs-string">"?Remove@?$TArray@E@@QAEXHH@Z"</span></span>); Remove += *(DWORD *)(Remove + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span>; pckMsk = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)Remove + <span class="hljs-number"><span class="hljs-number">0x74</span></span>; <span class="hljs-comment"><span class="hljs-comment">//max 44 chars with zero (43 without). You can find more. VirtualProtectEx(hMain, pckMsk, 1, PAGE_EXECUTE_READWRITE, &amp;tmpProtect); //</span></span></code> </pre><br>  It was found the first available place with a length of 44 bytes (you can search and more).  There is a buffer in which the string will be written, which is passed to <code>SendPacket</code> first (in fact, second) argument. <br><br>  What to do with the return address?  Simply slip the springboard inside the <code>engine.dll</code> onto our handler (after the call to <code>SendPacket</code> control passes to our springboard, and from there to our handler).  What does this look like?  Like this: <br><br><pre> <code class="cpp hljs">BYTE* RequestRestart = (BYTE *)GetProcAddress(hEngine, <span class="hljs-string"><span class="hljs-string">"?RequestRestart@UNetworkHandler@@UAEXAAVL2ParamStack@@@Z"</span></span>); RequestRestart += *(DWORD *)(RequestRestart + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span>; retAddr_handler_Render = RequestRestart + <span class="hljs-number"><span class="hljs-number">0x2b</span></span>; trmpAddr = (DWORD)fixupStack_Render - ((DWORD)retAddr_handler_Render + <span class="hljs-number"><span class="hljs-number">5</span></span>); VirtualProtectEx(hMain, retAddr_handler_Render, <span class="hljs-number"><span class="hljs-number">1</span></span>, PAGE_READWRITE, &amp;tmpProtect); *retAddr_handler_Render = <span class="hljs-number"><span class="hljs-number">0xE9</span></span>; *(DWORD *)(retAddr_handler_Render + <span class="hljs-number"><span class="hljs-number">1</span></span>) = trmpAddr; VirtualProtectEx(hMain, retAddr_handler_Render, <span class="hljs-number"><span class="hljs-number">1</span></span>, PAGE_EXECUTE, &amp;tmpProtect);</code> </pre><br>  <code>fixupStack_Render</code> itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __declspec(naked) fixupStack_Render() { __asm { add esp, [fixupSize] <span class="hljs-comment"><span class="hljs-comment">//SendPacket has cdecl convention mov esp, ebp //prolog of pop ebp ///////handler_Render ret //ret to the end of wrapper_Render } }</span></span></code> </pre><br>  What fixupSize?  When calling <code>SendPacket</code> <br><br><pre> <code class="hljs perl">fixupSize = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax) + <span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">push</span></span> [pckMsk]) + <span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0x46</span></span>) __asm { mov ecx, [unh] mov eax, [ecx + <span class="hljs-number"><span class="hljs-number">0x48</span></span>] mov ecx, [eax] mov edx, [ecx + <span class="hljs-number"><span class="hljs-number">0x68</span></span>] //SendPacket <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> <span class="hljs-number"><span class="hljs-number">0x46</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> [pckMsk] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> [retAddr_handler_Render] //trampoline to fixupStack_Render jmp edx }</code> </pre><br>  we give him a variable number of parameters, hence the stack cleaning lies on us.  The code in the <code>fixupStack_Render</code> procedure <code>fixupStack_Render</code> this.  Of course, <code>SendPacket</code> itself must be called from the main thread, the aforementioned exported <code>Render</code> function for such a purpose will fit. <br><br><h2>  Sending packages to the client </h2><br>  Implemented in the same way. <br><br><h2>  Substitution of incoming and outgoing packets </h2><br>  It is enough to change the arguments of the functions that we have successfully learned to intercept above <s>without</s> success. <br><br><h2>  Completely forgot </h2><br><ol><li>  Servers on which everything was tested - the Pythas </li><li>  The application was written under the Interlude chronicle. </li><li>  Protection S swears if you change the export table </li></ol><br><h2>  Epilogue </h2><br>  I express my gratitude to each participant of the forum T, who has helped me at least once;  with which we were looking for bugs and dump servers.  As well as the developer of protection S: thank you for giving me a reason to write this vraytap.  And of course, Habr users who read the article to the end. <br><br>  Full source included: <b><a href="https://github.com/unc1e/Lineage-2-Intrelude-packet-hack-for-SmartGuard">clack</a></b> <br><br>  Video demonstration of the bag work: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/kpHweCa-TU0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  I say goodbye to this. </div><p>Source: <a href="https://habr.com/ru/post/336842/">https://habr.com/ru/post/336842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336830/index.html">Finnopolis-2017: we invite fintech talents to Sochi</a></li>
<li><a href="../336832/index.html">Promotion of games on Google Play</a></li>
<li><a href="../336834/index.html">Rethinking PID 1. Part 4</a></li>
<li><a href="../336838/index.html">You're not a compiler</a></li>
<li><a href="../336840/index.html">How (and why) we ported Shenzhen Solitaire under MS-DOS</a></li>
<li><a href="../336844/index.html">One method for solving different tasks: the percentage distribution of calls</a></li>
<li><a href="../336846/index.html">Richard Hamming: "I often compare creativity with sex"</a></li>
<li><a href="../336848/index.html">Transfer mail from Exchange to Zimbra</a></li>
<li><a href="../336850/index.html">Back up configuration switches, or fasten a little automation to GLPI</a></li>
<li><a href="../336852/index.html">Optimize the launch time of iOS applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>