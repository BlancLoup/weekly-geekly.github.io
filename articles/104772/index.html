<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The system of disjoint sets and its application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, Habrahabr. This is another post within my program to enrich the database of the largest IT resource with information on algorithms and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The system of disjoint sets and its application</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, Habrahabr.  This is another post within my program to enrich the database of the largest IT resource with information on algorithms and data structures.  As practice shows, many people lack this information, and the need is found in the most diverse spheres of programmer life. <br>  I continue to mainly choose those algorithms / structures that are easily understood and which do not require a lot of code - but it is difficult to underestimate the practical significance.  Last time it was a <a href="http://habrahabr.ru/blogs/algorithm/101818/">Cartesian tree</a> .  This time - a <strong>system of disjoint sets</strong> .  It is also known as <em>disjoint set union</em> (DSU) or <em>Union-Find</em> . <br><br><h4>  Condition </h4><br>  We set ourselves the following task.  Let us operate with elements of <strong>N</strong> types (for simplicity, hereinafter - numbers from 0 to N-1).  Some groups of numbers are combined into sets.  We can also add a new element to the structure; it thus forms a set of size 1 from itself.  Finally, from time to time we will need to merge some two sets into one. <br><br>  We formalize the task: create a <i>fast</i> structure that supports the following operations: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>MakeSet (X)</strong> - add a new element X to the structure, create for it a set of size 1 from itself. <br>  <strong>Find (X)</strong> - return the <em>identifier of the</em> set to which the element X belongs. As the identifier we will choose one element from this set - the <em>representative of the</em> set.  It is guaranteed that for the same set the representative will be returned the same, otherwise it will be impossible to work with the structure: even checking the belonging of two elements to one set <code>if (Find(X) == Find(Y))</code> will not be correct. <br>  <strong>Unite (X, Y)</strong> - combine two sets in which the elements X and Y lie in one new. <br><br>  In the figure I will demonstrate the work of such a hypothetical structure. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/6cf7f9c4/e6848578/0bf0505b/5d3ded44.png"></div><br><br><a name="habracut"></a><br><h4>  Implementation </h4><br>  The classic DSU implementation was proposed by <a href="http://en.wikipedia.org/wiki/Bernard_A._Galler">Bernard Galler</a> and <a href="http://en.wikipedia.org/wiki/Michael_J._Fischer">Michael Fischer</a> in 1964, but was investigated (including a temporary assessment of complexity) by <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B0%25D1%2580%25D1%258C%25D1%258F%25D0%25BD,_%25D0%25A0%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582">Robert Tarjan</a> already in 1975. Taryan also owns some results, improvements and applications, which we will talk about later today. <br><br>  We will store the data structure in the form of a forest, that is, turn the DSU into a system of non-intersecting trees.  All elements of one set lie in one corresponding tree, the representative of a tree is its root, the merging of sets is simply the union of two trees into one.  As we will see, such an idea, along with two small heuristics, leads to a surprisingly high speed of the resulting structure. <br><br>  To begin with, we need an array <strong>p</strong> that stores for each vertex of the tree its immediate ancestor (and for the root of the tree X, it itself).  Using this array alone, you can effectively implement the first two DSU operations: <br><br><h6>  MakeSet (X) </h6><br>  To create a new tree from the X element, it is enough to indicate that it is the root of its own tree, and does not have an ancestor. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { p[x] = x; }</code> </pre> <br><br><h6>  Find (X) </h6><br>  Representative of the tree will be its root.  Then, to find this representative, it is enough to go up the parental links until we stumble upon the root. <br><br>  But that's not all: such a naive implementation in the case of a degenerate (stretched in line) tree can work for O (N), which is unacceptable.  One could try to speed up the search.  For example, to store not only the immediate ancestor, but large log-lifting tables, but it requires a lot of memory.  Or, instead of storing the reference to the ancestor, store the reference to the root itself ‚Äî however, when merging trees (Unite), these references will have to be changed to all elements of one of the trees, and this, again, is an O (N) cost. <br><br>  We will go the other way: instead of speeding up the implementation, we will simply try not to allow excessively long branches in the tree.  This is the first DSU heuristic; it is called path compression.  The essence of heuristics: after a representative is found, we will change the ancestor to this representative for each vertex on the way from X to the root.  That is, in fact, we will re-hang all these vertices instead of a long branch directly to the root.  Thus, the implementation of the Find operation becomes two-pass. <br><br>  The figure shows the tree before and after the Find (3) operation.  Red ribs - those that we walked along the path to the root.  Now they are redirected.  Notice how after this the height of the tree has drastically decreased. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/9600413d/b75f196d/d66a82bb/281e7a86.png"></div><br><br>  The source code in a recursive form is quite simple to write: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Find</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[x] == x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[x] = Find(p[x]); }</code> </pre> <br><br><h6>  Unite (X, Y) </h6><br>  With the merger of two trees will have to tinker a bit.  Find the roots of both merging trees to begin with using the already-written Find function.  Now, remembering that our implementation stores only references to immediate parents, to merge trees it would be enough just to suspend one of the roots (and with it the whole tree) by the son to another.  Thus, all the elements of this tree will automatically belong to another - and the procedure for finding a representative will return the root of the new tree. <br><br>  The question is: which tree to which to hang?  To always choose one, say, tree X, is no good: it is easy to pick an example on which, after N associations, we get a degenerate tree ‚Äî one branch of N elements.  And here comes the second DSU heuristics, aimed at reducing the height of the trees. <br><br>  In addition to the ancestors, we will store another <strong>Rank</strong> array.  In it for each tree will be stored the upper limit of its height - that is, the longest branch in it.  Notice, not the height itself - in the process of Finding, the longest branch can self-destruct, but it is too expensive to spend another iteration on finding the new longest branch.  Therefore, for each root, a number will be written in the Rank array, guaranteed to be greater than or equal to the height of its tree. <br><br>  Now it is easy to make a decision to merge: in order to prevent too long branches in the DSU, we will hang the lower tree to a higher one.  If their heights are equal, it does not matter who is hung up to whom.  But in the latter case, the newly-made root must not forget to increase its Rank. <br><br>  This is how a typical Unite is produced (for example, with parameters 8 and 19): <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/cd47e0f0/32a74c66/8bba86dd/9ff33ea2.png"></div><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { x = Find(x); y = Find(y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rank[x] &lt; rank[y]) p[x] = y; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { p[y] = x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rank[x] == rank[y]) ++rank[x]; } }</code> </pre> <br><br>  However, in practice it turns out that it is possible and not to spend additional O (N) memory on frauds with ranks.  It is enough to choose a root for overweighing <strong>at random</strong> - surprisingly, but such a solution gives in practice a speed quite comparable with the original rank realization.  The author of this article all his life uses a randomized DSU, and there has not yet been a case when he would let him down. <br><br>  C # implementation: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { x = Find(x); y = Find(y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand.Next() % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) Swap(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); p[x] = y; }</code> </pre> <br><br><h4>  Speed ‚Äã‚Äãperformance </h4><br>  Due to the use of two heuristics, the speed of each operation depends strongly on the tree structure, and the tree structure depends on the list of operations performed before.  The only exception is MakeSet - its running time is obviously O (1) :-) For the other two, the speed is very subtle. <br><br>  Robert Taryan proved a remarkable fact in 1975: the operating time for both Find and Unite in a forest of size N is O (Œ± (N)). <br>  Under Œ± (N) in mathematics, we denote the inverse Akkerman function, that is, the inverse function for <nobr>f (N) = A (N, N)</nobr> .  <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%2590%25D0%25BA%25D0%25BA%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Ackermann's</a> A (N, M) <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%2590%25D0%25BA%25D0%25BA%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">function is</a> known for having a tremendous growth rate.  For example, <nobr>A (4, 4) = 2 <sup>2 <sup>2 <sup>65536</sup></sup></sup> -3</nobr> , this number is truly huge.  In general, for all conceivable practical values ‚Äã‚Äãof N, the inverse Ackermann function will not exceed 5. Therefore, it can be taken as a constant and taken as <nobr>O (Œ± (N)) ‚âÖ O (1)</nobr> . <br><br>  So, we have: <br>  MakeSet (X) - O (1). <br>  Find (X) - O (1) is depreciated. <br>  Unite (X, Y) - O (1) depreciated. <br>  Memory consumption - O (N). <br><br>  Not bad at all :-) <br><br><h4>  Practical applications </h4><br>  There are a large number of different uses for DSUs.  Most of them are connected with solving some problem <strong>in offline mode</strong> - that is, when the list of requests regarding the structure that is received by the program is known in advance.  I will give here several such problems along with brief ideas for solutions. <br><br><h6>  Skeleton minimum weight </h6><br>  An undirected connected graph with weighted edges is given.  Throw out some ribs from it so that in the end you get a tree, and the total weight of the edges of this tree should be the smallest. <br><br>  One of the well-known places where this problem arises (although it is solved differently) is blocking redundant links in the Ethernet network to avoid possible packet cycles.  The protocols created for this purpose are widely known, with half of the major modifications made by Cisco.  See the <a href="http://ru.wikipedia.org/wiki/STP">Spanning Tree Protocol for</a> more details. <br><br>  The figure shows a weighted graph with a selected minimum skeleton. <br><div style="text-align:center;"><img src="http://habrastorage.org/storage/95ddf648/8be775cd/3d5dcaa0/a5d4282d.png"></div><br><br>  Kraskal's algorithm for solving this problem: we will sort all the edges by increasing weight and will maintain the current forest of minimum weight using DSU.  Initially, a DSU consists of N trees, one vertex each.  We go along the edges in order of increasing;  if the current edge combines different components, we merge them into one and remember the edge as an element of the core.  As soon as the number of components reaches one, we built the desired tree. <br><br><h6>  Tarjan's algorithm for searching LCA offline </h6><br>  Given a tree and a set of queries of the form: for given vertices <strong>u</strong> and <strong>v,</strong> return their least common ancestor (LCA) to their nearest common ancestor.  The entire set of requests is known in advance, i.e.  The task is formulated offline. <br><br>  Let's start to start the search in depth on the tree.  Consider some query &lt;u, v&gt;.  Let depth search come to such a state that one of the vertices of the query (say, u) has already been visited by the search earlier, and now the current top of the search is v, the entire subtree v has just been examined.  Obviously, the answer to the query will be either the vertex v itself, or one of its ancestors.  Moreover, each of the ancestors of v, on the way to the root, generates some class of vertices u for which it is the answer: this class is exactly equal to the already viewed branch of the tree ‚Äúto the left‚Äù of such ancestor. <br>  In the picture you can see a tree with a partition of the vertices into classes, while the white vertices are still unvisited. <br><div style="text-align:center;"><img src="http://habrastorage.org/storage/99f1ac00/cc1080ba/9a556bff/afca13d4.png"></div><br>  Classes of such vertices do not intersect with each other, which means that they can be supported in DSU.  As soon as the depth-first search returns from the subtree, merge the class of this subtree with the class of the current vertex.  And to search for an answer, support the <strong>Ancestor</strong> array ‚Äî for each vertex, the ancestor itself, which gave rise to the class of this vertex.  The value of the cell of this array for the representative must not forget to rewrite when merging the trees.  But now in the depth search process for each fully processed vertex v, we can find all &lt;u, v&gt; in the request list, where u is already processed, and output the answer: <code>Ancestor[Find(u)]</code> . <br><br><h6>  Multigraph connectivity components </h6><br>  A multigraph (a graph in which a pair of vertices can be connected by more than one immediate edge) is given, to which queries of the form ‚Äúdelete some edge‚Äù and ‚Äúhow many are now in the graph of connectivity components come in?‚Äù <br><br>  The decision is trite.  First, we will execute all removal requests, calculate the number of components in the final graph, and remember it.  We turn out the resulting graph in DSU.  Now we‚Äôll go through the deletion requests in the reverse order: each edge removal from the old graph means a <em>possible</em> merging of two components in our ‚Äúflashback graph‚Äù stored in the DSU;  In this case, the current number of connected components is reduced by one. <br><br><h6>  Image segmentation </h6><br>  Consider some image - a rectangular array of pixels.  It can be represented as a grid graph: each vertex-pixel is directly connected by edges with its four nearest neighbors.  The task is to select the same semantic zones in the image, for example, of a similar color, and to be able to quickly determine for two pixels whether they are in the same zone.  So, for example, old black-and-white films are painted: for a start, you need to select areas with approximately the same shades of gray. <br><br>  There are two approaches to solving this problem, both end up using a DSU.  In the first version, we draw an edge not between each pair of neighboring pixels, but only between those that are quite close in color.  After that, the usual rectangular traversal of the graph will fill in the DSU, and we will get a set of connected components - they are also monochromatic areas of the image. <br><br>  The second option is more flexible.  We will not completely remove the edges, but assign each of them a weight calculated on the basis of the difference in colors and some additional factors - our own for each specific segmentation task.  In the resulting graph, it suffices to find some forest of minimum weight, for example, using the same Krasalkal algorithm.  In practice, not every current connecting edge is recorded in the DSU, but only those for which at the moment the two components do not differ much by the measures of the other special weight function. <br><br><h6>  Maze Generation </h6><br>  Task: generate a maze with one entrance and one exit. <br><br>  Algorithm of the decision: <br>  Let's start with the state when all the walls are installed, except for the entrance and exit. <br>  At each step of the algorithm, choose a random wall.  If the cells between which it stands are still not connected at all (they lie in different components of the DSU), then we destroy it (we merge the components). <br>  We continue the process to a state of convergence: for example, when the input and output are connected;  or when there is only one component left. <br><br><h4>  Single Pass Algorithms </h4><br>  There are implementation options for Find (X), which require one pass to the root, not two, but retain the same or almost the same degree of speed.  They implement other strategies for reducing the height of the tree, unlike path compression. <br><br>  Option number 1: <em>path splitting</em> .  On the way from the top X to the root, redirect the parent connection of each peak from its ancestor to the ancestor of the ancestor (grandfather). <br><br>  Option number 2: <em>path halving</em> .  Take the idea of ‚Äã‚Äãpath splitting, but redirect the links of not all the vertices along the way, but only those on which we redirect - that is, "grandfathers". <br><br>  In the figure, the same tree is taken, the Find (3) query is executed in it.  The center shows the result with the use of path splitting, on the right - path halving. <br><img src="http://habrastorage.org/storage/d0fd83da/07eb7919/a4504522/2f98ba19.png"><br><br><h4>  Functional implementation </h4><br>  The system of disjoint sets has one major drawback: it does not support the operation of Undo in any form, because it is implemented through the imperative style.  It would be much more convenient to implement a DSU in a functional style, when each operation does not change the structure in place, but returns a slightly modified new structure in which the required changes are made (most of the memory of the old and new structures is common).  Such data structures in English terminology are called <b>persistent</b> , they are widely used in pure functional programming, where the idea of ‚Äã‚Äãdata immutability dominates. <br><br>  By virtue of the purely imperative idea of ‚Äã‚ÄãDSU algorithms, its functional implementation while maintaining performance for a long time seemed unthinkable.  However, in 2007, Sylvain Conchon and Jean-Christophe Filli√¢tre presented in their work the desired functional version in which the Unite operation returns a modified structure.  To be honest, it is not quite functional, it uses imperative assignments, but they are safely hidden inside the implementation, and the persistent DSU interface is purely functional. <br><br>  The main idea of ‚Äã‚Äãthe implementation is the use of data structures that implement ‚Äúpersistent arrays‚Äù: they support the same operations as arrays, but they still do not modify the memory, but return a modified structure.  Such an array can be easily implemented with the help of some tree, however, in this case, operations with it will take O (log <sub>2</sub> N) time, and for DSU such an estimate is already excessively large. <br><br>  For further technical details refer readers to the <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.79.8494%26rep%3Drep1%26type%3Dpdf">original article</a> . <br><br><h4>  Literature </h4><br>  Systems of non-intersecting sets in the scope of this article are discussed in the famous book - Kormen, Leyzerson, Rivest, Stein ‚ÄúAlgorithms: construction and analysis‚Äù.  There you can find evidence that the execution of operations takes about Œ± (N) time. <br><br>  On <a href="http://e-maxx.ru/algo/dsu">Maxim Ivanov's site</a> you can find the full DSU implementation in C ++. <br><br>  The <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.56.8354%26rep%3Drep1%26type%3Dps">Wait-free Parallel Algorithms for the Union-Find Problem</a> article discusses the parallel version of the DSU implementation.  It does not block threads. <br><br>  Thank you all for your attention :-) </div><p>Source: <a href="https://habr.com/ru/post/104772/">https://habr.com/ru/post/104772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../104756/index.html">Technologies used in the new Twitter</a></li>
<li><a href="../104763/index.html">Liquid clothing fits any size.</a></li>
<li><a href="../104766/index.html">HTML5 Prefetching - Preloading Documents</a></li>
<li><a href="../104768/index.html">Regular expression simplicity test</a></li>
<li><a href="../104771/index.html">Cryptanalysis of the Vigenere cipher</a></li>
<li><a href="../104775/index.html">The cost of credit cards fell to $ 1.50 apiece</a></li>
<li><a href="../104777/index.html">Achtung: DDoS</a></li>
<li><a href="../104781/index.html">Stylebot</a></li>
<li><a href="../104783/index.html">Not all Creative Commons licenses are free!</a></li>
<li><a href="../104785/index.html">CAPTCHA + advertising banner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>