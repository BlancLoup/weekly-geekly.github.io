<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js and server rendering in Airbnb</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The material, the translation of which we publish today, is dedicated to the story of how Airbnb optimizes server parts of web applications with an ey...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js and server rendering in Airbnb</h1><div class="post__text post__text-html js-mediator-article">  The material, the translation of which we publish today, is dedicated to the story of how Airbnb optimizes server parts of web applications with an eye to the increasing use of server-side rendering technologies.  Over the course of several years, the company gradually transferred its entire frontend to a <a href="https://medium.com/airbnb-engineering/rearchitecting-airbnbs-frontend-5e213efc24d2">uniform</a> architecture, according to which web pages are hierarchical structures of React components filled with data from their API.  In particular, during this process there was a systematic rejection of Ruby on Rails.  In fact, Airbnb is planning to switch to a new service based solely on Node.js, thanks to which fully prepared pages rendered on the server will be sent to users' browsers.  This service will generate most of the HTML code for all Airbnb products.  The rendering engine in question is different from most of the backend services used by the company due to the fact that it is not written in Ruby or Java.  However, it differs from traditional high-loaded Node.js-services, around which mental models and auxiliary tools used in Airbnb are built. <br><br> <a href="https://habr.com/company/ruvds/blog/418009/"><img src="https://habrastorage.org/webt/rg/zm/64/rgzm64dbdvumj6ycekqpoxbqxhw.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Node.js platform</font> </h2><br>  Reflecting on the Node.js platform, you can draw in your imagination how an application built with the asynchronous data processing capabilities of this platform quickly and efficiently serves hundreds or thousands of parallel connections.  The service pulls out the data it needs from everywhere and processes it a little to match the needs of a huge number of customers.  The owner of such an application has no reason to complain, he is confident in the lightweight model of simultaneous data processing used by him (in this material we use the word "simultaneous" to convey the term "concurrent", for the term "parallel" - "parallel").  She perfectly solves her task. <br><br>  Server-side rendering (SSR, Server Side Rendering) changes the basic ideas leading to a similar vision of the issue.  So, server rendering requires large computational resources.  The code in the Node.js environment is executed in one thread, as a result, to solve computational problems (as opposed to input / output tasks), the code can be executed simultaneously, but not in parallel.  Node.js is capable of handling a large number of parallel I / O operations; however, when it comes to computing, the situation changes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since, when using server rendering, the computational part of the request processing task is increased in comparison with the part related to I / O, simultaneously incoming requests will affect the speed of the server response because they are competing for processor resources.  It should be noted that when using asynchronous rendering, the competition for resources is still present.  Asynchronous rendering solves the problems of responsiveness of a process or browser, but does not improve the situation with delays or concurrency.  In this material we will focus on a simple model that includes only computational loads.  If we talk about a mixed load, which includes both input and output operations and calculations, then simultaneously incoming requests will increase delays, but taking into account the advantage of a higher system capacity. <br><br>  Consider a command like <code>Promise.all([fn1, fn2])</code> .  If <code>fn1</code> or <code>fn2</code> are promises resolved by means of the I / O subsystem, then during the execution of this command, parallel execution of operations can be achieved.  It looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96e/6f8/d81/96e6f8d8187475775542576cabbc51ca.png"></div><br>  <i><font color="#999999">Parallel execution of operations using I / O subsystem</font></i> <br><br>  If <code>fn1</code> and <code>fn2</code> are computing tasks, they will be executed like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e8/03d/803/8e803d80347cb302f3e86af0bbcd1e84.png"></div><br>  <i><font color="#999999">Performing computational tasks</font></i> <br><br>  One of the operations will have to wait for the completion of the second operation, since there is only one stream in Node.js. <br><br>  In the case of server rendering, this problem occurs when the server process has to handle several simultaneous requests.  Processing of such requests will be delayed until the requests received earlier are processed.  Here's what it looks like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/135/03e/54f/13503e54f4aa44cd1481c0848e7406c7.png"></div><br>  <i><font color="#999999">Processing simultaneous requests</font></i> <br><br>  In practice, request processing often consists of many asynchronous phases, even if they imply a serious computational load on the system.  This can lead to an even more difficult situation with the alternation of tasks for processing such requests. <br><br>  Suppose our requests consist of a chain of tasks that resembles the following: <code>renderPromise().then(out =&gt; formatResponsePromise(out)).then(body =&gt; res.send(body))</code> .  When a couple of such requests arrive in the system, with a small interval between them, we can observe the following picture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/958/ecf/070/958ecf0704405b06a60e230631ac7730.png"></div><br>  <i><font color="#999999">Processing requests that came with a small interval, the problem of the struggle for processor resources</font></i> <br><br>  In this case, it takes about twice as long to process each request than it takes to process an individual request.  As the number of requests processed simultaneously increases, the situation becomes even worse. <br><br>  In addition, one of the typical goals of an SSR implementation is the ability to use the same or very similar code on both the client and the server.  The major difference between these environments is that the client environment is essentially the environment in which one client works, and the server environment, by its nature, is a multi-client environment.  What works well on the client, such as singletons or other approaches to storing the global state of the application, leads to errors, data leaks, and, in general, to confusion, while simultaneously processing multiple requests to the server. <br><br>  These features become problems in a situation where you need to simultaneously handle multiple requests.  Everything usually works quite normally under lower loads in a cozy environment of the development environment, which is used by one client represented by a programmer. <br><br>  This leads to a situation that is very different from the classic examples of Node.js applications.  It should be noted that we use the JavaScript runtime for the rich set of libraries available in it, and because it is supported by browsers, and not for its model of simultaneous data processing.  In this application, the asynchronous model of simultaneous data processing demonstrates all its shortcomings, which are not compensated by advantages, which are either very few or not at all. <br><br><h2>  <font color="#3AC1EF">Lessons from the Hypernova project</font> </h2><br>  Our new rendering service, Hyperloop, will be the main service with which users of the Airbnb website will interact.  As a result, its reliability and performance play a crucial role in ensuring the convenience of working with the resource.  By implementing Hyperloop in production, we take into account the experience that we gained while working with our earlier server rendering system - <a href="http://github.com/airbnb/hypernova">Hypernova</a> . <br><br>  Hypernova does not work like our new service.  This is a pure rendering system.  It is called from our monolithic Rail service, called Monorail, and returns only HTML fragments for specific rendered components.  In many cases, such a ‚Äúfragment‚Äù represents the lion‚Äôs share of a page, and Rails provides only a page layout.  With legacy technology, parts of the page can be linked together using ERB.  In any case, however, Hypernova does not load any data needed to form a page.  This is a Rails task. <br><br>  Thus, Hyperloop and Hypernova have similar performance characteristics related to computing.  At the same time, Hypernova, as a production service that processes significant amounts of traffic, provides a good field for testing, leading to an understanding of how the Hypernova replacement will behave in combat conditions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cee/51a/2f7/cee51a2f7e198d242ce8e5294f4e972f.png"></div><br>  <i><font color="#999999">Hypernova work pattern</font></i> <br><br>  This is how Hypernova works.  User requests come to our main Rails application, Monorail, which collects the properties of React components that need to be displayed on a page and makes a request to Hypernova, passing these properties and component names.  Hypernova renders the components with properties in order to generate the HTML code that needs to be returned to the Monorail application, which then inserts this code into the page template and sends it all back to the client. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/d7d/35b/86dd7d35b582f66de058a0aa60f5ad0a.png"></div><br>  <i><font color="#999999">Sending the finished page to the client</font></i> <br><br>  In the event of an abnormal situation (this may be an error or a response time out) in Hypernova, there is a fallback option, using which components and their properties are embedded in the page without HTML generated on the server, after which it is sent to the client and rendered there hopefully successful.  This led us to not considering Hypernova as a critical part of the system.  As a result, we could allow the occurrence of a certain number of failures and situations in which timeout is triggered.  Adjusting the request timeouts, we, based on observations, set them at about the level of P95.  As a result, it is not surprising that the system worked with a basic timeout rate of less than 5%. <br><br>  In situations of traffic reaching peak values, we could see that up to 40% of requests to Hypernova are closed by timeouts in Monorail.  On the Hypernova side, we have seen <code>BadRequestError: Request aborted</code> lesser height.  These errors, in addition, existed in normal conditions, while in normal operation, due to the architecture of the solution, the other errors were not particularly noticeable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/746/8c1/192/7468c11924fcf883eb3a6e73c734a263.png"></div><br>  <i><font color="#999999">Peak values ‚Äã‚Äãof timeouts (red lines)</font></i> <br><br>  Since our system could work without Hypernova, we didn‚Äôt pay much attention to these features, they were perceived rather as annoying little things, and not as serious problems.  We explained these problems by the features of the platform, by the fact that the launch of the application is slow due to the rather heavy initial garbage collection operation, due to the peculiarities of compiling the code and caching data, and for other reasons.  We hoped that the new React or Node releases would include performance improvements that would mitigate the disadvantages of slow service startup. <br><br>  I suspected that what was happening was very likely the result of poor load balancing or a consequence of problems in the deployment of solutions when increasing delays were manifested due to excessive computational load on the processes.  I added an auxiliary layer to the system to log information about the number of requests processed simultaneously by separate processes, as well as to record cases in which the process received more than one request. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/5c2/70c/ce15c270c4ccdcd301f40fad7312e769.png"></div><br>  <i><font color="#999999">Research results</font></i> <br><br>  We considered the delay of the service to be the culprit for the delays, and in fact the problem was caused by parallel requests competing for CPU time.  According to the measurement results, it turned out that the time spent by the request while waiting for the completion of processing other requests corresponds to the time spent processing the request.  In addition, this meant that the increase in delays due to simultaneous processing of requests looks the same as an increase in delays due to an increase in the computational complexity of the code, which leads to an increase in the load on the system when processing each request. <br><br>  This, moreover, made it more obvious that the <code>BadRequestError: Request aborted</code> could not be confidently explained by the slow launch of the system.  The error was based on the request body parsing code, and occurred when the client canceled the request before the server was able to read the request body completely.  The client stopped working, closed the connection, depriving us of the data that is needed in order to continue processing the request.  It‚Äôs much more likely that this was due to the fact that we started processing the request, after this the event loop turned out to be blocked by rendering for another request, and then we returned to the interrupted task in order to complete it, but the result was that the client , who sent us this request, has already disconnected, interrupting the request.  In addition, the data transmitted in requests to Hypernova were quite voluminous, on average, in the region of several hundred kilobytes, and this, of course, did not contribute to the improvement of the situation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b4/b62/bc6/0b4b62bc6a1b5e902413711b0d3272e0.png"></div><br>  <i><font color="#999999">Error caused by disconnecting the client that did not wait for an answer</font></i> <br><br>  We decided to deal with this problem, using a couple of standard tools, in which we had a lot of experience.  This is a reverse proxy server ( <a href="https://www.nginx.com/">nginx</a> ) and a load balancer ( <a href="http://www.haproxy.org/">HAProxy</a> ). <br><br><h2>  <font color="#3AC1EF">Reverse proxying and load balancing</font> </h2><br>  In order to take advantage of the multi-core processor architecture, we run several Hypernova processes using the built-in module Node.js <a href="https://nodejs.org/api/cluster.html">cluster</a> .  Since these processes are independent, we can simultaneously handle simultaneously incoming requests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9df/cbe/aae/9dfcbeaae2d82fa13007670288d8b461.png"></div><br>  <i><font color="#999999">Parallel processing of requests coming at the same time</font></i> <br><br>  The problem here is that each Node process is fully occupied all the time that lasts for processing a single request, including reading the request body sent from the client (in this case Monorail plays its role).  Although we can read multiple requests in parallel in a single process, this, when it comes to rendering, leads to alternation of computational operations. <br><br>  Node process resource utilization is tied to client and network speed. <br><br>  As a solution to this problem, consider a buffering reverse proxy server that will allow you to maintain communication sessions with clients.  The inspiration for this idea was the unicorn web server that we use for our Rails applications.  <a href="https://bogomips.org/unicorn/PHILOSOPHY.html">The principles</a> declared by unicorn perfectly explain why this is so.  For this purpose we used nginx.  Nginx reads the request coming from the client to the buffer, and sends the request to the Node server only after it has been completely read.  This data transfer session runs on a local machine, through a loopback interface, or using Unix domain sockets, and this is much faster and more reliable than transferring data between individual computers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/50e/77b/a2050e77b5ff48219773729978481244.png"></div><br>  <i><font color="#999999">Nginx buffers requests and then sends them to the Node server</font></i> <br><br>  Due to the fact that nginx is now engaged in reading requests, we were able to achieve a more uniform load of Node processes. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/eb0/875/beaeb08758e4926cb3072670993f606f.png"></div><br>  <i><font color="#999999">Uniform loading of processes through the use of nginx</font></i> <br><br>  In addition, we used nginx to process some requests that do not require access to Node processes.  The discovery and routing layer of our service uses low-load <code>/ping</code> requests to verify communication between hosts.  Processing all of this in nginx eliminates a significant source of additional (albeit small) load on Node.js processes. <br><br>  The following improvement concerns load balancing.  We need to make thoughtful decisions about the distribution of requests between Node-processes.  The <code>cluster</code> module distributes requests in accordance with the round-robin algorithm, in most cases with attempts to bypass processes that do not respond to requests.  With this approach, each process receives a request in turn. <br><br>  The <code>cluster</code> module distributes connections, not requests, so all this does not work as we need.  The situation gets worse when using permanent connections.  Any persistent connection from a client is tied to a single specific workflow, which complicates the efficient distribution of tasks. <br><br>  The round-robin algorithm is good when there is a low variability in request delays.  For example, in the situation illustrated below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/883/4f2/ed5/8834f2ed56f7410de5f306f15e66e5e9.png"></div><br>  <i><font color="#999999">Algorithm round-robin and connections for which requests are stably received</font></i> <br><br>  This algorithm is no longer so good when it is necessary to process requests of different types, for the processing of which you may need completely different time costs.  The most recent request sent to a certain process is forced to wait for the processing of all requests sent earlier, even if there is another process that has the ability to process such a request. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/037/381/8c8/0373818c8632668b96f2ae77c32c9be2.png"></div><br>  <i><font color="#999999">Uneven process load</font></i> <br><br>  If you distribute the requests shown above more rationally, you get something like the one shown in the figure below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a3/b32/9448a3b328094d81d73480e6b0e9d6d6.png"></div><br>  <i><font color="#999999">Rational distribution of requests by threads</font></i> <br><br>  With this approach, waiting is minimized and it becomes possible to send responses to requests faster. <br><br>  You can achieve this by placing requests in a queue, and assigning them to a process only when it is not busy processing another request.  For this purpose we use HAProxy. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fda/2cc/367/fda2cc367f401ef351cad7bff55a13ea.png"></div><br>  <i><font color="#999999">HAProxy and process load balancing</font></i> <br><br>  When we used HAProxy for load balancing on Hypernova, we completely eliminated timeout peaks, as well as <code>BadRequestErrors</code> errors. <br><br>  Simultaneous requests were also the main cause of delays during normal operation; this approach reduced such delays.  One of the consequences of this is that now only 2% of requests were closed by timeout, not 5%, with the same timeout settings.  The fact that we managed to move from a situation with 40% of errors to a situation with timeout in 2% of cases showed that we are moving in the right direction.  As a result, today our users see the website's loading screen much less often.  It should be noted that the stability of the system will be of particular importance for us with the expected transition to a new system that does not have the same backup mechanism as Hypernova has. <br><br><h2>  <font color="#3AC1EF">Details about the system and its settings</font> </h2><br>  In order for all this to work, you need to configure nginx, HAProxy and Node-application.  Here is <a href="https://github.com/schleyfox/example-node-ops">an example of a</a> similar application using nginx and HAProxy, by analyzing which, you can understand the device of the system in question.  This example is based on the system that we use in production, but it is simplified and modified so that it can be performed in the foreground on behalf of an unprivileged user.  In production, everything should be configured using some kind of supervisor (we use runit, or, increasingly, kubernetes). <br><br>  <a href="">The nginx configuration is</a> fairly standard, using the server listening on port 9000, configured to proxy requests to the HAProxy server, which listens on port 9001 (in our configuration, we use Unix domain sockets). <br><br>  In addition, this server intercepts requests to the endpoint <code>/ping</code> to directly service requests directed at verifying network connectivity.         nginx ,     <code>worker_processes</code>  1,     nginx ‚Äî           HAProxy  Node-.  ,       ,    ,  Hypernova,     ( ).             . <br><br>  Node.js <code>cluster</code>        .        HAProxy,        <code>cluster</code> ,    .        <a href="https://github.com/airbnb/pool-hall">pool-hall</a> .  ‚Äî ,        ,   ,   <code>cluster</code> ,        .  <a href=""></a>   <code>pool-hall</code>     ,      . <br><br>  <a href=""> HAProxy</a> ,     9001       ,    9002  9005.     ‚Äî <code>maxconn 1</code> ,     .          .       HAProxy (    8999). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/232/d95/515/232d95515b1541bccfab440f8fe12cc8.png"></div><br> <i><font color="#999999">  HAProxy</font></i> <br><br> HAProxy            .    ,    <code>maxconn</code> .    <code>static-rr</code> (static round-robin),  ,  ,       .   ,      round-robin, ,        , ,   ,     .     ,          ,   .      . <br><br> ,       ,        .       (   ).         ,   ,     ,   ,     .  ,                   ,        . <br><br><h2> <font color="#3AC1EF">  HAProxy</font> </h2><br>         HAProxy.       ,         ,    ,               .  ,    ,    (  )   .      ,        ,    <code>cluster</code> .     ,    . <br><br>       <code>ab</code> (Apache Benchmark)   10000   .       -   .       : <br><br><pre> <code class="hljs swift">ab -l -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> &lt;<span class="hljs-type"><span class="hljs-type">CONCURRENCY</span></span>&gt; -n <span class="hljs-number"><span class="hljs-number">10000</span></span> http:<span class="hljs-comment"><span class="hljs-comment">//&lt;HOSTNAME&gt;:9000/render</span></span></code> </pre> <br>     15    4-  -,    <code>ab</code>     ,        .       ( <code>concurrency=5</code> ),    ( <code>concurrency=13</code> ),     ,        ( <code>concurrency=20</code> ).      ,      . <br><br>         ,  -,      .          ,      .       ,  ,   ,     ,       .  ,     ,       ,     . <br><br>    ,   ‚Äî      . <br><br>     <code>maxconn 1</code>     ,  ,         . <br><br>      HTTP  TCP  ,    ,     ,  .   ,      <code>maxconn</code> ,       .     ,            ,          (, ,    ). <br><br>  ,         , ,   ,  ,      ,       . <br><br>    ‚Äî  ,     .    <code>option redispatch</code>    <code>retries 3</code> ,    ,          ,   , ,    ,   .            . <br><br>     ,  - ,       .        ,       .   ,          ,     .     100    ,        10 ,    ,    .        ,      .   ,            <code>accept</code> . <br><br>      ,        ( <a href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html">backlog</a> )    ,    .       SYN-ACK ( <a href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html"></a> ,   , ,        ACK  ).      ,      ,     ,       ,      . <br><br>      ,   ,    ,   ,       .    ,       ,      1.   <code>maxconn</code>                .     0  ,   ,     ,  ,           ,     .       ,     .         -  ,      ,         .  <code>abortonclose</code>        ,    .  ,        <code>abortonclose</code> .            nginx. <br><br>  ,     ,    .       (    )   ,       ,        ,     ,       ,  .  HAProxy          ,      ,        (       ).               ,     ,         ,    HTML.          ,   ,       .  ,       ,       (     ,  ,     ).            ,   ,            .   ,  ,   ,  .           HAProxy,            MAINT    HAProxy. <br><br>   ,     ,   ,  <code>server.close</code>  Node.js    ,     HAProxy   ,       ,      ,      .     ,     ,       ,     ,   ,     . <br><br>  ,  ,    <code>balance first</code> ,           (   <code>worker1</code> )        15%   ,    ,   ,     <code>balance static-rr</code> .        ,       ¬´¬ª .      .     (12 ),  , , -      .   ,  ,       ,   ¬´¬ª     ¬´¬ª.        . <br><br> , ,      Node <code>server.maxconnections</code> , ( ,   ),   ,  ,   ,         .        ,    <code>maxconnection</code> ,      ,  ,    .     JavaScript,          (        ).  ,    ,        ,          .  ,     ,   ,      HAProxy  Node    ,       .     ,        ,         . <br><br>   ,      ,   , , <a href=""></a> . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>     Node.js      .     , , ,    -.      Node.js    .   , ,       ,    ,   ,        , ,  nginx  HAProxy. <br><br> ,   Airbnb  ,   Node.js     . <br><br>  <b>Dear readers!</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Do you use server rendering in your projects? </font></font><br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/418009/">https://habr.com/ru/post/418009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417999/index.html">English: Engineer's View</a></li>
<li><a href="../418001/index.html">5 models of effective team interaction</a></li>
<li><a href="../418003/index.html">Ministry of Communications estimated the costs of sites for the implementation of the law of Spring</a></li>
<li><a href="../418005/index.html">Software developers do not agree with the definition of "special technical equipment" from the FSB</a></li>
<li><a href="../418007/index.html">Cross-platform development using .NET, reactive programming, MVVM pattern and code generation</a></li>
<li><a href="../418011/index.html">One-page and SEO. Optimization secrets</a></li>
<li><a href="../418013/index.html">The Intel Core i7-8086K (Part 3)</a></li>
<li><a href="../418015/index.html">New Vasyuki. Innovative development of Moscow until 2100</a></li>
<li><a href="../418017/index.html">Analysis of the behavior of the Pegasus Trojan in the network</a></li>
<li><a href="../418023/index.html">Pointers in C are more abstract than they might seem.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>