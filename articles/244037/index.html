<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SSL certificates: everyone, everyone, and let no one leave offended</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As previously reported at GeekTimes, EFF, with the support of Mozilla, Cisco, Akamai, IdenTrust, and researchers from the University of Michigan (Univ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SSL certificates: everyone, everyone, and let no one leave offended</h1><div class="post__text post__text-html js-mediator-article">  As <a href="http://geektimes.ru/post/241630/">previously reported</a> at GeekTimes, EFF, with the support of Mozilla, Cisco, Akamai, IdenTrust, and researchers from the University of Michigan (University of Michigan) created a new Non-Commercial Certificate Authority <a title="Let‚Äôs encrypt" href="https://letsencrypt.org/">Let's Encrypt</a> <a href="https://habr.com/ru/post/244037/">[1]</a> .  The goal of the project is to accelerate the transition of the World Wide Web from HTTP to HTTPS. <br><a name="habracut"></a><br><h2>  What is the point? </h2><br>  As stated in <a href="https://habr.com/ru/post/244037/">[2]</a> , despite the fact that HTTP has received a huge spread (which is a sign of a successful protocol), its disadvantage is insecurity (openness of transmitted data) by-design.  Whenever a user connects to the site via HTTP, he is subject to a number of potential problems, such as hijacking accounts, intercepting traffic, tracking government and commercial organizations, embedding malicious code (scripts) in the code pages, censorship. <br><br>  Researchers note that HTTPS, although not a panacea, solves these problems, so the transition to its widespread use is an important task. <br><br>  The project is scheduled to launch in the summer (June?) Of 2015. Let's Encrypt will automatically issue free certificates for any site that requests them.  Planned.  that switching from HTTP to HTTPS using this service will be done by submitting just one command or pressing a button (cloud technologies ‚Äî automation to the masses). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It should be noted here that the most significant problems with the deployment of HTTPS, researchers consider the complexity, bureaucracy and cost of certificates required for HTTPS to work.  Many users have repeatedly encountered warnings and errors resulting from problems with certificates. <br><br>  The procedure for obtaining a certificate is bureaucratic, complicated and is the leading reason that websites continue to use HTTP instead of HTTPS. <br><br>  One of the goals of the Let's Encrypt project is to eliminate unnecessary links and automate the process, which, according to informal measurements by developers, will reduce the encryption setting time from 1-3 hours to 20-30 seconds. <br><br>  The project is based on a number of innovative approaches and technologies for managing secure automatic domain verification and issuing certificates.  For this purpose, it is planned to use the ACME protocol developed for these purposes between the web server and the CA.  Verification will, among other things, use the SSL Observatory (EFF), scans.io (MichU), Certificate Transparency (Google) services. <br><br>  For the operation of the new CA, a new non-profit organization Internet Security Research Group (ISRG) is being created. <br><br><h2>  How will this work? </h2><br>  Anyone who has configured HTTPS from scratch knows that obtaining a certificate is not the easiest procedure (going, for someone already worked out and quite understandable).  The creators of the project suggest <a href="https://habr.com/ru/post/244037/">[3]</a> that with the launch of the project it will be enough to execute a couple of commands: <br><br> <code>$ sudo apt-get install lets-encrypt</code> <br> <br> <code>$ lets-encrypt example.com</code> <br> <br>  Then <a href="https://example.com/">example.com</a> becomes available. <br><br>  The script (set of scripts) Let's Encrypt will do the following: <br><ul><li>  Automatically "prove" the server CA Let's Encrypt that you control the site (domain) </li><li>  Receive a certificate that will be trusted by browsers and installs it on your server, making the necessary configuration changes </li><li>  Will track the expiration time (expiration) of the certificate and request its renewal. </li><li>  Will help with the revocation of the certificate if necessary </li></ul><br>  All this - without confirmation by e-mail, editing configuration files, and for free. <br><br><h2>  What is under the hood? </h2><br>  For the operation of the system, an agent is implemented on your server that implements the ACME (Automatic Certificate Management Environment) protocol. <br><br> <a href=""><img src="https://habrastorage.org/files/e50/ba2/5c9/e50ba25c97c6416b9013f9c6ec0618cb.png" alt="http: //letsencrypt.org_challenge" width="300" height="71"></a> <br><br>  The process of proving domain ownership is as follows <a href="https://habr.com/ru/post/244037/">[4]</a> : <br><ol><li>  An agent on the server sends a request to Let's Encrypt CA with an indication of the domain that needs to be confirmed (example.com) </li><li>  The CA evaluates the domain and generates one or more challenge sets, the solution of which by the agent proves that the domain belongs.  Such tasks are divided into two types: <br><ul><li>  create DNS records for the subdomain example.com </li><li>  creating a resource accessible via HTTP at a known URI in <a href="http://example.com/">example.com</a> </li></ul><br></li><li>  In addition to domain validation tasks, a temporary attribute (data object) is generated, which the agent on the server signs with his private key to prove ownership of the attribute. </li><li>  The agent performs one of the sets of tasks and the signing of the attribute and notifies the CA that it is ready for verification. </li><li>  CA begins verification by verifying electronic digital signature (EDS) and the availability of files / subdomains </li><li>  If the EDS is correct and the problem is solved correctly, the CA considers that the agent identified by some public key is authorized to manage certificates for the example.com domain.  The key pair used by the agent becomes the "authorized key pair" for example.com. </li></ol><br>  After the agent is authorized, it can request, renew, or revoke certificates for its domain (s).  Relevant messages must be signed with an authorized key pair. <br><br> <a href=""><img src="https://habrastorage.org/files/df2/0eb/57d/df20eb57d5df46cb9b711e796bddeb92.png" alt="letsencrypt_authorization" width="300" height="165"></a> <br><br>  To obtain a certificate for the domain, the agent generates a Certificate Signing Request (CSR) PKCS # 10 with a request to Let's Encrypt CA to issue a certificate for example.com with the specified public key.  As usual, the CSR is signed by the private key corresponding to the public key in the request.  Additionally, the CSR is signed by an authorized domain key in order to confirm the CA legitimacy of the request. <br><br>  Upon receipt of the request, CA verifies both signatures.  If they are correct, it issues a certificate for example.com with the public key from the CSR and returns it to the agent. <br><br> <a href=""><img src="https://habrastorage.org/files/bc8/5fc/30d/bc85fc30de5a4b208f2d14866c6f789b.png" alt="http: //letsencrypt.org_certificate" width="300" height="129"></a> <br><br>  Other procedures (update, revocation) work in a similar way. <br><br><h2>  Learn a little more? </h2><br><h3>  Problem </h3><br>  The ACME protocol is discussed in detail in <a href="https://habr.com/ru/post/244037/">[5]</a> .  Certificates in X.509 PKI (Public Key Infrastructure, public key infrastructure) are used for various purposes, the most significant of which is domain name authentication.  Thus, the Certificate Authority (CA) PKI is ‚Äútrusted‚Äù to ensure that the certificate requester (applicant) party legitimately represents the domain names listed in the certificate.  Currently, verification is performed through a set of private indirect mechanisms.  The creators of ACME set out a way to interact directly and automatically verify and issue certificates. <br><br>  In established practice <a href="https://habr.com/ru/post/244037/">[5]</a> , obtaining a certificate consists of a series of mostly manual operations: <br><ul><li>  Generate PKCS request # 10 <a href="https://habr.com/ru/post/244037/">[6]</a> - CSR </li><li>  Copy-Paste CSR on CA page </li><li>  Prove domain ownership using one of the following methods: <br><ul><li>  Place the issued CA object (URI challenge) in the specified location on the server </li><li>  Place the line issued by CA (DNS challenge) in the specified DNS node corresponding to the confirmed domain </li><li>  Get a message from CA (email challenge) to a (theoretically) domain-controlled email address and enter the code on the CA page </li></ul><br></li><li>  Download the issued certificate and install it on the server. </li></ul><br>  The main idea for ACME was to obtain certificates for Web sites (HTTPS <a href="https://habr.com/ru/post/244037/">[7]</a> ).  In this case, each server is responsible for one or more domains, and the process (described above) is designed to verify this compliance. <br><br>  For various purposes it is possible to use different types of certificates <a href="https://habr.com/ru/post/244037/">[8]</a> : <br><ul><li>  Extended Validation (EV) - CA checks the applicability of the domain name and the characteristics of the organization (there are documents in order, the domain belongs to the organization, the organization requested the issuance of a certificate; more details in <a href="https://habr.com/ru/post/244037/">[9]</a> ) </li><li>  Organization Validation (OV) - CA verifies the legitimacy of the application of the domain name and the organization‚Äôs domain name </li><li>  Domain Validation (DV) - CA checks the applicability of the domain user‚Äôs use </li></ul><br>  Of these, DV is probably the most popular (here, the price, the minimum complexity and sufficiency are the main factors).  It is important that for confirmation at the DV level, all checks can be performed by the CA automatically, without operator intervention.  This is a key feature of the ACME solution ‚Äî issuing DV certificates comparable in complexity to issuing a self-signed certificate. <br><br><h3>  How is domain ownership confirmed? </h3><br>  To demonstrate that the server (applicant) is actually authorized to send messages on behalf of a certain domain, the ACME CA will request the solution of the following types of problem sets (this implies that the permission of example.com to the ‚Äúcontrollable‚Äù agent node must be via A or AAAA record): <br><ul><li>  Creating a domain in the DNS TXT-record type _acme-challenge.example.com.  containing some coolrandomealfanumerictoken issued by the server </li><li>  place the file so that it is available at the URI <a href="http://example.com/magnificientalfanumerictoken">example.com/magnificientalfanumerictoken</a> , GET by CA </li><li>  place the file so that it is accessible by the URI <a href="https://example.com/yetanothertoken">example.com/yetanothertoken</a> , for which the agent in a hurry raises the HTTPS;  GET verification from CA </li><li>  raise HTTPS (using self-signed certificate) and accept a TLS connection from CA.  The certificate is formed in this way.  to contain (in subjectAltName) the checked domain and the domain of the form &lt;Z&gt; .acme.invalid ", where Z = SHA-256 (R || S), (R is a random value reported by the server during the exchange process; S is a random value reported by customer) </li><li>  the list may be further expanded, for example, email, DNSSEC, WHOIS is planned </li></ul><br><br><h3>  How is the client-server exchange? </h3><br>  The client (agent) is exchanged with the ACME server (CA) using the HTTPS protocol with the exchange of <a title="Json" href="https://en.wikipedia.org/wiki/JSON">JSON</a> messages.  Each ACME message is a dictionary (dictionary), with a mandatory field of type (type), which determines the composition of the remaining fields of the message.  All messages are sent to the common HTTPS URI wired into the client.  The client, in general, behaves like a browser, sending requests by the POST method, following the redirects (statuses 301, 302).  Answers usually come with status 200, error information is encoded in JSON responses with the type ‚Äúerror‚Äù. <br><br>  The creators of the protocol, in my opinion, wisely foreseen the type of response "defer", which allows you to force the client to wait a specified time interval before re-request.  Since  the service is likely to be quite popular, then the opportunity to ask the client to wait if the server, for example, is overloaded and the request is queued, will allow the creators of Let's encrypt (and future services based on this protocol) to reduce infrastructure costs. <br><br>  When processing a CSR (sent as base-64 encoded; DER <a href="https://habr.com/ru/post/244037/">[10]</a> ), the server checks the validity of the fields before issuing the certificate.  It is assumed that the CA will discard the entity names (Subject Alt Name) from the certificate being issued, for which the requesting client (applicant) does not have authorization.  In response, the JSON containing the applicant's certificate includes the certificate itself (base-64 encoded; DER) and the chain of parent certificates in the form of the base64 array, DER, in the order required for the TLS handshake by <a href="https://habr.com/ru/post/244037/">[11]</a> , i.e.  so that the first certificate in the array confirms the certificate of the applicant, the second certificate of the array confirms the first certificate of the array (each subsequent certificate confirms the immediate predecessor; the root certificate may be discarded because it is assumed that it already exists on the client). <br><br><h2>  Show me your code! </h2><br><div class="spoiler">  <b class="spoiler_title">Disclaimer</b> <div class="spoiler_text">  (You need to note here, just in case, that the code is not mine, I'm just sympathetic) <br></div></div><br><br>  The client part is written in Python, there is a preview on GitHub: <a title="An ACME client that can update apache configurations (developer preview)" href="https://github.com/letsencrypt/lets-encrypt-preview">https://github.com/letsencrypt/lets-encrypt-preview</a> and he already knows how to configure Apache (there is a stub under nginx) <br><br>  The server part is written on JS, GitHub: <a title="Automated Certificate Management Environment (ACME)" href="https://github.com/letsencrypt/node-acme">https://github.com/letsencrypt/node-acme</a> <br><br>  In the <a title="lets-encrypt-preview wiki" href="https://github.com/letsencrypt/lets-encrypt-preview/wiki">project wiki,</a> you can find information on how to try all this on your server. <br><br><h2>  Sources and references </h2><br><ol><li><a name="ref_one"></a>  <a href="https://letsencrypt.org/">https://letsencrypt.org/</a> </li><li><a name="ref_two"></a>  <a href="https://www.eff.org/deeplinks/2014/11/certificate-authority-encrypt-entire-web">https://www.eff.org/deeplinks/2014/11/certificate-authority-encrypt-entire-web</a> </li><li><a name="ref_three"></a>  <a href="https://letsencrypt.org/howitworks/">https://letsencrypt.org/howitworks/</a> </li><li><a name="ref_four"></a>  <a href="https://letsencrypt.org/howitworks/technology/">letsencrypt.org/howitworks/technology</a> </li><li><a name="ref_five"></a>  <a href="">https://github.com/letsencrypt/acme-spec/blob/master/draft-barnes-acme.md</a> </li><li><a name="ref_six"></a>  <a href="http://www.ietf.org/rfc/rfc2314.txt">http://www.ietf.org/rfc/rfc2314.txt</a> </li><li><a name="ref_seven"></a>  <a href="http://tools.ietf.org/html/rfc2818">http://tools.ietf.org/html/rfc2818</a> </li><li><a name="ref_eight"></a><a name="ref_one"></a>  <a href="https://www.globalsign.com/ssl-information-center/types-of-ssl-certificate.html">https://www.globalsign.com/ssl-information-center/types-of-ssl-certificate.html</a> </li><li><a name="ref_nine"></a>  <a href="https://cabforum.org/ev-code-signing-certificate-guidelines/">https://cabforum.org/ev-code-signing-certificate-guidelines/</a> </li><li><a name="ref_ten"></a>  <a href="https://en.wikipedia.org/wiki/X.690">https://en.wikipedia.org/wiki/X.690#DER_encoding</a> </li><li><a name="ref_eleven"></a>  <a href="http://tools.ietf.org/html/rfc5246">http://tools.ietf.org/html/rfc5246</a> </li></ol><br>  Illustrations from <a href="https://letsencrypt.org/">letsencrypt.org</a> . </div><p>Source: <a href="https://habr.com/ru/post/244037/">https://habr.com/ru/post/244037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244027/index.html">We analyze the proxying methods based on HAProxy</a></li>
<li><a href="../244029/index.html">Corporate software: main trends and why they are important</a></li>
<li><a href="../244031/index.html">Protect .net applications from prying eyes</a></li>
<li><a href="../244033/index.html">HP 9830B Recovery</a></li>
<li><a href="../244035/index.html">Overview of Microsoft Azure platform updates for October-November</a></li>
<li><a href="../244039/index.html">DCLady 2014 Industry Competition</a></li>
<li><a href="../244041/index.html">Expressive JavaScript: Event handling</a></li>
<li><a href="../244047/index.html">Summary of course materials ICND1 100-101</a></li>
<li><a href="../244049/index.html">How to create your first e-course and make it sold</a></li>
<li><a href="../244051/index.html">Access certification: reduce risks, armed with relevant data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>