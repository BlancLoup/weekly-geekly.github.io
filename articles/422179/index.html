<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From clouds to earth: how to create a production-grade Kubernetes in any conditions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All good! Well, that time has come for our next Devops course . Probably, this is one of the most stable and standard courses, but at the same time it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From clouds to earth: how to create a production-grade Kubernetes in any conditions</h1><div class="post__text post__text-html js-mediator-article">  All good!  Well, that time has come for <a href="https://otus.pw/Zn7c/">our</a> next <a href="https://otus.pw/Zn7c/">Devops course</a> .  Probably, this is one of the most stable and standard courses, but at the same time it is the most diverse among students, since no group has yet looked like the other: in one developer, almost completely, then in the next engineers, then admins, and so on.  And it also means that the time has come for interesting and useful materials, as well as online meetings. <br><br><img src="https://habrastorage.org/webt/v-/xe/oi/v-xeoia0xxkvb6vuzmclcvknrys.png" alt="image"><a name="habracut"></a><br><br>  This article contains recommendations for launching the production-grade Kubernetes cluster in on-premise data center or peripheral locations (edge ‚Äã‚Äãlocation). <br>  What does production-grade mean? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Safe installation; </li><li>  Deployment is managed through a repetitive and recorded process; </li><li>  Work is predictable and consistent; </li><li>  It is safe to update and customize; </li><li>  To detect and diagnose errors and lack of resources, there is logging and monitoring; </li><li>  The service has sufficient ‚Äúhigh availability‚Äù given the available resources, including restrictions in money, physical space, power, and so on. </li><li>  The recovery process is available, documented and tested for use in case of failures. </li></ul><br>  In short, a production-grade means anticipating errors and preparing a recovery with a minimum of problems and delays. <br><br><img src="https://habrastorage.org/webt/ji/b8/je/jib8jeiekbsaflpgjsteescumgg.png"><br><br>  This article focuses on the on-premise deployment of Kubernetes on a hypervisor or bare-metal platform, given the limited amount of support resources in comparison with the increase in core public clouds.  Nevertheless, a part of these recommendations can be useful for a public cloud if the budget limits the selected resources. <br><br>  Deploying a single-metal bare-metal Minikube can be a simple and cheap process, but it is not a production-grade.  Conversely, you will not be able to reach the level of Google with Borg in an offline store, branch or peripheral location, although it is unlikely that you need it. <br><br>  This article outlines tips for achieving a production-level Kubernetes deployment, even in a resource limiting situation. <br><br>  <b>Important components in the Kubernetes cluster</b> <br><br>  Before delving into the details, it is important to understand the overall architecture of Kubernetes. <br>  The Kubernetes cluster is a highly distributed system based on the control plane and the architecture of the clustered worker node, as shown below: <br><br><img src="https://habrastorage.org/webt/_9/zu/xd/_9zuxdnulbsg6axshrcnxah2x_o.png"><br><br>  Typically, the components of the API Server, Controller Manager and Scheduler are located in several instances of the nodes of the control level (it is called the Master).  Master nodes typically also include etcd, however there are large and highly available scripts that require running etcd on independent hosts.  Components can be run as containers and, optionally, under the supervision of Kubernetes, that is, work as static pods. <br><br>  For high availability, redundant instances of these components are used.  Significance and required level of redundancy can vary. <br><table><tbody><tr><th>  <nobr>Component</nobr> </th><th>  Roles </th><th>  Consequences of loss </th><th>  Recommended Instances </th></tr><tr><td>  etcd </td><td>  Maintains the state of all Kubernetes objects </td><td>  Catastrophic loss of storage.  Most of the loss = Kubernetes loses control level, API Server depends on etcd, read-only API calls that do not need quorum, as well as already created workloads, can continue to work. </td><td>  odd number, 3+ </td></tr><tr><td>  API Server </td><td>  Provides API for external and internal use. </td><td>  It is impossible to stop, start, update new scams.  Scheduler and Controller Manager depend on API Server.  Loads continue if they are independent of API calls (operators, custom controllers, CRD, etc.) </td><td>  2+ </td></tr><tr><td>  kube-scheduler </td><td>  Places pods on nodes </td><td>  Pods cannot be placed, prioritized and moved between them. </td><td>  2+ </td></tr><tr><td>  kube-controller-manager </td><td>  Controls many controllers </td><td>  The main control loops responsible for the state stop working.  Integration of in-tree cloud provider is breaking. </td><td>  2+ </td></tr><tr><td>  cloud-controller-manager (CCM) </td><td>  Out-of-tree integration of cloud providers </td><td>  Integration of cloud provider breaks down </td><td>  one </td></tr><tr><td>  Additions (for example, DNS) </td><td>  Various </td><td>  Various </td><td>  Depends on the add-on (for example, 2+ for DNS) </td></tr></tbody></table><br>  The risks of these components include hardware failures, software bugs, bad updates, human errors, network interruptions, and system overload leading to resource depletion.  Excessiveness can reduce the impact of these hazards.  In addition, thanks to the functions of the hypervisor platform (resource planning, high availability), you can multiply the results using the Linux operating system, Kubernetes, and container runtime. <br><br>  The API Server uses multiple load balancer instances to achieve scalability and availability.  Load balancer is an important component for high availability.  Several A-records of the DNS API server can serve as an alternative in the absence of a balancer. <br><br>  The kube-scheduler and kube-controller-manager participate in the process of choosing a leader instead of using a load balancer.  Since <a href="https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/">cloud-controller-manager is</a> used for certain types of hosting infrastructure, the implementation of which may vary, we will not discuss them - just let us indicate that they are a component of the control layer. <br><br>  Pods running on the Kubernetes worker are managed by a kubelet agent.  Each worker instance runs a kubelet-agent and a <a href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">CRI-</a> compatible container launch environment.  Kubernetes itself is designed to monitor and recover from a crash node.  But for critical load functions, managing hypervisor resources and isolating loads, it can be used to improve availability and increase the predictability of their work. <br><br>  <b>etcd</b> <br><br>  etcd is the persistent storage for all Kubernetes objects.  The availability and recoverability of the etcd cluster should be a priority when deploying a production-grade Kubernetes. <br><br>  An etcd cluster of five nodes is the best option if you can enable it.  Why?  Because you will be able to maintain one, and still endure failure.  A cluster of three nodes is the minimum that we can recommend for a production-grade service, even if only one host hypervisor is available.  More than seven nodes are also not recommended, with the exception of <a href="https://monzo.com/blog/2017/11/29/very-robust-etcd/">very large installations</a> covering several availability zones. <br><br>  The minimum recommendations for hosting nodes etcd cluster - 2GB RAM and 8GB SSD hard drive.  Usually, 8GB of RAM and 20GB of hard disk space is sufficient.  Disk performance affects the recovery time of the node after a failure.  <a href="https://coreos.com/etcd/docs/latest/op-guide/hardware.html">Check</a> out to find out details. <br><br>  <i>In special cases, think about a few etcd clusters.</i> <br><br>  For very large Kubernetes clusters, consider using a separate etcd cluster for Kubernetes events, so that too many events do not affect the main Kubernetes API service.  When using the Flannel network, the configuration is saved in etcd, and the version requirements may differ from Kubernetes.  This can make it difficult to back up etcd, so we recommend using a separate etcd cluster specifically for the flannel. <br><br>  <b>Single Host Deployment</b> <br><br>  The list of accessibility risks includes hardware, software, and human factors.  If you are limited to a single host, the use of redundant storage, error-correcting memory, and dual power supplies can improve security against hardware failures.  Running a hypervisor on a physical host allows you to use redundant software components and adds operational benefits associated with deploying, updating, and controlling resource utilization.  Even in stressful situations, the behavior remains repeatable and predictable.  For example, even if you can only afford to launch singletones from master services, they should be protected from overload and resource depletion, competing with the workload of your application.  A hypervisor can be more efficient and easier to use than setting priorities in the Linux scheduler, cgroups, Kubernetes flags, etc. <br><br>  You can deploy three etc etc virtual machines if resources allow on the host.  Each of the VMs must be supported by a separate physical storage device or use separate parts of the storage using redundancy (mirroring, RAID, etc.). <br>  Dual redundant instances of the server API, scheduler, and controller manager are the next upgrade, if your only host has enough resources for this. <br><br>  <i>Single host deployment options, from least suitable for production to most</i> <br><table><tbody><tr><th>  Type of </th><th>  Specifications </th><th>  Result </th></tr><tr><td>  <nobr>Minimum equipment</nobr> </td><td>  Singleton etcd and master components. </td><td>  Home laboratory, not at all production-grade.  Several single points of failure (Single Point of Failure, SPOF).  Recovery is slow, and with the loss of storage is completely absent. </td></tr><tr><td>  Improved storage redundancy </td><td>  etcd singleton and master components, etcd storage is redundant. </td><td>  At a minimum, you can recover from a storage failure. </td></tr><tr><td>  Managed level redundancy </td><td>  No hypervisor, multiple instances of managed-level components in static hearths. </td><td>  There was protection against software bugs, but the OS and container launch environment are still single points of failure with devastating updates. </td></tr><tr><td>  Adding Hypervisor </td><td>  Run three redundant managed level instances in the VM. </td><td>  There was protection against software bugs and human error and an operational advantage in installation, resource management, monitoring and security.  OS upgrades and container launch environments are less destructive.  The hypervisor is the only single point of failure. </td></tr></tbody></table><br>  <b>Deploy to two hosts</b> <br><br>  With two hosts, storage problems etcd are similar to the single-host option ‚Äî you need redundancy.  It is preferable to run three encd instances.  It may seem non-intuitive, but it is better to concentrate all etcd nodes on the same host.  You do not increase reliability by dividing them by 2 + 1 between two hosts - losing nodes with most encd instances leads to interruption, regardless of whether they are 2 or 3. If the hosts are not identical, place the etcd cluster entirely on the more reliable one. <br><br>  It is recommended to launch redundant API servers, kube-schedulers and kube-controller-managers.  They should be shared between hosts to minimize the risk of failure of the container launch environment, operating system, and equipment. <br><br>  Running a hypervisor layer on physical hosts will allow you to work with redundant program components, ensuring control of resource consumption.  It also has the operational advantage of scheduled maintenance. <br><br>  <i>Deployment options for two hosts, from the least suitable for production to the most</i> <br><table><tbody><tr><th>  Type of </th><th>  Specifications </th><th>  Result </th></tr><tr><td>  <nobr>Minimum equipment</nobr> </td><td>  Two hosts, without redundant storage.  Singleton etcd and master components on the same host. </td><td>  etcd - a single point of failure, it makes no sense to run two on other master services.  The separation between two hosts increases the risk of a managed level of failure.  The potential advantage of resource isolation is by running a managed layer on one host and application workloads on another.  If the storage is lost, there is no recovery. </td></tr><tr><td>  Improved storage redundancy </td><td>  Singleton etcd and master components on the same host, etcd storage is redundant. </td><td>  At a minimum, you can recover from a storage failure. </td></tr><tr><td>  Managed level redundancy </td><td>  No hypervisor, multiple instances of managed-level components in static hearths.  etcd cluster on the same host, the other components of the managed level are separated. </td><td>  Hardware failure, firmware upgrades, operating systems, and container launch environments on a host without etcd are less destructive. </td></tr><tr><td>  Adding a hypervisor to both hosts </td><td>  The virtual machines run three redundant components of the managed level, etcd cluster on the same host, the components of the managed level are separated.  Application workloads can reside on both VM nodes. </td><td>  Improved isolation of application loads.  Updates of the operating system and container launch environments are less destructive.  Routine hardware / firmware maintenance becomes non-destructive if the hypervisor supports VM migration. </td></tr></tbody></table><br>  <b>Deploy to three (or more) hosts</b> <br><br>  Transition to uncompromising production-grade service.  We recommend dividing etcd between the three hosts.  One equipment failure will reduce the amount of possible application workloads, but will not result in a complete service outage. <br><br>  Very large clusters will require more instances. <br><br>  Launching a hypervisor layer provides operational advantages and improved isolation of application workloads.  This is beyond the scope of the article, but at the level of three or more hosts, improved features may be available (clustered redundant shared storage, resource management with a dynamic load balancer, automated state monitoring with live migration and failover). <br><br>  <i>Deployment options for three (or more) hosts from the least suitable for production to the most</i> <br><table><tbody><tr><th>  Type of </th><th>  Specifications </th><th>  Result </th></tr><tr><td>  <nobr>Minimum</nobr> </td><td>  Three hosts.  Etcdd on each node  Master components on each node. </td><td> Loss of a node reduces performance, but does not lead to a drop in Kubernetes.  The possibility of recovery remains. </td></tr><tr><td>  Add hypervisor to hosts </td><td>  In virtual machines on three hosts running etcd, API server, schedulers, controller manager.  Workloads are running on the VM on each host. </td><td>  Added protection against OS / environment of container / software launch and human error.  Operational benefits of installation, upgrades, resource management, monitoring, and security. </td></tr></tbody></table><br>  <b>Configure Kubernetes configuration</b> <br><br>  Master and Worker nodes must be protected from overload and resource depletion.  Hypervisor functions can be used to isolate critical components and reserve resources.  There are also Kubernetes configuration settings that can slow things like API speed.  Some installation kits and commercial distributions take care of this, but if you are self-deploying Kubernetes, the default settings may not be appropriate, especially for small resources or a cluster that is too large. <br><br>  The consumption of resources at a managed level correlates with the number of hearths and the outflow rate of hearths.  Very large and very small clusters will benefit from the modified <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">settings for</a> slowing down kube-apiserver requests and memory. <br><br>  <a href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/">Node</a> Allocatable must be configured on the nodes of the worker based on a reasonable supported load density on each node.  Namespaces can be created to divide the cluster of the worker node into several virtual clusters with <a href="https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/">quotas</a> for CPU and memory. <br><br>  <b>Security</b> <br><br>  Each Kubernetes cluster has a root Certificate Authority (CA).  The Controller Manager, API Server, Scheduler, kubelet client, kube-proxy and administrator certificates must be generated and installed.  If you use the tool or distribution kit of installation, then probably you should not deal with it independently.  The manual process is described <a href="">here</a> .  You should be ready to reinstall certificates in case of expansion or replacement of nodes. <br><br>  Since Kubernetes is fully managed by the API, it is extremely important to control and limit the list of those who have access to the cluster.  Encryption and authentication options are discussed in this documentation. <br><br>  Kubernetes application workloads are based on container images.  You need the source and contents of these images to be reliable.  Almost always this means that you will host the container image in the local repository.  Using images from the public Internet can cause problems of reliability and security.  You must select a repository that has support for image signing, security scanning, access control for sending and downloading images, and activity logging. <br><br>  Processes must be configured to support the application of host firmware updates, hypervisor, OS6, Kubernetes, and other dependencies.  Versioning is required to support auditing. <br><br>  Recommendations: <br><br><ul><li>  Strengthen the default security settings for components of the managed level (for example, <a href="http://blog.kontena.io/locking-down-kubernetes-workers/">blocking a worker node</a> ); </li><li>  Use <a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/">the Podov Security Policy</a> ; </li><li>  Consider the integration of <a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">NetworkPolicy</a> available for your network solution, including tracking, monitoring, and troubleshooting; </li><li>  Use RBAC to make authorization decisions; </li><li>  Consider physical security, especially when deployed in peripheral or remote locations that may be left unattended.  Add storage encryption to limit the effects of device theft, and protect against the connection of malicious devices, such as USB keys; </li><li>  Protect the text credentials of the cloud provider (access keys, tokens, passwords, etc.). </li></ul><br>  Kubernetes <a href="https://kubernetes.io/docs/concepts/configuration/secret/">secret</a> objects are suitable for storing small amounts of sensitive data.  They are stored in etcd.  They can be safely used to store the Kubernetes API credentials, but there are times when a more comprehensive solution is required for the workload or expansion of the cluster itself.  The HashiCorp Vault project is a popular solution if you need more than the built-in secret objects can provide. <br><br>  <b>Disaster Recovery and Backup</b> <br><br><img src="https://habrastorage.org/webt/gv/xp/kd/gvxpkd1qgpap0wosdhv-r4uu-9s.png"><br><br>  Implementing redundancy through the use of multiple hosts and VMs helps reduce the number of certain types of failures.  But scenarios such as a natural disaster, a bad update, a hacker attack, software bugs, or a human error can still turn into crashes. <br><br>  A crucial part of the production deployment is waiting for the need for future recovery. <br><br>  It is also worth noting that part of your investment in the design, documentation, and automation of the recovery process can be reused if large-scale replicated multi-site deployments are required. <br><br>  Among the elements of disaster recovery, it is worth noting backups (and possibly replicas), replacements, a planned process, people who will perform this process, and regular training.  Frequent test exercises and principles of <a href="https://github.com/dastergon/awesome-chaos-engineering">Chaos Engineering</a> can be used to test your readiness. <br><br>  Due to availability requirements, it may be necessary to store local copies of the OS, Kubernetes components, and container images to allow recovery even if the Internet fails.  The ability to deploy replacement hosts and nodes in a ‚Äúphysical isolation‚Äù situation improves security and increases deployment speed. <br><br>  All Kubernetes objects are stored in etcd.  Periodic backup of data of an etcd-cluster is an important element in restoring Kubernetes clusters under abnormal scenarios, for example, if all master nodes are lost. <br><br>  Cluster etcd can be backed up using the snapshot mechanism <a href="https://coreos.com/etcd/docs/latest/op-guide/recovery.html">built</a> into etcd and copying the result to storage to another failure domain.  Snapshot files contain all Kubernetes states and critical information.  Encrypt snapshot files to protect sensitive Kubernetes data. <br><br>  Keep in mind that some Kubernetes extensions can store states in separate etcd clusters, persistent volumes or some other mechanism.  If these conditions are critical, they should have a backup and recovery plan. <br><br>  But some important states are stored outside etcd.  Certificates, container images, other settings and states associated with operations can be controlled by an automatic install / update tool.  Even if these files can be regenerated again, a backup or replica will speed up disaster recovery.  Consider the need for a backup and recovery plan for the following objects: <br><br><ul><li>  Certificate and key pairs: CA, API Server, Apiserver-kubelet-client, ServiceAccount authentication, ‚ÄúFront proxy‚Äù, Front proxy client; </li><li>  Important DNS records; </li><li>  Assign and reserve IP / Subnet; </li><li>  External load balancer; </li><li>  Kubeconfig files; </li><li>  LDAP and other authentication details; </li><li>  The account and configuration data of the cloud provider. </li></ul><br>  <b>Load offerings</b> <br><br>  Anti-affinity specifications can be used to split clustered services between backup hosts.  But in this case, the settings are used only if it is scheduled.  This means that Kubernetes can restart the failed node of your clustered application, but does not have a built-in mechanism for rebalancing after a failure.  This topic deserves a separate article, but additional logic can be useful for achieving optimal placement of workloads after a host or a worker node is restored or expanded.  <a href="https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/">The Prioritization and Crowd Out function</a> can be used to select the desired sorting in case of a shortage of resources caused by a failure. <br><br>  In the case of stateful services, external mounted volumes are the Kubernetes recommendation standard for nonclustered services (for example, for a typical SQL database).  Currently, external volume snapshots managed by Kubernetes are in the <a href="https://docs.google.com/presentation/d/1dgxfnroRAu0aF67s-_bmeWpkM1h2LCxe6lB1l1oS0EQ/edit">roadmap feature request</a> category, and are most likely related to the integration of the Container Storage Interface (CSI).  Thus, the creation of backup copies of such a service will require in-box actions depending on the specific application, which is beyond the scope of this article.  Therefore, while we are waiting for the improvement of Kubernetes support for workflow snapshots and backup, it is worth thinking about starting the database service not in a container, but in a virtual machine, and opening it to Kubernetes loads. <br><br>  Clustered stateful services (for example, Cassandra) can take advantage of the separation between hosts using local persistent volumes, if resources permit.  This will require deploying multiple Kubernetes work nodes (there may be VMs on hypervisor hosts) to maintain a quorum at the point of failure. <br><br>  <b>Other offers</b> <br><br>  <a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/">Logs</a> and <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/resource-usage-monitoring/">metrics</a> (if you collect and store them) are useful for diagnosing failures, but given the variety of available technologies, we will not consider them in this article.  If you have an Internet connection, it is advisable to keep logs and metrics outside, centrally. <br><br>  In a production deployment, automated installation, configuration, and upgrade tools should be used (for example, <a href="https://github.com/kubernetes-incubator/kubespray">Ansible</a> , <a href="https://github.com/cloudfoundry-incubator/kubo-deployment">BOSH</a> , <a href="https://github.com/chef-cookbooks/kubernetes">Chef</a> , <a href="https://kubernetes.io/docs/getting-started-guides/ubuntu/installation/">Juju</a> , <a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">kubeadm</a> , <a href="https://forge.puppet.com/puppetlabs/kubernetes">Puppet</a> , etc.).  The manual process is too laborious and difficult to scale, it is easy to make mistakes and run into problems of repeatability.  <a href="https://www.cncf.io/certification/software-conformance/">Certified distributions</a> are likely to include a means to save the settings when upgrading, but if you use your own toolchain for installation and configuration, storing, backing up and restoring configuration artifacts is of paramount importance.  It is worth thinking about using a version control system, like Git, to store components and deployment settings. <br><br>  <b>Recovery</b> <br><br>  <a href="https://en.wikipedia.org/wiki/Runbook">Ranbuki</a> , in which recovery processes are documented, should be tested and saved offline - perhaps even printed.  When an employee is called at 2 am on Fridays, improvisation is not the best option.  It is better to complete all the items from the planned and tested checklist - which is accessible both to the employees in the office and to the remote ones. <br><br>  <b>Final thoughts</b> <br><br><img src="https://habrastorage.org/webt/a5/m-/gx/a5m-gxsrhmwpyxxwmcfsnfc8umm.png"><br><br>  Buying a commercial airline ticket is a simple and safe process.  But if you are flying to a remote place with a short runway, a commercial flight on an Airbus A320 is not an option.  This does not mean that airfare should not be considered at all.  It only means that compromises are necessary. <br><br>  In the context of aviation, engine failure in a single-engine vessel means a crash.  With two engines, at a minimum, there will be more opportunities to decide where the crash will occur.  Kubernetes on a small number of hosts is similar, and if your business case justifies, you should think about increasing the fleet, consisting of large and small machines (for example, FedEx, Amazon). <br><br>  When designing Kubernetes production-grade solutions, you have many options and options.  A simple article can not give all the answers and has no idea about your priorities.  Nevertheless, we hope that she provided a list of things to think about, as well as some useful recommendations.  There are options that have not been reviewed (for example, launching Kubernetes components using <a href="">self-hosting</a> , rather than static pods).  Perhaps they should be discussed in the following articles, if there is enough interest.  In addition, due to the high rate of improvement of Kubernetes, if your search engine found this article after 2019, some of its materials might already be outdated. <br><br>  THE END <br><br>  As always, we are waiting for your questions and comments here, and you can go to the <a href="https://otus.pw/6rWG/">Open Day</a> to <a href="https://otus.pw/SzcE/">Alexander Titov</a> . </div><p>Source: <a href="https://habr.com/ru/post/422179/">https://habr.com/ru/post/422179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422169/index.html">What did the Ada Lovelace program actually do?</a></li>
<li><a href="../422171/index.html">As I did the line-interactive UPS. Part 3</a></li>
<li><a href="../422173/index.html">Machine learning is increasingly used in particle physics.</a></li>
<li><a href="../422175/index.html">Environmental pollution reduces human cognitive abilities</a></li>
<li><a href="../422177/index.html">Why the Arduino is so slow and what can be done about it</a></li>
<li><a href="../422181/index.html">How to collect corporate services on one online platform: the story of MegaFon.Business</a></li>
<li><a href="../422183/index.html">And what could have been cheaper?</a></li>
<li><a href="../422185/index.html">How much data for learning model (not) similar to the test sample?</a></li>
<li><a href="../422187/index.html">Sberseasons: how I spent this summer</a></li>
<li><a href="../422189/index.html">The truth about introducing an intranet portal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>