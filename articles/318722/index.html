<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Routing orthogonal connections in chart editors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Routing orthogonal connections in chart editors 


 In this article, I will show how to solve the problem of routing connections in an MS Visio type d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Routing orthogonal connections in chart editors</h1><div class="post__text post__text-html js-mediator-article"><h1 id="marshrutizaciya-ortogonalnyh-soedineniy-v-redaktorah-diagramm">  Routing orthogonal connections in chart editors </h1><br><p>  In this article, I will show how to solve the problem of routing connections in an MS Visio type diagram editor.  There will be a minimum of theory and a maximum of practice.  If you need to quickly implement connection routing in a two-dimensional scene, and the first time you encounter a similar problem, then this article is for you. </p><br><p><img src="https://habrastorage.org/webt/_f/p5/ts/_fp5tsk0kyfgtl7tdssicgmljoq.png"></p><br><h2 id="problematika">  Problematics </h2><br><p>  I came to this problem in the process of developing my <a href="http://ultraoutliner.com/">ultra_outliner</a> hobby project.  Roughly speaking, it has a two-dimensional scene, in which there are many rectangular cards that can be linked.  And there can be quite a few connections - which means they need to be routed so that the segments do not overlap, do not cross the cards, etc. </p><br><p>  Many of you worked with Microsoft Visio, and of course appreciated how beautifully the arrows are routed automatically.  Of course, Visio does not always cope, and for such cases there is the possibility of manual adjustment.  But nevertheless, without considering extreme situations - I wanted to repeat this.  Indeed, after all, there all these problems are solved quite well. </p><br><a name="habracut"></a><br><p>  At first, I decided that this problem was solved long ago, and there are many libraries to choose from.  Unfortunately, I was fundamentally wrong.  There are libraries, but I liked less or less only one <a href="http://www.adaptagrams.org/documentation/libavoid.html">libavoid</a> , despite the fact that half of the possibilities are in the experimental stage and are not very stable.  Nevertheless, its author has several scientific publications on the subject of routing connections, and on the library website you can find links to scientific articles on which you can quite well master the issues. </p><br><h2 id="sobstvennaya-realizaciya">  Own implementation </h2><br><p>  Having learned enough theory, I could not deprive myself of pleasure and write the implementation myself.  Both coordinate axes are divided into discrete segments.  The points of division are determined by the orthogonal projections of the boundaries of the objects (cards), and with this, an additional partition is made with the selected step.  Thus, we get an irregular grid, the nodes of which can be routed connections. </p><br><p>  Further, in the simplest case, we iterate over the connections one by one, and using the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">Dijkstra algorithm</a> , we construct connections one by one.  From the cards we build an obstacle map, and in the heuristic function we add penalties for crossing the connections.  Also prohibiting the two compounds to have common matching segments (overlapping along). </p><br><p>  The implementation, of course, worked, but because of the uneven splitting of the axes in some places, ladders turned out.  Moreover, in a couple of days I certainly cannot achieve the results that the author of <a href="http://www.adaptagrams.org/documentation/libavoid.html">libavoid</a> has achieved over the years.  Therefore, having played enough, I decided to use libavoid, having entered into contact with the author in order to configure it for stable work. </p><br><h2 id="razrabotka-programmnogo-interfeysa">  Software interface development </h2><br><p>  I didn‚Äôt like the prospect of working with libavoid in its pure form in its upper layer code, since  The API is specific and you need to keep track of where and when to clear the memory.  And besides callback'i go on the global function.  Therefore, it was decided to make a wrapper that will follow all this. </p><br><p>  Actually, let's start with the inclusion of the header file: </p><br><pre><code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;libavoid/libavoid.h&gt;</span></span></span></span></code> </pre> <br><p>  The wrapper model is represented as a directed graph, where there are nodes and edges.  The node is rectangular.  Thus, the router class has the following interface: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> edge_router { public: //          node_t * create_node(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rect_t</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rect</span></span></span><span class="hljs-class">); //    void set_node_rect(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pnode</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rect_t</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rect</span></span></span><span class="hljs-class">); //     edge_t * create_edge(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">src</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dest</span></span></span><span class="hljs-class">) //  void remove_edge(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edge_t</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p_edge</span></span></span><span class="hljs-class">); //  void remove_node(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p_node</span></span></span><span class="hljs-class">); // void reroute(); private: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Avoid</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Router</span></span></span><span class="hljs-class"> aRouter; std::vector&lt;node_t*&gt; nodes; std::vector&lt;edge_t*&gt; edges; delegate_t * pDelegate; };</span></span></code> </pre> <br><p>  In the node description, apart from the helper methods, we will make a pointer to the libavoid-node: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> {</span></span> ... Avoid::ShapeRef * aNode; };</code> </pre> <br><p>  And in the edge we will make a pointer to the libavoid-connection, and why edge_router is needed here, it will be clear later: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edge_t</span></span></span><span class="hljs-class"> {</span></span> ... edge_satelite data; edge_router * pRouter; Avoid::ConnRef * aEdge; };</code> </pre> <br><p>  In edge_satelite, we will store information for a callback, which, as a rule, will be a pointer to a graphic edge (i.e., a connection object on the top layer of our implementation).  Therefore, for universality, you can make it generally in the template (and accordingly make such an edit in the edge_router).  Then, to handle edge geometry change events, we describe the delegate_t interface: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> E&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">router_delegate</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> edge_satelite = E; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edge_updated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(edge_satelite, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pos_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Now there is enough wrapper interface to cope with our initial task.  All interaction with libavoid (or with its own implementation) will remain inside it.  Next, consider the implementation of the described methods. </p><br><h2 id="realizaciya-sloya-marshrutizacii">  Routing layer implementation </h2><br><p>  We start with the libavoid configuration, which allows using only stable parts of it, and for which we had to write to the developer due to the lack of sufficient examples in the documentation.  All configuration is done in the constructor: </p><br><pre> <code class="hljs ruby">edge_router::edge_router() <span class="hljs-symbol"><span class="hljs-symbol">:aRouter</span></span>(Avoid::OrthogonalRouting) /<span class="hljs-regexp"><span class="hljs-regexp">/  { aRouter.setRoutingPenalty(Avoid::segmentPenalty, 50); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  """ aRouter.setRoutingPenalty(Avoid::shapeBufferDistance, 20); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ""    aRouter.setRoutingPenalty(Avoid::idealNudgingDistance, 20); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      aRouter.setRoutingOption(Avoid::RoutingOption::nudgeOrthogonalSegmentsConnectedToShapes, true); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   }</span></span></code> </pre> <br><p>  Next, create / delete nodes: </p><br><pre> <code class="hljs php">node_t * edge_router::create_node(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rect_t &amp; rect = rect_t(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) { node_t * new_node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> node_t; Avoid::Rectangle shapeRect(Avoid::Point(rect.x, rect.y), Avoid::Point(rect.x + rect.w, rect.y + rect.h)); new_node-&gt;aNode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Avoid::ShapeRef(&amp;aRouter, shapeRect); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Avoid::ShapeConnectionPin(new_node-&gt;aNode, <span class="hljs-number"><span class="hljs-number">1</span></span>, Avoid::ATTACH_POS_CENTRE, Avoid::ATTACH_POS_CENTRE, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, Avoid::ConnDirNone); nodes.push_back(new_node); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_node; } void edge_router::remove_node(node_t * p_node) { auto it = std::find(nodes.begin(), nodes.end(), p_node); nodes.erase(it); aRouter.deleteShape(p_node-&gt;aNode); }</code> </pre> <br><p>  Those.  create a rectangular shape with an anchor point in the center.  Immediately I warn you - if you make several anchor points - incomprehensible brakes begin, so it is better to do one point, and spread the boundary points of the connections to the border (due to nudge).  A change in node geometry (including simple movement) that leads to rerouting is described by: </p><br><pre> <code class="hljs php">void edge_router::set_node_rect(node_t * pnode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rect_t &amp; rect) { aRouter.moveShape(pnode-&gt;aNode, Avoid::Rectangle(Avoid::Point(rect.x, rect.y), Avoid::Point(rect.x + rect.w, rect.y + rect.h))); }</code> </pre> <br><p>  With compounds approximately the same: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">edge_t</span></span> * edge_router::create_edge(<span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span> * src, <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span> * dest) { <span class="hljs-keyword"><span class="hljs-keyword">edge_t</span></span> * new_edge = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">edge_t</span></span>; new_edge-&gt;pRouter = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   callback'a edges.push_back(new_edge); Avoid::ConnEnd dstEnd(src-&gt;aNode, 1); Avoid::ConnEnd srcEnd(dest-&gt;aNode, 1); new_edge-&gt;aEdge = new Avoid::ConnRef(&amp;aRouter, srcEnd, dstEnd); new_edge-&gt;aEdge-&gt;setCallback(libavoid_conn_callback&lt;E&gt;, new_edge); return new_edge; } void edge_router::remove_edge(edge_t * p_edge) { auto it = std::find(edges.begin(), edges.end(), p_edge); edges.erase(it); aRouter.deleteConnector(p_edge-&gt;aEdge); }</span></span></code> </pre> <br><p>  That's just with the exception that you need to give a link to the callback, which will be called after routing, in case the connection has changed the geometry.  It's time to deal with him: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> E&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">libavoid_conn_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">edge_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> edge_router&lt;E&gt;::<span class="hljs-keyword"><span class="hljs-keyword">edge_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> edge = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">edge_t</span></span>*&gt;(ptr); <span class="hljs-comment"><span class="hljs-comment">//   auto &amp; route = edge-&gt;aEdge-&gt;displayRoute(); //    std::vector&lt;pos_t&gt; path; for (size_t i = 0; i &lt; route.ps.size(); ++i) path.push_back(pos_t(route.ps[i].x, route.ps[i].y)); //        .           ,     . ... //    -     ,   callback edge-&gt;pRouter-&gt;pDelegate-&gt;edge_updated(edge-&gt;data, path); }</span></span></code> </pre> <br><p>  And finally, the routing call itself: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> edge_router::reroute() { aRouter.processTransaction(); }</code> </pre> <br><p>  Now consider the implementation of the scene itself using this result. </p><br><h2 id="realizaciya-verhnego-sloya-graficheskoy-sceny">  Implement the top layer of the graphic scene </h2><br><p>  The described implementation was implemented using <a href="https://www.qt.io/">QT</a> over the base class of a two-dimensional QGraphicsScene scene.  At the scene we will create an interface for creating nodes, creating connections, moving and deleting them: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">diagram_scene</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QGraphicsScene, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> router_delegate&lt;routable_link_image*&gt; { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span> = edge_router&lt;routable_link_image*&gt;; diagram_scene(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(movable_image * img)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(movable_image * img)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">routable_link_image * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_connection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(movable_image * src, movable_image * dst)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_connection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(connector_image * conn)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span> edgeRouter; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;movable_image*, <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span>*&gt; routableNodes; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;movable_image*&gt; nodes; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;routable_link_image*&gt; edges; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> enableRouting; };</code> </pre> <br><p>  Putting the scene in the constructor as a recipient of callbacks: </p><br><pre> <code class="hljs kotlin">diagram_scene::diagram_scene() { edgeRouter.pDelegate = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Adding the item to be connected to the scene (movable_image inherited from QGraphicsItem) must be followed by adding it to QGraphicsScene with the appropriate wrapper call: </p><br><pre> <code class="hljs php">void diagram_scene::add_image(movable_image * img) { addItem(img); nodes.push_back(img); routableNodes.insert(make_pair(img, edgeRouter.create_node(to_rect(img-&gt;sceneBoundingRect())))); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Removal will be quite symmetrical: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> diagram_scene::remove_image(movable_image * img) { removeItem(img); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find(nodes.begin(), nodes.end(), img); nodes.erase(it); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rit = routableNodes.find(img); edgeRouter.remove_node(rit-&gt;second); <span class="hljs-comment"><span class="hljs-comment">//   routableNodes.erase(rit); }</span></span></code> </pre> <br><p>  A similar implementation for connections, where routable_link_image is a successor from QGraphicsPathItem, i.e.  connection graphic object: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">routable_link_image</span></span> * diagram_scene::create_connection(movable_image * src, movable_image * dst) { auto new_img = new routable_link_image(pConfig, src, dst); auto src_it = routableNodes.find(src), dst_it = routableNodes.find(dst); new_img-&gt;routerEdge = edgeRouter.create_edge(src_it-&gt;second, dst_it-&gt;second); //   new_img-&gt;routerEdge-&gt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = new_img; addItem(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_img</span></span></span><span class="hljs-class">); //   edges.push_back(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_img</span></span></span><span class="hljs-class">); return new_img; } void diagram_scene::remove_connection(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connector_image</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conn</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edges</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">begin</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edges</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conn</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edgeRouter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove_edge</span></span></span><span class="hljs-class">((*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">)-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">routerEdge</span></span></span><span class="hljs-class">); //   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">edges</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">erase</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">); }</span></span></code> </pre><br><p>  And finally, we will do the rebuilding of the connection when we call the callback. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> diagram_scene::edge_updated(routable_link_image * img, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">pos_t</span></span>&gt; &amp; path) { img-&gt;rebuild(path); <span class="hljs-comment"><span class="hljs-comment">//  ,   QGraphicsItem }</span></span></code> </pre> <br><p>  Is done.  Now we need to deal with the call routing. </p><br><h2 id="vyzov-marshrutizacii">  Call routing </h2><br><p>  As a rule, wherever search algorithms on graphs are involved, calculations require quite a lot of resources, and here is no exception.  Any rebuild routing in the Debug build will take a few seconds (although it flies in Release).  Therefore, it is necessary to minimize the corresponding challenges. </p><br><p>  Therefore, it makes sense to call routing: </p><br><ul><li>  When adding new nodes </li><li>  When moving nodes </li><li>  When removing nodes </li></ul><br><p>  Moreover, sometimes it is necessary to do several actions within one logical transaction, and to perform routing only at the end.  To do this, we implement some kind of recursive mutex.  We enter in diagram_scene an attribute with the initial value true: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> enableRouting;</code> </pre> <br><p>  The routing call will also be made from diagram_scene: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> diagram_scene::reroute() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enableRouting) edgeRouter.reroute(); }</code> </pre> <br><p>  But to ensure the so-called transactions, we introduce, by analogy with std :: lock_guard, our structure: </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">routing_guard</span></span></span></span> { routing_guard(diagram_scene * obj) :pObject(obj), baseVal(pObject-&gt;enableRouting) { pObject-&gt;enableRouting = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ~routing_guard() { pObject-&gt;enableRouting = baseVal; pObject-&gt;reroute(); } diagram_scene * pObject; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> baseVal; };</code> </pre> <br><p>  And you can use as follows: </p><br><pre> <code class="hljs cs">{ <span class="hljs-function"><span class="hljs-function">routing_guard </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pScene</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ... } //   </span></span></code> </pre><br><p>  You can create multiple routing_guard in a row, and routing will be called after the destruction of the latter. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  See how it works in practice in the prototype <a href="http://ultraoutliner.com/">ultra_outliner</a> .  To do this, you do not need to delve into the essence of the program itself, but you can simply open the sample file from the samples folder, open the "plots" or "characters" tab (from the project explorer on the left), and move the connected elements there.  Any scene change will cause the routing to be rebuilt. </p><br><p>  To make it look prettier, there are additional elements on the connections (arrows, joint-s), but these are all design elements. </p><br><p>  And for those who want to understand the theory, I recommend reading the scientific publications on this topic on the <a href="http://www.adaptagrams.org/documentation/libavoid.html">libavoid</a> website. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318722/">https://habr.com/ru/post/318722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318712/index.html">Gigabyte history</a></li>
<li><a href="../318714/index.html">Legal risks of investing in startups of companies in the USA and Israel</a></li>
<li><a href="../318716/index.html">Animated Lines in iOS</a></li>
<li><a href="../318718/index.html">Coordinated work of macro and micro base stations in the creation of heterogeneous networks as the key to the development of mobile broadband</a></li>
<li><a href="../318720/index.html">Microservice at Golang</a></li>
<li><a href="../318724/index.html">Platform to quickly create a RESTful API</a></li>
<li><a href="../318726/index.html">FPGA Debug Board - Frankenstein. Christmas tree controller</a></li>
<li><a href="../318728/index.html">Results of the year: The great pre-New Year digest of ITMO University</a></li>
<li><a href="../318732/index.html">As we star rating crushed</a></li>
<li><a href="../318736/index.html">Annual Report Habrapost - 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>