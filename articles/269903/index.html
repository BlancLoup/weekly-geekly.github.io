<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a REST service on Rust. Part 5: Handlers, Refactoring, and Macros</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 We continue to write a web service on Rust. Table of contents: 

 Part 1: prototype 
 Part 2: we read INI; multirust 
 Part 3: update the da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a REST service on Rust. Part 5: Handlers, Refactoring, and Macros</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  We continue to write a web service on Rust.  Table of contents: <br><br>  <a href="http://habrahabr.ru/post/267477/">Part 1: prototype</a> <br>  <a href="http://habrahabr.ru/post/267661/">Part 2: we read INI;</a>  <a href="http://habrahabr.ru/post/267661/">multirust</a> <br>  <a href="http://habrahabr.ru/post/267779/">Part 3: update the database from the console</a> <br>  <a href="http://habrahabr.ru/post/268617/">Part 4: go to the REST API</a> <br>  Part 5 (this): handlers, refactoring, and macros 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we will look at the actual API request handlers and rewrite the previous, terrible code.  And in general, this is the last article in the series, so there will be refactoring, style, macros and all.  This is the longest part. <br><a name="habracut"></a><br><h3>  Why we cloned Arc twice </h3><br>  Here's what the code that sets API paths now looks like: <br><br><pre><code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb = Arc::new(Mutex::new(db)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> router = router::Router::new(); { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb_ = sdb.clone(); router.get(<span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::get_records(sdb_.clone(), req)); } { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb_ = sdb.clone(); router.get(<span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::get_record(sdb_.clone(), req)); } ‚Ä¶</code> </pre> <br>  For starters, the handlers themselves.  Here, for example, handlers :: get_records (): <br><br><div class="spoiler">  <b class="spoiler_title">handlers :: get_records</b> <div class="spoiler_text"><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_records</span></span></span></span>(sdb: Arc&lt;Mutex&lt;Connection&gt;&gt;, req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request) -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = req.url.clone().into_generic_url(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> name: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = <span class="hljs-literal"><span class="hljs-literal">None</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(qp) = url.query_pairs() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key, value) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> qp { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (&amp;key[..], value) { (<span class="hljs-string"><span class="hljs-string">"name"</span></span>, n) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> = name { name = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::BadRequest, <span class="hljs-string"><span class="hljs-string">"passed name in query more than once"</span></span>))); } } _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::BadRequest, <span class="hljs-string"><span class="hljs-string">"unexpected query parameters"</span></span>))), } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::BadRequest, <span class="hljs-string"><span class="hljs-string">"passed names don't parse as application/x-www-form-urlencoded or there are no parameters"</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json_records; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(recs) = ::db::read(sdb, name.as_ref().map(|s| &amp;s[..])) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> rustc_serialize::json; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(json) = json::encode(&amp;recs) { json_records = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(json); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::InternalServerError, <span class="hljs-string"><span class="hljs-string">"couldn't convert records to JSON"</span></span>))); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::InternalServerError, <span class="hljs-string"><span class="hljs-string">"couldn't read records from database"</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> content_type = Mime( TopLevel::Application, SubLevel::Json, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new()); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with( (content_type, status::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>, json_records.unwrap()))) }</code> </pre> <br></div></div><br>  Its signature is the reason that we had to clone Arc with the database inside the closure: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_records</span></span></span></span>(sdb: Arc&lt;Mutex&lt;Connection&gt;&gt;, req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request) -&gt; IronResult&lt;Response&gt; {</code> </pre> <br>  As you can see, Arc is passed here by value (i.e., with possession), and it is not a type that is trivially copied.  For this reason, we cloned Arc for transmission to the handler. <br><br><h3>  What happens in the handlers </h3><br>  In general, the handlers are of the same type, so I will only look at get_records in detail - it is the most complex.  I want to note that in the handlers, pattern matching is actively used to determine erroneous situations. <br><br>  First we get a rust-url url from <a href="http://ironframework.io/doc/iron/struct.Url.html">iron</a> url. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = req.url.clone().into_generic_url();</code> </pre> <br>  We do this to then use the <a href="http://ironframework.io/doc/url/struct.Url.html">query_pairs</a> method, which parses the URL as application / x-www-form-urlencoded data and (possibly) returns an iterator over the key-value pairs. <br><br><h3>  if let </h3><br>  Now I will show the new syntax ‚Äúif let‚Äù, and then I will tell you what its essence is. <br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">qp</span></span></span><span class="hljs-function">)</span></span> = url.query_pairs() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> qp {</code> </pre> <br>  You may have already guessed what this entry means.  The if let statement attempts to match the pattern, and if it is successful, passes the execution to the block for if let.  In this block, the name that we just associated the value with will be available - in this case, qp.  If it was not possible to compare the value with the template (query_pairs () returned None), then the else branch is executed - it looks like a normal if. <br><br><h3>  Return erroneous HTTP statuses </h3><br>  Accordingly, if the iterator is not returned to us, this is an error: <br><br><pre> <code class="hljs rust"> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::BadRequest, ‚Äúpassed names don<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> parse <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> application/x-www-form-urlencoded or there are no parameters‚Äù))); }</code> </pre> <br>  Here we have a tuple in parentheses describing the server's response: HTTP status and message. <br><br><h3>  Get the request parameters </h3><br>  If we are returned an iterator, we go around it to get the name parameter and save it to the name variable: <br><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> name: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = <span class="hljs-literal"><span class="hljs-literal">None</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(qp) = url.query_pairs() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key, value) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> qp { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (&amp;key[..], value) { (<span class="hljs-string"><span class="hljs-string">"name"</span></span>, n) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> = name { name = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::BadRequest, <span class="hljs-string"><span class="hljs-string">"passed name in query more than once"</span></span>))); } } _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::BadRequest, <span class="hljs-string"><span class="hljs-string">"unexpected query parameters"</span></span>))), } } }</code> </pre> <br>  The cycle is needed here to bypass the iterator, pull the desired element from the pair vector, and not have problems with ownership.  But in fact, any situation where exactly one request parameter, which is called name, was not passed to us, is erroneous.  Let's try to remove the loop. <br><br><h3>  We remove the cycle parameters </h3><br>  <a href="http://ironframework.io/doc/url/struct.Url.html">.query_pairs ()</a> actually returns Option &lt;Vec &lt;(String, String) &gt;&gt;.  Therefore, we can simply check the length of the vector and the name of a single parameter: <br><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> name: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = <span class="hljs-literal"><span class="hljs-literal">None</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> qp) = url.query_pairs() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> qp.len() != <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with((status::BadRequest, <span class="hljs-string"><span class="hljs-string">"passed more than one parameter or no parameters at all"</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (key, value) = qp.pop().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key == <span class="hljs-string"><span class="hljs-string">"name"</span></span> { name = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(value); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br>  Now we do not go around the vector, but check its length and immediately refer to the parameter that interests us. <br><br>  Here is an important point: <br><br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (key, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) = qp.pop().unwrap();</code> </pre> <br>  It‚Äôs important to use pop () - it sends us a vector element with a hold.  A normal reference by index (qp [0]) would give a reference, and we would not be able to move the value from the pair to Some (value) to put all this in the name. <br><br><h3>  Why does string comparison with &amp; str work? </h3><br>  It is also worth noting that pairs are stored in our vector (String, String).  But then we directly compare key with ‚Äúname‚Äù - a string literal: <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key == "name" { <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); }</code> </pre> <br>  It, as you remember, has type &amp; 'static str.  This works because the String implements the PartialEq type for comparison with &amp; 'a str: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br>  Therefore, no type conversion occurs here. <br><br>  If there was no such type, we could convert the String to &amp; str using the slice syntax: &amp; key [..] will return the slice over the entire string, i.e.  link- &amp; str with the same content. <br><br>  Next, we make the actual access to the database. <br><br><h3>  Uninitialized variables - is it dangerous? </h3><br>  First, we declare a name for the JSON records that our REST access point should return: <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json_records;</code> </pre> <br>  Hmm, do we initialize it with any value?  Want to shoot yourself in the leg? <br><br>  No, Rust will not let us use the declared name until it is initialized.  For example, in this code <br><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> { a = <span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, a); } }</code> </pre> <br>  an error will occur: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:6</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:24</span></span>: 6<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:25</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">error</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">use</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">of</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">possibly</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uninitialized</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">variable</span></span>: `<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>` <span class="hljs-selector-attr"><span class="hljs-selector-attr">[E0381]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:6</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">println</span></span>!("{}", <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>); ^</code> </pre> <br><br><h3>  We read records from a DB.  We use Option :: map </h3><br>  Next we read the records from the database: <br><br><pre> <code class="hljs ruby"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let Ok(recs) = <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:db</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:read</span></span>(sdb, name.as_ref().map(<span class="hljs-params"><span class="hljs-params">|s|</span></span> &amp;s[..])) {</code> </pre> <br>  Why is there something strange going on in the arguments? <br><br><pre> <code class="hljs smalltalk"> name.as_ref().map(|s| &amp;s[..])</code> </pre> <br>  Now I will explain.  First, we look at our signature :: db :: read (): <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(sdb: Arc&lt;Mutex&lt;Connection&gt;&gt;, name: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Record&gt;, ()&gt; {</code> </pre> <br>  As you can see, it takes a name in the form of <code>Option&lt;&amp;str&gt;</code> .  Our name is of type <code>Option&lt;String&gt;</code> .  But it doesn't matter: the <code>.as_ref()</code> method turns <code>Option&lt;T&gt;</code> into <code>Option&lt;&amp;T&gt;</code> - so we get <code>Option&lt;&amp;String&gt;</code> . <br><br>  Unfortunately, because  <code>&amp;String</code> wrapped in Option, it is not converted to <code>&amp;str</code> automatically.  Therefore, we use the aforementioned slice syntax in an anonymous function: <br><br><pre> <code class="hljs smalltalk"> .map(|s| &amp;s[..])</code> </pre> <br>  .map applies the function to the contents of the Option and converts T from <code>Option&lt;T&gt;</code> to some other type.  In this case, we will convert <code>&amp;String</code> to <code>&amp;str</code> .  This is similar to haskel <code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; fa -&gt; fb</code> . <br><br>  There is a subtlety: we could not call .map immediately on <code>name: Option&lt;T&gt;</code> , since  then the link will be valid only in the scope of the function parameters in the call.  In this case, we will get a link inside the closure, and it will live only as long as the closure lives.  But it is not saved anywhere and will be destroyed after the parameter is passed to the function.  Such a link will be a temporary object: <br><br><pre> handlers.rs:25:53: 25:54 error: `s` does not live long enough
 handlers.rs:25 if let Ok (recs) = :: db :: read (sdb, name.map (| s | &amp; s [..])) {
                                                                    ^
 handlers.rs:25:23: 25:60 note: reference must be valid for the call at 25:22 ...
 handlers.rs:25 if let Ok (recs) = :: db :: read (sdb, name.map (| s | &amp; s [..])) {
                                      ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 handlers.rs: 25: 47: 25:58 note: ...
 handlers.rs:25 if let Ok (recs) = :: db :: read (sdb, name.map (| s | &amp; s [..])) {
                                                                   ^ ~~~~~ </pre><br>  In the case of .as_ref (), the link lives while Option itself lives, so everything works. <br><br><h3>  And what about multithreading? </h3><br>  Let's take a look at :: db :: read and see how the vaunted protection against data races works. <br><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(rs) = show(&amp;*sdb.lock().unwrap(), name) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(rs) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()) }</code> </pre> <br>  We want to call show: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span></span>(db: &amp;Connection, arg: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;) -&gt; ::postgres::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Record&gt;&gt; {</code> </pre> <br>  This function accepts a reference to Connection, and we have <code>Arc&lt;Mutex&lt;Connection&gt;&gt;</code> .  We will not be able to get to the database connection of interest to us, except by expanding the reference counter and taking control of the mutex.  The type system makes invalid states unrepresentable. <br><br><h3>  Almost magic </h3><br>  So we want to take over the mutex.  It is nested in the reference counter.  Here two things come in: deconversion conversion and auto dereference when calling methods. <br><br>  For now, ignore the strange &amp; * and look at sdb.lock () itself.  sdb is Arc, but <code>Arc&lt;T&gt;</code> implements <code>Deref&lt;T&gt;</code> . <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Deref <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Arc&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: ?<span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Target</span></span></span></span> = T <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;T</code> </pre> <br>  Thus, <code>Arc&lt;T&gt;</code> will be automatically converted to &amp; T if necessary.  This will give us a <code>&amp;Mutex&lt;Connection&gt;</code> . <br><br>  Next comes the auto-dereference when calling methods.  In short, the compiler will insert as many dereferences into the method call as necessary. <br><br>  Here is a simple example: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Foo { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = Foo; f.foo(); (&amp;f).foo(); (&amp;&amp;f).foo(); (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();</code> </pre> <br>  All four last lines do the same thing. <br><br><h3>  Safely releasing a mutex using RAII </h3><br>  Mutex :: lock will give us <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> .  Result allows us to handle the error, and <code>MutexGuard&lt;T&gt;</code> is a RAII value that will automatically open the mutex as soon as we stop working with it. <br><br>  That <code>&amp;*</code> translates <code>MutexGuard&lt;T&gt;</code> into &amp; T ‚Äî first we dereference it and get T, and then we take the address to get the usual link, &amp; T. <br><br>  Why can lock () work directly with <code>Arc&lt;Mutex&lt;Connection&gt;&gt;</code> , but does MutexGuard need to be converted manually?  Because lock is a method, and a call to methods will actually not only dereference references, but also convert some references into others (that is, make an analog of <code>&amp;*</code> ).  When passing arguments to a function, this must be done manually. <br><br><h3>  Serialization </h3><br>  After receiving our records, we want to serialize them into JSON.  To do this, use <a href="http://doc.rust-lang.org/rustc-serialize/rustc_serialize/index.html">rustc_serialize</a> : <br><br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> rustc_serialize::<span class="hljs-keyword"><span class="hljs-keyword">json</span></span>;</code> </pre> <br>  As you can see, we can import modules not only globally, but also in the scope of a single function or block.  This helps not to clutter up the global namespace. <br><br>  The serialization itself is done with this code: <br><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(json) = json::encode(&amp;recs) { json_records = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(json); } ...</code> </pre> <br>  In this case, the serializer code is generated automatically!  We only need to declare the type of our records as serializable (and at the same time, deserializable): <br><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[derive(RustcEncodable, RustcDecodable)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Record</span></span></span></span> { id: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> phone: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><br><h3>  Send all back </h3><br>  Finally, we wrap our JSON in the correct HTTP with the appropriate headers and return it: <br><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> content_type = Mime( TopLevel::Application, SubLevel::Json, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new()); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(Response::with( (content_type, status::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>, json_records.unwrap())))</code> </pre> <br>  The remaining handlers work in a similar way, so instead of repeating, we will refactor our code. <br><br>  In general, our program is over!  Now our wonderful phone book can be updated not only from the command line, but also through a modern web API.  If you want to see how everything works, get a version of the code for the feature-complete tag from <a href="https://github.com/mkpankov/rust-phonebook/releases/tag/feature-complete">GitHub</a> . <br><br>  Refactoring is not so complicated, and I show this process just to convince you that the code on Rust can also be beautiful.  That unreadable mess that we had in the process of implementing the functional is simply the result of haste.  Rust is not to blame - you can write elegant code on it. <br><br><h3>  Do not clone clones </h3><br>  First of all, let's deal with the dual cloning of Arc, which I mentioned in the previous section: <br><br><pre> <code class="hljs rust"> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb_ = sdb.clone(); router.get(<span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::get_records(sdb_.clone(), req)); }</code> </pre> <br>  It is very easy to win.  Change handlers :: get_records signature with <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_records</span></span></span></span>(sdb: Arc&lt;Mutex&lt;Connection&gt;&gt;, req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request) -&gt; IronResult&lt;Response&gt; {</code> </pre> <br>  on <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_records</span></span></span></span>(sdb: &amp;Mutex&lt;Connection&gt;, req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request) -&gt; IronResult&lt;Response&gt; {</code> </pre> <br>  And in general, we use <code>&amp;Mutex&lt;Connection&gt;</code> everywhere - in handlers and in database functions.  Everything, double cloning is no longer necessary: <br><br><pre> <code class="hljs rust"> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb = sdb.clone(); router.get(<span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::get_records(&amp;*sdb, req)); }</code> </pre> <br>  With a huge main, too, should understand.  Just take all the actions into its functions and get a cool compact main: <br><br><pre> <code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (params, sslmode) = params(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = Connection::connect(params, &amp;sslmode).unwrap(); init_db(&amp;db); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = std::env::args().collect(); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> args.get(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(text) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> text.as_ref() { <span class="hljs-string"><span class="hljs-string">"add"</span></span> =&gt; add(&amp;db, &amp;args), <span class="hljs-string"><span class="hljs-string">"del"</span></span> =&gt; del(&amp;db, &amp;args), <span class="hljs-string"><span class="hljs-string">"edit"</span></span> =&gt; edit(&amp;db, &amp;args), <span class="hljs-string"><span class="hljs-string">"show"</span></span> =&gt; show(&amp;db, &amp;args), <span class="hljs-string"><span class="hljs-string">"help"</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, HELP), <span class="hljs-string"><span class="hljs-string">"serve"</span></span> =&gt; serve(db), command =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid command: {}"</span></span>, command)) } } <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"No command supplied"</span></span>), } }</code> </pre> <br><br><h3>  rustfmt! </h3><br>  Finally, sweet: <a href="https://github.com/nrc/rustfmt">rustfmt</a> !  The source code formatting utility on Rust is not finished yet, but it is already suitable for decorating the code of our small project. <br><br>  Cloning the repository, do the cargo build --release, and then copy the resulting executable file somewhere in $ PATH.  Then, in the root of our project we will do <br><br><pre> $ rustfmt src / main.rs </pre><br>  And everything, the code of the <i>whole project is</i> instantly formatted!  rustfmt follows links to other modules and formats them too. <br><br>  Unlike gofmt, rustfmt allows you to quite a bit to customize the style in which the source will be rewritten. <br><br>  The current default style is something like the one in which the compiler itself is written.  However, as the <a href="http://doc.rust-lang.org/stable/style/">official style guide</a> is finalized, rustfmt will also be finished. <br><br>  At this "reasonable" refactoring ends, and begins ... something controversial, but definitely fun: let's remove the remaining repetition of similar code using macros. <br><br><h3>  Macros </h3><br>  What kind of repetition am I talking about?  About it: <br><br><pre> <code class="hljs rust"> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb = sdb.clone(); router.get(<span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::get_records(&amp;*sdb, req)); } { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb = sdb.clone(); router.get(<span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::get_record(&amp;*sdb, req)); } { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb = sdb.clone(); router.post(<span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::add_record(&amp;*sdb, req)); } { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb = sdb.clone(); router.put(<span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::update_record(&amp;*sdb, req)); } { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sdb = sdb.clone(); router.delete(<span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| handlers::delete_record(&amp;*sdb, req)); }</code> </pre> <br>  Obviously, there is some high-level structure that we could not reflect in the code.  Since these blocks differ in the method that the router needs to call, in order to process all these options in a normal function, it would be necessary to match some enumeration, which would call the appropriate method depending on the argument. <br><br>  This is, generally speaking, an option, and most likely I would try to do it if I wrote this code at work, but here we have fun, and I have long wanted to try macros in Rust.  So let's get started. <br><br>  To begin with, the duplicate structure here is a block that clones Arc and then executes an operator.  Let's try to write the corresponding macro: <br><br><pre> <code class="hljs bash">macro_rules! clone_pass_bound { (<span class="hljs-variable"><span class="hljs-variable">$arc</span></span>:ident, <span class="hljs-variable"><span class="hljs-variable">$stmt</span></span>:stmt) =&gt; { { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> <span class="hljs-variable"><span class="hljs-variable">$arc</span></span> = <span class="hljs-variable"><span class="hljs-variable">$arc</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">clone</span></span>(); <span class="hljs-variable"><span class="hljs-variable">$stmt</span></span>; } } }</code> </pre> <br>  The first line says that we started defining a macro called clone_pass_bound.  Stupid name, but better come up with failed.  This is in itself a symptom of the fact that you probably should not do this in your working code.  But oh well - this is not our case now. <br><br>  The macros in Rust are typed, and ours takes two arguments - $ arc of type ‚Äúidentifier‚Äù (ident) and $ stmt of type ‚Äúoperator‚Äù (statement, stmt).  If you take a closer look, you can notice the similarity of the definition of a macro to match - here a certain combination of arguments is compared to a specific body.  Macro branches can have many branches, like match - and this is useful in the case of recursion. <br><br>  After the arrow are two pairs of curly braces.  Some are required according to the syntax of the macro description - in general, as in the usual match. <br><br>  With the help of the second pair, we say that our macro expands into a block.  Inside the block, we write almost the usual code, replacing sdb with $ arc.  This is a trivial generalization.  Cloning follows our operator. <br><br>  Here is how this macro is called: <br><br><pre> <code class="hljs lisp"> clone_pass_bound!( <span class="hljs-name"><span class="hljs-name">sdb</span></span>, router.get(<span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, move |req: &amp;mut Request| handlers:<span class="hljs-symbol"><span class="hljs-symbol">:get_records</span></span>(<span class="hljs-name"><span class="hljs-name">&amp;*sdb</span></span>, req)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  So far we have not saved anything in terms of volume, just received an incomprehensible challenge.  But do not despair - we just started! <br><br><h3>  Macro on macro </h3><br>  Now it becomes clear that one handler can be described using four parameters: a connection to the database, a router, which method to add to it (get, post, etc.), and how the handler defined by us is called.  Let's write a macro for this: <br><br><pre> <code class="hljs ruby">macro_rules! define_handler { ($connection<span class="hljs-symbol"><span class="hljs-symbol">:ident</span></span>, $router: ident.$method<span class="hljs-symbol"><span class="hljs-symbol">:ident</span></span>, $route<span class="hljs-symbol"><span class="hljs-symbol">:expr</span></span>, $handler<span class="hljs-symbol"><span class="hljs-symbol">:path</span></span>) =&gt; { clone_pass_bound!( $connection, $router.$method( $route, move <span class="hljs-params"><span class="hljs-params">|req: &amp;mut Request|</span></span> $handler(&amp;*$connection, req))); } }</code> </pre> <br>  Here, first of all, it is worth emphasizing again the similarity of calling a macro with the usual pattern matching.  As you can see, the macro argument argument separator does not have to be a comma - the router and we divided its method with a dot, for greater similarity with the usual code. <br><br>  Then stupidly replacing all specific names with meta variables of the macro and calling our previous macro is not that scary and difficult.  I wrote both of these macros on the first try. <br><br>  Now we have written two dozen lines of insane macros, and the code we wanted to cut finally began to decrease: <br><br><pre> <code class="hljs erlang-repl"> define_handler!(sdb, router.get, <span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, handlers::get_records); define_handler!(sdb, router.get, <span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, handlers::get_record); define_handler!(sdb, router.post, <span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, handlers::add_record); define_handler!(sdb, router.put, <span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, handlers::update_record); define_handler!(sdb, router.delete, <span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, handlers::delete_record);</code> </pre> <br>  This is not the limit - now we will define the last macro, which will make our definition very compact and quite understandable.  Now the changing parts of the code are quite obvious, and nothing can hurt to make the code completely DRY. <br><br>  In our last macro there will be exactly 1 (one) non-trivial moment. <br><br><h3>  Macro chases </h3><br>  This is what the last macro looks like: <br><br><pre> <code class="hljs ruby">macro_rules! define_handlers_family { ($connection<span class="hljs-symbol"><span class="hljs-symbol">:ident</span></span>, $router<span class="hljs-symbol"><span class="hljs-symbol">:ident</span></span>, $( [$method<span class="hljs-symbol"><span class="hljs-symbol">:ident</span></span>, $route<span class="hljs-symbol"><span class="hljs-symbol">:expr</span></span>, $handler<span class="hljs-symbol"><span class="hljs-symbol">:path</span></span>]),+ ) =&gt; { $( define_handler!($connection, $router.$method, $route, $handler); )+ } }</code> </pre> <br>  It is rather small.  A nontrivial moment is that we introduced repeatability in the arguments: <br><br><pre> <code class="hljs ruby"> ($connection<span class="hljs-symbol"><span class="hljs-symbol">:ident</span></span>, $router<span class="hljs-symbol"><span class="hljs-symbol">:ident</span></span>, $( [$method<span class="hljs-symbol"><span class="hljs-symbol">:ident</span></span>, $route<span class="hljs-symbol"><span class="hljs-symbol">:expr</span></span>, $handler<span class="hljs-symbol"><span class="hljs-symbol">:path</span></span>]),+ ) =&gt; {</code> </pre> <br>  <code>$( ‚Ä¶ ),+</code> means that the enclosed group in brackets should be repeated one or more times when calling this macro.  It looks like regular expressions. <br><br>  Next is the body of our macro monster.  At first I wrote this: <br><br><pre> <code class="hljs perl"> define_handler!($connection, $router.$method, $route, $handler);</code> </pre> <br>  To which the compiler countered: <br><br><pre> <code class="hljs mel">main.rs:<span class="hljs-number"><span class="hljs-number">134</span></span>:<span class="hljs-number"><span class="hljs-number">46</span></span>: <span class="hljs-number"><span class="hljs-number">134</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>: variable <span class="hljs-string"><span class="hljs-string">'method'</span></span> is still repeating at this depth main.rs:<span class="hljs-number"><span class="hljs-number">134</span></span> define_handler!($connection, $router.$method, $route, $handler); ^~~~~~~</code> </pre> <br>  As I said, the call part that defines $ method, $ route, and $ handler can be repeated.  In Rust macros, the rule is that a meta-variable that is at a certain ‚Äúlevel‚Äù of repetitions in a call must be at the same level of repetition when used. <br><br>  This can be thought of as follows: the tuples of parameters of macro calls are being moved simultaneously with the corresponding bodies.  Those.  one set of parameters must correspond to one body.  Thus it becomes easier to understand the structure of the macro - the body becomes like a challenge. <br><br>  And now we have the macro recorded as if it has only one body - it turns out that the call parameters are repeated, and the bodies cannot be repeated.  Then what kind of $ method should be in the body?  Unclear.  In order to avoid such situations, a rule has been devised for sorting parameters ‚Äúin step‚Äù with the bodies. <br><br>  For us, this all means that you need to wrap the body in the same repeatability modifier as the parameters: <br><br><pre> <code class="hljs mel"> $( define_handler!($connection, $router.$method, $route, $handler); )+</code> </pre> <br>  Now $ method, $ route and $ handler match duplicate parameters.  And $ connection and $ router are ‚Äúglobal‚Äù - they are not under one repeatability modifier, so they will be duplicated in each body. <br><br>  As a reward for this brainwave, we get a beautiful definition of all the paths in our API: <br><br><pre> <code class="hljs lisp"> define_handlers_family!( <span class="hljs-name"><span class="hljs-name">sdb</span></span>, router, [get, <span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, handlers:<span class="hljs-symbol"><span class="hljs-symbol">:get_records</span></span>], [get, <span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, handlers:<span class="hljs-symbol"><span class="hljs-symbol">:get_record</span></span>], [post, <span class="hljs-string"><span class="hljs-string">"/api/v1/records"</span></span>, handlers:<span class="hljs-symbol"><span class="hljs-symbol">:add_record</span></span>], [put, <span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, handlers:<span class="hljs-symbol"><span class="hljs-symbol">:update_record</span></span>], [delete, <span class="hljs-string"><span class="hljs-string">"/api/v1/records/:id"</span></span>, handlers:<span class="hljs-symbol"><span class="hljs-symbol">:delete_record</span></span>])<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  No unnecessary duplication, and in the final version looks even relatively understandable to the uninitiated. <br><br>  I want to note that macros in Rust are hygienic - collisions of names inside a macro with names outside are excluded. <br><br>  Oh yeah, I almost forgot - the compiler option is very helpful in debugging macros - pretty-print = expand.  So it will print the code after macros are expanded into the standard output stream.  It looks like the -E option on C and C ++ compilers. <br><br><h3>  See you again! </h3><br>  That's all.  Now everything is completely - I think this series of articles has told you enough so that you yourself can start building your code on Rust, including for the web. <br><br>  If you have already started doing something on Rust - write about it in the comments.  And also come to our <a href="https://gitter.im/ruRust/general">chat</a> with questions that arise along the way - they are happy to help you there. </div><p>Source: <a href="https://habr.com/ru/post/269903/">https://habr.com/ru/post/269903/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269893/index.html">Pure architecture in a go app. Part 1</a></li>
<li><a href="../269895/index.html">How I did the web version of KeePass</a></li>
<li><a href="../269897/index.html">Automatic generation of microcontroller software code based on event-oriented model</a></li>
<li><a href="../269899/index.html">Lua 5.3 Reference Guide</a></li>
<li><a href="../269901/index.html">Pitfalls Entity Framework and Performance</a></li>
<li><a href="../269905/index.html">How we lost and again found millions without testing A / B</a></li>
<li><a href="../269907/index.html">Unpacked types of unions in Scala based on the Curry-Howard isomorphism</a></li>
<li><a href="../269909/index.html">Errors are values</a></li>
<li><a href="../269915/index.html">Divide means multiply</a></li>
<li><a href="../269917/index.html">A library that helps bridge the conceptual gap between OOP and DB during testing using ORM - LinqTestable</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>