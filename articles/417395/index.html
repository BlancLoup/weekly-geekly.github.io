<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>End-to-end testing: what, why, why</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Testing in large companies in an enterprise is often difficult and ungrateful. The gap between business units and IT is huge: when a developer has a v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>End-to-end testing: what, why, why</h1><div class="post__text post__text-html js-mediator-article">  Testing in large companies in an enterprise is often difficult and ungrateful.  The gap between business units and IT is huge: when a developer has a vision at the level of code, and verification is at the level of unit tests, and the customer thinks working or non-working not even with services, but with entire processes beyond one development team, or even the whole divisions of the company.  And asks to organize business testing, or end-to-end testing, or testing based on scenarios from beginning to end (end 2 end). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/qv/ti/nhqvti-zb92rwglmubbrufr_bsq.jpeg" alt="image"></div><a name="habracut"></a><br>  Let's start from the very beginning - from two pillars, where did this notorious ‚Äúend-to-end business testing‚Äù come from, namely, the testing pyramid and the ISO9000 standard. <br><br><h3>  <b>Pyramid testing</b> </h3><br>  Testing pyramid is surely familiar to any tester who has become skilled in his profession and has crammed when communicating with adjacent departments.  Especially often it is necessary to appeal to her when justifying test automation.  What tests are cheaper and more important to develop?  And run? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/wi/ix/b1/wiixb1wde8koz5g7skkd8aev2sa.png"><br><br>  The essence of the pyramid of testing is not tricky: at the heart of testing, you should use the simplest and fastest tests in writing and execution - unit tests.  Of course, checking the interfaces of classes and functions is hardly the thing that can be shown to the customer, but without this solid, monolithic, trouble-free foundation, it is unlikely that it will be possible to build something higher.  As a rule, several dozen functions, methods, classes implement some kind of functionality for the customer, and in fact a dozen of unit tests can be reduced to some high-level tests.  The customer already needs a beautiful apartment with decoration, but it is unlikely that he will be satisfied when the skewed windows in his apartment stop opening and the floor and ceiling go cracked from the first breeze that blows.  However, the customer himself can go into the apartment and check its quality may not be the best idea.  Agree, it is difficult for the user to check the quality of concrete in the foundation, and to reproduce all weather conditions.  So in testing, of course, high-level testing is needed, then only when we have completed the unit tests, and the tests are already of a higher level. <br><br><img src="https://habrastorage.org/webt/zv/qm/zn/zvqmzn14i0uxhpgl1-wu8ht_-g0.png"><br><br>  It is more difficult to develop and to perform longer, higher-level tests - integration tests that verify the correctness of the work of simultaneously working modules, on which the whole team worked, releasing their product (system).  That is, the integration of the code is checked, the system is tested without interaction with external systems.  Such tests already imply a high-level check, most likely through a system call via the system API or even a GUI (front).  Working with this type of test is more difficult - to cover all the branches and nuances of the code, you most likely need to use a large number of highly intersecting checks on various test data, and during automation often develop a whole bunch of conditions and branching in the scripts.  That is, on the one hand, we have already approached the user, complicating our lives, but on the other hand, it is still difficult for us to find a common language, it costs us more, and the quality of checks is still not enough.  That is, we can launch the customer to a new apartment, he can check everything, but without taking into account interaction with other tenants, weather conditions and public utilities.  Agree, the sense of an ideal world, a model, in real life, as a rule, is not much. <br><br><img src="https://habrastorage.org/webt/1j/2x/um/1j2xumgpz_iiilxoqevf-jcqq5k.png"><br><br>  If we add these conditions - we will see how our system interacts with external systems - suppliers and consumers, with our environment, that is, we will carry out system testing, it is easy to see that the complexity of testing will also increase.  We will need to strive for the simultaneous operability of all interacting systems, albeit without the involvement of specialists in them.  For now, it is enough for us to simply accept some data from our suppliers and transfer our data to our customers.  In the correct sequence and format.  The further fate of the data does not bother us.  The main thing - our system works correctly in the right environment.  And everything would be fine here - for our customer we can already have a full-scale demonstration, but in real life this is not all the success criteria for our development.  Of course it's good that the customer got his apartment in a solid house, but if you have to get away from it, climbing over the barbed wire, then on a canoe on a lake with crocodiles, into the tents teeming with snakes, then maybe we have something wrong. did you do there? <br><br><img src="https://habrastorage.org/webt/nq/vo/eu/nqvoeufsr9rke8wr2rghhmolfmi.jpeg"><br><br>  Therefore, here the first idea for end-to-end testing is to check not only our environment, but also all the interconnected systems through which the data received or sent by our system passes.  And this, in turn, means that we will have to combine several such "testing pyramids" among themselves.  The construction of a fragile bridge, on which we will hold for the handle data that is valuable to the user. <br><br><img src="https://habrastorage.org/webt/ue/np/x2/uenpx2yjdpc40x5o5vuijdpx7rs.png"><br><br>  That's just the question of how to do this?  Who to do it?  How to put together? <br><br><h3>  <b>ISO9000</b> </h3><br><img src="https://habrastorage.org/webt/sh/rh/dq/shrhdqzexkmlb7o3owhc6wygqyc.gif"><br><br>  A series of standards describing quality management systems, including that any process in an organization should be described, documented, even if it is the process of issuing a rake to the janitor until the fall.  And if so, that no process that runs inside the software used and developed in the organization, can not be described.  The question is how to do it?  Of course, the best description, from the point of view of BDD, is the description of the behavior of tests, under which the testing pyramid will lie.  But we will immediately return to our dilemma with combining several pyramids with thin ropes from top to top, which our ropewalker customer and his users will walk without insurance. <br><br><img src="https://habrastorage.org/webt/9p/fz/y5/9pfzy5h9vkofu7hlfk4lhxrlvnu.png"><br><br><blockquote>  The process approach is a management strategy to manage the processes between them.  Thus, they need to consider these processes and their supporting processes. </blockquote><br>  Therefore, the easiest way to use abstractions is to create at least a process diagram, specify its inputs and outputs, make the process controllable and measurable, ensure interconnection with parent and child processes, as required by ISO9000 <br><blockquote>  All processes have: <br>  ‚Ä¢ inputs; <br>  ‚Ä¢ outputs; <br>  ‚Ä¢ operational control; <br>  ‚Ä¢ appropriate measurement &amp; monitoring. <br>  Each process will have support processes </blockquote><br><img src="https://habrastorage.org/webt/lf/ib/ff/lfibffcaniqhdca5jnpm3opkfs4.png"><br><br>  Business diagrams are best suited for this purpose, and standards such as UML, BPMN, ARIS, etc. are most often used. And the processes themselves become flowcharts with "cubes" strung on them.  Between the "cubes" there is an interaction, in the standard BPMN is a flow of actions and a message flow.  And this is exactly what we need! <br><br><img src="https://habrastorage.org/webt/9c/cd/xg/9ccdxgsawcfbvunf7tszehtx8ne.png"><br><br>  Any company that wants to have a certificate and follows the ISO9000 standard has most likely acquired such schemes, and they are an integral part of high-level requirements.  If good analysts work in the company, then, most likely, references to specific actions from the schemes will go down to low-level requirements.  We need them. <br>  In fact, in the diagrams, we can see the whole process, and understand which scenario we need to build, and which system / team to run with what data at what point. <br><br>  I do not underestimate the work of developers who write literate code that forwards messages between different parts of software and hardware systems, but it‚Äôs impossible to keep everything in mind.  And when the process is used in many other processes, it is better to have such a ‚Äúmap‚Äù with you for conducting competent testing, and even more so for building a test model. <br><br><h3>  <b>What to practice</b> </h3><br>  So, we have two introductory - every team / system should have a pyramid of tests prepared - from the smallest unit tests to complex system tests, as well as the fact that we must describe the requirements in the form of business within the organization -processes.  This fact will allow us to quickly respond to the customer, which business process works and at what point because of what it breaks, and when receiving defects from commercial operation, it is possible to quickly perform root cause analysis (analysis of root causes of defects).  In theory. <br><br>  But in practice, everything again falls on the tester - how to choose the right ones from a pile of tests, especially strangers, build them into a chain, and send the necessary data to the input of each system and verify it with the correctly defined expected result? <br><br><img src="https://habrastorage.org/webt/sc/um/p7/scump7nbssfw63ms00bfzkvf0ew.png"><br><br>  The easiest option is to initially develop tests based on business models, and to divide teams into projects that implement a particular business process.  To do this, some testing management tools already have the ability to download BPMN schemes (for example, for HPE ALM - download is supported in XPDL format).  HP ALM itself will break the scheme into a set of requirements (actions), and if desired, create a hierarchy of requirements (module Requirements-&gt; Business Models).  Further, our business is to cover the requirements with tests, and then build the requirements, and hence the tests in the chains covering our business process.  These chains in HPE ALM are called ‚Äúpaths‚Äù (path), and allow you to see all combinations of sequences.  If desired, the requirements, the chains can be immediately converted into tests. <br><br><img src="https://habrastorage.org/webt/dd/16/20/dd16204wmkjjmjiaopmd8aw_t3m.png"><br><br><img src="https://habrastorage.org/webt/xh/wr/lk/xhwrlkr-4ps7nlkf1ritfbtpusa.png"><br><br>  But even if you do not use the testing tools, you still have to form chains from the business process.  Especially considering the imperfection of the tools (not everything is so rosy), as well as the fact that, most likely, the test model will need to be assembled post-factum, and executed as a recourse at all by the ‚Äúcommon team‚Äù not clinging to new projects. <br><br><img src="https://habrastorage.org/webt/xs/pa/jl/xspajls0rzf6yx8uysegs967v1s.png"><br>  <i>How many ways can a squirrel walk to a bump?</i> <br><br>  In this case, we will need to open the tests of each team, find the requirements tied to the requirements in the business model, and build chains of them, retaining them in the ‚Äúcommon space‚Äù.  Creating a common space is some kind of substitute, but in any case it should be, even in the form of a barn book, excel, or a project area in the test management tool.  If we talk again about HPE ALM, then the BPT (Business Process Testing) module is responsible for this functionality, which at the same time allows you to transfer the results of one test to the parameters of another.  However, if you wish, and hard work on HPE ALM, this is possible and implemented through rebuilding test sets (Test set) into the execution flow (Execution flow).  Then when you run the full set, the testers responsible for passing each of the components of the end-to-end scenario will be called in turn. <br><br><img src="https://habrastorage.org/webt/ol/kt/ns/olktnspfsjlvrmfxrynsb1u906w.png"><br><br>  And, alas, testing controls alone are indispensable.  From my practice, almost all tools have some fatal flaws, and therefore, if you get to the stage of automating testing for a business process, you will come to create a script that will pull tests in the right sequence. <br><br><img src="https://habrastorage.org/webt/bp/cq/le/bpcqleyfv9lk223xt0rdvtrgj-k.png"><br><br>  As a result, two conclusions can be drawn: <br><br>  1) for end-to-end scenarios, previously developed tests for each of the systems included in the chain (scenario) of a business process are used with high probability. <br><br><img src="https://habrastorage.org/webt/rv/_t/ti/rv_ttizbebbewwqm9qu6mwle9vu.png"><br><br>  All complete test suites of a company can be represented in the form of a sparse matrix, where the columns are distributed for each system (for simplicity, system tests), and the rows are business processes.  That is, for those or other business processes, it is necessary to select / create tests covering the business process, establish relationships.  If there is no coverage, this is a reason to fill in the gaps in the test model, or to make sure that the quality is ensured by other levels of testing (integration testing, unit testing, code review and running it through analyzers). <br><br>  2) A tool is needed to monitor, trace and update the business process for synchronization with the test model. <br><br><img src="https://habrastorage.org/webt/4l/2y/t9/4l2yt9fthhj9kvvyqjdtq_lwaru.png"><br><br>  And if testing tools are more or less tolerably done with the creation of a test model, then everything is really very bad with updating, it is often easier to recreate the model, rather than trying to see the changes in the process and the test model.  And the experience of real teams suggests that it is better to create a live visualization of architecture.  The easiest way to do this is in the common area, using a simple whiteboard and stickers.  Then, the teams that are involved in the business process can clearly see how the process is modified (links are removed and added, actions are removed and added).  The main thing is that everyone has access to the board.  Plus, note that if the process involves messages between systems, then, as a rule, at least there should be two tests from each system - for sending and receiving data.  However, instead of stickers, you can use a whole Lego-city (from large blocks), or something even more creative.  The main thing here is one language and one information space, which is very lacking in the enterprise. <br><br><h3>  <b>Finally</b> </h3><br>  Organizing visual and proper testing for business processes is a difficult and very expensive thing.  Please note that E2E testing is not just an acceptance, user testing that the customer will perform, this is building a bridge, taking into account all the possible situations that the customer will follow and lead the users to follow. <br><br><img src="https://habrastorage.org/webt/no/_p/pw/no_ppwbcrkex70rsozks01j2fvm.jpeg"><br><br>  Once again - E2E - this is not a walk on the Lada-Kalina across the bridge, and not even travel by two KamAZ.  This is a complex engineering work, hanging bridges with sensors and conducting all possible checks and situations - at least a description of these scenarios. <br><br>  Whether or not your company needs such an ideal finishing run is solely a matter of your goals and needs.  Always, as with any testing, the potential risks from missed defects at this stage should be assessed, as well as the cost of preparation and carrying out end-to-end testing.  Rate that from this will cost you more, and only then act.  But in the case of end-to-end testing by business processes, it should be remembered that it does not make sense without a solid foundation in the form of 100% passrate unit tests (~ 90-100% coverage), without integration tests (~ 60-80% coverage, 90 100% passrate), without system tests (20-40% coverage, 80-100% passrate).  Establishing success criteria (quality gates) is more of a requirement for the quality of the product being produced, the main thing to remember here is that the volume of E2E tests is only the tip of the pyramid (1-2% coverage, ~ 99% passrate), which should not be greater than its base, not at the same time be a plug of holes from the previous stages.  This is an addition that is considered a priori closed in the previous stages. <br><br>  The organization of such testing is mainly work on the preparation and synchronization of test cases and data (test analytics), as well as a set of organizational measures, the synchronization of teams in one place at one time on a working test site.  Keeping this in mind, one should not try to show the customer ‚Äúend-to-end testing‚Äù ahead of time, in order not to waste time at once a large number of people without all the working components assembled together. <br><br>  <b>PS The</b> described tools, as well as practices - purely for example, the author did not set himself the goal of advertising products and reciting the only true approach to end-to-end testing. </div><p>Source: <a href="https://habr.com/ru/post/417395/">https://habr.com/ru/post/417395/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417383/index.html">JavaScript ES6: weaknesses</a></li>
<li><a href="../417385/index.html">How I moved ... home, or my answer to the author of the article on "merciless flour"</a></li>
<li><a href="../417389/index.html">Tilt Shift Lens Effect</a></li>
<li><a href="../417391/index.html">Cross-browser web extension for custom scripts Part 4</a></li>
<li><a href="../417393/index.html">How we made a system that gives customers discounts based on individual characteristics</a></li>
<li><a href="../417397/index.html">What programming language to learn in 2018 and why?</a></li>
<li><a href="../417399/index.html">Welcome aboard: we introduce new developers to the team</a></li>
<li><a href="../417401/index.html">Finally, we choose a budget multimeter with good functionality.</a></li>
<li><a href="../417405/index.html">Autoencoders and Strong AI</a></li>
<li><a href="../417407/index.html">Optimizing the rendering of scenes from the Disney cartoon "Moana". Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>