<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional languages ‚Äã‚Äãin hardware design</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Functional languages, as a rule, are not very suitable for low-level programming, although they are used for code generation. 

 Project examples  gen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional languages ‚Äã‚Äãin hardware design</h1><div class="post__text post__text-html js-mediator-article"><img height="30%" width="30%" src="https://habrastorage.org/getpro/habr/post_images/8ac/905/f32/8ac905f32d6903fc5e776604455b6577.png" align="left">  Functional languages, as a rule, are not very suitable for low-level programming, although they are used for code generation. <br><br><div class="spoiler">  <b class="spoiler_title">Project examples</b> <div class="spoiler_text">  generation of safe C code (used in Kaspersky Lab) <a href="http://ivorylang.org/">Ivory</a> , support for <a href="https://github.com/frp-arduino/frp-arduino">reactive programming on Arduino</a> , and so on <a href="https://github.com/tomahawkins/atom">Atom</a> , <a href="https://haskellembedded.github.io/">Ion</a> </div></div><br>  But if you go down even lower, to the hardware level, then suddenly the OP is very useful.  After all, a block of combinatorial logic is nothing but a function of the values ‚Äã‚Äãof the incoming signals to the outgoing ones, and for consistent logic it is enough to add the old and the new state to the parameters and the result. <br><a name="habracut"></a><br>  When I first learned Haskell, I joined a stormy discussion on ‚Äúwhat is the best way to simulate an RS-trigger‚Äù.  I immediately noticed that the language I‚Äôve recently studied solves all the problems that come up in this discussion. <br><br>  Modeling involves observing the evolution of a model‚Äôs state over time, but in Haskell there is no variable state as such.  For that is, lazy lists that turn into "horizontal time." 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">What time?</b> <div class="spoiler_text">  This ridiculous term was coined by one of the participants, who was very surprised that it was more convenient for me to put the entire evolution of one signal in a line, and the next line - the whole evolution of another signal (although on large models such a format will lead to serious memory overhead and better make an effort to print the result as in ordinary languages ‚Äã‚Äã- data output is the most difficult in Haskell).  In other matters, he even liked this format, since it is more like signals on an oscilloscope, compared to printing the values ‚Äã‚Äãof all signals in one line for each measure. </div></div><br>  A simple way to model signals is to present them with lists of values ‚Äã‚Äãat each moment in time.  If one signal is equal to another with an offset one quantum in time, we simply add 0 to the beginning of the list: <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">delay</span></span> s = <span class="hljs-number"><span class="hljs-number">0</span></span>:s</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Or so</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">delay</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>:</code> </pre><br></div></div><br>  You can create your own type for signals - it is more efficient, safer and more correct, but for simplicity, we still limit ourselves to using simple lists. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signal</span></span></span><span class="hljs-class"> v = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> v (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signal</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">) delay vs = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> vs</span></span></code> </pre><br>  If accurate modeling of the operating time is required, the signal can be represented by a list of pairs (time interval, signal value) and provide a representation of unsteady values. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/d44/2ae/f32d442aed1032adea788b0b89a6b4f3.gif"></div><br>  An RS trigger is a two NOR nodes interconnected mutually recursively.  This system has two stable states in which the output of one NOR is one, and the other is zero.  By feeding the unit to the second input of one of the NOR nodes, you can switch states. <br><br>  Generally speaking, an RS trigger is an asynchronous circuit.  But for the sake of simplicity, we will simulate it as synchronous, which is not quite right (even choosing the short size of ‚Äútact‚Äù is difficult to simulate transients, it is better to use a different signal representation). <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">nor</span></span> '_' '_' = '~' nor _ _ = '_' rs rs = (q, nq) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> q = '_' : zipWith nor r nq nq = '_' : zipWith nor qs main = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r = <span class="hljs-string"><span class="hljs-string">"~_______"</span></span> s = <span class="hljs-string"><span class="hljs-string">"___~~___"</span></span> (q,nq) = rs rs <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> print r print s print q print nq</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Haskell Quick Reference</b> <div class="spoiler_text">  Names of variables (more precisely, constants, since they cannot change in the scope) and functions begin with a small letter and consist of alphanumeric characters or consist of special characters and do not begin with ':'. <br><br>  Type names, constructors (we can assume that these are the names of constants in enumerations) and module names begin with a capital letter (or with a ':'). <br><br>  (:) - list constructor.  Creates a new list by adding one element to the old one. <br><pre> <code class="haskell hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> : [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]</code> </pre>  equivalent to [0,1,2,3,4,5] <br>  Strings in Haskell are represented as a list of characters.  "1234" means the same as ['1', '2', '3', '4'] <br><br>  zip - turns two lists into pairs. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">zip</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-string"><span class="hljs-string">"1234"</span></span></code> </pre>  is equal to <pre> <code class="haskell hljs">[(<span class="hljs-number"><span class="hljs-number">1</span></span>,'<span class="hljs-number"><span class="hljs-number">1</span></span>'),(<span class="hljs-number"><span class="hljs-number">2</span></span>,'<span class="hljs-number"><span class="hljs-number">2</span></span>'),(<span class="hljs-number"><span class="hljs-number">3</span></span>,'<span class="hljs-number"><span class="hljs-number">3</span></span>'),(<span class="hljs-number"><span class="hljs-number">4</span></span>,'<span class="hljs-number"><span class="hljs-number">4</span></span>')]</code> </pre> <br><br>  zipWith applies a function to two list items <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">zipWith</span></span> (+) [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>]</code> </pre>  calculate the element-by-element sum of the lists [2,5,8,11] <br>  zip is expressed through zipWith <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">zip</span></span> = zipWith (,)</code> </pre><br><br>  zip3 and zipWith3 work in the same way, but for three lists. <br><br>  scanl applies a function to each accumulated list item.  Its type (signature) is described as: <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">scanl</span></span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</code> </pre> <br>  The first argument scanl is a function of two arguments, the second is the initial value of the accumulator, the third is the input list. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">scanl</span></span> (+) <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]</code> </pre>  will calculate the list of partial sums: [0,1,3,6,10] <br><br>  ($) - postfix notation for applying a function to an argument. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> $ x = fx</code> </pre> <br>  Often used to write fewer brackets: <br>  fx $ gy is equivalent to fx (gy) <br><br>  Writing \ xy -&gt; fyx means an anonymous function (also called a closure) with parameters x and y. <br><br>  Next meet a few obscure terms.  I hope they do not scare the reader.  Even if this description is too complicated, by examples it will be easy to figure out how these functions are used. <br><br>  fmap - ‚Äúraises‚Äù a function from a single value to a function over an entire container.  The container should be a functor, but almost everything is.  In particular, such containers are signals that store values ‚Äã‚Äãfor each point in time.  Also such containers are lists, although for them, for historical reasons, there is a special function ‚Äúmap‚Äù with the same functionality. <br>  liftA is the same as fmap, but for applicative functors (as indicated by the letter 'A' in the name).  Signals are also applicative functors, and lists are more complicated.  Formally, lists are also applicative functors and liftA works with them as expected.  But liftA2 and liftA3 behave unexpectedly, but this is a topic for a separate article. <br><br>  liftA2 and liftA3 "raise" functions from two and three arguments to functions from containers.  They will work with signals, and for lists it is better to use zipWith and zipWith3. <br></div></div><br>  This approach makes it relatively easy to model quite complex circuits at the <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B5%25D0%25BD%25D1%258C_%25D1%2580%25D0%25B5%25D0%25B3%25D0%25B8%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B2%25D1%258B%25D1%2585_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0%25D1%2587">RTL</a> level.  The clock signal is clearly not present, but is implied wherever it is needed.  Registers can be modeled using a delay or by explicitly providing for the state in the parameters and the return value of the node code. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">macD</span></span> rxy = acc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> prods = zipWith (*) xy sums = zipWith (+) acc prods acc = <span class="hljs-number"><span class="hljs-number">0</span></span> : zipWith (\rv -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> v) r sums macS rxy = scanl macA <span class="hljs-number"><span class="hljs-number">0</span></span> $ zip3 rxy <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> macA acc (r,x,y) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> acc+x*y</code> </pre><br>  Two equivalent models of MAC operation (multiplication with addition) with a battery are described here.  macD - using a recursive signal with a delay, macS - using an explicitly described state. <br><br>  If a Haskell subset simulates synchronous hardware so well, then why not synthesize HDL from it?  There are several compiler extension projects that allow you to do this: commercial <a href="http://bluespec.com/">Bluespec</a> , free <a href="http://ittc.ku.edu/csdl/fpg/Tools/KansasLava">Lava</a> and <a href="http://www.clash-lang.org/">CŒªaSH</a> . <br><br><h1>  Clash </h1><br>  As an example, I want to consider Clash, since it can compile both in VHDL, in SystemVerilog, and in good old Verilog (which attracts me because it is used <a href="https://geektimes.ru/company/icover/blog/273966/">not only in microelectronics</a> :) <br><br>  The installation process is described in sufficient detail on the site.  You should pay attention to it - firstly, compatibility with ghc-7.x is declared (that is, it may not work with 8.x), secondly you do not need to try to run ‚Äúcabal install clash‚Äù - this is an outdated package, you need to install clash-ghc ( "Cabal install clash-ghc --enable-documentation"). <br><br>  The clash executable (or clash.exe, depending on the OS) will be installed in the "~ / .cabal / bin" directory, it is better to add it to $ PATH. <br><br>  The main node from which the clash starts compiling is called topEntity, which is a function from the incoming signal to the outgoing signal (of course, the signals can be composite). <br><br>  For example, consider a one-bit adder: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">topEntity</span></span> :: <span class="hljs-type"><span class="hljs-type">Signal</span></span> (<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Signal</span></span> (<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">Bool</span></span>) topEntity s = fmap (\(s1,s2) -&gt; (s1 .&amp;. s2, s1 `xor` s2)) s</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Whole file</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ADD1 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CLaSH.Prelude topEntity :: Signal (<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Signal (<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">Bool</span></span>) topEntity = fmap (\(<span class="hljs-title"><span class="hljs-title">s1</span></span>,<span class="hljs-title"><span class="hljs-title">s2</span></span>) -&gt; (<span class="hljs-title"><span class="hljs-title">s1</span></span> .&amp;. <span class="hljs-title"><span class="hljs-title">s2</span></span>, <span class="hljs-title"><span class="hljs-title">s1</span></span> `<span class="hljs-title"><span class="hljs-title">xor</span></span>` <span class="hljs-title"><span class="hljs-title">s2</span></span>))</code> </pre></div></div><br>  fmap turns a function of a pair of logical quantities into a function of a signal.  You can compile the file in verilog using the command "clash --verilog ADD1.hs" <br><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><pre> <code class="hljs lua">// Automatically generated Verilog<span class="hljs-number"><span class="hljs-number">-2001</span></span> module ADD1_topEntity_0(a1 ,result); <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] a1; <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] result; wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] app_arg; wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] case_alt; wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] app_arg_0; wire [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] case_alt_0; wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s1; wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s2; assign app_arg = s1 &amp; s2; reg [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] case_alt_reg; always @(*) begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s2) case_alt_reg = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; else case_alt_reg = 1'</span></span>b1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign case_alt = case_alt_reg; reg [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] app_arg_0_reg; always @(*) begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s1) app_arg_0_reg = case_alt; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> app_arg_0_reg = s2; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign app_arg_0 = app_arg_0_reg; assign case_alt_0 = {app_arg ,app_arg_0}; assign s1 = a1[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>]; assign s2 = a1[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; assign result = case_alt_0; endmodule</code> </pre></div></div><br>  To work with the state, you can use the Moore and Miles machines.  Consider a frequency divider, first with the help of Moore‚Äôs automaton. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DIV3S</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S0</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S1</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S2</span></span></span><span class="hljs-class"> div3st </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S0</span></span></span><span class="hljs-class"> _ = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S1</span></span></span><span class="hljs-class"> div3st </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S1</span></span></span><span class="hljs-class"> _ = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S2</span></span></span><span class="hljs-class"> div3st </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S2</span></span></span><span class="hljs-class"> _ = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S0</span></span></span><span class="hljs-class"> div3out </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S2</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class"> div3out _ = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">False</span></span></span><span class="hljs-class"> topEntity :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signal</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signal</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> topEntity = moore div3st div3out </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S0</span></span></span></span></code> </pre><br>  data is a Haskell construct that describes a data type.  In this program, we describe the type of DIV3S representing the state of our automaton.  Possible values ‚Äã‚Äãof this type are listed in '|'  - S0, S1 and S3. <br>  div3st is a state function (it is customary to call the unused parameter by the "_" symbol, in this case, the value of the input signal). <br>  div3out is a function from state to value of the output signal. <br><br>  The library function moore creates a node based on these two functions and the initial state. <br><br><div class="spoiler">  <b class="spoiler_title">Output systemverilog</b> <div class="spoiler_text"><pre> <code class="hljs vhdl">// Automatically generated SystemVerilog-<span class="hljs-number"><span class="hljs-number">2005</span></span> module DIV3Moore_moore(w3 ,// clock system1000 ,// asynchronous reset: active low system1000_rstn ,result); input logic [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] w3; input logic system1000; input logic system1000_rstn; output logic [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] result; logic [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s1_app_arg; logic [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s1; always_comb <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(s1) <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b00</span></span> : s1_app_arg = <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b01</span></span> : s1_app_arg = <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> : s1_app_arg = <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> logic [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] dout; always_ff @(posedge system1000 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge system1000_rstn) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : DIV3Moore_moore_register <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~ system1000_rstn) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dout &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> dout &lt;= s1_app_arg; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign s1 = dout; // <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always_comb <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(s1) <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b10</span></span> : result = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> : result = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre></div></div><br>  The same with the Miles machine: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DIV3S</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S0</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S1</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S2</span></span></span><span class="hljs-class"> div3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S0</span></span></span><span class="hljs-class"> _ = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S1</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">False</span></span></span><span class="hljs-class">) div3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S1</span></span></span><span class="hljs-class"> _ = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S2</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">False</span></span></span><span class="hljs-class">) div3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S2</span></span></span><span class="hljs-class"> _ = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S0</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) topEntity :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signal</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signal</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> topEntity = mealy div3 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S0</span></span></span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Output VHDL</b> <div class="spoiler_text"><pre> <code class="vhdl hljs"><span class="hljs-comment"><span class="hljs-comment">-- Automatically generated VHDL-93 library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.NUMERIC_STD.ALL; use IEEE.MATH_REAL.ALL; use std.textio.all; use work.all; use work.div3mealy_types.all; entity div3mealy_mealy is port(w2 : in boolean; -- clock system1000 : in std_logic; -- asynchronous reset: active low system1000_rstn : in std_logic; result : out boolean); end; architecture structural of div3mealy_mealy is signal y : boolean; signal result_0 : div3mealy_types.tup2; signal x : unsigned(1 downto 0); signal x_app_arg : unsigned(1 downto 0); signal x_0 : unsigned(1 downto 0); begin result &lt;= y; y &lt;= result_0.tup2_sel1; with (x) select result_0 &lt;= (tup2_sel0 =&gt; to_unsigned(1 ,2) ,tup2_sel1 =&gt; false) when "00", (tup2_sel0 =&gt; to_unsigned(2,2) ,tup2_sel1 =&gt; false) when "01", (tup2_sel0 =&gt; to_unsigned(0,2) ,tup2_sel1 =&gt; true) when others; -- register begin div3mealy_mealy_register : process(system1000,system1000_rstn) begin if system1000_rstn = '0' then x &lt;= to_unsigned(0,2); elsif rising_edge(system1000) then x &lt;= x_app_arg; end if; end process; -- register end x_app_arg &lt;= x_0; x_0 &lt;= result_0.tup2_sel0; end;</span></span></code> </pre> </div></div><br>  In Clash, instead of lists, vectors of fixed size are used and most of the library functions are redefined to work with them.  You can get to the standard list functions by adding to the file (or by running in the REPL) the line <code>import qualified Data.List as L</code>  After that, you can use functions by explicitly specifying the ‚ÄúL.‚Äù prefix.  for example <br><br><pre> <code class="hljs css">*<span class="hljs-selector-tag"><span class="hljs-selector-tag">DIV3Mealy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">L</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">L</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scanl</span></span> (+) 0 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3,4]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[0,1,3,6,10]</span></span></code> </pre> <br>  Most of the usual list functions work with vectors. <br><br><pre> <code class="hljs ruby">*DIV3Mealy L&gt; scanl (+) <span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:&gt;</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:&gt;</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:&gt;</span></span> Nil) &lt;<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>&gt; *DIV3Mealy L&gt; scanl (+) <span class="hljs-number"><span class="hljs-number">0</span></span> $(v [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]) &lt;<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;</code> </pre> <br>  But there are many subtleties, for details, refer to the <a href="http://hackage.haskell.org/package/clash-prelude-0.10.14/docs/CLaSH-Sized-Vector.html">documentation</a> . <br><br>  A guide with examples can be found <a href="http://hackage.haskell.org/package/clash-prelude-0.10.14/docs/CLaSH-Tutorial.html">here</a> . <br><br>  The <a href="http://www.clash-lang.org/">site</a> has examples of projects on Clash, in particular the implementation of the <a href="https://github.com/polygonhell/Clash6502">processor 6502</a> . <br><br><h1>  Perspectives </h1><br>  Haskell is a very powerful language, and it is possible to use it to develop DSL, for example, to develop a device‚Äôs software interface (with generation, in addition to HDL, also via <a href="http://ivorylang.org/">Ivory</a> drivers and emulators for virtualization systems), or architecture and microarchitecture (with generation of LLVM backend, optimizing for this microarchitecture). <br><br>  Taking this opportunity, I express my gratitude to <a href="https://habrahabr.ru/users/yuripanchul/" class="user_link">yuripanchul</a> for organizing the publication of the textbook ‚ÄúDigital Circuit <a href="https://habrahabr.ru/users/yuripanchul/" class="user_link">Design</a> and Computer Architecture‚Äù, which I am currently reading, and which encouraged me to write this article. </div><p>Source: <a href="https://habr.com/ru/post/316748/">https://habr.com/ru/post/316748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316736/index.html">The Tale of Cleopatra and Russian Cryptography (Continued)</a></li>
<li><a href="../316738/index.html">Advent of Code 2016</a></li>
<li><a href="../316740/index.html">Efficient storage: as we did from 50 Pb, 32 Pb</a></li>
<li><a href="../316742/index.html">How to create a trading robot using genetic programming</a></li>
<li><a href="../316746/index.html">Dual-pane using fragments</a></li>
<li><a href="../316750/index.html">Security Week 48: Tech Support Locker, Mirai Mutations, Vulnerability in Firefox and Tor Browser</a></li>
<li><a href="../316752/index.html">The story of a single plugin</a></li>
<li><a href="../316754/index.html">Death transit traffic?</a></li>
<li><a href="../316756/index.html">Creating and testing a firewall in Linux, Part 2.2. Firewall tables. Access to TCP / IP structures</a></li>
<li><a href="../316758/index.html">Linux kernel documentation goes to Python Sphinx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>