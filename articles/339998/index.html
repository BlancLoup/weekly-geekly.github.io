<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TeaVM - a tool to create a web frontend for Java, Kotlin and Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quite a long time ago I published an article on Habr√©, where I told about my project, TeaVM . Since then, a lot of things happened to him, including o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TeaVM - a tool to create a web frontend for Java, Kotlin and Scala</h1><div class="post__text post__text-html js-mediator-article"><p>  Quite a long time ago I published <a href="https://habrahabr.ru/post/240999/">an article</a> on Habr√©, where I told about my project, <a href="http://teavm.org/">TeaVM</a> .  Since then, a lot of things happened to him, including one important thing, about which we will discuss below and for which I decided to write again on Habr.  But first, let me briefly remind you what the project is about. </p><br><p>  So TeaVM is a Java bytecode compiler in javascript.  The idea of ‚Äã‚Äãcreating TeaVM came to me while I was a full-stack Java developer and used GWT to write a frontend.  In those days (and this was about 5 years ago), tools like node.js, webpack, babel, TypeScript were not widely distributed;  Angular was in the first version, and there were no alternatives like React and vue.js at all.  Then, quite seriously, people were testing sites in IE7 (and some who were not lucky with customers, even IE6).  In general, the JavaScript ecosystem was much less mature than it is now, and it was impossible to write JavaScript without pain. </p><br><p>  I liked the GWT because, against the background of all this, it seemed to be an adequate solution, although not without its flaws.  The main problems are listed under the cat: </p><a name="habracut"></a><br><ul><li>  The rebuild speed left much to be desired.  GWT is very slow.  We started the compilation and went to drink tea with cookies. </li><li>  GWT receives Java source for input and therefore, firstly, it works slowly (parsing and resolving Java code is not an easy task), secondly, it does not support anything except Java, thirdly, it is far behind even in support new versions of java itself. </li><li>  GWT is just a terrible framework for building UIs.  On the one hand, it tries to abstract from the DOM, on the other hand, it does not always go to the end, abstractions occur, and correcting it with direct intervention in the DOM is not easy, because  have to break through the thick layers of abstraction.  In addition, while the entire civilized world followed the path of a declarative markup description (WPF in .NET, JavaFX, Flex, the above-mentioned modern frameworks for JavaScript), GWT forcedly collect UI from widgets in the old fashioned way. </li></ul><br><p>  It didn‚Äôt seem to me that the idea of ‚Äã‚Äãwriting web applications in Java is bad in itself.  All the flaws of GWT were from the fact that Google, I think, simply did not invest sufficient resources in its development.  I preferred to put up with the shortcomings of GWT, just not to switch to JavaScript. </p><br><p>  And then I thought - why not use Java bytecode as input?  The bytecode saves a lot of information about the source program, so much so that decompilers manage to restore the sources almost exactly.  Javaas does all the most difficult work on generating bytecode, so it takes very little time to generate JavaScript.  Plus we get support for other languages ‚Äã‚Äãfor JVM and almost free support for new versions of Java (bytecode is much more conservative than Java language). </p><br><h2 id="chto-interesnogo-proizoshlo-s-proektom">  What interesting happened to the project </h2><br><p>  I have already said that a lot of interesting things happened to the project.  Here are the most important points that I would like to talk about: </p><br><ul><li> Added support for threads.  In JavaScript there are none at all, WebWorkers is not about that, because, unlike threads, they do not have a shared state, i.e.  you cannot create an object in one worker and transfer it to another without copying it.  Instead, TeaVM is able to transform the code of the methods so that their execution can be interrupted at some specified points (approximately the same way as babel does when it sees await).  This made it possible to do some variant of cooperative multitasking, when one thread, having reached some long IO operation (well, or just some <code>Thread.sleep()</code> ), pauses and allows another thread to execute. </li><li>  There was support for WebAssembly, while experimental.  Random bytecode is supported, but some JDK methods that are strongly tied to the JVM are not supported (this is primarily a different reflection).  There is also no interop with anything;  to trigger javascript you have to dance with a tambourine for a very long time.  In general, in order to support WebAssembly, I had to write my GC and stack unwinding, so this WebAssembly is low-level!  Over time, they promise to add support for GC and exceptions, but for now this is a real assembler. </li><li>  I had my own framework for writing a web-frontend on TeaVM, and this is the very news that I wrote this article for.  However, the details - below. </li></ul><br><h2 id="veb-freymvork">  Web framework </h2><br><p>  The TeaVM web framework is called Flavour and is entirely written in Java.  Recently I published the first version (numbered 0.1.0) on Maven Central.  Ideologically, it resembles modern Angular 2/4 and Vue.js, but is built entirely on idioms that are close to a Java developer.  For example, all Flavor components are represented by regular Java classes, annotated with annotations, there are no separate props and state, or any special objects that should encapsulate the changing properties.  The HTML template language is completely statically typed, any access to the object property or a call to the event handler is checked at compile time and, for example, typos in the name of the properties simply will not allow the project to be compiled. </p><br><p>  To communicate with the server, Flavor suggests using interfaces marked up with JAX-RS annotations, and the data is transmitted using DTO, which in turn are marked up with Jackson annotations.  This should be convenient for Java developers, who very likely already know and use these APIs in their projects. </p><br><p>  A natural question arises: why create a framework if there are existing ones: React, Angular, Vue.js?  You can just use JavaScript interop and not invent anything.  Of course, I thought about it.  But no, everything turns out to be much worse than it seems at first glance.  These frameworks are built around the idioms of dynamically typed JavaScript, and you can create an object with the right set of properties out of thin air, and hope that the "class" of the object has a magic method with the right name.  In general, in the JavaScript world, framework creators are not used to thinking about typing.  This can be overcome by writing all sorts of adapters, wrappers, preprocessors, generators.  But in the end, the system will be more complicated than the original frameworks, so it was decided to write your own. </p><br><h2 id="nemnogo-primerov">  Few examples </h2><br><h3 id="sozdanie-proekta">  Project creation </h3><br><p>  Of course, all those interested can read the documentation on the <a href="http://teavm.org/">site</a> .  But in order to make it easier and faster to taste the flavor of Flavour, I will show a small example here. </p><br><p>  So, you can create a project using Maven: </p><br><pre> <code class="hljs tex"> mvn archetype:generate <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-DarchetypeGroupId=org.teavm.flavour <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-DarchetypeArtifactId=teavm-flavour-application <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>-DarchetypeVersion=0.1.0</code> </pre> <br><p>  The generated project is collected, as expected, with the <code>mvn package</code> command. </p><br><h3 id="shablonizator">  Template engine </h3><br><p>  The page is described by two files - a class code that describes its behavior (provides data for display, contains event handlers) and an HTML template.  In the created project there is already an example of a page, but I still give one more example.  You can replace the example generated from the archetype or simply add two more files to the existing ones.  This is how the page class code looks like: </p><br><pre> <code class="hljs pgsql">@BindTemplate("templates/fibonacci.html") <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Fibonacci { private List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Fibonacci() { <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getValues() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> next() { <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.size() - <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>)); } }</code> </pre> <br><p>  And so - its template: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values -    this.getValues() --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">std:foreach</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fib"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">in</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"values"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html:text</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fib"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">std:foreach</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   , event:click    -  ,         ,       --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"button"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">event:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"next()"</span></span></span><span class="hljs-tag">&gt;</span></span>Show next<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  <code>std:foreach</code> , <code>html:text</code> and <code>event:click</code> are the Flavor components.  The user can describe his components (interested in how exactly they can read about it in the <a href="http://teavm.org/docs/flavour/custom-components.html">documentation</a> ), while they can either manually draw their DOM, or do it through a template.  There is nothing special about these components, they are not implemented by compiler magic.  If you wish, you can write your analogs.  For an illustration you can familiarize yourself with the <a href="">html: text</a> code. </p><br><p>  Finally, here‚Äôs what the <code>main</code> method code should look like: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String[] args</span></span></span><span class="hljs-function">)</span></span> { Templates.bind(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fibonacci(), <span class="hljs-string"><span class="hljs-string">"application-content"</span></span>); }</code> </pre> <br><p>  All the main magic starts right here.  The framework does not create an instance of the page class, and does not manage it in any way.  Instead, you create it yourself and manage it yourself as you like, and Flavour simply generates a DOM, inserts it in the right place, tracks changes in the state of the object and redraws the DOM according to these changes.  By the way, Flavor does not redraw the entire DOM, but changes only the necessary part of it. </p><br><p>  I want to note once again that templates are statically typed.  If you make a mistake and write <code>event:click="nxt()"</code> , then the compiler will write an error message.  This approach also allows you to generate faster code - Flavor does not waste time after loading the page to parse directives and initialize the baydings;  it does all this at compile time. </p><br><h3 id="rest-klient">  REST client </h3><br><p>  Now I would like to show how Flavor can be useful to a fullstack developer.  Suppose you use some CXF in conjunction with JAX-RS.  You wrote about this interface: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Path(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"math"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MathService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span> <span class="hljs-meta"><span class="hljs-meta">@Path(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"integers/sum"</span></span></span><span class="hljs-meta">)</span></span> int sum(<span class="hljs-meta"><span class="hljs-meta">@QueryParam(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta">)</span></span> int a, <span class="hljs-meta"><span class="hljs-meta">@QueryParam(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"b"</span></span></span><span class="hljs-meta">)</span></span> int b); }</code> </pre> <br><p>  and implemented it (for example, in the <code>MathServiceImpl</code> class), registered the implementation in CXF.  You have a small REST service.  Now, to make a request for it, from the client‚Äôs side, you can write the following code: </p><br><pre> <code class="hljs pgsql">MathService math = RESTClient.factory(MathService.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>).createResource("api"); <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.println(math.sum(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>));</code> </pre> <br><p>  (it can be seen in devtools that this code will send a GET request to the address <code>/api/math/integers/sum?a=2&amp;b=3</code> ). </p><br><p>  In general, it is not necessary to somehow explain to the web client how to properly make a REST request to the desired endpoint.  You have already done this in the same way for the server and for the client.  You can further increase and refactor the REST service, without having to synchronize it from the server side and from the client side - there is a synchronization point in the form of the <code>MathService</code> interface. </p><br><p>  GWT has a similar mechanism, GWT-RPC, but it forces to generate an additional async interface and use callbacks, while TeaVM can convert synchronous code to asynchronous.  And GWT-RPC uses its own incompatible protocol, so by creating an endpoint for GWT-RPC, you cannot reuse it, for example, for an iOS client. </p><br><h2 id="chto-eschyo-interesnogo-est">  What else is interesting? </h2><br><p>  Of course, in a small review article I can not tell everything at all.  Therefore, I‚Äôll just mention that there is such an interesting thing in TeaVM and Flavor, which makes them quite suitable for creating high-quality web applications. </p><br><ul><li>  Integration with IntelliJ IDEA.  Running Maven every time is not serious, after all, Maven is used to build on production and not during development.  TeaVM can run directly from IDEA, just press the Build button. </li><li>  Debugger  Without it, it is impossible to talk at all about something as a serious tool.  TeaVM can generate standard source maps;  There is also a debugging information format that is used in the IDEA plugin. </li><li>  Very fast compiler.  I spent efforts on optimization, and the byte code is so primitive thing that when processing it there is simply nothing to slow down.  This is not Java, where it is necessary, for example, to deduce types, with generics, variantness and captured types.  In addition, when running the compiler from IDEA, several techniques are used to reduce compile time, such as running the compiler from a daemon and caching information for subsequent builds.  All this allows to achieve quite comfortable speed of JavaScript reassembly. </li><li>  A good optimizer that can cut off a very small piece of an impressively sized JDK that is necessary for the normal operation of an application, and even make it fast. </li><li>  Routing  Flavor can parse and generate links that, from an API point of view, are quite statically typed interfaces. </li><li>  Validation of forms. </li><li>  Modal windows with a blocking API, like in Swing. </li><li>  This is mentioned above - Kotlin and Scala are supported, not just Java.  By the way, the TeaVM version of TodoMVC is written in Kotlin. </li><li>  Open license Apache 2.0, familiar in the world of Java-development. </li></ul><br><h2 id="zachem-java-v-vebe">  Why is Java on the web? </h2><br><p>  Recently, the JavaScript ecosystem has become quite mature.  It‚Äôs easier for a developer not to use all sorts of heavyweight monsters like GWT, but to learn how to customize tools that have become de facto standards, and write in a modern language with a lot of advanced features or even in a modern statically typed language (TypeScript). </p><br><p>  The problem is that all this needs to be studied.  Studying is not just the language syntax (an experienced developer will spend a few days on this), learn a lot of things - libraries, idioms, developer tools.  I am sure that yesterday‚Äôs experienced Java developer will take and deal with all this in a couple of weeks, but the question is, how well will he have time to figure it out?  Can he write really good code?  Even if you understand and can, there are still problems.  First, the developer will have to switch the context between Java and JavaScript.  Secondly, the developer will have to spend more time setting up the tools. </p><br><p>  Well, I have a question for the Java community.  For some reason, is there such a persistent movement towards the backend from the side of JavaScript?  I suspect that exactly one of the considerations that I cited above.  Why not be the same movement in the opposite direction?  Here is the JavaScript frontend developer community that has cooperated and spawned the backend ecosystem around node.js.  How are we, the Java community, worse?  There is a myth that supposedly JavaScript is smart and lightweight, and Java is big and heavy, and is not suitable for creating frontend.  In fact, with my project I try to prove that it is precisely that myth, and that properly prepared Java can also be small and quick.  An example of this is the implementation of TodoMVC, which takes 125kb (try writing TodoMVC on React or Angular 4 and see how big you get the bundle). </p><br><h2 id="v-zaklyuchenie">  Finally </h2><br><p>  If you're interested in Flavor, here's some more study material: </p><br><ul><li>  <a href="http://teavm.org/docs/intro/overview.html">Documentation</a> in English; </li><li>  <a href="https://github.com/konsoletyper/teavm-flavour-examples-todomvc">TodoMVC</a> at Kotlin; </li><li>  Java <a href="https://github.com/konsoletyper/teavm-flavour-minesweeper">Sapper</a> ; </li><li>  <a href="https://github.com/konsoletyper/teavm-flavour/tree/master/example">CRUD example, close to real</a> , with REST, validation, drop-down calendars, modal windows and much more; </li><li>  Of course, you can always ask me if something seemed incomprehensible. </li></ul><br><p>  I would love to get feedback.  Are you interested in my project, would you like to try it for writing a small application?  Do I still need to publish articles, and if so, what exactly would you like to read about it?  I can publish tutorials on Flavor, I can tell how it is arranged inside, how TeaVM works.  What is more interesting for you? </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339998/">https://habr.com/ru/post/339998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339988/index.html">A little bit about VIM and IDE</a></li>
<li><a href="../339990/index.html">Plastic: how not to hurt the team by an engraved statuette</a></li>
<li><a href="../339992/index.html">We enter on ‚ÄúMy Circle‚Äù a search for candidates by ‚ÄúHabrahabra‚Äù users</a></li>
<li><a href="../339994/index.html">Flowers, fly and well rehearsed random machine learning</a></li>
<li><a href="../339996/index.html">Ama. Avito. Backend</a></li>
<li><a href="../340000/index.html">Evil XML with two encodings</a></li>
<li><a href="../340002/index.html">Introduction to frequently used features of ES6. Part 1</a></li>
<li><a href="../340006/index.html">And how do you create singletons in ruby?</a></li>
<li><a href="../340008/index.html">Security Week 41: Accenture has posted all on Amazon, a year of malvertization on Pornhub, a fresh attack on Office</a></li>
<li><a href="../340010/index.html">CRI-O - Docker alternative to launch containers in Kubernetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>