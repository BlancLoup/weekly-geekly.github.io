<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PVS-Studio vs Chromium</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This time the victory was won by the good. Or rather, the source code of the project Chromium. Chromium is one of the best projects that we tested wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PVS-Studio vs Chromium</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/df2/da4/94e/df2da494e26d943526802b7bf05ab056.png" alt="PVS-Studio VS Chromium"><br>  This time the victory was won by the good.  Or rather, the source code of the project Chromium.  Chromium is one of the best projects that we tested with PVS-Studio. <br><a name="habracut"></a><br>  <a href="http://www.chromium.org/Home">Chromium</a> is an open source web browser developed by Google and designed to provide users with fast and secure Internet access.  Chromium is based on the Google Chrome browser.  At the same time, Chromium is a preliminary version of Google Chrome, as well as a number of other alternative web browsers. <br><br>  From the point of view of a programmer, Chromium is a solution (solution) consisting of 473 projects.  The total amount of C / C ++ source code is about 460 megabytes.  The number of rows is difficult to calculate. <br><br>  These 460 megabytes include a large number of different libraries.  If you separate them, then there will be about 155 megabytes.  Significantly less, but still a lot.  Moreover, everything is relative.  Many of these libraries are made by the developers of Chromium as part of the task of creating Chromium.  Although such libraries live by themselves, they can be completely attributed to the browser itself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Chromium became the largest and highest quality project I met during the <a href="http://www.viva64.com/en/pvs-studio/">PVS-Studio</a> tests.  When working with the Chromium project, it was actually not very clear who was checking whom.  We found and fixed several errors in PVS-Studio related to the analysis of C ++ files and with the support of a specific project structure. <br><br>  The quality of the source code Chromium says a lot of points and techniques used.  For example, most programmers use the following construction to determine the number of elements in an array: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> XX[] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(XX) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(XX[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br>  This is usually made into the following macro: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> count_of(arg) (sizeof(arg) / sizeof(arg[0]))</span></span></code> </pre> <br>  This is a workable and useful macro.  I myself, to be honest, always used exactly this macro.  However, it can cause an error, since he can accidentally slip a simple pointer, and he will not object to this.  Let me explain with an example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> C[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *B = Foo(); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> x = count_of( A ); <span class="hljs-comment"><span class="hljs-comment">// Ok x = count_of( B ); // Error x = count_of( C ); // Error }</span></span></code> </pre> <br>  The count_of (A) construct works correctly and returns the number of elements in array A, equal to three. <br><br>  But if you accidentally apply count_of () to a pointer, the result will be a meaningless value.  The trouble is that the macro will not warn the programmer in any way about the strange construction of the type count_of (B).  The size of the pointer is divided by the size of the array element.  This situation seems far-fetched and artificial, but I met it in real applications.  As an example, I will give the code from the Miranda IM project: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIZEOF(X) (sizeof(X)/sizeof(X[0])) int Cache_GetLineText(..., LPTSTR text, int text_size, ...) { ... tmi.printDateTime(pdnce-&gt;hTimeZone, _T(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"t"</span></span></span><span class="hljs-meta">), text, SIZEOF(text), 0); ... }</span></span></code> </pre> <br>  So such errors are quite a place to be and it would be nice to be able to defend against them.  It is even easier to make a mistake if you try to calculate the size of the array passed as an argument: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> C[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ x = count_of( C ); <span class="hljs-comment"><span class="hljs-comment">// Error }</span></span></code> </pre> <br>  According to the C ++ standard of the language, the 'C' variable is an ordinary pointer, and not an array at all.  As a result, in programs it is quite often possible to find processing only parts of the transmitted array. <br>  If we are talking about such errors, I will give you a trick, how can you find out the size of the transmitted array.  To do this, pass it to the link: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;C)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ x = count_of( C ); <span class="hljs-comment"><span class="hljs-comment">// Ok }</span></span></code> </pre> <br>  Now the result of the count_of (C) expression is 3. <br><br>  Let's go back to Chromium.  It uses a macro that avoids the errors described above.  Here is its implementation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp;ArraySizeHelper(T (&amp;<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>)[N]))[N]; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> arraysize(array) (sizeof(ArraySizeHelper(array)))</span></span></code> </pre> <br>  The idea of ‚Äã‚Äãthis magic spell is as follows.  The template function ArraySizeHelper accepts an array of arbitrary type with length N as input. At the same time, the function returns an array of 'char' elements with length N. The function is not implemented because it is not needed.  For the sizeof () operator, only the declaration of the ArraySizeHelper function is sufficient.  In the macro 'arraysize', the size of the byte array returned by the ArraySizeHelper function is calculated.  This size is the number of elements in the array, the length of which we want to calculate. <br><br>  If you have a headache, you can take my word for it to work.  And it works much better than the previously considered macro 'count_of ()'.  Since the ArraySizeHelper function takes an array by reference, it is impossible to pass a simple pointer to it.  Let's write a test code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp;ArraySizeHelper(T (&amp;<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>)[N]))[N]; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> arraysize(array) (sizeof(ArraySizeHelper(array))) void Test(int C[3]) { int A[3]; int *B = Foo(); size_t x = arraysize( A ); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Ok x = arraysize( B ); //   x = arraysize( C ); //   }</span></span></span></span></code> </pre> <br>  The erroneous code simply will not be compiled.  In my opinion, this is great if you can prevent a potential error at the compilation stage.  This is a wonderful example that reflects the quality of the approach to programming.  My respect for the developers at Google. <br><br>  I will give one more example, of a completely different plan, but also speaking about the quality of the code. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_util::Delete(db_name, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) &amp;&amp; !file_util::Delete(db_name, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// Try to delete twice. If we can't, fail. LOG(ERROR) &lt;&lt; "unable to delete old TopSites file"; return false; }</span></span></code> </pre> <br>  This code may seem strange to many programmers.  What is the point of trying to delete a file twice?  And there is meaning.  The one who wrote it, reached enlightenment and the essence of being programs.  The file is uniquely deleted or not deleted only in textbooks and the abstract world.  In a real system, it happens that the file just could not be deleted and a moment later - it is possible.  The reason for this may be antiviruses, viruses, version control systems, and God knows what else.  Programmers often do not think about such situations.  They think so, since they did not delete the file, it means that it will not work.  But if you want to do well and not litter in the directories, you need to take into account these extraneous effects.  I came across exactly the same situation when a file is not deleted once per 1000 launches.  And the decision was exactly the same.  Well, except that I just in case Sleep (0) inserted in the middle. <br><br>  But what about the check with PVS-Studio?  The Chromium code is probably the highest quality code I've ever seen.  This is confirmed by the very low density of errors that we could find.  If to take quantitatively, then of course there are a lot of mistakes.  But if you divide this number of errors by the amount of code, then it turns out that there are practically none.  What are these errors?  The most ordinary.  A few examples: <br><pre> <code class="cpp hljs">V512 A call of the <span class="hljs-string"><span class="hljs-string">'memset'</span></span> function will lead to underflow of the buffer <span class="hljs-string"><span class="hljs-string">'(exploded)'</span></span>. platform time_win.cc <span class="hljs-number"><span class="hljs-number">116</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NaCl::Time::Explode(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_local, Exploded* exploded) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ... ZeroMemory(exploded, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(exploded)); ... }</code> </pre> <br>  Mistakes are done by everyone.  It just forgot the star.  It should have been: sizeof (* exploded). <br><pre> <code class="cpp hljs">V502 Perhaps the <span class="hljs-string"><span class="hljs-string">'?:'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> works in a different way than it was expected. The <span class="hljs-string"><span class="hljs-string">'?:'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> has a lower priority than the <span class="hljs-string"><span class="hljs-string">'-'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>. views custom_frame_view.cc <span class="hljs-number"><span class="hljs-number">400</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kClientEdgeThickness; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldShowClientEdge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CustomFrameView::PaintMaximizedFrameBorder(gfx::Canvas* canvas) { ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> edge_height = titlebar_bottom-&gt;height() - ShouldShowClientEdge() ? kClientEdgeThickness : <span class="hljs-number"><span class="hljs-number">0</span></span>; ... }</code> </pre> <br>  Insidious operator "?:" Has a lower priority than subtraction.  Additional brackets are needed here: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> edge_height = titlebar_bottom-&gt;height() - (ShouldShowClientEdge() ? kClientEdgeThickness : <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  A check that does not make sense. <br><pre> <code class="cpp hljs">V547 Expression <span class="hljs-string"><span class="hljs-string">'count &lt; 0'</span></span> is always <span class="hljs-literal"><span class="hljs-literal">false</span></span>. Unsigned type value is never &lt; <span class="hljs-number"><span class="hljs-number">0.</span></span> ncdecode_tablegen ncdecode_tablegen.c <span class="hljs-number"><span class="hljs-number">197</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharAdvance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buffer_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { NaClFatal(<span class="hljs-string"><span class="hljs-string">"Unable to advance buffer by count!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ... }</code> </pre> <br>  The condition "count &lt;0" is always false.  Protection will not work and potentially some kind of buffer may be full.  This is, by the way, an example of how static analyzers can be used to search for vulnerabilities.  An attacker can quickly identify for himself those portions of the code that contain errors for their further, more careful analysis.  And here is another piece of code that might be interesting from a security point of view: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">V511 The </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sizeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> returns size of the pointer, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">not</span></span></span><span class="hljs-function"> of the </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">array</span></span></span><span class="hljs-function">, in '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sizeof</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(salt)</span></span></span><span class="hljs-function">' expression. common visitedlink_common.cc 84</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MD5Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MD5Context* context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>; VisitedLinkCommon::Fingerprint VisitedLinkCommon::ComputeURLFingerprint( ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 salt[LINK_SALT_LENGTH]) { ... MD5Update(&amp;ctx, salt, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(salt)); ... }</code> </pre> <br>  The MD5Update () function will process as many bytes as the pointer takes.  Is there a potential hole in terms of data encryption?  I do not know if there is any danger in all this or not.  But from the point of view of intruders - this is definitely an interesting place for a more detailed study. <br><br>  The correct code should look like this: <br><pre> <code class="cpp hljs">MD5Update(&amp;ctx, salt, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(salt[<span class="hljs-number"><span class="hljs-number">0</span></span>]) * LINK_SALT_LENGTH);</code> </pre> <br>  Or like this: <br><pre> <code class="cpp hljs">VisitedLinkCommon::Fingerprint VisitedLinkCommon::ComputeURLFingerprint( ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 (&amp;salt)[LINK_SALT_LENGTH]) { ... MD5Update(&amp;ctx, salt, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(salt)); ... }</code> </pre> <br>  Another example about a typo: <br><pre> <code class="cpp hljs">V501 There are identical sub-expressions <span class="hljs-string"><span class="hljs-string">'host != buzz::XmlConstants::str_empty ()'</span></span> to the left <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> to the right of the <span class="hljs-string"><span class="hljs-string">'&amp;&amp;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>. chromoting_jingle_glue iq_request.cc <span class="hljs-number"><span class="hljs-number">248</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JingleInfoRequest::OnResponse(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buzz::XmlElement* stanza) { ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> host = server-&gt;Attr(buzz::QN_JINGLE_INFO_HOST); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> port_str = server-&gt;Attr(buzz::QN_JINGLE_INFO_UDP); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (host != buzz::STR_EMPTY &amp;&amp; host != buzz::STR_EMPTY) { ... }</code> </pre> <br>  In fact, you need to check the variable port_str: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (host != buzz::STR_EMPTY &amp;&amp; port_str != buzz::STR_EMPTY) {</code> </pre> <br>  Some of the classics: <br><pre> <code class="cpp hljs">V530 The <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value of function <span class="hljs-string"><span class="hljs-string">'empty'</span></span> is required to be utilized. chrome_frame_npapi np_proxy_service.cc <span class="hljs-number"><span class="hljs-number">293</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NpProxyService::GetProxyValueJSONString(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>* output) { DCHECK(output); output-&gt;empty(); ... }</code> </pre> <br>  Should be: output-&gt; clear (); <br><br>  But there is even a job with a null pointer: <br><pre> <code class="cpp hljs">V522 Dereferencing of the null pointer <span class="hljs-string"><span class="hljs-string">'plugin_instance'</span></span> might take place. Check the logical condition. chrome_frame_npapi chrome_frame_npapi.cc <span class="hljs-number"><span class="hljs-number">517</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ChromeFrameNPAPI::Invoke(...) { ChromeFrameNPAPI* plugin_instance = ChromeFrameInstanceFromNPObject(header); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!plugin_instance &amp;&amp; (plugin_instance-&gt;automation_client_.get())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ... }</code> </pre> <br>  Another example of validation that never works: <br><pre> <code class="cpp hljs">V547 Expression <span class="hljs-string"><span class="hljs-string">'current_idle_time &lt; 0'</span></span> is always <span class="hljs-literal"><span class="hljs-literal">false</span></span>. Unsigned type value is never &lt; <span class="hljs-number"><span class="hljs-number">0.</span></span> browser idle_win.cc <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">IdleState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateIdleState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idle_threshold)</span></span></span><span class="hljs-function"> </span></span>{ ... DWORD current_idle_time = <span class="hljs-number"><span class="hljs-number">0</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">// Will go -ve if we have been idle for a long time (2gb seconds). if (current_idle_time &lt; 0) current_idle_time = INT_MAX; ... }</span></span></code> </pre> <br>  Perhaps we should stop.  I can go on, but it gets boring.  And this is only that which relates to Chromium itself.  But there are still tests with errors like this: <br><br><pre> <code class="cpp hljs">V554 Incorrect use of <span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>. The memory allocated with <span class="hljs-string"><span class="hljs-string">'new []'</span></span> will be cleaned <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-string"><span class="hljs-string">'delete'</span></span>. interactive_ui_tests accessibility_win_browsertest.cc <span class="hljs-number"><span class="hljs-number">306</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AccessibleChecker::CheckAccessibleChildren(IAccessible* parent) { ... <span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;VARIANT&gt; child_array(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VARIANT[child_count]); ... }</code> </pre> <br>  And a huge number of libraries on which Chromium is built.  Moreover, the size of the libraries is much larger than the size of Chromium itself.  And there are also many interesting places in the code.  It is clear that perhaps the code with errors is not used anywhere, but the error from this does not cease to be an error.  One first example (ICU library): <br><pre> <code class="cpp hljs">V547 Expression <span class="hljs-string"><span class="hljs-string">'* string != 0 || * string != '</span></span>_<span class="hljs-string"><span class="hljs-string">'' is always true. Probably the '</span></span>&amp;&amp;<span class="hljs-string"><span class="hljs-string">' operator should be used here. icui18n ucol_sit.cpp 242</span></span></code> </pre> <br><pre> <code class="cpp hljs">U_CDECL_BEGIN <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* U_CALLCONV _processVariableTop(...) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == locElementCapacity &amp;&amp; (*<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span> || *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> != <span class="hljs-string"><span class="hljs-string">'_'</span></span>)) { *status = U_BUFFER_OVERFLOW_ERROR; } ... }</code> </pre> <br>  The expression "(* string! = 0 || * string! = '_')" Is always true.  Apparently it should be: (* string == 0 || * string == '_'). <br><br><h2>  Conclusion </h2><br>  PVS-Studio was defeated.  Chromium code is one of the best codes we have analyzed.  We found almost nothing in Chromium.  Rather, we found a lot of mistakes, and in this article we showed only a small part of them.  But if you consider that all these errors are spread over the source code of 460 megabytes, then it turns out that there are practically none. <br><br>  PS <br><br>  I answer the question: will we let the Chromium developers know about the errors found?  No, we will not inform.  This is a very large amount of work that we cannot afford to do for free.  Check Chromium is not <a href="http://www.viva64.com/ru/a/0070/">a Miranda IM</a> <a href="http://www.viva64.com/ru/b/0090/">check</a> or <a href="http://www.viva64.com/ru/b/0090/">Ultimate Toolbox check at all</a> .  This is a big job, you need to carefully examine all the messages and find out whether this is really a mistake or not.  For this you need to navigate the project.  We will send the translation of this article to the developers of Chromium, and if they are interested, they will be able to carry out a project analysis and analyze all diagnostic messages.  Yes, for this they will need to purchase PVS-Studio.  But any department of Google can easily afford it. <br><br>  Pps <br><br>  No, we are not greedy.  We are ready <a href="http://www.viva64.com/go.php%3Furl%3D688">to help open projects</a> like FlylinkDC ++.  But these are different things. </div><p>Source: <a href="https://habr.com/ru/post/119815/">https://habr.com/ru/post/119815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../119806/index.html">JEEConf in Kiev - on fresh tracks</a></li>
<li><a href="../119809/index.html">Bridge to Success. Tomsk-2011</a></li>
<li><a href="../119810/index.html">Learn all about linguistic annotation of texts at the ABBYY Open seminar.</a></li>
<li><a href="../119811/index.html">What is the main editor / IDE I use for web development on Ruby on Rails?</a></li>
<li><a href="../119814/index.html">We protect DropBox (and other network folders) from prying eyes</a></li>
<li><a href="../119816/index.html">Sencha Touch Tutorial 3: Events</a></li>
<li><a href="../119817/index.html">Stallman's dystopia comes to life</a></li>
<li><a href="../119818/index.html">We look at the positions and platforms of Yandex.Direct in Google Analytics</a></li>
<li><a href="../119821/index.html">What is a honeypot and from what to protect virtual IP?</a></li>
<li><a href="../119822/index.html">On the ‚Äúproblems‚Äù of young entrepreneurs (startupers) in Russia in simple words</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>