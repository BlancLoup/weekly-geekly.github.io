<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pandora's White Box</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When discussing testing, most often the speakers talk about the features of the approach known as the ‚Äúblack box‚Äù. But here we will talk about the opp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pandora's White Box</h1><div class="post__text post__text-html js-mediator-article">  When discussing testing, most often the speakers talk about the features of the approach known as the ‚Äúblack box‚Äù.  But here we will talk about the opposite scenario - the ‚Äúwhite box‚Äù, which allows to formulate questions to the code, understanding its internal structure. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/nr2x5U3_ECI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  The article is based on the interpretation of the report of Nikita Makarov (Odnoklassniki) from our December conference Heisenbug 2017 Moscow. <br><a name="habracut"></a><br><h2>  Theory </h2><br>  At a large number of conferences and in a very large number of books, blog posts and other sources, it is said that testing by the black box method is good and correct, because this is how the user sees the system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/dad/401/dacdad4011d45d639e6a0de134a3f984.png"></div><br>  We kind of join it - we see and test it the same way. <br><br>  This is all cool, but for some reason very little is said about the white box. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b8/5ee/8d0/1b85ee8d07ce41f9e7763b9f13d135ce.png"></div><br><br>  Once I myself was wondering why.  What is white box testing? <br><br><h3>  White box definition </h3><br>  I got to understand.  Started looking for sources.  The quality of Russian speakers was very low, translated from English to Russian - a little higher.  And I got to English-speaking sources ‚Äî right up to Glenford Myers (G. Myers), who wrote a wonderful book, The Art of Software Testing. <br><br>  Literally in the second chapter, the author begins to talk about testing the white box: <br>  ‚ÄúTo meet the strategies associated with testing economics, you should establish some strategies before the beginning.  Two of the most prevalent strategies are testing ... " <br><br><div class="spoiler">  <b class="spoiler_title">Transfer</b> <div class="spoiler_text">  <i>To stay within the reasonable in terms of costs associated with testing, before you begin, you must develop some kind of strategy.</i>  <i>There are two prevalent <b><u>strategies</u></b> : black and white box testing.</i> </div></div><br>  At the end, in the Myers dictionary gives some definition of testing the white box: <br>  "White-box testing - a program of testing." <br><br><div class="spoiler">  <b class="spoiler_title">Transfer</b> <div class="spoiler_text">  <i>White box testing is a type of testing where you explore the internal structure of a program.</i> <br></div></div><br>  What in practice?  Myers suggests building test scenarios, focusing on coverage: <br><br><ul><li>  Statement coverage - coverage of statements in the code; <br></li><li>  Decision coverage <br></li><li>  Condition coverage <br></li><li>  Decision-condition coverage - coverage of conditions and solutions; <br></li><li>  Multiple-condition coverage - combinatorial coverage of conditions and solutions. <br></li></ul><br>  All that Myers talks about was 35 years ago.  What software was written then and what - now?  What code bases did they work then - and now?  A lot has changed.  Coverage is, of course, good, and there are many tools to measure it, which we will discuss below.  But coverage is not everything.  Especially considering the fact that we live in the world of distributed systems, where the bracelet from the hand of a person sends data through the phone to cloud services. <br><br>  What you need to understand now under the white box testing?  We look at the code, understand the structure and dependencies that are in this code, ask questions, draw conclusions and design tests based on this data.  We perform these tests manually or automatically and based on them we obtain new data on the state of our system - how it may or may not work.  This is our profit. <br><br><h3>  Why do you need a white box? </h3><br>  Why should we do all this if we have a black box - that is, how the user sees the system?  The answer is very simple: life is difficult. <br><br>  This is the call stack of a regular modern enterprise application written in Java: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ec/e13/5c4/9ece135c4cc9c3215eb802a81bafa69b.png"><br><br>  Not only in Java, everything is so verbose and plentiful.  In any other language it will look about the same.  What is there? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/168/17f/2bd/16817f2bd46f3aeb98890cb9f9e2d3a1.png"><br><br>  There are web server calls;  security framework, which does authorization, authentication, checks rights and everything else.  There is a web framework and another web framework (because in 2017 it is impossible to just take and write an entertaining application on a single web framework).  There are frameworks for working with a database and converting objects into columns, tables, columns and everything else.  And here there is a small yellow square - this is one challenge to business logic.  Everything under and above it happens in your application every time. <br><br>  Trying to get to this thing somewhere outside with a black box (as the user sees it), you can not test a lot of things.  And sometimes you really need it, especially when user behavior changes something in security, the user is redirected to some other place or something happens in the database.  The black box does not allow you to do this.  That is why you need to climb inside - in the white box. <br><br>  How to do it?  Let's take a look at the practice. <br><br><h2>  Practice </h2><br>  So that there are no wrong or high expectations, let's clarify some details from the very beginning: <br><br><ul><li>  Ready-made recipes will not be.  At all.  All that I will show requires the attachment of a file, hands and head. <br></li><li>  Much depends on the context.  I came from Java development (I‚Äôve been doing this for quite some time).  We have our own tools.  Some may seem miraculous, others - ugly.  Some of them cannot or should not exist in your context.  This is normal.  I came not to show the tools, but to share ideas.  That is why all my examples are simplified to the limit. <br></li><li>  So you can do all this with your development team, you need to have an influence on it.  What do I mean by that?  You should be able to read the code that developers write.  You should be able to speak the same language with them.  Without this, everything I‚Äôm going to talk about next will not work. <br></li></ul><br>  To make my further story more or less structured, I broke it down into three levels.  Let's start with the simplest - easy level. <br><br><h3>  Easy level </h3><br>  As I said, we look into the code and see: <br><br><ul><li>  code is not formatted; <br></li><li>  the code is not written according to the guidelines; <br></li><li>  names of methods, classes and variables does not correspond to what is accepted in the company; <br></li><li>  the code is stylistically incorrect (again, the guidelines do not match); <br></li><li>  any static code analyzer will find a bunch of standard problems for your language; <br></li><li>  Unit tests for code are either not available or are written in such a way that they do not stand up to criticism. <br></li></ul><br>  The fix for this is the very first and simplest thing you can do in the white box testing area.  Static code analysis tools, which are already quite complex today, remarkably cope with all this - such as Sonar for Java and analogues for your languages ‚Äã‚Äã(in fact, Sonar is multilingual and suits almost everyone). <br><br>  I do not want to stay here for long.  There are a lot of interesting reports about this. <br><br><h3>  Medium level </h3><br>  The average level of difficulty is different in scale.  When you work in a small company or team, you are the only tester, you have three or four developers (as well as the industry average), 100 thousand lines of code for everyone, and the code review is performed by throwing the lead developer into who guilty - you do not need any special tools.  But it happens rarely. <br><br>  Large successful projects are usually ‚Äúspread out‚Äù into several offices and development teams.  And the size of the code base starts with a million lines of code. <br><br>  When there is a lot of code in the project, the developers begin to build the formal rules by which this code is written: <br><br><ul><li>  the code should go to certain places, to certain packages; <br></li><li>  the code must be properly formatted; <br></li><li>  it must be inherited from a certain class, it must have the correct logger, the necessary annotations are set so that all metrics on the production are correctly counted and statistics are collected, the exceptions are sent to the right place. <br></li></ul><br>  In other words, as the amount of code grows, formal rules arise that can be checked.  Accordingly, there are tools that allow you to do this. <br><br>  Let's look at an example. <br><br><h3>  ArchUnit </h3><br>  <i><a href="https://goo.gl/kGKF9T">Sample source code</a></i> <br><br>  ArchUnit allows in the form of a more or less problem-oriented language to describe the formal rules of what should or should not be in the code, and to push them in the form of unit-test standards into each project.  So from within the project, ArchUnit allows you to verify that the ‚Äúsanitary minimum‚Äù is observed. <br><br>  So, we have <code>ArchRuleDefenition</code> rule: <br><br><pre> <code class="java hljs">    <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testNoDirectUsagesOfSelenium</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       ArchRule rule = ArchRuleDefinition               .noClasses()               .that()               .resideInAPackage(<span class="hljs-string"><span class="hljs-string">"org.example.out.test"</span></span>)               .should()               .accessClassesThat()               .resideInAPackage(<span class="hljs-string"><span class="hljs-string">"..org.openqa.selenium.."</span></span>);       rule.check(classes);   }</code> </pre><br>  The rule says that no class ( <code>.noClasses()</code> ) that is in the appropriate test <code>org.example.out.test</code> ( <code>org.example.out.test</code> ) should have direct access to the internals of Selenium ( <code>..org.openqa.selenium..</code> ). <br><br>  Let's run this test.  It falls wonderfully: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c86/c39/b72/c86c39b72fa7ed636fa37d0fe9a02ce5.png"><br><br>  At the same time, he writes that we have violated the rule (when a class in such and such a package is knocking on classes that are in a different package).  What is more valuable, in the form of a stack-trace, it shows all the lines where this rule is not respected. <br><br>  ArchUnit is a great tool that allows you to embed such things in the CI / CD cycle, that is, to write tests inside the project that check some architectural rules.  But it has one drawback: it checks everything when the code is already written and commited somewhere (that is, either a commit hook that rejects this commit or something else will work).  And there are situations when it is necessary for bad code to be impossible to write at all. <br><br><h3>  Annotation Processing </h3><br>  <i>Sample source code:</i> <br><br><ul><li>  <i><a href="https://goo.gl/GcuLC3">Library</a></i> <br></li><li>  <i><a href="https://goo.gl/eynhCr">Test Project</a></i> <br></li></ul><br>  In the past Heisenbug in the summer of 2017, my colleague from Yandex, Kirill Merkushev, talked about how code generation solves the problems of test automation.  Who has not watched his speech - please watch, there is a video <a href="https://www.youtube.com/watch%3Fv%3D9mF0zFW7cDQ">here</a> . <br><br>  In fact, code generation can solve many problems.  It allows you not only to create code that you do not want to write, but also to prohibit the creation of code that should not be written.  Let's see how it works. <br><br>  Most code generation works on annotation processing.  I have a project that describes a pair of annotation processors that are specific to the world of Java development ‚Äî in particular, the abstract Pojo.  There is no such thing as a structure in Java programs.  The founding fathers of Java are now thinking of introducing structures into a programming language.  This has already happened in C. We have not yet (although more than 40 years have passed).  But we were able to get out - we have Pojo (plain old java object), that is, objects with fields, getters, setters, but there is nothing in them anymore - no logic. <br><br>  I have an annotation that characterizes a Pojo object, and an annotation that characterizes a Helper is an object with no state, which are crammed with all sorts of procedural methods (pure business logic).  And I have two processors of such annotations. <br><br>  The Pojo annotation processor searches for relevant annotations in the code, and when it finds it, it checks the code for compliance with what Pojo is (or is not).  The Helper annotation processor operates in a similar manner (here is a <a href="https://github.com/kronar/qa-annotations">link to annotations and annotation processors</a> ). <br><br>  How does all this work?  I have a small project, I run a compilation in it: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/8d5/ff1/e0b8d5ff1b839500e5ff7e4502abf2b4.png"></div><br>  I see that it doesn't even compile: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/974/4f3/074/9744f3074432533a1fb29bc6da6a569a.png"><br><br>  This is because this project contains code that violates the rules: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> abc; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> annotations.Pojo; <span class="hljs-meta"><span class="hljs-meta">@Pojo</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnotherFailed</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> point; }</code> </pre><br>  Unlike the previous example, this piece is embedded inside the development environment, into continuous integration, that is, it allows you to cover a larger loop inside the CI / CD cycle. <br><br><h3>  Nightmare level </h3><br>  When you played enough at the previous levels, you want something more. <br><br><h3>  Code coverage </h3><br>  <i><a href="https://goo.gl/YJfQQB">Sample source code</a></i> <br><br>  To measure code coverage, since Myers wrote his book, a lot of different tools have appeared.  They are practically for every programming language.  Here I gave only what I considered popular by the number of links to them on the Internet (you can say that this is wrong - I agree with you): <br><br><ul><li>  Jacoco, Cobertura - Java; <br></li><li>  OpenCover - .NET; <br></li><li>  Coverage - Python; <br></li><li>  SimpleCov - Ruby; <br></li><li>  OpenCppCoverage - C ++; <br></li><li>  cover, gcov - Go. <br></li></ul><br>  In some programming languages ‚Äã‚Äã(for me it was a surprise) - for example, in Python and in Go - tools for measuring code coverage with tests are built into the language itself. <br><br>  There are tools and, moreover, there is an integration of these tools with development environments, when we see this wonderful little thing on the left, indicating that this piece of code is covered by unit tests (green), but this one is not (red). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d12/ae6/00b/d12ae600b6945d0aaffbe42ba432f752.png"><br><br>  And looking at it in the context of unit-tests, I want to ask the question - why can not this be done with integration or with functional tests?  Somewhere you can! <br><br>  But besides the tests, we have users.  We can test anything (the main thing is not to test garbage), but users press in one place, because they use it 95% of the time.  And why it is impossible to make the same beautiful stripes, but only for the code that is used or not used? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5f/75e/262/e5f75e262ff0ef005cabebc5af9466ca.png"><br><br>  In fact, this can be done.  Let's see how. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6e/2e5/113/b6e2e5113ac754fc4e9e7a633f3fb30f.png"></div><br>  Imagine that I am a tester of this application.  And it gets me to regression testing (‚ÄúUrgently, we are on fire, we are doing a mega start-up, we need to check what works and what does not work‚Äù).  I spend with him all these manipulations - everything works, we release to release.  The release is successful, all is well. <br><br>  Six months pass - the situation repeats.  For six months, the developers have changed something there.  What exactly, I do not know.  Can I find out - this is a separate question.  But most importantly - what code is now called?  Have I checked everything by pressing a single button or not all?  It is clear that not everything, but did I miss something important? <br><br>  Answers to these questions can be found if, together with the application, an agent is launched that removes its coverage. <br><br>  I used Jacoco.  You can take any, the main thing is that you can then understand what he intended for you.  As a result of the agent's work, we have a jacoco.exec file: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/643/d30/a00/643d30a007b438e2503490490ce1e8cd.png"><br><br>  From this file, the original application and the application binary, you can create a report from which you can see how it all works. <br><br>  I have a small script that analyzed this thing and created the html folder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efe/4f6/ab4/efe4f6ab4feaad6ab0d9489dc6642ffa.png"><br><br>  The script shows this report: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3b/718/d6f/c3b718d6fe2593ac415db53730da6981.png"><br><br>  In the process of testing, I pushed through something with my hands, but something wasn‚Äôt - in different percentages.  But since we are not ashamed to look in the white box and see what happens inside the application, we know where we need to push. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/760/3fd/0a5/7603fd0a51879d1e0278777fe3f52a5f.png"><br><br>  In this report, the green lines are those lines that I "pushed".  Red - which did not push. <br><br>  If we read this code more or less thoughtfully (even without delving into what is happening inside), we can understand that I did not push through any work related to the failure of the network.  Also, I did not check the cases of receiving a bad status code (that we are not authorized to request the repositories of this organization). <br><br>  To check if the network is down, you can either collapse the grid or inject Fault Injection testing, or you can write another Fault Injection Implementation, putting it in the directory with the application, and get the status code not 200, but, for example, 401. <br><br>  Trying to answer questions about what is being tested by our tests, where our users put pressure on and how one actually relates to another, we in Odnoklassniki created a service that knows how to put everything together.  We do custom service.  We can test some forgotten corner of our large portal, where nobody goes, but what is the value of this? <br><br>  At first we called it Cover.  But then because of a typo of one of our engineers, we renamed it COWOR. <br><br>  KOVYOR knows about our software development cycle, in particular, when to turn on coverage metering, when to turn it off, when to generate reports from this.  And KOVYOR allows us to compare reports on what was, for example, last week, and this;  by what we did autotests, and the fact that people pushed their hands. <br><br>  It looks like this (these are real screenshots from KOVYOR): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be9/086/469/be90864696e331083eed6c9201d861fc.png"><br><br>  We get a side-by-side comparison of the same code.  On the left are autotests, on the right are users.  Red is highlighted that is not pressed, green is what is pressed (in this case, auto tests push a particular piece of business logic much better than users). <br><br>  As you understand, everything can be adjusted: left and right can change, the colors used - too. <br><br>  As a result, we obtain such a fairly simple 2x2 matrix characterizing the code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ca/891/a37/0ca891a374449a376f246191156ea4b4.png"><br><br>  Where we have coverage and autotests, and people - it needs to be compared, and the COWER works with this.  Where there is coverage of autotests, but there are no people, you need to think carefully.  On the one hand, it can be a dead code - a very big problem of modern development.  On the other hand, it can be a functional that is used by people in some extraordinary circumstances (user recovery, unlocking, backup, recovery from backup ‚Äî something that is rarely called). <br><br>  Where there are no autotests, but there are people, obviously, it is necessary to write code, covering these places, and strive for reasonable, good, eternal.  And where there are no autotests or people, first of all, you need to insert some metrics and check that this code is never really called.  After that, you must mercilessly remove it. <br><br>  Code Coverage tools already exist, and you just need to integrate them to yourself.  With them you can: <br><br><ul><li>  use them for introspecting manual testing; <br></li><li>  get the standard of quality for autotests; <br></li><li>  to find with their help the dead code and dead features. <br></li></ul><br><h3>  Meta-information </h3><br>  There is a classic math task about how to pack a backpack: how to pack all the things into a backpack so that they fit in and leave as much space as possible.  I think many of you have heard of her.  Let's look at it in the context of testing. <br><br>  Suppose I have 10 autotests.  They look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dee/346/007/dee3460071ddfa1e6751ae0ebb4cfa84.png"></div><br>  In reality, each autotest runs at different times.  Therefore, at a certain point in time, they look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/382/c3e/63b/382c3e63babf500bf5ece2a8eebcac60.png"><br><br>  And we have two resources on which we run them: <br><br><ul><li>  Resource to run tests number 1 </li><li>  Resource to run tests number 2 </li></ul><br>  I do not know what it is - jenkins slave, virtual machines, docker-containers, phones - anything. <br><br>  If we take these 10 tests and spread them equally into two resources, we get the following picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d83/84c/946/d8384c946c84a66893b295a0caf24b7b.png"><br><br>  This picture is not good and not bad, but it has one feature: the first resource is idle for a long time, and testing on the second resource is still underway. <br><br>  Without changing the number of tests on each of these resources, you can simply regroup them and get just such a picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/752/b9e/e56/752b9ee567e51b8f2c256d1d58da96f9.png"><br><br>  Five tests remained in each resource, but the idle time was reduced - we saved approximately 20% of the testing time.  When we first got this optimization in our hands, it really saved us 20%.  That is, this figure is not from the ceiling, but from practice. <br><br>  If we consider this pattern further, the speed of tests is always a function of how many resources you have and how many tests you have.  Then you have to balance it and somehow optimize it. <br><br>  Why is it important? <br><br>  Because not everything is always the same.  Suppose someone resorts to your Continuous integration server and says that we need to run the tests as soon as possible ‚Äî check the fix and do it as soon as possible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6d/651/2dd/e6d6512dddf766f75d5cd76c649de220.png"><br><br>  You can go on about this man and give him all the possible resources to run tests. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29e/f28/1c5/29ef281c58c0ee79c77eda819c935b82.png"><br><br>  The truth may be that their fix is ‚Äã‚Äãnot very important compared to the current release, which should roll out in two hours.  This is the first. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b2/8f5/ab3/9b28f5ab3a67672ee359990b024e4f5f.png"><br><br>  And second, there are actually not so many tests as you have resources.  That is, the picture I showed earlier, where you have 10 tests and two resources, is a very big simplification.  There can be 200 resources, and 10 thousand tests. And this game, with how many people should be given resources, begins to influence everyone. <br><br>  To play this game correctly, you should always have answers to two questions: how many resources do you have to run and how many tests. <br><br>  If you think long enough about the question of how many resources you have and how many tests you have (especially over the latter), sooner or later you will come to the conclusion that it would be nice to parse the code of your tests and understand that what happens in it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7fb/3ce/d09/7fb3ced096f8c8eac052cdb0b02eac13.png"><br><br>  This thought may seem crazy to you, but do not chase it right away.  All development environments already do this to show you these tips: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b13/7db/ad9/b137dbad9eb0135bc4e899bf55567f18.png"><br><br>  And they are engaged in parsing not only the code, but all dependencies in it. <br>  They know how to do it.  Moreover, all development environments do this well, and some even provide libraries that allow you to solve such problems in literally six lines (at least <a href="http://bit.ly/2j8gype">for Java</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00e/1b0/db8/00e1b0db821a4c1bcff3bd2cdd8c4ac2.png"><br><br>  In these six lines, you parse and completely parse some piece of code.  You can get any meta information out of it: how many fields there are, methods, constructors - anything, including tests. <br><br>  And with all this in mind, we created a service called Berrimor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/878/34e/99587834e62e9fa68d087f8d261113af.png"><br><br>  BERRIMOR knows how to say ‚Äúporridge, sir!‚Äù, And he also knows: <br><br><ul><li>  download the code from the GIT repositories; <br></li><li>  parse code correctly (including regularly); <br></li><li>  highlights meta-information, namely: counts tests;  gets meta information from tests (tags, disabled tests);  knows the owners of the tests. <br></li></ul><br>  BERRIMOR delivers all this data to the outside. <br><br>  I could show you the BERRIMOR interface, but you would still have nothing there.  All its power lies within the API. <br><br><h3>  Social Code Analysis </h3><br>  In 2010, I read Sergei Archipenko‚Äôs lectures on managing software projects and I remember this quote: <br><br><blockquote>  "... the reality that lies in the special specifics of the production of programs, as compared with any other production activity, because what programmers produce is <b>intangible, these are collective mental models recorded in a programming language</b> " (Sergey Archipenkov, Lectures on software project management, 2009). </blockquote><br><br>  The key word is collective.  People have handwriting, but not everyone has it good.  Programmers also have handwriting (and also not always good).  There are some interconnections between people: someone writes a feature, someone patches it, someone repairs it.  These dependencies exist within each team, within each development team.  And they influence the quality of what is happening in the project. <br><br>  Social code analysis is an emerging discipline.  I have identified three videos that are publicly available and can help you understand what it is. <br><br><div class="spoiler">  <b class="spoiler_title">There they are</b> <div class="spoiler_text"><ul><li>  <i><a href="https://www.youtube.com/watch%3Fv%3DHJg5l9KTLBk">Mining Repository Data to Debug Software Development Teams</a> , Elmar Juergens;</i> </li><li>  <i><a href="https://www.youtube.com/watch%3Fv%3D0oDporwhToQ">Seven Secrets of Maintainable Codebases</a> , Adam Tornhill;</i> </li><li>  <i><a href="https://youtu.be/CrzpkF1-VsA%3Flist%3DPLSIUOFhnxEiAeGHYoBZCvEMY5wCOIpyOM%26t%3D1895">How to Flaky Tests in Continuous Integration: Practice Practice at Google and Future Directions</a> , John Micco, Atif Memon.</i> </li></ul><br></div></div><br>  Social code analysis allows you to: <br><br><ul><li>  understand who repairs and who breaks; <br></li><li>  find implicit links in the code.  When you change a class and a test for it, this is an obvious link in the code, and this is normal.  And when you change a class, a test and something else, and this happens every time, this is an implicit connection in the code; <br></li><li>  find hot spots in the code where it is most often fixed, changed, broken; <br></li><li>  find dead code and dead features.  Now it looks very strange (in 2017) that the code was written once in 2013‚Äì2015 and has not changed since then.  Either he is perfect and works well - and the metrics will show it, or he is dead; <br></li><li>  If you know how technical debt looks in your code, you can also find it. <br></li></ul><br>  A little more about the technical debt.  I have a weak technical duty hypothesis. <br><br><ul><li>  There is a bug tracker (issue tracker) on an abstract project in a vacuum.  The bug tracker has all the bugs, tasks, and each of them has some kind of ID; <br></li><li>  there is a Git version control system - in the most simplified case.  Git has commits, and commits have comments where they write links to task IDs; <br></li><li>  My hypothesis is that those files in Git, in which most often something changes for bugs - this is the place of accumulation of technical debt. <br></li></ul><br>  Here at Odnoklassniki it looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/422/c39/bb5/422c39bb54285c1119d3c964ecc38785.png"><br><br>  When I write something and commit, I specify the link to the ticket in Jira.  By virtue of NDA, I cannot show you a social code analysis using the example of the Odnoklassniki repositories.  I will show the example of the open source project Kafka. <br><br>  Kafka has an open issue tracker, an open repository with code: <br><br><ul><li>  <a href="https://issues.apache.org/jira/projects/KAFKA">https://issues.apache.org/jira/projects/KAFKA</a> <br></li><li>  <a href="https://github.com/apache/kafka">https://github.com/apache/kafka</a> <br></li><li>  Beautiful in the <a href="http://bit.ly/2yfc7lA">http://bit.ly/2yfc7lA</a> and <a href="http://bit.ly/2wO5ByG">http://bit.ly/2wO5ByG</a> repository <br></li></ul><br>  Let's see what happens there. <br><br>  So, I have (a <a href="">small utility application</a> ) that raises all the commits in this repository and parses all the comments to them, providing a search on the regular expression <code>Pattern.compile("KAFKA-\\d+")</code> commits that refer to some ticket <br><br>  In the console, you can see that there are only 4246 commits, and there are 1562 commits without such mention. That is, the analysis accuracy is a third less than we would like. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14b/b9b/3cc/14bb9b3cc20eca53e65470a37dfef3ea.png"><br><br>  Then we raise each commit, compose an index from it - which files in it changed (under which ticket).  We compile all these indices into a large hashmap: file name ‚Äî a list of tickets for which this file has changed.  Here's what it looks like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/633/450/d36/633450d36d8b9f0d2830bdad013ea08a.png"><br><br>  For example, we have the KafkaApis file and a number of a huge list of issues for which it has changed (the API changes frequently). <br><br>  Then we go to the issue-tracker Kafka and determine by what issue this thing changed - was it a bug, feature, optimization?  At the output, we get a small hash, where it says what the thing is and what is its priority (all these are just bugs): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/015/c16/a9e/015c16a9eb35cd07547dba8c61dd9316.png"><br><br>  as a result we get the following conclusion: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/665/295/25c/66529525c665cf824d66b14312799245.png"><br><br>  Where we write what percentage of changes were in a particular file: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88f/191/8a7/88f1918a72f74b19df107d0569e99a0e.png"><br><br>  For example, for the top line, the total number of tickets that passed in commits through this file is 231, 128 of them are bugs and, accordingly, 128 are divided by 231 - we get 55% - the share of changes.  Most likely, technical debt is concentrated in these files. <br><br><h2>  Results </h2><br>  I showed you six different examples.  This is not all that exists.  But this means that the white box is primarily a strategy.  How you will implement it on your project - you know better.  Presumably, do not be afraid to get into the code.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is always the whole truth about your project. </font><font style="vertical-align: inherit;">Therefore, read the code, write the code, interfere with the code that programmers write.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/57b/92a/702/57b92a702515335cc848fc3508dfc6b8.png"><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the topic of testing and error handling is as close to you as it is to us, you will certainly be interested in these reports at our May conference </font></font><a href="https://heisenbug-piter.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heisenbug 2018 Piter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li> <a href="https://heisenbug-piter.ru/talks/2018/spb/1jny85xvcg2qqg0c66ccwq/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auxiliary techniques for testing microservices</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Alexander Martyushov, Signavio)</font></font><br></li><li> <a href="https://heisenbug-piter.ru/talks/2018/spb/chexr4uzvkiqciysaogyo/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Web Security Testing Starter Kit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Andrey Leonov, SEMrush)</font></font><br></li><li> <a href="https://heisenbug-piter.ru/talks/2018/spb/beyolylrla4eq244mg4oi/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beta testing of VKontakte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Anastasia Semenyuk, VKontakte)</font></font><br></li><li> <a href="https://heisenbug-piter.ru/talks/2018/spb/3zx0l1uelgac2asiscokki/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the wake of Wild West testing: unusual tricks for common problems</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Vitaly Friedman, Smashing Magazine)</font></font><br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/354434/">https://habr.com/ru/post/354434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354422/index.html">Can't login to AdWords? What to do?</a></li>
<li><a href="../354424/index.html">Digest of IT events for May</a></li>
<li><a href="../354426/index.html">Mother's son's style of girlfriend</a></li>
<li><a href="../354430/index.html">Creating a signature on the template in Outlook for the organization, on computers outside the domain</a></li>
<li><a href="../354432/index.html">These incredibly valuable skills will help you become more successful.</a></li>
<li><a href="../354438/index.html">How JS Works: Animation with CSS and JavaScript</a></li>
<li><a href="../354440/index.html">Black Friday 2017 through the eyes of IT and developers. As we stood black Friday with a 10 times increase in traffic</a></li>
<li><a href="../354442/index.html">What is hidden inside the online cash registers: the development of a fiscal registrar</a></li>
<li><a href="../354444/index.html">Revelations emergency engineer</a></li>
<li><a href="../354448/index.html">More than a state: US foreign debt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>