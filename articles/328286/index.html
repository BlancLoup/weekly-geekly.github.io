<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The delay in online broadcasts from a webcam, you heartless bitch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will talk about the delay that arises when conducting online broadcasts from a webcam from a browser. Why does it arise, how to avo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The delay in online broadcasts from a webcam, you heartless bitch</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/2e2/a79/cc2/2e2a79cc2e7345768275827429c34a82.jpg"><br><br>  In this article we will talk about the delay that arises when conducting online broadcasts from a webcam from a browser.  Why does it arise, how to avoid it and how to make an online broadcast really broadcast in real time. <br><br>  Next, we will show what happens with a delay using the example of <b>WebRTC</b> implementation and how when using WebRTC it is possible to keep the delay at a low level suitable for comfortable communication. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Delay </h2><br>  1-3 seconds already causes slight discomfort in communication.  The lag is already clearly visible and has to adapt to it.  Knowing that there is a lag, you speak like a walkie-talkie, and wait until it reaches the far side and the answer comes.  Such a delay can still be called Roman-Tatiana, in honor of two journalists who go to the video link from the scene. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/252/9af/0e0/2529af0e0457496084c4b6e9bb7cb7bd.jpg"></div><br>  <i>- Roman, can you hear me?</i>  <i>Novel?</i> <i><br></i>  <i>- 3 seconds passed</i> <i><br></i>  <i>- I hear you perfectly.</i>  <i>Tatyana?</i> <i><br></i>  <i>- 3 seconds passed ...</i> <i><br></i>  <i>- Roman, here pii ... what's going on.</i>  <i>Novel?</i> <br><br><h2>  Common delay myths </h2><br>  Below are three common misconceptions related to the delay and quality of video transmission to the Web. <br><br><h3>  I have 100 mbps </h3><br>  1. I have 100 megabits, no problems should be. <br><br>  In fact, it does not matter how many megabits the provider drew in its advertising booklet.  What is important is the actual bandwidth between your device and the remote server or device, including all nodes through which traffic passes.  The provider cannot physically organize 100 Mbps to any arbitrary node on the Internet.  Even the speed of 1 Mbps is not guaranteed.  Suppose your interlocutor is physically located in a remote Brazilian province, and you are broadcasting from a Moscow data center.  No matter how thick and fast your declared channel is, it will not be the same to the final destination. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1e3/76a/7a7/1e376a7a710f43b69ab80de713d8299c.png"></div><br>  Thus, such an unpleasant fact develops - in fact, you do not know what the actual bandwidth of the channel between you and your interlocutor is, and even your provider does not know this, since this is a floating value at each moment in time and for each particular host, with which you exchange information. <br><br>  In addition to bandwidth, the regularity of packet arrival ( <b>no-jittering</b> ) is also important.  You can download videos from torrents at high speeds or see good results in the <b>Speedtest</b> service, but when playing in real time and with minimal delay, it is important to get all the packages on time. <br><br>  It would be ideal if the packets arrived exactly when their decoding and display on the screen is required - a millisecond to a millisecond.  But the network is not perfect and there is a <b>jitter</b> in it.  Packages arrive irregularly - then they are late, then come in batches, which requires their dynamic buffering for smooth playback.  If you drop a lot, the quality deteriorates.  If you buffer a lot, the delay will increase. <br><br>  Therefore, if someone says that he has a good and fast network (in the context of the transfer of real-time video) - do not believe it.  Any node at any time can apply restrictions and begin to drop or delay video packets in its queues and nothing can be done about it.  You can't send a message to all the nodes in the packet path and say <i>‚ÄúHey, don't drop my packets.</i>  <i>I need a minimum delay</i> . <i>‚Äù</i>  More precisely, this can be done by marking the packages in a special way.  But not the fact that the network nodes through which this packet goes will apply it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/7a9/ce4/d83/7a9ce4d83ab44e8b8a8ce6704f5c4053.png"></div><br><h3>  I have a LAN </h3><br>  2. I on the local network exactly delay should not be. <br><br>  In the local network, the delay is really less likely, simply because the traffic passes fewer nodes - at least three: the sender's device, the router, the video receiver's device. <br><br>  These three devices have their own operating systems, buffers, network stacks.  What happens if for example the sender's device actively distributes torrents?  Or if the network stack of the server or CPU is loaded with other tasks or if the office has a wireless network and several employees simultaneously watching YouTube in 720p resolution? <br><br>  With a sufficiently thick (high bitrate) video stream, about 10 Mbps, a router or another node may well begin to drop or delay some packets. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/8f5/036/39d/8f503639db7f4ecaa2e27c7ad9a8a788.jpg"></div><br>  Thus, the delay in the local network is also likely and depends on the bitrate of the video stream and the data processing capacity of the nodes of this network. <br><br>  It is worth noting here that such problems in the average local area network are much less common than in the global network and most often their causes are network overloads or problems with hardware / software. <br><br>  As a result, we argue that <b>any network, including the local one, is not ideal and video packets may be delayed and dropped in it</b> and, in general, we cannot directly affect the intensity and number of dropped packets. <br><br><h3>  I have UDP </h3><br>  3. I use UDP, and when using the UDP protocol there are no delays. <br><br>  Packets sent over UDP can also be delayed or lost in the network nodes and if these packets are not enough to build video and decode, they can be requested by the application again, which will cause a delay in playback. <br><br><h2>  Protocols </h2><br>  While the spacecraft are plying, we realize that there are only two web-based data transfer protocols (protocols that browsers work with): <b>TCP</b> and <b>UDP</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/cf4/7be/e17/cf47bee179014742a305cebbdf70ff10.jpg"></div><br>  <b>TCP</b> - protocol with guaranteed delivery.  This means that sending a packet to the network is an irreversible operation.  If you send data to the network, they will travel there until they reach their destination or until the TCP connection is timed out.  And this is the main reason for the delay when using the TCP protocol. <br><br>  Indeed, if the package was delayed or dropped, it will be sent again and again until the remote side sends a confirmation of the arrival of the package and this confirmation does not reach the sender. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/990/464/c61/990464c616e24777a104290a5d6c5b7c.jpg"></div><br>  The following higher level protocols / technologies are based on the TCP protocol, which are used to transfer live video to the web: <br><br><ul><li>  RTSP (interleaved mode) </li><li>  RTMP </li><li>  HTTP (HLS) </li><li>  WebRTC over TLS </li><li>  DASH </li></ul><br>  All of these protocols <b>guarantee high latency</b> for network problems.  It is important to note that these problems may well be not on the sender or the receiving party, but on any of the intermediate nodes.  Therefore, when trying to determine the cause of such a delay, it is often useless to check the network of the sender of the video stream and the network of the receiving party.  They can be all good and there will be a delay of more than 5 seconds, caused by something in the middle. <br><br>  Considering the above statement: <b>any network is not perfect and video packets can be delayed and dropped in it</b> , we conclude that in order to obtain a guaranteed minimum delay, you must completely abandon the use of TCP-based protocols. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/25e/dd6/f61/25edd6f61d164de1bf6f773a42507f12.jpg"></div><br>  It is not always easy to drop TCP.  In some cases, he has no alternatives.  For example, if all ports except 443 (https) are closed on the corporate Firewall, then the only way to transmit video is to tunnel it to https by organizing the transmission of video packets using the HTTPS protocol based on TCP.  In this case, you will have to put up with an unpredictable delay, but the video will be delivered anyway. <br><br>  <b>UDP</b> is a protocol with non-guaranteed packet delivery.  This means that if you send a packet to the network, it may be lost or delayed, but this will not prevent you from sending other packets afterwards, and the recipient will receive and process them. <br><br>  The advantage of this approach is the fact that the packet will not be sent again and again, as is the case with TCP, waiting for guaranteed confirmation from the recipient at the protocol level.  The recipient decides for himself whether to wait for him when all the packages are assembled in the right order or to work with what is.  In TCP, the recipient does not have such freedom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/2c6/b19/3c9/2c6b193c9b8942bda5fe496e766da297.jpg"></div><br>  There are not many web protocols for transmitting video on UDP: <br><br><ul><li>  WebRTC over UDP </li><li>  RTMFP </li></ul><br>  Here, under WebRTC, we mean the entire UDP-based protocol stack of this technology STUN, ICE, DTLS, SRTP, which works over UDP and ultimately provides video delivery over SRTP. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/267/21e/15e/26721e15e39c4e65be15a157e2232f07.jpg"></div><br>  Thus, using UDP, we are able to deliver packets quickly, with partial losses.  For example, to lose or permanently delay 5% of the sent packets.  The advantage is that we ourselves, at the application level, can decide whether we have enough 95% of the packets received in time to display the video correctly and, if you wish, request the missing packets again at the application level and request them as many times as necessary to a) achieve the required video quality b) keep the delay at a low acceptable level. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d8c/665/10f/d8c66510f46d45c18449cf564326d1c2.jpg"></div><br>  As a result, the UDP protocol does not relieve us from the need to package, but it allows us to implement sending more flexibly, balancing between video quality, which depends on packet loss and latency.  This cannot be done in TCP, because  There is a guaranteed delivery for the design. <br><br><h2>  Congestion control </h2><br>  Before that, we formed a statement that <b>any network is not perfect and video packets may be delayed and dropped in it and we cannot influence this</b> . <br><br>  An overview of the protocols did not give a happy smile on the right, but we came to the conclusion that <b>for low latency, you need to use the UDP protocol and implement packet sending, balancing video quality</b> . <br><br>  In fact, if our packets are dropped or delayed in the network, maybe we send them too much per unit time.  And if we cannot give a command that gives our packets a high priority, then we can reduce the load on these intermediate nodes by sending them less traffic. <br><br>  Thus, the abstract application for <b>low-latency</b> streaming has two main objectives: <br><br><ul><li>  Delay less than 500 ms </li><li>  Maximum possible quality for this delay </li></ul><br>  And these goals are achieved in the following ways: <br><table><tbody><tr><td colspan="2">  <b>Goals</b> </td></tr><tr><td>  <b>Delay less than 500 ms</b> </td><td>  <b>Highest possible quality</b> </td></tr><tr><td><ul><li>  Using UDP Protocol </li><li>  Dynamic detection of network problems </li><li>  Dynamic CPU Load Detection </li><li>  Dynamic Bitrate Reduction </li><li>  Dynamic FPS reduction </li><li>  Dynamic resolution reduction </li></ul><br></td><td><ul><li>  Partial package distribution </li><li>  Dynamic bit rate boost </li><li>  Dynamic FPS boost </li><li>  Dynamic resolution increase </li></ul><br></td></tr></tbody></table><br>  The left column lists ways to reduce latency, and the right one shows things that improve video quality. <br><br>  Thus, the video stream in which low latency is required and the quality is not static and constant and has to flexibly react to network changes over time, requesting to send packets at the right time, lowering or increasing the bitrate depending on the network status at the current time. <br><br>  We give one of the most common questions: ‚ÄúCan I stream 720p live video with a delay of 500 ms‚Äù.  This question, in general, does not make sense, because  The resolution of 1280x720p with a bitrate of 2 Mbps and a bitrate of 0.5 Mbps are two completely different pictures, although both have a resolution of 720p, one will be clear and the other is very diluted with macroblocks. <br><br>  The correct question would be: "Can I stream high-quality 720p video with a delay of less than 500 ms and a bitrate of 2 Mbps."  The answer is yes, you can, if between you and the destination there is a <b>real dedicated 2 Mbps</b> band (not the band indicated by the provider) that allows you to do this.  If there is no such guaranteed band, then the bitrate and picture quality will be floating, in order to fit into the specified delay, with every second adjustment to the existing band. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/54e/ac5/a93/54eac5a938bc48608a8dcaea9a931429.jpg"></div><br>  As you can see, the smile smiles, but asks itself the question ‚ÄúAm I happy?‚Äù.  Indeed, floating bitrate, adaptation of the resolution for bandwidth and partial distribution of packets are compromises that do not allow to simultaneously achieve close to zero delay and true Full HD quality in an arbitrary network.  But this approach allows you to keep the quality close to the maximum at each point in time and control the delay, keeping it at a low level. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/c6d/1cf/75b/c6d1cf75bd3f484ab0d13fe9d819038e.png"></div><br><h2>  Webrtc </h2><br>  Many people criticize WebRTC technology for alleged dampness and redundancy.  However, if you dig deeper into the implementation, it turns out that the technology is quite suitable and does its job well - that is,  Provides real-time audio and video delivery with low latency. <br><br>  Above, we wrote that due to the heterogeneity of the network, to maintain low latency, it is necessary to constantly adjust the flow parameters, such as bitrate, FPS and resolution.  All this work is clearly seen in the usual Chrome browser, in the <b>chrome</b> tab <b>: // webrtc-internals</b> <br><br>  It all starts with a webcam.  Suppose the camera is good and produces a stable video of 30 FPS.  At the same time, this is what can happen with a real video stream: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b35/77b/3a4/b3577b3a489744618c79b04ec3bb1032.jpg"></div><br>  As can be seen from the graph, despite the fact that the camera issues 30 FPS, the real frame rate jumps during transmission in an approximate range of 25-31 FPS and at local minima can reach 21-22 FPS. <br><br>  Simultaneously with FPS, the bitrate is reduced.  Indeed, the less video is encoded, the fewer frames / packets sent to the network, the lower the overall speed of the video stream. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/96a/87a/3c1/96a87a3c15894ff88fa124b0250ff322.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/web/8c0/c1f/fff/8c0c1ffff7ed4cd9b6df7693da487c41.jpg"></div><br>  Auxiliary metrics include RTT, NACK and PLI, which affect browser behavior (WebRTC) and the resulting bit rate and stream quality. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/0aa/89a/111/0aa89a1112c240ad884a07d86a532219.jpg"></div><br>  RTT is Round Trip Time, which refers to the ‚Äúping‚Äù to the receiver. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/6c6/340/4d6/6c63404d6ee143fc83e1642de08d3ba2.jpg"></div><br>  NACK is a message about lost packets sent by the recipient of the stream to the sender of this stream. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/470/de0/405/470de0405aa343ed90472b2918c46fcf.jpg"></div><br>  PLI is a message about a lost keyframe with the requirement of its delivery. <br><br>  Based on the number of lost packets, shares, RTT, you can build conclusions about the quality of the network at any given time and dynamically adjust the power of the video stream so that it does not exceed the limits of the capacity of each specific network and does not clog the channel.  In WebRTC, this is already implemented and works. <br><br><h2>  Testing 720p WebRTC video stream </h2><br>  To begin, let's test the WebRTC video stream broadcasting at a resolution of 1280x720 (720p) and measure the delay.  We will test the broadcast via WebRTC media server <b>Web Call Server 5</b> .  The test server is located at the Digitalocean site in Frankfurt's data center.  Ping to server is 90 ms.  The ISP has a speed of 50 Mbps. <br><br>  Test parameters: <br><table><tbody><tr><td>  Server </td><td>  Web Call Server 5, DO, Frankfurt DC, ping 90ms, 2 core, 2Gb RAM </td></tr><tr><td>  Flow resolution </td><td>  1280x720 </td></tr><tr><td>  System </td><td>  Windows 8.1, Chrome 58 </td></tr><tr><td>  Test </td><td>  Echo test with sending video to the server in one browser window and receiving in another </td></tr></tbody></table><br>  For testing, we used the standard <b>media_devices.html</b> example located at <a href="https://wcs5-eu.flashphoner.com/demo2/media-devices">this link</a> .  The source code of the example is <a href="https://github.com/flashphoner/flashphoner_client/tree/wcs_api-2.0/examples/demo/streaming/media_devices_manager">here</a> . <br><br>  In order to set the resolution of the stream to <b>720p</b> , select the camera and set 1280x720 in the Size settings.  In addition, we set Play / Video / Quality to 0 in order not to use transcoding. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/d23/ab1/ae8/d23ab1ae8aa24540849d9a0dea5bb1c1.jpg"></div><br>  Thus, we send a video stream to a remote 720p server and play it in the window on the right.  The page at this time displays the confirming status of PUBLISHING. <br><br>  Next, we start the timer with milliseconds from the virtual camera and take some screenshots to measure the real delay. <br><br>  Screen 1 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/fbe/df7/f06/fbedf7f06277443a980efda2611bec07.jpg"></div><br>  Screen 2 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/789/265/8d0/7892658d088b47b38e8003a8d7416269.jpg"></div><br>  Screen 3 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/a74/796/518/a74796518d824206a9d249e7e2fe79dc.jpg"></div><br>  Screen 4 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/9dd/71c/cb2/9dd71ccb2eab435585736f3be3345340.jpg"></div><br>  Screen 5 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/38b/793/ce1/38b793ce10484a57870fd87bf235e0ce.jpg"></div><br>  Screen 6 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/2be/0fb/db3/2be0fbdb3f9146cab8001eb77c89be91.jpg"></div><br>  Screen 7 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/312/0fe/422/3120fe42291347a28b21b05f7abce82b.jpg"></div><br>  Screen 8 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/92f/501/a6f/92f501a6f60f4d4c97a83189cb68d3c3.jpg"></div><br>  Screen 9 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/da0/4b6/4a1/da04b64a1c464d5aa5a1595f86eee993.jpg"></div><br>  Screen 10 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/a46/cc1/919/a46cc1919046461598b445145523e1a4.jpg"></div><br><br><h2>  Test results and delay </h2><br>  As a result, we get the following table with the measurement results in milliseconds: <br><table><tbody><tr><td></td><td>  <b>Captured</b> </td><td>  <b>Displayed</b> </td><td>  <b>Latency</b> </td></tr><tr><td>  one </td><td>  09599 </td><td>  09277 </td><td>  322 </td></tr><tr><td>  2 </td><td>  13376 </td><td>  12992 </td><td>  384 </td></tr><tr><td>  3 </td><td>  16256 </td><td>  15866 </td><td>  390 </td></tr><tr><td>  four </td><td>  19198 </td><td>  18751 </td><td>  447 </td></tr><tr><td>  five </td><td>  22394 </td><td>  22022 </td><td>  372 </td></tr><tr><td>  6 </td><td>  25661 </td><td>  25211 </td><td>  450 </td></tr><tr><td width="43">  7 </td><td width="171">  32511 </td><td width="189">  32126 </td><td width="199">  385 </td></tr><tr><td>  eight </td><td>  36166 </td><td>  35839 </td><td>  327 </td></tr><tr><td>  9 </td><td>  40318 </td><td>  39935 </td><td>  383 </td></tr><tr><td>  ten </td><td>  45310 </td><td>  44987 </td><td>  323 </td></tr></tbody></table><br>  We get the following delay schedule for the 720p stream on our minute test: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/92a/037/500/92a0375000b24c319f9ffffc3ba7bec6.png"></div><br>  The 720p test showed a fairly good result with a visual delay of 300-450 milliseconds. <br><br><h2>  WebRTC Bit Rate Charts </h2><br>  Let's see what happens at this moment with the video stream at the WebRTC level.  To do this, instead of the timer, we launch a cartoon in high resolution to see how WebRTC will manage the high bitrate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/2a3/2f0/b54/2a32f0b5435a4d58bcd96140618cfdf2.jpg"></div><br>  Below are graphs of this WebRTC broadcast. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/37c/a2a/041/37ca2a041555461d9c142ef8357f37ff.jpg"></div><br>  From the graphs it can be seen that the bitrate of the stream dynamically changes in the range of 1-2 Mbps.  This is because the server automatically detects a channel shortage and asks Chrome to lower the bitrate from time to time.  The bitrate bar changes dynamically and is indicated on the chart in red by <b>googAvailableSendBandwidth</b> .  Green color indicates the actual <b>googTransmitBitrate</b> bitrate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/0c8/002/a51/0c8002a51705487f86d3307e66119272.png"></div><br>  This is how <b>Congestion Control</b> works on the server side.  In order to avoid network congestion and packet loss, the server constantly adjusts the bitrate and the browser follows the server's commands to adjust the bitrate. <br><br>  At the same time on the width and height graphs everything is stable.  Shipped width is 1280, and height is 720p.  Those.  The sent resolution does not change and the bitrate control occurs without changing the resolution, by lowering the video encoding bitrate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/849/c05/901/849c059017cf49049327c8cbfb3e0eab.jpg"></div><br><h2>  CPU overload control </h2><br>  In order for the resolution not to change, we disabled the use of the <b>CPU detector detector</b> (googCpuOveruseDetection) for the Google Chrome browser on tests. <br><br>  The CPU detector monitors the CPU load and, when a certain threshold is reached, triggers events that cause Chrome to reset the resolution.  By disabling this feature, we allowed the processor to overrun, and fixed the resolution. <br><br><pre><code class="javascript hljs">mediaConnectionConstraints: {<span class="hljs-string"><span class="hljs-string">"mandatory"</span></span>: {<span class="hljs-attr"><span class="hljs-attr">googCpuOveruseDetection</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>}}</code> </pre> <br>  With the use of CPU-detector graphics look smoother, but the resolution of the video stream is constantly switched up and down. <br><br>  To test adaptations, choose a weaker machine.  It will be a Mac Mini 2011 with core i5 1.7 Ghz and Chrome 58. We‚Äôll use the same cartoon as a test. <br><br>  Please note that at the very beginning of the streaming, the video resolution fell by 540x480. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/7d1/433/be5/7d1433be5632454fa1c79126e89807b8.png"></div><br>  As a result, we have the following graphs: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f4c/710/38a/f4c71038a29f47b3afde9b7edfd13c80.png"></div><br>  On the graphs, you can see how the width and height of the image changes, i.e.  Video resolution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b1f/628/e65/b1f628e65cb74c10a6b1f25851e955b7.jpg"></div><br>  And on these graphs it is shown, against the background of what changes there were reductions and increases in width and height. <br><br>  The googAdaptationChanges parameter shows the number of events (adaptations) that Chrome initiated in the streaming process.  The more adaptations passes, the more often the video resolution and bitrate change during video streaming. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/7db/2e6/d92/7db2e6d9290040b9b7d911c0ff6f7140.png"></div><br>  As for the bitrate, its schedule turned out to be more sawtooth, despite the fact that the server did not raise the top bar. <br><br>  This aggressive change in bitrate is due to two things: <br><br><ol><li>  The inclusion of <b>googAdaptationChanges</b> adaptations on the side of the Google Chrome browser, which were caused by increased CPU load. </li><li>  Using the H.264 codec, which encodes differently than VP8 and can greatly reset the coding bitrate depending on the content of the scene. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ba9/eaf/6d2/ba9eaf6d2eb64f5f95ac4b4c31b37f06.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ba3/324/1ed/ba33241edef043d9aeea74f0c9bdaf6a.png"></div><br><h2>  Conclusion </h2><br>  As a result, we did the following: <br><br><ul><li>  We measured the delay WebRTC broadcast through a remote server and determined its average values. </li><li>  They showed how the bitrate of the 720p video stream in the VP8 codec behaves when the adaptations of the CPU are disabled, how the bitrate adapts to the network conditions. </li><li>  Saw the bit rate bar dynamically set by the server. </li><li>  We tested the WebRTC broadcast on a less powerful client machine with adaptation under the CPU and H.264 codec and saw the dynamic adjustment of the video stream resolution. </li><li>  They showed CPU metrics that affect resolution changes and the number of adaptations. </li></ul><br>  Thus, you can answer a few questions that were implied at the beginning of the article: <br><br>  <b>Question</b> : What should be done to make WebRTC broadcast with minimal delay? <br>  <b>Answer</b> : Just make a broadcast.  The resolution and bitrate of the stream are automatically adjusted to the values ‚Äã‚Äãthat provide the minimum delay.  For example, if you set 1280x720, the bitrate can go down to 1 Mbps, and the resolution is 950x540. <br><br>  <b>Question</b> : What should be done to make WebRTC broadcast with minimal latency at a stable resolution of 720p? <br>  <b>Answer</b> : For this, the user channel must actually give at least 1 Mbps and the adaptations of the CPU must be disabled.  In this case, the resolution will not fall and adjustment will occur only due to the bitrate. <br><br>  <b>Question</b> : What will happen to the 720p video stream on the 200 kbps band? <br>  <b>Answer</b> : The picture will be blurred by macroblocks and a low (about 10) FPS.  At the same time, the delay will remain low, but the video quality will be visually very bad. <br><br><h2>  Links </h2><br>  <a href="https://wcs5-eu.flashphoner.com/demo2/media-devices">Media Devices</a> is a WebRTC broadcast test case that was used to test latency. <br>  <a href="https://github.com/flashphoner/flashphoner_client/tree/wcs_api-2.0/examples/demo/streaming/media_devices_manager">Source</a> - the source code of the test translation example. <br>  <a href="https://flashphoner.com/">Web Call Server</a> - WebRTC server <br>  chrome: // webrtc-internals - WebRTC graphics </div><p>Source: <a href="https://habr.com/ru/post/328286/">https://habr.com/ru/post/328286/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328276/index.html">We do deface site using XSS</a></li>
<li><a href="../328278/index.html">Wrong nameless</a></li>
<li><a href="../328280/index.html">PostgreSQL indexes - 3</a></li>
<li><a href="../328282/index.html">Classified ads from social. networks. Looking for a better solution</a></li>
<li><a href="../328284/index.html">Game development based on physical simulation (for realistic destructible game world)</a></li>
<li><a href="../328288/index.html">Returning a customer is easy - don't let him go</a></li>
<li><a href="../328290/index.html">Troubleshooting MySQL Access Permissions: Frequently Asked Questions</a></li>
<li><a href="../328294/index.html">12 tools for debugging .NET-applications for performance and memory</a></li>
<li><a href="../328296/index.html">Philosophy or when the letters were green</a></li>
<li><a href="../328298/index.html">Good in the village in the summer with stagabitnom Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>