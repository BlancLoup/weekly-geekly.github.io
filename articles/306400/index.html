<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Representation of movements in 3D modeling: interpolation, approximation, and Lie algebra</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I would like to talk about one interesting mathematical technique that, being very interesting and useful, is little known to a wide c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Representation of movements in 3D modeling: interpolation, approximation, and Lie algebra</h1><div class="post__text post__text-html js-mediator-article">  In this article I would like to talk about one interesting mathematical technique that, being very interesting and useful, is little known to a wide circle of people involved in computer graphics. <br><br>  How many different ways are there to represent an ordinary rotation in three-dimensional space?  Most people who have ever done 3D graphics or 3D modeling will immediately name three main common options: <br><br><ul><li>  3x3 rotation matrix; </li><li>  The task of turning through Euler angles; </li><li>  Quaternions. </li></ul><br>  People with rich experience will add here for some reason not popular fourth paragraph: <br><ul><li>  The axis of rotation and angle. </li></ul><br>  I would like to talk about the <b>fifth</b> way of representing rotations, which is sympathetic because it is convenient for parametrization, allows you to effectively build polynomial approximations of these parametrization, carry out spherical interpolation, and most importantly, is universal - with minimal changes it works for <i>all</i> kinds of movements.  If you have ever needed a method that would allow you to easily make ‚Äúan analogue of slerp, but not for pure rotations, but for voluntary movements, and even scaling‚Äù, then read this article. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will start with a mathematical description of <i>where</i> the fifth way of representing rotations arises, <i>what exactly</i> is the emerging parametrization, but everyone can skip this section and go straight to the <a href="https://habr.com/ru/company/aligntechnology/blog/306400/">practical part at the end of the article</a> . <br><br><h2>  Lie groups and algebras: at the junction of algebra and differential geometry </h2><br>  Rotations of an object in three-dimensional space (and, in general, any movement of an object) from a mathematical point of view are a typical example of a <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D1%2583%25D0%25BF%25D0%25BF%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">structure called ‚Äúgroup‚Äù</a> .  The group operation here is ‚Äúcombining‚Äù when one motion is first applied and then the second;  This combination is obviously also a movement.  The unit of the group is the "change nothing" trivial movement.  For any movement, you can find the reverse movement, allowing "to return everything as it was."  On the practical side, in relation to geometry, the existence of a group often speaks of the existence of some kind of ‚Äúfeature‚Äù of a given movement, which is preserved within the group.  For example, if we moved an object somewhere by pure rotation, then we can <i>also</i> return it back by <i>pure rotation</i> .  The group of motions of the Euclidean space preserves the distance between the points of the object being moved.  The symmetry group of a cube consists of 48 movements that translate a cube into itself.  This is something that everyone knows more or less. <br><br>  It is easy, however, to note that the group of rotations is arranged in a certain sense ‚Äúmore interesting‚Äù than the group of symmetries of the cube.  So, we know that for rotations it is possible to interpolate continuous motion between any two points (to find a function that smoothly and continuously rotates an object from one position to another), whereas for the 48 elements of the symmetry group of the cube this is obviously impossible.  Another interesting property is the ability to <i>locally</i> parameterize the elements of this group by triples of numbers (for example, Euler angles).  In mathematical terms, all these properties are formalized with the phrase <i>‚Äúa group of rotations is a smooth manifold‚Äù</i> .  That is, we can imagine the space of all possible rotations in three-dimensional space as a certain <i>multidimensional surface</i> like a sphere.  Only here the usual sphere is a two-dimensional surface and it can be placed ( <i>nested</i> ) in three-dimensional space, and the space of rotations is a <i>three-dimensional hypersurface</i> and in order to depict it you will need four-dimensional space;  and to do this without self-intersections, a six-dimensional one, and the surface for a group of rotations obtained in this space would resemble a bagel rather than a sphere topologically.  But the mathematics there is almost the same, so I will use the usual two-dimensional sphere to intuitively illustrate the concept of ‚Äúsmooth manifold‚Äù. <br><br>  We now consider the <i>continuous motion of</i> an object, given by the function of the object's position depending on the moment of time f (t).  For example, f (0) can determine the initial position of the object, f (1) - the final, and f (0.5) will then correspond to the position of the object on the ‚Äúmiddle of the road‚Äù from the starting point to the final one.  Since the individual positions of the object are points on our smooth manifold, then considering f (t) at different points, we can build on our ‚Äúsphere‚Äù a chain of points connecting the starting and ending points on the ‚Äúsphere‚Äù;  in the limit, as it is easy to understand, this chain unites into a continuous curve.  That is, different curves on our manifold are different <i>trajectories of the movement of</i> objects and vice versa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1a8/9ab/4e9/1a89ab4e96344ca0bf64fe41ceeb9eaa.png"></div><br>  <i>Fig.</i>  <i>1. The group of rotations as a smooth manifold (sphere): the points correspond to the initial and final positions of the object, the curve passing through the sphere - the trajectory of its movement</i> <br><br>  Recall now that we still have not some abstract variety, but a group;  and this group has two operations: ‚Äúmultiplication‚Äù and ‚Äútaking the inverse element‚Äù.  We can "act" with these operations on the "sphere."  For example, we can make a so-called.  ‚ÄúLeft shift by the element g‚Äù, multiplying all the points on the sphere to the left by <i>g</i> , i.e.  replacing each element <i>a</i> with <i>g * a</i> .  Since we have a group, this movement preserves our ‚Äúsphere‚Äù as a whole, but it moves certain marked points inside it.  Intuitive interpretation: since we have a group of turns, we can <i>turn</i> our sphere on any of these turns. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f1c/a8a/d51/f1ca8ad51bd04b06b16201662c8faa3b.png"></div><br>  <i>Fig.</i>  <i>2. The action of the group on itself as a turn of the sphere</i> <br><br>  If such operations of the group on itself (multiplication and inversion) do not spoil the smoothness of the curves previously defined on it (they are smooth mappings of the sphere onto themselves), then such a group is called <i>a Lie group</i> .  All practically significant groups of movements are precisely Lie groups. <br><br>  The next interesting observation that we can make is that for smooth curves on smooth manifolds, we can define the concept of the velocity along a curve ‚Äî a <i>tangent vector</i> .  That is, in our case of a moving object, you can determine the <i>speed of rotation of the body</i> at any time, and this speed will be a <i>vector quantity</i> .  In differential geometry, there is a theorem stating that the space of all possible tangent vectors to curves at a given point of an n-dimensional manifold is the n-dimensional linear space ‚Äî the <i>tangent plane at a given point of the manifold</i> .  For example, the speed of rotation of the body can be determined by the axis of rotation and the angular velocity of rotation.  If we multiply the unit vector of the axis direction by the scalar of angular velocity, then we obtain <i>the angular velocity vector</i> , the direction of which defines the axis, and the length - the speed of rotation.  This vector will be an element of this tangent space to the group of rotations.  In the illustration, I use a two-dimensional sphere as a model, therefore the tangent space there is obtained by a two-dimensional tangent plane to this sphere. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/998/eee/63e/998eee63e349428bb923876580490aa4.png"></div><br>  <i>Fig.</i>  <i>3. The speed of rotation as a tangent vector to the trajectory of the object and the tangent plane - as the space of all possible velocities of rotation of the object at the selected point</i> <br><br>  However, due to the fact that the tangent plane is defined for a specific point of the manifold, so far we have defined the ‚Äúobject rotation speed‚Äù for only one specific point (a particular object position), and we would like it for any possible position.  This is where the ‚Äúsmooth action of a manifold on itself‚Äù characteristic of Lie groups comes to the rescue: by defining the tangent vector and the tangent plane of just one point of the manifold (as a rule, one), we can further move the resulting vector and plane to any other point of variety.  To do this, however, we will have to fix some specific way in which we will do this in order to avoid ambiguities, and the classical approach is to use the already mentioned <i>left shift</i> , i.e.  use the multiplication on the left of <i>g</i> to calculate the tangent vector and the tangent plane at <i>g</i> .  This is easy to give an obvious interpretation: suppose we have defined what ‚Äúleft rotation at a speed of 5 degrees per second‚Äù is for an object in position A. How to determine ‚Äúrotation of an object to the left at a speed of 5 degrees per second‚Äù in a different position B?  To do this, you just need to <i>first</i> give the object a turn in the old position, and <i>then</i> (multiply on the left) place the object in the right place with the same turn, which would lead a stationary object from position A to B. Such a notation naturally implies that the movements are <i>from right to left</i> : the action <i>a * b</i> corresponds to the action <i>b</i> , followed by the action <i>a</i> .  Thus, having determined the rotation speed at one point, it is possible to further define the concept of ‚Äúrotation speed‚Äù for all points in space.  The resulting <i>vector field</i> (the mathematician will add: a <i>left-invariant vector field</i> ) on a Lie group is naturally associated with ‚Äújust‚Äù rotational speed, without specifying exactly which point. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b12/fd8/7c3/b12fd87c3d8348178b7358b1e9e5e052.png"></div><br>  <i>Fig.</i>  <i>4. The ‚Äúrotation speed‚Äù determined at one point is naturally defined for all points of the rotation group.</i> <br><br>  As I wrote earlier, the space of all possible angular velocities at one point is a three-dimensional tangent space.  Since this construction works for any tangent vectors, the words ‚Äúat the point‚Äù can be removed here too;  that is, it turns out simply ‚Äúthe space of possible angular velocities of the object‚Äù, and this space is the usual linear space of all conceivable three-dimensional vectors.  This space is called a <i>Lie algebra</i> corresponding to a given Lie group.  Why algebra?  And because for this space the addition and multiplication by a scalar (space <i>linearly</i> ) is already naturally defined, and it is always possible to introduce a special ‚Äúmultiplication operation‚Äù - a <i>Lie bracket</i> with the following properties: <br><br><ol><li>  <i>[x, y]</i> is a bilinear operation with respect to <i>x</i> and <i>y</i> ; </li><li>  <i>[x, x] = 0</i> for any <i>x</i> ; </li><li>  <i>[x, [y, z]] + [y, [z, x]] + [z, [x, y]] = 0</i> for any <i>x, y, z</i> . </li></ol><br>  For our simple case, in addition, from points 1 and 2, the point also follows: <br><ol><li>  <i>[x, y] = - [y, x]</i> for any <i>x, y</i> . </li></ol><br>  As applied to our case of a group of rotations, the Lie algebra, as we have already understood, is the usual three-dimensional space of vectors, and the ‚Äúmultiplication‚Äù in it is a well-known <i>vector product</i> . <br><br>  Groups and Lie algebras play a prominent role in mathematics, since Lie algebra (linear space) is usually a much simpler object than the original group.  For example, in our model example, the original Lie group was a tricky three-dimensional donut embedded in a six-dimensional space, and the Lie algebra was already a usual three-dimensional space.  For the original elements of a Lie group, only the operation of combining rotations was defined and it was not commutative, whereas elements of a Lie algebra can be added together and multiplied by scalars.  But at the same time, the Lie algebra uniquely determines the corresponding Lie group and allows determining its properties (for example, determining the type of group) through the properties of the Lie algebra, which, by and large, reduce to the dimension of the linear space and the matrix describing the Lie bracket through its action on the basis vectors .  However, for practical purposes, we need another important property. <br><br>  Consider an arbitrary smooth trajectory of motion <i>f (t)</i> in our Lie group.  As already mentioned, it can be differentiated by determining the speed <img src="https://habrastorage.org/files/a39/214/7dc/a392147dcf304c80b711b76d4366d28d.png">  in each of the points of the trajectory.  We now take an arbitrary element <i>x</i> from a Lie algebra (an arbitrary angular velocity for our model example).  As previously mentioned, this element corresponds to a smooth vector field <i>x (g) of</i> tangent vectors to all elements <i>g of a</i> variety of a Lie group. <br>  Now consider the following differential equation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b4f/f5e/c6f/b4ff5ec6fcad49d5aa136b6e9fb48226.png"></div><br>  In other words, what will happen if we start from the unit transformation at the moment <i>t = 0</i> and after that we will constantly rotate our body with a fixed angular velocity <i>x</i> ?  In differential geometry and the theory of ordinary differential equations, it is proved that for any preassigned element <i>x</i> of a Lie algebra, this equation has the only possible solution <i>f (x, t)</i> , which is called an <i>integral curve</i> .  The value of this function at time <i>t = 1</i> shows ‚Äúhow far we will go‚Äù from the initial position per unit of time when moving with a fixed angular velocity <i>x</i> and is called the <i>exponential map of the</i> Lie algebra to the Lie group: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/80a/bf6/f5d/80abf6f5d6ac4074acbad00407092137.png"></div><br>  The exponentiation operation is uniquely defined for all elements of a Lie algebra and has a number of convenient properties: <br><ul><li>  <i>Exp (0) = 1;</i> </li><li>  <i>Exp (-x) = (Exp (x)) <sup>-1;</sup></i> </li><li>  <i>Exp (n * x) = (Exp (x)) <sup>n</sup></i> for integer <i>n</i> ; </li></ul><br>  But most importantly, the exponent allows one to trivially reconstruct the mentioned integral curve <i>f (x, t) of</i> motion with a constant angular velocity <i>f (x, t) = Exp (tx)</i> . <br><br>  Moreover, this curve is a <i>geodesic</i> on the original variety of a Lie group and, therefore, a <i>locally</i> shortest path connecting point 1 with any other point.  Using the left shift, this result can be trivially generalized for the trajectory of movement between arbitrary positions <i>a</i> and <i>b</i> .  It is enough to just count <i>g = ab <sup>-1</sup></i> , find an <i>x</i> for which <i>Exp (x) = g = ba <sup>-1</sup></i> , and then the geodesic connecting <i>a</i> and <i>b</i> will be <i>f (t) = a Exp (xt)</i> . <br><br>  Well, in the general case, a geodesic corresponding to a motion with a constant speed <i>x</i> and passing through any element <i>g</i> is <i>f (t, x, g) = g Exp (xt)</i> . <br><br>  Thus, the exponentiation of elements of a Lie algebra makes it possible to naturally determine the optimal interpolation trajectories in the initial Lie group.  The ‚Äúinverse‚Äù operation mentioned here, which, for a given element of <i>g</i> , finds the corresponding angular velocity of rotation <i>x</i> , as you might guess, is called logarithm <i>Exp (Ln (g)) = g</i> . <br><br>  However, unlike the exponent, it is usually ambiguous;  and for some elements of the group, the logarithm may not be defined at all.  For example, if a Lie group consists of several connected components (conventionally speaking, two spheres, and not one), then the integral curves obviously cannot leave a component containing a single element and the logarithm for any elements outside this component is not defined.  The physical meaning of this is rather trivial - if we consider, for example, a group of rotations and <i>mirror symmetries</i> in three-dimensional space, then a trajectory that would continuously translate an object to its specular reflection simply does not exist, and the ambiguity of determining rotation is due to the fact that if an object is continuously rotated, it will regularly return to the same position. <br><br><h2>  Matrix exponentiation and logarithm </h2><br>  From a practical point of view, it is now important to note the small fact that all practically used movements can be written in the form of real matrices of one kind or another.  For example, a group of rotations in three-dimensional space is described by 3x3 matrices with a single determinant, a group of Euclidean motions (rigid body transformation) - 4x4 matrices of the following form: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aff/439/9c4/aff4399c400d41a9a4e4b98c00990f86.png"></div><br>  Which also have a single determinant, etc.  The corresponding groups are subgroups of the common Common Linear Group <i>GL (R, n) of</i> non-degenerate matrices of dimension <i>nxn</i> .  This group is a Lie group, and it corresponds to the Lie algebra gl (R, n), consisting of <i>all</i> matrices of dimension <i>nxn</i> , for which the matrix commutator is a Lie bracket: <i>[A, B] = AB-BA</i> .  And in this algebra, the operations of <i>matrix exponentiation</i> and <i>matrix logarithmization</i> occur naturally, denoted by <i>Exp</i> and <i>Ln,</i> respectively.  The beauty of this fact is that all other particular motion groups are subgroups of this Lie group and they correspond to linear subspaces in the algebra <i>gl (R, n)</i> .  At the same time, they share with the more general group both the Lie bracket and the matrix exponentiation operations, i.e.  regardless of the particular subgroup of motions, the exponent and the logarithm are determined in the same way - through the exponent and the logarithm of the corresponding matrices. <br><br>  In addition to the already mentioned common properties: <br><ul><li>  <i>Exp (0) = 1</i> ; </li><li>  <i>Exp (-A) = (Exp (A)) <sup>-1</sup></i> ; </li><li>  <i>Exp (n * A) = (Exp (A)) <sup>n</sup></i> for integer <i>n</i> ; </li><li>  <i>f (x, g, t) = g Exp (tx)</i> ‚Äîa geodesic passing through <i>g</i> and corresponding to velocity <i>x</i> <br>  the matrix exponential has a number of additional useful properties; </li><li>  If <i>AB = BA</i> then <i>Exp (A + B) = Exp (A) Exp (B)</i> ; </li><li><img src="https://habrastorage.org/files/da2/ace/8e2/da2ace8e2019426e8210c0d7bbea4739.png">  (Taylor series) and this series converges everywhere; </li><li><img src="https://habrastorage.org/files/7b5/40d/4b5/7b540d4b509541e9a6efc308842fa25a.png">  (Mercator series), converges with <i>| A | &lt;1</i> ; </li><li><img src="https://habrastorage.org/files/84d/7de/100/84d7de1005eb432f9fc44183878c744c.png">  ; </li><li><img src="https://habrastorage.org/files/377/bc8/ae9/377bc8ae95434606882afa766ca00cba.png">  . </li></ul><br>  Efficient computation of the matrix exponent and the logarithm is a complex problem, and the most reasonable approach to its implementation is to use the corresponding mathematical library :). <br><br>  Let's see what the Lie algebra matrices look like for some practically significant groups.  For example, our simple group of rotations in the matrix form is written as ‚Äúall 3x3 matrices with a single determinant‚Äù, and its corresponding Lie algebra consists of 3x3 matrices of the following form: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b3c/762/12c/b3c76212c70e465582c22a6272afd180.png"></div><br><br>  Where <i>(x, y, z)</i> is the aforementioned angular velocity vector, which determines the rotational speed according to the principle ‚Äúvector length = angular velocity, direction = axis of rotation‚Äù.  <i>X, y,</i> and <i>z</i> here can be considered as the kinematic equivalent of Euler angles ‚Äî in essence, these are angular velocities of rotation relative to the <i>x, y,</i> and <i>z</i> axes.  But in general, we get just another way of recording rotations in the axis and angle view. <br><br>  If we consider the case of arbitrary motion in three-dimensional space, writing it down by 4x4 matrices of the form <img src="https://habrastorage.org/files/a82/801/5f1/a828015f19d64aa788907aa8af1fd972.png">  , where <i>R</i> is a 3x3 rotation matrix, and <i>T</i> is a 3x1 shift vector, then the corresponding Lie algebra is obtained from matrices: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d73/fac/c4a/d73facc4a73043daa0dfd94516c7c6d3.png"></div><br><br>  Where <i>(rx, ry, rz)</i> has the already mentioned meaning of the vector of angular velocity, and <i>(tx, ty, tz)</i> is the vector of the instantaneous velocity of the body at the point (0,0,0).  The corresponding pairs of vectors are called the <acronym><i>motor of instantaneous velocities of a</i> solid</acronym> , and their use is associated with an elegant and relatively little-known mathematical apparatus of the so-called <i>screw calculus</i> , which deserves a separate article on Habr√©. <br><br>  Want to add more scaling?  Simply add diagonal elements <i>(sx, sy, sz)</i> , corresponding to the speed of "stretching" on each of the axes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/034/cfd/829/034cfd82992a45e79602f46ada02781c.png"></div><br>  But for rigid body motion in 2D, which can be specified by 3x3 matrices, the Lie algebra is obtained from the matrices: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f0a/755/cd9/f0a755cd95134729ae866edb6a04a7b9.png"></div><br>  ... and so on, I think you already caught the idea :).  But anyway‚Ä¶ <br><br><h2>  Why is all this necessary? </h2><br><h3>  Interpolation </h3><br>  As a first example, let's take a simple 2D shape and try to move it in a continuous movement from one position to another.  Parameterize the position of the model <i>(x, y)</i> and the angle of rotation <i>(a)</i> , perform linear interpolation ... <br><div style="text-align:center;"><img src="https://habrastorage.org/files/323/5f8/fb5/3235f8fb5a774d4fbf5a0c4b9eac26b0.gif"></div><br><br>  Everything seems to work, but there is some kind of weak, but clearly perceptible, unnatural movement.  What is the matter?  Let's draw the trajectories along which the points located initially on the left side of the screen move. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b06/e40/a0f/b06e40a0f9834ebc8448fe97eee9fcc0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The lower part, where our airplane is located, is not too similar to a turn: different points move not only at different speeds, but also along different trajectories; however, the strangest thing happens in the upper left corner, where the points make a characteristic reciprocating motion. I did not do the corresponding illustration, because in practice such an artifact is not very common, but I think that among those who are engaged in three-dimensional animation, many have observed such a thing when interpolating at least a couple of times. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what happens if we take the exhibitor instead? Let </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be the matrix of the initial position of the object, and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be the matrix of the final position. We set the position of the object at time </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as</font></font><img src="https://habrastorage.org/files/47c/f94/cf8/47cf94cf82244b538a78f64c99db2922.png">  where <img src="https://habrastorage.org/files/595/929/135/595929135cda4b07ae69cb1b88067ba6.png">  . <br><div style="text-align:center;"><img src="https://habrastorage.org/files/b8e/320/901/b8e32090128d407887bcec0cc6d59379.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0b5/535/432/0b553543247b437f83a3e08d24b33281.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, it turned out a clean smooth turn, in which all points of the object move at a constant speed. Of course, the same result could be achieved without resorting to the exponent, but simply remembering that any movement on a plane is either a parallel translation or a rotation around a certain point at a certain angle. It would be enough to choose the appropriate center of rotation and vary the angle. But the charm of the exponent and the logarithm is that it is an absolute no-brainer, only two or three lines of code that will work with the same success in all circumstances. Need to interpolate motion in 3D? The same formula will automatically give you a screw, even if you do not know the Shalya theorem. Need to interpolate linear motion? The same formula will give a linear transition.An interesting and useful by-property of exponentiation as an interpolation method is that when interpolating the transition between elements of a subgroup, the exponent ‚Äúworks‚Äù especially within this subgroup. That is, if, for example, you have a robot in three-dimensional space that can move only in a certain plane, or, say, rotates about a certain point, then the interpolation between its two positions will automatically occur only in the same plane or rotation relative to this points.rotates about a certain point, the interpolation between its two positions will automatically occur only in the same plane or rotation about this point.rotates about a certain point, the interpolation between its two positions will automatically occur only in the same plane or rotation about this point.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parameterization and approximation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another useful property follows from the fact that a properly defined </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> always gives an element of the group of movements that we are interested in; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> decomposed into a taylor series. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, that is, let's say, we want to find a rotation matrix that will best meet a specific requirement. Let's say we have two pieces of the same surface, and we want to glue them together, for which we select the rotation matrix that best combines the first piece with the second one. To implement the search for such a matrix, we first need to somehow parametrize the space of these matrices. This can be done, for example, using the Euler angles, but when we substitute the resulting matrix with a bunch of sines and cosines, it will be unclear how to solve the resulting optimization problem. We can instead try using the elements of the motion matrix itself as parameters for optimization; this will result in a much simpler optimization problem (quadratic equation in the case of ICP),but there are no guarantees that the affine transformation matrix calculated in this way will be a rotation. There are several ways to circumvent this problem: for example, in a number of papers it is proposed to consider an affine matrix, and then orthogonalize it to the ‚Äúnearest‚Äù rotation. Exponentiation provides one of the interesting alternatives. As mentioned at the beginning, Lie algebra is a much simpler ‚Äúanalog‚Äù of the Lie group (rotations) that interests us.Lie algebra is a much simpler ‚Äúanalog‚Äù of the Lie group (rotations) that interests us.Lie algebra is a much simpler ‚Äúanalog‚Äù of the Lie group (rotations) that interests us.</font></font> Therefore: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we parametrize elements of a Lie algebra (and this is the usual linear space); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> use the exhibitor to return to the group of interest. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first glance, it may seem that this approach is even worse voiced at the beginning of the parameterization by Euler angles, since the matrix exponent in the optimization problem is even more inconvenient to consider than sines and cosines. </font><font style="vertical-align: inherit;">However, for small movements, instead of the exponent, we can simply write its decomposition into a Taylor series:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0a7/e8b/db7/0a7e8bdb718948d5b4d0e20f7c009db8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For small A, this series converges very quickly (for arbitrarily large ones, it also converges, but slowly), by virtue of which it can simply be chopped off on the first or second term after the unit matrix. </font><font style="vertical-align: inherit;">For example, extremely often for small angles use the approximation</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/134/3b5/756/1343b5756a004fa18ddf18ba974c1769.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It parameterizes the rotation matrix with a well-known approximation. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/824/6e4/5ff/8246e45ff37940cc8f7d70c0d5b4192f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">True, usually when this approximation is introduced, then neither the exhibitors nor the Taylor series are mentioned :). However, the ‚Äúlegs‚Äù of this approximation grow precisely from the Taylor series, and now you know how this approximation can be easily continued to 2, 3 and of any order for arbitrary classes of motions (and not just rotations). By the way, the well-known OpenCV-STAM is a special case for a group of three-dimensional rotations, the </font></font><a href="https://en.wikipedia.org/wiki/Rodrigues%2527_rotation_formula"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rodriguez rotation formula</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of this kind of approximations allows us to simplify the optimization problem (for example, to reduce it again to a quadratic one) and does not require a dubious transition with solving the problem for affine matrices and the subsequent design of the result to the desired group. Its only limitation is the requirement for the smallness of the matrix </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but as a rule, to get around it is quite simple. </font><font style="vertical-align: inherit;">It is enough just to parameterize not directly the ‚Äúobject position matrix‚Äù, but ‚Äúthe motion matrix to be applied to the object‚Äù. </font><font style="vertical-align: inherit;">Provided that the object initially stands more or less somewhere in the right place, the necessary ‚Äúshift‚Äù matrix in the whole class of tasks is quite small. </font><font style="vertical-align: inherit;">For example, this approach works well in iterative algorithms, since the step of moving objects on each subsequent iteration into them, as a rule, decreases rapidly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is such a simple, interesting and surprisingly little-known thing. </font><font style="vertical-align: inherit;">Do you use matrix exponents and Lie algebras in your projects :)?</font></font></div><p>Source: <a href="https://habr.com/ru/post/306400/">https://habr.com/ru/post/306400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306390/index.html">Forget about foreign languages ‚Äã‚Äãand music - teach children programming</a></li>
<li><a href="../306392/index.html">How trading on a stock exchange actually works: A simple algorithm (part 1)</a></li>
<li><a href="../306394/index.html">LogicMonitor - a startup that collected $ 130 million</a></li>
<li><a href="../306396/index.html">Old electronics - your personal gold reserve</a></li>
<li><a href="../306398/index.html">Undo and Redo - analysis and implementation</a></li>
<li><a href="../306402/index.html">Online chat in small business: to be or not to be?</a></li>
<li><a href="../306404/index.html">XCOM 2 - parse the mechanics and look at "that's exactly the same, only less and the other"</a></li>
<li><a href="../306406/index.html">Grafana Benefits for Testing</a></li>
<li><a href="../306408/index.html">How we started real MS Excel in PHP and what came of it</a></li>
<li><a href="../306410/index.html">What technologies of computer games are flowing into reality - and a review of technologies in live action games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>