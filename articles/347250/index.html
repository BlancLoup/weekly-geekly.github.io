<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Is javascript a solution to an asynchronous problem?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I want to tell you about my solution to the problem of asynchronous javascript functionality, by the means of introducing a completel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Is javascript a solution to an asynchronous problem?</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article, I want to tell you about my solution to the problem of asynchronous javascript functionality, by the means of introducing a completely asynchronous model of computation.  The concept itself will be described, and a link to the implementation will be given.  Interested please under the cat. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  Let's start with the main thing - synchronously or asynchronously?  When there is a synchronous process of computing and asynchronous functionality without which it can not do, this is a problem.  Moreover, when asynchrony is more advantageous and generally best practice this problem should be solved. </p><br><p>  What is already there to solve?  There are callbacks, there are promises.  But promisses are modified callbacks and only simplify the problem, but do not solve it.  For a real solution to the problem, it is necessary to reduce everything to one model - either completely synchronous or completely asynchronous. </p><br><p>  In the latest standards, there appeared their promises, and then async / await, which together allows us to reduce the computational process to a completely synchronous model.  And it would seem that the problem has been solved, but I have a number of complaints about this solution: </p><br><ul><li>  implementation is far from "elegance" </li><li>  slowly running at the moment </li><li>  produces poorly readable code </li><li>  poorly suited for the organization of "massive" parallelism (without a heap of poorly readable code) </li></ul><br><h2 id="kritikuesh---predlagay">  Criticize - offer </h2><br><p>  Let's forget about async / await, forget about promys, what should it look like?  Conveniently, uniformly, with a minimum of additional code?  Something like a function, only asynchronous: </p><br><ul><li>  what would the definition be like synchronous </li><li>  so that the principle of operation was like that of synchronous </li><li>  what would work inside the synchronous computing process </li></ul><br><p>  That is, it would be good to turn the synchronous JS function into asynchronous.  Let's make a list of steps to accomplish this task. </p><br><ul><li>  The first thing to do, for something like this, is to introduce your own call stack, but not simple, but tree!  The classic call stack is not suitable for massive parallelism. </li><li> Second, do it like this.  so that the top of <code></code> branch is always in the work, so that the stream of execution is guaranteed to be able to return to it in case of leaving. </li><li>  Third, it is a refusal to synchronously return a function, and a replacement for an asynchronous alternative, in which you can wait for something before returning the result.  That is, we need a return on command, and not in the no-alternative order of execution, uncontrollably striving for completion. </li><li>  Fourth, it is to move away from the synchronous computing process, inside the synchronous function, so that the synchronous calls of this function just ‚Äúpump‚Äù the asynchronous process. </li><li>  Fifth and last, it is a pair of wrapper functions for asynchronous call / return, which are all that needs to be expanded where necessary.  Let them be called <code>call</code> and <code>back</code> . </li></ul><br><h2 id="vpered-v-debri">  Forward to the wilds! </h2><br><p>  Let's try to portray it all.  By condition, the definition of an asynchronous function should be exactly the same as synchronous. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }</code> </pre> <br><h3 id="nachnem-s-poslednego">  Let's start with the last </h3><br><p>  Let the <code>call</code> : </p><br><ul><li>  has parameters: current vertex, name of function to call, arguments for this function </li><li>  creates a new vertex for this branch, leaving a link to the current </li><li>  calls the specified function with the specified arguments </li></ul><br><p>  Let <code>back</code> : </p><br><ul><li>  has parameters: current vertex, result </li><li>  deletes the current vertex for the given branch, follows the link to the previous one </li><li>  calls the function specified for the previous vertex, with the result returned by the function of the current vertex. </li></ul><br><h3 id="teper-vvedem-derevo-vyzovov">  Now we introduce the call tree </h3><br><p>  Here the first 2 points are performed: </p><br><ul><li>  Let there be a certain initial vertex, the root of the tree, and all the challenges begin from it </li><li>  let the vertex be passed as an argument to the function being called. </li><li>  Let the vertex be the only parameter of the function being called, and everything necessary, including the current arguments of this function, is stored in it. </li><li>  when called, the top of this branch is captured by the execution context of the function </li><li>  on a subsequent call, the vertex becomes a branch node, the new vertex is captured by the context of the new function called </li><li>  with asynchronous functionality, for example ajax, the vertex is stored in the closure </li><li>  in general: the current call -&gt; further call |  waiting in closure |  return </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> top </span></span></span><span class="hljs-function">) </span></span>{ }</code> </pre> <br><h3 id="sinhronnyy-vozvrat-nam-bolshe-ne-drug">  Synchronous return is no longer our friend </h3><br><p>  Paragraph three, as already described above, a special method-wrapper <code>back</code> , when called (team), goes one node back through the call tree.  Thus, asynchronous return is performed.  We will immediately agree that the synchronous return (return) is no longer taken into account, and the asynchronous call continues to exist even after a synchronous return. </p><br><h3 id="esche-ne-vse-ne-vse-tak-prosto">  Not everything, not everything is so simple </h3><br><p>  From the above it becomes clear that there will be more than one call to a specific synchronous function turned into asynchronous: </p><br><ul><li>  The first call is actually a classic function call; see the description of <code>call</code> </li><li>  the second and subsequent ones - to return from the asynchronous subcall, see the description </li></ul><br><p>  We need a way to catch, or isolate pieces of code needed for each particular call, and transfer the flow of execution to that particular place.  In addition, you need the ability to save data between sub-call returns, since the execution context disappears after each synchronous return.  We introduce the following: </p><br><ul><li>  let <code>mark</code> be entered in <code>top</code> </li><li>  let <code>call</code> set <code>mark</code> to <code>#</code> </li><li>  let <code>back</code> put a <code>mark</code> equal to the function name from the current vertex (which is deleted) </li><li>  let <code>switch</code> handle the flow of execution </li><li>  Let the data, which should be available all the time, before an asynchronous return ( <code>back</code> ), is written directly to <code>top.x = 1</code> ; </li></ul><br><div class="spoiler">  <b class="spoiler_title">We look</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> top </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( top.mark ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'B'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'C'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> </div></div><br><p>  Putting it all in place: </p><br><ul><li>  let <code>call</code> put the passed arguments in <code>top.arg</code> </li><li>  let <code>back</code> put the transferred result in <code>top.ret</code> </li></ul><br><div class="spoiler">  <b class="spoiler_title">We look</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> top </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( top.mark ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#'</span></span>: call(top, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'B'</span></span>: call(top, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, top.ret + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'C'</span></span>: back(top, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: top.ret}); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> </div></div><br><p>  From the example above it can be seen that a normal synchronous function is obtained, only stretched, and with the ability to wait for an asynchronous operation before returning.  You can also notice the splitting into steps, and their sequential execution.  Consider this, and the fact that the call tree is used, not the stack, and add parallelism: </p><br><ul><li>  let the <code>size</code> field be entered in <code>top</code> </li><li>  let <code>call</code> increase the <code>size</code> current vertex by one </li><li>  let <code>back</code> reduce the <code>size</code> previous vertex by one (the current one is destroyed) </li></ul><br><div class="spoiler">  <b class="spoiler_title">We look</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> top </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( top.mark ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#'</span></span>: top.buf = []; call(top, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data1'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data2'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data3'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'B'</span></span>: top.buf.push(top.ret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !top.size ) { call(top, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, top.buf); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'C'</span></span>: back(top, top.ret); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> </div></div><br><p>  It turns out that it is possible to start a massive parallel task, at any sequential step of the general asynchronous process of the function execution.  It is also an opportunity to wait for the completion of this task and accumulate the result.  Let's improve this, namely, we take into account the fact that the <code>top.ret</code> result of a specific function is not always needed, and it would be nice to be able to run different functions in parallel in one task: </p><br><ul><li>  let new <code>group</code> field be entered in <code>top</code> </li><li>  let <code>mark</code> be replaced by <code>group['#name']</code> </li><li>  let <code>size</code> be replaced by <code>group['#size']</code> </li><li>  Let the new groupMark parameter be entered in the <code>call</code> </li><li>  let <code>call</code> increase <code>top.group[groupMark]</code> current vertex by one </li><li>  let <code>back</code> decrease <code>top.group[groupMark]</code> previous vertex by one (the current one is destroyed) </li><li>  Let <code>call</code> and <code>back</code> control the value of the special names <code>top.group['#name']</code> and <code>top.group['#size']</code> containing the name and size of the current group </li></ul><br><div class="spoiler">  <b class="spoiler_title">We look</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> top </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( top.group[<span class="hljs-string"><span class="hljs-string">'#name'</span></span>] ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#'</span></span>: top.buf = []; call(top, <span class="hljs-string"><span class="hljs-string">'#group1'</span></span>, <span class="hljs-string"><span class="hljs-string">'B1'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data1'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'#group1'</span></span>, <span class="hljs-string"><span class="hljs-string">'B2'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data2'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'#group1'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data3'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#group1'</span></span>: top.buf.push(top.ret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !top.size ) { call(top, <span class="hljs-string"><span class="hljs-string">'#group2'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>, top.buf); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#group2'</span></span>: back(top, top.ret); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> </div></div><br><p>  Add another opportunity to wait for the end of several running groups, and that's it :) </p><br><ul><li>  Let <code>top.group['##size']</code> contain the sum of all <code>top.group['#size']</code> </li><li>  let <code>top.group['##name']</code> containing the name of the group with which this function was called (return group name) be entered </li></ul><br><div class="spoiler">  <b class="spoiler_title">We look</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> top </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( top.group[<span class="hljs-string"><span class="hljs-string">'#name'</span></span>] ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#'</span></span>: top.listB = []; top.listC = []; call(top, <span class="hljs-string"><span class="hljs-string">'#group1'</span></span>, <span class="hljs-string"><span class="hljs-string">'B1'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data1'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'#group1'</span></span>, <span class="hljs-string"><span class="hljs-string">'B1'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data1'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'#group1'</span></span>, <span class="hljs-string"><span class="hljs-string">'B2'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data2'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'#group2'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data1'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'#group2'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data1'</span></span>); call(top, <span class="hljs-string"><span class="hljs-string">'#group2'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'some_data2'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#group1'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (top.ret) {top.listB.push(top.ret);} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !top.group[<span class="hljs-string"><span class="hljs-string">'##size'</span></span>] ) { back(top, {<span class="hljs-attr"><span class="hljs-attr">B</span></span>: top.listB, <span class="hljs-attr"><span class="hljs-attr">C</span></span>: top.listC}); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'#group2'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (top.ret) {top.listC.push(top.ret);} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !top.group[<span class="hljs-string"><span class="hljs-string">'##size'</span></span>] ) { back(top, {<span class="hljs-attr"><span class="hljs-attr">B</span></span>: top.listB, <span class="hljs-attr"><span class="hljs-attr">C</span></span>: top.listC}); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> </div></div><br><h2 id="itog">  Total </h2><br><p>  The above describes the concept of an asynchronous function, which allows for the introduction of a fully asynchronous computation model, and in doing so: </p><br><ul><li>  simplicity and orderliness of the code is preserved </li><li>  uniformity guaranteed </li><li>  The speed of work is much higher than that of async / await, at the moment (depends on the implementation) </li><li>  wide possibilities for organizing parallel computing </li></ul><br><p>  I have developed a fairly successful <a href="https://github.com/username-rus/qkit">implementation of this concept</a> , with an emphasis on parallel computing.  A key feature is stream support (WebWorker) and the possibility of asynchronous function calls, no matter what stream they are in. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347250/">https://habr.com/ru/post/347250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347236/index.html">InfoWatch Group of Companies has summed up the year</a></li>
<li><a href="../347238/index.html">What's new for mobile developers in Visual Studio 15.6 Preview</a></li>
<li><a href="../347242/index.html">Apply the KISS principle to the design principles themselves.</a></li>
<li><a href="../347244/index.html">What engineers read GridGain. Books for those interested in In-Memory Computing</a></li>
<li><a href="../347246/index.html">An honest approach to managing people, or why I never do counteroffers</a></li>
<li><a href="../347252/index.html">How neural networks help in e-learning</a></li>
<li><a href="../347254/index.html">Understanding Meltdown and Specter: What you need to know about new vulnerabilities found in almost all CPUs</a></li>
<li><a href="../347256/index.html">Making games in Python 3 and Pygame: Part 3</a></li>
<li><a href="../347258/index.html">Why salt HTTP callbacks</a></li>
<li><a href="../347260/index.html">How to find a good marketer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>