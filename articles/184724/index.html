<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ragdoll physics do-it-yourself. Part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I decided to write a game. For yourself and for your pleasure. There was a choice in front of me - to use all the ready aka Box2D or write the ph...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ragdoll physics do-it-yourself. Part one</h1><div class="post__text post__text-html js-mediator-article">  Once I decided to write a game.  For yourself and for your pleasure.  There was a choice in front of me - to use all the ready aka <a href="http://box2d.org/">Box2D</a> or write the physics for it myself.  The second option seemed to me more interesting, and I began to look for information in the open spaces of the network that would help me write everything I needed.  I found.  As a result, a very flexible (as for the game) and simple physics engine was obtained.  The basis of the engine was the Verlet numerical integration method. <br><br><img src="https://habrastorage.org/storage2/046/f4f/fd8/046f4ffd838969d986f2bda6af4de58c.png"><br><br><a name="habracut"></a><br>  Werle's method describes the movement of material points in time.  For this there are different methods.  For example, such a system of equations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/197/109/1f5/1971091f5ce5d8d474950f01b33bf27d.png"><br>  Combining 2 equations, we get <br><br><img src="https://habrastorage.org/storage2/cb2/f5b/176/cb2f5b176aa4dd6b55f6cf97435beec2.png"><br>  The Verlet equation is not much different from the above entry. <br><br><img src="https://habrastorage.org/storage2/874/f80/685/874f806859eb9508b3fb95bbebda91cc.png"><br>  As you can see, in the Verlet method, the velocity of a point is expressed in terms of the difference between its current and old coordinates.  Great, we have less trouble.  The accuracy of calculations from this decreases, but we are not counting atomic reactors.  Plus it makes collision calculation so ridiculously simple.  Consider the movement of a point by example: <br><br><img src="https://habrastorage.org/storage2/091/419/736/0914197361679a574cc21884a923549c.png"><br>  We see that the current and old coordinates of the point are chosen in such a way that it inevitably moves to the right towards the blue square.  Looking forward a bit, I‚Äôll say that when a collision with a square is detected, to handle this collision it‚Äôs enough to bring the current coordinate of the point outside the square.  Everything.  Since the speed here is expressed in terms of the difference of coordinates, a change in the current or old coordinate automatically leads to a change in the speed of movement of a point. <br><br><img src="https://habrastorage.org/storage2/9fb/7f0/5d8/9fb7f05d83e3b726bd111930eb427c25.png"><br>  If you put all this into C ++ code, you get something like that. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> Vec2 Position; Vec2 OldPosition; Vec2 Acceleration; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Physics</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PointCount; Point* Points[ MAX_VERTICES ]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Timestep; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateVerlet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Physics::UpdateVerlet() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I = <span class="hljs-number"><span class="hljs-number">0</span></span>; I &lt; PointCount; I++ ) { Point&amp; P = *Points[ I ]; Vec2 Temp = P.Position; P.Position += P.Position - P.OldPosition + P.Acceleration*Timestep*Timestep; P.OldPosition = Temp; } }</code> </pre> <br>  This is enough to describe the movement of material points.  And it‚Äôs good if you only plan points in the game.  If you want something more interesting, you need to make solid bodies.  In nature, a solid body is a lot of point-atoms, interconnected by the mystical forces of nature.  Alas, for the simulation of physics in the game, this method is poorly suited, not a single computer will be able to withstand the calculations of billions and billions of points and connections between them.  Therefore, we will manage by modeling the vertices of physical bodies.  For a square this way 4 points and connections between them will be enough.  It remains only to describe these links.  Obviously, the distance between the vertices should remain constant.  If the distance between the peaks will change, the body will be deformed, but we do not want it (those who want it while they are silent).  How to keep the distance between peaks constant?  In reality, to solve this problem, it would be enough to shove a reinforcement of the appropriate length between the vertices.  Without further ado, we will do the same in our simulation.  Let's create a class that will describe this imaginary reinforcement, keeping the vertices at the required distance.  The algorithm that performs this work will be called immediately after processing the motion of the vertex points.  In essence, it is very simple.  We calculate the vector between two vertices connected by our imaginary reinforcement and compare the length of this vector with our reference length.  If the lengths are different, we just have to move / move the vertices to the required distance, so that the lengths will coincide again and voila - it's in the bag. <br>  This is how it all looks in the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Edge</span></span></span><span class="hljs-class"> {</span></span> Vertex* V1; Vertex* V2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> OriginalLength; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Physics::UpdateEdges() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I = <span class="hljs-number"><span class="hljs-number">0</span></span>; I &lt; EdgeCount; I++ ) { Edge&amp; E = *Edges[ I ]; <span class="hljs-comment"><span class="hljs-comment">//    Vec2 V1V2 = E.V2-&gt;Position - E.V1-&gt;Position; float V1V2Length = V1V2.Length(); //    float Diff = V1V2Length - E.OriginalLength; V1V2.Normalize(); //  E.V1-&gt;Position += V1V2*Diff*0.5f; E.V2-&gt;Position -= V1V2*Diff*0.5f; } }</span></span></code> </pre><br>  This is how it is.  If you create several vertices and connect them together with such sides, the resulting body will exhibit the properties of a solid body, including rotation caused by collision with other bodies and the floor.  How does all this work?  After all, we just added a new rule to maintain the distance between points, and here on - just a solid body.  The secret is in the very method of integrating Verlet.  As we remember, this method does not operate with speeds, instead it uses the difference between the coordinates of the current and the old position of the point.  As a result, the speed will also change as the coordinate changes.  And to maintain a constant length between the vertices, we just change their coordinates.  The final change in the velocity of the vertices gives an effect that is approximately reminiscent of the behavior of solids.  More precisely almost solid.  In the form in which the code is now, the body will be deformed when it hits the floor and each other.  Why?  Everything is very simple.  If the vertex is attached to more than one side, and usually will occur, the adjustment of the length of one of the sides will automatically lead to a change in the length of the other side. <br><br><img src="http://habrastorage.org/storage2/685/492/fac/685492faca6b21e3b8eb800c946ed91c.png"><br>  The only method of treating this disease is the multiple challenge of the function, the corrective length of the parties.  The more times it is called, the more accurate the approximation will be.  How many times to do it depends only on your imagination.  This concludes the first part of the article.  The next part will cover such moments as the detection and handling of collisions between bodies and also some feints with ears that can be done using this method. <br><habracut></habracut></div><p>Source: <a href="https://habr.com/ru/post/184724/">https://habr.com/ru/post/184724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184714/index.html">Rock and roll is dead and there is no mud yet</a></li>
<li><a href="../184716/index.html">A team of mathematicians wrote a 600-page book in six months using GitHub</a></li>
<li><a href="../184718/index.html">GoPro history + Hero 3 Black Edition review</a></li>
<li><a href="../184720/index.html">‚ÄúHappy Autumn‚Äù: Happy Farm announces a competition of IT startups - residents of the third cycle</a></li>
<li><a href="../184722/index.html">Three useful monads</a></li>
<li><a href="../184726/index.html">The game on JavaScript "Corners"</a></li>
<li><a href="../184728/index.html">Digital Smoothing</a></li>
<li><a href="../184730/index.html">Introduction to Lightweight modular staging and Scala virtualized</a></li>
<li><a href="../184732/index.html">Writing ORM for Delphi</a></li>
<li><a href="../184734/index.html">The site Boeing the opportunity to track the position of the aircraft is almost like in the simulator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>