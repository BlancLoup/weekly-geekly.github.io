<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In search of cryptographic GPSN</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi% username%! 

 In today's post we will talk about the cryptographic strength of pseudo-random number generators (PRNG). 
 To begin with, let's defi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In search of cryptographic GPSN</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/storage3/246/86c/3d3/24686c3d3cbe4d6afd0aa459f1821327.png"></div><br>  Hi% username%! <br><br>  In today's post we will talk about the cryptographic strength of pseudo-random number generators (PRNG). <br>  To begin with, let's define what crypto-resistant PRNG is (CGPSN). <br><blockquote>  KSGPSCH must satisfy the "test for the next bit."  The meaning of the test is as follows: there should not be a polynomial algorithm that, knowing the first k bits of a random sequence, can predict k + 1 bits with a probability of more than 50%. </blockquote>  <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8_%25D1%2581%25D1%2582%25D0%25BE%25D0%25B9%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B3%25D0%25B5%25D0%25BD%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25BF%25D1%2581%25D0%25B5%25D0%25B2%25D0%25B4%25D0%25BE%25D1%2581%25D0%25BB%25D1%2583%25D1%2587%25D0%25B0%25D0%25B9%25D0%25BD%25D1%258B%25D1%2585_%25D1%2587%25D0%25B8%25D1%2581%25D0%25B5%25D0%25BB">Wikipedia</a> <br><br>  Perhaps some of the readers used GPSN such as linear feedback shift registers (RLOS) or Mersenne's Whirlwind beloved by many programmers.  I will try to show that both of these methods, despite the very good statistical properties and large periods, do not meet the above definition and cannot be considered cryptographically stable, and also offer, as an alternative, two very reliable PRNGs. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Shift register with linear feedback </h4><br>  Often it was possible to see how this method was proposed to be used for cryptographic purposes, therefore, with it, in fact, we begin.  Generators of this kind consist of a shift register and feedback function. <br><img src="https://habrastorage.org/storage3/7ab/ea2/c0b/7abea2c0b5b4947b8b595fa0e388dbd7.png"><br><br>  Each PRNG on RLOS is associated with a specific polynomial, which characterizes the register length and the feedback function.  For example, a polynomial <img src="https://habrastorage.org/storage3/d4e/adc/6b9/d4eadc6b9451114bde463fad03c5f297.png">  matches the following register: <br><img src="https://habrastorage.org/storage3/bf2/ce1/5ad/bf2ce15ad8ebdfbf78d600bb42a5e0cd.png"><br><br>  The degree of the polynomial determines the length of the register, non-zero members describe which elements of the register constitute a diversion sequence. <br>  If the polynomial forming the diversion sequence is irreducible modulo 2, then the period generated by the register sequence will be maximum and calculated by the formula <img src="https://habrastorage.org/storage3/001/669/636/00166963633b973d478b773c70f7d3dc.png">  . <br><br>  Before starting work, an arbitrary sequence of bits is entered into the register, which is called the initial state.  After that, each clock cycle returns 1 bit, which looks completely random. <br>  By themselves, RSLOS are good PRNGs, but due to the fact that the bits obtained with their help have a linear relationship, it is unwise to use RSLOS for cryptographic purposes. <br>  If an attacker receives a sequence of bits of length n generated by the LFSR, he can load these bits into the register and scroll back to get the initial state.  Knowledge of the initial state will give it access to all sequences generated earlier and generated in the future. <br><br>  Hiding case information may seem like a good idea.  Then, even having received a sequence of length n, the attacker cannot take steps to open the initial state. <br>  But this situation is easily solved using the Berlekamp ‚Äì Massey algorithm.  This algorithm allows to reveal a polynomial associated with RSLOS.  To do this, it is sufficient to have a register-generated sequence of only 2n length. <br>  The algorithm is quite simple to implement: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BerlekampMassey</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = array.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N]; b[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; c[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; N; n++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= l; i++) { d ^= c[i] * array[n - i]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == <span class="hljs-number"><span class="hljs-number">1</span></span>) { Array.Copy(c, <span class="hljs-number"><span class="hljs-number">0</span></span>, t, <span class="hljs-number"><span class="hljs-number">0</span></span>, N); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N_M = (nm); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; N - N_M; j++) { c[N_M + j] ^= b[j]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt;= n / <span class="hljs-number"><span class="hljs-number">2</span></span>) { l = n + <span class="hljs-number"><span class="hljs-number">1</span></span> - l; m = n; Array.Copy(t, <span class="hljs-number"><span class="hljs-number">0</span></span>, b, <span class="hljs-number"><span class="hljs-number">0</span></span>, N); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br>  The input is a sequence of bits generated using the LFSR.  As a result, a polynomial characterizing the feedback scheme is returned. <br><br>  Of course, the LFSR can be cascaded for a more robust PRNG.  This idea is used in some stream ciphers.  However, many generators based on this method are vulnerable to so-called correlation attacks.  I gave some details about this type of attack in my recent post <a href="http://habrahabr.ru/post/186838/">GSM Security: Data Encryption</a> .  Here I will only say that with the help of a correlation attack, an attacker, possessing a sequence of generated PRNG, has the ability to restore the initial value and gain access to all values ‚Äã‚Äãgenerated in the future. <br><br><h4>  Whirlwind of mersenne </h4><br>  In my opinion, the PRNG called the Mersenne Whirlwind is much more interesting.  There are several variants of the algorithm. We consider only the most frequently used MT19937.  We briefly describe this algorithm. <br>  Mersenn's whirlwind consists of two parts: RSLOS and quenching. <br><img src="http://habrastorage.org/getpro/habr/post_images/a24/dd5/eb7/a24dd5eb7b6f3ba3da34c1508363774c.png" alt="image"><br>  The shift register consists of 624 elements, each 32 bits long.  Initialization of the initial state is described by the function: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize_generator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { index := <span class="hljs-number"><span class="hljs-number">0</span></span> MT[<span class="hljs-number"><span class="hljs-number">0</span></span>] := seed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">623</span></span> { <span class="hljs-comment"><span class="hljs-comment">// loop over each other element MT[i] := last 32 bits of(1812433253 * (MT[i-1] xor (right shift by 30 bits(MT[i-1]))) + i) // 0x6c078965 } }</span></span></code> </pre><br>  A certain seed value is supplied to the input of the initialization function, with which the entire register is filled. <br><br>  At the first and each subsequent 624th step, the internal state of the register is mixed: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_numbers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> to <span class="hljs-number"><span class="hljs-number">623</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y := (MT[i] &amp; <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// bit 31 (32nd bit) of MT[i] + (MT[(i+1) mod 624] &amp; 0x7fffffff) // bits 0-30 (first 31 bits) of MT[...] MT[i] := MT[(i + 397) mod 624] xor (right shift by 1 bit(y)) if (y mod 2) != 0 { // y is odd MT[i] := MT[i] xor (2567483615) // 0x9908b0df } } }</span></span></code> </pre><br><br>  At each step, the algorithm returns the following number from the current state of the register and produces the so-called "hardening": <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract_number</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> index == <span class="hljs-number"><span class="hljs-number">0</span></span> { generate_numbers() } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y := MT[index] <span class="hljs-comment"><span class="hljs-comment">// y := y xor (right shift by 11 bits(y)) y := y xor (left shift by 7 bits(y) and (2636928640)) // 0x9d2c5680 y := y xor (left shift by 15 bits(y) and (4022730752)) // 0xefc60000 y := y xor (right shift by 18 bits(y)) index := (index + 1) mod 624 return y }</span></span></code> </pre><br><br>  In order to gain access to the internal state of the algorithm, it is enough for an attacker to get a sequence consisting of 624 numbers. <br>  All you need to do is to return the numbers generated by the algorithm to the state in which they were before the ‚Äúquenching‚Äù stage.  For this it is necessary to do all the steps of hardening in the opposite direction.  For example, consider the last hardening step: <br> <code>y := y ^ (y &gt;&gt;&gt; 18)</code> <br>  Let's see what happens with binary data when performing this operation: <br>  y <font color="red">101101110101111001</font> 11111001110010 <br>  y &gt;&gt;&gt; 18 000000000000000010110111010111 <font color="#D3D3D3">100111111001110010</font> <br>  y ^ (y &gt;&gt;&gt; 18) <font color="red">101101110101111001</font> 01001110100101 <br>  As you can see, the first 18 bits of the result and the original number are the same.  In order to recover the remaining 14 bits, we need to do the following: <br> <code>result ^ (result &gt;&gt;&gt; 18)</code> <br>  Acting in a similar way for all steps of the quenching stage, we obtain the element of the initial state of the PRNG: <br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">uint</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> output</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tempout = output &gt;&gt; <span class="hljs-number"><span class="hljs-number">18</span></span>; output = output ^ tempout; tempout = output &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>; output = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(output ^ (tempout &amp; <span class="hljs-number"><span class="hljs-number">4022730752</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> a = output &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> b = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(output ^ (a &amp; <span class="hljs-number"><span class="hljs-number">2636928640</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> c = b &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> d = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(output ^ (c &amp; <span class="hljs-number"><span class="hljs-number">2636928640</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> e = d &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> f = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(output ^ (e &amp; <span class="hljs-number"><span class="hljs-number">2636928640</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> g = f &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> h = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(output ^ (g &amp; <span class="hljs-number"><span class="hljs-number">2636928640</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> i = h &lt;&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tempfinal = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(output ^ (i &amp; <span class="hljs-number"><span class="hljs-number">2636928640</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> k = tempfinal &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> l = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(tempfinal ^ k); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> m = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)l &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> final = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)(tempfinal ^ m); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> final;  }</code> </pre><br>  As I noted above, if an attacker has 624 numbers generated using the Mersenne Vortex, this is enough to restore the entire internal state and to predict with 100% probability all generated in the subsequent numbers. <br><br><h4>  Crypt resistant GPCH </h4><br>  As an alternative, I want to offer two very reliable methods. <br><br>  <b>Blum - Blum - Shub Algorithm</b> <br>  This generator is based on the complexity of solving the problem of factoring large numbers. <br>  The algorithm generates a sequence of pseudo-random bits and consists of the following steps: <br><ul><li>  Generate two large primes p, q, such that p = q = 3 mod 4. </li><li>  Calculate M = p * q. </li><li>  Take a large number x <sub>0</sub> , mutually simple with M. </li><li>  At each step of generating the sequence, the number x <sub>i + 1</sub> = x <sub>i</sub> <sup>2</sup> mod M is calculated. </li><li>  As a result, the last bit of the number x <sub>i is</sub> returned. </li></ul><br>  To date, this algorithm is perhaps the most reliable PRNG.  To open the initial state or guess the next element of a pseudo-random sequence, the attacker must know the numbers p and q. <br>  The BBS generator has only one drawback - this is extremely low speed.  To increase performance at each generation step, you can return instead of one, log (log M) bits.  This will increase the speed without reducing the robustness. <br><br>  <b>CTR encryption mode</b> <br>  A faster, but equally reliable way to get a pseudo-random sequence is the CTR mode of encrypting block ciphers, in other words, the counter mode.  As a encryption function, you can use any strong block cipher, for example AES. <br><img src="http://habrastorage.org/getpro/habr/post_images/101/9a9/7ed/1019a97ed252501446f04b6a0c299ce1.png" alt="image"><br>  The encryption key and a 128-bit data block consisting of a random bit string and a counter are input to the encryption function.  At each step, the counter is incremented by one, thus guaranteeing a non-repeating sequence of blocks.  The generated sequence consists of encrypted blocks.  In order to predict the next element of the generated sequence, the attacker needs to open the encryption key, i.e.  the task is reduced to cracking of the block cipher used in the scheme. <br><br><h4>  Conclusion </h4><br>  First of all, I wanted to demonstrate the cryptographic unreliability of such well-proven PRNGs, such as linear feedback registers and the Mersenne Vortex. <br>  Both of these algorithms are distinguished by high speed.  They generate really good sequences that are statistically indistinguishable from random ones.  But, unfortunately, when it comes to cryptography, this is often not enough and you need to use slower, but much more secure methods. </div><p>Source: <a href="https://habr.com/ru/post/196442/">https://habr.com/ru/post/196442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196422/index.html">The Large Hadron Collider with my own eyes. Part 2</a></li>
<li><a href="../196424/index.html">Four-legged robot WildCat on an autonomous engine runs at a gallop</a></li>
<li><a href="../196426/index.html">A passion for programming. How I refused the $ 300,000 Microsoft offered me in exchange for a full-time job on GitHub</a></li>
<li><a href="../196432/index.html">We write a platformer in Python. Part 2. Part 1, preparation for creating a level editor</a></li>
<li><a href="../196436/index.html">What do advertising specialists say about new domain zones?</a></li>
<li><a href="../196444/index.html">Hardware virtualization. Theory, reality and support in processor architectures</a></li>
<li><a href="../196448/index.html">Derek Sivers: "The method of interval repetition is the best way to learn programming languages"</a></li>
<li><a href="../196450/index.html">Intelligent traffic lights save motorists time and money</a></li>
<li><a href="../196454/index.html">I see‚Ä¶</a></li>
<li><a href="../196460/index.html">TWTRQ jumped 1,800% on Twitter‚Äôs IPO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>