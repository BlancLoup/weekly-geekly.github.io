<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing. Fundamental theory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 

 I want to collect all the most necessary theory on testing, which is asked at interviews for trainee, junior and a little middle. Actuall...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing. Fundamental theory</h1><div class="post__text post__text-html js-mediator-article">  Good day! <br><br>  I want to collect all the most necessary theory on testing, which is asked at interviews for trainee, junior and a little middle.  Actually, I have already collected quite a few.  The purpose of this post is to jointly add the missed and correct / paraphrase / add / make what else with what is already there, so that it becomes good and you can take it all and repeat it before the next interview about every occasion.  In general, colleagues, I ask under the cat, who to draw something new, who to systematize the old, and who to contribute. <br><br>  The result should be an exhaustive cheat sheet, which should be re-read on the way to the interview. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Everything listed below is not invented by me personally, but taken from various sources, where I personally liked the wording and definition more.  At the end of the list of sources. <br><br>  Subject: test definition, quality, verification / validation, goals, stages, test plan, test plan items, test design, test design techniques, traceability matrix, tets case, checklist, defect, error / deffect / failure, bug report , severity vs priority, test levels, types / types, approaches to integration testing, testing principles, static and dynamic testing, research / ad-hoc testing, requirements, bug life cycle, software development stages, decision table, qa / qc / test engineer, diagram of communications. <br><a name="habracut"></a><br>  Go! <br><br>  <b>Software testing</b> is a test of the correspondence between the actual and expected behavior of the program, performed on the final test suite selected in a certain way.  In a broader sense, testing is one of the techniques of quality control, which includes work planning activities (Test Management), test design (Test Design), Test Execution and analysis of the results (Test Analysis). <br><hr><br><br>  <b>Software Quality (Software Quality)</b> is a combination of software characteristics related to its ability to meet established and perceived needs.  [ISO 8402: 1994 Quality management and quality assurance] <br><hr><br><br>  <b>Verification</b> is the process of evaluating a system or its components to determine if the results of the current development stage satisfy the conditions formed at the beginning of this stage [IEEE].  Those.  whether our goals, deadlines, project development tasks, as defined at the beginning of the current phase, are being fulfilled. <br>  <b>Validation</b> is the determination of the compliance of the software being developed to the expectations and needs of the user with the requirements of the system [BS7925-1]. <br>  You can also find a different interpretation: <br>  The process of evaluating the conformity of a product to explicit requirements (specifications) is verification (verification), while at the same time evaluating the compliance of a product with the expectations and requirements of users is validation.  You can also often come across the following definition of these concepts: <br>  Validation - 'is ‚Äã‚Äãthis the right specification?'. <br>  Verification - 'is ‚Äã‚Äãthe system correct to specification?'. <br><hr><br><br>  <b>Test objectives</b> <br>  Increase the likelihood that an application intended for testing will work correctly under any circumstances. <br>  Increase the likelihood that the application intended for testing will meet all the requirements described. <br>  Providing current information on the status of the product at the moment. <br><hr><br><br>  <b>Testing steps:</b> <br>  1. Analysis <br>  2. Develop a testing strategy <br>  and planning quality control procedures <br>  3. Work with requirements <br>  4. Creation of test documentation <br>  5. Testing the prototype <br>  6. Basic testing <br>  7. Stabilization <br>  8. Operation <br><hr><br><br>  <b>A Test Plan</b> is a document that describes the entire scope of testing, starting with the description of the object, strategy, schedule, criteria for starting and ending testing, up to the equipment necessary for the operation, special knowledge, and risk assessment with options to resolve them . <br>  Answers the questions: <br>  What should be tested? <br>  What will you test? <br>  How will you test? <br>  When will you test? <br>  Criteria for testing. <br>  Criteria for the end of testing. <br><hr><br><br>  <b>Key points of the test plan</b> <br>  The IEEE 829 standard lists the items from which the test plan should (let - may) consist: <br>  a) Test plan identifier; <br>  b) Introduction; <br>  c) Test items; <br>  d) Features to be tested; <br>  e) Features not to be tested; <br>  f) Approach; <br>  g) Item pass / fail criteria; <br>  h) Suspension criteria and resumption requirements; <br>  i) Test deliverables; <br>  j) Testing tasks; <br>  k) Environmental needs; <br>  l) Responsibilities; <br>  m) Staf√ûng and training needs; <br>  n) Schedule; <br>  o) Risks and contingencies; <br>  p) Approvals. <br><hr><br><br>  <b>Test design</b> is a stage in the software testing process where test cases are designed and created (test cases) in accordance with previously defined quality criteria and testing objectives. <br>  Roles responsible for the test design: <br>  ‚Ä¢ Test analyst - determines "WHAT to test?" <br>  ‚Ä¢ Test Designer - defines ‚ÄúHOW to test?‚Äù <br><hr><br><br>  <b>Test design techniques</b> <br><br>  ‚Ä¢ <b>Equivalent Partitioning (EP)</b> .  As an example, you have a range of valid values ‚Äã‚Äãfrom 1 to 10, you must choose one valid value inside the interval, say 5, and one invalid value outside the interval - 0. <br><br>  ‚Ä¢ <b>Analysis of Boundary Values ‚Äã‚Äã(Boundary Value Analysis - BVA)</b> .  If we take the example above, as the values ‚Äã‚Äãfor positive testing, we choose the minimum and maximum limits (1 and 10), and the values ‚Äã‚Äãare larger and smaller than the limits (0 and 11).  Analysis Boundary values ‚Äã‚Äãcan be applied to fields, records, files, or to any kind of entity with restrictions. <br><br>  ‚Ä¢ <b>Cause / Effect (Cause / Effect - CE)</b> .  It is, as a rule, entering combinations of conditions (causes) to get a response from the system (Corollary).  For example, you check the ability to add a client using a specific screen form.  To do this, you will need to enter several fields, such as "Name", "Address", "Phone Number" and then press the "Add" button - this "Reason".  After clicking the ‚ÄúAdd‚Äù button, the system adds the client to the database and displays its number on the screen - this is ‚ÄúCorollary‚Äù. <br><br>  ‚Ä¢ <b>Error Guessing (EG)</b> .  This is when the test analyst uses his knowledge of the system and the ability to interpret the specification in order to ‚Äúpredict‚Äù under what input conditions the system may give an error.  For example, the specification says: ‚Äúthe user must enter the code‚Äù.  The test analyst will think: ‚ÄúWhat if I do not enter the code?‚Äù, ‚ÄúWhat if I enter the wrong code?  ", and so on.  This is an error prediction. <br><br>  ‚Ä¢ <b>Exhaustive Testing (ET)</b> is an extreme case.  Within this technique, you should check all possible combinations of input values, and in principle, this should find all the problems.  In practice, the application of this method is not possible, due to the huge number of input values. <br><hr><br><br>  <b>The Traceability matrix</b> is a two-dimensional table containing the functional requirements (functional requirements) of the product and the test cases prepared (test cases).  The headings of the table columns are the requirements, and the line headings are test scripts.  At the intersection, a mark means that the requirement of the current column is covered by the test script of the current line. <br>  The requirements compliance matrix is ‚Äã‚Äãused by QA engineers to validate product coverage tests.  MST is an integral part of the test plan. <br><hr><br><br>  <b>A Test Case</b> is an artifact that describes a set of steps, specific conditions and parameters necessary to verify the implementation of a test function or its part. <br>  Example: <br>  Action Expected Result Test Result <br>  (passed / failed / blocked) <br>  Open page "login" Login page is opened <br><br>  Each test case should have 3 parts: <br>  PreConditions A list of actions that lead the system to a state suitable for conducting a basic check.  Or a list of conditions, the fulfillment of which indicates that the system is in a condition suitable for conducting the main test. <br>  Test Case Description List of actions that translate the system from one state to another, to obtain a result, based on which we can conclude that the implementation is satisfied, the requirements set <br>  PostConditions A list of actions that take the system to its original state (the state before the test is the initial state) <br>  Types of Test Cases: <br>  Test cases are divided by the expected result into positive and negative: <br>  ‚Ä¢ Positive test case uses only valid data and checks that the application has correctly executed the called function. <br>  ‚Ä¢ Negative test case operates with both correct and incorrect data (at least 1 incorrect parameter) and aims to check for exceptional situations (validation of validators), and also checks that the application called function does not execute when the validator is triggered. <br><hr><br><br>  <b>A check list</b> is a document that describes what should be tested.  In this case, the checklist can be completely different levels of detail.  How detailed the checklist will depend on the reporting requirements, the level of knowledge of the product by employees and the complexity of the product. <br>  As a rule, the checklist contains only actions (steps), without the expected result.  The checklist is less formalized than the test script.  It is appropriate to use it when test scripts are redundant.  Also, the checklist is associated with flexible approaches to testing. <br><hr><br><br>  <b>A defect (also known as a bug)</b> is a discrepancy between the actual result of the program and the expected result.  Defects are detected at the stage of software testing (software), when the tester compares the results of the program (component or design) with the expected result described in the specification of requirements. <br><hr><br><br>  <b>Error</b> - user error, that is, he is trying to use the program in another way. <br>  Example - enters the letters in the field where you want to enter numbers (age, quantity of goods, etc.). <br>  In a quality program, such situations are provided and an error message (error message) is displayed, with a red cross. <br>  <b>Bug (defect)</b> - a programmer's error (or a designer or someone else who takes part in the development), that is, when in the program, something goes wrong as planned and the program gets out of control.  For example, when user input is not controlled at all, as a result, incorrect data cause crashes or other ‚Äújoys‚Äù in the program's work.  Or inside the program is built in such a way that it does not initially correspond to what is expected of it. <br>  <b>Failure</b> - failure (and not necessarily hardware) in the component, the entire program or system.  That is, there are such defects that lead to failures (A defect caused the failure) and there are those that do not.  UI defects for example.  But a hardware failure that is not related to software in any way is also failure. <br><hr><br><br>  <b>Bug Report</b> is a document describing a situation or sequence of actions that led to incorrect operation of the test object, indicating the reasons and the expected result. <br>  Cap <br>  Short Description A brief description of the problem, clearly indicating the cause and type of the error situation. <br>  Project (Project) The name of the test project <br>  Application Component (Component) Name of part or function of the product being tested. <br>  Version number (Version) The version on which the error was found <br>  Severity The most common five-level system for grading the severity of a defect is: <br>  ‚Ä¢ S1 Blocking (Blocker) <br>  ‚Ä¢ S2 Critical <br>  ‚Ä¢ S3 Major (Major) <br>  ‚Ä¢ S4 Minor (Minor) <br>  ‚Ä¢ S5 Trivial <br>  Priority Defect Priority: <br>  ‚Ä¢ P1 High <br>  ‚Ä¢ P2 Medium <br>  ‚Ä¢ P3 Low <br>  Status Status of the bag.  Depends on the procedure used and the life cycle of the bug (bug workflow and life cycle) <br><br>  Author (Author) Creator bug report <br>  Assigned To The name of the person assigned to solve the problem. <br>  Environment <br>  OS / Service Pack, etc.  / Browser + version / ... Information about the environment on which the bug was found: operating system, service pack, for WEB testing - the name and version of the browser, etc. <br>  ... <br>  Description <br>  Steps to play (Steps to Reproduce) Steps by which you can easily reproduce the situation that led to the error. <br>  Actual Result (Result) The result obtained after passing the steps to play. <br>  Expected Result Expected Result <br>  Additions <br>  Attachment A file with logs, a screenshot or any other document that can help clarify the cause of the error or indicate the way to solve the problem. <br><hr><br><br>  <b>Severity vs Priority</b> <br>  Severity is an attribute that characterizes the effect of a defect on an application‚Äôs performance. <br>  Priority (Priority) - an attribute that indicates the order of the task or the elimination of the defect.  It can be said that this is a work planning manager tool.  The higher the priority, the faster the defect needs to be corrected. <br>  Severity is exposed by tester <br>  Priority - by manager, team lead or customer <br><br>  <b>Graduation Grade Defect (Severity)</b> <br><br>  <b>S1 Blocking (Blocker)</b> <br>  A blocking error that causes the application to become inoperable, as a result of which further work with the system under test or its key functions becomes impossible.  Problem solving is necessary for the further functioning of the system. <br><br>  <b>S2 Critical</b> <br>  Critical error, incorrect key business logic, security hole, problem that caused server to crash temporarily or some part of the system is inoperable, without the possibility of solving the problem using other entry points.  Problem solving is necessary for further work with key functions of the system under test. <br><br>  <b>S3 Major (Major)</b> <br>  Significant error, part of the main business logic does not work correctly.  The error is not critical or there is an opportunity to work with the function under test using other input points. <br><br>  <b>S4 Minor (Minor)</b> <br>  A minor error that does not violate the business logic of the application being tested is an obvious user interface problem. <br><br>  <b>S5 Trivial</b> <br>  A trivial error that does not relate to the business logic of the application, a poorly reproducible problem, barely noticeable through the user interface, the problem of third-party libraries or services, a problem that does not affect the overall quality of the product. <br><hr><br><br>  <b>Grade Priority Defect (Priority)</b> <br>  <b>P1 High (High)</b> <br>  The error should be fixed as soon as possible, because  its availability is critical for the project. <br>  <b>P2 Medium</b> <br>  The error should be corrected, its presence is not critical, but requires a mandatory solution. <br>  <b>P3 Low</b> <br>  The error should be corrected, its presence is not critical, and does not require an urgent solution. <br><hr><br><br>  <b>Testing Levels</b> <br><br>  <b>1. Unit Testing</b> <br>  Component (modular) testing verifies the functionality and looks for defects in parts of the application that are available and can be tested separately (program modules, objects, classes, functions, etc.). <br><br>  <b>2. Integration Testing</b> <br>  The interaction between the system components after component testing is checked. <br><br>  <b>3. System Testing (System Testing)</b> <br>  The main task of system testing is to check both functional and non-functional requirements in the system as a whole.  This reveals defects, such as incorrect use of system resources, unintended combinations of user-level data, incompatibility with the environment, unintended usage scenarios, missing or incorrect functionality, inconvenience of use, etc. <br><br>  <b>4. Operational Testing (Release Testing).</b> <br>  Even if the system meets all requirements, it is important to make sure that it meets the user's needs and fulfills its role in the environment of its operation, as it was defined in the business model of the system.  It should be noted that the business model may contain errors.  Therefore, it is important to conduct operational testing as the final step of validation.  In addition, testing in the operating environment allows you to identify non-functional problems, such as: conflict with other systems related in the business field or in software and electronic environments;  insufficient system performance in the operating environment, etc. It is obvious that finding such things at the implementation stage is a critical and expensive problem.  Therefore, it is so important to carry out not only verification, but also validation, from the very early stages of software development. <br><br>  <b>5. Acceptance Testing</b> <br>  A formal testing process that checks the compliance of the system with the requirements and is conducted with the aim of: <br>  ‚Ä¢ determine whether the system meets the acceptance criteria; <br>  ‚Ä¢ the decision of the customer or other authorized person is accepted by the application or not. <br><hr><br><br>  <b>Types / types of testing</b> <br><br>  <b>Functional types of testing</b> <br>  ‚Ä¢ Functional testing (Functional testing) <br>  ‚Ä¢ Security Testing (Security and Access Control Testing) <br>  ‚Ä¢ Interoperability Testing <br><br>  <b>Non-functional testing types</b> <br>  ‚Ä¢ All kinds of performance testing: <br>  o load testing (Performance and Load Testing) <br>  o stress testing (Stress Testing) <br>  o stability or reliability testing (Stability / Reliability Testing) <br>  o volume testing (Volume Testing) <br>  ‚Ä¢ Installation testing <br>  ‚Ä¢ Usability Testing <br>  ‚Ä¢ Failover and Recovery Testing <br>  ‚Ä¢ Configuration Testing (Configuration Testing) <br><br>  <b>Change of Test Types</b> <br>  ‚Ä¢ Smoke Testing <br>  ‚Ä¢ Regression Testing <br>  ‚Ä¢ Retesting <br>  ‚Ä¢ Build Verification Test <br>  ‚Ä¢ Sanitary Testing or Consistency / Health Testing (Sanity Testing) <br><br>  <b>Functional testing</b> examines predetermined behavior and is based on an analysis of the specifications of the functionality of a component or system as a whole. <br><br>  <b>Security testing</b> is a testing strategy used to test the security of a system, as well as to analyze risks related to ensuring a holistic approach to protecting an application, hacker attacks, viruses, and unauthorized access to confidential data. <br><br>  <b>Interoperability Testing</b> is functional testing that tests the ability of an application to interact with one or more components or systems and includes compatibility testing and integration testing. <br><br>  <b>Load testing</b> is an automated test that simulates the work of a certain number of business users on a shared (shared) resource. <br><br>  <b>Stress testing (Stress Testing)</b> allows you to check how the application and the system as a whole work under stress and also evaluate the ability of the system to regenerate, i.e.  to return to normal after cessation of exposure to stress.  Stress in this context may be an increase in the intensity of operations to very high values ‚Äã‚Äãor an emergency change in the configuration of the server.  Also, one of the tasks in stress testing can be to evaluate performance degradation, so stress testing objectives can overlap with performance testing objectives. <br><br>  <b>Volume Testing</b> .  The task of volumetric testing is to obtain an assessment of performance when increasing the amount of data in the database <br><br>  <b>Stability / Reliability Testing</b> .  The task of testing stability (reliability) is to test the performance of the application during long-term (many hours) testing with an average load level. <br><br>  <b>Testing the installation is</b> aimed at verifying successful installation and configuration, as well as updating or uninstalling software. <br><br>  <b>Usability testing</b> is a testing method aimed at establishing the degree of usability, learnability, comprehensibility and attractiveness for users of a developed product in the context of specified conditions.  This also includes: <br>  User Interface Testing (UI Testing) is a type of testing research that is performed to determine if some artificial object (such as a web page, user interface, or device) is convenient for its intended use. <br>  User eXperience (UX) is the feeling that a user experiences while using a digital product, while the User interface is a tool that allows user-web resource interaction. <br><br>  <b>Failover and Recovery Testing</b> tests the product under test in terms of its ability to withstand and recover successfully from possible failures caused by software errors, hardware failures or communication problems (for example, a network failure).  The purpose of this type of testing is to check the recovery systems (or duplicate basic functionality of the systems), which, in case of failure, will ensure the safety and integrity of the data of the tested product. <br><br>  <b>Configuration Testing</b> - a special type of testing aimed at checking the operation of software with various system configurations (declared platforms, supported drivers, various computer configurations, etc.) <br><br>  <b>Smoke (Smoke)</b> testing is considered as a short cycle of tests performed to confirm that after building the code (new or revised) the application to be installed starts and performs the basic functions. <br><br>  <b>Regression testing</b> is a type of testing aimed at checking changes made in an application or the environment (fixing a defect, merging code, migrating to another operating system, database, web server or application server) to confirm that the existing functionality is working. as before.  Regression tests can be either functional or non-functional tests. <br><br>  <b>Retesting</b> - testing, during which test scripts are run that have detected errors during the last run, to confirm the success of correcting these errors. <br>  What is the difference between regression testing and re-testing? <br>  Re-testing - fixes bug fixes. <br>  Regression testing - verifies that fixing bugs did not affect other software modules and did not cause new bugs. <br><br>  <b>Build testing or Build Verification Test</b> - testing aimed at determining the compliance of the released version with the quality criteria for starting testing.  According to its goals, it is analogous to Smoke Testing, aimed at accepting a new version for further testing or operation.  It can penetrate further, depending on the quality requirements of the released version. <br><br>  <b>Sanitary testing</b> is highly targeted testing is sufficient to prove that a particular function operates according to the requirements stated in the specification.  It is a subset of regression testing.  It is used to determine the health of a specific part of an application after changes made in it or the environment.  Usually done manually. <br><br>  <b>Error Guessing (EG)</b> .  This is when the test analyst uses his knowledge of the system and the ability to interpret the specification in order to ‚Äúpredict‚Äù under what input conditions the system may give an error.  For example, the specification says: ‚Äúthe user must enter the code‚Äù.  The test analyst will think: ‚ÄúWhat if I do not enter the code?‚Äù, ‚ÄúWhat if I enter the wrong code?  ", and so on.  This is an error prediction. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/3cd/83d/3df3cd83d6bc9e28f4c86cb6d395a651.png" alt="image"><br><hr><br><br>  <b>Approaches to integration testing:</b> <br><br>  ‚Ä¢ <b>Bottom Up (Bottom Up Integration)</b> <br>  All low-level modules, procedures, or functions are aggregated and then tested.  After that, the next level of modules is collected for integration testing.  This approach is considered useful if all or practically all modules of the developed level are ready.  Also, this approach helps to determine the level of readiness of the application by the results of testing. <br><br>  ‚Ä¢ <b>Top Down Integration</b> <br>  First, all high-level modules are tested, and low-level ones are gradually added one by one.  All modules of the lower level are simulated with plugs with similar functionality, then as they become ready, they are replaced with real active components.  So we are testing from top to bottom. <br><br>  ‚Ä¢ <b>Big Bang (‚ÄúBig Bang‚Äù Integration)</b> <br>  All or almost all developed modules come together as a complete system or its main part, and then integration testing is carried out.  This approach is very good for saving time.  However, if test cases and their results are not recorded correctly, the integration process itself will become very complicated, which will be an obstacle for the testing team to achieve the main goal of integration testing. <br><hr><br><br>  <b>Principles of testing</b> <br><br>  <b>Principle 1</b> - Testing demonstrates the presence of defects (Testing shows presence of defects) <br>  Testing can show that defects are present, but cannot prove that they are not.  Testing reduces the likelihood of defects in the software, but even if no defects were detected, this does not prove its correctness. <br><br>  <b>Principle 2</b> - Exhaustive Testing Unreachable (Exhaustive testing is impossible) <br>  Full testing using all combinations of inputs and preconditions is physically impossible, except in trivial cases.  Instead of exhaustive testing, risk analysis and prioritization should be used to more accurately focus testing efforts. <br><br>  <b>Principle 3</b> - Early testing <br>  To find defects as early as possible, testing activities should be started as early as possible in the software or system development life cycle, and should be focused on specific goals. <br><br>  <b>Principle 4</b> - Defects clustering <br>  Testing efforts should be concentrated in proportion to the expected and later real density of defects by module.  As a rule, most of the defects found during testing or resulting in the majority of system failures are contained in a small number of modules. <br><br>  <b>Principle 5</b> - Pesticide Paradox (Pesticide paradox) <br>  If the same tests are run many times, in the end, this set of test scenarios will no longer find new defects.  To overcome this ‚Äúpesticide paradox‚Äù, test scripts should be regularly reviewed and corrected, new tests should be versatile to cover all components of the software or systems, and to find as many defects as possible. <br><br>  <b>Principle 6</b> - Testing is context dependent (Testing is concept depending) <br>  Testing is done differently depending on the context.  For example, security-critical software is tested differently than an e-commerce site. <br><br>  <b>Principle 7</b> - Absence-of-errors fallacy <br>  Detection and correction of defects will not help if the created system does not suit the user and does not satisfy his expectations and needs. <br><hr><br><br>  <b>Static and dynamic testing</b> <br>  Static testing differs from dynamic testing in that it is done without launching the product code.  Testing is carried out by analyzing the software code (code review) or compiled code.  The analysis can be done both manually and with the help of special tools.  The purpose of the analysis is the early detection of errors and potential problems in the product.  Also static testing includes specification testing and other documentation. <br><hr><br><br>  <b>Research / ad-hoc testing</b> <br>  The simplest definition of research testing is developing and executing tests at the same time.      (    ,    ).  ,     ,           . <br><br>   ad hoc  exploratory testing  ,  , ad hoc    ,    exploratory      .  ,        . <br><hr><br><br> <b></b> ‚Äî   () ,    . <br>   ,   ,     . ,   . <br><br> <b>  :</b> <br> ‚Ä¢  <br> ‚Ä¢  <br> ‚Ä¢    <br> ‚Ä¢    <br> ‚Ä¢  () <br> ‚Ä¢  <br> ‚Ä¢  <br><hr><br><br> <b>  </b> <br><img src="https://habrastorage.org/getpro/habr/post_images/753/d2e/9df/753d2e9df6a6304f453e8dd6971768fa.jpg" alt="image"><br><hr><br><br> <b>  </b> ‚Äî  ,     ,         .        ( ¬´-¬ª)   ,      .             (¬´ ¬ª). <br><br>     : <br> ‚Ä¢    ; <br> ‚Ä¢ ; <br> ‚Ä¢ ; <br> ‚Ä¢  ; <br> ‚Ä¢   . <br><br>        .       ,       . <br><hr><br><br> <b>   :</b> <br> ‚Ä¢ - <br> ‚Ä¢  <br> ‚Ä¢  <br> ‚Ä¢ - <br> ‚Ä¢  <br> ‚Ä¢ - <br><hr><br><br> <b>   (decision table)</b> ‚Äî       ,      .      ,        . <br><img src="http://www.interface.ru/iarticle/img/1170_3.bmp" alt="image"><br><hr><br><br> <b>QA/QC/Test Engineer</b> <br><img src="https://habrastorage.org/getpro/habr/post_images/b3a/946/a7a/b3a946a7adf2a88d8a3c1151176d12c1.png" alt="image"><br>  ,        :  ‚Äî  QC. QC ‚Äî  QA. <br><hr><br><br> <b> </b> ‚Äî    ,        .           . <br><img src="https://habrastorage.org/getpro/habr/post_images/a2c/f6e/4aa/a2cf6e4aaa5f800787ed89a5a6e61a76.png" alt="image"><br><hr><br><br> : <a href="http://www.protesting.ru/">www.protesting.ru</a> , <a href="http://www.bugscatcher.net/">www.bugscatcher.net</a> , <a href="http://www.qalight.com.ua/">www.qalight.com.ua</a> , <a href="http://www.thinkingintests.wordpress.com/">www.thinkingintests.wordpress.com</a> ,  ISTQB, <a href="http://www.quizful.net/">www.quizful.net</a> , <a href="http://www.bugsclock.blogspot.com/">www.bugsclock.blogspot.com</a> , <a href="http://www.zeelabs.com/">www.zeelabs.com</a> , <a href="http://www.devopswiki.net/">www.devopswiki.net</a> , <a href="http://www.hvorostovoz.blogspot.com/">www.hvorostovoz.blogspot.com</a> . </div><p>Source: <a href="https://habr.com/ru/post/279535/">https://habr.com/ru/post/279535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279525/index.html">Yota Air: what does outside work teach?</a></li>
<li><a href="../279527/index.html">uDev tech events: Kharkov, March 30</a></li>
<li><a href="../279529/index.html">The company Crytek announced a new engine CryEngine V</a></li>
<li><a href="../279531/index.html">Localization of mobile games for the Asian market</a></li>
<li><a href="../279533/index.html">Six part-time jobs for an IT professional who are paid in dollars</a></li>
<li><a href="../279537/index.html">Creating a nanoCAD distribution with custom settings</a></li>
<li><a href="../279539/index.html">Popular WordPress plugin contains backdoor</a></li>
<li><a href="../279541/index.html">Ubiquiti LiteBeam AC‚Äì we build radio networks in a new and budgetary way</a></li>
<li><a href="../279543/index.html">Webinar 4: Docker Container Management System</a></li>
<li><a href="../279545/index.html">MCMC-sampling for those who studied, but did not understand</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>