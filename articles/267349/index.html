<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JSON Web Token and sliding expiration in a web application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In web applications, the most common authentication method so far has been the use of cookies, which store the identifier of the server session and ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JSON Web Token and sliding expiration in a web application</h1><div class="post__text post__text-html js-mediator-article">  In web applications, the most common authentication method so far has been the use of cookies, which store the identifier of the server session and have their expiration date (expiration date).  At the same time, it is possible to automatically extend this date upon the next access of the user to the server.  This approach is called sliding expiration. <br><br>  Recently, however, developers have sought to abandon the use of cookies and server session due to a number of reasons and are looking for alternative authentication methods.  One of them is the use of JSON Web Token (JWT) - a token that contains in encrypted form all the minimum necessary information for authentication and authorization.  There is no need to store user data in the session, since the self-contained marker is self-contained.  However, this in turn adds certain difficulties with control over JWT, which can negate all its advantages over cookies.  In the Internet, I have found several solutions to these problems, and here I would like to propose an alternative option, which, it seems to me, with its simplicity should satisfy the needs of many projects. <br><a name="habracut"></a><br>  The main reasons why developers might refuse cookies and sessions are, in my opinion, the following: <br><ul><li>  Increasingly, developers are switching to single-page web applications (SPAs) and accessing their server through the API.  They use the same API to serve mobile applications.  And in order to unify the approach to authentication, they prefer to use access tokens, since the use of cookies on mobile platforms is difficult. </li><li>  When a web application scales horizontally (web farm), there is a problem in synchronizing session state between servers.  Of course, there are solutions for this, but it is easier to create stateless applications that do not require the use of a session at all.  JWT solves this problem. </li></ul><br><br>  JWT itself, as well as a cookie, has its own date of "puffing" (expiration date) and in the simplest case is used as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  The user requests access from your server (and generally from the Authorization Server), sending him a username and password. </li><li>  The Authorization Server checks the user's validity and sends him an access token, which has a certain expiration date (for example, after 2 weeks). </li><li>  The user uses this access token to access resources on your server (and in general, on the Resource Server). </li><li>  Upon expiration date (after 2 weeks), the user will have to re-authenticate </li></ol><br>  The main disadvantage of this approach is that in the case of a short expiration period, the user will often have to enter a login and password (which is inconvenient and less secure in terms of frequently sending the password).  As an option, it is proposed to simply use a long expiration period (for example, 1 year).  However, this approach causes a number of problems: <br><ul><li>  In case of theft of access token (for example, through XSS vulnerability), an attacker will be able to gain access to the resource for a long period. </li><li>  If the administrator wants to restrict the user rights or change his role, the user will have to go through the authentication procedure again in order for the access token to be updated. </li></ul><br>  In order to solve the problems described, it is often proposed, along with a short-term access token, to additionally use a second long-playing refresh token.  In this case, during authentication, the user receives a refresh token (with a duration of expiration, for example, 1 year) and an access token (for example, with a duration of 30 minutes).  And to access the resources, he still uses access token, but now after 30 minutes, in order to get a new access token, all he has to do is send his refresh token to the Authorization Server and he will send him a fresh access token in response, and once again check User rights. <br><br>  The approach with the use of refresh token rather complicates both client and server code.  At the same time, he needs to keep all refresh token users along with Client id and other additional information. <br><br>  If you want the user to use the resource indefinitely after logging in, it is proposed to implement sliding expiration for tokens.  That is, in the simplest (first) case, when an access token is received, the server, when approaching expiration date (or every time), sends the user a new access token with the date shifted.  Such an approach in the case of the theft of a token, leads to the fact that the attacker can use the resource indefinitely. <br><br>  In the second case, the same is done, but only for the refresh token. <br><br>  That's all the approaches that I managed to find.  I, in turn, would like to limit myself for simplicity to only one access token, but at the same time to have a sliding expiration and the ability to change the rights and restrict access to the token if it is stolen. <br><br>  To do this, I would add a new RefreshDate field to the token (the date after which the token needs to be updated; must be less than expiration date if it is specified) and only one field - MinRefreshDate - to the database in the user table.  This field should store the minimum RefreshDate date that is valid for the user.  At the same time, to update the token, MinRefreshDate must be non-empty and must always be smaller than the RefreshDate of the token itself, which needs to be updated. <br><br>  The process of use would look something like this: <br><br><ol><li>  Suppose today is January 01, 1789.  Refresh period, take 3 days.  MinRefreshDate for user not specified (NULL). </li><li>  The user sends the login / password to the Authorization Server for the first time and receives in return an access token with RefreshDate = 04/01/89.  At the same time, the server sees that MinRefreshDate is empty and makes it equal to 04/01/89. </li><li>  The user uses access token on January 1,2 and 3rd to access the Resource Server. </li><li>  The administrator changes the user role on January 2nd. </li><li>  At the next user request on the 4th of January (or later), the Resource Server understands that it is necessary to update the access token and itself requests it from the Authorization Server. </li><li>  The Authorization Server verifies that MinRefreshDate is not empty and less than the RefreshDate of the token, and also checks the current user rights and forms a fresh access token with RefreshDate = 07/01/89 and a new user role. </li><li>  Resource Server sends the user a new access token along with resources. </li><li>  The user continues to use the new access token on the 4th and 5th of January under the new role. </li><li>  On the 6th, the access token was stolen by the attacker.  However, the user notices this (for example, if he received a notification that he did not come into his profile from a regular ip or browser) </li><li>  On the same day, the user enters the profile settings and presses something like 'close all sessions and exit'.  This will reset MinRefreshDate for this user. </li><li>  On the 7th, the attacker tries to update the stolen token, but cannot, because MinRefreshDate = NULL. </li><li>  On the 8th, the user again performs the authentication procedure and sends the login / password.  At the same time, it receives a new token with RefreshDate = 11.01.89.  At the same time, the server sees that MinRefreshDate is empty and makes it equal to 01/11/89 (in the case of a date already filled, it does not) </li><li>  On the 9th, the attacker again tries to update the token (for which RefreshDate = 07/01/89), but cannot, because his RefreshDate is smaller than MinRefreshDate. </li></ol><br>  That's all the decision.  It still has problems associated with the time window before the RefreshDate has stolen or requires updating the role of the token.  Also, if the user does not notice that the token was stolen, then the attacker can easily update the token and use the resource on behalf of the user as much as he pleases.  But all these problems can be partially solved by reducing the duration of the Refresh period (for example, up to 30 minutes) and enhanced control over the unusual activity of the user. <br><br>  I have no illusions that this approach will be of interest to someone and will be applied in practice, but I would like to hear an opinion on how safe and suitable all this is for actual use. <br><br>  PS: Of course, on a real project, additional security should be provided with SSL and a synchronization token (Anti-Forgery Token).  Plus, instead of MinRefreshDate, you could use some unique sequence of characters (such as SessionToken).  But in this case, the JWT would also have to additionally add a SessionToken field so that it can be validated.  You can also store for each user a set of SessionTokens (which would be created with each authentication) in order to more flexibly control and limit specific tokens. <br><br>  Thank. </div><p>Source: <a href="https://habr.com/ru/post/267349/">https://habr.com/ru/post/267349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267339/index.html">Iproute2 policy-routing and traffic balancing between uplinks - the problem of dropping connections</a></li>
<li><a href="../267341/index.html">Adaptation of the Feedly application for Material Design</a></li>
<li><a href="../267343/index.html">Scheduling DHCP server</a></li>
<li><a href="../267345/index.html">Block diagram for the selection of STL-algorithm</a></li>
<li><a href="../267347/index.html">Results of the Russian Code Cup 2015 and analysis of the final tasks</a></li>
<li><a href="../267351/index.html">Local Internet radio station using icecast + ices</a></li>
<li><a href="../267353/index.html">SMS notification of power failure using Asterisk + Dongle and apcupsd</a></li>
<li><a href="../267355/index.html">Mikrotik. Building VPN ipsec tunnels with dynamic ip clients</a></li>
<li><a href="../267357/index.html">Zerodium offers a million dollars for an iOS 9 exploit</a></li>
<li><a href="../267361/index.html">Big Data from A to Z. Part 1: Principles of working with big data, the MapReduce paradigm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>