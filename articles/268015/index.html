<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scalable JSON serialization / deserialization library</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, I participated in the project of writing firmware for some device. In the process of work, the question arose, and how, in fact, to i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scalable JSON serialization / deserialization library</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, I participated in the project of writing firmware for some device.  In the process of work, the question arose, and how, in fact, to interact with the "big brother" (computer manager)?  Since completely different devices (various smartphones, tablets, laptops with different operating systems, etc.) were laid as ‚Äúbig brother‚Äù, it was planned to use a web application that dictated the use of JSON for messaging. <br><br>  The result was an easy and fast JSON serialization / deserialization library.  The main features of this library: <br><br><ul><li>  in the basic functionality (without using containers STL) does not use dynamic memory, in general; <br></li><li>  consists only of header files (headers-only); <br></li><li>  there is support for STL containers; <br></li><li>  allows you to create extensions to handle arbitrary types. <br></li></ul><br><a name="habracut"></a><h4>  Some lyrics </h4><br>  Initially, writing my own library serialized me to encourage <a href="http://habrahabr.ru/post/244963/">this</a> post.  Unfortunately, that option did not suit me, because it uses STL and use it on the controller, in which there is only 1MB of flash and 198KB of RAM, to put it mildly, it is strange.  But I liked the idea of ‚Äã‚Äãdescribing fields for serialization.  Similar syntax for boost :: serialization looks similar.  He was taken as a basis. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The serialization process is trivial - we are, in fact, bypassing the serializable data structure in depth.  As you know, this action <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D0%25B3%25D0%25BB%25D1%2583%25D0%25B1%25D0%25B8%25D0%25BD%25D1%2583">can be described recursively</a> , due to which it is possible to refuse to allocate dynamic memory (use only the stack).  It is clear that everything will collapse (more precisely, it will freeze) when I try to serialize a couple of objects that link to each other, but such cases have not come across to me yet. <br><br>  Deserialization is a bit more complicated.  In the process of thinking and after, getting to know someone else's creativity, I got the impression that there can be two types of deserializers (according to the initial data for building the parse tree): <br><br><ol><li>  build a parse tree on the input line, then try on this tree to the object into which the message is deserialized (for example, Qt, jsoncpp or jsmn); <br></li><li>  they build a parse tree on the transferred object, and then an accepted string is tried on (parser from cxxtools and the proposed library). <br></li></ol><br>  Also parsers can be divided into: <br><br><ol><li>  parsers that require a string containing a JSON message (Qt, jsoncpp, and jsmn) for their work; <br></li><li>  "Online" parsers, processing individual message symbols (cxxtools and the proposed library). <br></li></ol><br>  Parsers building the parse tree on the incoming line have a slight advantage (in my opinion, the mythical one).  Suppose we send a request to the server and wait for a response in this format: <br><br><pre><code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">one</span></span> : <span class="hljs-number"><span class="hljs-number">10.01</span></span>, <span class="hljs-attr"><span class="hljs-attr">two</span></span> : <span class="hljs-number"><span class="hljs-number">20.02</span></span> },</code> </pre> <br>  But the answer comes like this: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">error</span></span> : <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">-</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span><span class="xml"> }.</span></span></code> </pre><br>  In this situation, we can try to display the message fields on the expected structure and if it does not work out - and we know that we can get an error - try ("manually") to display the message on the structure with an error.  Parsers building a parse tree on the transferred object are less flexible - they will simply discard the message as erroneous. <br><br>  Why do I think this advantage is doubtful?  Consider an example based on the digitalocean <a href="https://developers.digitalocean.com/documentation/v2/">REST API</a> . <br><br>  Take, for example, the server part.  When interacting with the server, the client accesses a specific URL by a specific method, passing JSON in the message body.  For example: <br><br>  <i>Create a new Domain</i> <i><br></i>  <i>To create a new domain, send a POST request to / v2 / domains.</i>  <i>Set the "name" attribute to you.</i>  <i>Set the "ip_address" attribute to the IP address.</i> <br><br>  URL - <i>" <a href="https://api.digitalocean.com/v2/domains">api.digitalocean.com/v2/domains</a> ".</i> <br>  Method - <i>POST</i> . <br><br>  JSON message: <br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"example.com"</span></span>,<span class="hljs-string"><span class="hljs-string">"ip_address"</span></span>:<span class="hljs-string"><span class="hljs-string">"1.2.3.4"</span></span>}.</code> </pre><br>  Any other message will be an error. <br><br>  Also with the client side.  If successful, the server responds with the status ‚Äú201 Created‚Äù and a specific JSON message: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"domain"</span></span>: { <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"example.com"</span></span>, <span class="hljs-string"><span class="hljs-string">"ttl"</span></span>: <span class="hljs-number"><span class="hljs-number">1800</span></span>, <span class="hljs-string"><span class="hljs-string">"zone_file"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> } }.</code> </pre><br>  If an error occurs during the execution of the request, the status changes accordingly: <br><br>  HTTP / 1.1 403 Forbidden <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"forbidden"</span></span>, <span class="hljs-string"><span class="hljs-string">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"You do not have access for the attempted action."</span></span> }.</code> </pre><br>  Thus, with proper construction of the protocol of interaction between the client and the server, no deserializer will have any problems. <br><br>  Deserializers, however, who build the parse tree on the transferred object, have their advantage - under certain conditions they allow parsing the received string without using dynamic memory.  In my opinion, this is an important advantage, since the dynamic memory is significantly slower compared to the stack, subject to leakage and fragmentation.  The situation with the speed of memory allocation worsens even more in a multi-threaded environment. <br><br>  And here we come to the main point.  In the device under development, it was decided to use scmRTOS (well, I like it - it is small and it works), and there is no memory manager in it, which hinted at writing my own.  And since all the rest of the logic was implemented without the use of dynamic memory and it is well known from the course of algorithms that context-free grammars (to which JSON should be treated) can be parsed with a stack machine, it was decided to try to write a deserializer using only the stack. <br><br>  The serializer in the firmware was used very actively and (subjectively, since it was not compared with anything) showed excellent results.  Unfortunately, by the time the device was finished working on the device, the deserializer had not yet been written.  Nevertheless, the idea captured, and as a result, it was added, so on.  "In production" has not yet been used. <br><br><h4>  Serializer </h4><br>  The serializer itself consists of two classes: the <i>JSONSerializer</i> class and the <i>Serializer</i> class inheriting from it (which will allow us to further implement serialization in XML, at least I hope so).  Actually, <i>Serializer</i> implements the tree traversal logic, and <i>JSONSerializer</i> converts data to text and transfers text to <i>Handler</i> for further sending to the counterparty. <br><br>  <i>Handler's</i> interface looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SerializeHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializeEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span>; };</code> </pre><br>  The <i>bool operator () operator (const char * str, uint32_t len)</i> receives a message in portions as it is serialized.  The call to <i>bool SerializeEnd ()</i> reports that the object has been serialized.  This was done for one simple reason: since the serializer knows nothing about where the final message is displayed (for example, in USB) and, accordingly, does not know whether the message will be fragmented during transmission or turn into additional fields ‚Äî formation (with necessary), the filling and forwarding of the buffer was assigned to the <i>Handler</i> . <br><br><h5>  Serialization of a specific class </h5><br>  To serialize an object of a certain class, you need to inherit this class from the jsmincpp :: serialize :: Serialized class.  This action is necessary to select the correct overloaded function inside the serializer.  It does not carry any special load, since the jsmincpp :: serialize :: Serialized class does not contain fields. <br><br>  It is also necessary to implement the function <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Serializer &amp;</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> { ‚Ä¶ }</code> </pre><br>  For example, for some class it will look like this: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SerializedClass</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Serialized { <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> One; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Two; SerializedClass( ) : One( <span class="hljs-number"><span class="hljs-number">0</span></span> ), Two( <span class="hljs-number"><span class="hljs-number">0</span></span> ) { } SerializedClass( <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> one, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> two ) : One( one ), Two( two ) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( S &amp;serializer )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ SERIALIZE( One ); SERIALIZE( Two ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  If it is necessary to serialize nested objects, their classes must be subjected to the same modifications. <br><br>  Further serialization looks elementary: <br><pre> <code class="hljs pgsql">typedef Serializer &lt; JSONSerializer &lt; SerializeHandler &gt; &gt; Serializer_t; SerializeHandler <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>; Serializer_t serializer( <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> ); SerializedClass obj; ‚Ä¶ serializer.Serialize( obj )</code> </pre><br><br><h5>  Serialization from a pointer to the base class or how to drag a camel into the eye of a needle </h5><br>  If you, like me, have a serializer in a separate thread and take objects for serialization from its message queue, the previous version does not fit (why drag RTTI to the controller when we have already abandoned dynamic memory?).  There is a notorious question with a camel.  It will be solved by a certain base class, from which we will inherit our serializable class and put a pointer to it in the queue.  This class is <i>AbstractSerialized</i> .  It, in turn, is inherited from <i>Serialized</i> , which allows serializing the resulting class in the above scenario (if necessary). <br><br>  It looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Serializer &lt; JSONSerializer &lt; SerializeHandler &gt; &gt; Serializer_t; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SerializeObj</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractSerialized &lt; Serializer_t &gt; { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Serializer_t &amp;serializer )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ ‚Ä¶ } }; ‚Ä¶ SerializeObj *obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializeObj; ‚Ä¶ <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.Send( obj ); ‚Ä¶ SerializeHandler handler; <span class="hljs-function"><span class="hljs-function">Serializer_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serializer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( handler )</span></span></span></span>; AbstractSerialized &lt; Serializer_t &gt; *obj = <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.Get( ); serializer.Serialize( obj ); ‚Ä¶</code> </pre><br>  Behind this, we are done with the serialization of objects. <br><br><h5>  Extension of the serializer functionality </h5><br>  I absolutely do not like "things in themselves."  If there is a choice, I prefer something that can be expanded (especially great if it is a living space) and adapted to suit my needs.  This serializer can also be expanded by allowing arbitrary classes to be output to a channel in a specific way.  Let me explain with an example what this means. <br><br>  In the device under development, messaging with the ‚Äúbig brother‚Äù was carried out (as a first approximation) via USART at a speed of 19,200 bps.  The longest message contained an array of 6 floats.  Since the developed device used 6 absolute encoders with an accuracy of about 0.5 degrees and, accordingly, the absolute values ‚Äã‚Äãof the values ‚Äã‚Äãdid not exceed 360 degrees, the serialized value for the float looked like this: <i>222.001999</i> .  It has 5 extra digits (in fact, the last half of the characters are superfluous and do not carry a semantic load).  You can somewhat speed up the exchange of messages, if you throw out extra characters.  We cannot in any way influence the float's serialization library, but we can write a serializer for an arbitrary class.  Thus, the class <i>FloatPoint_3x1</i> was created. <br><br>  The class itself looks like this: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatPoint_3x1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FloatPoint_3x1( ) : _val( <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ) { } FloatPoint_3x1( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> val ) : _val( val ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _val; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _val; };</code> </pre><br>  Nothing special - a container for data.  Note, you don't need to inherit it from <i>Serialized</i> ! <br><br>  The serialization function for it looks like this: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S &gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt;( S &amp;serializer, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FloatPoint_3x1 &amp;data ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f [ ] = <span class="hljs-string"><span class="hljs-string">"%3.1f"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [ <span class="hljs-number"><span class="hljs-number">10</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len = ::<span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>( buffer, f, data.GetValue( ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serializer.GetHandler( )( buffer, len ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Everything is simple - we form a text string in the buffer and output it to the <i>Handler</i> .  As a result, the serialized value looks like this: <i>222.0</i> . <br><br>  This feature is a very powerful thing - we have full control over the output stream. <br><br><h4>  Deserializer </h4><br>  Deserialization is done by the <i>Deserializer</i> class (unexpected, right?), Which can work in two modes: <br><br><ol><li>  gets when creating a list of classes into which it will try to deserialize received messages; <br></li><li>  receives as input an object of a specific class, into the fields of which it will try to deserialize the received message. <br></li></ol><br>  When instantiating a deserialization class, the first template parameter and the first parameter are passed to the constructor, the class responsible for reading the received data, with the following minimum set of methods: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputStream</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SymbolStream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++( ); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*( ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SymbolStream &amp;other ); <span class="hljs-function"><span class="hljs-function">SymbolStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">End</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span>; };</code> </pre><br>  The idea is peeped at the STL input iterators and working with it should look familiar. <br><br>  The <i>SymbolStream &amp; operator ++ ()</i> method reads the next character from the input device (if read is buffered, it moves to the next character in the buffer) or gets up in anticipation of the arrival of a new character. <br><br>  The <i>char operator * ()</i> method returns the current character. <br><br>  The <i>SymbolStream End ()</i> and <i>bool operator == (const SymbolStream &amp; other) methods</i> are designed to determine when the input stream has reached the end-of-stream state (end of stream). <br><br><h5>  Deserialization with automatic selection from the list of classes </h5><br>  When the deserializer class is instantiated by the second template parameter, a list of classes is transferred, into which fields the received messages can be deserialized. <br><br>  Since telepaths, as usual, are on vacation, and the magic is not available to us, the deserializer must decide on the basis of some signs what message was specifically taken.  By a titanic effort of will, it was decided to accept the message format as follows: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"&lt;  &gt;"</span></span>:{&lt;  &gt;}}.</code> </pre><br>  Nested classes are allowed, the nesting level is determined by the free space on the stack.  This mode is suitable, for example, for embedded devices with data exchange via USB CDC ACM (virtual COM port) or USART, i.e., where there is one channel for exchanging all messages and there are no signs to determine which class belongs message.  This somewhat limits the use of deserialization in ready-made solutions without additional adaptation, but is ideally suited for newly designed systems. <br><br>  In the program it looks like this: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OtherObject</span></span></span><span class="hljs-class">; typedef </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObjectsList</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DESERIALIZEOBJ</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class"> ), </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DESERIALIZEOBJ</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OtherObject</span></span></span><span class="hljs-class"> ) &gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SerializeList_t</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  Where <i>‚ÄúObject‚Äù</i> and <i>‚ÄúOtherObject‚Äù</i> are the names of classes being deserialized (not instantiated objects! The deserializer will create objects itself). <br><br>  The third template parameter and the second parameter of the constructor are passed to the allocator (although, probably, it is more correct to say the factory).  This class has the following interface: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Creator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T * )</span></span></span></span>; };</code> </pre><br>  The <i>T * Create (const T &amp;)</i> method allocates memory and allocates the created <i>‚ÄúT‚Äù</i> object in it. <br><br>  The <i>void Delete (T *)</i> method, respectively, deletes a specific object created earlier. <br>  The deserialization itself is performed by the <i>bool Deserialize (H &amp; handler)</i> method of the deserializer.  A handler is passed to its input, which will receive control if the received message is successfully deserialized.  Its interface is as follows: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: <span class="hljs-type"><span class="hljs-type">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()( <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> *param ); <span class="hljs-type"><span class="hljs-type">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()( OtherObject *param ); ‚Ä¶ };</code> </pre><br>  Actually, one overloaded <i>operator ()</i> per class from the list of messages being deserialized. <br><br>  This is necessary because I cannot return different classes from the <i>bool Deserialize (H &amp; handler)</i> method of the deserializer.  Only in the <i>Handler</i> methods we have access to the type of the deserialized message.  Knowing the type, the received message can, for example, be placed in the necessary queue for subsequent processing by another thread or processed on the spot. <br>  In case of successful deserialization, the <i>bool Deserialize (H &amp; handler)</i> method returns <i>true</i> and <i>false</i> in case of an error. <br><br>  We deserialize one message at a time, and to continue processing, we call the method again (the necessary number of times). <br>  Looks like this: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OtherObject</span></span></span><span class="hljs-class">; ‚Ä¶ typedef </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ObjectsList</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DESERIALIZEOBJ</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class"> ), </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DESERIALIZEOBJ</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OtherObject</span></span></span><span class="hljs-class"> ) &gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SerializeList_t</span></span></span><span class="hljs-class">; ‚Ä¶ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SocketStream</span></span></span><span class="hljs-class"> s( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">socket</span></span></span><span class="hljs-class"> ); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeserializeHandler</span></span></span><span class="hljs-class"> h( ); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Deserializer</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SymbolStream</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SerializeList_t</span></span></span><span class="hljs-class"> &gt; d( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> ); if( !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Deserialize</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">h</span></span></span><span class="hljs-class"> ) ) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeserializeErrorHandler</span></span></span><span class="hljs-class">( );</span></span></code> </pre><br><h5>  A few words about the non-use of dynamic memory </h5><br>  By default, the <i>StaticCreator</i> class is used as the <i>Creator</i> : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> BuffSize &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticCreator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> _buff [ BuffSize / <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ( _buff ) T; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T * )</span></span></span><span class="hljs-function"> </span></span>{ } };</code> </pre><br>  It creates the required objects in its buffer. <br><br>  Thus, after deserialization, in the Handler handler, <i>you</i> must copy the deserialized object somewhere.  In the prototype of this serializer, I passed the object by value to the queue of another thread for further processing (which made it possible to completely abandon the use of dynamic memory).  If this behavior does not suit and there is an opportunity to use dynamic memory, you need to use another <i>Creator</i> or write your own. <br><br>  <i>MallocCreator</i> is available in the <i>library</i> , using <i>Malloc ()</i> to allocate objects and <i>SharedPrtCreator</i> , which allows the use of smart pointers ( <i>std :: shared_ptr</i> ).  For more, I did not have enough imagination. <br><br><h5>  Deserialization of a specific class </h5><br>  If we know the specific type of message being deserialized, we can use the second mode of the deserializer.  Just pass a pointer to the object into which we want to deserialize the received message to the overloaded <i>bool Deserialize</i> method <i>(O * obj)</i> . <br><br>  You can specify the <i>NullObj</i> dummy object as the only member of the deserialization list.  It looks like this: <br><br><pre> <code class="hljs lisp"> SocketStream s( <span class="hljs-name"><span class="hljs-name">socket</span></span> )<span class="hljs-comment"><span class="hljs-comment">; typedef ObjectsList &lt; DESERIALIZEOBJ(NullObj) &gt; SerializeList_t; Deserializer &lt; SymbolStream, SerializeList_t &gt; d( s ); Object obj; d.Deserialize( &amp;obj );</span></span></code> </pre><br>  Or in the case of using <i>shared_ptr</i> , like this: <br><br><pre> <code class="hljs xml"> SocketStream s( socket ); typedef ObjectsList <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DESERIALIZEOBJ</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">NullObj</span></span></span><span class="hljs-tag">) &gt;</span></span> SerializeList_t; Deserializer <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SymbolStream</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SerializeList_t</span></span></span><span class="hljs-tag"> &gt;</span></span> d( s ); auto obj = make_shared<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Object</span></span></span><span class="hljs-tag"> &gt;</span></span>(); d.Deserialize( obj.get( ) );</code> </pre><br>  In this mode of operation (regardless of the transferred <i>Creator</i> ), the dynamic memory is not used by the deserializer ( <i>Creator is</i> instantiated, but its methods are not called). <br><br><h5>  Extension of deserialization functionality </h5><br>  This deserializer allows the extension of its functionality.  First, the possibility of expanding the number of user classes being deserialized.  Secondly, the ability to change the memory allocation strategy for the class being deserialized. <br><br>  Consider the extension of the functional on the example of some class <i>StaticString</i> .  This class will allow us to deserialize strings in systems where there is no dynamic memory.  Of course, it contains many restrictions, but with some skill you can use it.  The class looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Num &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticString</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: StaticString( ) : _length( <span class="hljs-number"><span class="hljs-number">0</span></span> ) { _buff [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } StaticString( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str ) { Assign( str ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Num == _length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _buff[ _length++ ] = symbol; _buff[ _length ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> strSize = ::<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( str ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( strSize &gt; Num - _length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ::<span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>( _buff, str ); _length += strSize; _buff[ _length + <span class="hljs-number"><span class="hljs-number">1</span></span> ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str )</span></span></span><span class="hljs-function"> </span></span>{ _length = <span class="hljs-number"><span class="hljs-number">0</span></span>; _buff[ _length ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Add( str ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _buff; } <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GetLength( ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _length; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> _length; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _buff [ Num + <span class="hljs-number"><span class="hljs-number">1</span></span> ]; };</code> </pre><br>  Actually, nothing special - a static array for characters, around which the logic of working with a string is built. <br><br>  Deserialization is done with the following code: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Hash, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Num &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticStringParam</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { HASH = Hash }; StaticStringParam( StaticString&lt; Num &gt; ¬∂m ) : _param( param ) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( D &amp;deserializer )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseStaticString( _param, deserializer.GetStream( ) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: StaticString&lt; Num &gt; &amp;_param; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Hash, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Num &gt; StaticStringParam &lt; Hash, Num &gt; MakeParam( StaticString&lt; Num &gt; ¬∂m ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StaticStringParam &lt; Hash, Num &gt;( param ); }</code> </pre><br>  As you can see, we have full access to the input stream of characters, therefore, we can deserialize anything. <br><br><h5>  Some limitations when using this deserializer </h5><br>  At the stage of writing the concept, the following problem arose: JSON itself does not limit the length of the parameter name, which requires, generally speaking, the need to use dynamic memory (with the possibility of increasing the size of the allocated buffer), or a static buffer of sufficient size to accommodate the longest name.  It was a pity for the memory (development, I recall, was originally conducted for the microcontroller), so the following idea was realized: what if not to accumulate the characters of the parameter name in the buffer and then compare it with the names of the deserialized parameters, and take the CRC32 from the input string, and later compare with the calculated at the compilation stage (constexpr function) CRC32 from the field names of the deserializable class.  This saves us memory (instead of strings, only uint32_t is stored) and speeds up the comparison, but adds headaches to possible CRC32 collisions from parameter names.  What can I say ... Test your code more, the tests should catch such problems!  You are testing your code, right? <br><br><h4>  STL container support </h4><br>  In the process of reading the forums, sometimes I came across messages from the sufferers asking them to indicate the JSON serializer / deserializer with STL support.  There was an overwhelming desire to support the afflicted.  Which was implemented - like all the main STL containers are supported, both by the serializer and by the deserializer.  If something is not supported, you can always finish the support.  There is nothing more to say about this. <br><br><h4>  Comparison and benchmarks </h4><br>  The serializer itself is rather trivial, so there is no desire even to compare it with anyone. <br>  It was more interesting to compare the deserializer with competing libraries.  Since I didn‚Äôt find C ++ libraries suitable for use on the controller (I didn‚Äôt look for it in general), but adding STL support and expandability transferred the product to another consumer category ‚Äî the ability to use on full-fledged servers, I compared the libraries with those libraries that I recommend using found on the forums.  The comparison, of course, is not comprehensive - only four competitors.  But I did not want to test competitors further, because the results, in my opinion, were very depressing.  The tests themselves are <a href="https://drive.google.com/open%3Fid%3D0B97fmWkRKVpeSXJETkZnODA3NkU">here</a> , in the subdirectories of the / src directory in the * .mk files, correct the paths to the compiler and libraries (except Qt. To build it, create a project in QtCreator and copy * .cpp into it).  The build is done in the root directory by calling make &lt;benchmark&gt;.  You can view the build projects simply by calling make. <br><br>  So, the following libraries were tested (besides the one developed): <br><br><ul><li>  <a href="https://bitbucket.org/zserge/jsmn/wiki/Home">jsmn</a> is a C project, but does not use dynamic memory, it was interesting to compare; <br></li><li>  <a href="https://www.qt.io/ru/">Qt</a> ; <br></li><li>  <a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp</a> ; <br></li><li>  <a href="http://www.tntnet.org/cxxtools.html">cxxtools</a> . <br></li></ul><br>  The comparison was made as follows: according to the documentation of a specific library (well, naturally, since I understood it), an application was written, the task of which was to deserialize some (syntactically and semantically correct) lines into an object of a certain class.  And so 1 000 000 times, because on my laptop (i3) fewer iterations took place in a very short time.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work time was measured by the time command and was taken from the ‚Äúuser: XXX‚Äù line. </font><font style="vertical-align: inherit;">It is clear that the test does not pretend to be serious, but some conclusions can be made. </font><font style="vertical-align: inherit;">Tests were run 100 times. </font><font style="vertical-align: inherit;">The results are presented in the table.</font></font><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Library / framework </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Best execution time, with </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relation to the leader of the test </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Average execution time, with </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relation to the leader of the test </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jsmincpp </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.219 </font></font><br></td><td>  - </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.22252 </font></font><br></td><td>  - </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jsmn </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.595 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.716895 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.60017 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.697151 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt </font></font><br></td><td>  1.359 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.205479 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.54353 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.93659 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jsoncpp </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.981 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22.74429 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.89901 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 26.51002 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cxxtools </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.26 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 24.01826 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.95608 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 26.76649 </font></font><br></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some comments. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In terms of execution speed, we almost made a program with a library in C (who claimed that C ++ is slow? If you are writing in C ++, is it not worth thinking about your professional suitability?). </font></font><br></li><li>    ,   ,  .     ,  ,   cxxtools   shared      6.391 ,    7.63804 , . .         shared .    :  Qt   . ,      shared , ,     Qt     ‚Äî  0.4 ‚Äî 0.6 . (   ,  C++ ?!). <br></li><li>    striped  : <br><ul><li>  jsmincpp ‚Äì 8040 , <br></li><li>  jsmn ‚Äì 8792 . <br></li></ul><br>    700  ( 10%)    C'  . (  ,  C++   ? ,    !) <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But seriously, can anyone know the fast JSON deserialization libraries? </font><font style="vertical-align: inherit;">It would be interesting to compare the possibilities and look at the internal structure.</font></font></div><p>Source: <a href="https://habr.com/ru/post/268015/">https://habr.com/ru/post/268015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268005/index.html">Sonic Pi music programming language, All-Russian programming contest and volunteer meeting this Friday</a></li>
<li><a href="../268007/index.html">Linux botnet organizes DDoS attacks with 150 Gbps traffic and higher</a></li>
<li><a href="../268009/index.html">We teach employees English: the experience of Edison</a></li>
<li><a href="../268011/index.html">PyNSK # 3 - the third meeting of the Novosibirsk Python community</a></li>
<li><a href="../268013/index.html">Troika Hoare</a></li>
<li><a href="../268017/index.html">Porting a C # / XAML Windows 8.1 application to UWP</a></li>
<li><a href="../268019/index.html">Network for the smallest. Micro issue ‚Ññ5. Networking FAQ</a></li>
<li><a href="../268021/index.html">Microsoft scared users of Windows 7</a></li>
<li><a href="../268023/index.html">The story of a "hack" or How Yahoo gave me a login and password from someone else's mail</a></li>
<li><a href="../268025/index.html">How-to: The process of creating the layout of html-letters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>