<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Security issues of Android applications: classification and analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Image : etnyk , CC BY-NC-ND 2.0 

 The use of smartphones in everyday life is not limited to voice calls and SMS. The ability to download and execute ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Security issues of Android applications: classification and analysis</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/pt/blog/332904/"><img src="https://habrastorage.org/web/125/252/65c/12525265c83e4f6dba6c60d85e559d94.jpg"></a> <br><br>  <i>Image</i> : <a href="https://www.flickr.com/photos/etnyk/5588953445/">etnyk</a> , <a href="https://creativecommons.org/licenses/by-nc-nd/2.0/">CC BY-NC-ND 2.0</a> <br><br>  The use of smartphones in everyday life is not limited to voice calls and SMS.  The ability to download and execute software, as well as mobile Internet access, has led to the emergence of a huge number of mobile applications.  The functionality of a modern smartphone consists of browsers, social networking client programs, office applications and all kinds of services that work on the web.  Android devices have taken up most of the smartphone market due to the open architecture of the Android platform and a convenient developer API.  Currently, Android is the most popular mobile OS with a market share of more than 75%.  The number of applications downloaded from the Google Play store in 2016 amounted to 65 billion <a href="https://habr.com/ru/company/pt/blog/332904/">[1]</a> . <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In parallel, there is a rapid growth in the number of malicious applications: in 2015, 2.3 million of them were detected <a href="https://habr.com/ru/company/pt/blog/332904/">[3]</a> .  In addition, about 60% of Android devices work on versions of the OS with known vulnerabilities, and they can potentially be attacked by attackers <a href="https://habr.com/ru/company/pt/blog/332904/">[6]</a> .  These threats, in turn, led to the development of remedies.  The official Google Play store introduced application filtering using the Google Bouncer sandbox.  Anti-virus companies began to release their products under Android (although, as shown in <a href="https://habr.com/ru/company/pt/blog/332904/">[8]</a> , many of them themselves contain dangerous vulnerabilities).  The number of scientific publications on this topic has also increased: one of the 2015 survey reviews on security solutions for Android <a href="https://habr.com/ru/company/pt/blog/332904/">[2]</a> has more than 40 projects and does not mention all currently known research.  Due to the fact that mobile devices are the source and storage of a large amount of sensitive data, the security problem of the Android OS and its applications is particularly acute. <br><br>  The Android platform is free software, its source code is completely open.  Device manufacturers independently develop the code base, creating specialized firmware in order to achieve greater functionality and better performance.  A side effect of such activities are vulnerabilities and weaknesses in the implementation of algorithms that are absent in the main code base, but exist on many real devices.  Malicious software uses these vulnerabilities to enhance rights and overcome defensive mechanisms.  Identifying vulnerabilities in firmware in the absence of source codes is extremely difficult.  The primary problem is the lack of a controlled execution environment, which is necessary for dynamic analysis. <br><br>  Thus, a complete analysis of the security of a device requires the study of the properties of system and application software as a whole.  This article provides a personal classification of Android security issues, as well as a list of requirements for the full-system analysis of the Android platform. <br><br><h2>  1. Android OS device </h2><br>  The Android OS is based on the Linux kernel with some architectural changes that were made by Google engineers.  Applications for the Android operating system are developed in the Java language.  Starting with Android 1.5, the Android NDK toolkit has been introduced, which allows you to develop application modules in C and C ++ and compile them into native code <a href="https://habr.com/ru/company/pt/blog/332904/">[4]</a> .  Applications are delivered in the form of files of the special format APK, which is a ZIP-archive with a certain directory structure and files.  The app APK file contains: <br><br><ul><li>  manifesto; </li><li>  modules compiled into native code (shared libraries .so); </li><li>  various application resources; </li><li>  DEX file; </li><li>  other necessary files. </li></ul><br>  Starting with Android 4.4, two application execution environments are supported: Dalvik VM and ART.  It should be noted that the process of preparing the APK file has not changed, only the process of installing applications in the new ART runtime has changed.  Starting with version 5.0, the ART runtime has become the default instead of Dalvik VM. <br><br>  The Dalvik VM runtime for Java programs on Android is very different from the ‚Äúregular‚Äù Java VM.  First, when compiling a Java program, it is compiled into the bytecode of the Dalvik virtual machine, which is very different from the bytecode of the HotSpot virtual machine.  The Dalvik virtual machine is a registered one, which makes its implementation on RISC architectures, often used in mobile devices, more efficient.  Also, when developing Dalvik, memory limitations in mobile devices were taken into account.  Starting with Android 2.2, the Dalvik runtime includes a JIT compiler that compiles hot chunks of Java code into native code <a href="https://habr.com/ru/company/pt/blog/332904/">[5]</a> . <br><br>  The standard Java libraries were either replaced with the refined libraries from the Apache Harmony package or rewritten.  When you compile a Java program, you get a DEX (Dalvik Executable) file that contains the byte code for the Dalvik virtual machine.  The file format was designed to reduce the memory footprint and differs significantly from the standard JAR format.  To call modules implemented in native code from Java programs, the JNI interface is used.  It should be noted that it is possible to load machine modules dynamically over the network using the DexClassLoader component. <br><br><h2>  2. Security issues </h2><br>  The parent process for all Android applications is the Zygote process.  This process is an Android application framework, in which all the necessary libraries of the Android environment are already loaded, but the code of the application itself is missing.  The launch of the Android application from the point of view of the operating system is as follows: <br><br><ol><li>  Initially, the system calls the fork to create a descendant from the Zygote process (see Figure 1). </li><li>  In this new process, the file of the application being launched is opened (open system call). </li><li>  There is a reading of information about the class files (classes.dex) and resources from the application file.  Sockets are opened for IPC. </li><li>  The mmap system call is made to map the application files to memory. </li><li>  The runtime environment sets up the required environment and executes the application (interprets the Dalvik byte code or transfers control to the functions in the executable code in the case of ART <a href="https://habr.com/ru/company/pt/blog/332904/">[7]</a> ). </li></ol><br>  At the kernel level of the Android OS, each application is a separate process with unique user / group ID values ‚Äã‚Äãthat are given to it during installation.  Thus, each program works in its sandbox.  Starting with version 4.3, in addition to this security policy, the use of the mandatory access control component SELinux has been added <a href="https://habr.com/ru/company/pt/blog/332904/">[10]</a> . <br><br><img src="https://habrastorage.org/web/8d8/956/6ed/8d89566edd6b499f88d0833738f03e11.png"><br><br>  <i>Fig.</i>  <i>1. Run a new application in the Android OS</i> <br><br>  By default, an application is limited in its capabilities and cannot do anything to adversely affect another application or user: neither read user data, nor modify system applications;  No access to the network.  To gain access to various resources, the application accesses the Android OS services.  Access permissions are set statically in the application manifest file and are issued to the application during its operation as needed.  The system prompts the user for consent to grant these permissions during installation or during the application update.  Responsibility for issuing access to an application lies with the user, he himself decides which application to give permission for certain actions, and which one does not give, during his installation.  Using this approach, in which all permissions are issued at once when installing an application, has led to the fact that users began to distribute privileges to applications without thinking about the consequences.  In turn, applications began to request more and more permissions as their functionality expanded.  In Android 6 Marshmallow, this system is replaced by another: the application requests access to resources from the user during its operation, and the user can either allow access or deny it <a href="https://habr.com/ru/company/pt/blog/332904/">[11]</a> . <br><br>  The Android application consists of four types of components and does not contain a main () function or any other single entry point.  Application components interact with each other using special messages called Intent. <br><br>  Components called Activity define the user interface.  Typically, a single Activity component is used to describe a single screen of an application.  An activity can start another Activity by passing parameters using the Intent mechanism.  During operation, only one Activity can operate and process user input, the rest for this time remain frozen or destroyed, depending on the selected application mode. <br><br>  Components called Service <a href="https://habr.com/ru/company/pt/blog/332904/">[9]</a> perform background processing.  When an Activity needs to perform some operation, such as downloading a file or playing music, and continue working when the user has moved to another application or turned off the current one, the application starts a service whose purpose is to perform this operation.  Developers can use Service as a daemon application that starts at system boot time.  The Service component usually supports RPC (Remote Procedure Call), so other system components can access it. <br><br>  The content provider component stores and exchanges data using the relational database interface.  Each Content provider contains a unique URI for data and processes requests to it as SQL queues (Select, Insert, Delete). <br><br>  Components of the Broadcast receiver act as mailboxes for messages from other applications. <br><br>  Security issues arising in the Android OS were considered in [ <a href="https://habr.com/ru/company/pt/blog/332904/">2</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">12</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">13</a> ], but the classification of problems into categories is given only in the article <a href="https://habr.com/ru/company/pt/blog/332904/">[2]</a> .  This classification is quite detailed and covers many security problems, but it has several significant flaws: some categories cover a wide area of ‚Äã‚Äãvulnerabilities, while others are quite specialized;  these categories of vulnerabilities do not correlate with the software levels of the Android OS architecture;  vulnerabilities from Internet sources are not covered, and vulnerabilities in protocols and equipment are poorly covered (paragraphs 2.7 and 2.8 in our classification).  The following classification of vulnerabilities eliminates these shortcomings. <br><br><h3>  2.1.  Vulnerabilities of the Linux kernel and its modules </h3><br>  This category of problems includes vulnerabilities that are inherent in all operating systems based on the same version of the Linux kernel as the Android operating system.  Exploits that exploit vulnerabilities in the kernel can get user data or system administrator rights.  Raising the privileges of the process to the rights of a system administrator, a malicious program can disable the Android security system, insert malicious code into existing programs, and install a rootkit.  In addition, manufacturers of various devices add modules to the kernel for their devices;  There may also be vulnerabilities in these modules.  Examples of privilege elevation vulnerabilities are described in [ <a href="https://habr.com/ru/company/pt/blog/332904/">14</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">15</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">16</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">64</a> ].  It is also worth noting that a vulnerability was recently discovered in the ashmem component for interprocess communication in Android <a href="https://habr.com/ru/company/pt/blog/332904/">[62]</a> . <br><br><h3>  2.2.  Vulnerabilities of device manufacturers' modifications and components </h3><br>  Recently, manufacturers of various mobile devices began to release their modified Android firmware.  These firmware can contain various applications and services developed by the device manufacturer, which can often not be removed.  For example, in October 2016, a hidden backdoor was discovered in Foxconn firmware <a href="https://habr.com/ru/company/pt/blog/332904/">[63]</a> .  An analysis of these services, given in articles <a href="https://habr.com/ru/company/pt/blog/332904/">[17]</a> , shows that they contain from 65 to 85% of vulnerabilities found throughout the system.  In addition, it is worth noting that vulnerabilities that were found and fixed in the main Android branch can remain in the device manufacturers for a long time [ <a href="https://habr.com/ru/company/pt/blog/332904/">18</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">19</a> ]. <br><br><h3>  2.3.  Machine Code Module Vulnerabilities </h3><br>  Android applications support the launch of machine code via the JNI interface.  This gives rise to another category of vulnerabilities associated with well-known vulnerabilities of memory leaks in low-level languages ‚Äã‚Äã(for example, in C and C ++) <a href="https://habr.com/ru/company/pt/blog/332904/">[20]</a> .  Since there are no restrictions at the Android OS process level, other than those imposed by the Linux kernel, third-party libraries in machine codes can use permissions issued to the entire application to perform malicious activity (see also the next category of vulnerabilities, Section 2.4).  Also, application code modules in machine codes are used by the authors of malicious applications in order to circumvent the analysis and monitoring tools of the Android level.  These modules can also use anti-analysis techniques used in normal programs. <br><br><h3>  2.4.  Vulnerabilities of intercomponent interaction mechanisms </h3><br>  This category includes vulnerabilities associated with interactions between various application components.  Since, at the operating system level, the application is limited to the process sandbox, it needs a mechanism to access the components of the Android OS to interact with them.  This happens through the device / dev / Binder and various other Android OS services.  As mentioned above, the parameters of this access are specified in the manifest file, as an XML file with permissions.  The analysis given in [ <a href="https://habr.com/ru/company/pt/blog/332904/">12</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">21</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">22</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">23</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">24</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">25</a> ] points to the shortcomings of this system of restrictions and shows ways to circumvent them.  For example, an application can use the access rights of another application and get data through it through the ICC.  There may also be vulnerabilities associated with third-party libraries.  Third-party libraries used in the application receive the same set of restrictions as the application itself.  Therefore, third-party libraries can use permissions issued to the entire application to commit malicious activity.  Applications can also intercept system events sent via a broadcast request and store information about incoming calls and SMS. <br><br><h3>  2.5.  Vulnerabilities in the applications themselves </h3><br>  Each application stores some user data.  This data must be properly protected so that other applications cannot access it ‚Äî but this protection is not always provided.  For example, Skype in one version of the application saved the contact database in clear text on disk.  Thus, contacts could be read by any other application that has access to the disk <a href="https://habr.com/ru/company/pt/blog/332904/">[26]</a> .  Applications can also use cryptographic libraries with errors <a href="https://habr.com/ru/company/pt/blog/332904/">[27]</a> or some proprietary implementations.  In addition, not all applications produce good user authentication and authorization.  In addition, applications may allow SQL injections and are prone to XSS attacks.  It is also worth noting that most of the developed applications are written in Java without using any protection for binary code, and Java byte-code, as is well known, is easy to disassemble and analyze.  It is worth noting that this category of vulnerabilities also includes the well-known Mobile OWASP-10 list.  Many such vulnerabilities are described in [ <a href="https://habr.com/ru/company/pt/blog/332904/">28</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">29</a> ]. <br><br><h3>  2.6.  Vulnerabilities in embedded services and libraries </h3><br>  The standard set of libraries and services running on Android also contains vulnerabilities.  For example, a Stagefright vulnerability was recently discovered in a library for displaying video in MMS messages, to which all versions of Android were exposed, starting with 2.2 <a href="https://habr.com/ru/company/pt/blog/332904/">[30]</a> .  A vulnerability was later discovered in the MediaServer component, which affects all versions of Android c 2.3 to 5.1 <a href="https://habr.com/ru/company/pt/blog/332904/">[31]</a> .  The article <a href="https://habr.com/ru/company/pt/blog/332904/">[13]</a> shows the vulnerabilities of the Dalvik runtime: by running a large number of processes in the system, you can ensure that the subsequent process starts with administrator rights. <br><br><h3>  2.7.  Internet sources </h3><br>  Android applications are distributed through a wide number of sources in addition to the official app store.  Since Android applications are written mainly in Java, they can be easily redeveloped and repackaged using malicious code [ <a href="https://habr.com/ru/company/pt/blog/332904/">32</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">33</a> ].  In addition, as shown in article <a href="https://habr.com/ru/company/pt/blog/332904/">[34]</a> , the Bouncer application analysis sandbox used in the official catalog is easy to work around.  Therefore, the official store itself also contains a large number of malicious programs.  In addition, Android supports remote installation of applications through Google Play on devices associated with a Google account.  Thus, if you hack a Google account for a device, you can install a malicious application from Google Play that the attacker previously uploaded there.  At the same time, no confirmation of these actions is required on the mobile phone screen, as they are requested in the browser window and the application is installed on the phone in the background when accessing the Internet.  This category of vulnerabilities also includes the use of social engineering, when they propose to install an application from an unauthorized source to continue work <a href="https://habr.com/ru/company/pt/blog/332904/">[35]</a> . <br><br><h3>  2.8.  Vulnerabilities of hardware and related modules and protocols </h3><br>  Mobile devices running Android OS have a wide range of equipment for interacting with the outside world.  Corresponding vulnerabilities can be exploited in close proximity to the device or if there is physical access to the device. <br><br>  Examples of such attacks include a Denial of Service attack on Wi-Fi Direct technology <a href="https://habr.com/ru/company/pt/blog/332904/">[36]</a> , theft of credit card data using NFC <a href="https://habr.com/ru/company/pt/blog/332904/">[37]</a> , remote code execution via Bluetooth <a href="https://habr.com/ru/company/pt/blog/332904/">[38]</a> , installing a malicious application without the user's knowledge via adb with using the backup mechanism <a href="https://habr.com/ru/company/pt/blog/332904/">[39]</a> .  In <a href="https://habr.com/ru/company/pt/blog/332904/">[13]</a> , vulnerabilities are shown that can be used to elevate application privileges using errors in the adb protocol implementation. <br><br><h2>  3. Tools for analyzing Android applications </h2><br>  Since the first Android phones were released, a large number of tools for analyzing Android applications have been written.  The most comprehensive review of these tools is contained in articles [ <a href="https://habr.com/ru/company/pt/blog/332904/">40</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">41</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">42</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">2</a> ].  In the first three sources, the tools are classified by type of analysis: static, dynamic, and their combination (mixed).  The article <a href="https://habr.com/ru/company/pt/blog/332904/">[2]</a> uses the classification of tools according to the stages of application deployment on an Android device.  In our work, the classification by type of analysis is used. <br><br><h2>  Static analysis </h2><br>  Static analysis tools can be divided into the following categories: <br><br><ul><li>  Tools that extract meta information from the application manifest and provide information about the requested permissions, Activity components, services and registered Broadcast receivers.  Meta-information is often used later in dynamic analysis to launch application functions. </li><li>  Tools for modifying an existing application bytecode using instrumentation techniques.  This allows, for example, adding tracing functionality to existing applications. </li><li>  Tools that implement the Dalvik bytecode decompiler or disassembler. </li></ul><br>  One of the most popular tools for reverse engineering is Apktool <a href="https://habr.com/ru/company/pt/blog/332904/">[43]</a> .  It has the ability to decode application resources into approximately the original form, repacking applications back into APK / JAR files, debugging smali bytecode.  Another well-known project smali / backsmali <a href="https://habr.com/ru/company/pt/blog/332904/">[44] is</a> used to decompile and compile Dalvik byte-code in apktool.  Also, the Dedexer tool <a href="https://habr.com/ru/company/pt/blog/332904/">[45]</a> is often used to disassemble the Dalvik bytecode. <br><br>  Radare2 <a href="https://habr.com/ru/company/pt/blog/332904/">[46]</a> is an open source tool for disassembling, analyzing, debugging and modifying Android application binary files. <br><br>  One of the most versatile tools for static analysis is Androguard <a href="https://habr.com/ru/company/pt/blog/332904/">[47]</a> .  It can disassemble and decompile the application back into Java source code.  Having received two APK files, it can calculate their similarity coefficient for detecting repackaged applications or known malicious applications.  Due to its flexibility, it is used in some mixed analysis tools. <br><br>  A more complete list of static analysis tools can be found in the articles listed above.  It should be noted that static analysis has a number of significant limitations associated with the fact that there is only an abstract view of the program.  For example, static analysis becomes much more difficult if obfusting transformations are applied to the program.  Depending on the complexity of obfuscation, some (and maybe all) static approaches may become completely useless.  If the call to each method is done only indirectly, it is unlikely that a call graph of the program can be constructed.  In Android, this transformation can be done using the Java Reflection API to call methods and create objects instead of using normal calls and instructions to create a new object.  The market for solutions to protect the source code already has several products for obfuscating Android application files that can negate all the benefits of static analysis [ <a href="https://habr.com/ru/company/pt/blog/332904/">48</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">49</a> ].  In more detail about techniques of counteraction to static analysis it is possible to read <a href="https://habr.com/ru/company/pt/blog/332904/">50</a> . <br><br><h2>  Dynamic and mixed analysis tools </h2><br>  Dynamic analysis tools track the behavior of an unknown application at run time when it is run in a controlled sandbox to get a behavioral trace.  To do this, the sandbox is instrumented at various levels of the architecture by sections of code that track the behavior of the application and the Android OS. <br><br><img src="https://habrastorage.org/web/6a7/308/41e/6a730841e4c44a5b97c974c7ac9cc665.png"><br><br>  <i>Fig.</i>  <i>2. Android Sandbox Architecture Levels</i> <br><br>  The Android sandbox architecture is an Android emulator (most often QEMU), within which the Android OS is running.  Instrumentation is performed either at the emulator level, or at the Android OS level, or both there and there.  The Android OS level is also divided into four sublevels: <br><br><ul><li>  applications that </li><li>  application development environment </li><li>  working environment of the application and library </li><li>  kernel and its modules. </li></ul><br>  Techniques used in dynamic application analysis: <br><br><ul><li>  Tracking tagged data.  Such tools are used to track potential leaks of confidential information. </li><li>  Monitoring system calls.  Tools can record system calls using virtual machine instrumentation, strace, or a kernel module.  This allows tracing of machine code. </li><li>  Tracing methods (functions).  Tools can track calls to the Java methods of an application in a Dalvik virtual machine, function calls in machine codes via JNI, system calls, and interrupts. </li></ul><br>  Mixed analysis tools include tools that combine dynamic and static analysis techniques. <br><br><h2>  4. The ideal system for full-system analysis of the Android platform </h2><br>  Articles [ <a href="https://habr.com/ru/company/pt/blog/332904/">40</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">41</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">42</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">2</a> ] contain more than 40 different tools for analyzing Android applications and analyzing Android OS as a whole.  As noted in [ <a href="https://habr.com/ru/company/pt/blog/332904/">34</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">60</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">61</a> ], existing dynamic analysis tools have a number of serious flaws.  These shortcomings are inherent in the standard application analysis tool in the Google Play store - Google Bouncer, as a result of which malicious applications can be distributed through the official store without being detected. <br><br>  Comparison of the capabilities of the approaches and systems in the publications reviewed allows us to formulate the requirements for an ideal analysis system for the Android platform, which is able to analyze the applications and all the layers of the system software.  The system borrows some effective techniques from the works reviewed, combining them with the aim of overcoming shortcomings in existing solutions. <br><br><img src="https://habrastorage.org/web/5d5/bfa/ad0/5d5bfaad04204923b1c4a11096e1fb12.png"><br><br>  The system architecture is shown in Fig.  3. The main component is a full-system emulator that can download both Android OS firmware from real devices and the official Android image for the emulator.  The emulator supports probros probing from a real device, as well as the execution of individual sections of code on real devices.  Inside the emulator, there are modules that provide: <br><br><ul><li>  mixed performance support </li><li>  tracing applications </li><li>  analysis of tagged data </li><li>  interconnect analysis, </li><li>  merging machine and java application code, </li><li>  interaction with real equipment. </li></ul><br>  List of requirements for this system: <br><br><h3>  1. Support for downloading firmware from manufacturers of various devices </h3><br>  A significant disadvantage of all existing analysis tools of the Android OS and its applications is the impossibility of launching firmware from device manufacturers in available emulators.  As was shown in Section 2.2, modified firmware from device manufacturers contain from 65 to 85% of vulnerabilities found throughout the system.  At the moment there are no tools for analysis that would allow to run the firmware from manufacturers.  All existing solutions work on a special build of Android for the GoldFish virtual platform. <br><br><h3>  2. The ability to execute individual pieces of machine code on a real device </h3><br>  According to information from the articles [ <a href="https://habr.com/ru/company/pt/blog/332904/">34</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">61</a> ], there are ways to identify the work inside the emulator.  As a rule, the execution of a QEMU emulator in the binary translation mode is detected, since most sandboxes are based on it.  The methods are based on the different behavior of certain parts of the machine code in the emulator and on the real device.  Since changing the mechanism of binary translation is a difficult task, the execution of individual pieces of machine code on a real device would be a good approach to countering these methods of detecting an emulator. <br><br><h3>  3. Forwarding data from the sensors of the equipment of real devices in the emulator </h3><br>  As described in [ <a href="https://habr.com/ru/company/pt/blog/332904/">34</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">61</a> ], there are ways to determine an emulator based on data obtained from equipment sensors, such as an accelerometer, gyroscope, GPS, light sensor, and gravity.  The output values ‚Äã‚Äãof these sensors are based on information gathered from the environment, and therefore, realistic emulation is a complex task.  The presence of such sensors is the main difference between smartphones and desktop computers.  The increasing number of sensors on smartphones provides new opportunities for identifying mobile devices. <br><br><h3>  4. Joint analysis at the level of Java-code and machine code </h3><br>  The difficulty for many systems for analyzing Android applications is that applications contain both modules in Dalvik bytecode and modules in machine codes.  Of the existing solutions, support for analyzing all modules is implemented only in DroidScope <a href="https://habr.com/ru/company/pt/blog/332904/">[57]</a> and CopperDroid [ <a href="https://habr.com/ru/company/pt/blog/332904/">58</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">59</a> ].  An ideal analysis system should be able to track data flows and controls at the level of user and system code.  For custom code, when possible, raise the presentation layer to Java code, which is a high-level development language.  It is also necessary to ensure the ‚Äúgluing together‚Äù of data flows and control when moving from machine code to Java and vice versa. <br><br><h3>  5. Support inter-component analysis </h3><br>  The article on CopperDroid [58] shows the implementation of support for the analysis of inter-component interactions both within the Android application and between different applications.  This is done by intercepting data passing through a component of the binder kernel, since all interaction passes through it.  The approach implemented in CopperDroid makes it possible not to modify the Android source code, which makes it possible to transfer it to new versions of the Android OS and the new ART launch environment with minimal changes. <br><br><h3>  6. Protection against static detection heuristics </h3><br>  As shown in [ <a href="https://habr.com/ru/company/pt/blog/332904/">[57]</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">61</a> ], most sandboxes for analysis can be detected by simply checking the IMEI, IMSI, or firmware build numbers of the device.  Also, the emulator can be detected by checking the routing table for standard values.  From existing solutions, protection against detection by static heuristics is implemented only in the ApkAnalyzer project <a href="https://habr.com/ru/company/pt/blog/332904/">[65]</a> . <br><br><h3>  7. Minimal changes to Android firmware </h3><br>  It is also worth noting that many dynamic analysis solutions are based on the instrumentation of the code of various components of the Android OS, in particular the Dalvik virtual machine.  This complicates their continued support, as well as the migration to the new launch environment for ART applications.  Many sandboxes are limited to analyzing the code of Java components, while more and more applications use components in machine code. <br><br><h3>  8. Support for full-system analysis of tagged data with control flow tracking. </h3><br>  It is worth noting that many of the dynamic analysis tools use the analysis of tagged data using the TaintDroid tool <a href="https://habr.com/ru/company/pt/blog/332904/">[56]</a> .  Successful ways to circumvent the analysis of this tool were shown in paper <a href="https://habr.com/ru/company/pt/blog/332904/">[60]</a> .  The following facts are the reason for the success of these attacks: 1) TaintDroid only tracks data flows and does not track control flows, 2) TaintDroid only tracks data flows at the Dalvik virtual machine level and passing through the JNI interface.  Possible ways of resolving these deficiencies are described in <a href="https://habr.com/ru/company/pt/blog/332904/">[60]</a> and provide guidance for further research. <br><br><h3>  9. Support for character execution and partial execution with specific values ‚Äã‚Äãusing data obtained from static code analysis (concolic execution - mixed execution) </h3><br>  The article <a href="https://habr.com/ru/company/pt/blog/332904/">[51]</a> describes the analysis environment that implements this approach.  This environment combines the techniques of static analysis of the control flow graph of a program, symbolic execution of a program, and execution of a program with specific values.  Approaches combining techniques of symbolic execution and execution of a program with specific meanings are described in [ <a href="https://habr.com/ru/company/pt/blog/332904/">52</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">53</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">54</a> , <a href="https://habr.com/ru/company/pt/blog/332904/">55</a> ].  The purpose of this method is to observe the execution paths that lead to program sections containing the ‚Äúinteresting‚Äù code.  ‚ÄúInteresting‚Äù code is understood as such code, the execution of which depends on any external events that have occurred or on the settings of the system environment.  For example, code classes in Android, dynamically loaded using the DexClassLoader component or calling "machine" methods through the JNI interface. <br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The security problems of the Android mobile OS exist at all levels of the platform and require a more comprehensive approach than the protection measures that can be observed now. In developing the classification of vulnerabilities presented in this article, it was noted that one of the main problems is significant market fragmentation, which does not allow for the timely delivery of security updates to all devices, as implemented in iOS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, the existing means of protection, including antivirus and sandboxes, have many drawbacks and cannot fully protect the user. Although you can create a sandbox for a full-system analysis of the Android OS without the described disadvantages if you are guided by the list of requirements presented in this article.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite this pessimistic picture, there have recently been a number of positive movements towards improving the security of Android. In particular, Google has launched a security update release program: they come out every month and some vendors still add them to their firmware versions (devices supported by Google get these updates first). In addition, users can independently install on their devices a version of the Android OS CyanogenMod (now LineageOS), which supports these security updates. Also, the user can reduce the risks, if limited to a set of popular applications only from the official Google Play store. Vulnerabilities like RCE (remote code execution) are becoming increasingly rare, so malicious applications are delivered to phones via phishing sites more often.unofficial app stores or using social engineering. The average user of the Android OS, following certain safety practices, can be calm for your smartphone.</font></font><br><br><blockquote><h3> <b></b> :   (@ <a href="https://habrahabr.ru/users/melon/">melon</a> ) </h3></blockquote><br><h3>    : </h3><br><ol><li><a name="1"></a> <a href="http://statista.com/statistics/281106/number-of-android-app-downloads-from-google-play">statista.com/statistics/281106/number-of-android-app-downloads-from-google-play</a> </li><li><a name="2"></a> Tan DJJ et al. Securing Android: A Survey, Taxonomy, and Challenges // ACM Computing Surveys (CSUR). 2015. Vol. 47. ‚Ññ 4. P. 58. </li><li><a name="3"></a> <a href="http://file.gdatasoftware.com/web/en/documents/whitepaper/G_DATA_Mobile_Malware_Report_H1_2016_EN.pdf">file.gdatasoftware.com/web/en/documents/whitepaper/G_DATA_Mobile_Malware_Report_H1_2016_EN.pdf</a> </li><li><a name="4"></a> <a href="http://developer.android.com/ndk/guides/stable_apis.html">developer.android.com/ndk/guides/stable_apis.html</a> </li><li><a name="5"></a> Dalvik VM Internals // <a href="http://sites.google.com/site/io/dalvik-vm-internals">sites.google.com/site/io/dalvik-vm-internals</a> </li><li><a name="6"></a> <a href="http://securityweek.com/overwhelming-majority-android-devices-dont-have-latest-security-patches">securityweek.com/overwhelming-majority-android-devices-dont-have-latest-security-patches</a> </li><li><a name="7"></a> Google I/O 2014 ‚Äî The ART runtime // <a href="http://youtube.com/watch%3Fv%3DEBlTzQsUoOw">youtube.com/watch?v=EBlTzQsUoOw</a> </li><li><a name="8"></a> <a href="http://media.defcon.org/DEF%2520CON%252024/DEF%2520CON%252024%2520presentations/DEFCON-24-Huber-Rasthofer-Smartphone-Antivirus-And-Security-Applications-Under-Fire.pdf">media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEFCON-24-Huber-Rasthofer-Smartphone-Antivirus-And-Security-Applications-Under-Fire.pdf</a> </li><li><a name="9"></a> <a href="http://developer.android.com/guide/components/services.html">developer.android.com/guide/components/services.html</a> </li><li><a name="10"></a> <a href="http://source.android.com/devices/tech/security/selinux">source.android.com/devices/tech/security/selinux</a> </li><li><a name="11"></a> <a href="http://developer.android.com/preview/features/runtime-permissions.html">developer.android.com/preview/features/runtime-permissions.html</a> </li><li><a name="12"></a> Enck W., Ongtang M., McDaniel P. Understanding android security // IEEE security &amp; privacy. 2009. ‚Ññ 1. P. 50‚Äî57. </li><li><a name="13"></a> Shabtai A., Mimran D., Elovici Y. Evaluation of Security Solutions for Android Systems // arXiv preprint arXiv:1502.04870. ‚Äî 2015. </li><li><a name="14"></a> Hei X., Du X., Lin S. Two vulnerabilities in Android OS kernel // Communications (ICC), 2013 IEEE International Conference on. IEEE, 2013. P. 6123‚Äî6127. </li><li><a name="15"></a> <a href="http://forum.xda-developers.com/showthread.php%3Ft%3D2048511">forum.xda-developers.com/showthread.php?t=2048511</a> </li><li><a name="16"></a> Zhou X. et al. Identity, location, disease and more: Inferring your secrets from android public resources // Proceedings of the 2013 ACM SIGSAC conference on Computer &amp; communications security. ACM, 2013. P. 1017‚Äî1028. </li><li><a name="17"></a> Wu L. et al. The impact of vendor customizations on android security // Proceedings of the 2013 ACM SIGSAC conference on Computer &amp; communications security. ACM, 2013. P. 623‚Äî634. </li><li><a name="18"></a> <a href="http://en.wikipedia.org/wiki/Stagefright_(bug)">en.wikipedia.org/wiki/Stagefright_(bug)</a> </li><li><a name="19"></a> Zhou X. et al. The peril of fragmentation: Security hazards in android device driver customizations // Security and Privacy (SP), 2014 IEEE Symposium on. IEEE, 2014. P. 409‚Äî423. </li><li><a name="20"></a> Sun M., Tan G. NativeGuard: Protecting android applications from third-party native libraries // Proceedings of the 2014 ACM conference on Security and privacy in wireless &amp; mobile networks. ACM, 2014. P. 165‚Äî176. </li><li><a name="21"></a> Octeau D. et al. Effective inter-component communication mapping in android with epicc: An essential step towards holistic security analysis // USENIX Security 2013. </li><li><a name="22"></a> Chin E. et al. Analyzing inter-application communication in Android // Proceedings of the 9th international conference on Mobile systems, applications, and services. ACM, 2011. </li><li><a name="23"></a> Felt AP et al. Permission Re-Delegation: Attacks and Defenses // USENIX Security Symposium. 2011. </li><li><a name="24"></a> Bugiel S. et al. Xmandroid: A new android evolution to mitigate privilege escalation attacks // Technische Universit√§t Darmstadt, Technical Report TR-2011-04. </li><li><a name="25"></a> Bugiel S. et al. Towards Taming Privilege-Escalation Attacks on Android // NDSS. 2012. </li><li><a name="26"></a> <a href="http://cvedetails.com/cve/CVE-2011-1717">cvedetails.com/cve/CVE-2011-1717</a> </li><li><a name="27"></a> Fahl S. et al. Why Eve and Mallory love Android: An analysis of Android SSL (in) security // Proceedings of the 2012 ACM conference on Computer and communications security. ACM, 2012. P. 50‚Äî61. </li><li><a name="28"></a> <a href="http://owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks">owasp.org/index.php/Projects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks</a> </li><li><a name="29"></a> Lu L. et al. Chex: statically vetting android apps for component hijacking vulnerabilities //Proceedings of the 2012 ACM conference on Computer and communications security. ACM, 2012. P. 229‚Äî240. </li><li><a name="30"></a> <a href="http://kb.cert.org/vuls/id/924951">kb.cert.org/vuls/id/924951</a> </li><li><a name="31"></a> CVE-2015-3842 // <a href="http://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2015-3842">cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-3842</a> </li><li><a name="32"></a> Zhou Y. et al. Hey, You, Get Off of My Market: Detecting Malicious Apps in Official and Alternative Android Markets // NDSS. 2012. </li><li><a name="33"></a> Nolan G. Decompiling android. ‚Äì Apress, 2012. </li><li><a name="34"></a> Petsas T. et al. Rage against the virtual machine: hindering dynamic analysis of android malware // Proceedings of the Seventh European Workshop on System Security. ACM, 2014. P. 5. </li><li><a name="35"></a> Android Security Underpinnings // <a href="http://youtube.com/watch%3Fv%3DNS46492qyJ8">youtube.com/watch?v=NS46492qyJ8</a> </li><li><a name="36"></a> <a href="http://coresecurity.com/advisories/android-wifi-direct-denial-service">coresecurity.com/advisories/android-wifi-direct-denial-service</a> </li><li><a name="37"></a> <a href="http://securityaffairs.co/wordpress/37667/hacking/nfc-attack-credit-card.html">securityaffairs.co/wordpress/37667/hacking/nfc-attack-credit-card.html</a> </li><li><a name="38"></a> <a href="http://zerodayinitiative.com/advisories/ZDI-15-092/">zerodayinitiative.com/advisories/ZDI-15-092/</a> </li><li><a name="39"></a> <a href="http://securityfocus.com/archive/1/535980/30/150/threaded">securityfocus.com/archive/1/535980/30/150/threaded</a> </li><li><a name="40"></a> Neuner S. et al. Enter sandbox: Android sandbox comparison // arXiv preprint arXiv:1410.7749. 2014. </li><li><a name="41"></a> Hoffmann J. From Mobile to Security: Towards Secure Smartphones: . ‚Äì 2014. </li><li><a name="42"></a> Faruki P. et al. Android Security: A Survey of Issues, Malware Penetration and Defenses. </li><li><a name="43"></a> <a href="http://ibotpeaches.github.io/Apktool">ibotpeaches.github.io/Apktool</a> </li><li><a name="44"></a> <a href="http://github.com/JesusFreke/smali">github.com/JesusFreke/smali</a> </li><li><a name="45"></a> <a href="http://dedexer.sourceforge.net/">dedexer.sourceforge.net</a> </li><li><a name="46"></a> <a href="http://radare.org/r">radare.org/r</a> </li><li><a name="47"></a> <a href="http://github.com/androguard/androguard">github.com/androguard/androguard</a> </li><li><a name="48"></a> <a href="http://dexprotector.com/">dexprotector.com</a> </li><li><a name="49"></a> <a href="http://guardsquare.com/dexguard">guardsquare.com/dexguard</a> </li><li><a name="50"></a> PANDORA applies non-deterministic obfuscation randomly to Android, Schulz P. Code protection in android // Insititute of Computer Science, Rheinische Friedrich-Wilhelms-Universit√§t Bonn, Germany. 2012. </li><li><a name="51"></a> Sch√ºtte J., Fedler R., Titze D. Condroid: Targeted dynamic analysis of android applications // in review. 2014. </li><li><a name="52"></a> Sen K. DART: Directed Automated Random Testing // Haifa Verification Conference. 2009. Vol. 6405. P. 4. </li><li><a name="53"></a> Sen K., Marinov D., Agha G. CUTE: a concolic unit testing engine for C. ACM, 2005. Vol. 30. ‚Ññ 5. P. 263‚Äî272. </li><li><a name="54"></a> Godefroid P. Random testing for security: blackbox vs. whitebox fuzzing // Proceedings of the 2nd international workshop on Random testing: co-located with the 22nd IEEE/ACM International Conference on Automated Software Engineering (ASE 2007). ACM, 2007. P. 1. </li><li><a name="55"></a> Jayaraman K. et al. jFuzz: A Concolic Whitebox Fuzzer for Java // NASA Formal Methods. 2009. P. 121‚Äî125. </li><li><a name="56"></a> Enck W. et al. TaintDroid: an information-flow tracking system for realtime privacy monitoring in smartphones // ACM Transactions on Computer Systems (TOCS). 2014. Vol. 32. ‚Ññ 2. P. 5. </li><li><a name="57"></a> Yan LK, Yin H. DroidScope: Seamlessly Reconstructing the OS and Dalvik Semantic Views for Dynamic Android Malware Analysis // USENIX Security Symposium. 2012. P. 569‚Äî584. </li><li><a name="58"></a> Tam K. et al. CopperDroid: Automatic Reconstruction of Android Malware Behaviors // Proc. of the Symposium on Network and Distributed System Security (NDSS). 2015. </li><li><a name="59"></a> <a href="http://copperdroid.isg.rhul.ac.uk/copperdroid">copperdroid.isg.rhul.ac.uk/copperdroid</a> </li><li><a name="60"></a> Sarwar G. et al. On the Effectiveness of Dynamic Taint Analysis for Protecting against Private Information Leaks on Android-based Devices // SECRYPT. 2013. P. 461‚Äî468. </li><li><a name="61"></a> Jing Y. et al. Morpheus: automatically generating heuristics to detect Android emulators // Proceedings of the 30th Annual Computer Security Applications Conference. ACM, 2014. P. 216‚Äî225. </li><li><a name="62"></a> <a href="http://googleprojectzero.blogspot.ru/2016/12/bitunmap-attacking-android-ashmem.html">googleprojectzero.blogspot.ru/2016/12/bitunmap-attacking-android-ashmem.html</a> </li><li><a name="63"></a> <a href="http://bbqand0days.com/Pork-Explosion-Unleashed">bbqand0days.com/Pork-Explosion-Unleashed</a> </li><li><a name="64"></a> <a href="http://powerofcommunity.net/poc2016/x82.pdf">powerofcommunity.net/poc2016/x82.pdf</a> </li><li><a name="65"></a> <a href="http://apk-analyzer.net/">apk-analyzer.net</a> </li><li><a name="66"></a> <a href="http://www.phdays.ru/program/fast-track/45984">www.phdays.ru/program/fast-track/45984</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/332904/">https://habr.com/ru/post/332904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332892/index.html">Vivaldi Sync: Answers to Questions</a></li>
<li><a href="../332896/index.html">Privileged ports cause global warming</a></li>
<li><a href="../332898/index.html">Why changes in the new Phoenix 1.3 are so important</a></li>
<li><a href="../332900/index.html">ES8 came out and here are its main new features.</a></li>
<li><a href="../332902/index.html">Pentest-laboratory "Pentestit Test lab v.11" - full passage</a></li>
<li><a href="../332906/index.html">What's new in CUBA Platform 6.5</a></li>
<li><a href="../332908/index.html">A little about the bugs in the BIOS / UEFI of Lenovo / Fujitsu / Toshiba / HP / Dell laptops</a></li>
<li><a href="../332910/index.html">Fly UNIGINE airplanes: a new aircraft simulator for MAKS-2017</a></li>
<li><a href="../332912/index.html">27000 errors in the Tizen operating system</a></li>
<li><a href="../332914/index.html">20 materials about the methods of successful traffic to the site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>