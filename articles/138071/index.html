<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of a WEB project on Node.JS: Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A week passed from the moment of PR on the project ‚Äú What to do? ". I remind you that this project began as an experiment on the development of an ave...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of a WEB project on Node.JS: Part 1</h1><div class="post__text post__text-html js-mediator-article">  A week passed from the moment of <a href="http://habrahabr.ru/blogs/i_am_advertising/137637/">PR</a> on the project ‚Äú <a href="http://chtodelat.com/">What to do?</a>  ".  I remind you that this project began as an experiment on the development of an average WEB-project entirely in JavaScript (Node.JS).  Now I want to share with the community the results of this experiment, obtained useful experience, as well as a detailed map with a rake marked on it. <br><br><h4>  Episode 1: The Beginning of the Road </h4><br><a name="habracut"></a>  I set myself the following goals: <br><ul><li>  Understand how convenient it is to develop conventional WEB-projects on Node.JS; </li><li>  Compare the speed of development on Node.JS with other technologies used (in my case it was PHP and Java); </li><li>  To get to the pitfalls that you do not come across on numerous synthetic examples; </li><li>  Assess the work of the finished project: stability, resistance to stress, the complexity of the support and development of such a project. </li></ul>  This project was my first experience in developing a full-fledged site on Node.JS, before that I used it only to write supporting services for working projects.  I started with an introduction to the WEB frameworks for this platform.  At that time there were several of them and there was a choice.  At this stage, you need to understand that if you write in JavaScript in the same way as in PHP, or as in Java, or in any other language, this will not lead to anything good.  You need to write in JavaScript as in JavaScript, otherwise why do we need it at all (thanks, Cap)?  Therefore, we immediately pass by clouds of frameworks offering various implementations of classical inheritance, synchronous programming, etc.  crutches, not peculiar to the language.  I was looking for a "true" -JavaScript path and wanted to evaluate it, and not the PHP port in JavaScript. <br><br>  Of all the frameworks, the choice fell on <a href="http://expressjs.com/">Express</a> .  It seemed to me the least overloaded with excesses and at the same time it most fully corresponded to my requirements and could be easily supplemented with third-party modules. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      From the framework, I wanted the following: <br><ul><li>  MVC architecture; </li><li>  Routing; </li><li>  Work with the DBMS; </li><li>  Template engine; </li><li>  Multi-language support; </li><li>  Multithreading support; </li><li>  Minimal overhead projector. </li></ul>  Also, it should have been easy to understand and be a handy tool, and not another technology that requires additional study. <br><br><h4>  Episode 2: The Way of the Samurai </h4><br>  Having played a bit with Express on a test case, having understood its architecture and studied the source code, I decided to make my own framework that would satisfy all my needs and would not be overloaded with functionality for me.  Bike - say you.  Experience - I will say.  One of the best ways to understand a system is to develop its analogue yourself.  The framework was developed, debugged, and the first version of the site was based on it.  The site was launched, and I began to monitor its work, simultaneously correcting pop-up errors and adding new features. <br><br><h4>  Episode 3: The Great Flood </h4><br>  Naturally, the first time on the site there were very few visitors to at least somehow objectively evaluate his work.  However, after a few days, I discovered that the site was lying.  He fell silently, there was nothing suspicious in the logs, but the fall was accompanied by a series of http requests quickly following each other - it was someone's robot.  These requests could not be called a load, many robots scan sites with such speed, and it should not fall because of this.  I picked up the site and tested it using the siege utility.  And really - the site went even on a very small number of parallel requests, which completely did not meet my expectations.  Logs were silent.  The sadness grew.  The excavation began. <br><br><h4>  Episode 4: The First Stone </h4><br>  Repeating the experiment, I watched what was going on with the server and discovered a problem - the node process was surviving all the available memory and was either cut down or hung up (stopped accepting http requests).  I‚Äôll make a reservation that during development I tried to keep track of memory consumption, since  This is one of the most dangerous moments in long-running applications.  I did not make extra closures, I did not lose var, in general I behaved carefully.  Once again, I reviewed my code, I was convinced that the error was not in it and, frankly speaking, I was upset because  there it would be easiest to fix it.  <a href="https://github.com/dannycoates/node-inspector">The debugger for Node.JS exists</a> , it is quite convenient, but debugging Node.JS application is more difficult due to its asynchronous operation.  I repent, I did not reach the 80th level in working with this wonderful tool and could not calculate the leakage.  So ended my vacation.  The time for learning the power of Node.JS has become much less, and I decided to postpone this matter until better times.  Not satisfied with the result, I wrote a small utility that restarted the process every day.  On such crutches the site worked for 4-5 months.  Meanwhile, the development of Node.JS did not stand still.  New versions came out one after another, and third-party modules also developed, getting rid of childhood diseases. <br><br><h4>  Episode 5: New Hope </h4><br>  And so, after a rather long break, in the <a href="https://raw.github.com/joyent/node/v0.6.10/ChangeLog">change log of Node.JS</a> there appeared records about fixed memory leaks (versions 0.6.6 - 0.6.7).  Also, starting with version 0.6.0, <a href="http://nodejs.org/docs/latest/api/cluster.html">cluster api</a> hit the stable release, which allowed to get rid of unnecessary dancing to run several node processes.  All this added enthusiasm and forced to look at the project from a new angle.  By this time I have already seen which parts of my framework are not used, what is missing in it, which is not convenient.  Plus, I decided to replace MySQL (it was originally used) with MongoDB. <br><br>  Once again, after analyzing the popular frameworks, I realized that all of them, by and large, are assemblies of various modules and minor improvements ‚Äúfrom myself‚Äù, and also dictate their own rules for building an application.  All this drives in a rigid framework at a doubtful prize.  If you need to update a separate module, and the framework conflicts with it, you will have to wait for the updated version to be added to it by the developers.  Or if you want to use a module that this framework does not support, for example, your favorite template engine.  What to do?  Fork and add support, and then manually update the update while waiting for the framework developers to accept your pull request?  Not! <br><br>  The modular system Node.JS completely allows not to use frameworks (read - ready-made assemblies of modules), but to work with modules directly.  In this additional functionality, instead of wrapping in the framework, you need to make a separate module.  This approach greatly increases the flexibility of the system and improves code reuse. <br><br>  So I had a project refactoring plan.  It consisted of the following points: <br><ul><li>  Abandon the use of the framework, go to the direct use of modules; </li><li>  Choose from a huge number of modules the most suitable for solving my problem; </li><li>  Replace MySQL with MongoDB; </li><li>  To organize the launch of several node processes, use the now native <a href="http://nodejs.org/docs/latest/api/cluster.html">cluster api</a> . </li></ul>  A few more weekends, and the plan was implemented.  Everything went quite smoothly, the amount of code decreased, the structure of the application became more understandable.  Everything has been tested and ready to run.  Then I published a PR article on Habr√© and waited. <br><br><h4>  Episode 6: Epic Wines </h4><br>  Not to say that "habraeffekt" was huge.  Just a couple of thousand people came.  After a couple of hours the site fell, but not because of the load, but because of my mistake.  Yes, in one hard-to-reach place, I made a typo in the variable name, which was the reason for the fall.  Otherwise, no problems.  The pages were given very quickly, the processor did not strain, the memory did not flow.  For a week now I have not restarted the node, and the site continues to work stably.  This result, after the previous sad experience, is very good. <br><br><h4>  findings </h4><br>  You cannot write to JavaScript just for JavaScript.  Choosing a language for the reason that it is cool / new / popular (underline the necessary) is stupid.  We need to clearly understand what we want from the technology and what it can give us, and also what it will ask in return.  My main task was to identify all these ‚Äúwhat‚Äù and get an answer to the question: ‚ÄúIs Node.JS suitable for developing average WEB projects‚Äù.  My answer is yes, it does.  But, as in any other technology, there are difficulties that will have to face.  I begin, perhaps, with the minuses, to finish on a positive note. <br><br><h5>  Houston, we have problems </h5><br><h6>  -one </h6><br>  The first thing you will encounter when developing on Node.JS is the lack of a full-fledged IDE that works out of the box.  Of course, there are plugins for Eclipse and NetBeans, there is partial support in other IDEs.  But it‚Äôs impossible to call them full-fledged solutions at the moment.  There is a very promising development of <a href="https://github.com/ajaxorg/cloud9">Cloud9 IDE</a> .  It is an IDE for JavaScript development right in the browser.  This IDE is developing rapidly and is already actively used by many Node.JS developers, but at the same time, in my subjective opinion, it is not yet ready to work on large projects, although it is very convenient to use it for writing small modules.  During the work on the project, I changed more than one IDE.  I started with notepad ++, used Cloud9 IDE for a long time, tried others, I don‚Äôt remember their names, but eventually returned to NetBeans.  Although there is no support for the Node.JS API, it is quite convenient to work with pure JavaScript there.  It remains to wait and hopes for the emergence of full support.  The development of <a href="http://timboudreau.com/blog/read/NetBeans_Tools_for_Node_js">such a plugin is</a> already underway. <br><br><h6>  -2 </h6><br>  The second unpleasant moment will be the need to restart the application after making each change.  Despite the existence of utilities that automate this process, it still takes some time.  Just as quickly as in PHP, make a change and immediately see the result will not work.  However, the application restarts fairly quickly - from one to several seconds, depending on the modules used.  In this Node.JS, undoubtedly, wins over Java - there restarting a serious WEB application takes much longer. <br><br><h6>  -3 </h6><br>  The next problem that node.JS beginners will encounter is most likely a memory leak.  Memory should be monitored always and everywhere, but fast-living PHP scripts or small client JavaScript are very relaxing.  In such applications, many developers do not particularly betray the value of losing a few kilobytes of memory, and some do not follow this indicator at all.  Node.JS does not make such concessions.  The application on Node.JS works for a long time, and in the event of a leak, each request to the site will take with it a piece of memory that will end very quickly, leading to known consequences.  The specificity of JavaScript also contributes to the appearance of this type of error.  One extra closure in a large field of view or one lost var can give you unforgettable debug hours.  But there is a plus in this - this experience will force any developer to appreciate memory and control its use when programming in other languages.  Personally, I do not consider this feature a minus. <br><br><h6>  -four </h6><br>  Another feature that causes inconvenience is the return of errors from the asynchronous code.  For comparison, in PHP all the code is executed synchronously, so you can catch the error at any nesting level using the try-catch construct.  We can wrap the controller's work into it and, in the event of an exceptional situation, make a throw, and the error ‚Äúpops up‚Äù to the waiting handler, which will show the user a beautiful page of shame.  Despite the fact that JavaScript also has a try-catch construct, it will not help us, because  Most of the code works asynchronously (I / O operations).  At the same time, exceptional situations, as a rule, arise not when a method is called, but when its callback, which is executed already outside the try-catch structure, works.  To transmit information about errors in Node.JS, it is customary to use the first parameter of the callback function.  Those.  if we have an error, we call the callback function either with one single parameter describing it, or we set the first parameter to undefined / null, and in the following we pass the results of our functionality.  In real applications, call nesting can be quite large and it is very inconvenient to send an error to the top each time.  I believe that the problem can still be solved by applying the <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2581%25D0%25BF%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">AOP</a> , but this topic is beyond the scope of this article. <br><br><h6>  -five </h6><br>  They also make nervous the simplest mistakes that quite often get to the production server.  A typo in the name of a variable in a very rarely executed block of code can lead to stopping the entire site or one of the processes if cluser api is used.  To avoid such troubles, you can use utilities that monitor the operation of the application and restart it if necessary, but real ninjas just test their code well (although no one is immune from an error in a third-party module). <br><br><h6>  -6 </h6><br>  The last thing I would like to add is complex mathematical calculations not for Node.JS.  On this topic on the hub, <a href="http://habrahabr.ru/blogs/nodejs/129640/">there was already a</a> very flame topic and there‚Äôs no point in repeating everything that is written in it and I don‚Äôt see comments to it.  I can only say that the author of the topic (of course, I mean the author of the original, not the translation) has problems with the choice of technology, or he is just a Troll.  In Node.JS, it is still possible to perform complex mathematical calculations, by splitting the problem into short iterations, performed in several turns of the event loop, but this is already a perversion and fanaticism.  It is much easier to move such tasks outside the event loop or even choose another technology for development. <br><br><h5>  And for what all this? </h5><br>  If by this time you do not have such a question, then you are either an experienced JavaScript developer, or a search robot, or Chuck Norris (hello, Chuck!).  For everyone else, I will try to describe the benefits that the development of a WEB project on Node.JS gives us. <br><br><h6>  +1 </h6><br>  I consider the most significant advantage of Node.JS is asynchronous I / O and transparency of working with it.  In most web projects, the most frequent operations are reading data from the database and saving it.  These operations are usually the slowest.  But they are not always dependent on each other, on the contrary, in most cases they are atomic.  For example, when adding a new comment to an article, we need: <br><ul><li>  Save the comment itself; </li><li>  Update user (for example, the number of comments from the user and the date of his last comment); </li><li>  Update article (similar to updating user); </li><li>  Log the result of the query. </li></ul><br>  All these operations are independent of each other and the DBMS is able to perform them simultaneously.  When performing synchronously, for example in PHP, these operations will be performed one after the other sequentially, each time waiting for the completion of the previous one.  In Node.JS we have the opportunity to send all 4 of these requests to the DBMS ‚Äúin parallel‚Äù.  In fact, requests are still sent sequentially (so I quoted the word "parallel" in quotes), because  Node.JS works in the same process.  But Node.JS does not wait for the result of the previous request to send the next one.  The time of sending the request, compared with the time of its work, while can be neglected.  When requests are executed, callback functions will be called to process their result.  These calls will occur as consistently as sending requests, and the result will be processed incomparably faster than their execution time.  Thus, the total time to work with the data will be approximately equal to the time of the longest query + a small overhead to send queries and process their results.  But in any case, it will be faster than the sum of the execution time of all queries during their sequential processing (the overhead to send queries and process their results in this case also does not go anywhere). <br><br><h6>  +2 </h6><br>  The second very pleasant possibility is that the answer to the client can (and should) be sent immediately, as it will be ready, without waiting for the completion of the work of the entire query logic.  Let's go back to the previous example.  When adding a comment, we write a log in the database.  We need this operation, but we don‚Äôt need the user to get an answer.  With Node.JS we can form and send the answer, and then finish what we need: write logs, clear the cache, etc.  The user timeout is reduced accordingly. <br><br><h6>  +3 </h6><br>  The third positive factor is that we have the same language on the server and on the client, this allows you to reuse some code (validation of forms, building patterns on the client, etc.).  And in general, it greatly simplifies the development, especially when the client part of the application is complex and requires serious work, and not the processing of a couple of events on the buttons. <br><br><h6>  +4 </h6><br>  The Node.JS process lives long and handles all http requests within itself.  This means that for each new request, initialization is not performed, as, for example, in PHP.  The settings are loaded, connections to the database and the cache are open, the code is compiled and ready to go.  Thanks to this architecture and the flexibility of JavaScript, there is a huge scope for various optimization techniques.  For example, once you have parsed a template, you can store it as a function that takes data as input and returns ready-made HTML.  Or you can easily organize local (for the process) caching of the most frequently used data, which will give an increase in the speed of working with them even compared to memcached.  Yes, there are solutions for PHP that allow to partially speed up the initialization process - APC for op-code, support for persistent connections in FastCGI, etc.  But when comparing the accelerated initialization process with its absence in principle - the gain will always be the last. <br><br><h6>  +5 </h6><br>  Around the Node.JS for its relatively short life a solid ecosystem has already formed, including hundreds of modules and, accordingly, their developers.  Largely due to the convenience of github, the community has an excellent tool for the development of this ecosystem, which is taking leaps and bounds, and anyone can make a contribution to this development.  Using tools such as <a href="http://toolbox.no.de/">The Node Toolbox</a> and <a href="http://npmjs.org/">npm</a> , the process of finding, selecting, and installing the necessary modules becomes simple and fast. <br><br><h6>  +6 </h6><br>  The JavaScript language itself and the Node.JS API are very flexible and concise.  Programs are compact and easy to read.  You are unlikely to see in them classes consisting almost entirely of getters and setters, or dozens of files with interface descriptions.  Such things as closures and lambda functions allow you to write very beautiful code, but with the special talent of a developer they can turn it into a branch of hell. <br>  I laughed for a long time, seeing the <a href="http://devnest.blogspot.com/2012/01/nodejs-vs-netty.html">performance comparison of Java and Node.JS.</a>  Here you can talk for a long time and give various arguments, but I will say simply how I think.  In the event loop, I spit such performance if the program code increases tenfold.  I have experience in developing a large WEB-project in Java + Spring Framework + Hibernate.  There are 10 lines of code, beautifully describe what the 11th will do.  Crude, of course, but it roughly reflects the situation.  Perhaps for some class of problems this is also relevant, but not for average WEB-projects.  It is worth adding that such a comparison on the ‚ÄúHello world‚Äù does not reflect the real state of affairs.  With the appearance of application logic, work with the database, caching and other components of the system, the probability of catching the brakes due to the non-optimal use of the technology is greatly increased than due to its imperfection.  In addition, we must remember that the server resources may be missing in two cases: <br><ul><li>  The code is written poorly; </li><li>  Your site has a huge attendance. </li></ul>  In the first case, only straightening the arms with the subsequent rewriting of the code and technology will do nothing to do with it.  In the second - you already have enough money to buy another server, because  it is economically more profitable than the support of tens of times more code. <br><br><h4>  Conclusion </h4><br>  Node.JS is not a magic wand.  This is a powerful tool with its pros and cons, which should be used only when you need it.  I am satisfied with the result of my experiment.  <a href="http://chtodelat.com/">The project</a> is fast, has a simple and clear code that is easy to develop and maintain.  Despite some shortcomings, Node.JS is convenient to use for the development of WEB-projects and I believe in its development in this direction. <br><br><h4>  To be continued </h4><br>  In the second part I will focus on the application architecture.  I'll tell you what modules I used and how the interaction between them is organized. <br><br>  Thanks to everyone who read it.  I will be glad to see your feedback and opinions in the comments. </div><p>Source: <a href="https://habr.com/ru/post/138071/">https://habr.com/ru/post/138071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138064/index.html">Vkontakte will be forced to actively deal with piracy</a></li>
<li><a href="../138065/index.html">24 Weeks Metro-Design for Windows Phone | # 2 Windows Phone Application Design Process</a></li>
<li><a href="../138067/index.html">Determining a country by IP: testing the speed of algorithms</a></li>
<li><a href="../138069/index.html">Droider Show # 27. Siri will speak Russian</a></li>
<li><a href="../138070/index.html">Optimization of workflow in CAD-systems</a></li>
<li><a href="../138072/index.html">Rostelecom on Habr√©</a></li>
<li><a href="../138073/index.html">We vote for the whole world with golosim.ru</a></li>
<li><a href="../138074/index.html">Google actually gave up the title of "corporation good"</a></li>
<li><a href="../138075/index.html">Re-check project Notepad ++</a></li>
<li><a href="../138076/index.html">Coloring matrix 17—Ö17 in four colors without monochromatic rectangles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>