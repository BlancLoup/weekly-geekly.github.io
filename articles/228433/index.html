<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Computing Graphs, Speculative Locks and Arenas for Tasks at Intel¬Æ Threading Building Blocks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is a translation of the article ‚ÄúFlow Graphs, Speculative Locks, and Task Arenas in Intel Threading Building Blocks‚Äù from Parallel Universe ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Computing Graphs, Speculative Locks and Arenas for Tasks at Intel¬Æ Threading Building Blocks</h1><div class="post__text post__text-html js-mediator-article">  This post is a translation of the article ‚ÄúFlow Graphs, Speculative Locks, and Task Arenas in Intel Threading Building Blocks‚Äù from Parallel Universe Magazine, Issue 18, 2014. If you are interested in the Intel TBB library in particular, and interesting modern concepts of parallel programming in general, welcome under cat. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  Intel Threading Building Blocks (Intel TBB) provides C ++ programmers with a solution for adding concurrency to their applications and libraries.  The well-known advantage of the Intel TBB library is that it makes the scalability and power of parallel execution of their applications easily accessible to developers if their algorithms are based on cycles or tasks.  A general overview of the library can be seen under the spoiler. <br><div class="spoiler">  <b class="spoiler_title">About the library</b> <div class="spoiler_text">  The library includes common parallel algorithms, a task scheduler and task balancer, thread-safe containers, a memory manager, synchronization primitives, and so on (Figure 1).  Using basic parallel programming patterns in conjunction with these building blocks, developers make parallel applications that abstract from the problems of implementing a multithreading mechanism on a particular platform, while obtaining performance that scales with an increase in the number of cores. <br><img src="https://habrastorage.org/getpro/habr/post_images/8e9/3fb/e54/8e93fbe5426cbdd0a40ae5491a54b76a.png"><br>  Figure 1: ‚ÄúBuilding Blocks‚Äù Intel Threading Building Blocks <br><br>  The book ‚ÄúStructured parallel programming‚Äù [1] describes a number of useful parallel patterns that fit well with Intel TBB algorithms: <br><ul><li>  <i>parallel_for</i> : map, stencil (multidimensional data table) </li><li>  <i>parallel_reduce, parallel_scan</i> : reduce (reduction), scan (calculation of partial reductions) </li><li>  <i>parallel_do</i> : workpile (multidimensional data table with an unknown number of elements at the beginning of execution) </li><li>  <i>parallel_pipeline</i> : pipeline </li><li>  <i>parallel_invoke, task_group</i> : fork-join patterns </li><li>  <i>flow_graph</i> : computation graph work patterns </li></ul><br>  Intel TBB can be used with any C ++ compiler.  It also supports the C ++ 11 standard, for example, lambda expressions, which simplifies writing and readability of the code, since there is no need to write utility functor classes.  The various components of the library can be used independently and even combined with other parallel programming technologies. <br>  Intel TBB 4.2 has introduced new features that include support for the latest architectural features, such as Intel Transactional Synchronization Extensions (Intel TSX) technology and support for the Intel Xeon Phi co-processor on Windows *.  There is also support for Windows Store * and Android * applications [2, 3].  In addition, the current components have been improved (see documentation).  Intel TBB 4.2 is available both separately and as part of products such as Intel INDE, Intel Cluster Studio XE, Intel Parallel Studio XE, Intel C ++ Studio XE, Intel Composer XE and Intel C ++ Composer XE. <br>  The open source library version supports more architectures, compilers, and operating systems, thanks to the contribution of our community.  The library can work with the Solaris * operating system and the Oracle * C ++ compiler for Intel Architecture compiler and the C ++ compiler for SPARC * -compatible architectures, IBM * Blue Gene * supercomputers, and PowerPC * -compatible architectures.  It also works with Android *, Windows Phone * 8 and Windows RT * for ARM * -compatible architectures, FreeBSD *, Robot * and many other platforms that support atomic operations built into the GCC * compiler.  This broad cross-platform means that an application once written using the Intel TBB library can be ported to many other operating systems or architectures without rewriting the basic algorithms. <br></div></div><br>  Next, we will focus on several specific parts of the library.  First, there will be an overview of the computational graph ( <i>flow graph</i> ), which is available starting with Intel TBB 4.0.  Then it will be told about two components of the library, which were first released in the Intel TBB 4.2 version.  These are speculative locks, which take advantage of Intel Transactional Synchronization Extensions (Intel TSX) technology and <i>user-managed task arenas</i> , which provide advanced control and management of the level of parallelism and task isolation. <br><br><h4>  Computational graphs </h4><br>  Although the Intel TBB library is well known for parallelizing loops, the computational graph interface [4] expands its capabilities for fast and efficient implementation of algorithms based on data and / or performance dependency graphs, helping developers use parallelism in their applications at a higher level. <br>  For example, consider a simple application that sequentially performs four functions, as shown in Fig.  2 (a).  The cycle parallelization approach implies that the developer can review each of these functions for parallelization using algorithms such as parallel_for and parallel_reduce.  Sometimes this may be enough, but in other cases this may not be enough.  For example, in Fig.  2 (b) shows that we managed to parallelize the functions B and D in cycles. The execution time in this case will be reduced, but what if the resulting increase in performance is still not enough? <br><img src="https://habrastorage.org/getpro/habr/post_images/6ab/288/414/6ab2884144585bd757d0c63480a6cd06.png"><br>  Fig.  2: A simple example of different forms of parallelism 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Sometimes excessive restrictions are imposed on the function call, such as: the order of the function call must be defined, strictly ordered, calls one after the other, even in the case of partial dependencies between functions, not complete.  In Fig.  2 (a) the functions are written by the developer in such a way that the function is executed only after all the input values ‚Äã‚Äãare obtained during the previous execution.  But what if the functions B and C depend on the data calculated in function A, and the function C does not depend on the data of function B?  Fig.  2 (c) shows the implementation of this example through a graph and loop parallelization.  In this implementation, parallelization at the loop level is used and the complete ordering is replaced by partial, which allows functions B and C to be executed simultaneously. <br>  The Intel TBB flow graph interface allows developers to easily express parallelism at the graph level.  It provides support for various types of graphs, which can be found in many areas, such as multimedia processing, games, financial and high-performance computing, and computing in healthcare.  This interface is fully supported in the library and is available starting with Intel TBB 4.0. <br>  When using Intel TBB flow graph, calculations are represented by nodes, and communication channels between these nodes are represented by edges.  The user uses edges to define dependencies that must be taken into account by nodes when queuing for execution, providing the Intel TBB Task Scheduler to implement parallelism at the graph topology level.  When a node in the graph receives a message, the task to execute the functor on this message is queued for execution by the Intel TBB scheduler. <br><br>  The flow graph interface supports several different types of nodes (Fig. 3): functional nodes (Functional nodes) that perform user functions, buffer nodes (Buffering nodes), which can be used to streamline and buffer messages as they should pass through the graph , aggregation and de-aggregation nodes (Aggregation / Deaggregation nodes), which connect or disconnect messages, as well as other useful nodes.  Users connect objects of these nodes with edges in order to indicate the dependencies between them, and provide objects that perform work in these nodes. <br><img src="https://habrastorage.org/getpro/habr/post_images/6a7/5e4/1cc/6a75e41cc87b5a3667ea0fa691c2fa21.png"><br>  Fig.  3: Types of nodes (nodes) supported by the flow graph interface <br><br>  Consider the source code for a simple flow graph of the ‚ÄúHello World‚Äù application.  This example is very simple and does not contain any parallelism, but demonstrates the syntax of this interface.  In this example, with the help of lambda expressions, two nodes are created: <i>hello</i> and <i>world</i> , which type ‚ÄúHello‚Äù and ‚ÄúWorld‚Äù, respectively.  Each <i>continue_node</i> node is a function node of the type provided by the interface.  The <i>make_edge</i> call creates an edge between the <i>hello</i> and <i>world</i> nodes.  Whenever a task started by the <i>hello</i> node is completed, it will send a message to the <i>world</i> node, causing it to start the task to perform its lambda expression. <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"tbb/flow_graph.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; using namespace tbb::flow; int main() { graph g; continue_node&lt; continue_msg&gt; hello( g, []( const continue_msg &amp;) { cout &lt;&lt; "Hello"; } ); continue_node&lt; continue_msg&gt; world( g, []( const continue_msg &amp;) { cout &lt;&lt; " World\n"; } ); make_edge(hello, world); hello.try_put(continue_msg()); g.wait_for_all(); return 0; }</span></span></span></span></code> </pre> <br>  In the above code, the call <i>hello.try_put (continue_msg ())</i> sends a message to the <i>hello</i> node, causing it to call a task to execute the body of the object.  When the task is completed, it sends a message to the <i>world</i> node.  Only when all the tasks started by the nodes have been completed will the return from the <i>g.wait_for_all ()</i> function be <i>performed.</i> <br>  The Intel TBB flow graph interface allows you to program very complex graphs, including thousands of nodes, edges, loops, and other elements.  Fig.  4 shows a visual representation of two graphs of the implementation of the Cholesky Expansion, which use an algorithm similar to the one that can be found in [5].  In Fig.  4 (a) Each call to the Intel Math Kernel Library (Intel MKL) <i>dpotf2m</i> , <i>dtrsm</i> , <i>dgemm</i> and <i>dsyrk functions</i> is a separate node in the graph.  In this case, the graph is huge, with many nodes on each block of the matrix, but it can be easily implemented by modifying the initial consecutive nested Lotsky Decomposition cycles by replacing function calls with node and edge creation.  In this graph, edges are used to indicate dependency relationships;  each node waits until all nodes on which it depends are executed.  It is easy to see how parallelization is implemented in this graph. <br><div class="spoiler">  <b class="spoiler_title">Fig.</b>  <b class="spoiler_title">4: Two parallel implementations of the Kholetsky Expansion based on flow graph interfaces</b> <div class="spoiler_text"><img src="//habrastorage.org/files/27e/03c/17d/27e03c17da4245228d06a82b10e206aa.png"><br>  Fig.  4 (a) Using a directed acyclic graph <br><img src="//habrastorage.org/files/e31/8fa/870/e318fa8700bd4465b7e6dbf1514986a7.png"><br>  Fig.  4 (b) Using a compact data dependency graph <br></div></div><br><br>  Fig.  4 (b) shows an alternative version, which can also be implemented using the <i>flow graph</i> interface.  In this small, more compact version of the graph, there is only one node, which is responsible for calling all the necessary functions of the Intel MKL library.  In this implementation, blocks are transmitted as messages between nodes in a graph.  When a node accepts a set of blocks of a particular type, it calls a task that processes these blocks, and then sends the newly generated block to other nodes.  Parallelization in such a graph will be implemented because of the ability of the library to simultaneously perform many instances of objects of each node of the graph. <br>  Although the implementation details discussed in Fig.  4, beyond the scope of this article, this example demonstrates that the Intel TBB flow graph interface is a powerful and flexible level of abstraction.  It can be used to create large directed acyclic graphs, such as in Figure 4 (a), where the developer creates a dedicated node for each call to the Intel MKL.  On the other hand, using the Intel TBB flow graph interface, you can create a compact data dependency graph, which includes loops and conditional execution, as shown in Fig.  4 (b). <br>  More information on flow graph interfaces can be found in the Intel TBB Reference Manual. <br><br>  In the next half of the article, we will look at speculative locks, which take advantage of Intel Transactional Synchronization Extensions (Intel TSX) technology and user-managed task arenas, which provide enhanced control and management of the level of parallelism and task isolation. . <br>  To be continued‚Ä¶ <br><div class="spoiler">  <b class="spoiler_title">Bibliography</b> <div class="spoiler_text">  [1] Michael McCool, Arch Robison, James Reinders ‚ÄúStructured Parallel Programming‚Äù <a href="http://parallelbook.com/">parallelbook.com</a> <br>  [2] Vladimir Polin, ‚ÄúAndroid * Tutorial: Writing a Multithreaded Application using Intel Threading Building Blocks‚Äù.  <a href="http://software.intel.com/en-us/android/articles/android-tutorial-writing-a-multithreaded-application-using-intel-threading-building-blocks">software.intel.com/en-us/android/articles/android-tutorial-writing-a-multithreaded-application-using-intel-threading-building-blocks</a> <br>  [3] Vladimir Polin, ‚ÄúWindows * 8 Tutorial: Writing a Multithreaded Application for the Windows Store * using Intel Threading Building Blocks‚Äù.  <a href="http://software.intel.com/en-us/blogs/2013/01/14/windows-8-tutorial-writing-a-multithreaded-application-for-the-windows-store-using">software.intel.com/en-us/blogs/2013/01/14/windows-8-tutorial-writing-a-multithreaded-application-for-the-windows-store-using</a> <br>  [4] Michael J. Voss, ‚ÄúThe Intel Threading Building Blocks Flow Graph‚Äù, <br>  Dr.  Dobb's, October 2011, <a href="http://www.drdobbs.com/tools/the-intel-threading-building-blocks-flow/231900177">www.drdobbs.com/tools/the-intel-threading-building-blocks-flow/231900177</a> . <br>  [5] Aparna Chandramowlishwaran, Kathleen Knobe, and Richard Vuduc, ‚ÄúPerformance <br>  Evaluation of Concurrent Collections on High-Performance Multicore Computing Systems ‚Äù, <br>  2010 Symposium on Parallel &amp; Distributed Processing (IPDPS), April 2010. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/228433/">https://habr.com/ru/post/228433/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228421/index.html">Dynamic magnetic stripe as the main element of an electronic card</a></li>
<li><a href="../228425/index.html">Overview cover for smartphone Pocketbook CoverReader</a></li>
<li><a href="../228427/index.html">Magic formula or how to see the threat</a></li>
<li><a href="../228429/index.html">Popularization of technical creativity in China</a></li>
<li><a href="../228431/index.html">How to build a spacecraft without leaving the office</a></li>
<li><a href="../228435/index.html">Spiral Ulam, the area of ‚Äã‚Äãthe prohibition of primes</a></li>
<li><a href="../228437/index.html">Promotional Wars: Search Engines vs. Internet Providers</a></li>
<li><a href="../228445/index.html">Explore and test queues from Hazelcast</a></li>
<li><a href="../228447/index.html">Visualization of transatlantic flights in 24 hours</a></li>
<li><a href="../228449/index.html">The smartphone can read the password from the screen from the reflection in your eyes, as well as fingerprints</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>