<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization of Viola and Jones method for Elbrus platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The method (algorithm) of Viola and Jones [1] is one of the ways to identify the boundaries of objects in an image. Although the algorithm developed b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization of Viola and Jones method for Elbrus platform</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/59/f0/52/59f052072c9b4528474030.png" align="right">  The method (algorithm) of Viola and Jones [1] is one of the ways to identify the boundaries of objects in an image.  Although the algorithm developed by P. Viola and M. Jones back in 2001, was originally focused on a quick search for faces in images, now various variations of this popular algorithm are successfully used in various problems of searching for boundaries: </p><br><ul><li>  images of pedestrians [2], </li><li>  car images [3], </li><li>  road signs images [4], </li></ul><br><p>  as well as other objects present in the images from approximately the same angle.  This kind of popularity of modifications of the method of Viola and Jones is explained by the high accuracy of the search for objects and high resistance to both geometric distortions and brightness changes. </p><a name="habracut"></a><br><h3 id="opisanie-metoda-violy-i-dzhonsa">  Description of the method of Viola and Jones </h3><br><p>  The Viola and Jones algorithm reduces the task of detecting objects in an image to the problem of binary classification at each point of the image.  The method was based on the "sliding window" technique.  For each rectangular region of an image taken with various shifts and scales, with the help of a previously trained classifier (detector) the hypothesis of the presence or absence of a search object in a given region should be tested.  A complete study of all regions leads to hundreds of thousands of classifier launches in a single image.  That is why the classifier has two stringent requirements: high performance and a small number of false positives. </p><br><p>  In this paper, Viola and Jones described a classifier for a human face.  The training sample consisted of 4,916 images of faces scaled to 24x24 pixels ( <em>positive sample</em> ) and 9,500 full-size images in which there were no faces and from which areas that did not contain faces ( <em>negative sample</em> ) were randomly extracted. </p><br><p>  To construct the feature space, Haar features were chosen, informative for characteristic brightness variations.  Haar signs are easily calculated using the integral representation of the image.  It turned out that for images with sizes of 24x24, the number of configurations of one feature is 45396. </p><br><p>  In the Viola and Jones method, the AdaBoost algorithm [5] was applied, which simultaneously allows the selection of the most informative features and the construction of a binary classifier.  For this, the authors associated with each attribute a weak classifier representing a single-level decision tree, which are then fed to the AdaBoost algorithm. </p><br><p>  A necessary part of the Viola and Jones method is the procedure of combining the constructed strong classifiers, which can significantly increase the productivity of the face detection process by localizing those regions of the image under study that could contain images of faces. </p><br><p>  As noted above, in the Viola and Jones algorithm, when teaching classifiers, the Haar family of attributes, dating back to the Haar wavelets, is used to describe objects [6].  This choice is primarily due to the fact that the signs of Haar allow us to adequately describe the characteristic features of the detected objects related to the brightness differences.  The signs of Haar allow us to see that the image of a person‚Äôs face is darker than the area of ‚Äã‚Äãthe nose (Fig. 1d).  In the described algorithm, three classes of features were involved: 2-rectangular signs (Figure 1a), 3-rectangular signs (Figure 1b) and 4-rectangular signs (Figure 1c). </p><br><p>  The value of each sign of the Haar was equal to the difference of the sums of pixels of image areas inside black and white rectangles of equal size.  2-rectangular and 3-rectangular signs of the Haar can be oriented vertically (see figure 1) or horizontally.  To quickly calculate the signs of Haar, an integral image representation is used [7]. </p><br><p>  In the AdaBoost algorithm, when learning the method of Viola and Jones, as weak classifiers, recognition trees with one branch and two leaves are used (called the <em>decision stump</em> and comparing the value of the corresponding attribute with the threshold value).  The formally weak classifier <em>b</em> <sub><em>j</em></sub> ( <em>x</em> ), based on the attribute <em>f</em> <sub>j</sub> , the threshold <em>Œ∏</em> <sub><em>j</em></sub> and the parity <em>p</em> <sub><em>j</em></sub> is defined as: </p><br><img src="https://habrastorage.org/webt/59/f0/53/59f0535940a7c053424413.png"><br><p>  Such a set of weak classifiers along with the training sample is fed to the input of the AdaBoost algorithm. </p><br><img src="https://habrastorage.org/webt/59/f0/53/59f053953b56b168221275.png"><br><p>  Figure 1 - Rectangular signs of Haar used in training <br>  classifier: a) 2-rectangular sign;  b) 3-rectangular feature; <br>  c) 4-rectangular feature;  d) example of the location of the sign <br>  regarding the scanning window (source [7]) </p><br><p>  The cascade classifier ( <em>cascade</em> ) is created under the assumption that for any examined image the number of "positive" areas that do not contain the search object exceeds by several orders the number of areas containing this object ("negative" areas).  To improve the performance of the object detector, it is useful to abandon the negative image areas as soon as possible.  Or the number of signs for the analysis of negative areas should be substantially less than the number of signs calculated for positive areas. </p><br><p>  Each image area that is analyzed for the presence of the search object is fed to the input of an ordered sequence of classifiers, called <em>cascade levels</em> .  As you progress through the sequence of classifiers, the computational complexity of the levels increases.  If the classifier fails to recognize a certain area (that is, the area is classified as negative), such area is no longer processed by the remaining classifiers. </p><br><p>  For the cascade classifier according to its definition, the following relationships are true: </p><br><img src="https://habrastorage.org/webt/59/f0/53/59f053ce82612296166225.png"><br><p>  where <em>FPR</em> is the fraction of false detection of the cascade, <em>TPR</em> is the fraction of correct detection of the cascade, <em>K</em> is the number of levels of the cascade, <em>fpr</em> <sub><em>i</em></sub> is the fraction of false detection of the <em>i</em> -th cascade level, <em>tpr</em> <sub><em>i</em></sub> is the fraction of correct detection of the -th cascade level. </p><br><p>  The estimated number of calculated signs that will be calculated for each study area is calculated by the formula: </p><br><img src="https://habrastorage.org/webt/59/f0/53/59f053f52774a544869282.png"><br><p>  where <em>n</em> <sub><em>i</em></sub> is the number of weak classifiers of the -th level, <em>pr</em> <sub><em>i</em></sub> is the share of the <em>i-</em> th level triggerings. </p><br><p>  The learning algorithm of the classifier should solve the optimization problem, trying to build a cascade with the best indicators of <em>FPR</em> and <em>TPR</em> , while minimizing the expected number of calculated signs of <em>N.</em>  Clearly, such a task is rather difficult to solve, primarily due to the lack of clear links between the <em>FPR</em> , <em>TPR</em> and <em>N</em> values. </p><br><p>  The simple idea of ‚Äã‚Äãlearning a cascade on an existing tagged training set, including positive and negative examples, is known.  You must select three parameters in advance: </p><br><ul><li>  the proportion of false positives for each level of the cascade, </li><li>  the proportion of correct operations for each level of the cascade, </li><li>  the proportion of false positives for the entire cascade as a whole ( <em>FPR</em> <sup>*</sup> ). </li></ul><br><p>  After that, the cascade classifier is constructed iteratively, and at each iteration, training is conducted using the AdaBoost algorithm.  Levels are added to the cascade until the target quality specified by the <em>FPR</em> <sup>*</sup> value is reached.  The training input for each level of the cascade should be fed to the input, in which negative examples are the false alarms of the cascade classifier that has already been trained at the moment. </p><br><p>  We described the described approach to the training of the object detector in the problem of detecting scanned images of a passport.  The training set consisted of two sets: </p><br><ul><li>  1302 positive samples (cut samples of the 2nd page of the passport of a citizen of the Russian Federation) and 2000 negative samples (full-size FullHD images containing anything except the passport of the Russian Federation) </li><li><p>  1103 positive samples (cut samples of the 3rd page of the passport of a citizen of the Russian Federation) and 2000 negative samples (full-size FullHD images containing anything except the passport of the Russian Federation) </p><br><p>  The physical size (in pixels) for both classifiers was selected 201x141.  With this size, it is still possible to understand that these are the top or bottom pages (that is, the class is determined uniquely), and the intraclass uniqueness disappears. </p><br><p>  As a result, two classifiers were trained. </p><br></li><li>  qualifier of the 2nd page of the passport of a citizen of the Russian Federation, consisting of 8 levels and 28 weak classifiers in total </li><li>  qualifier of the 3rd page of the passport of a citizen of the Russian Federation, consisting of 8 levels and 36 weak classifiers. </li></ul><br><p>  The test sample consisted of 300 photographs and passport scans (both pages were on the image at the same time).  The quality of the binding of the top page of the passport (second page) was 0.967.  The quality of the binding of the bottom page of the passport (third page) was 0.98. </p><br><h3 id="osobennosti-arhitektury-elbrus">  Features architecture Elbrus </h3><br><p>  Architecture Elbrus belongs to the category of architectures that use the principle of a wide command word (Very Long Instruction Word, VLIW).  On processors with a VLIW architecture, the compiler generates sequences of groups of commands (broad command words), in which there are no dependencies between the commands within each group and the dependencies between the commands in different groups are minimized.  Further, the commands within each group are executed in parallel, which ensures a high level of parallelism at the command level. </p><br><p>  Due to the fact that the parallelization at the command level is entirely provided by the optimizing compiler, the equipment for executing commands is greatly simplified, since now it does not solve parallelization problems, as is the case, for example, with the x86 architecture.  The power consumption of the VLIW processor is reduced: it no longer needs to analyze dependencies between operands or rearrange operations, since all these tasks are assigned to the compiler.  It should be noted that the compiler has much more computational and time resources than hardware source code analyzers, and therefore can perform the analysis more carefully and find more independent operations [8]. </p><br><p>  In addition, a feature of the architecture of Elbrus are the methods of working with memory.  Often, access to external memory can take considerable time and slow down calculations.  Caching is used to solve this problem, but it has its drawbacks, since the cache has a strictly limited size and typical caching algorithms are aimed at storing only frequently used data in the cache. </p><br><p>  Another way to improve the efficiency of access to memory is to use data preloading methods.  These methods allow you to predict memory access and download data to a cache or other special device some time before they are used.  They are divided into software and hardware.  In program methods, special pre-swap instructions are scheduled at compile time.  They are handled in the same way as normal memory accesses.  Hardware methods work during program execution and use dynamic information about memory access to predict.  They require the presence of additional modules in the microprocessor, but do not need special instructions for paging and can work asynchronously. </p><br><p> Elbrus processors support hardware and software swap method.  At the same time, a special device for accessing arrays (Array Access Unit, AAU) is included in the microprocessor hardware, but the need for swapping is determined by the compiler generating special instructions (initializing the AAU, starting and stopping the preliminary swapping program, asynchronous swapping instructions and synchronous data transfer instructions from the array swap buffer (Array Prefetch Buffer, APB) to the register file).  The use of a swap device is more efficient than putting an array of elements into a cache, since array elements are often processed sequentially and rarely used more than once [9].  However, it should be noted that the use of the preliminary swap buffer on Elbrus is possible only when working with aligned data.  Due to this, reading / writing of aligned data takes place noticeably faster than the corresponding operations for non-aligned data. </p><br><p>  Also, Elbrus microprocessors support several types of parallelism besides parallelism at the command level: vector parallelism, control flow parallelism, task parallelism in a multi-machine complex. </p><br><h3 id="sredstva-povysheniya-proizvoditelnosti-programmnogo-koda-na-platforme-elbrus">  Tools to improve the performance of software code on the platform Elbrus </h3><br><p>  To increase the speed of the developed algorithm on the Elbrus architecture processor is possible by using the high-performance library EML and intrinsics (eng. Intrinsics), implementing vector parallelism. </p><br><p>  The EML library is a high-performance library that provides the user with a set of various methods for processing signals, images, video, as well as mathematical functions and operations [10].  It is intended for use in programs written in C / C ++ languages.  The EML library includes several of the following function groups: </p><br><pre><code class="cpp hljs">- Vector ‚Äî      () ; - Algebra ‚Äî   ; - Signal ‚Äî   ; - Image ‚Äî   ; - Video ‚Äî   ; - Volume ‚Äî    ; - Graphics ‚Äî    .</code> </pre> <br><p>  For data arrays, the most requested operations are defined, for example, addition, elementwise multiplication, calculation of the average value of the array, etc. </p><br><p>  Developers can use vector parallelism on the Elbrus platform directly, that is, perform the same operation on a single register containing several data elements at once.  For this, intrinsiki functions are used, the calls of which are replaced by the compiler with high-performance code for this platform.  The Elbrus-4C microprocessor supports instruction set version 3, in which the register size is 64 bits.  Using a 64-bit register, you can simultaneously process 2 real 32-bit numbers, 4 16-bit integers, or 8 8-bit integers, and thus improve performance.  The Elbrus microprocessor intrinsic set is in many ways similar to the SSE, SSE2 intrinsic set and includes operations for data conversion, initialization of vector elements, arithmetic operations, bitwise logical operations, permutation of vector elements, etc. </p><br><h3 id="optimizaciya-klassifikatora-violy-i-dzhonsa-dlya-arhitektury-elbrus">  Optimization of the Viola and Jones classifier for Elbrus architecture </h3><br><p>  Experimental verification of the developed Viola and Jones classification algorithm was performed in the task of detecting the third page of the passport of the Russian Federation, containing the passport number and series, as well as the last name, first name, patronymic, gender, date and place of birth of a citizen of the Russian Federation.  To solve this problem, a binary classifier was trained, to the input of which a gray image arrives, reduced to a size of 480 by 360 pixels.  In case the reduction to a given size does not preserve the proportions of the input image, the smallest dimension of the image is reduced to the corresponding size, and the second decreases with the preservation of proportions.  The outputs of the classifier are interpreted as the presence or absence of a passport page, oriented so that its sides are parallel to the edges of the frame. </p><br><p>  The developed classifier operates with modified Haar double-rectangular signs, which are calculated on the basis of integral images: </p><br><img src="https://habrastorage.org/webt/59/f0/a2/59f0a2a92603e960784384.png"><br><p>  where <em>I</em> is the integral image, <em>W</em> , <em>H</em> is the width and height of the rectangle from which the sum is calculated, ( <em>x</em> , <em>y</em> ) is the coordinate of the upper left corner of the subwindow, ( <em>p</em> , <em>q</em> ) is the shift of the second rectangle to calculate the sum, <em>r</em> is the result of the sign .  Unlike the classical two-rectangular feature of the Haar, this feature is more resistant to changes in brightness in the original image. </p><br><p>  During the detection, these calculations are made for each sub-window of the original image.  Since for our classifier, the step with which these subwindows are taken is equal to 1 both horizontally and vertically, operations of the form (1) for each row of the original picture are easily implemented using such vector EML operations as: </p><br><pre> <code class="cpp hljs">- <span class="hljs-function"><span class="hljs-function">eml_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eml_Vector_AddShift_32S</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32s *pSrc1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32s *pSrc2, eml_32s *pDst, eml_32s len, eml_32s len)</span></span></span><span class="hljs-function"> -       32-  Src1  pSrc2    2^shift      pDst. - eml_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eml_Vector_SubShift_32S</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32s *pSrc1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32s *pSrc2, eml_32s *pDst, eml_32s len, eml_32s len)</span></span></span><span class="hljs-function"> -       32-  Src1  pSrc2    2^shift      pDst. - eml_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eml_Vector_AddCShift_32S</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_32s *pSrc, eml_32s val, eml_32s *pDst, eml_32s len, eml_32s shift)</span></span></span><span class="hljs-function"> -    val      32-  pSrc    2^shift      pDst. - eml_Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eml_Vector_DivShift_32S</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_16s *pSrc1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eml_16s *pSrc2, eml_16s *pDst, eml_32s len, eml_32s shift)</span></span></span><span class="hljs-function"> -       32-  Src1  pSrc2    2^shift      pDst.</span></span></code> </pre> <br><p>  Thus, the calculation of 2-rectangular signs of Haar was vectorized.  Figure 2 shows the time for calculating such a sign depending on the number of applications of the classifier horizontally.  The experiments were performed on a machine with an Elbrus-4C processor.  You can see that the EML allows you to speed up the computation time of the 2-rectangular Haar attribute up to 10 times in the process of object detection, and this is most effective when the number of applications of the classifier is 64 or more. </p><br><p>  Next, we estimate the time for classifying one subwindow, depending on the length of the original image (see Figure 3).  It can be seen that the use of EML made it possible to reduce the time for detecting the RF passport page by up to 30 times. </p><br><img src="https://habrastorage.org/webt/59/f0/6d/59f06d01dfe2e545589225.png"><br><p>  Figure 2 - Dependence of the calculation time of the modified 2-rectangular Haar characteristic <em>T</em> on the number of applications </p><br><img src="https://habrastorage.org/webt/59/f0/6d/59f06d0ce430b640330841.png"><br><p>  Figure 3 - Dependence of the time to calculate the classification <em>T</em> on the number of applications of the classifier horizontally <em>n</em> </p><br><p>  Similar results far exceeded the expected.  Apparently, the reasons for this are the peculiarities of the STL implementation (used in the basic implementation) and the peculiarities of working with memory on Elbrus (for example, the need to align to use an array swapping device - a special Elbrus chip).  It turned out that the operations of the EML library take into account these circumstances and make it possible to speed up low-level operations nicely, without requiring the developer to "deeply dive" into the nuances of the architecture. </p><br><p>  !  You can see the Elbrus computers and our products at <a href="http://mcst.ru/mcst-primet-uchastie-v-vystavke-chipexpo-2017">ChipEXPO - 2017</a> </p><br><h3 id="spisok-ispolzovannyh-istochnikov">  List of used sources </h3><br><ol><li>  Viola P., Jones M. Robust Real-time Object Detection // International Journal of Computer Vision.  2001. [7] </li><li>  Viola P., Jones M., Snow D. Detecting pedestrians using patterns // Int.  J. Comput.  Vis.  2005. Vol.  63, No. 2. P. 153‚Äì161.  [thirty], </li><li>  Moutarde F., Stanciulescu B., Breheret A. Real-time visual detection of vehicles and pedestrians with new efficient adaBoost features // 2008 IEEE International Conference on Intelligent RObots Systems (IROS 2008).  2008. [33] </li><li>  Chen S., Hsieh J. Boosted road sign detection and recognition // 2008 Int.  Conf.  Mach.  Learn.  Cybern.  2008. ‚Ññ July.  P. 3823‚Äì3826.  [36] </li><li>  Freund Y., Schapire RE A decision-theoretic generalization of on-line learning and an application to boosting. Journal of Computer Science and System Sciences, No. 55. Issue 1, August 1997, P. 119-139 </li><li>  Papageorgiou CP, Oren M., Poggio T. A general framework for object detection // Sixth Int.  Conf.  Comput.  Vis.  IEEE Cat No98CH36271.  1998. Vol.  6, No. January.  P. 555-562 [47] </li><li>  Crow FC Summed-area tables for texture mapping // ACM SIGGRAPH Computer Graphics.  1984. Vol.  18, No. 3. P. 207‚Äì212 [49] </li><li>  Kim A.K., Bychkov I.N.  Russian Technologies ‚ÄúElbrus‚Äù for personal computers, servers and supercomputers // Modern information technologies and IT education, M .: Foundation for Assistance in the Development of Internet Media, IT Education, Human Potential ‚ÄúInternet Media League‚Äù, 2014, ‚Ññ 10. 39-50. </li><li>  Kim A.K., Perekatov V.I., Ermakov S.G. Microprocessors and computer complexes of the Elbrus family.  - SPb .: Peter, 2013. - 272 C. </li><li>  Ishin PA, Loginov V.E., Vasilyev P.P.  Accelerating Computations Using High-Performance Mathematical and Multimedia Libraries for the Elbrus Architecture // Bulletin of Aerospace Defense, Moscow: Almaz Scientific and Production Association.  Acad.  A.A.  Raspletina, 2015, No. 4 (8).  64-68. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/340918/">https://habr.com/ru/post/340918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340906/index.html">Magic Leap has raised $ 502 million: why investors continue to invest in Google's secret project</a></li>
<li><a href="../340910/index.html">Time to fix errors in open-source projects, competition</a></li>
<li><a href="../340912/index.html">TrustZone: hardware implementation in ARMv7A</a></li>
<li><a href="../340914/index.html">How to evaluate whether marketing activities will bring profit to the store</a></li>
<li><a href="../340916/index.html">Blockchain eyes of the developer</a></li>
<li><a href="../340920/index.html">Automation of work with current customers. Account Management. Choose a CRM system. Part 3</a></li>
<li><a href="../340922/index.html">We explain the modern JavaScript dinosaur</a></li>
<li><a href="../340924/index.html">Using the neural network to build a model for assessing borrowers in the field of online microfinance</a></li>
<li><a href="../340926/index.html">Web application on Node and Vue, part 2: components, forms, routes</a></li>
<li><a href="../340928/index.html">Under the hood Ethereum Virtual Machine. Part 1 - Solidity basics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>