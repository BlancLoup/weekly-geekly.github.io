<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt: template for correct work with threads</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All habra 
 Somehow I needed to implement a multi-threaded application with intensive signal exchange in Qt 5.1.1 for WinXP in VS2009. I took Schlee ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt: template for correct work with threads</h1><div class="post__text post__text-html js-mediator-article">  All habra <br>  Somehow I needed to implement a multi-threaded application with intensive signal exchange in Qt 5.1.1 for WinXP in VS2009.  I took <a href="http://www.labirint.ru/books/272473/">Schlee</a> , deducted from him that you need to inherit a class from QThread and - voila, well in multi-threading!  Just in case, I looked into the <a href="http://qt-project.org/doc/qt-5.1/qtcore/qthread.html">Qt documentation</a> - there no one objected to the inheritance from QThread of its class.  Well - order, done!  I start it - it seems like it works, but somehow it is not so ... I start tracking in debug mode - and there the devil knows what's going on!  That signals do not go out, then go out, but somehow crookedly and from another stream.  In short, a mess!  I had to google thoroughly and sort out the topic (I was helped by the articles <a href="http://vasinnet.blogspot.com/2012/08/recommended-way-to-using-qthread.html">here</a> , <a href="http://habrahabr.ru/post/150274/">here</a> and <a href="http://qt-project.org/wiki/Threads_Events_QObjects">there</a> ).  As a result, I made a class template in C ++ (or rather, a whole hierarchy of these), which allowed me to finally write (relatively) small code of a class that lives in another thread that works correctly and stably. <br>  <b>Upd:</b> <i><a href="http://habrahabr.ru/post/202312/">in the comments</a> I was prompted by a better approach - I described it <a href="http://habrahabr.ru/post/203254/">in a new article</a></i> . <br><a name="habracut"></a><br><h4>  What do you want </h4><br>  I strove for quite obvious things: <br><ul><li>  use C ++ classes in all their beauty - that is, so that the constructor is called when creating the stream and the destructor before destruction; </li><li>  use Qt features in all its beauty - i.e., signal-slot connections, events, etc .; </li><li>  if desired - control over the process of creation and work - the priority of the flow, the slot for the start of work and the signal of emergency completion; </li><li>  minimum writings and maximum clarity. </li></ul><br>  I got something like: <br><br><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeJob</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QObject</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q_OBJECT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeJob</span></span></span><span class="hljs-class"> () { /* ... */ } //   ~</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeJob</span></span></span><span class="hljs-class"> () { /* ... */ } //   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signals</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">finished</span></span></span><span class="hljs-class"> ();</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/     public slots: void to_terminate () { /</span></span>* ... *<span class="hljs-regexp"><span class="hljs-regexp">/ } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   }; ... ThreadedObject&lt;SomeJob&gt; thr; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -  thr.start (); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     </span></span></code> </pre> <br><br>  Beautiful! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  How we will act </h4><br>  In Qt 5.1, the low-level QThread class is for our purposes.  The <a href="http://qt-project.org/doc/qt-5.1/qtcore/qthread.html">following is said</a> about him: ‚Äúthe QThread class gives the opportunity to manage threads in a platform-independent form‚Äù.  Schlee had a wonderful book, but he came up with an example of threads that was very confusing: he offers to <i>inherit</i> the QThread class, override the run () method and do the work in it.  This is not bad for a ‚Äúlaunched, executed, and completed‚Äù task, but it is totally unacceptable for more complex cases. <br>  In general, in vain I <s>listened to</s> him read, I had to immediately delve into the documentation.  And there is, by the way, a good example.  It shows the correct path: <a href="http://qt-project.org/doc/qt-5.1/qtcore/qobject.html">the QObject :: moveToThread function (QThread * thread)</a> , which transfers <i>affinity</i> (similarity? - the affinity) of a given object and all its ancestors to the thread. <br>  Thus, in the first approximation, the solution to the problem is as follows: <br><ol><li>  thread creation - QThread class; </li><li>  creating an object and moving it to a new stream; </li><li>  installation of signal-slot communications; </li><li>  start a thread with a given priority. </li></ol><br>  It seems to be all right, but - remember?  - I want the constructor of the created object to run <i>in the new thread</i> .  To do this, it must be started <i>after the thread starts</i> .  You can create an object first, and then a stream.  But everything that will be created by the object constructor will be placed on the stack (heap) of the <i>current</i> thread, and not the new one.  You can somehow neatly transfer all this household to a new stream and delete it in the old one, but ... it is easier to call the designer already in the new stream.  So here we have the problem number 1.  Need to solve. <br>  Then came problem number 2.  I created a nice template that inherits from QObject - I needed it for signal-slot communications.  And then a <a href="http://qt-project.org/doc/qt-5.1/qtdoc/moc.html">pop-up appeared</a> : ‚ÄúMOC does not allow using all the features of C ++.  The main problem is that <i>class templates cannot have signals or slots</i> . ‚Äù  # @ &amp; *! <br>  However, I also overcame this topic. <br><br>  I came up with the following classes: <br><ol><li>  your native class T; </li><li>  There is a class for creating an object - CreatorBase (a descendant of QObject).  In the slot, it calls a new method to create a new object and transmits its address with a signal; </li><li>  there is a template implementation of the creator class - Creator &lt;T&gt; (descendant of CreatorBase).  It implements a method for creating an object of a given type; </li><li>  There is a class called ThreadedObjectBase (a descendant of QObject) that creates a new thread.  It receives the CreatorBase creator object and establishes the necessary signal-slot connections; </li><li>  the user uses the template object and thread storage class ThreadedObject &lt;T&gt; (a descendant of ThreadedObjectBase).  It causes the creation of a new object and overloads the * and -&gt; operators, as well as the type pointer of the object being created; </li><li>  the user creates a class (it can be a descendant of QObject) in which, if desired, it implements the ‚Äúclass finished work‚Äù signal and the ‚Äúwork interruption‚Äù slot, and can also specify a <a href="http://qt-project.org/doc/qt-5.1/qtcore/qobject.html">pending object deletion</a> . </li></ol><br><br>  The sequence of actions turned out to be simple: <br><ol><li>  the object and thread storage class is ThreadedObject; </li><li>  it creates the creator of the Creator and QThread objects for the new thread; </li><li>  the creator of the object is transferred to the new stream; </li><li>  signal-slot connections are established; </li><li>  the newly created thread starts up with the necessary priority; </li><li>  a custom class T is created in the created stream; </li><li>  ThreadedObjectBase finds out about this using the setObject slot (void * Obj), stores the address of the object and notifies the world about it with the signal objectIsReady (); </li><li>  You can learn about the successful ending of all these actions from the bool ThreadedObject &lt;T&gt; :: objectIsCreated (void) const. </li></ol><br><br><h4>  Implementation </h4><br>  Consider the code of the created classes (so that it all fits into the screen, I removed the comments). <br>  Object Creators: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatorBase</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *_obj; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Allocation</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setObject</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Allocation ())</span></span></span></span>; } signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setObject</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Obj)</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Creator</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CreatorBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Allocation</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt; (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T); } };</code> </pre><br><br>  Everything is obvious here: the CreatorBase creator base class has a allocate () slot that will run in the new active thread.  It calls the setObject (void * Obj) signal, which passes the address of the object created in the descendant void * Creator &lt;T&gt; :: Allocation (). <br><br>  The base class ThreadedObjectBase is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadedObjectBase</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: QThread *_thread; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetObjectPointer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Ptr)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ThreadedObjectBase (QObject *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>): QObject (parent), _thread (<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">starting</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CreatorBase *Creator, QThread::Priority Priority = QThread::InheritPriority, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ToDeleteLaterThread = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res; _thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QThread; Creator-&gt;moveToThread (_thread); res = connect (_thread, SIGNAL (started ()), Creator, SLOT (allocate ())); Q_ASSERT_X (res, <span class="hljs-string"><span class="hljs-string">"connect"</span></span>, <span class="hljs-string"><span class="hljs-string">"connection is not established"</span></span>); res = connect (Creator, SIGNAL (setObject (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT (setObject (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*))); Q_ASSERT_X (res, <span class="hljs-string"><span class="hljs-string">"connect"</span></span>, <span class="hljs-string"><span class="hljs-string">"connection is not established"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ToDeleteLaterThread) { res = connect (_thread, SIGNAL (finished ()), _thread, SLOT (deleteLater ())); Q_ASSERT_X (res, <span class="hljs-string"><span class="hljs-string">"connect"</span></span>, <span class="hljs-string"><span class="hljs-string">"connection is not established"</span></span>); } _thread-&gt;start (Priority); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ThreadedObjectBase (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { } <span class="hljs-function"><span class="hljs-function">QThread *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _thread; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> QThread *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cthread</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _thread; } signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectIsReady</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setObject</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Obj)</span></span></span><span class="hljs-function"> </span></span>{ SetObjectPointer (Obj); <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectIsReady</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } };</code> </pre><br><br>  The basic method here is starting.  It creates a thread with the specified priority.  On start, the _thread thread calls <a href="http://qt-project.org/doc/qt-5.1/qtcore/qthread.html">QThread :: started ()</a> .  We associate this signal with the CreatorBase :: allocate () slot, which creates a new object.  That, in turn, causes the signal CreatorBase :: setObject (void *), which we pick up with the ThreadedObjectBase :: setObject (void * Obj) slot.  Everything, the object is created (the signal ThreadedObjectBase :: objectIsReady () is issued about), a pointer to it is received. <br><br>  If the user wants to set a deferred removal of the flow class (which is desirable), a connection is established inside _thread <a href="http://qt-project.org/doc/qt-5.1/qtcore/qthread.html">QThread :: finished ()</a> -&gt; <a href="http://qt-project.org/doc/qt-5.1/qtcore/qobject.html">QObject :: deleteLater ()</a> . <br>  Also, the user can set the signal name (will be stored in the _finished_signal variable).  This signal is called by the created object at the end of its work.  Similarly, the slot from _terminate_slot will be called by the flow interruption signal (the flow, however, does not stop instantaneously; you can wait for its termination by calling thread () -&gt; wait - see <a href="http://qt-project.org/doc/qt-5.1/qtcore/qthread.html">QThread :: wait</a> ). <br><br>  Well, finally, the template class visible to the user: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadedObject</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ThreadedObjectBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: T* _obj; Creator&lt;T&gt; _creator; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_finished_signal; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_terminate_slot; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _to_delete_later_object; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetObjectPointer</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res; _obj = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span> &lt;T*&gt; (Ptr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_finished_signal) { res = connect (_obj, _finished_signal, _thread, SLOT (quit ())); Q_ASSERT_X (res, <span class="hljs-string"><span class="hljs-string">"connect"</span></span>, <span class="hljs-string"><span class="hljs-string">"connection is not established"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_terminate_slot) { res = connect (_thread, SIGNAL (finished ()), _obj, _terminate_slot); Q_ASSERT_X (res, <span class="hljs-string"><span class="hljs-string">"connect"</span></span>, <span class="hljs-string"><span class="hljs-string">"connection is not established"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_to_delete_later_object &amp;&amp; _finished_signal) { res = connect (_obj, _finished_signal, _obj, SLOT (deleteLater ())); Q_ASSERT_X (res, <span class="hljs-string"><span class="hljs-string">"connect"</span></span>, <span class="hljs-string"><span class="hljs-string">"connection is not established"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ThreadedObject (QObject *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>): ThreadedObjectBase (parent), _obj (<span class="hljs-number"><span class="hljs-number">0</span></span>) { } ~ThreadedObject (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *FinishedSignal = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *TerminateSlot = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, QThread::Priority Priority = QThread::InheritPriority, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ToDeleteLaterThread = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ToDeleteLaterObject = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Creator&lt;T&gt; *creator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Creator&lt;T&gt;; _finished_signal = FinishedSignal; _terminate_slot = TerminateSlot; _to_delete_later_object = ToDeleteLaterObject; starting (_creator, Priority, ToDeleteLaterThread); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> creator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectIsCreated</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _obj != <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span> &lt;T*&gt; (_obj); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cptr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T*&gt; (_obj); } <span class="hljs-comment"><span class="hljs-comment">// .  operator T* (void) { return ptr (); } T* operator -&gt; (void) { return ptr (); } operator const T* (void) const { return cptr (); } const T* operator -&gt; (void) const { return cptr (); } };</span></span></code> </pre><br><br>  Here the main method is start, which memorizes the names of signals and slots, and also sets the pending method deletion.  The objectIsCreated () method returns true when an object has already been created.  Multiple overloads allow you to use ThreadedObject &lt;T&gt; as a smart pointer. <br><br>  Here is a simple example of using these classes: <br><br><pre> <code class="cpp hljs">ThreadedObject &lt;Operation&gt; _obj; QObject::connect (&amp;_obj, SIGNAL (objectIsReady ()), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT (connectObject ())); _obj.start (SIGNAL (finished ()), SLOT (terminate ()), QThread::HighPriority);</code> </pre><br><br>  A real example is attached below - a button is created in the main thread.  In the new thread, an int variable is created, as well as a signal from the timer and a timer event.  Both of these timers reduce the value of the variable int, when the value reaches zero, the <a href="http://qt-project.org/doc/qt-5.1/qtcore/qcoreapplication.html">QCoreApplication :: quit ()</a> slot is called.  On the other hand, closing the application stops the flow.  The example is verified in WinXP.  I would like to hear in the comments about the successful trials in Linux, MacOS, Android and <a href="http://qt-project.org/doc/qt-5.1/qtdoc/supported-platforms.html">other supported platforms</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Example + Classes</b> <div class="spoiler_text">  ThreadedObject file: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ** // **      // ** class CreatorBase: public QObject { Q_OBJECT void *_obj; //   protected: virtual void *Allocation (void) = 0; //     public slots: void allocate (void) { emit setObject (Allocation ()); } //    signals: void setObject (void *Obj); //    }; // ** // **      // ** class ThreadedObjectBase: public QObject { Q_OBJECT protected: QThread *_thread; //  virtual void SetObjectPointer (void *Ptr) = 0; //     ThreadedObjectBase (QObject *parent = 0): QObject (parent), _thread (0) {} //   void starting (CreatorBase *Creator, QThread::Priority Priority = QThread::InheritPriority, bool ToDeleteLaterThread = true) //    { bool res; //    - _thread = new QThread; //   Creator-&gt;moveToThread (_thread); //  _creator   res = connect (_thread, SIGNAL (started ()), Creator, SLOT (allocate ())); Q_ASSERT_X (res, "connect", "connection is not established"); //   _thread    Creator- res = connect (Creator, SIGNAL (setObject (void*)), this, SLOT (setObject (void*))); Q_ASSERT_X (res, "connect", "connection is not established"); // Creat-    if (ToDeleteLaterThread) //   thread? { res = connect (_thread, SIGNAL (finished ()), _thread, SLOT (deleteLater ())); Q_ASSERT_X (res, "connect", "connection is not established"); } //   _thread     _thread-&gt;start (Priority); //   } public: // .  virtual ~ThreadedObjectBase (void) { } //    QThread *thread (void) { return _thread; } // ,   // .  const QThread *cthread (void) const { return _thread; } // ,   signals: void objectIsReady (void); //  " " private slots: void setObject (void *Obj) { SetObjectPointer (Obj); emit objectIsReady (); } //    }; // class ThreadedObjectBase // ** // **   // ** template &lt;class T&gt; class ThreadedObject: public ThreadedObjectBase { private: template &lt;class T&gt; class Creator: public CreatorBase //     { protected: void *Allocation (void) { return reinterpret_cast &lt;void*&gt; (new T); } }; protected: T* _obj; //  Creator&lt;T&gt; _creator; //   const char *_finished_signal; //  "  " const char *_terminate_slot; //  " " bool _to_delete_later_object; //  "  ? void SetObjectPointer (void *Ptr) //    { bool res; //    - _obj = reinterpret_cast &lt;T*&gt; (Ptr); //     if (_finished_signal) //   "  "? { res = connect (_obj, _finished_signal, _thread, SLOT (quit ())); Q_ASSERT_X (res, "connect", "connection is not established"); } //        if (_terminate_slot) //   " "? { res = connect (_thread, SIGNAL (finished ()), _obj, _terminate_slot); Q_ASSERT_X (res, "connect", "connection is not established"); } //        " " if (_to_delete_later_object &amp;&amp; _finished_signal) //    ? { res = connect (_obj, _finished_signal, _obj, SLOT (deleteLater ())); Q_ASSERT_X (res, "connect", "connection is not established"); } //         } public: // .  ThreadedObject (QObject *parent = 0): ThreadedObjectBase (parent), _obj (0) {} //  ~ThreadedObject (void) { } //  void start (const char *FinishedSignal = 0, const char *TerminateSlot = 0, QThread::Priority Priority = QThread::InheritPriority, bool ToDeleteLaterThread = true, bool ToDeleteLaterObject = true) //    { _finished_signal = FinishedSignal; //    "  " _terminate_slot = TerminateSlot; //    " " _to_delete_later_object = ToDeleteLaterObject; //      starting (_creator, Priority, ToDeleteLaterThread); //   } // .  bool objectIsCreated (void) const { return _obj != 0; } //    ? T* ptr (void) { return reinterpret_cast &lt;T*&gt; (_obj); } //    const T* cptr (void) const { return reinterpret_cast &lt;const T*&gt; (_obj); } //     // .  operator T* (void) { return ptr (); } //    T* operator -&gt; (void) { return ptr (); } //    operator const T* (void) const { return cptr (); } //     const T* operator -&gt; (void) const { return cptr (); } //     }; // class ThreadedObject</span></span></code> </pre><br><br>  Main.cpp file: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QtGui&gt; #include &lt;QtWidgets&gt; #include &lt;QtCore&gt; #include "ThreadedObject.h" // ** // **   // ** class Operation: public QObject { Q_OBJECT int *Int; //    QTimer _tmr; //  int _int_timer; //   public: Operation (void) { Int = new int (5); } //   ~Operation (void) { if (Int) delete Int; } //   signals: void addText(const QString &amp;txt); //  " " void finished (); //  " " public slots: void terminate () //   { killTimer (_int_timer); //    _tmr.stop (); //    delete Int; //   Int = 0; //    emit finished (); //    } void doAction (void) //   { bool res; emit addText (QString ("- %1 -"). arg (*Int)); res = QObject::connect (&amp;_tmr, &amp;QTimer::timeout, this, &amp;Operation::timeout); Q_ASSERT_X (res, "connect", "connection is not established"); //    _tmr.start (2000); //    thread()-&gt;sleep (1); //  1 ... timeout (); // ...   ... startTimer (2000); // ...     } protected: void timerEvent (QTimerEvent *ev) { timeout (); } //   private slots: void timeout (void) { if (!Int || !*Int) //  ? return; // ...  --*Int; //   emit addText (QString ("- %1 -"). arg (*Int)); //   if (!Int || !*Int) //  ? emit finished (); // ...  } }; // ** // ** ,    // ** class App: public QObject { Q_OBJECT ThreadedObject &lt;Operation&gt; _obj; // - QPushButton _btn; //  protected: void timerEvent (QTimerEvent *ev) { bool res; //    - killTimer (ev-&gt;timerId ()); //   res = QObject::connect (&amp;_obj, SIGNAL (objectIsReady ()), this, SLOT (connectObject ())); Q_ASSERT_X (res, "connect", "connection is not established"); //     _obj.start (SIGNAL (finished ()), SLOT (terminate ()), QThread::HighPriority); //      } private slots: void setText (const QString &amp;txt) { _btn.setText (txt); } //     void connectObject (void) //     { bool res; //    - res = QObject::connect (this, &amp;App::finish, _obj, &amp;Operation::terminate); Q_ASSERT_X (res, "connect", "connection is not established"); //        res = QObject::connect (this, &amp;App::startAction, _obj, &amp;Operation::doAction); Q_ASSERT_X (res, "connect", "connection is not established"); //     res = QObject::connect (_obj, &amp;Operation::finished, this, &amp;App::finish); Q_ASSERT_X (res, "connect", "connection is not established"); //      res = QObject::connect (_obj, &amp;Operation::addText, this, &amp;App::setText); Q_ASSERT_X (res, "connect", "connection is not established"); //     res = QObject::connect (&amp;_btn, &amp;QPushButton::clicked, _obj, &amp;Operation::terminate); Q_ASSERT_X (res, "connect", "connection is not established"); //    _btn.show (); //   emit startAction (); //   } public slots: void terminate (void) { emit finish (); } //    signals: void startAction (void); //  " " void finish (void); //  " " }; // ** // **     // ** int main (int argc, char **argv) { QApplication app (argc, argv); //  App a; //  bool res; //    a.startTimer (0); //          res = QObject::connect (&amp;a, SIGNAL (finish ()), &amp;app, SLOT (quit ())); Q_ASSERT_X (res, "connect", "connection is not established"); //      res = QObject::connect (&amp;app, SIGNAL (lastWindowClosed ()), &amp;a, SLOT (terminate ())); Q_ASSERT_X (res, "connect", "connection is not established"); //      return app.exec(); //     } #include "main.moc"</span></span></span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/202312/">https://habr.com/ru/post/202312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202302/index.html">Development of cross-platform mobile applications in Delphi # 4</a></li>
<li><a href="../202304/index.html">Tiny Excel in pure javascript (30 lines of code)</a></li>
<li><a href="../202306/index.html">ScienceHub # 06: Computational Linguistics</a></li>
<li><a href="../202308/index.html">Baytkod</a></li>
<li><a href="../202310/index.html">04 Collector: links for designers and developers</a></li>
<li><a href="../202314/index.html">Counts for the smallest: Dijkstra or how I did not go on an interview on Twitter</a></li>
<li><a href="../202318/index.html">About summer internship at JetBrains</a></li>
<li><a href="../202322/index.html">72-megapixel camera-ball shoots 360-degree panoramas in flight</a></li>
<li><a href="../202324/index.html">DDR4 will be available next month.</a></li>
<li><a href="../202328/index.html">Could there be too much automation on the plane?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>