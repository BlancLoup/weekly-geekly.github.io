<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do not be afraid of Core Data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It has long been noticed that among many of his colleagues in the workshop there is some suspicion and even in some way hostility to Core Data, and so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do not be afraid of Core Data</h1><div class="post__text post__text-html js-mediator-article"> It has long been noticed that among many of his colleagues in the workshop there is some suspicion and even in some way hostility to Core Data, and some of the framework did not even touch.  What is already there, and at the beginning of my journey of mastering the new platform, I was biased towards him, taking advantage of such comments.  But do not succumb to prejudice and myths without touching the product yourself.  To those of us who went ‚Äúagainst the system‚Äù, but have not yet fully grasped the tool, I dedicate this article.  Based on a small example based on the real task of developing the mobile client of our social network My World, I want to talk about some of the "underwater" stones and focus the attention of the novice developer on the important points of optimizing the use of Core Data.  It is assumed that the reader already has an idea what the core elements of Core Data are for ( <code>NSManagedObjectContext</code> , <code>NSPersistentStoreCoordinator</code> , etc.) and at least superficially familiar with the API. <br><br>  Our case: it is necessary to develop an application that allows you to store and structure a large amount of photos with various meta-information about them.  For this we need Core Data ... and that's it. <br><br> <a href="http://habrahabr.ru/company/mailru/blog/235941/"><img src="https://habrastorage.org/getpro/habr/post_images/29d/739/53b/29d73953b38d78ea08ff4ee2189aee85.jpg" alt="Core Data rulezzz!"></a> <br><a name="habracut"></a><br><h1>  Core data stack </h1>  So, the first thing we have to do is prepare the right Core Data stack.  Fortunately for us, there is a universal solution, I think the well-known Best Practice from WWDC 2013: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/509/8c5/270/5098c52703006b3608b9c885bf648fc7.png" alt="Core data stack"><br><br>  <a href="">The stack</a> is divided into two contexts; Main Context is used on the main stream for reading data;  Background Context - to edit, insert and delete large amounts of data.  That is, it is recommended to initially build the architecture of your application so that all changes occur in the background context, and you only perform read-only operations on the main context. <br><br>  It should be noted that a lot of articles have been written on the architecture of the stacks, describing various branches of contexts.  In my opinion, they only lift the threshold for the use of Core Data and only frighten novice developers from using the framework.  In fact, for the 90% of applications, the above model will suffice, another 9% will be enough for one Main Context and only the rest of the <s>hardcore</s> players will need something more complicated. <br><br><h1>  Subtle moments </h1><ul><li>  Starting with iOS 7, sqlite storage, unlike previous versions, operates in <a href="http://www.sqlite.org/wal.html">WAL (Write Ahead Log) journaling</a> mode, which allows you to perform one write operation and multiple read operations in parallel.  If suddenly you support iOS 6, then it is possible to enable this mode when creating a stack coordinator in iOS 4+ versions using <code>NSSQLitePragmasOption</code> , however this can be fraught with troubles.  Also in iOS 6 in a stack with two coordinators, when synchronizing contexts through notification <a href="http://stackoverflow.com/questions/19562119/coredata-threading-ios-6-vs-7">, objects in them may not be updated</a> .  Therefore, for iOS 6 it is better to use a stack with two contexts that have a common coordinator and do not bother with the journaling mode, the percentage of active devices is extremely low. </li><li>  WAL also stores a time bomb in the form of broken manual migration and possible backup errors.  Since the storage on the disk is organized in the form of three files: dbname.sqlite, dbname.sqlite-wal and dbname.sqlite-shm, then when organizing a manual backup, you should not forget to save them all, otherwise then you will have to wait for a very ‚Äúpleasant‚Äù surprise.  Apple engineers apparently forgot about the presence of a WAL file themselves, so when using the Migration Manager we can also break the base.  I myself have not encountered a similar problem, you can read more <a href="http://pablin.org/2013/05/24/problems-with-core-data-migration-manager-and-journal-mode-wal/">here</a> . </li><li>  Typical manuals on Core Data and a project template in Xcode suggest placing the stack directly in the <code>AppDelegate</code> class and initializing everything you need during the launch of the application.  However, if in your application the work with the database is sporadic or optional (for example, it is needed only after the user is registered in the application and is not needed for guest access), it makes sense to put the stack ‚Äúsideways‚Äù.  For this, a separate <code>Singleton</code> class will be suitable, which will be initialized directly at the moment when it is really needed.  This will save a significant amount of memory and reduce the time to start the application. </li></ul><br><h1>  Model design </h1>  Thinking through the data schema is the most important moment when working with Core Data.  Correcting a mistake made during the design phase of an architecture can cost a lot of time and nerves to a developer.  Ideal if the model does not change after going into battle.  In reality, if you do not have to resort to manual migration through the Migration Manager and all changes are swallowed <a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/CoreDataVersioning/Articles/vmLightweightMigration.html">Lightweight Migration</a> - you are well done.  Give this stage as much time as possible and try to experiment with different versions of the models. <br><br>  Let's return to our application, in it we want to achieve the following goals: <br>  - <s>synchronize photos with the server without affect on the UI</s> (done! Use for this Background Context in the stack); <br>  - on the main screen show all photos sorted by date; <br>  - on the secondary screen, group photos, where the grouping criteria is the number of likes, photos within the group are additionally sorted by date. <br><br>  Let's get to the beginning to solve the problem in the forehead, create a model in which there will be only one Entity - our photo with all the meta-information: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/853/869/377/853869377048ebdf791ea75414571a06.png" alt="First model"><br><br>  It was very simple, and if we were lazy developers, the work would have been finished on this (and someone else would have written the article :)). <br><br>  For testing, we will assume that on the main screen we will need a simple <code>NSFetchRequest</code> , the results of which we then show in the <code>UICollectionView</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87b/e54/907/87be5490729ab698c3e2c1010194773e.png" alt="NSFetchRequest"><br><br>  And on the additional screen, we will use all the power of <code>NSFetchedResultsController</code> to form sections and sort them: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e05/8be/d20/e058bed2036adc14c839c2960425e635.png" alt="NSFetchedResultsController"><br><br>  Having decided on our model, we will make a benchmark measurement of performance on the iPhone 5 for 10,000 photos.  Hereinafter we will test our model for typical operations associated with our model: <br><ul><li>  Insert 10,000 objects and then save the context. </li><li>  Request of all 10,000 objects sorted by one field (date in our case) </li><li>  Using <code>NSFetchedResultsController</code> c sorting by 2 fields and forming sections (sorting by the number of likes and date, forming sections by the number of likes) </li><li>  The same controller using <code>fetchBatchSize</code> equal to 30 (estimated number of photos on the gallery screen on the phone), to evaluate the effectiveness of block sampling </li></ul><br>  All data in the tables are given in seconds, respectively, the insertion of 10,000 of our photos on the iPhone 5 will take a little less than two seconds. <br><table><tbody><tr><th>  Operations \ Model Type </th><td>  Model V1 </td></tr><tr><th>  Insets (10,000 objects) </th><td>  1.952 </td></tr><tr><th>  NSFetchRequest (1 sort) </th><td>  0.500 </td></tr><tr><th>  NSFetchedResultsController (2 sorts) </th><td>  0.717 </td></tr><tr><th>  NSFetchedResultsController (2 sorts + batchSize) </th><td>  0.302 </td></tr></tbody></table><h1>  Indices </h1>  Although the execution time may seem inconsequential, you should not neglect the possibility of optimization.  Moreover, on older devices, operations are performed several times slower, and you should not forget about it.  The first optimization is the easiest and is known to everyone - we will try to add an index for the fields that participate in the queries we form, namely <i>date</i> and <i>likes</i> : <br><table><tbody><tr><th>  Operations \ Model Type </th><td>  Model V1 </td><td>  V1 + index </td><td>  Diff </td></tr><tr><th>  Insert (10000 objects) </th><td>  1.952 </td><td>  2.193 </td><td>  + 12% </td></tr><tr><th>  NSFetchRequest (1 sort) </th><td>  0.500 </td><td>  0.168 </td><td>  -66% </td></tr><tr><th>  NSFetchedResultsController (2 sorts) </th><td>  0.717 </td><td>  0.657 </td><td>  -eight% </td></tr><tr><th>  NSFetchedResultsController (2 sorts + batchSize) </th><td>  0.302 </td><td>  0.256 </td><td>  -15% </td></tr></tbody></table><br>  Pretty good performance boost at minimal cost.  Note that the time to add records has increased, this is due to the need to build an index.  That is why it is important to apply the index only where it is really needed.  By ticking the <code>Indexed</code> checkbox in all possible fields, thinking that it will speed up your application, you are doing yourself a disservice. <br><br>  Are all the juices we squeezed out of the index?  You may notice that the <code>NSFetchedResultsController</code> "sped up" significantly less than the simple <code>NSFetchRequest</code> .  What is the matter? <br><br><h1>  Composite Indexes </h1>  Let's take a look under the hood CoreData.  First of all, for this we need to enable the log for Core Data requests, by adding the "-com.apple.CoreData.SQLDebug 1" parameter to the Run scheme of our project as shown: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/99a/a5d/b7899aa5d88dacd7e6857f36d6a7d29f.png" alt="Debug"><br><br>  Next we need the sqlite file of the repository in its full state.  If you are working with a simulator, then Xcode 6 stores the simulator's file system in the directory "~ / Library / Developer / CoreSimulator / Devices /".  The name of the simulator directory corresponds to the Identifier value, which can be viewed in the device list (opened by Shitft + CMD + 2).  Next, look for the directory of your application and find out the full path to the .sqlite file, which is usually placed in the Documents directory of the application.  If you want to access the storage on the device, then the easiest way is to use the iExplorer application, using it as a file manager to browse the application directories on your device.  From there you can copy the storage files (do not forget about the .sqlite-wal and .sqlite-shm files) to any convenient directory.  All that is left to do is to connect to our repository from the console by running the command: <br><br><pre> <code class="sql hljs">sqlite3 PATH/TO/SQLITE/FILE</code> </pre> <br>  Now, by running our project and feeding the SQL directive " <b>EXPLAIN QUERY PLAN</b> " query from Core Data logs, we can find out some details of the processes occurring in sqlite.  Let's see what actually happens when executing <code>NSFetchRequest</code> : <br><br><pre> <code class="sql hljs">sqlite&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">QUERY</span></span> PLAN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, t0.Z_PK, t0.Z_OPT, t0.ZASSETURL, t0.ZCOUNTRY, t0.ZDATE, t0.ZHEIGHT, t0.ZLATITUDE, t0.ZLIKES, t0.ZLOCATIONDESC, t0.ZLONGITUDE, t0.ZSIZE, t0.ZWIDTH <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ZCDTMOPHOTOV1INDEX t0 <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> t0.ZDATE; 0|0|0|SCAN TABLE ZCDTMOPHOTOV1INDEX AS t0 USING INDEX ZCDTMOPHOTOV1INDEX_ZDATE_INDEX</code> </pre><br>  As expected, the SQL query uses an index, which led to a significant acceleration.  And what happens in <code>NSFetchedResultsController</code> : <br><br><pre> <code class="sql hljs">sqlite&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">QUERY</span></span> PLAN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, t0.Z_PK, t0.Z_OPT, t0.ZASSETURL, t0.ZCOUNTRY, t0.ZDATE, t0.ZHEIGHT, t0.ZLATITUDE, t0.ZLIKES, t0.ZLOCATIONDESC, t0.ZLONGITUDE, t0.ZSIZE, t0.ZWIDTH <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ZCDTMOPHOTOV1INDEX t0 <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> t0.ZLIKES <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>, t0.ZDATE <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>; 0|0|0|SCAN TABLE ZCDTMOPHOTOV1INDEX AS t0 USING INDEX ZCDTMOPHOTOV1INDEX_ZLIKES_INDEX 0|0|0|<span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> TEMP B-TREE <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RIGHT</span></span> PART <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span></code> </pre><br>  Here things are somewhat worse, the index worked only for <i>likes</i> , and a temporary binary tree is created to sort by date.  It is easy to optimize this behavior by creating a compound index for both fields participating in the query (CAUTION: if an additional condition appears in your query, for example WHERE, with some third field, then you also need to add it to the composite index, otherwise will not be used upon request).  This is done very easily in the Data Model Inspector, specifying, separated by commas, all the fields included in the composite index in the Indexes list of our Entity photo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d3/c47/761/7d3c47761aa3de12764bcad14647e4f9.png" alt="Data Model Inspector"><br><br>  Let's see how the SQL query will now be processed: <br><br><pre> <code class="sql hljs">sqlite&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">QUERY</span></span> PLAN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, t0.Z_PK, t0.Z_OPT, t0.ZASSETURL, t0.ZCOUNTRY, t0.ZDATE, t0.ZHEIGHT, t0.ZLATITUDE, t0.ZLIKES, t0.ZLOCATIONDESC, t0.ZLONGITUDE, t0.ZSIZE, t0.ZWIDTH <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ZCDTMOPHOTOV1COMPOUNDINDEX t0 <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> t0.ZLIKES <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>, t0.ZDATE <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>; 0|0|0|SCAN TABLE ZCDTMOPHOTOV1COMPOUNDINDEX AS t0 USING INDEX ZCDTMOPHOTOV1COMPOUNDINDEX_ZLIKES_ZDATE</code> </pre><br>  You can make sure that instead of a binary tree a composite index is used, and this can not but affect the performance: <br><table><tbody><tr><th>  Operations \ Model Type </th><td>  Model V1 </td><td>  V1 + index </td><td>  V1 + composite index </td><td>  Diff (V1) </td></tr><tr><th>  Insert (10000 objects) </th><td>  1.952 </td><td>  2.193 </td><td>  2.079 </td><td>  + 7% </td></tr><tr><th>  NSFetchRequest (1 sort) </th><td>  0.500 </td><td>  0.168 </td><td>  0.169 </td><td>  -66% </td></tr><tr><th>  NSFetchedResultsController (2 sorts) </th><td>  0.717 </td><td>  0.657 </td><td>  0.331 </td><td>  -54% </td></tr><tr><th>  NSFetchedResultsController (2 sorts + batchSize) </th><td>  0.302 </td><td>  0.256 </td><td>  0.182 </td><td>  -40% </td></tr></tbody></table><h1>  Entity splitting </h1>  Another possibility for optimization is the creation of entities that contain only the information we need in a particular request.  We see that our structure contains many minor fields that are not involved in the formation of the issuance of the initial result in our controllers.  Moreover, when working with an object, Core Data completely pulls them into memory, that is, the larger the structure, the more memory is consumed (in iOS 8, an API appeared that allows you to change objects directly in the storage; the API is quite limited in use, since it imposes additional requirements for synchronization contexts).  In our application, the division of our record into two suggests itself: the photo itself and the metadata for it: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0f/8af/98a/f0f8af98ac1222d4cccda286422618fc.png" alt="Separated entities"><br><br>  We will carry out the next test and look at the operation of the indices for such a model. <br><table><tbody><tr><th>  Operations \ Model Type </th><td>  Model V2 </td><td>  V2 + index </td><td>  Diff (V1 + index) </td></tr><tr><th>  Insert (10000 objects) </th><td>  3.218 </td><td>  3.524 </td><td>  + 61% </td></tr><tr><th>  NSFetchRequest (1 sort) </th><td>  0.219 </td><td>  0.215 </td><td>  + 28% </td></tr><tr><th>  NSFetchedResultsController (2 sorts) </th><td>  0.551 </td><td>  0.542 </td><td>  -18% </td></tr><tr><th>  NSFetchedResultsController (2 sorts + batchSize) </th><td>  0.387 </td><td>  0.390 </td><td>  + 52% </td></tr></tbody></table><br><img src="https://habrastorage.org/getpro/habr/post_images/16b/12e/3a5/16b12e3a519b9ac18991692df126b0a1.jpg" alt="Why is your index now?"><br><br>  The results of this test are quite interesting.  Please note that the speed of this model using the index is identical given the error of the model without it.  Using the already known way to look into the depths, we can find that in both cases the index is not involved, since JOIN metadata occurs first, and only then sorts are performed in the combined table: <br><br><pre> <code class="sql hljs">sqlite&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">QUERY</span></span> PLAN <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, t0.Z_PK, t0.Z_OPT, t0.ZASSETURL, t0.ZMETA <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ZCDTMOPHOTOV2INDEX t0 <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> ZCDTMOPHOTOMETAINDEX t1 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t0.ZMETA = t1.Z_PK <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> t1.ZLIKES <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>, t1.ZDATE <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>; 0|0|0|SCAN TABLE ZCDTMOPHOTOV2INDEX AS t0 0|1|1|SEARCH TABLE ZCDTMOPHOTOMETAINDEX AS t1 USING INTEGER PRIMARY KEY (rowid=?) 0|0|0|<span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> TEMP B-TREE <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span></code> </pre><br>  Bottom line: this model does not suit us. <br><br><h1>  Normalization </h1>  We continue our experiments.  We made sure that strict data normalization is not always good for Core Data.  The results of the previous model were far from expected.  Let's try to fix it.  To do this, it is enough to duplicate our <i>date</i> and <i>likes</i> fields in the essence of the photo (without forgetting to add a composite index and a separate one for the date), thus avoiding the need for LEFT OUTER JOIN in our queries.  The decision to leave or delete these fields in the essence of the metadata must be made depending on the situation.  For example, if in addition you want to make a request with a rating of countries on the amount of likes of photos taken in them, then when removing these fields, we will again be faced with the need to make a JOIN, but in the other direction of communication.  In our test, the properties of the entities are duplicated, and this is a completely normal occurrence for Core Data: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/309/a3f/775309a3f587ad604176aac8e15d700d.png" alt="Third model"><br><br>  Let's look at the test results: <br><table><tbody><tr><th>  Operations \ Model Type </th><td>  Model V3 </td><td>  Diff (V1 + composite index) </td><td>  Diff (V1) </td></tr><tr><th>  Insert (10000 objects) </th><td>  3.861 </td><td>  + 86% </td><td>  + 98% </td></tr><tr><th>  NSFetchRequest (1 sort) </th><td>  0.115 </td><td>  -32% </td><td>  -77% </td></tr><tr><th>  NSFetchedResultsController (2 sorts) </th><td>  0.283 </td><td>  -15% </td><td>  -61% </td></tr><tr><th>  NSFetchedResultsController (2 sorts + batchSize) </th><td>  0.181 </td><td>  -one% </td><td>  -40% </td></tr></tbody></table><br>  The experiment was a success, we have accelerated the read operations, which are the main ones in the application up to 40% compared to the fastest flat model and up to 80% with the initial version without indices. <br><br><h1>  Results and fine points </h1><ul><li>  Use indexes and use them only for fields that are relevant to your queries.  Do not forget about the existence of composite indices </li><li>  Experiment with different schemes, test their performance.  It's very simple, because Xcode 6 has built-in support for perfomance tests. </li><li>  Do not forget to check how CoreData framework generates SQL queries using logs.  With <i>EXPLAIN QUERY PLAN</i> , learn how sqlite digests your SQL query. </li><li>  When accessing the <code>NSFetchedResultsController</code> results <code>NSFetchedResultsController</code> use only the access method provided by the controller itself: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *object = [controller objectAtIndexPath:indexPath];</code> </pre><br>  You should not access the <code>fetchedObjects</code> array or the <i>NSFetchedResultsSectionInfo</i> protocol to an array of section objects: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> *object = [[controller fetchedObjects] objectAtIndex:index]; <span class="hljs-comment"><span class="hljs-comment">//  NSArray *objects = [[[controller sections] objectAtIndex:sectionIndex] objects]; NSManagedObject *object = [objects objectAtIndex:index];</span></span></code> </pre><br>  Why, you ask?  If you use <code>fetchBatchSize</code> size N, then after the request is completed, the controller will load only the first N objects into memory (or the first section if the block size is larger than the section size!).  As soon as you request the first fault-object outside the loaded block or an object from another section, the controller will make a <u>full</u> pass through the results of your request, that is, it will perform <i>N = number of objects / fetchBatchSize</i> requests to the repository.  This operation is about 3-4 times slower than a simple request for all items.  When using access via <code>objectAtIndexPath</code> this behavior is not observed.  I would be very happy if there is someone among the readers who can shed light on such strange behavior that is not described in the documentation. </li><li>  Normalization is not always the best solution for Core Data </li><li>  If from the scene in Cupertino you are told that the new iPhone is 2 times faster than the previous one ... you need to believe this, in Core Data operations these statements are confirmed almost completely.  I prepared a summary file with the results, where you will also find tests iPhone 5S.  In almost all the results, it is 2 times faster than its predecessor.  Accordingly, on the more current iPhone 4S, these results will be about 2 times slower, not to mention even older devices.  <a href="https://cloud.mail.ru/public/6f25710d0d0c%252FCDT.xlsx">Here</a> you will find a summary table of results, which also contains the results of the new iPhone 6. </li></ul><br><br>  As you can replace, Core Data is not only a simple tool for working with data, but also a powerful tool in capable hands.  Explore and experiment, and I hope that the article has opened something new for you and pushed you towards a more efficient use of Core Data in your projects.  Good luck! </div><p>Source: <a href="https://habr.com/ru/post/235941/">https://habr.com/ru/post/235941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../235921/index.html">bb-mobile Techno 9.7 3G - iPad Air Clone Budget</a></li>
<li><a href="../235927/index.html">Internet in Belarus</a></li>
<li><a href="../235931/index.html">Top 10 Things We Understand When Working With Foundation for Apps</a></li>
<li><a href="../235937/index.html">Scrawl - a screenshot of websites and security of web interfaces of SIP devices</a></li>
<li><a href="../235939/index.html">The Sims 4 developers joked about "pirates"</a></li>
<li><a href="../235943/index.html">How I created the open source page scroll plugin One Page Scroll</a></li>
<li><a href="../235945/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ124 (September 1 - 7, 2014)</a></li>
<li><a href="../235947/index.html">Happy Tester Day</a></li>
<li><a href="../235951/index.html">Google Glass Explorer Edition now sold via Google Play</a></li>
<li><a href="../235953/index.html">What is marketing, and why these people try to deceive you in most cases - educational program</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>