<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intel¬Æ RealSense ‚Ñ¢. Work with raw data streams</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Developers who are interested in the features that are available to implement management without the help of controllers in their applications, it is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intel¬Æ RealSense ‚Ñ¢. Work with raw data streams</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ef4/b5c/2e3/ef4b5c2e31f74a8c8bbaa1b8035bb08c.jpg"><br>  Developers who are interested in the features that are available to implement management without the help of controllers in their applications, it is enough to familiarize themselves with the Intel RealSense SDK, related examples and resources on the Internet.  If you ‚Äúimmerse yourself‚Äù in this solution, you will find a wide range of functions that allow you to create completely new, great interfaces using new technologies. <br>  In this article we will talk about streams of various raw data, about access to them and how to use them.  Through direct access to the raw data, we will not only be able to work with metadata, but also get the fastest way to determine what the user is doing in the real world. <br><a name="habracut"></a><br>  In this article, we used the Bell Cliff 3D camera as an Intel RealSense camera, which displays several data streams, from traditional RGB color images to depth data and images from an infrared camera.  Each of these streams behaves in its own way, but we'll talk about this in more detail below.  After reading this article, you will learn what streams are available and when to work with them. <br>  To understand the presented materials, it is useful (but not necessary) to know C ++ to get acquainted with code examples and to have a general idea of ‚Äã‚Äãthe Intel RealSense technology (or its earlier version - Intel Perceptual Computing SDK). <br><br><h2>  <font color="#0071c5">Why is it important</font> </h2><br>  If you are only interested in the implementation of a simple gesture or face recognition system, then you will find everything you need in the modules of the Intel RealSense SDK algorithms, and you can not take care of the raw data streams.  The problem will arise when you need the functionality that is missing in the modules of the algorithms in the SDK.  The application will not work without an alternative solution. <br>  So, the first question: ‚ÄúWhat does your application need and is it possible to fulfill these requirements using the modules of the Intel RealSense SDK algorithms?‚Äù.  If you need a pointer on the screen that tracks the movement of your hand, this may be enough for the hand or finger tracking module.  To quickly determine if the available functionality matches your needs, you can use the examples in the SDK.  If this is not enough, then you can begin planning to use the raw data stream. <br><br>  For example, 2D gesture detection is currently supported.  But what if you need to detect gestures on a set of three-dimensional hands and determine additional information on the movement of the user's hands?  What if you need to record a high-speed stream of gestures and save them as a sequence, not as a snapshot?  It will be necessary to bypass the finger and hand recognition system, which forms the computational load, and introduce a technique for dynamic telemetry coding in real time.  In general, you may encounter insufficient functionality; a more direct solution may be required for a particular software problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another example: suppose you create an application that detects and recognizes a sign language and converts it into text for transmission to a newsgroup.  The current Intel RealSense SDK functionality supports hand and finger tracking (but only in single gestures) and does not have targeted support for sign language recognition.  The only solution in such cases is to develop your own gesture recognition system, which will be able to quickly convert gestures into a sequence of the positions of fingers and hands, and with the help of a template system will recognize characters and restore text.  The only currently available way to achieve this result is access to the raw data stream using high-speed recording and converting the value on the fly. <br><br>  The ability to write code to fill the gap between existing and desired functionality is extremely important, and it is provided in the Intel RealSense SDK. <br>  This technology is still relatively new, and developers are still exploring its capabilities.  Access to raw data streams expands possible actions, and from such improvements new solutions are born. <br><br><h2>  <font color="#0071c5">Streams</font> </h2><br>  The best way to learn about data streams is to familiarize yourself with them.  To do this, run the Raw Streams example in the bin folder of the installed Intel Realsense SDK instance. <br><br>  <i>\ Intel \ RSSDK \ bin \ win32 \ raw_streams.exe</i> <br><br>  The example is provided with full source code and a project that will be very useful to us.  If you start the executable file and press the START button when starting the application, you will get an RGB color stream, as shown in Figure.  one. <br><br><img src="https://habrastorage.org/files/a44/85b/260/a4485b2606904155adc895644f48345c.jpg"><br>  <i>Figure 1. Typical RGB color stream</i> <br><br>  Waving a pen to yourself, press the STOP button, open the Depth menu and select 640x480x60.  Press the START button again. <br><br><img src="https://habrastorage.org/files/a77/716/209/a77716209c174725968eb02023730356.jpg"><br>  <i>Figure 2. Filtered depth data stream from an Intel RealSense 3D camera.</i> <br><br>  As seen in fig.  2, this image is significantly different from the RGB color stream.  You see a black and white image representing the distance of each pixel to the camera.  Light pixels are closer, and dark pixels are farther;  Black is either considered a background or not recognized reliably. <br>  Moving in front of the camera, you will realize that the camera can make decisions about user actions very quickly.  For example, it is quite clear how to select hands on the stage due to the thick black contour that separates them from the body and head, which are further away from the camera. <br><br><img src="https://habrastorage.org/files/044/fd5/c35/044fd5c35e5c4a618018ce8560729a38.jpg"><br>  <i>Figure 3. Night Vision.</i>  <i>The Intel RealSense 3D Camera delivers a stream of raw video captured in the infrared spectrum</i> <br><br>  The latter type of stream may not be known by previous developers of the Intel Perceptual Computing SDK, but in Figure 2.  3 shows that in the IR menu you can get an image taken in the infrared range from the camera.  This is a stream of raw data, its reading speed far exceeds the update rate of typical monitors. <br><br>  You can initialize all or any of these threads for simultaneous reading as the application needs;  For each stream, you can select the desired resolution and refresh rate.  It is important to note that the final frame rate of incoming flows will depend on the available bandwidth.  For example, if you try to initialize the RGB stream at 60 frames per second, the depth stream at 120 frames per second and the IR stream at 120 frames per second and transmit all these streams with a single synchronization, only the lowest update rate (60 frames per second) will be available , and only if the system handles such work. <br><br>  A sample with raw streams is suitable for getting started, but does not allow combining streams, so it should be used only to familiarize yourself with the types, resolutions and refresh rates available for your camera.  Remember that the Intel RealSense SDK is designed to work with different types of 3D cameras, so sample resolution may not be available on other cameras.  Therefore, you should not rigidly set the resolution in the application code. <br><br><h2>  <font color="#0071c5">Creating streams and accessing data</font> </h2><br>  You can view the full source code of the sample with raw threads by opening the next project in Visual Studio *. <br><br>  <i>\ Intel \ RSSDK \ sample \ raw_streams \ raw_streams_vs20XX.sln</i> <br><br>  The example contains a simple user interface and a full set of parameters, so the code is not very easy to read.  It makes sense to remove the additional code and leave only the necessary lines of code used to create, process and delete the stream received from the camera.  Below is the code that represents a ‚Äúcleaned‚Äù version of the above project, but this code contains all the necessary components, even for the simplest Intel RealSense applications. <br><br>  The first two important functions are the initialization of the Intel RealSense 3D camera and its release upon completion of the program.  This can be seen in the code below, and the details of the called functions will be given below. <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RSInit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ InitCommonControls(); g_session=PXCSession::CreateInstance(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!g_session) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; g_bConnected = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; g_RSThread = CreateThread(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,ThreadProc,g_pGlob-&gt;hWnd,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); Sleep(<span class="hljs-number"><span class="hljs-number">6000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( g_bConnected==<span class="hljs-literal"><span class="hljs-literal">false</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RSClose</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ g_bConnected = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; WaitForSingleObject(g_RSThread,INFINITE); }</code> </pre> <br>  Here we have top-level functions for any application intended for raw data: creating an instance of a session and a thread to execute the code that processes the stream, then freeing the stream with the global flag <i>g_bConnected</i> .  It is recommended to use CPU streams when working with data streams, as this will allow the main application to work at any desired frame rate, regardless of the frame rate of the camera.  In addition, it helps to distribute the load on the CPU among several cores, thereby improving the overall performance of the application. <br><br>  In the above code, we are only interested in the line with the <i>ThreadProc</i> function, which contains all the code responsible for managing threads.  Before proceeding to the details, we note that this source code is not exhaustive, here global declarations and secondary sections have been removed to improve readability.  For information on global announcements, see the original source code for the sample <i>raw_streams</i> project. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DWORD WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThreadProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPVOID arg)</span></span></span><span class="hljs-function"> </span></span>{ CRITICAL_SECTION g_display_cs; InitializeCriticalSection(&amp;g depthdataCS); HWND hwndDlg=(HWND)arg; ~ PopulateDevices(hwndDlg); PXCCapture::DeviceInfo dinfo=GetCheckedDevice(hwndDlg); PXCCapture::Device::StreamProfileSet profiles=GetProfileSet(hwndDlg); StreamSamples((HWND)arg, &amp;dinfo, &amp;profiles, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, g_file ); ReleaseDeviceAndCaptureManager(); g_session-&gt;Release(); DeleteCriticalSection(&amp;g_depthdataCS); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  To work with data flow, it is important to create a ‚Äúmain section‚Äù in the code.  If you do not do this in a multi-threaded environment, then two threads can theoretically write data to the same global variable at the same time, which is undesirable. <br><br>  For those who are not familiar with multithreading, this function is called and does not end until the main thread (which created this thread) for the <i>g_bConnected</i> parameter is set to false.  The main function call here is <i>StreamSamples</i> , and the rest of the code above and below serves only to enter and exit.  The first function of interest to us is <i>PopulateDevices</i> , it is almost identical to the same function in the <i>raw_streams</i> project.  It fills the <i>g_devices</i> list <i>with the</i> names of all available devices.  If you are using an Intel RealSense 3D camera on an ultrabook, then there is a possibility that you will have two devices (the second is a built-in ultrabook camera).  Pay attention to the following lines. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ID_DEVICEX=<span class="hljs-number"><span class="hljs-number">21000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NDEVICES_MAX=<span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>  = ID_DEVICEX; g session-&gt;CreateImpl&lt;PXCCapture&gt;(g_devices[c], &amp;g_ capture); g_device=g_capture-&gt;CreateDevice((c-ID_DEVICEX)%NDEVICES_MAX);</code> </pre><br><br>  The code, constants and global functions are copied from the original code, they can be further reduced.  The most important calls here are <i>Createlmpl</i> and <i>CreateDevice</i> .  As a result, the Intel RealSense 3D camera pointer is now stored in <i>g_device</i> . <br>  If there is a valid pointer to the device, the rest of the initialization code works without problems.  The <i>StreamProfileSet</i> function is a wrapper for this code. <br><pre> <code class="cpp hljs">g_device-&gt;QueryDeviceInfo(&amp;dinfo);</code> </pre><br>  The <i>StreamProfileSet</i> function <i>is</i> responsible for collecting all types of streams and permissions that need to be initialized; it can be simple or complex based on needs.  For compatibility with cameras, it is strongly recommended to list the available permissions and types in the list instead of hard coding fixed settings. <br><pre> <code class="cpp hljs">PXCCapture::Device::<span class="hljs-function"><span class="hljs-function">StreamProfileSet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProfileSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwndDlg)</span></span></span><span class="hljs-function"> </span></span>{ PXCCapture::Device::StreamProfileSet profiles={}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!g_device) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> profiles; PXCCapture::DeviceInf dinfo; g_device-&gt;QueryDeviceInfo(&amp;dinfo); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s=<span class="hljs-number"><span class="hljs-number">0</span></span>, mi=IDXM_DEVICE+l;s&lt;PXCCapture::STREAM_LIMIT;s++) { PXCCapture::StreamType st=PXCCapture::StreamTypeFromIndex(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dinfo.streams&amp;st)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id=ID_STREAMlX+s*NPROFILES_MAX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nprofiles=g_device-&gt;QueryStreamProfileSetl\lum(st); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p=<span class="hljs-number"><span class="hljs-number">0</span></span>;p&lt;nprofiles;p++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( st==PXCCapture::StreamType::STREAM_TYPE_COLOR) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( st==PXCCapture::StreamType::STREAM_TYPE_IR) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( st==PXCCapture::StreamType::STREAM_TYPE_DEPTH &amp;&amp; p==<span class="hljs-number"><span class="hljs-number">2</span></span>) { PXCCapture::Device::StreamProfileSet profilesl={}; g_device-&gt;QueryStreamProfileSet(stj p, Sprofilesl); profiles[st]=profilesl[st]; } } mi++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> profiles; }</code> </pre><br>  <i>QueryStreamProfileSet</i> returns a significant amount of code in which we need the available streams for a single depth stream and return a profile.  You can write your own conditions to search for the necessary streams, whether with a certain resolution or with a certain frame rate, if there are rollback conditions, so that the application can work with the stream of a suitable format. <br>  The final function and the central code block for accessing stream data is <i>StreamSamples</i> .  If you remove the security code and comments, the code will look like this. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StreamSamples</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwndDlg, PXCCapture::DeviceInf *dinfo, PXCCapture::Device::StreamProfileSet *profiles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> synced, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isRecord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPlayback, pxcCHAR *file)</span></span></span><span class="hljs-function"> </span></span>{ PXCSenseManager *pp=g_session-&gt;CreateSenseManager(); pp-&gt;QueryCaptureManager()-&gt;FilterByDeviceInfo(dinfo); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (PXCCapture::StreamType st=PXCCapture::STREAM_TYPE_COLOR;st!=PXCCapture::STREAM_TYPE_ANY;st++) { PXCCapture::Device::StreamProfile &amp;profile=(*profiles)[st]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([profile.imagelnfo.format) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pp-&gt;EnableStream(st,profile.imagelnfo.width, profile.imagelnfo.height, profile.frameRate.max); } pp-&gt;QueryCaptureManager()-&gt;FilterByStreamProfiles(profiles); <span class="hljs-function"><span class="hljs-function">MyHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hwndDlg)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pp-&gt;Init(&amp;handler)&gt;=PXC_STATUS_NO_ERROR) { pp-&gt;QueryCaptUreManager()-&gt;QueryDevice()-&gt;SetMirrorMode(PXCCapture: :Device: :MirrorMode: :MIRROR_MODE_DISABLED); g_bConnected = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nframes=<span class="hljs-number"><span class="hljs-number">0</span></span>;g_bConnected==<span class="hljs-literal"><span class="hljs-literal">true</span></span>;nframes++) { pxcStatus sts2=pp-&gt;AcquireFrame(synced); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sts2&lt;PXC_STATUS_N0_ERR0R &amp;&amp; sts2!=PXC_STATUS_DEVICE_LOST) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sts&gt;=PXC_STATUS_NO_ERROR) { PXCCapture::Sample *sample = (PXCCapture::Sample*)pp-&gt;QuerySample(); <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> invalids[l]; invalids[<span class="hljs-number"><span class="hljs-number">0</span></span>] = pp-&gt;QueryCaptureManager()-&gt;QueryDevice()-&gt;QueryDepthSaturationValue(); invalids [<span class="hljs-number"><span class="hljs-number">1</span></span>] = pp-&gt;QueryCaptureManager()-&gt;QueryDevice()-&gt;QueryDepthl_owConfidenceValue(); PXCImage::ImageInfo dinfo=sample-&gt;depth-&gt;QueryInfo(); PXCImage::ImageData ddata; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sample-&gt;depth-&gt;AcquireAccess( PXCImage::ACCESS_READ, PXCImage::PIXEL_FORMAT_DEPTH, &amp;ddata)&gt;=PXC_STATUS_NO_ERROR) { EnterCriticalSection(&amp;g_depthdataCS); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> ( g_depthdata, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(g_depthdata)); <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *dpixels=(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>*)ddata.planes[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dpitch = ddata.pitches[<span class="hljs-number"><span class="hljs-number">0</span></span>]/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>  = <span class="hljs-number"><span class="hljs-number">0</span></span>;  &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dinf.height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dinfo.width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> d = dpixels[y*dpitch+x]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == invalids[<span class="hljs-number"><span class="hljs-number">0</span></span>] || d == invalids[l]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; g_depthdata[x][y] = d; } } LeaveCriticalSection(&amp;g_depthdataCS); g_bDepthdatafilled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } sample-&gt;depth-&gt;ReleaseAccess(&amp;ddata); } pp-&gt;ReleaseFrame(); } } pp-&gt;Close(); pp-&gt;Release(); }</code> </pre><br>  At first glance, there is a bit of code here, but if you look at it, you will see that these are just a few configuration calls, a conditional loop and a final purge before returning to the ThreadProc function that caused this code.  The main variable used is called pp, which is the pointer to the Intel RealSense SDK Manager for our main actions.  Note.  As mentioned above, in order to improve the readability of the code, error tracking has been removed from it, but in practice you should not create code that assumes that all calls to the Intel RealSense SDK are successful. <br>  The first code snippet, which will include the threads of interest to us, looks like this. <br><pre> <code class="cpp hljs">pp-&gt;EnableStream(st,profile.imagelnfo.width, profile.imagelnfo.height, profile.frameRate.max);</code> </pre><br>  This simple request includes a stream type with a specific resolution and frame rate and instructs the camera to get ready to send us this raw data.  The next important line activates the dispatcher so that it can begin the process of getting the data. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MyHandler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hwndDlg)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pp-&gt;Init(&amp;handler)&gt;=PXC_STATUS_NO_ERROR)</code> </pre><br>  The <i>MyHandler</i> class is defined in the original <i>raw_streams</i> project and comes from the <i>PXCSenseManager: Handler</i> class.  If successful, you will find out that the camera is on and transmits the data stream. <br>  Now we need to start a conditional cycle, which will work until any external influence changes the condition of the cycle.  In this loop, we will receive the stream data one frame at a time.  To do this, use the <i>AcquireFrame</i> command. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nframes=<span class="hljs-number"><span class="hljs-number">0</span></span>;g_bConnected==<span class="hljs-literal"><span class="hljs-literal">true</span></span>;nframes++) { pxcStatus sts2=pp-&gt;AcquireFrame(synced);</code> </pre><br>  As long as <i>g_bConnected</i> is true, we will do it as quickly as possible in a separate thread created for this purpose.  To get the actual data you need a few more lines of code. <br><pre> <code class="cpp hljs">PXCCapture::Sample *sample = (PXCCapture::Sample*)pp-&gt;QuerySample(); <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> invalids[l]; invalids[<span class="hljs-number"><span class="hljs-number">0</span></span>] = pp-&gt;QueryCaptureManager()-&gt;QueryDevice()-&gt;QueryDepthSaturationValue(); invalids [<span class="hljs-number"><span class="hljs-number">1</span></span>] = pp-&gt;QueryCaptureManager()-&gt;QueryDevice()-&gt;QueryDepthl_owConfidenceValue(); PXCImage::ImageInfo dinfo=sample-&gt;depth-&gt;QueryInfo(); PXCImage::ImageData ddata; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sample-&gt;depth-&gt;AcquireAccess( PXCImage::ACCESS_READ, PXCImage::PIXEL_FORMAT_DEPTH, &amp;ddata)&gt;=PXC_STATUS_NO_ERROR)</code> </pre><br>  The first command receives a sample pointer from the dispatcher and uses it to obtain a pointer to the actual data in memory using the last <i>AcquireAccess command</i> .  The code performs two queries to ask the dispatcher what values ‚Äã‚Äãcorrespond to a ‚Äúsaturated‚Äù pixel and an ‚Äúunreliable‚Äù pixel.  Both of these conditions may occur when receiving depth data from the camera.  They should be ignored when interpreting the returned data.  The main result of this code: the <i>ddata</i> data structure is now filled with information that will allow us to directly access the depth data (in this example).  By changing the corresponding parameters, you can access the data of the <i>COLOR</i> and <i>IR</i> streams, if they are enabled. <br>  This completes the code snippet related to the Intel RealSense SDK (from the first initialization call to getting the pointer to the stream data).  The rest of the code will be somewhat more familiar for developers with experience in creating image processing programs. <br><pre> <code class="cpp hljs">EnterCriticalSection(&amp;g_depthdataCS); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> ( g_depthdata, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(g_depthdata) ); <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *dpixels=(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>*)ddata.planes[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dpitch = ddata.pitches[<span class="hljs-number"><span class="hljs-number">0</span></span>]/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>  = <span class="hljs-number"><span class="hljs-number">0</span></span>;  &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dinf.height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dinfo.width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> d = dpixels[y*dpitch+x]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == invalids[<span class="hljs-number"><span class="hljs-number">0</span></span>] || d == invalids[l]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; g_depthdata[x][y] = d; } } LeaveCriticalSection(&amp;g_depthdataCS);</code> </pre><br>  Notice that the important session object created earlier is used to block our thread so that no other thread can access our global variables.  This is done so that you can write a global array and be sure that code from another part of the application will not affect the work.  If you follow the nested loops, you will see that after blocking the stream, we clear the global array <i>g_depthdata</i> and fill it with values ‚Äã‚Äãfrom the above-mentioned <i>ddata</i> structure, which contains a pointer to the depth data.  In nested loops, we also compare the value of the depth pixels with two invalid values ‚Äã‚Äãthat we set earlier using the <i>QueryDepthSaturationValue</i> and <i>QueryDepthLowConf idenceValue calls</i> . <br><br>  After transferring data to a global array, the CPU thread can get the next frame from the stream data, and the main CPU thread can begin to analyze this data and make decisions.  You can even create a new workflow to perform this analysis, which will allow the application to work in three threads and more efficiently use the resources of the multi-core architecture. <br><br><h2>  <font color="#0071c5">What to do with stream data</font> </h2><br>  So, now you know how to get data stream from an Intel RealSense 3D camera, and you are probably wondering what to do with this data.  Of course, you can simply display this data on the screen and admire the image, but soon you will need to convert this data into useful information and process it in your application. <br><br>  As there are no two identical snowflakes, all implementations of raw data streams will differ, but there are still several general approaches that help to organize data analysis.  To reduce the amount of new code, we will use the above code as a template for the examples offered below. <br><br><h4>  Find the nearest point </h4><br>  It is recommended to find the closest point of the object in front of the camera.  In doing so, you just transferred the depth data from the data stream to the global array in the CPU stream.  You can create a nested loop to check each value in the array. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">short</span></span> bestvalue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bestx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> besty = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>  = <span class="hljs-number"><span class="hljs-number">0</span></span>;  &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dinfo.height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dinfo.width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> thisvalue = g_depthdata[x][y]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( thisvalue &gt; bestvalue ) { bestvalue = thisvalue; bestx = x; besty = y; } } }</code> </pre><br>  Each time a closer value is found, it replaces the current best value, and the coordinates along the X and Y axes are recorded. By the time the cycle bypasses each pixel in the depth data, the final <i>BESTX</i> and <i>BESTY variables</i> will store the coordinates of the depth data for the nearest point camera. <br><br><h4>  Ignore objects in the background. </h4><br>  It may be necessary to identify the shapes of the foreground objects, but the application should not confuse them with objects in the background, for example, with a seated user or people passing by. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">short</span></span> newshape[dinfo.height][dinfo.width]; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(newshape,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(newshape)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>  = <span class="hljs-number"><span class="hljs-number">0</span></span>;  &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dinfo.height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dinfo.width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> thisvalue = g_depthdata[x][y]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( thisvalue&gt;<span class="hljs-number"><span class="hljs-number">32000</span></span> &amp;&amp; thisvalue&lt;<span class="hljs-number"><span class="hljs-number">48000</span></span> ) { newshape[x][y] = thisvalue; } } }</code> </pre><br>  If you add a condition when reading each pixel and transfer only those pixels that are within a certain range, then you can extract objects from the depth data and transfer them to the second array for further processing. <br><br><h2>  <font color="#0071c5">Hints and Tips</font> </h2><br>  <b>What to do</b> <br><ul><li>  If you are working with examples for the first time and using an ultrabook with a built-in camera, then the application can use this built-in camera instead of the Intel RealSense camera.  Ensure that the Intel RealSense camera is properly connected and that your application is using an Intel RealSense 3D camera device.  For more information on how to find a list of devices, see the links to <i>g_devices</i> in this article. </li><li>  Always try to use multi-thread computing in an Intel RealSense application: in this case, the application will not be tied to the frame rate of the stream of Intel RealSense 3D cameras, and on multi-core systems, higher performance will be achieved. </li></ul><br>  <b>What not to do</b> <br><ul><li>  Do not hard-code the device or profile parameters when initializing streams, as future Intel RealSense 3D cameras may not support the parameters you specified.  You should always list the available devices and profiles and use the search terms to find the right one. </li><li>  Avoid unnecessary data transfer to secondary arrays, since each such cycle consumes a lot of CPU and memory resources.  Keep your data analysis as close as possible to the original data read operation. </li></ul><br><br><h2>  <font color="#0071c5">Conclusion</font> </h2><br>  Knowing how to get the raw data stream from an Intel RealSense 3D camera will help expand the capabilities of this technology and create modern solutions.  We have already seen great hands-free applications created by the first developers in this area, but this is only a small part of all the possibilities of new technologies. <br>  Many users still treat computers as devices that should be actively influenced so that they work, but now computers have got a ‚Äúvision‚Äù and can watch all of our movements.  Do not peep, please note, but just watch, so that at the right moment to come to the rescue.  According to the saying in the land of the blind, the one-eyed will become king.  Is it wrong that we live in a world inhabited by "blind" computers?  Imagine what kind of revolution will occur if one of them ‚Äúbegins to see light‚Äù in the not too distant future?  As developers, we are the architects of this revolution, together we can create a completely new paradigm in which computers see their operators and try to help them. <br><br>  <a href="http://www.intel.ru/content/www/ru/ru/architecture-and-technology/realsense-overview.html">Learn more about RealSense on the Intel website.</a> <br>  <a href="https://software.intel.com/ru-ru/realsense/home">All about RealSense for Developers</a> <br>  <a href="https://software.intel.com/ru-ru/intel-realsense-sdk">Download RealSense SDK</a> <br>  <a href="https://software.intel.com/ru-ru/Forums/realsense">RealSense Developer Forum</a> </div><p>Source: <a href="https://habr.com/ru/post/253361/">https://habr.com/ru/post/253361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253349/index.html">Introduction to ASP.NET 5</a></li>
<li><a href="../253351/index.html">An example of the implementation of calls to Asterisk CLI in PHP. Asterisk response structuring</a></li>
<li><a href="../253353/index.html">CompTIA certifications for IT professionals. Part 4 of 7. CompTIA Security +</a></li>
<li><a href="../253357/index.html">We program robots - free robosimulator V-REP. The first steps</a></li>
<li><a href="../253359/index.html">Handbook of console methods in JS</a></li>
<li><a href="../253365/index.html">Working with MS SQL Database with Go Tools for Beginners</a></li>
<li><a href="../253367/index.html">Centralized logging in MongoDB</a></li>
<li><a href="../253371/index.html">Price drop came: servers in the Netherlands at the premium data center are several times cheaper, 2 x Intel Quad Core E5504 / 16GB DDR3 / 12x1TB SATA / 1Gbps 100TB for $ 99.99 just now</a></li>
<li><a href="../253373/index.html">Building an Ethernet network for IP video surveillance</a></li>
<li><a href="../253379/index.html">Simple ticket system for customer support: open beta and launch history</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>