<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SObjectizer: the problem of overloading agents and means of dealing with it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles we have mentioned the problem of overloading agents several times. What it is? What does it threaten with? How to deal with it? W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SObjectizer: the problem of overloading agents and means of dealing with it</h1><div class="post__text post__text-html js-mediator-article"><p>  In previous articles we have mentioned the problem of overloading agents several times.  What it is?  What does it threaten with?  How to deal with it?  We will talk about all this today. </p><br><p>  The problem of overloading agents arises when some agent sends more messages than it manages to process.  As a result, message queues are constantly increasing in size.  Growing queues consume memory.  Memory consumption slows down the application.  Due to the slowdown, the problem agent starts processing messages longer, which increases the growth rate of message queues.  Which contributes to faster memory consumption.  Which leads to even greater slowdown of the application.  That leads to even slower work of the problem agent ... As a result, the application slowly and sadly degrades to complete inoperability. </p><br><p>  The problem is aggravated by the fact that the interaction through asynchronous messages and the use of the fire-and-forget approach directly provoke overloads (fire-and-forget is when agent A receives the incoming message M1, processes it, and sends the outgoing message M2 to agent B not caring about the consequences). </p><a name="habracut"></a><br><p>  Indeed, when send is responsible only for putting a message in the receiving agent's queue, the sender does not block on the send, even if the recipient does not cope with its message flow.  This creates the prerequisites for the message senders not to care about whether the recipient is able to cope with the load. </p><br><p>  Unfortunately, there is no universal recipe for dealing with overloads, suitable for all situations.  Somewhere you can just lose new messages addressed to an overloaded agent.  Somewhere this is unacceptable, but you can throw away the oldest messages that have been queued for too long and have ceased to be relevant.  Somewhere you can‚Äôt lose messages at all, but you can switch to another way of handling messages when overloaded.  For example, if an agent is responsible for resizing photos to be displayed on a Web page, then when overloaded, the agent may switch to a coarser resizing algorithm: the quality of photos will fall, but the queue of photos for processing will be resolved faster. </p><br><p>  Therefore, a good tool for protection against overloads should be sharpened for a specific task.  Because of this, for a long time in SObjectizer there were no ready-made mechanisms available to the user out of the box.  The user solved his problems himself. </p><br><p>  One of the most practical ways to protect against overload, in our experience, was an approach using two agents: collector and performer.  Agent-collector collects incoming messages to be processed in some suitable container.  The performer agent processes the messages that the collector agent has collected. </p><br><p><img src="https://habrastorage.org/files/326/30b/390/32630b3906514d50ab252ac3c84095a6.jpg"></p><br><p>  The trick is that the collector and performer agents are bound to different working contexts.  Therefore, if the performer agent starts to slow down, this does not affect the work of the collector.  As a rule, the collector agent processes its events very quickly: processing usually consists in saving a new message to a separate queue.  If this individual queue is full, then the collector agent can immediately return a negative response to a new message.  Or throw some old message from the queue.  Also, the collector agent may periodically check the time the messages stay in this particular queue: if a message has been waiting for processing for too long and has ceased to be up to date, then the collector agent throws it out of the queue (possibly sending some negative response to the initiator of this message). </p><br><p>  The performer agent, as a rule, processes its incoming messages much longer than the collector agent, which is logical, since  The responsibility for the actual applied work lies with the performer.  The performer agent itself requests the next batch of messages from the collector agent for processing. </p><br><p>  In the simplest case, the performer agent completes the processing of the current message and sends to the collector agent a request to issue the next message to be processed.  After receiving this request, the agent-collector issues the first message from its turn to the performer agent. </p><br><p>  The composition of SObjectizer includes several examples demonstrating various variations on the topic of collectors and performers.  Descriptions of these examples can be found in the project‚Äôs Wiki ( <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520By%2520Example%2520Work%2520Generation/"># 1</a> , <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520By%2520Example%2520Collector%2520and%2520Performer%2520Pair/"># 2</a> , <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520By%2520Example%2520Collector%2520and%2520Many%2520Performers/"># 3</a> , <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520By%2520Example%2520Simple%2520Message%2520Deadline/"># 4</a> ). </p><br><p>  As we gained experience using SObjectizer and based on the results of numerous discussions, we came to the conclusion that in spite of the opportunity to make with our own hands protection schemes against overloads of varying degrees of complexity and efficiency, in SObjectizer itself we would also like to have some kind of basic mechanism.  Let not advanced, but available directly "out of the box", which is especially in demand with rapid prototyping. </p><br><p>  Limits for messages (so-called <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520Limits/">message limits</a> ) have become such a mechanism.  The agent can specify how many instances of messages of a particular type it permits to save in the message queue.  And what to do with the "extra" copies.  Exceeding the specified limit is an overload and the SObjectizer responds to it in one of the following ways: </p><br><ul><li>  throws out a new message as if it was not there; </li><li>  forwards the message to another mbox.  This reaction is performed under the assumption that another recipient will be able to process the extra message; </li><li>  transform an extra message into another type of message and send a new message to some mbox.  This response may allow, for example, to immediately send a negative response to the sender of the message; </li><li>  terminates the application by calling std :: abort ().  This option is suitable for cases where the load exceeds all conceivable limits and there is almost no chance of recovery, therefore it is better to stop and restart than continue to accumulate the message in the queues. </li></ul><br><p>  Let's take a look at how message limits can help cope with overloads (sample source can be found <a href="https://bitbucket.org/sobjectizerteam/habrhabr_article_overload">in this repository</a> ). </p><br><p>  Suppose we need to process requests for resizing images to a given size.  If there are more than 10 such requests, then we need to process new requests using a different algorithm, faster, but less accurate.  If this does not help either, then we will log the extra requests in a special way and send an empty picture of the resulting size to the initiator. </p><br><p>  Create three agents.  The first agent will perform normal image processing.  Unnecessary images that he is unable to quickly resolve will be sent to the second agent via message_limit. </p><br><pre><code class="hljs markdown">//  ,     . class accurate<span class="hljs-emphasis"><span class="hljs-emphasis">_resizer final : public agent_</span></span>t { public : accurate<span class="hljs-emphasis"><span class="hljs-emphasis">_resizer( context_</span></span>t ctx, mbox<span class="hljs-emphasis"><span class="hljs-emphasis">_t overload_</span></span>mbox ) //          // .       // ,      . : agent<span class="hljs-emphasis"><span class="hljs-emphasis">_t( ctx //     resize_</span></span>request //       // . + limit<span class="hljs-emphasis"><span class="hljs-emphasis">_then_</span></span>redirect<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resize_request</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span>( //    10 ... 10, //     mbox. [<span class="hljs-string"><span class="hljs-string">overload_mbox</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) { return overload_mbox; } ) ) {...} ... };</code> </pre> <br><p>  The second agent performs faster, but more crude image processing.  Therefore, his limit on the number of messages in the queue will be higher.  Unnecessary messages redirect to a third agent: </p><br><pre> <code class="hljs markdown">//  ,     . class inaccurate<span class="hljs-emphasis"><span class="hljs-emphasis">_resizer final : public agent_</span></span>t { public : inaccurate<span class="hljs-emphasis"><span class="hljs-emphasis">_resizer( context_</span></span>t ctx, mbox<span class="hljs-emphasis"><span class="hljs-emphasis">_t overload_</span></span>mbox ) : agent<span class="hljs-emphasis"><span class="hljs-emphasis">_t( ctx + limit_</span></span>then<span class="hljs-emphasis"><span class="hljs-emphasis">_redirect&lt; resize_</span></span>request &gt;( //    20 ... 20, //     mbox. [<span class="hljs-string"><span class="hljs-string">overload_mbox</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) { return overload_mbox; } ) ) {...} ... };</code> </pre> <br><p>  The third agent instead of resizing generates an empty picture.  Those.  when everything is bad and the load turned out to be very high, it is better to leave empty places instead of pictures than to fall into complete stupor.  However, the generation of empty images does not happen instantly, so you can expect that the third agent will have some reasonable limit for pending requests.  But if this limit is exceeded, then, perhaps, it is better to bang the entire application through std :: abort, so that after the restart it can start work again.  It is possible that the brakes with the processing of the request flow are caused by some incorrect behavior of the application, and the restart will allow you to start anew from scratch.  Therefore, the third agent stupidly forces to call std :: abort when the limit is exceeded.  Primitive, but extremely effective: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  ,      , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        . class empty_image_maker final : public agent_t { public : empty_image_maker( context_t ctx ) : agent_t( ctx /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    50- . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -  ,  -  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ . + limit_then_abort&lt; resize_request &gt;( 50 ) ) {...} ... };</span></span></code> </pre><br><p>  And all together, agents can be created, for example, in the following way: </p><br><pre> <code class="hljs markdown">//        . //  mbox,       . mbox<span class="hljs-emphasis"><span class="hljs-emphasis">_t make_</span></span>resizers( environment<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; env ) { mbox_</span></span>t resizer<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox; //        (..   //   ),      // active_</span></span>obj. env.introduce<span class="hljs-emphasis"><span class="hljs-emphasis">_coop( disp::active_</span></span>obj::create<span class="hljs-emphasis"><span class="hljs-emphasis">_private_</span></span>disp( env )-&gt;binder(), [<span class="hljs-string"><span class="hljs-string">&amp;resizer_mbox</span></span>](<span class="hljs-link"><span class="hljs-link"> coop_t &amp; coop </span></span>) { //     , ..    // mbox-     "" . auto third = coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt; empty_</span></span>image<span class="hljs-emphasis"><span class="hljs-emphasis">_maker &gt;(); auto second = coop.make_</span></span>agent<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">inaccurate_resizer</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span>( third-&gt;so<span class="hljs-emphasis"><span class="hljs-emphasis">_direct_</span></span>mbox() ); auto first = coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt; accurate_</span></span>resizer &gt;( second-&gt;so<span class="hljs-emphasis"><span class="hljs-emphasis">_direct_</span></span>mbox() ); //   ,       //   .        //  . resizer<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox = first-&gt;so_</span></span>direct<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox(); } ); return resizer_</span></span>mbox; }</code> </pre> <br><p>  In general, the message limits mechanism makes it possible in simple cases to do without developing custom collectors and performers.  Although they cannot completely replace them (for example, the message limits do not allow to automatically discard the oldest messages from the queue - this is due to the organization of queues of requests from dispatchers). </p><br><p>  So, we will try to summarize briefly.  If your application consists of agents that interact exclusively through asynchronous messages, and you like to use the fire-and-forget approach, then overloading agents is almost guaranteed.  Ideally, to protect your agents, you should use something like pairs of collector-performer agents whose behavior is tailored to your task.  But, if you do not need the ideal solution, but rather ‚Äúcheap and cheerful‚Äù, then limits will come to the rescue for messages that SObjectizer provides out of the box. </p><br><p>  Ps.  Overloading is possible not only for the actors / agents within the Actor Model, but also when using CSP channels.  Therefore, in SObjectizer, analogs of CSP-shny channels, <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520chains/">message chains</a> , also contain means of protection against overload, somewhat similar to message limits. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/310818/">https://habr.com/ru/post/310818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310808/index.html">Quality content for the site: what is it?</a></li>
<li><a href="../310810/index.html">Crysis worldwide via RDP protocol</a></li>
<li><a href="../310812/index.html">Microsoft, UN and EmerCoin: using blockchain technology in real projects</a></li>
<li><a href="../310814/index.html">Launch ReactOS on a secure military laptop from the M1 Abrams tank kit</a></li>
<li><a href="../310816/index.html">The first project on FPGA Altera and USB-Blaster connection in Linux</a></li>
<li><a href="../310820/index.html">How to use the Mongoose schema to generate graphQL types</a></li>
<li><a href="../310824/index.html">Principles of reactive programming using a simple RSS aggregator using ReactiveX for Python</a></li>
<li><a href="../310826/index.html">Unit testing in complex applications</a></li>
<li><a href="../310828/index.html">SMS sending using jSMPP methods UDH, SAR, Payload</a></li>
<li><a href="../310830/index.html">How to get the most out of code minification</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>