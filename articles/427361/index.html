<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features of window filtering on FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! In this article we will discuss one important part of digital signal processing - window filtering of signals, in particular on FPGAs. The arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features of window filtering on FPGA</h1><div class="post__text post__text-html js-mediator-article">  Hello!  In this article we will discuss one important part of digital signal processing - window filtering of signals, in particular on FPGAs.  The article will show how to design classic windows of standard length and ‚Äúlong‚Äù windows from 64K to 16M + samples.  The main development language is VHDL, the element base is modern FPGA Xilinx crystals of the last families: these are Ultrascale, Ultrascale +, 7-series.  The article will show the implementation of CORDIC - the base kernel for the configuration of window functions of any duration, as well as the basic window functions.  The article describes a design method using high-level C / C ++ languages ‚Äã‚Äãin Vivado HLS.  As usual, at the end of the article you will find a link to the source code of the project. <br><br>  CDRD: a typical signal flow pattern through DSP nodes for spectrum analysis tasks. <br><br><img src="https://habrastorage.org/webt/hq/5j/_l/hq5j_lnsfr_k8oaex-cesewdeyi.png"><br><a name="habracut"></a><br><h3>  Introduction </h3><br>  Many people know from the ‚ÄúDigital Signal Processing‚Äù course that for an infinite time signal of a sinusoidal form, its spectrum is a delta function at the signal frequency.  In practice, the spectrum of a real time-limited harmonic signal is equivalent to the <b>~ sin (x) / x</b> function, and the width of the main lobe depends on the duration of the signal analysis interval <b>T.</b>  The time limit is nothing more than multiplying a signal by a rectangular envelope.  From the course of DSP, it is known that multiplication of signals in the time domain is a convolution of their spectra in the frequency domain (and vice versa), therefore the spectrum of the limited rectangular envelope of the harmonic signal is equivalent to ~ sinc (x).  This is also due to the fact that we cannot integrate the signal on an infinite time interval, and the Fourier transform in discrete form, expressed in a finite sum, is limited in the number of samples.  As a rule, the FFT length in modern FPGA digital processing devices takes <b>NFFT</b> values ‚Äã‚Äãfrom 8 to several million points.  In other words, the spectrum of the input signal is calculated on the interval <b>T</b> , which in many cases is equal to <b>NFFT</b> .  By limiting the signal on the interval <b>T</b> , we thereby impose a "window" of a rectangular shape, the duration of <b>T</b> samples.  Therefore, the resulting spectrum is the spectrum of a multiplied harmonic signal and a rectangular envelope.  In DSP tasks, windows of various shapes have been invented for quite a long time, which, when applied to a signal in the time domain, can improve its spectral characteristics.  A large number of various windows is primarily due to one of the main features of any window overlay.  This feature is expressed in the relationship between the level of side lobes and the width of the central lobe.  Known pattern: the stronger the suppression of side lobes, the wider the main lobe, and vice versa. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the applications of window functions is the detection of weak signals against the background of stronger ones by suppressing the level of side lobes.  The main window functions in DSP tasks are triangular, sinusoidal, Lanczos window, Hannah, Hamming, Blackman, Harris, Blackman-Harris, flat top window, Natall, Gauss, Kaiser window and many others.  Most of them are expressed in terms of a finite series by summing harmonic signals with specific weighting factors.  Windows of complex shape are calculated by taking an exponent (Gauss window) or a modified Bessel function (Kaiser window), and will not be considered in this article.  More information about window functions can be found in the literature, which I traditionally give at the end of the article. <br><br>  The following figure shows typical window functions and their spectral characteristics, constructed using Matlab CAD tools. <br><br><img src="https://habrastorage.org/webt/nf/dw/pm/nfdwpmdfjlxbkjx4thfjo3d3wrq.png"><br><br><h3>  Implementation </h3><br>  At the beginning of the article I inserted the KDPV, which shows in general form a block diagram of multiplying the input data by a window function.  Obviously, the easiest way to implement storing a window function in an FPGA is to write it into memory (block <i>RAMB</i> or distributed <i>Distributed</i> - not a big deal), and then cyclically retrieve data at the time of receipt of the input signal samples.  As a rule, in modern FPGAs the volumes of internal memory allow you to store window functions of relatively small size, which are then multiplied with the incoming input signals.  By small, I mean window functions with a length of up to 64K samples. <br><br>  But what if the length of the window function is too large?  For example, 1M samples.  It is easy to calculate that for such a window function, represented in a 32-bit bit grid, you will need NRAMB = 1024 * 1024 * 32/32768 = 1024 cells of the RAMB36K type of FPGA Xilinx crystals.  And for 16M counts?  16 thousand memory cells!  Not a single modern FPGA has so much memory.  For many FPGAs this is too much, but in other cases it is a wasteful use of FPGA resources (and, of course, the customer‚Äôs cash). <br><br>  In this regard, you need to come up with a method for generating samples of window functions directly in the FPGA on the fly, without recording the coefficients from the remote device into the block memory.  Fortunately, the basic things have long been invented for us.  Using an algorithm such as <b>CORDIC</b> (the ‚Äú <i>figure by number</i> ‚Äù method), it is possible to design many window functions whose formulas are expressed through harmonic signals (Blackman-Harris, Hanna, Hamming, Nattala, etc.) <br><br><h3>  CORDIC </h3><br>  CORDIC is a simple and convenient iterative method for calculating the rotation of the coordinate system, which allows you to calculate complex functions by performing primitive addition and shift operations.  Using the CORDIC algorithm, you can calculate the harmonic signals sin (x), cos (x), find the phase - atan (x) and atan2 (x, y), hyperbolic trigonometric functions, rotate the vector, extract the number root, etc. <br><br>  At first, I wanted to take a ready-made CORDIC core and reduce the amount of work, but I have a long-time dislike for Xilinx cores.  After studying the repositories on the githaba, I realized that all the kernels represented are not suitable for a number of reasons (poorly documented and unreadable, not universal, made for a specific task or element base, <s>written in verilog</s> , etc.).  Then I asked comrade <a href="https://habr.com/users/lazifo/" class="user_link">lazifo</a> to do this work for me.  Of course, he coped with it, because the implementation of CORDIC is one of the simplest tasks in the field of DSP.  But since I am impatient, in parallel with his work, I wrote <s>my own bicycle with</s> my parameterized kernel.  The main features are the configurable bitness of the output signals <b>DATA_WIDTH</b> and the input normalized phase <b>PHASE_WIDTH</b> from -1 to 1, the task of the precision of the <b>PRECISION</b> calculations.  The CORDIC core is made along a conveyor parallel circuit ‚Äî at each clock cycle the core is ready to perform calculations and receive input samples.  The kernel spends on computing the output sample of N clock cycles, the number of which depends on the bitness of the output samples (the greater the bit depth - the more iterations to calculate the output value).  All calculations occur in parallel.  Thus, CORDIC is the base kernel for creating window functions. <br><br><h3>  Window functions </h3><br>  In this article, I implement only those window functions that are expressed through harmonic signals (Hannah, Hamming, Blackman-Harris of a different order, etc.).  What is needed for this?  In general terms, the formula for constructing a window looks like a series of finite length. <br><br><img src="https://habrastorage.org/webt/it/ih/tg/itihtgetk0lxnpoavnivrrot0ou.png"><br><br>  A specific set of coefficients <b>a <sub>k</sub></b> and row members determines the name of the window.  The most popular and frequently used is the Blackman-Harris window: of a different order (from 3 to 11).  Below is a table of coefficients for Blackman-Harris windows: <br><br><img src="https://habrastorage.org/webt/fy/ss/_4/fyss_4cniul5oacholwxdvxfhli.jpeg"><br><br>  In principle, the Blackman-Harris window set is applicable to many spectral analysis problems, and there is no need to try to use complex Gauss or Kaiser windows.  The Nattala or flat top windows are just a variation of windows with different weights, but with the same basic principles as Blackman-Harris.  It is known that the more members of the series - the stronger the suppression of the side-lobe level (provided a reasonable choice of the window function is used).  Based on the task, the developer is simply to choose the type of windows used. <br><br><h3>  FPGA implementation - traditional approach </h3><br>  All the cores of window functions are designed using the classical approach of describing digital circuits on the FPGA and written in the VHDL language.  Below is a list of components made: <br><br><ul><li>  <i>bh_win_7term</i> - Blackman-Harris 7th order, a window with maximum suppression of side flakes. </li><li>  <i>bh_win_5term</i> - Blackman-Harris 5 order, includes a window with a flat top. </li><li>  <i>bh_win_4term</i> - Blackman-Harris 4 order, includes the window Nattala and Blackman-Nattala. </li><li>  <i>bh_win_3term</i> - Blackman-Harris 3 orders, </li><li>  <i>hamming_win</i> - Hamming and Hanna windows. </li></ul><br>  The source code for the Blackman-Harris window component is 3 orders of magnitude: <br><br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> bh_win_3term <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> ( TD : <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>:=<span class="hljs-number"><span class="hljs-number">0.5</span></span>ns; <span class="hljs-comment"><span class="hljs-comment">--! Time delay PHI_WIDTH : integer:=10; --! Signal period = 2^PHI_WIDTH DAT_WIDTH : integer:=16; --! Output data width XSERIES : string:="ULTRA" --! for 6/7 series: "7SERIES"; for ULTRASCALE: "ULTRA"; ); port ( RESET : in std_logic; --! Global reset CLK : in std_logic; --! System clock AA0 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A0 AA1 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A1 AA2 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A2 ENABLE : in std_logic; --! Clock enable DT_WIN : out std_logic_vector(DAT_WIDTH-1 downto 0); --! Output DT_VLD : out std_logic --! Output data valid ); end bh_win_3term;</span></span></code> </pre> <br>  In some cases, I used the <i>UNISIM</i> library to embed the <b>DSP48E1 and DSP48E2 nodes</b> in the project, which ultimately allows us to increase the computation speed by pipelining inside these blocks, but as practice has shown, it is faster and easier to give up laziness and write something like <b>P = A * B + C</b> and specify the following directives in the code: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> USE_DSP <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> &lt;signal_name&gt;: <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">"YES"</span></span>;</code> </pre> <br>  This works fine and hard for the synthesizer sets the type of element on which the mathematical function is implemented. <br><br><h3>  Vivado hls </h3><br>  In addition, I implemented all the kernels using the <b>Vivado HLS</b> tools.  I will list the main <b>advantages of</b> Vivado HLS - a high speed of design ( <i>time-to-market</i> ) in high-level C or C ++ languages, fast modeling of the developed nodes due to the lack of the concept of clock frequency, flexible configuration of solutions (in terms of resources and performance) by introducing pragmas and directives in the project, as well as a low entry threshold for developers in high-level languages.  The main disadvantage is the non-optimal cost of FPGA resources in comparison with the classical approach.  Also, it is not possible to achieve the speeds of work that are provided by the classic old RTL methods (VHDL, Verilog, SV).  Well, the biggest <b>drawback</b> is dancing with a tambourine, but this is characteristic of all Xilinx CAD systems.  (Note: in the Vivado HLS debugger and in the real C ++ model, different results are often obtained, since the Vivado HLS works crookedly when using the advantages of <i>arbitrary precision</i> ). <br><br>  The following picture shows the log of the synthesized CORDIC core in Vivado HLS.  It is quite informative and displays a lot of useful information: the number of resources used, the user interface of the kernel, the cycles and their properties, the delay for calculations, the interval for calculating the output value (important when designing sequential and parallel circuits): <br><br><img src="https://habrastorage.org/webt/oe/e3/zh/oee3zhonsadxnqugfhd8geg7hca.png"><br><br>  You can also see the way to calculate data in various components (functions).  It can be seen that the phase data is read at the zero cycle, and at 7 and 8 cycles the result of the operation of the CORDIC node is displayed. <br><img src="https://habrastorage.org/webt/kw/nf/j7/kwnfj7uftmtnnv6iaxoecjvji1g.png"><br><br>  The result of Vivado HLS: a synthesized RTL core created from C-code.  The log shows that, according to temporary analysis, the kernel successfully passes all restrictions: <br><br><img src="https://habrastorage.org/webt/83/tb/hw/83tbhwy9j5jqkgn2tdz697dz-na.png"><br><br>  Another big plus of Vivado HLS is that to check the obtained result, she herself makes a testbench synthesized RTL code based on the model that was used to check the C code.  This may be a primitive check, but I think that this is very cool and quite convenient enough to compare the work of the algorithm in C and HDL.  Below is a screenshot from Vivado, showing the simulation of the kernel model of a window function obtained by means of Vivado HLS: <br><br><img src="https://habrastorage.org/webt/6q/zw/3m/6qzw3mcmm6xixm-wh9kpumqpzx8.png"><br><br>  Thus, for all window functions, similar results were obtained, regardless of the design method - on VHDL or on C ++.  However, in the first case, greater work frequency and fewer resources are used, and in the second case, the maximum design speed is achieved.  Both approaches have the right to life. <br><br>  I specifically calculated how much time I would spend on developing with different methods.  I implemented the C ++ project in Vivado HLS about 12 times faster than on VHDL. <br><br><h3>  Comparison of approaches </h3><br>  Compare source codes in HDL and C ++ for the core CORDIC.  The algorithm, as mentioned earlier, is based on the operations of addition, subtraction and shift.  On VHDL, it looks like this: there are three data vectors - one is responsible for the angle rotation, and the other two determine the length of the vector along the X and Y axes, which is equivalent to sin and cos (see the picture from the wiki): <br><br><img src="https://habrastorage.org/webt/ab/3w/hv/ab3whvtkvcgl-ycqnkz3mjzr0lk.png"><br><br>  By iteratively calculating the value of Z, the values ‚Äã‚Äãof X and Y are computed in parallel. The process of cyclically searching for output values ‚Äã‚Äãon HDL: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> ROM_LUT : rom_array := ( x<span class="hljs-string"><span class="hljs-string">"400000000000"</span></span>, x<span class="hljs-string"><span class="hljs-string">"25C80A3B3BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"13F670B6BDC7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0A2223A83BBB"</span></span>, x<span class="hljs-string"><span class="hljs-string">"05161A861CB1"</span></span>, x<span class="hljs-string"><span class="hljs-string">"028BAFC2B209"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0145EC3CB850"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00A2F8AA23A9"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00517CA68DA2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0028BE5D7661"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00145F300123"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000A2F982950"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000517CC19C0"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00028BE60D83"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000145F306D6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000A2F9836D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000517CC1B7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000028BE60DC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000145F306E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000A2F9837"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000517CC1B"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000028BE60E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000145F307"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000A2F983"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000517CC2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000028BE61"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000145F30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000A2F98"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000517CC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000028BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000145F3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000A2FA"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000517D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000028BE"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000145F"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000A30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000518"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000028C"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000146"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000000A3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000051"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000029"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000014"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000000A"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000005"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000003"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000001"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000000"</span></span> ); pr_crd: <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk, reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reset = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">---- Reset sine / cosine / angle vector ---- sigX &lt;= (others =&gt; (others =&gt; '0')); sigY &lt;= (others =&gt; (others =&gt; '0')); sigZ &lt;= (others =&gt; (others =&gt; '0')); elsif rising_edge(clk) then sigX(0) &lt;= init_x; sigY(0) &lt;= init_y; sigZ(0) &lt;= init_z; ---- calculate sine &amp; cosine ---- lpXY: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigX(ii+1) &lt;= sigX(ii) + sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) - sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); else sigX(ii+1) &lt;= sigX(ii) - sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) + sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); end if; end loop; ---- calculate phase ---- lpZ: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigZ(ii+1) &lt;= sigZ(ii) + ROM_TABLE(ii); else sigZ(ii+1) &lt;= sigZ(ii) - ROM_TABLE(ii); end if; end loop; end if; end process;</span></span></code> </pre><br>  In C ++, the Vivado HLS code looks almost the same, but the record is several times shorter: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Unrolled loop // int k; stg: for (k = 0; k &lt; NWIDTH; k++) { #pragma HLS UNROLL if (z[k] &lt; 0) { x[k+1] = x[k] + (y[k] &gt;&gt; k); y[k+1] = y[k] - (x[k] &gt;&gt; k); z[k+1] = z[k] + lut_angle[k]; } else { x[k+1] = x[k] - (y[k] &gt;&gt; k); y[k+1] = y[k] + (x[k] &gt;&gt; k); z[k+1] = z[k] - lut_angle[k]; } }</span></span></code> </pre><br><br>  Apparently, the same cycle with shift and additions is used.  However, by default, all loops in Vivado HLS are ‚Äúminimized‚Äù and executed sequentially, as planned for the C ++ language.  Introducing the <b>HLS UNROLL</b> or <b>HLS PIPELINE pragma</b> converts sequential calculations to parallel ones.  This leads to an increase in FPGA consumed resources, however, it allows you to calculate and submit new values ‚Äã‚Äãto the core at each clock cycle. <br><br>  The results of the project synthesis on VHDL and C ++ are presented in the figure below.  As can be seen, logically, the discrepancy is two times in favor of the traditional approach.  For the remaining FPGA resources the difference is not significant.  I did not really go into the optimization of the project in C ++, but definitely by setting different directives or partially changing the code, the amount of resources used can be reduced.  In both cases, the timings converged for a given core frequency of ~ 350 MHz. <br><img src="https://habrastorage.org/webt/lp/id/ic/lpidicvwz-edguptklqfahlo0ya.png"><br><br><h3>  Features of the implementation </h3><br>  Since the calculations are performed in a fixed point format, the window functions have a number of features that must be considered when designing DSP systems on a FPGA.  For example, the greater the data width of the window function - the better the overlay accuracy of the window.  On the other hand, if the window function is insufficient for the window function, distortions will be introduced into the resulting waveform, which will affect the quality of the spectral characteristics.  For example, a window function must have at least 20 bits when multiplied by a signal of 2 ^ 20 = 1M samples. <br><br><h3>  Conclusion </h3><br>  This article shows one of the ways to design window functions without using external memory or block FPGA memory.  A method for enabling only the FPGA logical resources (and in some cases DSP blocks) is given.  Using the CORDIC algorithm, it is possible to obtain window functions of any bit depth (within reasonable limits), of any length and order, and therefore - to have a set of practically any spectral characteristics of the window. <br><br>  In one of the works, I managed to get a stable operating Blackman-Harris window function 5 and 7 on 1M samples at a frequency of ~ 375 MHz, and also to make a generator of turning coefficients for a CORDIC-based FFT at a frequency of ~ 400 MHz.  FPGA crystal used: Kintex Ultrascale + (xcku11p-ffva1156-2-e). <br><br>  Link to <a href="https://github.com/capitanov/blackman_harris_win"><b>github</b> project here</a> .  The project contains a mathematical model in Matlab, source codes of window functions and CORDIC on VHDL, as well as models of listed window functions in C ++ for Vivado HLS. <br><br><h3>  Useful articles </h3><br><ul><li>  <a href="http://www.dsplib.ru/content/winex/winex.html">DSPLib window functions</a> </li><li>  <a href="http://www.dsplib.ru/content/winadd/win.html">Some DSPlib window functions</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Window_function">Expanded article on window filtering wiki</a> </li><li>  <a href="https://en.wikipedia.org/wiki/CORDIC">Wiki article about CORDIC</a> </li><li>  <a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2017_4/ug902-vivado-high-level-synthesis.pdf">Vivado HLS Userguide</a> </li><li>  <a href="https://habr.com/post/269991/">Article about spectral analysis on Habr√©</a> </li></ul><br>  I also advise a very popular book on DSP - <a href="https://www.amazon.com/Digital-Signal-Processing-Practical-Approach/dp/0201596199">E. Aificher, Jervis B. Digital Signal Processing.</a>  <a href="https://www.amazon.com/Digital-Signal-Processing-Practical-Approach/dp/0201596199">Practical approach</a> <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/427361/">https://habr.com/ru/post/427361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427351/index.html">Security Week 40: vulnerabilities in CMS Drupal and not only</a></li>
<li><a href="../427353/index.html">Drones show: how we coordinated a swarm of dancing kopter</a></li>
<li><a href="../427355/index.html">CJM compilation, key art director skills and user understanding</a></li>
<li><a href="../427357/index.html">Writing Shaders in Unity. GrabPass, PerRendererData</a></li>
<li><a href="../427359/index.html">How ECS, C # Job System and SRP change the approach to architecture</a></li>
<li><a href="../427363/index.html">Introduction of LoRaWAN in an agricultural enterprise. All about construction, start-up and solutions</a></li>
<li><a href="../427365/index.html">Report from RedSlerma about monitoring (Monit, Zabbix)</a></li>
<li><a href="../427367/index.html">Conference BLACK HAT USA. How a Hollywood hacker uses surveillance cameras. Part 1</a></li>
<li><a href="../427369/index.html">Conference BLACK HAT USA. How a Hollywood hacker uses surveillance cameras. Part 2</a></li>
<li><a href="../427371/index.html">Video course "Basics of working with BPMN notations". Free</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>