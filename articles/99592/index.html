<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compilation. 6: intermediate code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first stage - analysis of the syntax of our jay-squeak is passed; getting to the code generation. 

 We start by generating a p-code (intermediate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compilation. 6: intermediate code</h1><div class="post__text post__text-html js-mediator-article">  The first stage - <a href="http://habrahabr.ru/blogs/programming/99397/">analysis of the syntax of</a> our jay-squeak is passed;  getting to the code generation. <br><br>  We start by generating a p-code (intermediate portable pseudocode) - something like an ‚Äúabstract machine language‚Äù.  It is chosen so that <ul><li>  it was easy to generate; </li><li>  it was easy to handle. </li></ul>  The processing of a p-code is, as a rule, its processing into executable machine-dependent code.  Nevertheless, it can be limited only to the generation of the p-code, and declare it a ready-made compiled program.  Running such a program would, in essence, be interpreting the p-code.  This approach has more and more supporters;  so, to begin with, we restrict ourselves to compiling into p-code. <br><br><h3>  Further in the post: </h3><ol><li>  Code selection </li><li>  Compilation </li><li>  Performance </li><li>  Backpatching </li></ol><a name="habracut"></a><h3>  Code selection </h3><br>  Often, p-code is made stackable (for example, MSIL): imagine a processor with no numbered registers inside, but one big stack, and all actions are performed with upper values ‚Äã‚Äãon the stack.  (Those who have programmed for x87 are familiar with this model.) The stack code is really convenient to generate and convenient to execute, but not very convenient to process - for example, it is difficult to track dependencies between commands. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The <a href="http://dmzlj.livejournal.com/129758.html">creator of the Beep language</a> expressly speaks about the choice between stack and register intermediate code: <br><blockquote><h6>  Register without options: </h6><br>  Runtime simplification.  Less pointer manipulation.  There is no concept of stack overflow.  Less code, less memory management - less space for critical errors. <br>  The compilation complexity increases: a register allocation phase appears.  In the case of execution on a virtual machine, the number of registers is not important for us, we can make enough of them in order not to do allocation at all, but simply map all parameters and variable functions to registers (see Lua).  If the number of parameters exceeds the number of registers, it is possible to allocate a part of the activation record in the heap, but it is easier to make it so that the compiler would suggest the author of such a code to treat the head. <br>  In any case, if there is a question of simplifying the runtime at the cost of complicating the compiler, this should be done. <br>  Ability to optimize: mapping N registers of the virtual machine to the registers of the processor.  On a stack machine, this is much more difficult. <br></blockquote><br>  So instead of a stack, we take a three-address MIPS-like code: <ul><li>  All commands are of equal length (we have 4 bytes each) </li><li>  The first byte is the command number (by separate opcode for each possible operation) </li><li>  The second byte is the register number for the result <i>(256 registers is enough for anyone!)</i> </li><li>  The remainder is either the two numbers of the operand registers, or the immediate value ‚Äî the operand. </li></ul>  Register number 0 will be reserved for storing zero: it is useful to us.  In general, it is useful to use the reserved ‚Äúinvalid‚Äù register number to mean ‚Äúno register at all‚Äù. <br><br>  In addition to commands corresponding to computational operations, we also need: <br><ul><li>  loading an immediate value into a register; </li><li>  reading from memory to the register; </li><li>  write from register to memory; </li><li>  conditional transition; </li><li>  output string or number; </li><li>  enter a number; </li><li>  stop. </li></ul> All computational commands take two registers, and all others take immediate value. <br><br>  Working with memory for us is not yet relevant: if not all variables can be placed in registers, then the programmer is not lucky.  Operations that do not exist in the jar-crease yet, like calling functions, moreover, we don‚Äôt include them in the p-code. <br><br>  We arrange the opcodes so that the commands of a similar structure (in terms of the registers used) go in a row, and put the definition of the command structure into a separate <code>jsk.h</code> file: it will be required by both the compiler and the interpreter. <br> <code><font color="#008000">typedef</font> <font color="#008000">unsigned</font> <font color="#008000">char</font> regnum; <br> <br> <font color="#008000">struct</font> command { <br> <font color="#008000">enum</font> opcodes { <br> hlt, <br> store, <font color="#8080ff">// dst&gt;</font> <br> jz, <font color="#8080ff">// dst&gt;</font> <br> echo, <font color="#8080ff">// dst&gt;</font> <br> mov, <font color="#8080ff">// &gt;dst</font> <br> load, <font color="#8080ff">// &gt;dst</font> <br> input, <font color="#8080ff">// &gt;dst</font> <br> add, <font color="#8080ff">// src&gt;dst</font> <br> sub, <font color="#8080ff">// src&gt;dst</font> <br> mul, <font color="#8080ff">// src&gt;dst</font> <br> div, <font color="#8080ff">// src&gt;dst</font> <br> eq, <font color="#8080ff">// src&gt;dst</font> <br> ne, <font color="#8080ff">// src&gt;dst</font> <br> ge, <font color="#8080ff">// src&gt;dst</font> <br> le, <font color="#8080ff">// src&gt;dst</font> <br> gt, <font color="#8080ff">// src&gt;dst</font> <br> lt <font color="#8080ff">// src&gt;dst</font> <br> }; <br> <br> opcodes opcode; <br> regnum dest; <br> <font color="#008000">union</font> { <br> <font color="#008000">struct</font> { <br> regnum src1, src2; <br> }; <br> <font color="#008000">short</font> imm; <br> }; <br> command(opcodes opcode, regnum dest, regnum src1, regnum src2) : <br> opcode(opcode), dest(dest), src1(src1), src2(src2) {} <br> command(opcodes opcode, regnum dest, <font color="#008000">short</font> imm) : <br> opcode(opcode), dest(dest), imm(imm) {} <br> }; <br></code> <br>  In order for the opcode to actually be allocated one byte, you will have to specify the <nobr><code>-fshort-enums</code></nobr> key <nobr><code>-fshort-enums</code></nobr> <br><br><h3>  Compilation </h3><br>  The lines for <code>echo</code> will be stored together with the program code, at the very end;  combine the same strings so that only one copy is kept.  To do this, we will store the <code>map</code> all lines, where the value is the "identifier" of the line (its sequence number in the program). <br><br>  All variables in the squeak are global.  In a separate <code>map</code> we will store the number of the register allocated to it by the name of a variable. <br><br>  In general, the idea is the same as with a formatted printout;  only now in each node of the tree we do not store text, but a list of commands.  For the elements of the expression also store the number of the register in which the result of the calculation. <br><br>  We take the parser and go: we replace the <code>print()</code> method with a similar <code>emit()</code> , which glues the lists of commands of the child nodes into one large list. <br><br>  <i>(340 lines of code rendered at <a href="http://tyomitch.net.ru/jsk.y.html">http://tyomitch.net.ru/jsk.y.html</a> , to keep the size of the post within the limits of permissible.)</i> <br><br>  As you can see, it was necessary to ‚Äúsplit‚Äù the <code>value</code> node into three different types: a literal number, a literal string, and a reference to a variable.  When formatting the code, the differences between them were insignificant, but during the generation it was already necessary to distinguish them. <br><br><h3>  Performance </h3><br>  We will display the file with the n-code in memory, and we will work with it as with an array of <code>command</code> structures.  Actually, execution is a cycle of 4 lines, and the implementation of command functions;  most of the code is auxiliary husk. <br><br> <code><font color="#ff40ff">#include</font> <font color="#ff6060">&lt;fcntl.h&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;stdio.h&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;stdlib.h&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;unistd.h&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;sys/mman.h&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">"jsk.h"</font> <br> <br> <font color="#008000">int</font> pc = <font color="#ff6060">0</font> ; <font color="#8080ff">//   ( )</font> <br> <font color="#008000">bool</font> halted = <font color="#ff6060">false</font> ; <br> <font color="#008000">int</font> mem[ <font color="#ff6060">1000</font> ]; <font color="#8080ff">//   :     </font> <br> <br> <font color="#008000">typedef</font> <font color="#008000">int</font> (*op)( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm); <font color="#8080ff">//    </font> <br> <br> <font color="#008000">const</font> <font color="#008000">char</font> * fdata = <font color="#ff6060">NULL</font> ; <font color="#8080ff">//   -</font> <br> <br> <font color="#008000">extern</font> op ops[]; <font color="#8080ff">//  </font> <br> <br> <font color="#008000">int</font> main( <font color="#008000">int</font> argc, <font color="#008000">char</font> ** argv) { <br> <br> <font color="#808000">if</font> (argc!= <font color="#ff6060">2</font> ) { <br> printf( <font color="#ff6060">"Missing pcode file name.</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> ); <br> exit( <font color="#ff6060">1</font> ); <br> } <br> <br> <font color="#008000">int</font> fd = open(argv[ <font color="#ff6060">1</font> ], O_RDONLY); <br> <font color="#808000">if</font> (fd&lt; <font color="#ff6060">0</font> ) { <br> printf( <font color="#ff6060">"Cannot open pcode file.</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> ); <br> exit( <font color="#ff6060">1</font> ); <br> } <br> <font color="#008000">struct</font> stat finfo; <br> fstat(fd, &amp;finfo); <br> fdata = ( <font color="#008000">const</font> <font color="#008000">char</font> *)mmap( <font color="#ff6060">0</font> , finfo.st_size, PROT_READ, MAP_PRIVATE, fd, <font color="#ff6060">0</font> ); <br> <font color="#808000">if</font> (!fdata) { <br> printf( <font color="#ff6060">"Cannot read pcode file.</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> ); <br> exit( <font color="#ff6060">1</font> ); <br> } <br> <br> <font color="#008000">const</font> command* pcode = ( <font color="#008000">const</font> command*) fdata; <br> <br> <font color="#008000">int</font> r[ <font color="#ff6060">256</font> ] = { <font color="#ff6060">0</font> }; <font color="#8080ff">// registers</font> <br> <br> <font color="#808000">while</font> (!halted) { <br> command next = pcode[pc++]; <br> r[next.dest] = ops[next.opcode](r[next.src1], r[next.src2], r[next.dest], next.imm); <br> } <br> <br> munmap(( <font color="#008000">void</font> *)fdata, finfo.st_size); <br> close(fd); <br> <font color="#808000">return</font> <font color="#ff6060">0</font> ; <br> } <br> <br> <font color="#008000">int</font> hlt( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { halted = <font color="#ff6060">true</font> ; <font color="#808000">return</font> dest; } <br> <font color="#008000">int</font> store( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { mem[imm] = dest; <font color="#808000">return</font> dest; } <br> <font color="#008000">int</font> jz( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">if</font> (!dest) pc+=imm; <font color="#808000">return</font> dest; } <br> <font color="#008000">int</font> echo( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">if</font> (imm) printf( <font color="#ff6060">"</font> <font color="#ff40ff">%s</font> <font color="#ff6060">"</font> , fdata+imm); <font color="#808000">else</font> printf( <font color="#ff6060">"</font> <font color="#ff40ff">%d</font> <font color="#ff6060">"</font> , dest); <font color="#808000">return</font> dest; } <br> <font color="#008000">int</font> mov( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> imm; } <br> <font color="#008000">int</font> load( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> mem[imm]; } <br> <font color="#008000">int</font> input( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#008000">int</font> d; scanf( <font color="#ff6060">"</font> <font color="#ff40ff">%d</font> <font color="#ff6060">"</font> , &amp;d); <font color="#808000">return</font> d; } <br> <font color="#008000">int</font> add( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1+src2; } <br> <font color="#008000">int</font> sub( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1-src2; } <br> <font color="#008000">int</font> mul( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1*src2; } <br> <font color="#008000">int</font> div( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1/src2; } <br> <font color="#008000">int</font> eq( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1==src2; } <br> <font color="#008000">int</font> ne( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1!=src2; } <br> <font color="#008000">int</font> ge( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1&gt;=src2; } <br> <font color="#008000">int</font> le( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1&lt;=src2; } <br> <font color="#008000">int</font> gt( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1&gt;src2; } <br> <font color="#008000">int</font> lt( <font color="#008000">int</font> src1, <font color="#008000">int</font> src2, <font color="#008000">int</font> dest, <font color="#008000">int</font> imm) { <font color="#808000">return</font> src1&lt;src2; } <br> <br> op ops[] = {hlt, store, jz, echo, mov, load, input, add, sub, mul, div, eq, ne, ge, le, gt, lt}; <br></code> <br><br>  Fanfare!  We start the first program in the world on jay-creaking: <br><br> <code>[tyomitch@home ~]$ <b>bison jsk.y</b> <br> [tyomitch@home ~]$ <b>c++ -fshort-enums jsk.tab.c lex.yy.c -o jskc</b> <br> [tyomitch@home ~]$ <b>c++ -fshort-enums jsk.c -o jsk</b> <br> [tyomitch@home ~]$ <b>./jskc &lt; test.jsk &gt; pcode</b> <br> [tyomitch@home ~]$ <b>hexdump -C pcode</b> <br> 00000000 04 01 00 00 04 02 e8 03 03 00 26 01 03 01 00 00 |..........&amp;.....| <br> 00000010 03 00 a0 00 03 02 00 00 03 00 a7 00 0e 03 01 02 |................| <br> 00000020 02 03 1d 00 07 04 01 02 04 05 02 00 0a 06 04 05 |................| <br> 00000030 03 00 62 01 03 06 00 00 03 00 cc 00 06 07 00 00 |..b.............| <br> 00000040 04 08 01 00 0b 09 07 08 02 09 04 00 04 0a 01 00 |................| <br> 00000050 08 0b 06 0a 07 02 0b 00 02 00 0e 00 04 0c 02 00 |................| <br> 00000060 0b 0d 07 0c 02 0d 04 00 04 0e 01 00 07 0f 06 0e |................| <br> 00000070 07 01 0f 00 02 00 07 00 04 10 03 00 0b 11 07 10 |................| <br> 00000080 02 11 03 00 03 00 46 01 00 00 00 00 02 00 01 00 |......F.........| <br> 00000090 03 00 6a 01 02 00 e1 ff 03 00 ff 00 00 00 00 00 |..j.............| <br> 000000a0 20 d0 b4 d0 be 20 00 2c 20 d0 b0 20 d1 8f 20 d0 | .... ., .. .. .| <br> 000000b0 b1 d1 83 d0 b4 d1 83 20 d1 83 d0 b3 d0 b0 d0 b4 |....... ........| <br> 000000c0 d1 8b d0 b2 d0 b0 d1 82 d1 8c 0a 00 3f 20 20 28 |............?  (| <br> 000000d0 31 3d d0 bc d0 b5 d0 bd d1 8c d1 88 d0 b5 2c 20 |1=............, | <br> 000000e0 32 3d d0 b1 d0 be d0 bb d1 8c d1 88 d0 b5 2c 20 |2=............, | <br> 000000f0 33 3d d0 bf d0 be d0 bf d0 b0 d0 bb 29 20 00 d0 |3=..........) ..| <br> 00000100 92 d1 80 d1 91 d1 88 d1 8c 2c 20 d1 82 d0 b0 d0 |........., .....| <br> 00000110 ba 20 d0 bd d0 b5 20 d0 b1 d1 8b d0 b2 d0 b0 d0 |. .... .........| <br> 00000120 b5 d1 82 21 0a 00 d0 97 d0 b0 d0 b4 d1 83 d0 bc |...!............| <br> 00000130 d0 b0 d0 b9 20 d1 87 d0 b8 d1 81 d0 bb d0 be 20 |.... .......... | <br> 00000140 d0 be d1 82 20 00 d0 a3 d1 80 d0 b0 21 20 d0 af |.... .......! ..| <br> 00000150 20 d0 bc d0 be d0 bb d0 be d0 b4 d0 b5 d1 86 21 | ..............!| <br> 00000160 0a 00 d0 ad d1 82 d0 be 20 00 d0 af 20 d0 bd d0 |........ ... ...| <br> 00000170 b8 d1 87 d0 b5 d0 b3 d0 be 20 d0 bd d0 b5 20 d0 |......... .... .| <br> 00000180 bf d0 be d0 bd d1 8f d0 bb 21 0a 00             |.........!..| <br> 0000018c <br> [tyomitch@home ~]$ <b>./jsk pcode</b> <br>    0  1000,     <br>  500? (1=, 2=, 3=) <b>2</b> <br>  750? (1=, 2=, 3=) <b>2</b> <br>  875? (1=, 2=, 3=) <b>2</b> <br>  938? (1=, 2=, 3=) <b>1</b> <br>  906? (1=, 2=, 3=) <b>1</b> <br>  890? (1=, 2=, 3=) <b>2</b> <br>  898? (1=, 2=, 3=) <b>2</b> <br>  902? (1=, 2=, 3=) <b>1</b> <br>  900? (1=, 2=, 3=) <b>1</b> <br>  899? (1=, 2=, 3=) <b>1</b> <br> ,   ! <br></code> <br>  If you look closely at the dump, you will notice that the first <code>0xa0</code> bytes are occupied by the p-code (fours of bytes), and the rest of the file is strings in UTF-8. <br><br><h3>  Backpatching </h3><br>  Now in each node of the tree there is a list of all the commands corresponding to it, and each implementation of <code>emit</code> involves combining commands from child nodes in the same order (left to right) in which these nodes were created during parsing.  It is possible to save both memory for storing commands, and code for merging them, if all generated commands are immediately dumped into the result, and only ‚Äúmetainformation‚Äù such as register numbers is stored in characters. <br><br>  The most dramatic difference is that now we don‚Äôt need a tree at all: for each character it is enough to store <i>one scalar</i> .  Moreover: the characters of the operators now have no value at all - the entire result of their analysis is immediately dumped into the vector of the finished p-code;  therefore, convolutions where no code is generated do not even need to inherit anything. <br><br>  A minor problem arises in constructions such as <code>if</code> and <code>while</code> , where, after checking the condition, you must insert a jump forward if the condition is not met;  and until the end of the analysis of the structure it is not known how much it is necessary to jump.  We'll have to leave the dummy team in place of the jump, and fill it in at the end of the analysis.  Such a system of one-pass code generation with dummies, and their subsequent ‚Äúpatching‚Äù, is called <i>backpatching</i> .  It is very versatile, and not only allows you to compile all the usual control structures, but also simplifies the implementation of <code>break</code> operators jumping forward an unknown distance. <br><br>  To insert a dummy jump after checking the condition in <code>if</code> and <code>while</code> , add a <i>marker</i> to the grammar - ‚Äúempty character‚Äù: <br><pre> OP: 'if' '(' EXPR ')' M OP 'else' M OP;
   |  'while' '(' EXPR ')' M OP;
 M:;
</pre><br>  The trick is that the convolution <code>M</code> executed after the <code>EXPR</code> convolution (which generates the condition verification code) and before the <code>OP</code> convolution, so that we can add the generation of the dummy to the convolution code <code>M</code>  When we collapse the entire structure, fill the dummy with a jump to the next dummy (after <code>if</code> ) or until the end of the generated code (after the <code>else</code> and <code>while</code> ). <br><br>  The distance to jump forward now know;  and how for <code>while</code> know the distance to jump back at the end of the cycle?  After all, if there are no lists of commands, then in the convolution code we will not be able to find out how many commands the whole construct took.  We'll have to get another <code>N</code> marker, which does not generate the code, but simply remembers the address of the desired place: <br><pre> OP: 'while' N '(' EXPR ')' M OP;
 M:;
 N:;
</pre><br>  An additional advantage of the new system is that for each generated command, its address is immediately known, so that for strings we can store not temporary ‚Äúidentifiers‚Äù, but lists of all links.  This will simplify the substitution of address strings at the final stage of generating the p-code. <br><br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;iostream&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;vector&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;list&gt;</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;map&gt;</font> <br> <font color="#008000">extern</font> <font color="#008000">int</font> yylineno; <br> <font color="#008000">extern</font> <font color="#008000">int</font> yylex(); <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s) <font color="#ff40ff">{</font> <br> std::cerr <font color="#808000">&lt;&lt;</font> s <font color="#808000">&lt;&lt;</font> <font color="#ff6060">", line "</font> <font color="#808000">&lt;&lt;</font> yylineno <font color="#808000">&lt;&lt;</font> std::endl; <br> exit( <font color="#ff6060">1</font> ); <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">"jsk.h"</font> <br> <font color="#008000">struct</font> arg_t <font color="#ff40ff">{</font> <br> regnum dest; <font color="#8080ff">// if numeric</font> <br> std::string str; <font color="#8080ff">// if literal</font> <br> <font color="#ff40ff">}</font> ; <br> <font color="#008000">typedef</font> <font color="#008000">struct</font> <font color="#ff40ff">{</font> <br> std::string str; <font color="#8080ff">// tokens</font> <br> regnum dest; <font color="#8080ff">// expr</font> <br> arg_t arg; <br> std::list <font color="#808000">&lt;</font> <font color="#008000">arg_t</font> <font color="#808000">&gt;</font> args; <br> <font color="#008000">int</font> addr; <font color="#8080ff">// markers</font> <br> <font color="#008000">char</font> null; <font color="#8080ff">// op (no data)</font> <br> <font color="#ff40ff">}</font> YYSTYPE; <br> <font color="#ff40ff">#define YYSTYPE YYSTYPE</font> <br> <font color="#ff40ff">#define TOKENPASTE(x, y) x ## y</font> <br> <font color="#ff40ff">#define TOKENPASTE2(x, y) TOKENPASTE(x, y)</font> <br> <font color="#ff40ff">#define foreach(i, list)</font> <font color="#008000">typedef</font> <font color="#ff40ff">typeof(list) TOKENPASTE2(T,</font> <font color="#ff6060">__LINE__</font> <font color="#ff40ff">); \</font> <br> <font color="#ff40ff">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </font> <font color="#808000">for</font> <font color="#ff40ff">(TOKENPASTE2(T,</font> <font color="#ff6060">__LINE__</font> <font color="#ff40ff">)::iterator i = list.begin(); i != list.end(); i++)</font> <br> template&lt;typename L&gt; <br> <font color="#008000">inline</font> <font color="#008000">void</font> append(L&amp; list1, L&amp; list2) <font color="#ff40ff">{</font> <br> list <font color="#ff6060">1.</font> splice(list1.end(), list2, list2.begin(), list2.end()); <br> <font color="#ff40ff">}</font> <br> <br> std::vector <font color="#808000">&lt;</font> <font color="#008000">command</font> <font color="#808000">&gt;</font> pcode; <br> std::map&lt;std::string,regnum&gt; vars; <br> std::map&lt;std::string,std::list <font color="#808000">&lt;</font> <font color="#008000">int</font> <font color="#808000">&gt;</font> &gt; strings; <br> regnum lastreg = <font color="#ff6060">0</font> ; <br> <font color="#008000">inline</font> regnum newreg() <font color="#ff40ff">{</font> <br> <font color="#808000">if</font> (!++lastreg) <br> yyerror( <font color="#ff6060">"Too many registers used."</font> ); <br> <font color="#808000">return</font> lastreg; <br> <font color="#ff40ff">}</font> <br> <br> <font color="#008000">inline</font> <font color="#008000">int</font> emit( <font color="#008000">const</font> command&amp; cmd) <font color="#ff40ff">{</font> <br> pcode.push_back(cmd); <br> <font color="#808000">return</font> pcode.size()- <font color="#ff6060">1</font> ; <br> <font color="#ff40ff">}</font> <br> <font color="#008000">inline</font> <font color="#008000">int</font> emit(command::opcodes opcode, regnum dest, regnum src1, regnum src2) <font color="#ff40ff">{</font> <br> <font color="#808000">return</font> emit(command(opcode, dest, src1, src2)); <br> <font color="#ff40ff">}</font> <br> <font color="#008000">inline</font> <font color="#008000">int</font> emit(command::opcodes opcode, regnum dest, <font color="#008000">short</font> imm) <font color="#ff40ff">{</font> <br> <font color="#808000">return</font> emit(command(opcode, dest, imm)); <br> <font color="#ff40ff">}</font> <br> <font color="#008000">inline</font> <font color="#008000">void</font> fix( <font color="#008000">int</font> index, command::opcodes opcode, regnum dest, <font color="#008000">short</font> imm) <font color="#ff40ff">{</font> <br> pcode[index] = command(opcode, dest, imm); <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">%}</font> <br> <br> <font color="#808000">%token</font> IF ELSE WHILE EXIT <br> <font color="#808000">%token</font> EQ LE GE NE <br> <font color="#808000">%token</font> STRING NUM ID <br> <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">str</font> <font color="#808000">&gt;</font> ID NUM STRING <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">dest</font> <font color="#808000">&gt;</font> EXPR EXPR1 EXPR2 TERM VAL <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">arg</font> <font color="#808000">&gt;</font> ARG <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">args</font> <font color="#808000">&gt;</font> ARGS <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">null</font> <font color="#808000">&gt;</font> OPS OP1 OP2 OP <br> <font color="#808000">%type</font> <font color="#808000">&lt;</font> <font color="#008000">addr</font> <font color="#808000">&gt;</font> MN <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">PROGRAM:</font> OPS <font color="#ff40ff">{</font> emit(command::hlt, <font color="#ff6060">0</font> , <font color="#ff6060">0</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OPS:</font> OP <font color="#8080ff">// no action</font> <br> <font color="#7f9fbf">|</font> OPS OP <font color="#8080ff">// no action</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP1:</font> <font color="#ff6060">'{'</font> OPS <font color="#ff6060">'}'</font> <font color="#ff40ff">{}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">';'</font> <font color="#ff40ff">{}</font> <br> <font color="#7f9fbf">|</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> M OP1 ELSE M OP1 <font color="#ff40ff">{</font> fix( <font color="#808000">$5</font> , command::jz, <font color="#808000">$3</font> , <font color="#808000">$8</font> - <font color="#808000">$5</font> ); <br> fix( <font color="#808000">$8</font> , command::jz, <font color="#ff6060">0</font> , pcode.size()- <font color="#ff6060">1</font> - <font color="#808000">$8</font> ); <br> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> WHILE N <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> M OP1 <font color="#ff40ff">{</font> fix( <font color="#808000">$6</font> , command::jz, <font color="#808000">$4</font> , emit(command::jz, <font color="#ff6060">0</font> , <font color="#808000">$2</font> -pcode.size()- <font color="#ff6060">1</font> ) - <font color="#808000">$6</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXIT <font color="#ff6060">';'</font> <font color="#ff40ff">{</font> emit(command::hlt, <font color="#ff6060">0</font> , <font color="#ff6060">0</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP2:</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> M OP <font color="#ff40ff">{</font> fix( <font color="#808000">$5</font> , command::jz, <font color="#808000">$3</font> , pcode.size()- <font color="#808000">$5</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> IF <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> M OP1 ELSE M OP2 <font color="#ff40ff">{</font> fix( <font color="#808000">$5</font> , command::jz, <font color="#808000">$3</font> , <font color="#808000">$8</font> - <font color="#808000">$5</font> ); <br> fix( <font color="#808000">$8</font> , command::jz, <font color="#ff6060">0</font> , pcode.size()- <font color="#ff6060">1</font> - <font color="#808000">$8</font> ); <br> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> WHILE N <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> M OP2 <font color="#ff40ff">{</font> fix( <font color="#808000">$6</font> , command::jz, <font color="#808000">$4</font> , emit(command::jz, <font color="#ff6060">0</font> , <font color="#808000">$2</font> -pcode.size()- <font color="#ff6060">1</font> ) - <font color="#808000">$6</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">OP:</font> OP1 | OP2 ; <font color="#8080ff">// no action</font> <br> <br> <font color="#7f9fbf">M:</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = emit(command::hlt, <font color="#ff6060">0</font> , <font color="#ff6060">0</font> ); <font color="#ff40ff">}</font> <font color="#8080ff">// dummy</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">N:</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = pcode.size(); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">EXPR:</font> EXPR1 <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> ID <font color="#ff6060">'='</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$3</font> ; <br> <font color="#808000">if</font> (vars[ <font color="#808000">$1</font> ]) <br> emit(command::add, vars[ <font color="#808000">$1</font> ], <font color="#808000">$3</font> , <font color="#ff6060">0</font> ); <br> <font color="#808000">else</font> <br> vars[ <font color="#808000">$1</font> ] = <font color="#808000">$3</font> ; <font color="#8080ff">// new var</font> <br> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">EXPR1:</font> EXPR2 <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> EXPR1 EQ EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::eq, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 LE EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::le, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 GE EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::ge, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 NE EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::ne, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 <font color="#ff6060">'&gt;'</font> EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::gt, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR1 <font color="#ff6060">'&lt;'</font> EXPR2 <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::lt, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">EXPR2:</font> TERM <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> EXPR2 <font color="#ff6060">'+'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::add, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR2 <font color="#ff6060">'-'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::sub, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">TERM:</font> VAL <font color="#8080ff">// inherit</font> <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'*'</font> VAL <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::mul, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'/'</font> VAL <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::div, <font color="#808000">$$</font> , <font color="#808000">$1</font> , <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">VAL:</font> NUM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::mov, <font color="#808000">$$</font> , atoi( <font color="#808000">$1</font> .c_str())); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'-'</font> VAL <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::sub, <font color="#808000">$$</font> , <font color="#ff6060">0</font> , <font color="#808000">$2</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'!'</font> VAL <font color="#ff40ff">{</font> <font color="#808000">$$</font> = newreg(); emit(command::eq, <font color="#808000">$$</font> , <font color="#ff6060">0</font> , <font color="#808000">$2</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'('</font> EXPR <font color="#ff6060">')'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$2</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> ID <font color="#ff40ff">{</font> <font color="#808000">if</font> (vars[ <font color="#808000">$1</font> ]) <br> <font color="#808000">$$</font> = vars[ <font color="#808000">$1</font> ]; <br> <font color="#808000">else</font> <br> yyerror( <font color="#ff6060">"Undefined variable"</font> ); <br> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> ID <font color="#ff6060">'('</font> ARGS <font color="#ff6060">')'</font> <font color="#ff40ff">{</font> <font color="#808000">if</font> (! <font color="#808000">$1</font> .compare( <font color="#ff6060">"input"</font> )) <font color="#ff40ff">{</font> <br> <font color="#808000">if</font> ( <font color="#808000">$3</font> .size()) <br> yyerror( <font color="#ff6060">"Input: too many arguments"</font> ); <br> <font color="#808000">$$</font> = newreg(); <br> emit(command::input, <font color="#808000">$$</font> , <font color="#ff6060">0</font> ); <br> <font color="#ff40ff">}</font> <font color="#808000">else</font> <font color="#808000">if</font> (! <font color="#808000">$1</font> .compare( <font color="#ff6060">"echo"</font> )) <font color="#ff40ff">{</font> <br> <font color="#808000">if</font> (! <font color="#808000">$3</font> .size()) <br> yyerror( <font color="#ff6060">"Input: too many arguments"</font> ); <br> <font color="#808000">$$</font> = <font color="#ff6060">0</font> ; <br> foreach(i, <font color="#808000">$3</font> ) <br> <font color="#808000">if</font> (!i- <font color="#808000">&gt;</font> dest) <font color="#8080ff">// string</font> <br> strings[i- <font color="#808000">&gt;</font> str].push_back(emit(command::echo, <font color="#ff6060">0</font> , <font color="#ff6060">0</font> )); <br> <font color="#808000">else</font> <br> emit(command::echo, i- <font color="#808000">&gt;</font> dest, <font color="#ff6060">0</font> ); <br> <font color="#ff40ff">}</font> <font color="#808000">else</font> <br> yyerror( <font color="#ff6060">"Undefined function"</font> ); <br> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">ARGS:</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> .clear(); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> ARG <font color="#ff40ff">{</font> <font color="#808000">$$</font> .clear(); <font color="#808000">$$</font> .push_back( <font color="#808000">$1</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> ARGS <font color="#ff6060">','</font> ARG <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> ; <font color="#808000">$$</font> .push_back( <font color="#808000">$3</font> ); <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">ARG:</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> .dest = <font color="#808000">$1</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> STRING <font color="#ff40ff">{</font> <font color="#808000">$$</font> .str= <font color="#808000">$1</font> ; <font color="#808000">$$</font> .dest= <font color="#ff6060">0</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#008000">int</font> main() <font color="#ff40ff">{</font> <br> yyparse(); <br> <font color="#008000">int</font> offset = pcode.size()* <font color="#808000">sizeof</font> (command); <br> foreach(i, strings) <font color="#ff40ff">{</font> <br> foreach(j, i- <font color="#808000">&gt;</font> second) <font color="#8080ff">// all refs</font> <br> pcode[*j].imm = offset; <br> offset += i- <font color="#808000">&gt;</font> first.length(); <br> offset++; <br> <font color="#ff40ff">}</font> <br> foreach(i, pcode) <font color="#8080ff">// dump code</font> <br> write( <font color="#ff6060">1</font> , &amp;*i, <font color="#808000">sizeof</font> (*i)); <br> foreach(i, strings) <font color="#8080ff">// dump strings</font> <br> write( <font color="#ff6060">1</font> , i- <font color="#808000">&gt;</font> first.c_str(), i- <font color="#808000">&gt;</font> first.length()+ <font color="#ff6060">1</font> ); <br> <br> <font color="#ff40ff">}</font> <br></code> <br>  The compiler code is almost halved, and it compiles the same way as before. <br>  If there is no difference, why write more? </div><p>Source: <a href="https://habr.com/ru/post/99592/">https://habr.com/ru/post/99592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99582/index.html">Library for working with Blu-Ray from the creators of VLC</a></li>
<li><a href="../99583/index.html">Operation</a></li>
<li><a href="../99584/index.html">Nokia began searching for a new CEO</a></li>
<li><a href="../99589/index.html">ASP.NET MVC: My Rules for Views</a></li>
<li><a href="../99590/index.html">Droider Chart. Release 10</a></li>
<li><a href="../99594/index.html">Electrons in silicon dispersed to 0.3% of the speed of light</a></li>
<li><a href="../99595/index.html">Compilation. 7: register assignment</a></li>
<li><a href="../99597/index.html">ITrack's CMS Rating - Results of Distribution of Market Shares for the II Quarter of 2010</a></li>
<li><a href="../99598/index.html">Vim 7.3 public beta released</a></li>
<li><a href="../99599/index.html">HP has applied for registration of the trademark "PALMPAD"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>