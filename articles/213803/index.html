<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Full featured SDHC memory card driver for Stm32f4 (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is this article for? 
 All embeds, sooner or later, face the problem of the lack of a microcontroller's ROM for their projects. Well, trite, you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Full featured SDHC memory card driver for Stm32f4 (part 1)</h1><div class="post__text post__text-html js-mediator-article"><h4>  What is this article for? </h4><br>  All embeds, sooner or later, face the problem of the lack of a microcontroller's ROM for their projects.  Well, trite, you need to develop a control system for a simple CNC machine, where the control program is stored on the device itself or a data acquisition system, say, from sensors from some experiment - it is obvious that the microcontroller was not originally intended to store such arrays of information. <a name="habracut"></a><br><br>  There are a lot of solutions of this case, ranging from the acquisition and connection of EEPROM chips to a standard USB flash drive to a USB hardware stone host (if there is one, of course).  Well, for hand-made projects, the best option would be the most classic SD card memory card.  They come in different types, have different initialization and data transfer mechanisms and connect to the host through various interfaces (however, only three of them, but more on that later).  Moreover, many modern microcontrollers have hardware modules of these interfaces on their boards, and the work of the developer is reduced only to their configuration and sending the necessary commands to the card in accordance with the protocol.  Well, even memory cards have a pleasant property to be bought at every turn. <br><br><h4>  About Secure Digital (SD) Cards </h4><br>  I will not rewrite Wikipedia - here I will provide basic information and types of SD memory cards and their characteristics. <br>  <b>Secure Digital format</b> is the most popular (perhaps the most popular today) format of flash memory for use mainly in portable devices.  Inside each such card there is, in fact, a flash memory chip (Memory Core) and a controller with 8 registers connecting it with the outside world.  The tasks of the latter are hardware implementation of external interfaces, support of information about the card (type, capacity, speed class, a bunch of other characteristics), power control, and, of course, management of the mikrukha memory itself (addressing, reading, writing, cleaning and organizing about 80 control commands ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/d01/077/f9e/d01077f9e62e22b537edea45334fcd20.png"><br><br>  The SD format was founded by Panasonic, SanDisk and Toshiba based on MMC cards.  Later, these companies created the SD Card Association, which is currently engaged in the development and promotion of SD technology.  The main document, which describes in detail the interface, protocol, commands, card registers - the <b>Physical Layer Simplified Specification</b> (Copyright 2001-2006 SD Group (Panasonic, SanDisk, Toshiba) and SD Card Association).  It is this information that all R &amp; D centers use when developing the hardware and software of their future devices.  The file itself is safely available in the internet, and download it does not provide any difficulties.  So, in accordance with this document, there are the following types of memory cards: <br>  ‚Ä¢ <b>SD</b> cards (or else SDSC (Secure Digital Standard Capacity)) - the first generation of memory cards.  The limit on the volume - 2 GB.  The minimum size of the addressable space is 1 byte. <br>  ‚Ä¢ <b>SDHC</b> cards (Secure Digital High Capacity) - high-capacity memory cards (up to 32 GB).  They have a significant difference from the first type, namely, addressing occurs in blocks of 512 bytes and no one in this world can change this value.  In other words, you can‚Äôt just take and write, for example, 71 bytes of information: the minimum size of a pack, I repeat, is 512 bytes.  I didn‚Äôt dig for why, but there is a personal opinion that this is due to the used 32-bit address space of the controller and the fact that memory cards are usually formatted for a particular file system, the cluster size of which is conveniently combined with such blocks. .  Another SDHC card arc initialization process, which will talk a bit later on. <br>  ‚Ä¢ <b>SDXC</b> (Secure Digital eXtended Capacity) - Extended Capacity Memory Cards - theoretically up to 2TB of memory.  Addressing is also 512 bytes.  So it turns out with 32-bit space: (2 ^ 32) * 512 = 2 TB. <br><br>  There are specifications for each generation of maps, and at the same time in each document for a newer generation, the information about the old ones is described - that is, they get fat with each update of the product.  So download the Physical Layer Simplified Specification of the latest version and find everything you need to work with all generations of cards.  In addition, memory cards are divided into several classes according to the speed of reading / writing data.  Well, as for all there mini-, microSD, microSDXC, etc.  - this is just another body size and pinout - no internal differences from the standard envelope cards. <br><br>  <b>And now it‚Äôs important:</b> OUTSIDE, depending on the card type, capacity, its manufacturer, body type, color, and the store where you bought it - all Security Digital cards have the same interface with the outside world.  Commands, initialization mechanisms are different, yes, but the interfaces are the same.  This is exactly what allows napofig to insert a SD card and a SDHC memory card into a camera.  Well, here we are at the moment to discuss the language of the card, to be exact, as many as three: <b>SD</b> and <b>UHS-II</b> (native speaker) and ‚Äúthe language of universal microprocessor communication, which every <s>uncut dog</s> microcontroller now knows‚Äù - <b>SPI</b> . <br><br><h4>  Memory card interface </h4><br>  As mentioned above, Security Digital cards have three external interfaces: SD, UHS-II and SPI.  The first are the ‚Äúnative‚Äù data exchange channels with the host, and, as a result, allow you to implement full-featured, full-speed interaction.  SPI does not support a number of commands and does not give the maximum data exchange rate, but it is in all microcontrollers (both in modern and old models), which makes it possible to connect a card to everything that does not lie badly without any special problems.  There are lots of articles on how to do this.  But, with the development of microprocessor technology, with the reduction of nanometers in the technological process of stone production, the SPI interface, as a means of communication with an SD card, is gradually dying out.  Indeed, if your MC supports a hardware implementation of the SD protocol, will you get involved in a less functional alternative?  Fate sent me a Stm32f4 stone from STMicroelectronics to the project, in which there is just the same peripheral module SDIO (Security Digital Input Output), which implements the interface and card protocol in hardware. <br><br>  So what is the SD protocol and what is it eaten with?  There are three key concepts here: <br>  ‚Ä¢ <b>command</b> - a sequence of bits perceived by the card controller and calling it for a particular action; <br>  ‚Ä¢ <b>response</b> - the response of the card controller to the command.  It can contain both general information (card status, current state of various internal modules, etc.), and, in fact, the information expected by the host (requested the card ID in the command ‚Äî received it in response); <br>  ‚Ä¢ <b>data</b> - well, here without comments. <br><br>  But before we look at the logic of the protocol, we turn to the interface physics (very clear). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43e/148/cd7/43e148cd7223fe7c75fcf094f55a6e8e.jpg"><br>  Pin 4 - card power; <br>  Pin 3, 6 - land; <br>  Pin 5 - clock signal; <br>  Pin 2 - a line of commands and responses; <br>  Pin 1, 7, 8, 9 - lines 4-bit data bus. <br><br>  All parcels to the card and back are sequences of bits strictly synchronized with the clock signal transmitted through the <b>CLK</b> line.  Recommended frequencies are described in the card specification and have different meanings, depending on its type and speed class.  I will only note that for any card initialization takes place at a very small (compared to data transmission) frequency.  The data bus can be <b>1-bit</b> (only D0 works) or <b>4-bit</b> ‚Äî this is configured at initialization.  It is important that for the SD cards from the host side, the data lines and commands must be <b>push-pull</b> and <b>be powered up through 4.5-10 kŒ© resistors.</b>  The clock bus <b>also</b> needs to be pulled up to power. <br><br><h5>  Well, now to the protocol! </h5><br>  There are several options for exchanging host card information. <br><br>  <u>1) Commands without data.</u> <br>  All teams are divided into <b>requiring</b> and <b>not requiring a response</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/438/48c/897/43848c89714048a608821f7da77163ee.png"><br><br>  As can be seen from the figure, if we (the host) need to send a command that does not require a response, just send it off.  If, however, the team implies a response, a helmet, and then wait for a response.  Almost all commands and responses are checked by checksum, both from the host side and from the card side.  Well, look at the format of the command: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0b/7d1/fff/f0b7d1fff857f9727146cc394b0ca288.png"><br><br>  The frame consists of 48 bits.  The first one - the start bit is always zero.  Then, we say that the data is sent from the host to the map and send a command with an argument.  Yes, yes, the command consists of an index and an argument.  After the command, it is necessary to send a 7-bit checksum, calculated according to the cyclic redundancy code (CRC) algorithm, and complete the sending with a stop bit.  Commands are of two types: <b>CMD (basic commands)</b> and <b>ACMD (Application-Specific Command)</b> .  They can be with and without argument, have a response and not have.  In total there are about 80 teams (did not count exactly, maybe more), and each of them is described in detail in the specification.  We will focus only on a few, which are necessary for the main work with the card (initialization, reading, writing).  The command index is the number that comes after the characters CMD or ACMD.  6 bits and 32 bits of the command argument are reserved for it, if required. <br><br>  <b>An important explanation about ACMD</b> : the space of their indices intersects with the indexes of the CMD commands, therefore, in order for the controller to perceive the command exactly as Application-Specific, it must be preceded by <b>CMD55</b> ! <br><br>  <b>Response (if required)</b> is also a whole topic, at least, because there are five types of them. <br><br>  ‚Ä¢ <b>R1 (normal response command)</b> - length 48 bits.  Perhaps the most popular response. <br><img src="https://habrastorage.org/getpro/habr/post_images/ed3/2d4/364/ed32d43643f56a686bbe7fcbffee42c8.png"><br>  It contains the start bit, the transmission direction bit (from card to host), 6 bits of the command index that prompted the response, the <b>status of the card</b> and, of course, the checksum with a stop bit.  All information in the response of this type is carried by a <b>32-bit card status field</b> .  The specification describes carefully and in good faith what each bit of this status means (the card is busy / free, blocked / unlocked, the current state of the data transfer machine, readiness for a particular action, and much more). <br><br>  ‚Ä¢ <b>R1b</b> - the same format as in the case of R1 response, only transmits another busy flag (busy) on the data line. <br><br>  ‚Ä¢ <b>R2 (CID, CSD register)</b> - 136-bit-long response sends the contents of the CID and CSD registers of the card controller to the host. <br><img src="https://habrastorage.org/getpro/habr/post_images/c79/c22/dfa/c79c22dfa2ac865ad5fce2782c6c1a50.png"><br>  Here, all useful information is contained in a 127-bit field, into which either the content of the <b>CID</b> is placed (in case it is a response to the CMD2 or CMD10 command), or the contents of the <b>CSD</b> register (in the case of sending a CMD9 command).  So what are these registers such that special teams are invented for them, and with such a long response? <br>  <b>CID (Card identification data)</b> - as the name implies, contains all identification information about the card (serial number, manufacturer, date of manufacture, etc ...).  <b>CSD (Card-specific data)</b> - all technical information about the card (memory size, size of read / write blocks, maximum speed characteristics, maximum characteristics of current consumption in various modes, and much more).  It is this information that the mobile or camera host uses to get all the information about the inserted card. <br><br>  ‚Ä¢ <b>R3</b> - 48 bits long, comes as a response to the ACMD41 command and carries information about the contents of the OCR (Operation Conditions Register) of the card register. <br><img src="https://habrastorage.org/getpro/habr/post_images/64b/d51/098/64bd5109850f1e1b8a2eb8f3464784b1.png"><br>  ACMD41 - card initialization command.  After sending it, you must wait for this response, which will indicate the successful completion of the initialization process and report the contents of the <b>OCR</b> register (available voltage range, type of memory card, and busy flag). <br><br>  ‚Ä¢ <b>R6 (Published RCA response)</b> - contains <b>RCA (Relative card address)</b> cards and some status bits. <br><img src="https://habrastorage.org/getpro/habr/post_images/a3a/fa9/974/a3afa99740ae49763c0d96bc33a56bb9.png"><br>  The bus involves connecting multiple cards to the same host.  Therefore, it is very important such a thing as your own card address on the bus.  This is the contents of the <b>RCA</b> register. <br><br>  ‚Ä¢ <b>R7 (Card interface condition)</b> - 48-bit response to the command CMD8. <br><img src="https://habrastorage.org/getpro/habr/post_images/ade/27f/4f2/ade27f4f255c54039dfe616113db65d3.png"><br>  The card operates with a certain voltage, no more no less.  Before initialization, it is necessary to <b>validate</b> (more on this later).  In response, the card sends the voltage itself (more precisely, the value corresponding to this range) and a certain check pattern (this will also be discussed later). <br><br>  <u>2) Data.</u> <br>  Let me remind you (it was said a long time ago ...), we considered the sending of commands and receiving a response from the card.  Now it's time to figure out how to send, in fact, the data.  Again, this is done in <b>blocks of 512 bytes</b> (for SDHC cards) - the entire address space of the card is divided into <b>512 byte cells</b> .  Sending data should always be preceded by a special command telling the card controller that the data is just about to go.  And they go, as I said - on a 1-bit or 4-bit bus.  Let's look at the format of sending data to the host from the card (read). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c3/535/52d/1c353552d4f8793474d00f89cf6ea864.png"><br><br>  There are two possible data transfer modes: one block (block read operation) and several blocks at once (multiple block read operation).  In any case, the start of the transfer and its completion take place on a special command, note with a response. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d4/d4f/13d/8d4d4f13dd1e5154bcfa6c19a64f36f9.png"><br><br>  The reverse procedure (write) is carried out in a similar way, only between packs the busy is necessarily present, signaling that the card is not ready to accept the next block (the data have not yet been written to the flash cards). <br><br><h4>  <b>Initializing SD Memory Cards</b> </h4><br>  Well, we, embeds, people are used to everything that needs to be initialized, so the SD card is not an exception to this magnificent rule.  You need to check the supported voltages, assign addresses, and generally, make sure that we can work with this card.  Let's take a look at the initialization algorithm pulled out of the specification and go through it in order, block by block, in order to understand what needs to be done with the device before using it for its intended purpose. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b94/f95/5c6/b94f955c60bf21b9a4aa7e15da79c512.png"><br><br>  <b>IMPORTANT</b> : initialization is performed at low speed mode!  The frequency of the card clock is not more than 400 kHz !!! <br><br>  <b>MORE IMPORTANT</b> : after powering up, do not rush to load the card with commands, let the voltage settle down, wait 250 milliseconds (a little longer, depending on the number of cards connected to one bus, data line width and power supply parameters).  As soon as the voltage reached the required level, all parasitic capacitances, etc. were charged.  etc., you can create an initialization process.  And it begins with resetting all the cards and transferring them to Idle State. <br><br>  ‚Ä¢ Helmet <b>CMD0</b> , pay attention, without an argument and do not expect anything in the response.  As a result, all the cards on the line will be transferred to idle mode. <br><br>  ‚Ä¢ Remember, I said that stress needs to be validated?  Right!  We need to tell the map what voltage we are working on and listen to everything about it.  A <b>CMD8</b> helmet with an argument in which bits <b>11: 8</b> denote host voltage and bits <b>7: 0</b> - <b>check pattern (test pattern)</b> - any, the specification recommends sending <b>10101010</b> .  The voltage bits are set in accordance with the table: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/c95/778/f03c957783dc110e9a03ace2fe607f2e.png"><br><br>  Well, we are all very well defined and far from Low Voltage Range.  Stm32f4 gives just the voltage in the range 2.7 - 3.6 V, so we put 1 on the eighth bit of the argument.  Total, we have a command with argument <b>110101010</b> .  Sent.  We checked that everything went well and we are waiting for an answer, it will not make us do it for a long time.  In the specification, we saw that the answer to this command is the <b>R7</b> type. <br>  If we did not wait for it, the further <b>ACMD41</b> team <b>will</b> decide exactly how we were cheated - slipped the card of version 1.X of standard capacity or not an SD card at all.  True, there is a possibility that we are just doing something wrong.  But let's not talk about sad things, and suppose that the flash drive still answered.  If everything is OK with the voltage, the map is satisfied, we are satisfied, the answer will contain everything that we sent in the argument, that is, <b>110101010</b> .  This is called a <b>valid esponse</b> .  If so, proceed to a further step, otherwise - again - either cheated, or somewhere cant. <br><br>  ‚Ä¢ <b>We waited for 110101010</b> , and it was time to directly initialize - the <b>ACMD41 command</b> .  And here we remember <b>IMPORTANCE</b> : in <b>order to tell the card that the command is not simple, but ACMD, we will send CMD55 first</b> .  In the argument we must indicate the address of the card for which this command is intended.  But stop, we have, because, while there is no address, we do not know him.  Nothing, we learn ... but later, but for now we write zeros and a helmet.  Having received the answer of type <b>R1</b> , we make sure that the card is ready to accept ACMD and only after that helmet <b>41</b> index!  The command comes with an argument in which we specify 1 in place of the <b>30th</b> bit, indicating that the host supports SDHC cards and the host voltage in place of <b>23: 0</b> bits (see the contents of the OCR register).  The answer is waiting for <b>R3</b> type.  Here it is important for us to get <b>1</b> in place of the <b>31st</b> bit in the response packet that carries the contents of the <b>OCR</b> of the card register (busy flag).  This will indicate that the card has completed the initialization process.  Seeing that this process takes a long time (much longer than the clock cycle of the microcontroller), it is necessary to send ACMD41 in a loop until we receive a response with the busy flag removed.  As soon as this happened, checks are <b>30</b> bits, and if it is one, then we have an SDHC or SDXC high capacity card, and an SD standard capacity card otherwise.  If we waited, waited, and the bizi flag all hangs and hangs, then, as in the case described above, either the wrong card or (most likely) our joint. <br><br>  ‚Ä¢ Further, <b>CMD2</b> helmet - without an argument and look at the answer <b>R2</b> .  In this case, it will carry information about the contents of the <b>CID</b> register, and we will be able to subtract the manufacturer's ID, serial number of the card and other information. <br><br>  ‚Ä¢ And finally, the final step is getting the card address ( <b>RCA - relative</b> <b><br></b>  <b>address</b> ).  As it was already mentioned, several cards can be connected to one bus, so each one should have its own unique local address.  Helmet <b>CMD3</b> and get a response type <b>R6</b> , in which <b>in the lower 16</b> bits contains the status of the card, and <b>in the older</b> - the new RCA address.  From now on, to access our card, we will have to call her by name, that is, by RCA address. <br><br>  ‚Ä¢ Optional item.  By default, the card works with a 1-bit data bus, which, of course, is slower than with a 4-bit data bus.  If we want to achieve maximum speed - helmet <b>ACMD6</b> , with the previous <b>CMD55</b> , of course.  But before that, you need to transfer the card to the <b>Transfer State</b> (see below) with the command <b>CMD7</b> with RCA as an argument.  In the <b>ACMD6</b> argument <b>,</b> in place of the very first bit, we write <b>1</b> - if we want to enable the 4-bit mod and <b>0</b> - to disable it.  Answer <b>R1</b> will tell about the success of the operation. <br><br><h5>  SDHC card initialization example </h5><br>  In this example, a self-made command sending function is used, written under the periphery of Stm32F4. <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDIO_send_command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resp_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *resp)</span></span></span></span>;</code> </pre> <br>  ‚Ä¢ index - command index; <br>  ‚Ä¢ arg - argument; <br>  ‚Ä¢ resp type - response type (0 - no response, 1 - short (48 bit) response, 2 - long (136 bit) response); <br>  ‚Ä¢ resp - array of responses (in the case of a short response, the information is carried by the first element of the array, in the case of a long one - 4 elements). <br>  ‚Ä¢ The command returns 0 if the command was sent successfully and received a response and an error code otherwise. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDHC_card_initialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *RCA)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RESP[<span class="hljs-number"><span class="hljs-number">4</span></span>]; result = SDIO_send_command(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, RESP); <span class="hljs-comment"><span class="hljs-comment">// CMD0,    if (result != 0) return result; //   result = SDIO_send_command(8, 0x1AA, 1, RESP); // CMD8   110101010 if ( (result != 0) || (RESP[0] != 0x1AA) ) return 4; //   while( !(RESP[0]&amp;(1&lt;&lt;31) ) ) //,      { result = SDIO_send_command(55, 0, 1, RESP); // CMD55,  , ,    ACMD if (result != 0) return result; result = SDIO_send_command(0x29, 0x40020000, 1, RESP); // ACMD41 if (result != 0) return result; } result = SDIO_send_command(2, 0, 3, RESP); // CMD2      if (result != 0) return result; result = SDIO_send_command(3, 0, 1, RESP); // CMD3   RCA  if (result != 0) return result; SDIO-&gt;CLKCR = (0x02&lt;&lt;0)|(1&lt;&lt;11)|(1&lt;&lt;8)|(1&lt;&lt;14); //  (  2 - ) *RCA = ( RESP[0] &amp; (0xFFFF0000) ); //    RCA result = SDIO_send_command(7, *RCA, 1, RESP); //   if (result != 0) return result; result = SDIO_send_command(55, *RCA, 1, RESP); // CMD55,  , ,    ACMD if (result != 0) return result; result = SDIO_send_command(6, 0x02, 1, RESP); // ACMD6 c  0x02,  4-  if (result != 0) return result; if (RESP[0] != 0x920) return 1; else return 0; //,         return 0; }</span></span></code> </pre><br>  We start the code, we are convinced that in the answer the NULL came and we complete initialization.  Everything, we can work with memory and write / read information. <br><br><h4>  <b>Data exchange</b> </h4><br>  Here all drives <b>SD Memory Card State Diagram (data transfer mode).</b> <br><img src="//habrastorage.org/files/24c/646/618/24c646618e3846339f426c3ce8695efa.png"><br>  There are 6 card statuses in this mode and you can recognize them in the <b>R1</b> response in the place of <b>12: 9</b> bits.  Refer to the specification. <br><img src="//habrastorage.org/files/a86/221/cd2/a86221cd2617448799fc83c4d842ddc3.png"><br>  ‚Ä¢ <b>Stand by State (stby)</b> - set after initialization instead of Idle State. <br>  ‚Ä¢ <b>Transfer State (tran)</b> - data transfer mode. <br>  ‚Ä¢ <b>Receive Data State (rcv)</b> - waiting for a packet of data from the host. <br>  ‚Ä¢ <b>Programming State (prg)</b> - record of the received packet in flash. <br>  ‚Ä¢ <b>Sending Data State (data)</b> - sending a packet of data to the host. <br>  ‚Ä¢ <b>Disconnect State (dis)</b> - used to select another card with the CMD7 command. <br><br><h5>  Write data to the card </h5><br>  So, after successful initialization, we are in a state of <b>tran</b> , in any case, should be.  We look at the diagram: in order to go to the <b>rcv</b> state, we need to send the CMD24 command with the address of 512 byte cells, which we want to write.  Have sent.  The card went into standby data.  Next, we start to throw information to it on the data bus until we transfer all 512 bytes or send the CMD12 (stop transmission) command.  After the completion of the act, the card itself will move to the <b>prg</b> state and stay there for some time (until the data is written).  We are waiting ... How do we wait?  And we send it in the cycle CMD13 with the address of the card in the argument, until the status <b>tran</b> is returned in the R1 type <b>response</b> .  When it finally happens, you can send another packet of data by sending CMD24 again.  In addition, there is also a recording mode for several blocks at once (CMD25) and other modes - for details - in the specification. <br><br><h5>  Reading data </h5><br>  In order to perform the reverse procedure, first of all, we make sure that the card is in <b>tran</b> .  Helmet CMD17 with RCA address in argument.  If everything goes well, the card will move to the <b>data</b> state and will start issuing information on the data lines, again with a 512 byte block.  The task of the host at this time carefully listen to the line and read the data.  As soon as the parcel is finished, the card itself will move to <b>tran</b> status.  I think it‚Äôs not necessary to say that reading as well as writing is possible in several blocks at once. <br><br>  I will not give in this article a listing of the read / write program, since, unlike the initialization subroutine, it is too strongly tied to the <b>SDIO</b> hardware of the Stm32f4 microcontroller module, and this is the topic of the second part of the article. <br><br>  <i>Literature:</i> <br>  1) <a href="http://www.users.ece.utexas.edu/~valvano/EE345M/SD_Physical_Layer_Spec.pdf%25E2%2580%258E">SD_Physical_Layer_Spec 2.0</a> <br>  2) <a href="https://www.sdcard.org/downloads/pls/simplified_specs/part1_410.pdf%25E2%2580%258E">SD_Physical_Layer_Spec 4.1</a> <br>  3) STM32F4 CortexM4 Reference manual </div><p>Source: <a href="https://habr.com/ru/post/213803/">https://habr.com/ru/post/213803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213791/index.html">Valentine's day gift for 4 nights and 1 day</a></li>
<li><a href="../213795/index.html">SmartWatch for Vasya Engineer</a></li>
<li><a href="../213797/index.html">We program robots on Windows 8. Sphero magic ball</a></li>
<li><a href="../213799/index.html">Future Sales: Cyber ‚Äã‚ÄãEyes for a Manager</a></li>
<li><a href="../213801/index.html">Several useful CSS tricks</a></li>
<li><a href="../213805/index.html">Lambda Expressions in Java 8 - Simple examples of how they can make your life easier</a></li>
<li><a href="../213807/index.html">The theory of human memory, the beginnings of AI</a></li>
<li><a href="../213809/index.html">C # Events Humanly</a></li>
<li><a href="../213811/index.html">The video recorded the most powerful collision of a meteorite with the Moon.</a></li>
<li><a href="../213813/index.html">7 Tricks for Working with Arrays in Ruby</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>