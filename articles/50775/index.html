<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ MythBusters. Intended Functions Myth</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. 

 Thanks to this vote, it turned out that Habr√© lacks articles on such a powerful, but less and less used C ++ language. High-level profession...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ MythBusters. Intended Functions Myth</h1><div class="post__text post__text-html js-mediator-article">  Hello. <br><br>  Thanks to <a href="http://habrahabr.ru/blogs/cpp/47734/" title="Is there a place for C ++ on habrahabr?">this</a> vote, it turned out that Habr√© lacks articles on such a powerful, but less and less used C ++ language.  High-level professionals, gurus, wizards and wizards of the C ++ language, as well as those who have already managed to leave this language ‚Äúbehind‚Äù can no longer be read.  Today I want to start a series of articles designed to help the newcomers, who <u>relatively</u> recently started learning this language, or those who (God forbid) read few books, but try to learn everything only in practice. <br><br>  I also hope to involve as many authors as possible in writing such articles, because my experience here will not be enough. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h5>  Lyrical digression </h5><br><br>  A few words about the title, designed to combine articles of this kind.  It, naturally, did not appear by chance, however, and does not quite fit the essence. <br><br>  My articles will be designed for those who are already more or less familiar with the C ++ language, but who have little experience in writing programs on it.  I will not write manuals or "introductory" manuals in the spirit of "buckets", "cups", "ounces", etc.  Instead, I will try to cover some of the ‚Äúnarrow‚Äù and not always and not quite obvious places of the C ++ language.  What is meant?  I have repeatedly encountered, both by my own example and when communicating with other programmers, cases when a person was sure that he was right about some possibility of C ++ language (sometimes quite a long time), and later it turned out that he was deeply and irrevocably mistaken for one God known reasons. <br><br>  And the reasons are not really supernatural.  Often the human factor plays its role.  For example, after reading a book for beginners, in which, as you know, many nuances are not explained, and sometimes not even mentioned, in order to simplify the perception of the foundations of the language, the reader <em>thinks out the</em> missing things on his own for reasons a la ‚ÄúI think this is logical ".  From here there are crumbs of misunderstandings, sometimes leading to rather serious mistakes, well, and in most cases they simply hinder the successful completion of various kinds of C ++ competitions :) <br><br><h5>  So, the first myth </h5><br><br>  As you know, in C ++ there is the possibility of declaring <em>inline</em> functions.  This is achieved by using the inline keyword.  In the place where such functions are called, the compiler will not generate the call command (with the parameters pre-pushed onto the stack), but simply copy the function body to the call site with the corresponding parameters ‚Äúin place‚Äù (in the case of class methods, the compiler will also substitute the necessary address this, where used).  Naturally, inline is just a recommendation to the compiler, not an order, however, if the function is not too complicated (a rather subjective concept) and the code does not perform operations like taking the address of a function, etc., then most likely the compiler will do exactly that waiting for the programmer. <br><br>  The substituted function is declared quite simply: <br><br> <code><font color="black"><font color="#0000ff">inline</font> <font color="#0000ff">void</font> foo <font>(</font> <font color="#0000ff">int</font> <font color="#000040">&amp;</font> _i <font>)</font> <br> <font>{</font> <br> _i <font color="#000040">++</font> <font color="#008080">;</font> <br> <font>}</font></font></code> <br> <br>  But it is not about that now.  We will look at using inline class methods.  And we begin with a small example, the fault of which can lead to this myth. <br><br>  You all know that <strong>class method definitions can be written both outside the class and inside, and inline functions are no exception</strong> .  Moreover, the functions defined directly inside the class automatically become substitutable, and the inline keyword in this case is unnecessary.  Consider an example (I use struct instead of class only in order not to write public): <br><br> <code><font color="black"><font color="#666666">// InlineTest.cpp</font> <br> <br> <font color="#339900">#include &lt;cstdlib&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">struct</font> A <br> <font>{</font> <br> <font color="#0000ff">inline</font> <font color="#0000ff">void</font> foo <font>(</font> <font>)</font> <font>{</font> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"A::foo()"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <font>}</font> <br> <font>}</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">struct</font> B <br> <font>{</font> <br> <font color="#0000ff">inline</font> <font color="#0000ff">void</font> foo <font>(</font> <font>)</font> <font color="#008080">;</font> <br> <font>}</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> B <font color="#008080">::</font> <font color="#007788">foo</font> <font>(</font> <font>)</font> <br> <font>{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"B::foo()"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font>}</font> <br> <br> <font color="#0000ff">int</font> main <font>(</font> <font>)</font> <br> <font>{</font> <br> A a <font color="#008080">;</font> B b <font color="#008080">;</font> <br> a. <font color="#007788">foo</font> <font>(</font> <font>)</font> <font color="#008080">;</font> <br> b. <font color="#007788">foo</font> <font>(</font> <font>)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000ff">EXIT_SUCCESS</font> <font color="#008080">;</font> <br> <font>}</font></font></code> <br> <br>  In this example, everything is fine, and on the screen we see the cherished lines: <br><br><blockquote>  A :: foo () <br>  B :: foo () <br></blockquote><br>  And the compiler really framed the bodies of the methods in the place of their calls. <br><br>  Finally we got to the essence of today's article.  The problems begin at the moment when we (observing the ‚Äúgood programming style‚Äù) divide the class into cpp- and h-files: <br><br> <code><font color="black"><font color="#666666">// Ah</font> <br> <br> <font color="#339900">#ifndef _A_H_</font> <br> <font color="#339900">#define _A_H_</font> <br> <br> <font color="#0000ff">class</font> A <br> <font>{</font> <br> <font color="#0000ff">public</font> <font color="#008080">:</font> <br> <font color="#0000ff">inline</font> <font color="#0000ff">void</font> foo <font>(</font> <font>)</font> <font color="#008080">;</font> <br> <font>}</font> <font color="#008080">;</font> <br> <br> <font color="#339900">#endif // _A_H_</font></font></code> <br> <br> <code><font color="black"><font color="#666666">// A.cpp</font> <br> <br> <font color="#339900">#include "Ah"</font> <br> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">void</font> A <font color="#008080">::</font> <font color="#007788">foo</font> <font>(</font> <font>)</font> <br> <font>{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"A::foo()"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font>}</font></font></code> <br> <br> <code><font color="black"><font color="#666666">// main.cpp</font> <br> <br> <font color="#339900">#include &lt;cstdlib&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include "Ah"</font> <br> <br> <font color="#0000ff">int</font> main <font>(</font> <font>)</font> <br> <font>{</font> <br> A a <font color="#008080">;</font> <br> a. <font color="#007788">foo</font> <font>(</font> <font>)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000ff">EXIT_SUCCESS</font> <font color="#008080">;</font> <br> <font>}</font></font></code> <br> <br>  At the linking stage, we get an error like this (depends on the compiler - I have MSVC): <br><br><blockquote>  main.obj: error LNK2001: unresolved external symbol "public: void __thiscall A :: foo (void)" (? foo @ A @@@ QAEXXZ) <br></blockquote><br>  Why?!  Everything is quite simple: the definition of the substituted method and its call are in different translation units!  I'm not quite sure how exactly this is done internally, but I see this problem like this: <br><br>  if this were the usual method, then in the translation unit main.obj the compiler would put something like call XXXXX, and later the linker would replace XXXXX with the specific address of the A :: foo () method from the translation unit A.obj (of course, I everything is simplified, but the essence does not change). <br><br>  In our case, we are dealing with an inline method, that is, instead of a call, the compiler must substitute the text of the method itself.  Since the definition is in a different translation unit, the compiler leaves this situation in the care of the linker.  There are two points here: firstly, ‚Äúhow much space should the compiler leave to substitute the body of the method?‚Äù, And secondly, the Aobu method in the A.obj translation unit is not used anywhere, and the method is declared as inline ( which means that where needed, the compiler had to copy the body of the method), so a separate compiled version of this method does not fall into the final object file at all. <br><br>  In confirmation of paragraph 2, I will give a slightly updated example: <br><br> <code><font color="black"><font color="#666666">// Ah</font> <br> <br> <font color="#339900">#ifndef _A_H_</font> <br> <font color="#339900">#define _A_H_</font> <br> <br> <font color="#0000ff">class</font> A <br> <font>{</font> <br> <font color="#0000ff">public</font> <font color="#008080">:</font> <br> <font color="#0000ff">inline</font> <font color="#0000ff">void</font> foo <font>(</font> <font>)</font> <font color="#008080">;</font> <br> <font color="#0000ff">void</font> bar <font>(</font> <font>)</font> <font color="#008080">;</font> <br> <font>}</font> <font color="#008080">;</font> <br> <br> <font color="#339900">#endif // _A_H_</font></font></code> <br> <br> <code><font color="black"><font color="#666666">// A.cpp</font> <br> <br> <font color="#339900">#include "Ah"</font> <br> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">void</font> A <font color="#008080">::</font> <font color="#007788">foo</font> <font>(</font> <font>)</font> <br> <font>{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"A::foo()"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font>}</font> <br> <br> <font color="#0000ff">void</font> A <font color="#008080">::</font> <font color="#007788">bar</font> <font>(</font> <font>)</font> <br> <font>{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"A::bar()"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> foo <font>(</font> <font>)</font> <font color="#008080">;</font> <br> <font>}</font></font></code> <br> <br> <code><font color="black"><font color="#666666">// main.cpp</font> <br> <br> <font color="#339900">#include &lt;cstdlib&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include "Ah"</font> <br> <br> <font color="#0000ff">int</font> main <font>(</font> <font>)</font> <br> <font>{</font> <br> A a <font color="#008080">;</font> <br> a. <font color="#007788">foo</font> <font>(</font> <font>)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000ff">EXIT_SUCCESS</font> <font color="#008080">;</font> <br> <font>}</font></font></code> <br> <br>  Now everything works as it should, due to the fact that the inline method A :: foo () is called in the non-configurable method A :: bar ().  If you look at the assembler code of the final binary, you can see that, as before, there is no separate compiled version of the foo () method (that is, the method does not have its own address), and the method body is copied directly to the call sites. <br><br>  How to get out of this situation?  Very simple: inline methods need to be defined directly in a header file (not necessarily inside a class declaration).  In this case, the re-definition error does not occur, since the compiler tells the linker to ignore ODR ( <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BE%25D0%25B4%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BE%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F" title="One Definition Rule">One Definition Rule</a> ) errors, <em>and the linker, in turn, leaves only one definition in the resulting binary file.</em> <br><br><h5>  Conclusion </h5><br><br>  I hope that at least someone my first article will be useful and will help to achieve a little complete understanding of such a strange and sometimes contradictory, but certainly interesting programming language like C ++.  Successes :) <br><br>  <strong>UPD.</strong>  In the process of communication with <a href="https://habrahabr.ru/users/gribozavr/" class="user_link">gribozavr</a> , some inaccuracy regarding ODR was revealed in my article.  Italicized. </div><p>Source: <a href="https://habr.com/ru/post/50775/">https://habr.com/ru/post/50775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../50767/index.html">History of words: Start-up is not a startup</a></li>
<li><a href="../50768/index.html">LiveJournal in Google Reader done right</a></li>
<li><a href="../50771/index.html">Hivext: Web services platform</a></li>
<li><a href="../50773/index.html">WebAmp Concept</a></li>
<li><a href="../50774/index.html">Do you want to die fast? .. Become a PM!</a></li>
<li><a href="../50776/index.html">Overview of Jabber clients under Windows</a></li>
<li><a href="../50778/index.html">Uzbek mobile phone. With tv</a></li>
<li><a href="../50784/index.html">World Intellectual Property Day</a></li>
<li><a href="../50787/index.html">Select a dedicated server. Underwater rocks.</a></li>
<li><a href="../50790/index.html">IBM Lotus Symphony 1.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>