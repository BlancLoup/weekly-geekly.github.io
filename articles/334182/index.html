<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rest in peace, REST. Long life GraphQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Transfer. Original Samer Buna. Original article . 
 When I first learned about GraphQL after a long use of various REST APIs, I could not resist tweet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rest in peace, REST. Long life GraphQL</h1><div class="post__text post__text-html js-mediator-article"><p></p><hr>  Transfer.  Original Samer Buna.  <a href="https://medium.freecodecamp.org/rest-apis-are-rest-in-peace-apis-long-live-graphql-d412e559d8e4">Original article</a> . <hr><br>  When I first learned about GraphQL after a long use of various REST APIs, I could not resist tweets with this content: <br><p>  <strong>Rest API has become a REST-in-Peace API.</strong>  <strong>Long life GraphQL</strong> </p><br><blockquote>  Translator's Note - Rest In Peace, RIP - a common epitaph "Rest in Peace".  The first word in it is written in the same way as the acronym REST. </blockquote><p>  Then it was an attempt to make laugh, but now I am convinced of the justice of the playful forecast. </p><br><p>  Understand correctly.  I'm not going to blame GraphQL for killing REST or something.  REST will never die, just as XML will live forever.  But who in their right mind would use XML instead of JSON?  In my opinion, GraphQL will do the same thing for REST as JSON has done for XML. </p><a name="habracut"></a><br><p>  This article is not one hundred percent agitation in favor of GraphQL.  For its flexibility you have to pay.  This is a separate section. </p><br><p>  I am an admirer of the approach. <a href="https://startwithwhy.com/">Start with the question WHY</a> , why do so. </p><br><h2 id="vkratce-zachem-graphql">  In short: Why GraphQL? </h2><br><p>  Here are the three most important issues GraphQL solves: </p><br><ul><li><p>  <strong>The need to apply several times for data to render a component</strong> .  GraphQL allows you to get all the necessary data for a single request to the server. </p><br></li><li><p>  <strong>Client dependency on server</strong> .  Using GraphQL, the client communicates in a universal query language, which: 1) eliminates the need for the server to rigidly specify the structure or composition of the returned data and 2) does not bind the client to a specific server. </p><br></li><li>  <strong>Ineffective ways to develop</strong> .  In GraphQL, developers describe the data required for an interface using a declarative language.  Developers are focused on what <em>they</em> want to get, not <em>how</em> to do it.  The data needed for the UI is closely related to how the same data is described in GraphQL. </li></ul><br><p>  The article details how GraphQL solves these problems. </p><br><p>  Let's start with a simple description for those who are not familiar with GraphQL. </p><br><h2 id="chem-yavlyaetsya-graphql">  What is GraphQL? </h2><br><p>  GraphQL is a <em>language</em> .  If you teach him an application, it will be able to declare the necessary backend information about the necessary data, which GraphQL also understands. </p><br><p>  As a child learns the language in childhood, and growing up is forced to put more effort into learning, so GraphQL is much easier to integrate into a newly created application than to integrate into a streamlined service. </p><br><p>  In order for the service to understand GraphQL, you need to create a separate level in the query processing stack and open access to it for customers who need to interact with the service.  This level can be considered a translator of the GraphQL language, or a GraphQL-understanding mediator.  GraphQL is not a data storage platform.  Therefore, it is not enough for us to simply understand the GraphQL syntax; we also need to translate queries into data. </p><br><p>  The GraphQL level, written in any programming language, contains a scheme ( <strong>schema</strong> ) similar to a graph or a communication diagram, from which customers will learn about the capabilities of the service.  Client applications familiar with GraphQL can make queries on this scheme in accordance with their own capabilities.  This approach separates clients from the server and allows them to evolve and scale independently. </p><br><p>  Queries in the GraphQL language can be either data queries - <strong>query</strong> (read operation), or mutations - <strong>mutation</strong> (write operations).  In both cases, the query is a regular string, which the GraphQL service parses, executes, and maps to the data in a specific format.  The common response format for mobile and web applications is JSON. </p><br><h2 id="chem-yavlyaetsya-graphql-obyasnenie-na-palcah">  What is GraphQL?  (explanation on fingers) </h2><br><p>  GraphQL does not go beyond data sharing.  There is a client and server to interact with.  The client should inform the server what data is needed, and the server should close this need with actual data.  GraphQL is in the middle of an interaction. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e6/bdb/662/5e6bdb66261fc363d5d3d4bd2e13e8bc.png" alt="image"></p><br><p>  Screenshot from my Pluralsight training course - Building Scalable APIs with GraphQL </p><br><p>  You ask why the client can not communicate with the server directly?  Of course it can. </p><br><p>  There are several reasons to use the GraphQL level between clients and servers.  Perhaps the most popular reason is <em>efficiency</em> .  Typically, the client receives many resources on the server, but the server gives one resource at a time.  Therefore, the client is forced to repeatedly contact the server to obtain all the necessary data. </p><br><p>  GraphQL shifts the complexity of multiple queries to server shoulders, let GraphQL do it.  The client sends a single request to the GraphQL level and receives a single answer, which contains everything that the client needs. </p><br><p>  There are many other advantages of GraphQL.  For example, an important advantage when interacting with multiple services.  When many clients request data from many services, the GraphQL level in the middle simplifies and standardizes the exchange of data. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/465/46a/88e/46546a88e5da874f2168a08c88ff3619.png" alt="image"></p><br><p>  Screenshot from my Pluralsight training course - Building Scalable APIs with GraphQL </p><br><p>  Instead of directly accessing the two services (on the previous slide), the client interacts with the GraphQL level, and that one already receives data from the services.  In this way, GraphQL eliminates the need for a client to support different APIs by converting a single client request into requests to several data providers in a language they can understand. </p><br><p>  Imagine three people speaking three different languages, and each has some information.  If you need to ask a question that requires combining the knowledge of all people, the help of a translator who speaks all three languages ‚Äã‚Äãwill greatly simplify the receipt of the answer.  This is exactly what GraphQL does. </p><br><p>  But computers are not yet so smart as to answer arbitrary questions on their own, and there must be algorithms somewhere.  That is why, at the GraphQL level, it is necessary to define a schema, which customers can use. </p><br><p>  The outline is basically a capability document that lists all the questions that a client can address at the GraphQL level.  The scheme can be used quite flexibly, since it is a graph of nodes.  In essence, the scheme limits what can be queried at the GraphQL level. </p><br><p>  Not quite clear?  Let's take a look at GraphQL, as a replacement for the REST API, which it actually is.  Let me answer the question that you are probably asking now. </p><br><h2 id="chto-ne-tak-s-rest-api">  What is wrong with the REST API? </h2><br><p>  The big problem with the REST API is the large number of endpoints.  This forces customers to make many requests to get the right data. </p><br><p>  REST API is a set of destination points, each of which corresponds to a resource.  If a client needs different resources, it is necessary to make several requests to collect all the necessary data. </p><br><p>  REST API does not offer the client a query language.  The client does not affect what data the server returns.  There is simply no language in which the client could indicate this.  More precisely, the means available to the client to influence the server are very limited. </p><br><p>  For example, a destination for a READ operation allows you to do one of two things: </p><br><ul><li> GET <code>/ResouceName</code> - get a list of records; </li><li>  GET <code>/ResourceName/ResourceID</code> - get the record by ID. </li></ul><br><p>  The client cannot specify, for example, which fields of the record he wants to take from this resource.  This information is protected in the REST service itself, and it will always return all the provided fields, regardless of which of them are needed by the client.  In GraphQL, this problem is called over-fetching information that is not required.  Overloading in vain loads the network and consumes memory on the client and server side. </p><br><p>  Another significant REST API problem is versioning.  The need to support multiple versions means new destinations.  This entails additional difficulties in the use and support of the API and may cause duplication of code on the server. </p><br><p>  GraphQL is designed to solve these problems.  Of course, these are not all the problems of the REST API, but I don‚Äôt want to delve into what the REST API is or is not.  Rather, talking about the conventional resource-oriented approach to the API based on HTTP destination points.  Over time, each such API turns into a jumble of ordinary destinations, as prescribed by REST, and special ones added for performance reasons.  And here the alternative in the form of GraphQL looks much better. </p><br><h2 id="chto-stoit-za-magiey-graphql">  What is behind GraphQL magic? </h2><br><p>  GraphQL is based on different ideas and architectural solutions, but perhaps the most important are the following: </p><br><ul><li><p>  GraphQL schema is strongly typed.  To create a scheme, set the <em>fields</em> (fields) of certain <em>types</em> (types).  These types can be primitives or user-defined types, but everything in the schema is typed.  A developed type system opens up possibilities such as introspection API, and allows you to create powerful tools for the client and server side. </p><br></li><li><p>  GraphQL describes data as a graph, because in fact the data set is a graph.  When you need to visualize data, a graph is the most appropriate structure.  GraphQL executable code saves this data representation through an API, in which the form of requests and responses reflects the inherent form of the graph. </p><br></li><li>  In GraphQL, it is customary to express the need for data declaratively.  For this, the client is given a declarative language.  The nature of declarativeness initially tunes to such an understanding of GraphQL language, which is close to the ways of thinking about data in the native language.  This greatly simplifies working with the GraphQL API compared to other approaches. </li></ul><br><p>  Thanks to the last point, I personally believe in the excellence of GraphQL. </p><br><p>  These are all high-level concepts.  Consider a little more. </p><br><p>  To solve the problem of multiple queries, GraphQL turns the server into a single destination.  In fact, GraphQL absolutizes the idea of ‚Äã‚Äãa custom destination and makes the entire server a point that can respond to any request. </p><br><p>  Another important idea is the presence of a developed query language due to which the client can work with a single destination.  Without such a language, there would be no point in limiting the number of destinations.  A language is needed to describe custom queries and return data. </p><br><p>  Clients manage the interaction using the query language.  They request what they need, and the server returns exactly what is requested.  This solves the problem of data reloading. </p><br><p>  GraphQL versioning is interesting.  Versioning can be completely abandoned.  In fact, you can add fields without deleting existing ones, because the data is a graph, and you can add nodes to it as you like.  Therefore, you can leave paths for old APIs and enter new ones without marking their version numbers.  Just the API has grown up. </p><br><p>  This is especially true for mobile clients, since it is impossible to directly tell them which version of the API to use.  The installed mobile application can use the old version of the API for many years.  There is no problem for the web, as you can simply replace the code of the web application on the server.  But it is much more difficult for mobile applications. </p><br><p>  Still not convinced?  What if we compare GraphQL and REST with a specific example? </p><br><h2 id="restful-api-protiv-graphql-apiprimer">  RESTful API vs. GraphQL API - Example </h2><br><p>  For example, an interface is being developed on the theme of the Star Wars film and its characters. </p><br><p>  The first thing to create is a simple visual component to display information about a single Star Wars character.  Take Darth Vader, who appears regularly throughout the film.  The component will show the name, date of birth, the name of the planet and the names of all films in which the character participates. </p><br><p>  It sounds easy, but we are dealing with three different resources: Person, Planet and Film.  They are simply interconnected, so that anyone can guess the data structure.  The Person object belongs to the planet and owns from one to several Film objects. </p><br><p>  The data for the first component looks like this: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"person"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Darth Vader"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"birthYear"</span></span>: <span class="hljs-string"><span class="hljs-string">"41.9BBY"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"planet"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tatooine"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"films"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"A New Hope"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"The Empire Strikes Back"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Return of the Jedi"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Revenge of the Sith"</span></span> } ] } } }</code> </pre> <br><p>  Let it come from the server just such a structure.  Then you can visualize the data in React as follows: </p><br><pre> <code class="hljs haskell">// <span class="hljs-type"><span class="hljs-type">The</span></span> <span class="hljs-type"><span class="hljs-type">Container</span></span> <span class="hljs-type"><span class="hljs-type">Component</span></span>: &lt;<span class="hljs-type"><span class="hljs-type">PersonProfile</span></span> person={<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.person} &gt;&lt;/</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PersonProfile</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">The</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PersonProfile</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Component</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Name</span></span></span><span class="hljs-class">: {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">person</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Birth</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Year</span></span></span><span class="hljs-class">: {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">person</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">birthYear</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Planet</span></span></span><span class="hljs-class">: {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">person</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">planet</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Films</span></span></span><span class="hljs-class">: {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">person</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">films</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">film</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">film</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class">)}</span></span></code> </pre> <br><p>  This is a simple example, and since we are probably assisted by knowledge of Star Wars, the connection between the UI and the data is obvious.  The UI uses all the keys we created from JSON. </p><br><p>  Let's see how to get this data through the RESTful API. </p><br><p>  First we get information about the character by ID.  The RESTful API is expected to provide it like this: </p><br><pre> <code class="hljs objectivec">GET - /people/{<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>}</code> </pre> <br><p>  Such a request will return the name, date of birth and other information about the character.  A good RESTful API will also report the character's planet ID and the ID of all movies with it. </p><br><p>  The JSON response might look like this: </p><br><pre> <code class="hljs pgsql">{ "name": "Darth Vader", "birthYear": "41.9BBY", "planetId": <span class="hljs-number"><span class="hljs-number">1</span></span> "filmIds": [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], *** other information we <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> need *** }</code> </pre> <br><p>  Then we get the name of the planet: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> - /planets/<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  And then we get the names of the films: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> - /films/<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> - /films/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> - /films/<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> - /films/<span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br><p>  And only after six requests we can collect the answers and provide the component with the necessary data. </p><br><p>  In addition to the six queries to visualize a fairly simple component, this decision was imperative.  We have specified how to receive and process data so that it can be passed to the component. </p><br><p>  You can try it yourself and see what I mean.  Star Wars has a RESTful API at <a href="http://swapi.co/"></a>  <a href="http://swapi.co/">http://swapi.co/</a> .  Construct a character data object.  The keys may be called a little differently, but the resource URLs will be the same.  You need exactly six requests.  Moreover, you will get redundant information that is not needed for the component. </p><br><p>  Of course, this is one possible implementation of the RESTful API for this data.  You can imagine the implementation better, which simplifies the task.  For example, if the nested resources are available in the API and the server knows about the relationship between the character and the films, you can get movies like this: </p><br><pre> <code class="hljs objectivec">GET - /people/{<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>}/films</code> </pre> <br><p>  But a simple RESTful API probably does not have this capability, and you will have to ask backend developers to create additional destination points for us.  This is the practice of scaling RESTful API - you have to add all the new destination points to meet the needs of customers.  Maintaining these points is quite time consuming. </p><br><p>  Now take a look at the GraphQL approach.  GraphQL server to the maximum embodies the idea of ‚Äã‚Äãa custom destination, bringing the idea to the absolute.  There is only one destination on the server, and the way to communicate with it is not important.  If you use HTTP, the HTTP request method will be ignored.  Suppose there is a GraphQL destination point available on / graphql over HTTP. </p><br><p>  Since the task is to get all the data at once, we need a way to specify the composition of the data to the server.  To do this, use the GraphQL query: </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> POST - /graphql?query={...}</code> </pre> <br><p>  A GraphQL query is simply a string containing all the necessary data.  And here comes the power of declarativeness. </p><br><p>  In Russian, the need for data is expressed as follows: <em>for the specified character, the name, date of birth, name of the planet and the names of all his films are needed</em> .  In GraphQL, it looks like this: </p><br><pre> <code class="hljs dos">{ person(ID: ...) { name, birthYear, planet { name }, films { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre> <br><p>  Compare how the need for data in human language and GraphQL is described.  The descriptions are as close as possible.  Also compare the GraphQL query and the JSON that we started with.  The request exactly repeats the structure of the expected JSON, not including the values.  If we draw a parallel between the request and the response, the request is a response without data. </p><br><p>  If the answer is: </p><br><pre> <code class="hljs erlang">    ‚Äì .</code> </pre> <br><p>  That question can be represented by the same expression, but without a specific meaning: </p><br><pre> <code class="hljs">()    ?</code> </pre> <br><p>  The GraphQL query has the same similarity.  If you take the resulting JSON, remove all the "answers" (values), then we get a GraphQL query, suitable for the role of the question about this JSON. </p><br><p>  Now compare the GraphQL query with the declarative React UI code, which describes the data.  Everything that is specified in the GraphQL query is used in the UI, and everything used in the UI is present in the query. </p><br><p>  This is a great way to represent the GraphQL data model.  The interface knows what data is needed, and getting it is not difficult.  Designing a GraphQL query is a simple task of identifying what is used as variables directly in the UI. </p><br><p>  If you swap parts of this model, it will also be useful.  On request, GraphQL makes it easy to imagine how the response is used in the UI, since the response has the same ‚Äústructure‚Äù as the query.  You do not need to specifically study the answer to understand how to use it, and you don‚Äôt even need API documentation.  Everything within the request. </p><br><p>  Star Wars has a GraphQL API <a href="https://github.com/graphql/swapi-graphql">at</a> .  Try using it to get data about the character.  There are minor differences, but in general the request to obtain the necessary data in this API looks like this (with Darth Vader as an example): </p><br><pre> <code class="hljs pgsql">{ person(personID: <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-type"><span class="hljs-type">name</span></span>, birthYear, homeworld { <span class="hljs-type"><span class="hljs-type">name</span></span> }, filmConnection { films { title } } } }</code> </pre> <br><p>  The query returns a structure very close to the needs of the visual component.  But most importantly, all data is received at once. </p><br><h2 id="plata-za-gibkost-graphql">  GraphQL flexibility fee </h2><br><p>  The perfect solution is a myth.  Along with the flexibility of GraphQL come some problems and concerns. </p><br><p>  One of the threats with which GraphQL is open is network attacks on resource exhaustion (such as Denial of Service).  GraphQL server can be attacked by excessively complex queries that consume all resources.  Easily request data with deep nesting (user -&gt; friends -&gt; friends of friends ...) or use field synonyms to force the server to receive the same data many times.  Although such attacks do not occur only in GraphQL, you need to keep them in mind when working with GraphQL. </p><br><p>  There are several oppositions.  You can analyze the cost of each request before executing and impose restrictions on the amount of data that the request can consume.  You can enter a timeout for interrupting a request that is too long.  Also, since GraphQL is only a level that associates a query with data stores, you can set constraints at deeper levels under GraphQL. </p><br><p>  GraphQL API        (  ),        .      ,     . , Facebook   . </p><br><p>       GraphQL ‚Äì    .    ‚Äì ,        GraphQL? </p><br><p>     ,  ,  GraphQL  DSL (domain specific language ‚Äì   )       . ,          (  ). </p><br><p>       . GraphQL       .    .       GraphQL,   GraphQL         ,    .         RESTful API. </p><br><p>  GraphQL     .  RESTful API  ,    .     .       . </p><br><p>  GraphQL        .           .     ,         . </p><br><p>      . Graph Query  <em>Graph Cache</em> .   ,   GraphQL:             , ‚Äì       ,   . </p><br><p>     .   ,      .        ,    .        .          .  <a href="https://facebook.github.io/relay/">Relay.js</a>     ¬´ ¬ª. </p><br><p> ,      GraphQL ‚Äì   N+1 SQL-.  GraphQL      ,     .     ,    SQL-   . </p><br><p>   RESTful API  ,     N+1,    SQL-.   GraphQL,    ,  .  , Facebook        ‚Äì <a href="https://github.com/facebook/dataloader">DataLoader</a> . </p><br><p>  ,   DataLoader       ,    GraphQL.   DataLoader      .    ,     SQL-  . </p><br><p>   DataLoader      .            , DataLoader          .             . </p><br><h2>  ... </h2><br><p>  Thanks for attention.    -  <a href="https://app.pluralsight.com/profile/author/samer-buna">Pluralsight</a>  <a href="https://www.lynda.com/Samer-Buna/7060467-1.html">Lynda</a> .    ‚Äì <a href="https://www.pluralsight.com/courses/reactjs-advanced">Advanced React.js</a> , <a href="https://www.pluralsight.com/courses/nodejs-advanced">Advanced Node.js</a>  <a href="https://www.lynda.com/Express-js-tutorials/Learning-Full-Stack-JavaScript-Development-MongoDB-Node-React/533304-2.html">Learning Full-stack JavaScript</a> . </p><br><p>   -  -    JavaScript, Node.js, React.js  GraphQL     . <a href="http://samer%40jscomplete.com/"> </a> ,    (.).          ,      <a href="https://slackin-bfcnswvsih.now.sh/"> </a> (   )      #questions. </p><br><p>   <a href="https://medium.freecodecamp.org/%40samerbuna">Samer Buna</a> <br> <a href="https://medium.freecodecamp.org/rest-apis-are-rest-in-peace-apis-long-live-graphql-d412e559d8e4"> </a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334182/">https://habr.com/ru/post/334182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334172/index.html">Tizen: sum up</a></li>
<li><a href="../334174/index.html">‚ÄúData mining now is an advantage in the market‚Äù: about the conference SmartData and Big Data</a></li>
<li><a href="../334176/index.html">We deal with copying and cloning</a></li>
<li><a href="../334178/index.html">Tips for those planning to localize their project</a></li>
<li><a href="../334180/index.html">Developer Preview 4 is already available. Official launch of the Android O platform soon</a></li>
<li><a href="../334184/index.html">High-tech shopping: innovations that change the appearance of retail and shopping centers</a></li>
<li><a href="../334186/index.html">Programming Contest: JSDash (Intermediate Results 2)</a></li>
<li><a href="../334188/index.html">Where did the System Administrator Day come from and why is it important to celebrate it</a></li>
<li><a href="../334192/index.html">Use of the device on the basis of STM32 in the irrigation system for open ground</a></li>
<li><a href="../334194/index.html">What is new in nginx?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>