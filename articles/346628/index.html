<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Spring Security interrogation query path</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most developers have only a rough idea of ‚Äã‚Äãwhat is happening inside Spring Security, which is dangerous and can lead to the appearance of vulnerabili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Spring Security interrogation query path</h1><div class="post__text post__text-html js-mediator-article">  Most developers have only a rough idea of ‚Äã‚Äãwhat is happening inside Spring Security, which is dangerous and can lead to the appearance of vulnerabilities. <br><br>  In this article, step by step, we will follow the path of the http request, which will help you understand and solve Spring Security problems with understanding. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/sj/7w/nbsj7w8-x3lwttjzoz7wei6qpic.jpeg" alt="image"></div><br><a name="habracut"></a><br><h2>  Project preparation </h2><br>  To begin with, we will prepare a project, go to <a href="https://start.spring.io/">https://start.spring.io/</a> , tick the boxes Web&gt; web, and Core&gt; Security. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Add a controller: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> String.valueOf(System.currentTimeMillis()); } }</code> </pre> <br>  Add rest-assured: <br><br><pre> <code class="hljs lisp">testCompile('io.rest-assured<span class="hljs-symbol"><span class="hljs-symbol">:rest-assured</span></span>:<span class="hljs-number"><span class="hljs-number">3.0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>')</code> </pre> <br>  Add a bulk: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">apply</span></span> plugin: <span class="hljs-string"><span class="hljs-string">'groovy'</span></span></code> </pre> <br>  Let's write a test: <br><br> <code>ControllerIT.groovy</code> <br> <br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(properties = <span class="hljs-string"><span class="hljs-string">"security.user.password=pass"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ControllerIT</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@LocalServerPort</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> serverPort; <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initRestAssured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RestAssured.port = serverPort; RestAssured.filters(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResponseLoggingFilter()); RestAssured.filters(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestLoggingFilter()); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-string"><span class="hljs-string">'api call without authentication must fail'</span></span>() { when() .get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) .then() .statusCode(HttpStatus.SC_UNAUTHORIZED); } }</code> </pre> <br>  Run the test.  What is in the logs? <br><br>  Request: <br><br><pre> <code class="hljs pgsql">Request <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> Request URI: http://localhost:<span class="hljs-number"><span class="hljs-number">51213</span></span>/</code> </pre> <br>  Answer: <br><br><pre> <code class="hljs pgsql">HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">401</span></span> X-Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>: nosniff X-XSS-Protection: <span class="hljs-number"><span class="hljs-number">1</span></span>; mode=block <span class="hljs-keyword"><span class="hljs-keyword">Cache</span></span>-Control: no-<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>, no-store, max-age=<span class="hljs-number"><span class="hljs-number">0</span></span>, must-revalidate Pragma: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> Expires: <span class="hljs-number"><span class="hljs-number">0</span></span> X-Frame-<span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>: DENY <span class="hljs-keyword"><span class="hljs-keyword">Strict</span></span>-Transport-<span class="hljs-keyword"><span class="hljs-keyword">Security</span></span>: max-age=<span class="hljs-number"><span class="hljs-number">31536000</span></span> ; includeSubDomains WWW-Authenticate: Basic realm="Spring" Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: application/<span class="hljs-type"><span class="hljs-type">json</span></span>;charset=UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> Transfer-<span class="hljs-keyword"><span class="hljs-keyword">Encoding</span></span>: chunked <span class="hljs-type"><span class="hljs-type">Date</span></span>: Sun, <span class="hljs-number"><span class="hljs-number">22</span></span> Oct <span class="hljs-number"><span class="hljs-number">2017</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">53</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> GMT { "timestamp": <span class="hljs-number"><span class="hljs-number">1508673180745</span></span>, "status": <span class="hljs-number"><span class="hljs-number">401</span></span>, "error": "Unauthorized", "message": "Full authentication is required to access this resource", "path": "/" }</code> </pre> <br>  SS without additional settings has already begun to protect method calls, since the configuration has worked - <code>SpringBootWebSecurityConfiguration</code> supplied by spring boot.  Inside this class is the <code>ApplicationNoWebSecurityConfigurerAdapter</code> which sets defaults. <br><br>  Some of them can be affected through the settings: <br>  <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</a> <br>  look for "# SECURITY PROPERTIES", you can also look at the code: <code>SecurityProperties</code> <br><br>  Tune up the spring boot configuration to complete the story: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@TestPropertySource(properties = [ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"security.user.password=pass"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"security.enable-csrf=true"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"security.sessions=if_required"</span></span></span><span class="hljs-meta"> ])</span></span></code> </pre> <br><h3>  Filters </h3><br>  Spring Security in a web application starts with a servlet filter. <br>  Let's try, but first we will add a test with successful authorization. <br><br><pre> <code class="hljs pgsql">@Test <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-string"><span class="hljs-string">'api call with authentication must succeed'</span></span>() { given() .auth().preemptive().basic("user", "pass") .<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>("/") .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>() .statusCode(HttpStatus.SC_OK); }</code> </pre> <br>  We put bryak and run the test. <br><br><img src="https://habrastorage.org/webt/u8/y3/1e/u8y31erv8gfzvcu9otjrwzariky.png"><br>  <i>rice</i>  <i>1 - get method</i> <br><br>  let's go down the huge call stack <code>(new Exception().getStackTrace().length == 91)</code> and find the first mention of the spring <br><br><img src="https://habrastorage.org/webt/sz/fl/jz/szfljzmtwjlrfa3oxze3_ur2-h8.png"><br>  <i>rice</i>  <i>2 - call stack</i> <br><br>  Let's see what is in the variable <code>filterChain</code> <br><br><img src="https://habrastorage.org/webt/f6/ck/j_/f6ckj_juo8cyeknz-iiephntuhi.png"><br>  <i>rice</i>  <i>3 - application filter chain</i> <br><br>  The <code>springSecurityFilterChain</code> filter is interesting here <code>springSecurityFilterChain</code> it is he who does all the SS work in the web part. <br><br>  <code>DelegatingFilterProxyRegistrationBean</code> itself is not very interesting, let's see to whom it delegates its work. <br><br><img src="https://habrastorage.org/webt/lg/g9/rh/lgg9rhsjy56pjgrmaixnmxywqro.png"><br>  <i>rice</i>  <i>4 - filter chain proxy</i> <br><br>  He delegates his work to the <code>FilterChainProxy</code> class.  Inside it happens a few interesting things. <br><br>  First of all, let's look at the <code>FilterChainProxy#doFilterInternal</code> .  What's going on here?  We <code>VirtualFilterChain</code> filters, create <code>VirtualFilterChain</code> and run the request and response on them. <br><br><pre> <code class="java hljs">List&lt;Filter&gt; filters = getFilters(fwRequest); ... VirtualFilterChain vfc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VirtualFilterChain(fwRequest, chain, filters); vfc.doFilter(fwRequest, fwResponse);</code> </pre><br>  Inside the getFilters method, we take the first <code>SecurityFilterChain</code> that matches the request. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;Filter&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFilters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (SecurityFilterChain chain : filterChains) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chain.matches(request)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> chain.getFilters(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Let's go to the debbager and see which list is being iterated. <br><br><img src="https://habrastorage.org/webt/lw/nc/1y/lwnc1yor--xtyj1fpo8st_yehfc.png"><br>  <i>rice</i>  <i>5 - security filter chains</i> <br><br>  What does this list tell us? <br><br>  In both sheets is <code>OrRequestMatcher</code> , which will try to match the current url with at least one pattern from the list. <br><br>  The first element of the list has an empty list of filters, respectively, there will be no additional filtering, and as a result there will be no protection. <br><br>  Check in practice. <br><blockquote>  Any url that matches this pattern will not be protected by SS by default. <br> <code>"/css/**", "/js/**", "/images/**", "/webjars/**", "/**/favicon.ico", "/error"</code> <br> </blockquote>  Add a method: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"css/hello"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cssHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello I'm secret data"</span></span>; }</code> </pre><br>  Let's write a test: <br><br><pre> <code class="hljs pgsql">@Test <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-string"><span class="hljs-string">'get css/hello must succeed'</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>("css/hello") .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>() .statusCode(HttpStatus.SC_OK); }</code> </pre><br>  Much more interesting is the second SecurityFilterChain which matches any url "/ **" <br><br>  In our case there is the following list of filters. <br><br><pre> <code class="hljs">0 = {WebAsyncManagerIntegrationFilter} 1 = {SecurityContextPersistenceFilter} 2 = {HeaderWriterFilter} 3 = {CsrfFilter} 4 = {LogoutFilter} 5 = {BasicAuthenticationFilter} 6 = {RequestCacheAwareFilter} 7 = {SecurityContextHolderAwareRequestFilter} 8 = {AnonymousAuthenticationFilter} 9 = {SessionManagementFilter} 10 = {ExceptionTranslationFilter} 11 = {FilterSecurityInterceptor}</code> </pre><br>  This list may vary depending on the settings and added dependencies. <br>  For example with this configuration: <br><br><pre> <code class="java hljs">http .authorizeRequests().anyRequest().authenticated() .and() .formLogin() .and() .httpBasic();</code> </pre><br>  Filters would be added to this list: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">UsernamePasswordAuthenticationFilter</span></span> DefaultLoginPageGeneratingFilter</code> </pre><br>  In which order the filters go by default can be viewed here: FilterComparator <br><br><h3>  0 = {WebAsyncManagerIntegrationFilter} </h3><br>  We are not very interesting, according to the documentation, it ‚Äúintegrates‚Äù the SecurityContext with the WebAsyncManager which is responsible for asynchronous requests. <br><br><h3>  1 = {SecurityContextPersistenceFilter} </h3><br>  Searches for the SecurityContext in the session and populates the SecurityContextHolder if found. <br>  The default is ThreadLocalSecurityContextHolderStrategy which stores the SecurityContext in a ThreadLocal variable. <br><br><h3>  2 = {HeaderWriterFilter} </h3><br>  Just add the headers in response. <br><br>  Disable cache: <br><br>  - Cache-Control: no-cache, no-store, max-age = 0, must-revalidate <br>  - Pragma: no-cache <br>  - Expires: 0 <br><br>  We do not allow browsers to automatically determine the type of content: <br><br>  - X-Content-Type-Options: nosnif <br><br>  Do not allow iframe <br><br>  - X-Frame-Options: DENY <br><br>  We enable built-in protection in the browser from cross-site scripting (XSS) <br><br>  - X-XSS-Protection: 1;  mode = block <br><br><h3>  3 = {CsrfFilter} </h3><br>  Perhaps there is not a single developer who, when meeting with SS, would not encounter the error ‚Äúlack of csrf token‚Äù. <br><br>  Why we did not meet this error earlier?  It's simple, we run methods on which there is no csrf protection. <br><br>  Let's try to add POST method <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"post"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello it is post request"</span></span>; }</code> </pre><br>  Test: <br><br><pre> <code class="hljs pgsql">@Test <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-string"><span class="hljs-string">'POST without CSRF token must return 403'</span></span>() { given() .auth().preemptive().basic("user", "pass") .<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>() .post("/post") .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>() .statusCode(HttpStatus.SC_FORBIDDEN); }</code> </pre><br>  The test was successful, we were returned a 403 error, the csrf protection is in place. <br><br><h3>  4 = {LogoutFilter} </h3><br>  Next comes the logout filter, it checks if the url matches the pattern. <br> <code>Ant [pattern='/logout', POST] -  </code> <br>  and starts the logout procedure <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> = {CompositeLogoutHandler} logoutHandlers = {ArrayList} <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> = {CsrfLogoutHandler} <span class="hljs-number"><span class="hljs-number">1</span></span> = {SecurityContextLogoutHandler}</code> </pre><br>  By default, the following occurs: <br><br><ol><li>  Csrf token removed. </li><li>  Session ends </li><li>  Cleaned SecurityContextHolder </li></ol><br><h3>  5 = {BasicAuthenticationFilter} </h3><br>  Now we got directly to authentication.  What happens inside? <br>  The filter checks if there is an Authorization header with a value starting with Basic. <br>  If found, retrieves the login \ password and sends them to the <code>AuthenticationManager</code> <br><br>  Inside there is something like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (headers.get(<span class="hljs-string"><span class="hljs-string">"Authorization"</span></span>).startsWith(<span class="hljs-string"><span class="hljs-string">"Basic"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { UsernamePasswordAuthenticationToken token = extract(header); Authentication authResult = authenticationManager.authenticate(token); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AuthenticationException failed) { SecurityContextHolder.clearContext(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authenticationEntryPoint.commence(request, response, failed); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { chain.doFilter(request, response); }</code> </pre><br><h4>  AuthenticationManager </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthenticationManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Authentication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication authentication)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> AuthenticationException</span></span>; }</code> </pre><br>  AuthenticationManager is an interface that accepts Authentication and returns Authentication too. <br><br>  In our case, the Authentication implementation will be the UsernamePasswordAuthenticationToken. <br>  It would be possible to implement the AuthenticationManager itself, but there is little point in this, there is a default implementation - ProviderManager. <br><br>  ProviderManager authorizes delegates to another interface: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthenticationProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Authentication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication authentication)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> AuthenticationException</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supports</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;?&gt; authentication)</span></span></span></span>; }</code> </pre><br>  When we pass the <code>Authentication</code> object to the <code>ProviderManager</code> , it iterates through the existing <code>AuthenticationProvider</code> and checks whether <br>  AuthenticationProvider this implementation Authentication <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supports</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;?&gt; authentication)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (UsernamePasswordAuthenticationToken.class .isAssignableFrom(authentication)); }</code> </pre><br>  As a result, inside <code>AuthenticationProvider.authenticate</code> we can already transfer the passed Authentication to the desired implementation without caste exection. <br><br>  Next, from the specific implementation we take out the creditshenals. <br><br>  If authentication fails, <code>AuthenticationProvider</code> should throw an exception, the <code>ProviderManager</code> will catch it and try the next AuthenticationProvider from the list, if none of the AuthenticationProvider returns successful authentication, the ProviderManager will forward the last caught event. <br><br>  In more detail and with pictures the process is described here: <br>  <a href="https://spring.io/guides/topicals/spring-security-architecture/">https://spring.io/guides/topicals/spring-security-architecture/</a> <br><br>  Next, the <code>BasicAuthenticationFilter</code> saves the resulting Authentication to the SecurityContextHolder <br>  SecurityContextHolder.getContext (). SetAuthentication (authResult); <br>  The authentication process is now complete. <br><br>  If AuthenticationException is thrown, <code>SecurityContextHolder.clearContext();</code> will be reset <code>SecurityContextHolder.clearContext();</code>  context and will be called AuthenticationEntryPoint. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthenticationEntryPoint</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, ServletException</span></span>; }</code> </pre><br>  The task of AuthenticationEntryPoint is to write in response to the information that authentication failed. <br><br>  In the case of basic authentication, this will be: <br><br><pre> <code class="java hljs">response.addHeader(<span class="hljs-string"><span class="hljs-string">"WWW-Authenticate"</span></span>, <span class="hljs-string"><span class="hljs-string">"Basic realm=\""</span></span> + realmName + <span class="hljs-string"><span class="hljs-string">"\""</span></span>); response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage());</code> </pre><br>  As a result, the browser will show the basic authorization window. <br><br><h3>  6 = {RequestCacheAwareFilter} </h3><br>  What is this filter for?  Imagine the script: <br><br>  1. The user logs on to the protected url. <br>  2. It throws on the login page. <br>  3. After successful authorization, the user transfers to the page he requested at the beginning. <br><br>  It is for the restoration of the original request that this filter exists. <br>  Inside it is checked if there is a saved query, if there is, it replaces the current query. <br>  The request is saved in the session, at what stage it is saved will be written below. <br><br>  Let's try to reproduce. <br><br>  Add a method: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"customHeader"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestHeader(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"x-custom-header"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String customHeader) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> customHeader; }</code> </pre><br>  Add a test: <br><br><pre> <code class="hljs ruby">@Test void <span class="hljs-string"><span class="hljs-string">'passed x-custom-header must be returned'</span></span>() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sessionCookie</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">given</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> .header(<span class="hljs-string"><span class="hljs-string">"x-custom-header"</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>() .get(<span class="hljs-string"><span class="hljs-string">"customHeader"</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>() .statusCode(HttpStatus.SC_UNAUTHORIZED) .extract().cookie(<span class="hljs-string"><span class="hljs-string">"JSESSIONID"</span></span>) given() .auth().basic(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"pass"</span></span>) .cookie(<span class="hljs-string"><span class="hljs-string">"JSESSIONID"</span></span>, sessionCookie) .<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>() .get(<span class="hljs-string"><span class="hljs-string">"customHeader"</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>() .statusCode(HttpStatus.SC_OK) .body(equalTo(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>)); }</code> </pre> <br>  As we see in the second request, we returned the header that we passed in the first request.  The filter is working. <br><br><h3>  7 = {SecurityContextHolderAwareRequestFilter} </h3><br>  Wraps an existing request in SecurityContextHolderAwareRequestWrapper <br><br><pre> <code class="java hljs">chain.doFilter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requestFactory.create((HttpServletRequest) req, (HttpServletResponse) res), res);</code> </pre><br>  Implementation may vary depending on servlet api version servlet 2.5 / 3 <br><br><h3>  8 = {AnonymousAuthenticationFilter} </h3><br>  If by the time this filter is executed, SecurityContextHolder is empty, i.e.  failed authentication The filter populates the SecurityContextHolder object with anonymous authentication - AnonymousAuthenticationToken with the role "ROLE_ANONYMOUS". <br><br>  This guarantees that the SecurityContextHolder will have an object, this allows not to be afraid of NP, as well as a more flexible approach to setting up access for unauthorized users. <br><br><h3>  9 = {SessionManagementFilter} </h3><br>  At this stage, actions related to the session are performed. <br><br>  It may be: <br><br>  - change session ID <br>  - limiting the number of simultaneous sessions <br>  - saving SecurityContext in securityContextRepository <br><br>  In our case, the following happens: <br>  <code>SecurityContextRepository</code> with the default implementation of the HttpSessionSecurityContextRepository saves the SecurityContext to the session. <br>  Called <code>sessionAuthenticationStrategy.onAuthentication</code> <br><br>  Inside sessionAuthenticationStrategy is: <br><br><pre> <code class="hljs">sessionAuthenticationStrategy = {CompositeSessionAuthenticationStrategy} delegateStrategies 0 = {ChangeSessionIdAuthenticationStrategy} 1 = {CsrfAuthenticationStrategy}</code> </pre><br>  2 things happen: <br><br>  1. By default, protection against session fixation attack is enabled, i.e.  after authentication, session id changes. <br>  2. If a csrf token was transmitted, a new csrf token is generated <br><br>  Let's try to check the first item: <br><br><pre> <code class="hljs ruby">@Test void <span class="hljs-string"><span class="hljs-string">'JSESSIONID must be changed after login'</span></span>() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sessionCookie</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> .get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>() .statusCode(HttpStatus.SC_UNAUTHORIZED) .extract().cookie(<span class="hljs-string"><span class="hljs-string">"JSESSIONID"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newCookie</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">given</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> .auth().basic(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"pass"</span></span>) .cookie(<span class="hljs-string"><span class="hljs-string">"JSESSIONID"</span></span>, sessionCookie) .<span class="hljs-keyword"><span class="hljs-keyword">when</span></span>() .get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>() .statusCode(HttpStatus.SC_OK) .extract().cookie(<span class="hljs-string"><span class="hljs-string">"JSESSIONID"</span></span>) Assert.assertNotEquals(sessionCookie, newCookie) }</code> </pre><br><h3>  10 = {ExceptionTranslationFilter} </h3><br>  At this point, the SecurityContext should contain anonymous or normal authentication. <br><br>  ExceptionTranslationFilter passes request and response on the filter chain and handles possible authorization errors. <br><br>  SS distinguishes 2 cases: <br><br>  1. AuthenticationException <br>  It <code>sendStartAuthentication</code> , inside of which the following occurs: <br><br> <code>SecurityContextHolder.getContext().setAuthentication(null);</code>  - clears SecurityContextHolder <br> <code>requestCache.saveRequest(request, response);</code>  - saves the current request to requestCache so that RequestCacheAwareFilter has something to recover. <br> <code>authenticationEntryPoint.commence(request, response, reason);</code>  - calls authenticationEntryPoint - which records in response a signal that it is necessary to perform authentication (headers \ redirect) <br><br>  2. AccessDeniedException <br><br>  Here again 2 cases are possible: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ... }</code> </pre><br>  1. User with anonymous authentication, or with authentication by rememberMe token <br>  sendStartAuthentication is called <br><br>  2. A user with full, non-anonymous authentication is invoked: <br>  accessDeniedHandler.handle (request, response, (AccessDeniedException) exception) <br>  which defaults the answer forbidden 403 <br><br><h3>  11 = {FilterSecurityInterceptor} </h3><br>  At the last stage, the authorization is based on the url of the request. <br>  FilterSecurityInterceptor is inherited from AbstractSecurityInterceptor and decides whether the current user has access to the current url. <br><br>  There is another implementation of the MethodSecurityInterceptor which is responsible for admitting a method call using @Secured \ @PreAuthorize annotations. <br><br>  AccessDecisionManager is called inside. <br><br>  There are several strategies for deciding whether to allow or not, the default is used: AffirmativeBased <br><br>  The code inside is very simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (AccessDecisionVoter voter : getDecisionVoters()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = voter.vote(authentication, object, configAttributes); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (result) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AccessDecisionVoter.ACCESS_GRANTED: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AccessDecisionVoter.ACCESS_DENIED: deny++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deny &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AccessDeniedException(); } checkAllowIfAllAbstainDecisions();</code> </pre><br>  In other words, if someone votes for, we skip, if at least 1 vote against is not allowed, if no one has voted, we will not let it go. <br><br>  Let's summarize a little: <br><br>  <code>springSecurityFilterChain</code> is a set of spring security filters. <br><br>  Example filter set for basic authorization: <br><br>  <code>WebAsyncManagerIntegrationFilter</code> - Integrates SecurityContext with WebAsyncManager <br>  <code>SecurityContextPersistenceFilter</code> - Looks for the SecurityContext in a session and fills in the SecurityContextHolder if it finds <br>  <code>HeaderWriterFilter</code> - Adds ‚Äúsecurity‚Äù headers to the response <br>  <code>CsrfFilter</code> - Checks for the presence of csrf token <br>  <code>LogoutFilter</code> - Performs logout <br>  <code>BasicAuthenticationFilter</code> - Performs basic authentication. <br>  <code>RequestCacheAwareFilter</code> - Restores the request saved prior to authentication, if any <br>  <code>SecurityContextHolderAwareRequestFilter</code> - Wraps an existing request in SecurityContextHolderAwareRequestWrapper <br>  <code>AnonymousAuthenticationFilter</code> - Fills SecurityContext with Anonymous Authentication <br>  <code>SessionManagementFilter</code> - Performs session related actions <br>  <code>ExceptionTranslationFilter</code> - Handles AuthenticationException \ AccessDeniedException that occur below the stack. <br>  <code>FilterSecurityInterceptor</code> - Checks if the current user has access to the current url. <br><br>  <code>FilterComparator</code> - here you can see the list of filters and their possible order. <br><br>  <code>AuthenticationManager</code> - interface responsible for authentication <br>  <code>ProviderManager</code> - An implementation of an AuthenticationManager that uses an internally uses <code>AuthenticationProvider</code> <br>  <code>AuthenticationProvider</code> is an interface responsible for authenticating a specific <code>Authentication</code> implementation. <br>  <code>SecurityContextHolder</code> - stores authentication usually in a ThreadLocal variable. <br>  <code>AuthenticationEntryPoint</code> - modifies the response to make it clear to the client that authentication is required (headers, redirect to login page, etc.) <br><br>  <code>AccessDecisionManager</code> decides whether <code>Authentication</code> access to some resource. <br>  <code>AffirmativeBased</code> is the default strategy used by AccessDecisionManager. <br><br><h2>  Recommendations </h2><br><h3>  Write simple tests that test the order of filters and their settings. </h3><br>  This will avoid unpleasant surprises. <br> <code>FilterChainIT.groovy</code> <br> <br><pre> <code class="hljs ruby">@RunWith(SpringRunner.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FilterChainIT</span></span></span><span class="hljs-class"> { @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Autowired</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FilterChainProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filterChainProxy</span></span></span><span class="hljs-class">;</span></span> @Autowired List&lt;Filter&gt; filters; @Test void <span class="hljs-string"><span class="hljs-string">'test main filter chain'</span></span>() { assertEquals(<span class="hljs-number"><span class="hljs-number">5</span></span>, filters.size()); assertEquals(OrderedCharacterEncodingFilter, filters[<span class="hljs-number"><span class="hljs-number">0</span></span>].getClass()) assertEquals(OrderedHiddenHttpMethodFilter, filters[<span class="hljs-number"><span class="hljs-number">1</span></span>].getClass()) assertEquals(OrderedHttpPutFormContentFilter, filters[<span class="hljs-number"><span class="hljs-number">2</span></span>].getClass()) assertEquals(OrderedRequestContextFilter, filters[<span class="hljs-number"><span class="hljs-number">3</span></span>].getClass()) assertEquals(<span class="hljs-string"><span class="hljs-string">"springSecurityFilterChain"</span></span>, filters[<span class="hljs-number"><span class="hljs-number">4</span></span>].filterName) } @Test void <span class="hljs-string"><span class="hljs-string">'test security filter chain order'</span></span>() { assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, filterChainProxy.getFilterChains().size()); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chain</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterChainProxy</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFilterChains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); assertEquals(chain.filters.size(), <span class="hljs-number"><span class="hljs-number">11</span></span>) assertEquals(WebAsyncManagerIntegrationFilter, chain.filters[<span class="hljs-number"><span class="hljs-number">0</span></span>].getClass()) assertEquals(SecurityContextPersistenceFilter, chain.filters[<span class="hljs-number"><span class="hljs-number">1</span></span>].getClass()) } @Test void <span class="hljs-string"><span class="hljs-string">'test ignored patterns'</span></span>() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chain</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterChainProxy</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFilterChains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"/css/**"</span></span>, chain.requestMatcher.requestMatchers[<span class="hljs-number"><span class="hljs-number">0</span></span>].pattern); assertEquals(<span class="hljs-string"><span class="hljs-string">"/js/**"</span></span>, chain.requestMatcher.requestMatchers[<span class="hljs-number"><span class="hljs-number">1</span></span>].pattern); assertEquals(<span class="hljs-string"><span class="hljs-string">"/images/**"</span></span>, chain.requestMatcher.requestMatchers[<span class="hljs-number"><span class="hljs-number">2</span></span>].pattern); } }</code> </pre><br><h3>  Do not call SecurityContextHolder.getContext (). GetAuthentication ();  for current user </h3><br>  Authentication - in itself is not a very convenient object to use.  Almost all methods return an Object, and to get the necessary information you need to cast into a specific implementation. <br><br>  Better get the interface, do the implementation depending on your needs, write a HandlerMethodArgumentResolver. <br><br>  Code with this approach is better to read, test, maintain. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Auth</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthUserArgumentResolver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerMethodArgumentResolver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supportsParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodParameter parameter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parameter.getParameterType().equals(Auth.class); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Auth </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveArgument</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span></span></span><span class="hljs-function"> </span></span>{ Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toAuth(principal) } } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Auth auth)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hello "</span></span> + auth.getId(); }</code> </pre><br><h3>  Expand Existing Implementations </h3><br>  Spring security contains a lot of interfaces that can be implemented, but most likely there is an abract class that is 99% doing what you need. <br><br>  For example, for the Authentication interface, there is an <code>AbstractAuthenticationToken</code> , and an authentication filter is reasonable to inherit from <code>AbstractAuthenticationProcessingFilter</code> <br><br><h3>  Use SecurityConfigurerAdapter to configure your authentication. </h3><br>  In the event that you have fully custom authentication, most likely you had to do the following: <br><br>  1. Create an Authentication implementation <br>  2. Create an AuthenticationProvider that supports your implementation of Authentication <br>  3. Add a filter that started the authentication process. <br><br>  It is reasonable to unite them all in one place.  Look at <code>HttpBasicConfigurer, OpenIDLoginConfigurer</code> they do the same. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyConfigurer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecurityConfigurerAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultSecurityFilterChain</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpSecurity</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSecurity http)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ AuthenticationManager authenticationManager = http.getSharedObject(AuthenticationManager.class); MyAuthenticationProvider myAuthenticationProvider = http.getSharedObject(MyAuthenticationProvider.class); MyAuthenticationFilter filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAuthenticationFilter(authenticationManager); http .authenticationProvider(myAuthenticationProvider) .addFilterBefore(postProcess(filter), AbstractPreAuthenticatedProcessingFilter.class); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecurityConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSecurityConfigurerAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSecurity http)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ http .authorizeRequests().anyRequest().authenticated() .and() .apply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyConfigurer()) } }</code> </pre><br><h3>  To restrict method invocation by role, use @Secured \ @PreAuthorize </h3><br>  Write a test that will pass through all the methods of the controllers and check for the presence of @Secured \ @PreAuthorize annotations. <br><br>  When configuring WebSecurityConfigurerAdapter, require authorization for all url.  Add exceptions if necessary.  Exceptions should be as stringent as possible. <br>  Explicitly specify the type of the http method, and the url should be as complete as possible. <br><br>  It is better to explicitly specify the full path to the method, even if there were no other api with such an endpoint at the time of writing. <br><br>  For example, if there is a controller with two GET methods: <code>"url/methodOne", "url/methodTwo"</code> , <br>  Do not do this: <br><br><pre> <code class="java hljs">authorizeRequests().antMatchers(HttpMethod.GET, <span class="hljs-string"><span class="hljs-string">"url/**"</span></span>).permitAll().</code> </pre><br>  Better write: <br><br><pre> <code class="java hljs">authorizeRequests().antMatchers(HttpMethod.GET, <span class="hljs-string"><span class="hljs-string">"url/methodOne"</span></span>, <span class="hljs-string"><span class="hljs-string">"url/methodTwo"</span></span>).permitAll().</code> </pre><br><h3>  In case of problems, enable org.springframework.security: debug </h3><br>  Spring Security has quite detailed debug logs, often they are enough to understand the essence of the problem. <br><br><h3>  Distinguish antMatchers ("permit_all_url"). PermitAll () and web.ignoring (). AntMatchers ("ignored_url") </h3><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSecurity http)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ http.authorizeRequests(). anyRequest() .authenticated() .antMatchers(<span class="hljs-string"><span class="hljs-string">"permit_all_url"</span></span>) .permitAll(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WebSecurity web)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ web.ignoring().antMatchers(<span class="hljs-string"><span class="hljs-string">"ignored_url"</span></span>); }</code> </pre><br>  In the case of ‚Äúignored_url‚Äù it will be checked at the stage of selecting the security filter chain and if the url matches, then an empty filter will be used. <br><br>  In the case of "permit_all_url", the check will take place at the AccessDecisionManager stage. <br><br><h4>  Links </h4><br><ol><li>  <a href="">https://github.com/VladDm93/spring-security-request-journey.git</a> - code. </li><li>  <a href="https://spring.io/guides/topicals/spring-security-architecture/">https://spring.io/guides/topicals/spring-security-architecture - An overview of the architecture of Spring security.</a> <br></li></ol></div><p>Source: <a href="https://habr.com/ru/post/346628/">https://habr.com/ru/post/346628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346606/index.html">Learned Telegram chat bot with AI in 30 lines of Python code</a></li>
<li><a href="../346608/index.html">We test user scripts with Hermione. Yandex lecture</a></li>
<li><a href="../346610/index.html">Reasoning around systems engineering and comments on "Richard Hamming: Chapter 28. Systems Engineering"</a></li>
<li><a href="../346618/index.html">Correcting typos with context</a></li>
<li><a href="../346622/index.html">Examination of internal FPGA defects: we are looking for a black cat in a dark room</a></li>
<li><a href="../346630/index.html">Events, processes and services: a modern approach to automating business processes</a></li>
<li><a href="../346632/index.html">Parsim memes in python: how to bypass the server lock</a></li>
<li><a href="../346634/index.html">Lab: Introduction to Docker from scratch. Your first microservice</a></li>
<li><a href="../346636/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ297 (January 8 - 14, 2018)</a></li>
<li><a href="../346640/index.html">Studying the wget command with 12 examples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>