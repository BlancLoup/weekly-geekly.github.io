<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Internal representation of values ‚Äã‚Äãin PHP7 (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Due to the large amount of material, the publication had to be divided into two parts. In the first one, I‚Äôll talk about how zval (Zend value) impleme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Internal representation of values ‚Äã‚Äãin PHP7 (part 1)</h1><div class="post__text post__text-html js-mediator-article"> Due to the large amount of material, the publication had to be divided into two parts.  In the first one, I‚Äôll talk about how <code>zval</code> (Zend value) implementations have changed since the fifth version of PHP.  Also discuss the implementation of links.  In the second part, the implementation of individual data types, such as strings and objects, will be discussed in detail. <br><br><h1>  zval's in PHP 5 </h1><br>  The zval structure in the fifth version looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_struct</span></span></span><span class="hljs-class"> {</span></span> zvalue_value value; zend_uint refcount__gc; zend_uchar type; zend_uchar is_ref__gc; } zval;</code> </pre><br>  As you can see, the construction includes <code>value</code> , <code>type</code> and additional information <code>__gc</code> , which I will discuss below.  <code>Value</code> is the union of the various possible values ‚Äã‚Äãthat zval can store: <br><a name="habracut"></a><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zvalue_value { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> lval; <span class="hljs-comment"><span class="hljs-comment">//  ,    double dval; //      struct { //   char *val; int len; } str; HashTable *ht; //   zend_object_value obj; //   zend_ast *ast; //   } zvalue_value;</span></span></code> </pre><br>  C language aggregation is a structure in which only one component can be active at a time, and the size of which is equal to the size of the largest component.  All the components of the union are stored in memory in one place and can be interpreted differently, depending on which one of them you are addressing.  If we assume <code>lval</code> , then its value will be interpreted as a signed integer.  The <code>dval</code> value will be represented as a double-precision floating-point number.  And so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To find out which component of the union is currently being used, you can view the current value of the type property: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_NULL 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_LONG 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  lval */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_DOUBLE 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  dval */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_BOOL 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  lval   0  1 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_ARRAY 4 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  ht */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_OBJECT 5 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  obj */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_STRING 6 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  str */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_RESOURCE 7 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  lval   resource ID */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  ,      */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_CONSTANT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_CONSTANT_AST 9</span></span></code> </pre><br><br><h1>  Link Counting in PHP 5 </h1><br>  With a few exceptions, zval in PHP 5 is located in a heap.  Therefore, PHP needs to somehow be monitored: which <code>zval</code> are being used and which ones need to be cleaned.  For this, reference counting is used.  Component <code>refcount__gc</code> just stores information about how many times referred to <code>zval</code> .  For example, in <code>$a = $b = 42</code> the value 42 refers to two variables, so refcount is 2. If the value of refcount is zero, this means that the value is not used and can be cleared. <br><br>  Note that the links that refcount counts (how many times a value is currently used) have nothing to do with PHP links (using &amp;).  To avoid confusion, hereinafter we will use the terms "links" and "PHP-links."  We do not consider the last yet. <br><br>  Similar to the counting of links, the idea underlies the ‚Äúcopy-on-write‚Äù.  You can only use <code>zval</code> together until it changes.  To modify the shared <code>zval</code> it must be duplicated (separated) and all operations should be carried out with a copy. <br><br>  This example shows copying on write and killing <code>zval'</code> : <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// $a -&gt; zval_1(type=IS_LONG, value=42, refcount=1) $b = $a; // $a, $b -&gt; zval_1(type=IS_LONG, value=42, refcount=2) $c = $b; // $a, $b, $c -&gt; zval_1(type=IS_LONG, value=42, refcount=3) //    zval $a += 1; // $b, $c -&gt; zval_1(type=IS_LONG, value=42, refcount=2) // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1) unset($b); // $c -&gt; zval_1(type=IS_LONG, value=42, refcount=1) // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1) unset($c); // zval_1 ,   refcount=0 // $a -&gt; zval_2(type=IS_LONG, value=43, refcount=1)</span></span></code> </pre><br>  Link counting has one serious flaw: this mechanism is not capable of defining circular references.  For this, PHP uses an additional tool - a <a href="http://php.net/manual/en/features.gc.collecting-cycles.php">circular garbage collector</a> .  Every time the value of refcount decreases and there is a chance that <code>zval</code> becomes part of the loop, it is written to the root buffer.  When this buffer is full, potential cycles are marked and cleaned by the garbage collector. <br><br>  The following structure is used to ensure the work of this cyclic collector: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_gc_info</span></span></span><span class="hljs-class"> {</span></span> zval z; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { gc_root_buffer *buffered; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_gc_info</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> } u; } zval_gc_info;</code> </pre><br><br>  The zval_gc_info structure includes a regular <code>zval</code> and an additional pointer.  The <code>u</code> pointer, which is a union, is used to denote one of two types.  The <code>buffered</code> pointer stores information about where the <code>zval</code> referenced in the <code>root buffer</code> .  In the case of <code>zval</code> destruction, the pointer is destroyed until the cyclic collector is started (which is very convenient), <code>next</code> used when the collector deletes values. <br><br><h1>  The need for change </h1><br>  Let's talk a little about the size (all of the following applies to 64-bit systems).  The <code>zvalue_value</code> union is 16 bytes, since <code>str</code> and <code>obj</code> are the same size.  The entire <code>zval</code> structure is 24 bytes, and <code>zval_gc_info</code> is 32 bytes.  Among other things, placing the <code>zval</code> on the heap consumes an additional 16 bytes.  Total for each <code>zval</code> accounts for 48 bytes, regardless of the number of places where it is used. <br><br>  And here doubts creep in the effectiveness of the implementation of <code>zval</code> .  Judge for yourself: let's say it stores a simple integer, which in itself takes 8 bytes.  Also, in any case, you need to store and type label, which occupies one byte, but because of the structure requires all eight.  To the resulting 16 bytes, you need to add another 16 for the needs of reference counting and the cyclic garbage collector, and another 16 for placement on the heap.  Not to mention that the operations of allocation and subsequent deletion consume a lot of resources. <br><br>  It is appropriate to ask the question: does storing simple integers really require reference counting, the use of a cyclic collector, and placement on a heap?  Of course not.  Here is a list of the main problems associated with the implementation of <code>zval</code> in PHP 5: <br><ul><li>  <code>Zval</code> (almost) is always required to be placed on the heap. </li><li>  <code>Zval</code> always require the use of reference counting and gathering information about cycles.  Even in cases where the sharing of values ‚Äã‚Äãis not worth the resources spent (integer) or cycles can not occur in principle. </li><li>  Direct reference counting leads to double execution of this procedure in the case of objects and resources.  The reason for this phenomenon, I will analyze the second part of the publication. </li><li>  In some cases, you have to resort to a large number of bypass maneuvers.  For example, to gain access to an object stored in a variable, you need to totally dereference four pointers, with all the associated strings.  I will also talk about this in the second part. </li><li>  Direct reference counting also means that values ‚Äã‚Äãcan be shared only between <code>zval</code> 's.  For example, a string cannot be shared in a <code>zval</code> and hash table key (without storing this key, also in the form of a zval). </li></ul><br><h1>  Zval's in PHP 7 </h1><br>  In the seventh version of the language, we got a new implementation of <code>zval</code> .  One of the major innovations is that <code>zval</code> no longer needs to be placed separately on the heap.  Also, the refcount is now stored not in the <code>zval</code> itself, but in any of the complex values ‚Äã‚Äãit points to - in strings, arrays or objects.  This gives the following benefits: <br><ul><li>  Simple values ‚Äã‚Äãdo not require placement on the heap and do not use reference counting. </li><li>  No more double counting.  In the case of objects, a counter is used only inside the object itself. </li><li>  Since the <b>refcount is</b> now stored in the actual value, it can be used independently of the zval itself.  For example, a string can be used in <code>zval</code> and be a key in a hash table. </li><li>  Now there are far fewer pointers that need to be iterated to get the value. </li></ul><br>  Here is the structure of the new <code>zval</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zval_struct</span></span></span><span class="hljs-class"> {</span></span> zend_value value; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> ZEND_ENDIAN_LOHI_4( zend_uchar type, zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) } v; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> type_info; } u1; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> var_flags; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next; <span class="hljs-comment"><span class="hljs-comment">// hash collision chain uint32_t cache_slot; // literal cache slot uint32_t lineno; // line number (for ast nodes) uint32_t num_args; // arguments number for EX(This) uint32_t fe_pos; // foreach position uint32_t fe_iter_idx; // foreach iterator index } u2; };</span></span></code> </pre><br><br>  The first component has remained almost the same, this is the union <code>value</code> .  The second component is an integer one that stores information about the type, which is divided into separate bytes using a merge (you can ignore the macro <code>ZEND_ENDIAN_LOHI_4</code> , it is needed only to provide a consistent structure between platforms with different byte order).  The important parts of this nested construct are <code>type</code> and <code>type_flags</code> , which I will discuss below. <br><br>  There is also one small problem here.  <code>Value</code> takes 8 bytes, and due to its structure, adding even one byte will entail an increase in the size of <code>zval</code> by 16 bytes.  But we don‚Äôt need as many as 8 bytes to store the type.  Therefore, in <code>zval</code> there is an additional <code>u2</code> join, which is not used by default, but can be used to store 4 bytes of data.  Different components of the union are designed for different uses of this additional storage. <br><br>  In PHP 7, the <code>value</code> union is slightly different from the fifth version: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _zend_value { zend_long lval; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dval; zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; <span class="hljs-comment"><span class="hljs-comment">//    ,   zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct { ZEND_ENDIAN_LOHI( uint32_t w1, uint32_t w2) } ww; } zend_value;</span></span></code> </pre><br><br>  Note that <code>value</code> now occupies 8 bytes instead of 16. It stores only integer ( <code>lval</code> ) and floating-point numbers ( <code>dval</code> ).  Everything else is a pointer.  All pointer types (with the exception of the special ones noted above) use reference counting and contain a header defined by zend_refcounted: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_refcounted</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> refcount; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> ZEND_ENDIAN_LOHI_3( zend_uchar type, zend_uchar flags, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> gc_info) } v; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> type_info; } u; };</code> </pre><br><br>  Of course, there is also a refcount in this structure.  In addition, there are <code>type</code> , <code>flags</code> and <code>gc_info</code> .  Type only inherits the type of <code>zval</code> and allows the GC to distinguish between different counting structures without storage in <code>zval</code> .  <code>Flags</code> used for different tasks with different data types.  I will tell about it in more detail in the second part. <br><br>  <code>Gc_info</code> similar to <code>buffered</code> in the old version of <code>zval</code> .  But instead of storing the pointer to the <code>root buffer</code> it now stores the index.  Since the <code>root buffer</code> has a limited capacity (10,000 items), it suffices to use a 16-bit pointer instead of a 64-bit one.  Also, <code>gc_info</code> contains information about the ‚Äúcolor‚Äù of the node used to refer to the nodes in the collections. <br><br><h1>  Zval memory management </h1><br>  I already mentioned that <code>zval</code> no longer needs to be placed separately on the heap.  But they need to be stored somewhere.  They are still part of the heap structures.  For example, a hash table will contain its own <code>zval</code> instead of a pointer to a separate <code>zval</code> .  The compiled function variable table and the object property table will be <code>zval</code> arrays.  As such, <code>zval</code> now usually stores those whose indirection is one level lower.  That is, <code>zval</code> 'is now called what used to be <code>zval</code> *. <br><br>  Once it was necessary to copy <code>zval</code> * and increment its refcount in order to use <code>zval</code> in a new location.  Now all you have to do is copy the contents of <code>zval</code> (ignoring <code>u2</code> ) and, <b>perhaps</b> , increment the refcount of the value it points to if the value uses reference counting. <br><br>  How does PHP know that counting is used?  This cannot be determined by type alone, since some types do not use refcount ‚Äî for example, strings and arrays.  For this, one bit of the <code>type_info</code> component is <code>type_info</code> . <br><br>  Several bits are also used to encode type properties: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_TYPE_CONSTANT (1&lt;&lt;0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_TYPE_IMMUTABLE (1&lt;&lt;1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_TYPE_REFCOUNTED (1&lt;&lt;2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_TYPE_COLLECTABLE (1&lt;&lt;3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_TYPE_COPYABLE (1&lt;&lt;4) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_TYPE_SYMBOLTABLE (1&lt;&lt;5) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  */</span></span></span></span></code> </pre><br><br>  There are three basic properties that a type can have: <code>refcounted</code> , <code>collectable</code> and <code>copyable</code> . <br><br>  <code>Collectable</code> means that <code>zval</code> can be part of a loop.  For example, string variables are often <code>refcounted</code> , but it‚Äôs impossible to create a loop with them. <br><br>  <code>opyable</code> determines whether a value should be copied when duplication is performed.  If you duplicate a <code>zval</code> pointing to an array, this does not mean that the refcount value of the array will only increase.  Instead, a new independent copy of the array will be created.  But in the case of some types, for example, objects and resources, with duplication, the refcount only increases.  Such types are called non-copyable.  This corresponds to the transfer of semantics of objects and resources (which are not passed by reference). <br><br>  Below is a table that shows which flags can use certain types.  By "simple" we mean types like integer or boolean, which do not use a pointer to an external structure.  In the second part, I will also examine the unchanging arrays in more detail. <br><br><pre> <code class="php hljs"> | refcounted | collectable | copyable | immutable -----------------------+------------+-------------+----------+----------   | | | |  | x | | x |   | | | |  | x | x | x |   | | | | x  | x | x | |  | x | | |  | x | | |</code> </pre><br>  Let's look at two examples of how the <code>zval</code> control works in practice.  First we take a construction with integer values: <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// $a = zval_1(type=IS_LONG, value=42) $b = $a; // $a = zval_1(type=IS_LONG, value=42) // $b = zval_2(type=IS_LONG, value=42) $a += 1; // $a = zval_1(type=IS_LONG, value=43) // $b = zval_2(type=IS_LONG, value=42) unset($a); // $a = zval_1(type=IS_UNDEF) // $b = zval_2(type=IS_LONG, value=42)</span></span></code> </pre><br><br>  Since integer values ‚Äã‚Äãare no longer shared, both variables use different <code>zval</code> .  I remind you that they are now embedded, and not placed in memory separately.  This is underlined by using = instead of -&gt;.  When clearing a variable, the type of the corresponding <code>zval</code> will change to <code>IS_UNDEF</code> . <br><br>  Now for the second example, here a complex value is already used: <br><br><pre> <code class="php hljs">$a = []; <span class="hljs-comment"><span class="hljs-comment">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[]) $b = $a; // $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=2, value=[]) // $b = zval_2(type=IS_ARRAY) ---^ //    zval $a[] = 1 // $a = zval_1(type=IS_ARRAY) -&gt; zend_array_2(refcount=1, value=[1]) // $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[]) unset($a); // $a = zval_1(type=IS_UNDEF)  zend_array_2  // $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])</span></span></code> </pre><br>  Each variable still has a separate (built-in) <code>zval</code> , but both pointers refer to the same (counted) <code>zend_array</code> structure.  After the change is complete, you need to duplicate the array.  In PHP 5, in a similar situation, everything works the same way. <br><br><h1>  Types </h1><br>  What types are supported in PHP 7: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    #define IS_UNDEF 0 #define IS_NULL 1 #define IS_FALSE 2 #define IS_TRUE 3 #define IS_LONG 4 #define IS_DOUBLE 5 #define IS_STRING 6 #define IS_ARRAY 7 #define IS_OBJECT 8 #define IS_RESOURCE 9 #define IS_REFERENCE 10 //   #define IS_CONSTANT 11 #define IS_CONSTANT_AST 12 //   #define IS_INDIRECT 15 #define IS_PTR 17</span></span></code> </pre><br><br>  What are the differences from PHP 5: <br><ul><li>  The type <code>IS_UNDEF</code> used instead of the pointer to <b><code>zval</code></b> <code>NULL</code> (do not confuse with <code>IS_NULL zval</code> ).  For example, in the examples above, variables are assigned the type <code>IS_UNDEF</code> . </li><li>  The <code>IS_BOOL</code> type <code>IS_BOOL</code> divided into <code>IS_FALSE</code> and <code>IS_TRUE</code> .  Since this boolean value is now built into the type, this allows you to optimize a number of checks based on the type.  This change is unnoticeable for users who still operate with a single ‚Äúboolean‚Äù type. </li><li>  <b>PHP</b> links no longer use the <code>is_ref</code> flag in <b>zval</b> .  A new type <code>IS_REFERENCE</code> introduced <code>IS_REFERENCE</code> .  Below I will tell how it works. </li><li>  <code>IS_INDIRECT</code> and <code>IS_PTR</code> are special internal types. </li></ul><br>  Type <code>IS_LONG</code> instead of the usual <code>long</code> from the C language now uses the value <code>zend_long</code> .  The reason is that in 64-bit Windows, the length is only 32 bits.  Therefore, PHP 5 no longer uses 32-bit numbers on Windows.  And in PHP 7, you can use 64-bit values ‚Äã‚Äãif the system is also 64-bit. <br><br>  In the next part, we take a closer look at the implementation of the <code>zend_refcounted</code> individual types.  Here we confine ourselves to parsing the implementation of PHP links. <br><br><h1>  Links </h1><br>  In PHP 7, the approach to using &amp; PHP links has changed dramatically.  And this was one of the main reasons for the appearance of bugs.  First, let's remember how this is implemented in PHP 5. In the normal situation, the principle of ‚Äúcopy on write‚Äù implies that <code>zval</code> needs to be duplicated before making changes.  This is done in order not to accidentally change the value for each place using <code>zval</code> , which corresponds to the semantics of passing by value. <br><br>  For php links this is no good.  If the value is a PHP link, then you will want to change it for each user.  In PHP 5, the <code>is_ref</code> flag allows <code>is_ref</code> to determine if a value is a PHP reference, and if so, whether a separation is required before making changes. <br><br><pre> <code class="php hljs">$a = []; <span class="hljs-comment"><span class="hljs-comment">// $a -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[]) $b =&amp; $a; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[]) $b[] = 1; // $a = $b = zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[1]) //  is_ref=1, PHP    zval</span></span></code> </pre><br><br>  One significant problem is connected with this approach: it is impossible to share a value between two variables, one of which is a PHP link, and the other is not. <br><br><pre> <code class="php hljs">$a = []; <span class="hljs-comment"><span class="hljs-comment">// $a -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[]) $b = $a; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[]) $c = $b // $a, $b, $c -&gt; zval_1(type=IS_ARRAY, refcount=3, is_ref=0) -&gt; HashTable_1(value=[]) $d =&amp; $c; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[]) // $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[]) // $d   $c,   $a  $b,  zval    .      zval  is_ref=0    is_ref=1. $d[] = 1; // $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[]) // $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[1]) //      zval $d[] = 1   $a  $b.</span></span></code> </pre><br><br>  This behavior leads to the fact that when using links, performance is lower than when using normal values.  Here is a less intricate example illustrating this problem: <br><br><pre> <code class="php hljs">$array = range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>); $ref =&amp; $array; var_dump(count($array)); <span class="hljs-comment"><span class="hljs-comment">// &lt;--   </span></span></code> </pre><br><br>  <code>count()</code> takes a value directly from a variable, but <code>$array</code> is a PHP reference, so a complete copy of the array is created before it is passed to <code>count()</code> .  If <code>$array</code> not a reference, the value would be shared. <br><br>  Now let's see how PHP links are implemented in the seventh version.  Since <code>zval</code> no longer allocated separately, there is no way to use the approach from PHP 5. There is a new type <code>IS_REFERENCE</code> that uses the <code>zend_reference</code> structure as a value: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_reference</span></span></span><span class="hljs-class"> {</span></span> zend_refcounted gc; zval val; };</code> </pre><br><br>  Essentially, <code>zend_reference</code> is a <code>zval</code> with reference counting.  In all variables of the reference set, the <code>zval</code> will be stored with the <code>IS_REFERENCE</code> type pointing to the same <code>zend_reference</code> instance.  The behavior of <code>val</code> is no different from any other <code>zval</code> , including in terms of the possibility of sharing the complex value it points to. <br><br>  In the examples above, consider the semantics of PHP 7. For brevity, we take only the structure referenced by the individual <code>zval</code> variables. <br><br><pre> <code class="php hljs">$a = []; <span class="hljs-comment"><span class="hljs-comment">// $a -&gt; zend_array_1(refcount=1, value=[]) $b =&amp; $a; // $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[]) $b[] = 1; // $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[1])</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A new one </font></font><code>zend_reference</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was created by assigning by reference. </font><font style="vertical-align: inherit;">Notice that the refcount reference is 2 (because two variables are part of the set of PHP references), but the refcount value itself is 1, because it is referenced by one structure </font></font><code>zend_reference</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now consider the situation when using links and non-links:</font></font><br><br><pre> <code class="php hljs">$a = []; <span class="hljs-comment"><span class="hljs-comment">// $a -&gt; zend_array_1(refcount=1, value=[]) $b = $a; // $a, $b, -&gt; zend_array_1(refcount=2, value=[]) $c = $b // $a, $b, $c -&gt; zend_array_1(refcount=3, value=[]) $d =&amp; $c; // $a, $b -&gt; zend_array_1(refcount=3, value=[]) // $c, $d -&gt; zend_reference_1(refcount=2) ---^ //  ,   PHP-,    ,   zend_array. $d[] = 1; // $a, $b -&gt; zend_array_1(refcount=2, value=[]) // $c, $d -&gt; zend_reference_1(refcount=2) -&gt; zend_array_2(refcount=1, value=[1]) //       zend_array,   .</span></span></code> </pre><br><br>          ,           ,    ,    PHP-  .        .    PHP 7     <code>count()</code>   ,       .         ,      <code>zend_reference</code>       . <br><br><h1>  Conclusion </h1><br>  :    PHP 7   ,  <code>zval</code>     ,      refcount.      ,      ‚Äî ,   .       ,      . </div><p>Source: <a href="https://habr.com/ru/post/257999/">https://habr.com/ru/post/257999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257981/index.html">Automatically Testing JavaFX Applications</a></li>
<li><a href="../257983/index.html">What does it mean to develop a robot</a></li>
<li><a href="../257985/index.html">Development of MMO RPG - a practical guide. Server (Part 1)</a></li>
<li><a href="../25799/index.html">We do TIKR.ru - an analogue of Google / Yahoo Finance</a></li>
<li><a href="../257991/index.html">Features of API development on symfony2</a></li>
<li><a href="../2580/index.html">Google plugin gives passwords</a></li>
<li><a href="../258003/index.html">Artificial Intelligence in Wolfram Language: Image Identification Project</a></li>
<li><a href="../258005/index.html">Development for Microsoft SQL Server (and not only): version control, continuous integration and procedures - as we do</a></li>
<li><a href="../258007/index.html">HP P2000 G3 MSA Array System Firmware Update</a></li>
<li><a href="../258009/index.html">Lock for the designer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>