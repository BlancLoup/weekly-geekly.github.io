<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Misconceptions about automated testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Dmitry Karlovsky and this is a continuation of the traditional heading "Why do we not like to write tests?". The short answer is: be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Misconceptions about automated testing</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello, my name is Dmitry Karlovsky and this is a continuation of the traditional heading "Why do we not like to write tests?".  The short answer is: because the bonuses received from them do not outweigh the effort.  If so, then we are doing something wrong.  Let's see what could have gone wrong .. </p><br><p><img src="https://habrastorage.org/webt/af/hv/wx/afhvwxpluy8ocuzlmuw5pupndji.jpeg" alt="Picture to attract attention"></p><br><p>  This article grew out of the "Misconceptions" section of Longrid, <a href="https://habrahabr.ru/post/351430/">"The Concept of Automatic Testing,"</a> through the addition of new errors and arguments. </p><a name="habracut"></a><br><h2 id="modulnye-testy-bystree-komponentnyh">  Unit tests faster component </h2><br><p>  Yes, moki are usually executed faster than real code.  However, they hide some kinds of errors, which is why they have to write more tests.  If the framework does not know how to be lazy and does a lot of unnecessary work to raise the component tree (for example, <a href="https://www.webcomponents.org/">web-components</a> with nails nailed to the DOM or <a href="https://angular.io/guide/testing">TestBed in Angular</a> that creates everything in the world during initialization), then the tests slow down significantly, but not so fatally.  If the framework does not render until it is asked for it and does not create components until they are needed (such as <a href="https://github.com/eigenmethod/mol/tree/master/view">$ mol_view</a> ), component tests pass no slower than modular ones. </p><br><h2 id="s-komponentnymi-testami-slozhno-lokalizovat-oshibku">  With component tests it is difficult to locate the error </h2><br><p>  Yes, if they are executed in a random order, then an error in logic can drop a bunch of tests from which it may not be clear where to start digging.  This, unfortunately, is a common anti-pattern - to find all files with a given extension and execute them in a random order, saying that the tests do not depend on each other.  And this is true for unit tests. </p><br><p>  However, it makes sense to perform component tests in order from less dependent components to more dependent ones.  Then the first fallen test will show the source of the problem.  The rest of the tests can usually not be performed anymore, which is great saving time for passing the tests.  Again, in the <a href="https://github.com/eigenmethod/mam">MAM architecture,</a> all the code (which is production, that test) is serialized in a single order.  This ensures that dependency tests are performed before the dependent tests, which means that they can safely rely on the dependency to work correctly.  If you use other tools, consider how you can use them to build tests in the correct order. </p><br><h2 id="shablony-testirovat-ne-nado">  Templates do not need to test </h2><br><p>  It is necessary to test the logic.  A rare template engine ( <a href="https://mustache.github.io/">mustache</a> , <a href="https://github.com/eigenmethod/mol/tree/master/view">view.tree</a> ) prohibits embedding logic into templates, which means they should also be tested.  Often, unit tests are not suitable for this ( <a href="http://airbnb.io/enzyme/">enzyme</a> as a rare exception), so you still have to resort to component ones. </p><br><h2 id="testy-dolzhny-sootvetstvovat-shablonu-givenwhenthen">  Tests must follow the Given / When / Then pattern. </h2><br><p>  Yes, sometimes in the test scenario, you can highlight these steps, but do not suck them out of your finger when they are not.  Often, the script has a simpler (for example, only Then block) or complex (Given / Check / When / Then) structure.  A few examples: </p><br><p>  Pure functions often have only the Then block: </p><br><pre><code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert( <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow( <span class="hljs-number"><span class="hljs-number">2</span></span> , <span class="hljs-number"><span class="hljs-number">3</span></span> ) === <span class="hljs-number"><span class="hljs-number">8</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Then</span></span></code> </pre> <br><p>  No less often, the action (When) consists precisely in preparing the state (Given): </p><br><pre> <code class="hljs pgsql">component.setState({ <span class="hljs-type"><span class="hljs-type">name</span></span> : <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> }) // Given/<span class="hljs-keyword"><span class="hljs-keyword">When</span></span> console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( component.greeting === <span class="hljs-string"><span class="hljs-string">'Hello, Jin!'</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span></code> </pre> <br><p>  And it happens that verification is not needed, because the very fact of successful code execution is sufficient: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ensurePerson</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">name </span></span>: <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> , age : <span class="hljs-number"><span class="hljs-number">33</span></span> })</code> </pre> <br><p>  Similar code is completely meaningless: </p><br><pre> <code class="hljs vhdl">const <span class="hljs-keyword"><span class="hljs-keyword">component</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyComponent // Given expect( <span class="hljs-keyword"><span class="hljs-keyword">component</span></span> ).toBeTruthy() // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span></code> </pre> <br><p>  Just like a test that never fell, it doesn't test anything.  So an assort who never threw an exception does not check anything. </p><br><h2 id="v-pravilnom-teste-dolzhen-byt-tolko-odin-assert">  In the right test there should be only one assert. </h2><br><p>  It is not uncommon for us to check that we have correctly prepared the state with a mid-point calibration: </p><br><pre> <code class="hljs pgsql">wizard.nextStep().nextStep() // Given console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( wizard.passport.isVisible === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Check</span></span> wizard.toggleRegistration() // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( wizard.passport.isVisible === <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span></code> </pre> <br><p>  It is impossible to break this test into the following two, since the second implicitly relies on the state created by the first: </p><br><pre> <code class="hljs pgsql">wizard.nextStep().nextStep() // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( wizard.passport.isVisible === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span></code> </pre> <br><pre> <code class="hljs pgsql">wizard.nextStep().nextStep() // Given wizard.toggleRegistration() // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( wizard.passport.isVisible === <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span></code> </pre> <br><p>  Imagine that the requirements have changed and now by default we show the registration form: </p><br><pre> <code class="hljs pgsql">wizard.nextStep().nextStep() // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( wizard.passport.isVisible === <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span></code> </pre> <br><p>  Now, if <code>toggleRegistration</code> implemented in such a way that, for example, it uses its state to speed up work, then it will pass the second test, still returning true and it turns out that the first application of <code>toggleRegistration</code> will not change anything in the form: </p><br><pre> <code class="hljs kotlin">isPassportVisible = <span class="hljs-literal"><span class="hljs-literal">false</span></span> toggleRegistration() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.passport.isVisible = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isPassportVisible = !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isPassportVisible }</code> </pre> <br><p>  In the variant with the additional verification of the default state, we would have caught the dropped test in this case.  Moreover, one should not be afraid to write longer scripts if the next step is based on the state of the previous one. </p><br><pre> <code class="hljs pgsql">wizard.nextStep().nextStep() // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( wizard.passport.isVisible === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> wizard.toggleRegistration() // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( wizard.passport.isVisible === <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> wizard.toggleRegistration() // <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> console.<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( wizard.passport.isVisible === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ) // <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span></code> </pre> <br><p>  Usually, the argument against this approach is the difficulty of understanding which of the asserts has fallen.  But wait, no one forces you to use such a testing tool that does not provide comprehensive information about the location of the test crash.  A good tool (for example, <a href="https://github.com/eigenmethod/mol/tree/master/test">$ mol_test</a> ) will even helpfully stop the debugger in this place, allowing you to immediately begin to investigate the problem. </p><br><p>  To summarize, we can recommend writing tests not using the "Given / When / Then" pattern, but as a small adventure, starting from absolute emptiness and through a certain number of actions, going through a number of states, which we check. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353080/">https://habr.com/ru/post/353080/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353068/index.html">Sending mail from the Docker container (postfix and sasl dokerization)</a></li>
<li><a href="../353070/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ309 (April 2 - 8, 2018)</a></li>
<li><a href="../353072/index.html">Developing native extensions for Node.js</a></li>
<li><a href="../353074/index.html">About the main reason for the existence of modern JS frameworks</a></li>
<li><a href="../353076/index.html">React-testing-library library overview</a></li>
<li><a href="../353082/index.html">Desperate quad circle search</a></li>
<li><a href="../353084/index.html">Digital Signature Cloud Services</a></li>
<li><a href="../353088/index.html">We write the plugin for Unity correctly. Part 1: iOS</a></li>
<li><a href="../353090/index.html">IT asset management: how myths affect projects (Part 2)</a></li>
<li><a href="../353092/index.html">Digital events in Moscow from April 9 to 15</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>