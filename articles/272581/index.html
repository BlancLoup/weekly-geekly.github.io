<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Zsh life tricks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zsh is one of the best command shells, with an impressive array of features. However, due to the large number of possibilities, it is not surprising t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Zsh life tricks</h1><div class="post__text post__text-html js-mediator-article">  Zsh is one of the best command shells, with an impressive array of features.  However, due to the large number of possibilities, it is not surprising that some of them pass by the attention or the possibility of using them to solve everyday tasks is not obvious.  This article will look at both a few ‚Äúbuilt-in‚Äù features of zsh, as well as examples of complex code that make life easier. <div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  <a href="https://habr.com/post/272581/">1. Using READNULLCMD</a> <br>  <a href="https://habr.com/post/272581/">2. Insert the opening and closing brackets</a> <br>  <a href="https://habr.com/post/272581/">3. Global alias</a> <br>  <a href="https://habr.com/post/272581/">4. Returning terminal settings</a> <br>  <a href="https://habr.com/post/272581/">5. zmv function</a> <br>  <a href="https://habr.com/post/272581/">6. Run mpv with automatically found subtitles</a> <br>  <a href="https://habr.com/post/272581/">7. Creation of commands with automatic screening of arguments.</a> <br>  <a href="https://habr.com/post/272581/">8. Automatic exclusion of files from globs</a> </div></div><a name="habracut"></a><br><a name="readnullcmd"></a><h1>  1. Using READNULLCMD </h1><br>  The variable READNULLCMD specifies the command to be called if the stdin redirection is used without entering the command: <code>&lt;file.txt</code> .  So you can call <code>less</code> by typing a lot less characters: just set <code>READNULLCMD=less</code> . <br><br><a name="parenthesis"></a><h1>  2. Insert the opening and closing brackets </h1><br>  Editors like Vim often use add-ons that automatically close parentheses when they are entered.  Those.  when you enter <code>[</code> you get <code>[]</code> with a cursor in the middle.  In shells, this is also possible (even in bash): you just need to use something like <code>binkey -s "[" $'\Cv[]\C-b'</code> : the equivalent of this command may well be placed in .inputrc.  A more versatile solution for zsh is to use ZLE widgets: <pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>-<span class="hljs-type"><span class="hljs-type">double</span></span>-brackets() { LBUFFER="${LBUFFER}[[ " RBUFFER=" ]]${RBUFFER}" } zle -N <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>-<span class="hljs-type"><span class="hljs-type">double</span></span>-brackets bindkey <span class="hljs-string"><span class="hljs-string">',H'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>-<span class="hljs-type"><span class="hljs-type">double</span></span>-brackets</code> </pre>  Here, the LBUFFER variable contains the entire command line up to the cursor, and the RBUFFER variable contains the whole after.  The second command creates a widget, the third assigns it to the combination <code>,H</code> : thus input <code>,H</code> turns into <code>[[ ]]</code> with the cursor in the middle. <br><br><a name="global-aliases"></a><h1>  3. Global alias </h1><br>  You all probably know what an alias is in a shell, and you may have used something like <code>alias hp='hg push'</code> .  Alias ‚Äã‚Äãin zsh have two additional features:  suffix alias, which allow you to automatically open files without entering a program (example: <code>alias -s txt=vim</code> turns the <code>foo.txt</code> command into <code>vim foo.txt</code> ) and global ones.  I have never used the first ones, but I find the second ones quite useful. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Global alias are used to replace single words with their meaning.  Unlike suffix and ordinary alias, the replaced word does not have to be in the command position (i.e., the first word on the command line, or the first word after the command separator).  Since alias are processed before the main parser works, you can easily have anything in the global alias: redirection, <code>if</code> , command delimiters. <br><br>  From my point of view, redirection of various kinds is most useful: <pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> -g NN=<span class="hljs-string"><span class="hljs-string">'&amp;&gt;/dev/null'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> -g L=<span class="hljs-string"><span class="hljs-string">'|less'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> -g G=<span class="hljs-string"><span class="hljs-string">'|grep'</span></span></code> </pre>  In this example, three alias are defined: one silences the command, another uses less to show the output of the command, the third filters input.  Example use: write <code>hg cat -r default file.csv G 42 L</code> equivalent to <code>hg cat -r default file.csv | grep 42 | less</code> <code>hg cat -r default file.csv | grep 42 | less</code>  <code>hg cat -r default file.csv | grep 42 | less</code> , but much shorter.  To submit the <code>G</code> command to the input, it is literally necessary to use shielding: <code>\G</code> or <code>'G'</code> .  Note that <code>\G</code> and <code>'G'</code> also form words, and they can also have alias: <code>alias -g "'G'=|grep"</code> , but I hope you are sane enough to not use this fact. <br><br>  Despite its convenience, due to some features of zsh, global alias are very dangerous because they can spoil zsh add-ons.  I saw in one <code>case</code> script, where there was also a condition of the form <code>L)</code> , and it did not work because of its transformation into a completely different condition.  Therefore, global alias should be determined most recently, after you have already downloaded all the add-ons.  To load add-ons after detection, disable the <code>ALIASES</code> setting: use something like <pre> <code class="hljs bash"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">source</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">setopt</span></span> localoptions <span class="hljs-built_in"><span class="hljs-built_in">setopt</span></span> noaliases <span class="hljs-built_in"><span class="hljs-built_in">builtin</span></span> <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${@[@]}</span></span></span><span class="hljs-string">"</span></span> } .() { <span class="hljs-built_in"><span class="hljs-built_in">setopt</span></span> localoptions <span class="hljs-built_in"><span class="hljs-built_in">setopt</span></span> noaliases <span class="hljs-built_in"><span class="hljs-built_in">builtin</span></span> . <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${@[@]}</span></span></span><span class="hljs-string">"</span></span> }</code> </pre>  And so for each option of loading add-ons (besides <code>source</code> and <code>.</code> There is also at least <code>autoload</code> , about the effectiveness of just such functions for which I‚Äôm not sure what I‚Äôve done).  Global alias, however, are dangerous only in an interactive session, scripts with <code>#!/bin/zsh</code> will not be affected. <br><br><a name="term-reset"></a><h1>  4. Returning terminal settings </h1><br>  It is not a secret to anyone that if you write <code>cat /bin/test</code> (more precisely, <code>cat any-binary-file</code> ), you can get various strange effects: for example, replacing part of the characters entered further with symbols for drawing graphics.  Most effects are eliminated by writing blindly <code>echo $'\ec'</code> , but this is the thing that I would like to automate.  The hook <code>precmd</code> will help us in this, allowing you to run your function right before the shell is displayed.  The problems that I sometimes see, if I accidentally output a binary file to the terminal, my editor (Vim) crashes, or I just run wine (for some reason it switches the keyboard transmit mode and does not return): graphic symbols instead of normal, alternate screen becomes main (= there is no scrollback (input history)), the arrows stop working (the keyboard transmit is marked here), the cursor is not displayed.  To solve them, the following function was created: <pre> <code class="hljs lua">_echoti() { emulate -L zsh (( ${+terminfo[$<span class="hljs-number"><span class="hljs-number">1</span></span>]} )) &amp;&amp; echoti $<span class="hljs-number"><span class="hljs-number">1</span></span> } term_reset() { emulate -L zsh <span class="hljs-string"><span class="hljs-string">[[ -n $TTY ]]</span></span> &amp;&amp; (( $+terminfo )) &amp;&amp; { _echoti rmacs #    _echoti sgr0 #   _echoti cnorm #   _echoti smkx #  ¬´keyboard transmit mode¬ª echo -n $<span class="hljs-string"><span class="hljs-string">'\e[?47l'</span></span> #  alternate screen # See https://github.com/fish-shell/fish-shell/issues/<span class="hljs-number"><span class="hljs-number">2139</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> smkx } } zmodload zsh/terminfo &amp;&amp; precmd_functions+=( term_reset ) ttyctl -f</code> </pre>  .  After its introduction to type <code>echo $'\ec'</code> I almost no longer have to. <br><br>  Also note <code>ttyctl -f</code> : this built-in zsh feature blocks some changes to the terminal settings: those settings that are set using <code>stty</code> , and not those that can be set using special sequences (escape sequences). <br><br><a name="zmv"></a><h1>  5. zmv function </h1><br>  You may have come across the rename command to automatically rename multiple files.  It even exists in two copies: a <a href="http://search.cpan.org/dist/rename/">variant</a> written in perl and written in <a href="http://rename.sourceforge.net/">C.</a>  Zsh has something similar, but only more powerful: first, you can copy files this way or run <code>hg mv</code> instead of just moving around the <code>mv</code> type.  Secondly, you can use an ‚Äúintuitive‚Äù version like <code>noglob zmv -W *.c *.cpp</code> (to get rid of <code>noglob</code> , use <code>alias</code> ; in the following examples, <code>noglob</code> implied).  Zmv does not use regular expressions for work, but expressions more suitable for the glob task.  You can also use virtually any expression as the second argument: <code>zmv -w test_*.c 'test/${1/_foo/_bar}'</code> will turn <code>test_foo_1.c</code> into <code>test_bar_1.c</code> .  Here, parameters like <code>$N</code> provide access to the ‚Äúcapturing groups‚Äù analog from regular expressions, and <code>-w</code> turns <code>test_*.c</code> into <code>test_(*).c</code> <br><br>  All arguments: <ul><li>  <code>-f</code> : ignore target file.  Those.  if the <code>test.cpp</code> file exists, then the <code>zmv -W *.c *.cpp</code> command will refuse to move any files if <code>test.c</code> is among them.  <code>-f</code> will force zmv to do this, but, however, will not pass the <code>-f</code> argument to <code>mv</code> . </li><li>  <code>-i</code> : clarify the need before each move.  For an affirmative answer, you need to press <code>y</code> or <code>Y</code> , for refusal you need to press something else.  Note: you <i>only</i> need to press <code>y</code> or <code>Y</code>  You do not need to press the input, it will be perceived as a failure for the next file. </li><li>  <code>-n</code> : print all commands that zmv will execute without actually executing. </li><li>  <code>-Q</code> : enable glob qualifiers.  Due to the fact that glob qualifier is easily confused with the capturing group, they are disabled by default.  Glob qualifier is a part of glob that specifies the result: there are qualifiers for determining the sort order, including some settings for one glob, and also the filters that are most useful in these circumstances, such as ‚Äúreveal only symbolic links‚Äù. </li><li>  <code>-s</code> : pass additional argument <code>-s</code> to the command.  Used in conjunction with <code>-L</code> , or equivalent using <code>zln</code> instead of <code>zmv</code> . </li><li>  <code>-v</code> : print executable commands as they are executed. </li><li>  <code>-o</code> <i>arg</i> : specify additional arguments for the command.  So, to pass the <code>mv</code> argument <code>--force</code> you need to use <code>zmv -o--fore</code> .  Can only be used once. </li><li>  <code>-p</code> <i>prog</i> : use this program instead of mv.  The command must understand <code>--</code> : it will be executed as <code>prog -- source target</code> . </li><li>  <code>-P</code> <i>prog</i> : similar to the previous argument, but for commands that do not understand <code>--</code> .  The program will be called as <code>prog source target</code> . </li><li>  <code>-w</code> : automatically add capturing groups for all wildcards, described above. </li><li>  <code>-W</code> : same as the previous argument, but using the <code>$N</code> parameters created for capturing groups automatically occurs for wildcards in the right argument. </li><li>  <code>-C</code> , <code>-L</code> and <code>-M</code> : similar to <code>-pcp</code> , <code>-pln</code> and <code>-pmv</code> respectively: allows you to use copy, create symbolic links or move regardless of the name of the function (by default there are two additional functions that use the same code as zmv : zcp and zln). </li></ul><br><a name="aplayer"></a><h1>  6. Run mpv with automatically found subtitles </h1><br>  If you have ever downloaded serials with external subtitles from torrents, then you have undoubtedly noticed that every person posting them has his own opinion as to where the subtitles should be.  There are two main options: in your own directory and directly next to the video, but under the ‚Äúown directory‚Äù any directory name can be hidden, and even different embedding depths: I saw directories like ‚Äúsubs {sub group}‚Äù, ‚Äúsubtitles {sub group}‚Äù , "Subs / {sub group}" and even simply "{sub group}".  An additional problem is the use of non-standard fonts in subtitles, with their distribution along with subtitles. <br><br>  You can use different methods to ensure that the subtitles are still picked up and use the correct fonts.  I chose to create a function that automatically does the necessary work in almost all cases: <pre> <code class="hljs lua">aplayer() { emulate -L zsh setopt extendedglob setopt nullglob <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -a args args=() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -A mediadirs mediadirs=() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $@ ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">[[ ${arg[0]} == '-' ]]</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> continue fi <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test -f $<span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> mediadirs[${<span class="hljs-built_in"><span class="hljs-built_in">arg</span></span>:A:h}]=<span class="hljs-number"><span class="hljs-number">1</span></span> fi done <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -i found=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ${(k)mediadirs} ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> tail=$d:t test -d ~/.fonts/aplayer/${tail}<span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; continue <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $d/**/(#i)font* ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test -d $f ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> (( found++ )) ln -s $f ~/.fonts/aplayer/${tail}-${found} elif <span class="hljs-string"><span class="hljs-string">[[ $f == (#i)*.rar ]]</span></span> || <span class="hljs-string"><span class="hljs-string">[[ $f == (#i)*.zip ]]</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> (( found++ )) mkdir ~/.fonts/aplayer/${tail}-${found} pushd -q ~/.fonts/aplayer/${tail}-${found} <span class="hljs-number"><span class="hljs-number">7</span></span>z x $f popd -q fi done done <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( found )) ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fc-cache -v ~/.fonts fi <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -aT subpaths SUBPATHS <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -A SUBPATHS_MAP SUBPATHS=( ${(k)^mediadirs}/(#i)*(<span class="hljs-built_in"><span class="hljs-built_in">sub</span></span>|)*{,/**/*}(/) ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $SUBPATHS ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> SUBPATHS_MAP[$sp]=<span class="hljs-number"><span class="hljs-number">1</span></span> done <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -a subarr <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ${(k)mediadirs} ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> subd <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $d/**/ ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! test -z $SUBPATHS_MAP[$d] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> continue fi subarr=( $subd/*.(ass|ssa|srt) ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( $#subarr )) ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> SUBPATHS_MAP[$subd]=<span class="hljs-number"><span class="hljs-number">1</span></span> SUBPATHS+=( $subd ) fi done done <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( ${#SUBPATHS} )) ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> args+=( <span class="hljs-comment"><span class="hljs-comment">--sub-paths $subpaths ) fi mpv $args $@ &amp;&gt;/dev/tty }</span></span></code> </pre>  Having zsh things like associative arrays helps a lot when creating such functions. <br><br>  Here, the first part of the function is traversed by all arguments and clogs the catalogs in which the works are located in the associative array mediadirs.  It is made associative solely to avoid duplicates. <br><br>  Further, the function is traversed in all directories with works and finds fonts in them or subdirectories, which can be either in the archive or in a subdirectory.  Fonts are determined by a specific name (the presence of a <code>font</code> at the beginning of the name), <code>setopt nullglob</code> allows you not to clue about their absence (by default, the absence would cause an error).  Using <code>setopt extendedglob</code> together with <code>(#i)</code> allows you not to worry about the register: <code>(#i)</code> allows fonts to be located both in the <code>FONTS</code> directory and in <code>Fonts</code> .  After finding and installing fonts in <code>~/.fonts</code> indexes are updated using <code>fc-cache</code> : otherwise, even fonts copied to the correct directory will not be used.  <code>${(k)ASSOCIATIVE_ARRAY}</code> turns an associative array into a simple array of keys. <br><br>  In the third cycle, there are directories with subtitles that have ‚Äúsimple‚Äù names like ‚Äúsubs‚Äù or ‚Äúsubtitles‚Äù and are stuffed into an associative array.  Again, ignoring case and separately <code>(/)</code> at the end are used, limiting glob to directories only (for example, glob qualifier).  <code>${^array}</code> used to make <code>array=( abc ); echo ${^array}*</code>  <code>array=( abc ); echo ${^array}*</code> was equivalent to <code>echo {a,b,c}*</code> . <br><br>  The last cycle finds directories with subtitles, called non-standard way.  A subtitle directory is considered to be any subdirectory (with respect to video directories) containing at least one file with the <code>ass</code> , <code>ssa</code> or <code>srt</code> extension. <br><br>  It is necessary to note the presence of a rather strange code: nobody seems to touch the <code>subpaths</code> variable, but its value is used as the argument <code>--sub-paths</code> .  The fact is that zsh noted a rather frequent pattern when an array of values ‚Äã‚Äã(usually directories) is a simple string, where different values ‚Äã‚Äãare separated from each other by a separator (usually a colon): an example of such an ‚Äúarray‚Äù is <code>PATH</code> .  However, it would be convenient for programmers to work with such arrays exactly as with arrays, therefore, ‚Äúlinked‚Äù variables were created, where one of the array variables (example: <code>path</code> ) and another string with the specified (default colon) separator (example: <code>PATH</code> ) , and the change of one of the variables is automatically reflected in the other.  In this way, the <code>SUBPATHS</code> array was associated with the string <code>subpaths</code> . <br><br><a name="zpy"></a><h1>  7. Creation of commands with automatic screening of arguments. </h1><br>  Arguments of some commands are never files.  However, this fact does not stop zsh from disclosing templates.  In the usual case, it suffices to write <code>alias mycmd='noglob mycmd'</code> and <code>mycmd *.foo</code> will become equivalent to <code>mycmd '*.foo'</code> .  But what if you want to create a team, at the input of which you are going to file <code>$VAR</code> literally and do not want to write <code>'$VAR'</code> ?  Here I will give an example of code that records <code>zpy import zsh; print(zsh.getvalue("PATH"))</code>  <code>zpy import zsh; print(zsh.getvalue("PATH"))</code> equivalent to <code>zpython 'import zsh; print(zsh.getvalue("PATH"))'</code>  <code>zpython 'import zsh; print(zsh.getvalue("PATH"))'</code> ;  of course, only in interactive mode: <pre> <code class="hljs bash"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zshaddhistory</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">emulate</span></span> -L zsh <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( <span class="hljs-variable"><span class="hljs-variable">${+_HISTLINE}</span></span> &amp;&amp; <span class="hljs-variable"><span class="hljs-variable">${#_HISTLINE}</span></span> )) ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> -sr -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${_HISTLINE}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">unset</span></span> _HISTLINE <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (( <span class="hljs-variable"><span class="hljs-variable">${#1}</span></span> )) ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> -sr -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${1%%$'\n'}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fc</span></span> -p } accept-<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">line</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">emulate</span></span> -L zsh <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">${BUFFER[1,4]}</span></span> == <span class="hljs-string"><span class="hljs-string">"zpy "</span></span> ]] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> _HISTLINE=<span class="hljs-variable"><span class="hljs-variable">$BUFFER</span></span> BUFFER=<span class="hljs-string"><span class="hljs-string">"zpython </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${(qqq)BUFFER[5,-1]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> .accept-line } <span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> -N accept-line</code> </pre>  The main part of the function: when you call the accept-line widget (it is called when you press enter) it determines whether the line starts with <code>zpy</code> and, if so, the line is replaced with <code>zpython ‚Ä¶</code> , where <code>‚Ä¶</code> is the screened part of the line after <code>zpy</code> and space.  The <code>zshaddhistory</code> function <code>zshaddhistory</code> used to ensure that the source line is in history, not its replacement. <br>  In this way, you can add any nonstandard syntax to zsh. <br><br><a name="globfilter"></a><h1>  8. Automatic exclusion of files from globs </h1><br>  Imagine that you have a Vim editor and you want to use it to open all the files in the directory (use the template <code>*</code> ).  But besides simple text files in the directory there are many binary files like <code>*.o</code> (object) files that you do not want to open.  To do this, instead of just the asterisks, you can write several templates corresponding to the necessary files.  Or use an exception pattern ( <code>*~*.o</code> , requires <code>setopt extendedglob</code> ).  But with a relatively simple trick, you can automate it: <pre> <code class="hljs lua">filterglob () { <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -r exclude_pat=<span class="hljs-string"><span class="hljs-string">"$2"</span></span> shift <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -r cmd=<span class="hljs-string"><span class="hljs-string">"$1"</span></span> shift <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -a args args=( <span class="hljs-string"><span class="hljs-string">"${@[@]}"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -a new_args <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> -i expandedglobs=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> first_unexpanded_glob= <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((I=<span class="hljs-number"><span class="hljs-number">1</span></span>; I&lt;=$#args; I++ )) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">[[ $args[I] != ${${args[I]}/[*?]} ]]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> initial_arg=${args[I]} args[I]+=<span class="hljs-string"><span class="hljs-string">"~$exclude_pat(N)"</span></span> new_args=( $~args[I] ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( $#new_args )) ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> expandedglobs=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">[[ $options[cshnullglob] == off &amp;&amp; $options[nullglob] == off ]]</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">[[ $options[nomatch] == on ]]</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> : ${~${args[I]%\(N\)}} # Will <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> out. <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> new_args=( <span class="hljs-string"><span class="hljs-string">"$initial_arg"</span></span> ) fi fi <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">[[ -z $first_unexpanded_glob ]]</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> first_unexpanded_glob=${args[I]%\(N\)} readonly first_unexpanded_glob fi fi args[I,I]=( <span class="hljs-string"><span class="hljs-string">"${new_args[@]}"</span></span> ) (( I += $#new_args - <span class="hljs-number"><span class="hljs-number">1</span></span> )) fi done <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">[[ $options[cshnullglob] == on &amp;&amp; $options[nullglob] == off ]]</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( !expandedglob )) ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> : $~first_unexpanded_glob # Will <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> out. fi fi <span class="hljs-string"><span class="hljs-string">"$cmd"</span></span> <span class="hljs-string"><span class="hljs-string">"${args[@]}"</span></span> } alias vim=<span class="hljs-string"><span class="hljs-string">'noglob filterglob "*.o" vim'</span></span></code> </pre>  This defines alias, which prohibits zsh (noglob) itself, but uses the function that opens the templates (filterglob) to launch vim itself.  But it doesn‚Äôt just reveal them, but also complements the template with the exception so that <code>vim *</code> will work as <code>vim *~*.o</code> . <br>  The function uses the following zsh features: <code>${~var}</code> causes zsh to use a pattern expansion as applied to the value of the <code>var</code> variable and substitutes the result of the pattern expansion instead of the variable itself.  <code>array[idx1,idx2]=( $new_array )</code> removes part of the array from <code>idx1</code> to <code>idx2</code> inclusive, inserting the values ‚Äã‚Äãof the array <code>new_array</code> in place of the deleted elements.  The size of the <code>array</code> can change.  Constructs of the form <code>: $~var</code> with the comment ‚ÄúWill error out‚Äù are needed in order for zsh to show the expected error.  At the same time, the function is completed.  There are no particular reasons to use this option instead of <code>echo ‚Ä¶ &gt;&amp;2</code> , although my like should support catching an error using <code>always</code> (which you are unlikely to use in an interactive session). </div><p>Source: <a href="https://habr.com/ru/post/272581/">https://habr.com/ru/post/272581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272571/index.html">Call event handlers thread-safe without extra assignment in C # 6</a></li>
<li><a href="../272573/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 21. "Master Splyntr"</a></li>
<li><a href="../272575/index.html">Minimum font size and default encoding in Vivaldi 1.0.344.5</a></li>
<li><a href="../272577/index.html">How to copy Skype and Google Chrome and Mozilla Firefox settings profiles from one / home to another</a></li>
<li><a href="../272579/index.html">Free course ‚ÄúAndroid. Fast start"</a></li>
<li><a href="../272589/index.html">Exploitation of injections in Hibernate ORM</a></li>
<li><a href="../272591/index.html">Microsoft added the ability to disable tracking in versions of Windows 10 for corporate clients</a></li>
<li><a href="../272593/index.html">How institution botanists automate</a></li>
<li><a href="../272597/index.html">How to make friends 1C and Office 365</a></li>
<li><a href="../272601/index.html">Google fixed Android vulnerabilities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>