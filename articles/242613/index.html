<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Write clean code with Reactive Extensions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have a process that can run for a long time and return several intermediate results over time, then the .NET Framework Reactive Extensions will...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Write clean code with Reactive Extensions</h1><div class="post__text post__text-html js-mediator-article">  <i>If you have a process that can run for a long time and return several intermediate results over time, then the <b>.NET Framework Reactive Extensions</b> will allow you to simplify the code and better manage it.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/f37/dee/4cff37dee24402a5c5e3c33a5f2c0eb1.jpg" alt="pure code with reactive extensions"><br><br>  In most cases, you simply call the method and get the result at the output.  But some processes are different.  For example, the method can be performed for a long period of time.  Or, worse, the method not only runs for a long time, but also irregularly returns some intermediate results during execution.  Of course, including for this, there are events in the .NET Framework, with the help of events a single object can call the method of the second object, passing some information, at that moment in time when it is needed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But there is a solution to this problem better than using events - Reactive Extensions.  If you have a process that works for a long time and returns intermediate results from time to time, then Jet Extensions will help you handle such results whenever they come.  The code from using Reaction Extensions instead of events not only becomes simpler, but you also get richer functionality (for example, you can use LINQ to filter out any unnecessary data). <br><a name="habracut"></a><br>  The documentation for Reactive Extensions is described as a way to handle data flow.  When working with Extensions, it is not difficult to imagine any process that iterates over data in a collection, periodically searches for something interesting and sends to the application what it found - this causes the application to react <i>(to react)</i> , hence the name ‚ÄúReactive‚Äù <i>(reactive)</i> ).  In our example, we will assume that we want to do something while our application performs a number of changes in the sales order.  To do this, we need to write the <i>StatusChanged</i> method and call it every time an order changes in the application.  Or, we can add the <i>StatusChanged</i> event to our <i>SalesOrder</i> class and call it every time the status changes ‚Äî we can simply connect our code to this event. <br><br>  Solving this problem with the help of Jet Extensions, in my opinion, is not only simpler than the ones proposed above, but also ‚Äî thanks for their integration with LINQ ‚Äî more flexible.  Definitely, when it comes to connecting or disconnecting a source of information, a solution using Reactive Extensions is simpler than similar code using events. <br><br><h5>  Installation of Reactive Extensions </h5><br>  First you need to connect the Reactive Extensions to the project using NuGet.  There are several packages of Reactive Extensions, including implementations for JavaScript, Android, and handling LINQ requests for web services.  To find the package you need, just run the search for the phrase ‚ÄúReactive Extensions‚Äù and add the Main Library package to the project. <br><br>  The second step is to decide which data we want to return with each change in the order.  Together with the current order status, it makes sense to also return the order ID.  Let's make for this a class with the necessary properties: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StatusChange</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OrderId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> OrderStatus { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  In the next step, we will define the <i>Reactive Extensions Subject</i> , which will work with this type, initialize it when our application starts and subscribe, using the <i>Subscribe</i> method, to calls of the Subject's methods to be aware of the changes: <br><br><pre> <code class="cs hljs">ISubject&lt;StatusChange&gt; statChange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;StatusChange&gt;(); statChange.Subscribe(sc =&gt; MessageBox.Show(sc.OrderStatus));</code> </pre><br>  In the <i>Subscribe</i> method, we pass a lambda expression indicating what we want to do when there are any changes in the order.  In our example, we simply show the value of the <i>OrderStatus</i> property of our class. <br><br>  Now everywhere in our application, when we change the status of an order, we will create an instance of the <i>StatusChange</i> class, fill in its properties and call the <i>OnNext</i> method of the created Subject.  A typical notification code for initial order creation might look like this: <br><br><pre> <code class="cs hljs">statChange.OnNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StatusChange() { OrderId = <span class="hljs-number"><span class="hljs-number">1</span></span>, OrderStatus = <span class="hljs-string"><span class="hljs-string">"New"</span></span> });</code> </pre><br>  Each time the <i>OnNext</i> method is called, a <i>message</i> will be displayed with the value of the <i>StatusChange.OrderStatus</i> property, which we defined in the lambda expression. <br><br><h5>  Solution expansion </h5><br>  Of course, in a real project, handling status changes may require more than one line of code, even more than we want to fit in a lambda expression.  Instead of lambda expressions, we can always pass a pointer to another method to the <i>Subscribe</i> method, for example: <br><br><pre> <code class="cs hljs">statChange.Subscribe(StatusChanged);</code> </pre><br>  The method may not take any parameters, but if it accepts as a parameter an object of the same type with which the Subject is associated, then the object specified in the <i>OnNext</i> call will be passed to <i>it</i> .  Such a method, for example, can simply output each new state to the console: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StatusChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">StatusChange status</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(status.OrderStatus); }</code> </pre><br>  If we need to perform several different methods when changing status, then there is no need to pack them into one method.  Instead, we can call <i>Subscribe</i> our Subject several times, passing the necessary methods in turn. <br><br><pre> <code class="cs hljs">statChange.Subscribe(StatusChanged); statChange.Subscribe(StatusAudit);</code> </pre><br>  With this approach, we have a weak linking of the process that makes changes to the order (our application), with processes that react to these changes (methods <i>StatusChanged</i> , <i>StatusAudit</i> ).  Only one thing links these processes together - the definition of the <i>StatusChange</i> class, which we can safely extend with additional properties without breaking other processes.  Until now, it almost did not differ from the use of events, except that the code needed to write a little less. <br><br>  But the use of Reactive Extensions not only simplifies our code, it allows us to rise above events.  To begin with, let's say we don‚Äôt want to handle every change in order status.  For example, we want to catch only those orders whose state has been changed to ‚ÄúIn progress‚Äù.  We may use LINQ to clarify what results we want to get from the Subject.  Before trying this out, we need to add the <i>System.Reactive.LINQ namespace</i> to our code. <br><br>  After connecting this namespace, we will see that we can write LINQ expressions or use LINQ extension methods to choose which results we want to receive and process.  All three examples below show that our method will be called only for changes with the ‚ÄúProcessing‚Äù status: <br><br><pre> <code class="cs hljs">statChange.Where(c =&gt; c.OrderStatus == <span class="hljs-string"><span class="hljs-string">"Processing"</span></span>).Subscribe(ReportStatusChange); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scs = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> statChange <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> sc.OrderStatus == <span class="hljs-string"><span class="hljs-string">"Processing"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sc; scs.Subscribe(ReportStatusChange); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sub = (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> statChange <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> sc.OrderStatus == <span class="hljs-string"><span class="hljs-string">"Processing"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sc).Subscribe(ReportStatusChange);</code> </pre><br>  We may also want to have special handlers when the status changes to erroneous or when placing an order.  We could well define this by order status, but the Reactive Extensions provide a better solution: the <i>OnError</i> and <i>OnCompleted</i> methods of the Subject.  When we call the <i>Subscribe</i> Subject method, we can pass parameters on the methods (or lambda expressions) that must be executed when the Subject <i>OnError</i> and <i>OnCompleted</i> methods are <i>called</i> .  In the example below, the names of the methods are changed to make the code more visual: <br><br><pre> <code class="cs hljs">statChange.Subscribe(OnNext, OnError, OnCompleted);</code> </pre><br>  The <i>OnError</i> method must accept an exception as a parameter, and the <i>OnCompleted</i> method must be without parameters.  A typical example would be: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception ex</span></span></span><span class="hljs-function">)</span></span> { Console.Error.WriteLine(ex.Message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"order processing completed"</span></span>); }</code> </pre><br>  Now, in case something went wrong, our application should call the <i>OnError</i> method of the Subject.  When calling this method, you need to pass an exception to the parameter, which contains information about the problem (in a real project there will be something better than the example below): <br><br><pre> <code class="cs hljs">statChange.OnError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Something has gone horribly wrong!"</span></span>));</code> </pre><br>  When an application finishes working with an order, it should call the <i>OnCompleted</i> method of the Subject.  In addition to calling handlers for this state change, this method also instructs the Subject that he should not send any more notifications (by the way, another thing that cannot be done with events is to disable subscribers on the side of the event).  Also, the Subject can free himself from all listeners by calling the <i>Dispose</i> method. <br><br><h5>  Notification Encapsulation </h5><br>  In our application, there is one problem - in every place where we change the status of the order, we must remember to call the Subject's <i>OnNext</i> method.  It would be good to automate it.  Ideally, we can hide this call inside the setter of the <i>Status</i> property of the order class.  This eliminates both duplication of code and the ability to forget to call the <i>OnNext</i> method. <br><br>  In the code listing below, the <i>SalesOrder</i> class contains a property of the type <i>ISubject</i> , which is initialized in the constructor by an instance of the Subject.  Now, the Subject's <i>OnNext</i> method will be called wherever the <i>Status</i> property changes (additional code can be added to this class to also support the <i>OnError</i> and <i>OnCompleted</i> Subject methods): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SalesOrder</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _status; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISubject&lt;StatusChange&gt; StatChange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Status { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _status; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _status = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StatusChange() { OrderId = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Id, OrderStatus = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Status }; StatChange.OnNext(sc); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SalesOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StatChange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;StatusChange&gt;(); } }</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/242613/">https://habr.com/ru/post/242613/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242595/index.html">Megatons of waste paper with a flick of the wrist</a></li>
<li><a href="../242601/index.html">Immersion cooling, underwater servers: Immersion-2 for 3M ‚Ñ¢ Novec ‚Ñ¢ delivers magical results, put into practice in Hong Kong</a></li>
<li><a href="../242603/index.html">Cryptographic solutions. From the cloud signature to the trusted environment</a></li>
<li><a href="../242609/index.html">Expressive javascript: search and error handling</a></li>
<li><a href="../242611/index.html">Career project manager vs organization</a></li>
<li><a href="../242615/index.html">‚ÄúEppur si muove!‚Äù * Or working with timezone in Python</a></li>
<li><a href="../242619/index.html">"IT theater" of concrete and green</a></li>
<li><a href="../242621/index.html">Objective-C Minimalism</a></li>
<li><a href="../242623/index.html">Brackets for doubters and newbies</a></li>
<li><a href="../242627/index.html">A cozy book post for you and your project.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>