<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>First steps with STM32 and mikroC compiler for ARM architecture - Part 3 - UART and GSM module</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now, having learned a little about programming under our microcontroller, we will try to connect it with the outside world. The STM32 hardware interfa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>First steps with STM32 and mikroC compiler for ARM architecture - Part 3 - UART and GSM module</h1><div class="post__text post__text-html js-mediator-article">  Now, having learned a little about programming under our microcontroller, we will try to connect it with the outside world.  The STM32 hardware interface modules support many many different external interfaces.  Let's start with the most commonly used interface UART.  What kind of interface can be read <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BD%25D0%25B8%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25B8%25D1%2591%25D0%25BC%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B0%25D1%2582%25D1%2587%25D0%25B8%25D0%25BA">here</a> and <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-usart.html">here</a> . <br><a name="habracut"></a><br>  Let's try to connect our MK to the computer via UART.  To do this, I use a simple USB - UART TTL (3.3V) (do not forget that our MK has levels - 3.3 V), a converter based on the PL2303 chip. <br><img src="https://habrastorage.org/files/484/f41/f1a/484f41f1ac4e4f2faacc481114204cb3.jpg" alt="image"><br>  The STM32 has 3 UART interfaces.  Before you use it, you must configure our serial transceiver in the MK.  To do this, use the command: <br><br><pre><code class="cpp hljs">UART_Init(baud_rate);</code> </pre> <br>  This command starts our UART at <b>baud_rate</b> speed (for example, 9600 or 19200 kbs) with standard parameters (8 data bits, without hardware parity.) <br><br>  If you need to run the UART in some non-standard mode, then use: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs">UARTx_Init_Advanced(baud_rate, data_bits, parity, stop_bits);</code> </pre> <br>  here: <br><br><ul><li>  <b>baud_rate</b> ‚Äî port speed; </li><li>  <b>data_bits</b> - the number of data bits, it is possible to use the structures <b><i>_UART_5_BIT_DATA, _UART_6_BIT_DATA, _UART_7_BIT_DATA, _UART_8_BIT_DATA;</i></b> </li><li>  <b>parity</b> - parity check ( <b><i>_UART_NOPARITY, _UART_EVENPARITY, _UART_ODDPARITY</i></b> ), respectively, without parity, parity, odd parity; </li><li>  <b>stop_bits</b> - the number of stop bits ( <b><i>_UART_ONE_STOPBIT, _UART_TWO_STOPBITS</i></b> ) - 1 or 2 stop bits, respectively; </li></ul><br>  To transfer data bytes to our UART, use: <br><br><pre> <code class="cpp hljs">UARTx_Write(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _data); UARTx_Write(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _data);</code> </pre><br>  or for an array of data (no matter the text or set of values) we transfer the function: <br><br><pre> <code class="cpp hljs">UARTx_Write_Text(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * UART_text);</code> </pre> <br>  using a pointer to an array. <br><br>  Let's write a simple program: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ourtext[] = <span class="hljs-string"><span class="hljs-string">"Hellow world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *txt_pnt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ UART1_INIT (<span class="hljs-number"><span class="hljs-number">19200</span></span>); delay_ms (<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  5  txt_pnt = &amp;ourtext; UART1_Write_Text(txt_pnt); while (1) { } {</span></span></code> </pre><br>  Connect the <b>RX</b> STM32 to the <b>TX</b> Converter and the <b>TX</b> STM32 to the <b>RX</b> Converter and insert it into the USB port of our computer.  Open the terminal program (I use <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">PuTTY</a> ), select the SERIAL mode, port speed, for example, 19200 kbs and the COM port that appeared when we connected our USB-TTL converter (you can see in the device manager in the "COM and LPT ports" branch) and click " OPEN.  We see our text in the terminal window. <br><br><img src="https://habrastorage.org/files/517/158/8fd/5171588fdd4d450ab4ca311ee6caa14c.JPG" alt="image"><br><br>  Sending successively several bytes of data, it is necessary to control whether the transmission of the previous one has ended.  Each UART has its own status register. <br><br>  <b>USART1_SR</b>  The <b>USART1_SRbits.TC</b> bit is responsible for the completion of the transfer. The <b>UARTx_Write_Text</b> function <b>(char * UART_text)</b> itself controls, before sending the next one, the completion of the transfer of the previous byte. <br><br>  To read data from the UART microcontroller, use the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UARTx_READ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  To know that there is a received byte in the buffer of our UART, we use the function: <br><br><pre> <code class="cpp hljs">UART_Data_Ready()</code> </pre>  returning <b>1</b> if the received byte is in the buffer and <b>0</b> if it is not there.  In this case, we need to constantly monitor whether the UART has received something from our controller.  Let's try when receiving, for example, the letter "A" (ASCII code 65) to light the LED on the board: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GPIO_Digital_Output(&amp;GPIOb_BASE, _GPIO_PINMASK_1); UART1_INIT (<span class="hljs-number"><span class="hljs-number">19200</span></span>); delay_ms (<span class="hljs-number"><span class="hljs-number">5</span></span>); UART1_Write_Text(<span class="hljs-string"><span class="hljs-string">"WAIT CHAR A"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UART1_Data_Ready()) <span class="hljs-comment"><span class="hljs-comment">//       UART { if (UART1_READ()== 65) //    65 { GPIOb_ODR.b1 = 1; //   } } } }</span></span></code> </pre><br>  In order not to constantly occupy the MC by polling the state of the UART register, you can (and should) use an interrupt.  When receiving the next byte, a hardware interrupt from the UART will be called in which we can process the data received by the pop serial interface.  To enable the ‚ÄúRX UART‚Äù event interrupt, we need to write a logical 1 to the <b>RXNEIE</b> bit in the CR1 register of the used UART module. <br><br><pre> <code class="cpp hljs">UART1_init (<span class="hljs-number"><span class="hljs-number">19200</span></span>); NVIC_IntEnable(IVT_INT_USART1); <span class="hljs-comment"><span class="hljs-comment">//    IVT_INT_USART1 EnableInterrupts(); //   USART1_CR1bits.RXNEIE = 1; //      delay_ms (5);</span></span></code> </pre><br>  as in the case of the timer, when an interrupt occurs, a subroutine is called: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">our_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> iv IVT_INT_USART1 </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UART1_READ()== <span class="hljs-number"><span class="hljs-number">65</span></span>) GPIOb_ODR.b1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   A =   if (UART1_READ()== 66) GPIOb_ODR.b1 = 0; //   B =   }</span></span></code> </pre><br>  With the help of UART you can connect our MK not only with a computer, but also with many peripheral devices.  For example, consider the widely available GSM module SIM800L.  I got this module already soldered on a small board.  Such cheap can be ordered in China.  All the signals necessary for working with the module are placed on the pins of this board, besides the board has a holder for a SIM card. <br><br><img src="https://habrastorage.org/files/fb5/5f1/35f/fb55f135fb914332b466d27e2416a8a2.jpg"><br><br>  The only thing that is not convenient is the need for supplying this board with voltage from 3.7 to 4.2 V. So you have to either connect an external lithium battery, or convert it to a 4.1 V. Output voltage. Considering the wide distribution of regulated DC-DC, this I think it will not be a particular problem. <br><br>  We connect our module to the MK, not forgetting that the RX module goes to the TX MK and vice versa.  For the Maple mini module we connect the <b>RX to 26 pin (PA9 / UART1TX), TX to 25 (PA10 / UART1RX).</b> <br><br>  To communicate with the module are used, so called, AT commands.  This is a set of terminal commands that the modem understands and performs certain actions in response to them.  With the commands of our module can be found in the <a href="http%253A%252F%252Fcristiansteib.github.io%252FSim800l%252Finfo%252FSIM800%252BSeries_AT%252BCommand%252BManual_V1.09.pdf%26usg%3DAFQjCNEEAB5yb8CqBCr1F6GQIJM_HewbZw%26sig2%3DP7nN8aJkw1L42evfGLjS4g">datasheet</a> , in addition, there is a good <a href="http://alex-exe.ru/radio/wireless/gsm-sim900-at-command/">article</a> where the work with this module is well written. <br><br>  We will use 2 UART microcontrollers, UART1 for communication MK-GSM and UART3 for communication MK - computer terminal. <br><br>  We initialize our UARTs <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ UART1_init (<span class="hljs-number"><span class="hljs-number">19200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UART     UART3_init (19200); //  UART    GSM  NVIC_IntEnable(IVT_INT_USART1); //       GSM USART1_CR1bits.RXNEIE = 1; EnableInterrupts(); delay_ms(200); while (1) { } }</span></span></code> </pre><br>  Our program will require a relatively large number of functions, so we place them in a separate c-file.  To do this, press <b>Ctrl + N</b> in Microc, create another file in the project, for example, GSM_SIM800L..  In order for our compiler to understand that some of the functions need to be searched in another file, we add a line at the beginning of the main c-file (you can also connect libraries in the same way.). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GSM_SIM800L."</span></span></span></span></code> </pre><br>  To begin with, in the GSM_SIM800L.c file, we write the function that sends the AT command to the module and receives the response from it. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> GSM_TEMP[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//    GSM  unsigned short com_status; //    0 -   , 1 - , 2 -     (  ) unsigned short com_mode = 0; 0 -   , 1 -   void Clear_GSM_Bufer () //    GSM { unsigned int cnt; for (cnt=0; cnt&lt;256; cnt++) GSM_TEMP[cnt] = 0; cntas = 0; } short int gsm_send_at (char *at_cmd) //   AT ,  MicroC       { unsigned int brk; //       Clear_GSM_Bufer (); //   com_status = 2; //  " " com_mode = 0; //     UART1_Write_Text (at_cmd); //   AT -  while (com_status == 2 &amp;&amp; brk &lt; 50000) //  com_status   1  0 { brk++; delay_us(2); } com_mode = 1; //    ,    return com_status; //   } void gsm_read() iv IVT_INT_USART1 { GSM_TEMP[cntas] = UART1_READ(); //    UART   GSM_TEMP if (cntas&gt; 255) cntas = 0; else cntas++; //              if (com_mode == 0) //      { if (strstr(GSM_TEMP, "OK\r\n") != 0) com_status = 1; //  - com_status = 1 if (strstr(GSM_TEMP, "ERROR\r\n") != 0) com_status = 0; //Error - com_status = 0 } }</span></span></code> </pre><br>  In MicroC, a string is an array of <b>char</b> characters that ends with the value 00 (NULL) meaning the end of the string.  The string as a function argument is specified by a pointer to the type <b>char</b> (for example <i><b>char * nasha_stroka</b></i> ).  MicroC supports the functions of the standard C_String.h library.  For example, the above function is used. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strstr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s2)</span></span></span></span>;</code> </pre><br>  this function searches for a substring specified by the pointer <b>* s2</b> in the string <b>* s1</b> .  The function will return a pointer to the found substring <b>* s2</b> .  (actually returns the string from the beginning <b>* s2</b> to the end ( <b>NULL</b> character) of the string <b>* s1</b> ).  If the substring <b>* s2 is</b> not found, the function will return <b>NULL</b> .  By default in C, passing an array by its name is a pointer to the beginning of the array.  If you need to transfer an array c of a particular element, then use ( <b>&amp; array_name [ind]</b> ). <br><br>  To begin with, it is impassable to give the module a simple command <b>‚ÄúAT \ r‚Äù</b> - the Module should respond to <b>‚ÄúOK \ r \ n‚Äù</b> and agree on the speed of its UART.  <u>Any AT command ends with the newline character <b>"\ r"</b> .</u>  A module's response to any command can consist of several lines and always ends with <b>‚ÄúOK \ r \ n‚Äù</b> or <b>‚ÄúERROR \ r \ n‚Äù</b> .  A module message, such as an incoming call or SMS message, always ends with <b>"\ r \ n"</b> , and life has simplified that only the last line is usually informative.  Reception of such lines, I call the asynchronous answer (not entirely correct, but let it be so). <br><br>  Perform a few commands needed to configure the module.  For simplicity, we will not monitor the module‚Äôs responses, although it is easy to check the status for equality 1 when executing each command; <br><br><ul><li>  <b>"ATE0 \ r"</b> - Turn off the echo (repeat at the output of our team's UARTa) </li><li>  <b>"AT + GMM \ r"</b> - Return the name of the module </li><li>  <b>"AT + CMGD = 1,4 \ r"</b> - Delete all SMS stored in our module </li><li>  <b>‚ÄúAT + CMGF = 1 \ r‚Äù</b> - Turn on ASCII mode for SMS, otherwise it will be harder for us to read them in Unicode characters </li><li>  <b>‚ÄúAT + DDET = 1‚Äù</b> - Enable recognition by the DTMF command module </li></ul><br><pre> <code class="cpp hljs">gsm_send_at (<span class="hljs-string"><span class="hljs-string">"AT\r"</span></span>); gsm_send_at (<span class="hljs-string"><span class="hljs-string">"ATE0\r"</span></span>); gsm_send_at (<span class="hljs-string"><span class="hljs-string">"AT+CMGD=1,4\r"</span></span>); gsm_send_at (<span class="hljs-string"><span class="hljs-string">"AT+CMGF=1\r"</span></span>); gsm_send_at (<span class="hljs-string"><span class="hljs-string">"AT+DDET=1\r"</span></span>);</code> </pre><br>  Let us write another function that returns the module‚Äôs response (and not just the request status, and maximizes the form we need. In the datasheet for the module, the responses to the AT commands are described using regular expressions about the response feature. known characters). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gsm_at_parse</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *at_cmd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *beg_str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *end_str)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// *at_cmd =   // *beg_str =       // *beg_str =       { char *tempchar; if (gsm_send_at (at_cmd) == 1) //   { tempchar = strstr (GSM_TEMP, beg_str); //  beg_str tempchar = tempchar + strlen(beg_str); *(strstr (tempchar, end_str)) = 0; //  NULL    end_str return tempchar; } }</span></span></span></span></code> </pre><br>  For example, <b>"AT + GMM \ r \ n"</b> returns the name of the module in the form <i>"\ r \ n SIM_800L \ r \ n \ r \ nOK \ r \ n"</i> .  "Bite off" the initial <i>"\ r \ n"</i> and end <i>"\ r \ n \ r \ nOK \ r \ n"</i> <br><br><pre> <code class="cpp hljs">UART3_Write_Text (gsm_at_parse(<span class="hljs-string"><span class="hljs-string">"AT+GMM\r"</span></span>, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"\r\n\r\nOK\r\n"</span></span>)); \\   UART3 (    ,  ) UART3_Write_Text (<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); UART3_Write_Text (gsm_at_parse(<span class="hljs-string"><span class="hljs-string">"AT+CCLK?\r"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">"+"</span></span>)); \\      UART3_Write_Text (<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); UART3_Write_Text (gsm_at_parse(<span class="hljs-string"><span class="hljs-string">"AT+CSPN?\r"</span></span>, <span class="hljs-string"><span class="hljs-string">": \""</span></span>, <span class="hljs-string"><span class="hljs-string">"\""</span></span>); \\    GSM. UART3_Write_Text (<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>);</code> </pre><br>  Among the AT commands of the module there is the command <b>‚ÄúAT + CREG? \ R‚Äù</b> .  This command will return the status of the module about network registration.  If everything is OK and the module is registered the answer should be: <i>"\ r \ n + CREG: 0.1 \ r \ n \ r \ n \ OK \ r \ n"</i> .  <b>0.0</b> - module is not registered and there is no network search (for example, no SIM card is inserted), <b>0.2</b> - module is not registered, network is being searched.  Let's write the function of checking the network status of the module, besides, we will return the signal level of the GSM network (for this there is an AT command <b>‚ÄúAT + CSQ \ r‚Äù</b> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">short</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gsm_net_status</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *tempchar[<span class="hljs-number"><span class="hljs-number">7</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//   int sgr; //      dBi if ( gsm_send_at("AT+CREG?\r") == 1) //     { if (strstr(GSM_TEMP, "0,1")) //    -   "+CREG: 0,1" { tempchar = GSM_AT_PARSE ("AT+CSQ\r",": ","," ); //  ,    +CSQ: 17,0,     :  , sgr = atoi(tempchar); //     sgr = -115 + (sgr * 2); //    dBi return sgr; //   } } return 0; //   0 -      . }</span></span></code> </pre><br>  Now our module is working.  If we call him, he will issue a type string to his UART. <br>  <b>"\ r \ n RING \ r \ n + CLIP:" + 380XXXXXXXX ", 145," ",," ", 0 \ r \ n"</b> .  With the incoming SMS, the answer will be <b>"\ r \ n + CMTI:" SM ", 10 \ r \ n"</b> , where 10 means that our SMS is stored in memory at number 10. These are the asynchronous answers I called.  we will accept and process them in our interrupt handler.  I wrote the recognition of the answers I needed most.  in principle, how this is done should be clear from the code below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *eol <span class="hljs-comment"><span class="hljs-comment">//  ,   "\r\n" char callingnumber[14]; //   , 13   NULL  char last_sms[4]; //    char dtmf_in[2]; //  DTMF  unsigned short callnow; //   unsigned short active_call; //   unsigned short sms; //    void gsm_read() iv IVT_INT_USART1 { GSM_TEMP[cntas] = UART1_READ(); if (cntas&gt; 255) cntas = 0; else cntas++; if (com_mode == 0) { if (strstr(GSM_TEMP, "OK\r\n") != 0) com_status = 1; if (strstr(GSM_TEMP, "ERROR\r\n") != 0) com_status = 0; } //        if (com_mode == 1) { if (cntas&gt; 2) eol = strstr(&amp;GSM_TEMP[2], "\r\n"); else eol = 0; //    if (eol != 0) //    { if (strstr(&amp;GSM_TEMP, "+CLIP") != 0) //     "+CLIP"       { callnow=1; //   temp = strstr(GSM_TEMP, "\"+"); //     + -     strncpy (callingnumber, temp+1, 13); //    callingnumber[]  ,  13  } if (strstr(&amp;GSM_TEMP, "CARRIER") != 0) //   "NO CARRIER" { *callingnumber=0; //      ( NULL   ) callnow=0; //     active_call=0; } if (strstr(&amp;GSM_TEMP, "DTMF") != 0) { temp = strstr(GSM_TEMP, " "); //SIM800    DTMF ,          DTMF . strncpy(dtmf_in,temp+1,1); //   dtmf_in[] } if (strstr(GSM_TEMP, "CMTI")!=0) //    { temp = strstr(GSM_TEMP, ","); // ",",       strncpy (last_sms, temp + 1, eol - (temp + 1)); //   last_sms[] sms=1; //   } Clear_GSM_Bufer (); //  } } }</span></span></code> </pre><br>  By controlling the value of the call call variable in the program cycle, you can learn about the incoming call.  We can pick up the phone with the help of the command <b>"ATA \ r"</b> , and reset the call - <b>"ATH0 \ r"</b> . <br><br><pre> <code class="cpp hljs">har *nashomer[<span class="hljs-number"><span class="hljs-number">14</span></span>] = <span class="hljs-string"><span class="hljs-string">"+380931234567"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callnow == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(&amp;callingnumber, <span class="hljs-string"><span class="hljs-string">"nashomer"</span></span>)==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// strcmp (*s1, *s2) -  2 ,  0    s1 = s2 { gsm_send_at ("ATA\r"); // AT  " " active_call = 1; //      . } else { gsm_send_at ("ATH0\r"); // AT  " " callnow = 0; //    } }</span></span></code> </pre><br>  Similarly, controlling the value of the <b>sms</b> variable, we learn about the incoming SMS message.  we can read it with the command <b>‚ÄúAT + CMGR = 2 \ r‚Äù</b> where N = SMS number.  In response, the module will return a string of the type "\ r \ n + CMGR:" REC READ "," + 380XXXXXXXX "," "," 17/02 / 1,11: 57: 46 + 2 "\ r \ n hellow habrahabr \ r \ n \ r \ nOK \ r \ n ".  To parse this line, create a function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gsm_read_sms</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sms_num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sms_field)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    ( )      ( ), //1 -  , //2 -   , //3 -   { char sms_at[30]; short int res_at; strcat (sms_at, "AT+CMGR="); strcat (sms_at, sms_num); strcat (sms_at, "\r"); res_at = gsm_send_at (sms_at); if (res_at == 1 &amp;&amp; sms_field == 1) { *(strstr (GSM_TEMP, "\",\"\",\"")) = 0; sms = 0; return strstr(GSM_TEMP, "\"+") + 1; } if (res_at == 1 &amp;&amp; sms_field == 2) { *(strstr(strstr(GSM_TEMP, "\",\"\",\"") + 6, "+")) = 0; sms = 0; return strstr(GSM_TEMP, "\",\"\",\"") + 6; } if (res_at == 1 &amp;&amp; sms_field == 3) { *(strstr (GSM_TEMP, "\r\n\r\nOK\r\n")) = 0; sms = 0; return strstr(GSM_TEMP, "\"\r\n") + 3; } return 0; //   0 }</span></span></span></span></code> </pre><br>  For example: <br><br><pre> <code class="cpp hljs">UART3_Write_Text (gsm_read_sms(<span class="hljs-string"><span class="hljs-string">"5"</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//         5 UART3_Write_Text (gsm_read_sms("2",3)); //        2</span></span></code> </pre><br>  To send an SMS, use the AT command <b>"AT + CMGS =" + 380XXXXXXXX \ r "</b> . This command responds with the character" \ r \ n&gt; "- an invitation to enter. You can catch this invitation in the module response, I just give a delay in 100 ms. And send SMS text to UART <b>which should end with a symbol with ASCII code <b>26</b></b> <br><br><pre> <code class="cpp hljs">UART1_Write_Text (<span class="hljs-string"><span class="hljs-string">"AT+CMGS=\""</span></span>); UART1_Write_Text (nomer); <span class="hljs-comment"><span class="hljs-comment">//    UART1_Write_Text ("\"\r"); Delay_ms (100); UART1_Write_Text (text); //   UART1_Write (26);   </span></span></code> </pre><br>  The article describes only a small part of the capabilities of both the GSM module and the UART interface of the MK STM32.  Nevertheless, I hope that the above information will be useful for understanding the work with the serial interface implemented in the microcontroller. <br><br>  In the next article I will explain what an I2C bus is, how to work with it, and how to connect an LCD indicator based on the HD44780 controller to the STM32 on a parallel bus and through an I2C I / O extender. </div><p>Source: <a href="https://habr.com/ru/post/321056/">https://habr.com/ru/post/321056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321044/index.html">How I parsed docx using XSLT</a></li>
<li><a href="../321048/index.html">Analysis and translation of the alien language using the Wolfram Language</a></li>
<li><a href="../321050/index.html">The hunt for the mythical MVC. Review, return to the original sources and how to analyze and display patterns yourself</a></li>
<li><a href="../321052/index.html">BLE under the microscope. Part 3</a></li>
<li><a href="../321054/index.html">How to get a discount from 20 to 60% for posting vacancies and free access to the resume database on My Circle</a></li>
<li><a href="../321058/index.html">Welcome to Game Design meetup February 4</a></li>
<li><a href="../321060/index.html">Bypass restrictions in Calabash-Android with UIAutomator</a></li>
<li><a href="../321062/index.html">Using GlusterFS with Docker swarm cluster</a></li>
<li><a href="../321064/index.html">We pump over NES Classic Mini</a></li>
<li><a href="../321066/index.html">Complex neural network based on the Fourier series of a function of many variables</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>