<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Robot Loader Project: Orientation Definition</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A month ago, I wrote about the definition of my own position by my robot loader. (Sorry, I posted that article in an unfortunate time on Saturday nigh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Robot Loader Project: Orientation Definition</h1><div class="post__text post__text-html js-mediator-article">  A month ago, <a href="http://habrahabr.ru/post/161803/">I wrote</a> about the definition of my own position by my robot loader.  (Sorry, I posted that article in an unfortunate time on Saturday night, so few people saw it.) As I noted, the readings of the wheel sensors allow the robot to determine its position quite accurately - the slowly accumulating error is corrected as soon as the robot scans the barcode on any from the shelves of the warehouse.  On the other hand, the accumulated direction error was nothing to correct. <br><br>  I discussed my difficulties with the humanities girl, and asked her how she knew how to orient in space.  According to her, in the London Science Museum, she found an exhibition dedicated to the orientation of ants by looking vertically upwards overhead.  Visitors were asked to take a mirror and walk around the room, looking at patterns on the ceiling in the mirror and focusing only on them.  (The ceiling map was attached.) <br><br>  I decided to check: what does my robot see on the ceiling of the warehouse? <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/iM-WZb50Yr8%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhgWI6eIn2ude80idb2HYRieUyGmig" frameborder="0" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Even on such a low-quality record, long rectangular windows are perfectly distinguishable.  All of them, of course, parallel to one of the axes of the warehouse, and therefore parallel to the rows of shelves.  It turns out that if a window gets into the frame and I can determine its direction, then I get the direction of the robot, with an accuracy of 180 ¬∞.  The windows are not visible from any point of the warehouse, but for periodic course correction - they get into the frame quite often. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In pattern recognition, I am not a whale, and the first thing I <a href="http://habrahabr.ru/qa/28989/">asked at Q &amp; A</a> was there anything ready for recognition of rectangular windows, for example, is OpenCV applicable?  Unfortunately, I wasn‚Äôt told anything sensible - people who were ‚Äúin the subject line‚Äù, considered chewing a kettle on the bottom of their dignity. <br><br><blockquote>  American forum: asked a question - get an answer. <br>  Israeli forum: asked a question - you get a question. <br>  Russian forum: asked a question - they will explain to you what an asshole you are. <br></blockquote><br>  Moreover, the robot was controlled from under the Microsoft Robotics Development Studio, and I did not find the finished .NET assembly for working with OpenCV - I decided to write my own recognition from scratch.  Not rocket science, tea - just something to recognize the bright white rectangles. <br><br>  The ceiling of the warehouse is seen by the robot something like this: <br><img src="https://habrastorage.org/storage2/637/de0/312/637de03126408f4135da3f357fd5a53a.jpg"><br><br>  To begin with, let's separate the bright white window from the dark background.  We translate from RGB to YCbCr and divide by Y = 227 (the threshold was chosen empirically, and in an ideal world it would be adapted adaptively to the brightness of the image as a whole).  Along the way, we reduce the original image 640x480 to 320x240 - that's enough for us, and the processing will accelerate four times. <br><br>  Code: <br><pre><code class="hljs pgsql">byte[] bytes = response.Frame; <span class="hljs-type"><span class="hljs-type">int</span></span> stride = bytes.Length / height; byte[,] belong = (byte[,])<span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.CreateInstance(typeof(byte), <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">326</span></span>, <span class="hljs-number"><span class="hljs-number">246</span></span> }, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span> }); <span class="hljs-type"><span class="hljs-type">int</span></span> Ythreshold = settings.Ythreshold; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">240</span></span>; y++) { <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = stride * y * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">320</span></span>; x++) { <span class="hljs-type"><span class="hljs-type">int</span></span> blu = bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + stride] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + stride + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>++; <span class="hljs-type"><span class="hljs-type">int</span></span> grn = bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + stride] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + stride + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>++; <span class="hljs-type"><span class="hljs-type">int</span></span> red = bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + stride] + bytes[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> + stride + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> += <span class="hljs-number"><span class="hljs-number">4</span></span>; belong[x, y] = (<span class="hljs-number"><span class="hljs-number">0.299</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> * red + <span class="hljs-number"><span class="hljs-number">0.587</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> * grn + <span class="hljs-number"><span class="hljs-number">0.114</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> * blu &gt; Ythreshold ? (byte)<span class="hljs-number"><span class="hljs-number">1</span></span> : (byte)<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><br>  As a result of the separation, this image is obtained: <br><img src="https://habrastorage.org/storage2/a45/3e3/6e5/a453e36e5b105583b238bd0907567841.jpg"><br><br>  As usual on video images, in addition to a correctly selected window, we received noise from individual pixels on the glare surfaces, and at the same time inside the window itself there were ‚Äúbroken pixels‚Äù that were not bright enough. <br><br>  We remove the noise by the median filter (although for some reason I was advised to have a Gaussian blur in QA. Well, why is there a blur?) With a radius of 3 pixels and a threshold of 5 bright pixels out of 21 examined.  Such a filter ‚Äúleans‚Äù towards the connection of bright areas, between which there are dark pixels - so that our window of three glasses merges into one rectangle. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[,] filtered = (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[,])Array.CreateInstance(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">326</span></span>, <span class="hljs-number"><span class="hljs-number">246</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> medianThreshold = settings.MedianThreshold; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">320</span></span>; x++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">240</span></span>; y++) filtered[x, y] = belong[x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y - <span class="hljs-number"><span class="hljs-number">2</span></span>] + belong[x, y - <span class="hljs-number"><span class="hljs-number">2</span></span>] + belong[x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y - <span class="hljs-number"><span class="hljs-number">2</span></span>] + belong[x - <span class="hljs-number"><span class="hljs-number">2</span></span>, y - <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y - <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x, y - <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y - <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x + <span class="hljs-number"><span class="hljs-number">2</span></span>, y - <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x - <span class="hljs-number"><span class="hljs-number">2</span></span>, y * <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y * <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x, y * <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y * <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x + <span class="hljs-number"><span class="hljs-number">2</span></span>, y * <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x - <span class="hljs-number"><span class="hljs-number">2</span></span>, y + <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y + <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x, y + <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y + <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x + <span class="hljs-number"><span class="hljs-number">2</span></span>, y + <span class="hljs-number"><span class="hljs-number">1</span></span>] + belong[x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y + <span class="hljs-number"><span class="hljs-number">2</span></span>] + belong[x, y + <span class="hljs-number"><span class="hljs-number">2</span></span>] + belong[x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y + <span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; medianThreshold;</code> </pre><br>  The dimension for the <code>belong</code> and <code>filtered</code> arrays - [-3..322, -3..242] - was chosen on purpose with ‚Äúfields‚Äù of three pixels on each side in order to work with these arrays without bothering with index checks. <br><br>  After filtering, only the window combined from three glasses and a few highlights on the shelf remain white on the image: <br><img src="https://habrastorage.org/storage2/fe1/256/58d/fe125658dc8ea7b5e2b743a2203ee517.jpg"><br><br>  Let us state that the biggest white spot in the frame is by all means a window.  Flood (floodfill) every white spot, and take the largest in area. <br><br><pre> <code class="hljs ruby">int biggest_area = <span class="hljs-number"><span class="hljs-number">0</span></span>; byte area_id = <span class="hljs-number"><span class="hljs-number">1</span></span>, biggest_id = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> areas start from <span class="hljs-number"><span class="hljs-number">2</span></span> Rectangle bounds = new Rectangle(); PointF cg = new PointF(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> center Point[] stack = new Point[<span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-number"><span class="hljs-number">320</span></span>; x++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">240</span></span>; y++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filtered[x, y] &amp;&amp; belong[x, y] &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { int area = <span class="hljs-number"><span class="hljs-number">0</span></span>, left = <span class="hljs-number"><span class="hljs-number">320</span></span>, top = <span class="hljs-number"><span class="hljs-number">240</span></span>, right = <span class="hljs-number"><span class="hljs-number">0</span></span>, bottom = <span class="hljs-number"><span class="hljs-number">0</span></span>; int sx = <span class="hljs-number"><span class="hljs-number">0</span></span>, sy = <span class="hljs-number"><span class="hljs-number">0</span></span>; ++area_id; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> FloodFill int sp = <span class="hljs-number"><span class="hljs-number">0</span></span>; stack[<span class="hljs-number"><span class="hljs-number">0</span></span>] = new Point(x, y); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sp &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Point <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> = stack[sp--]; area++; sx += <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X; sy += <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y; belong[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y] = area_id; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X &lt; left) left = <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X &gt; right) right = <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y &lt; top) top = <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y &gt; bottom) bottom = <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filtered[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y] &amp;&amp; belong[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y] &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) stack[++sp] = new Point(<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filtered[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y - <span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; belong[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) stack[++sp] = new Point(<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filtered[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y + <span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; belong[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) stack[++sp] = new Point(<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filtered[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y] &amp;&amp; belong[<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y] &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) stack[++sp] = new Point(<span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.X + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>.Y); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (area &gt; biggest_area) { biggest_area = area; biggest_id = area_id; bounds = new Rectangle(left, top, right - left, bottom - top); cg = new PointF((float)sx / area, (float)sy / area); } }</code> </pre><br>  The image for recognition is ready!  Two-level - white rectangle on a black background.  We even calculated during the filling the coordinates of its ‚Äúcenter of mass‚Äù <code>cg</code> (in the image is a red dot) and borders (the green dot is the center of the bounding box).  We can now check how much our white spot looks like a window: the <code>biggest_area</code> area should be no less than 2000 pixels, the distance between two centers should be no more than 20 pixels, otherwise the figure is too asymmetric for a rectangle.  But how further will we determine its orientation? <br><img src="https://habrastorage.org/storage2/13e/07b/311/13e07b3119dbd8f74f200eb6ee2b38c3.png"><br><br>  Rocket scientists, perhaps, would apply the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A5%25D0%25B0%25D1%2584%25D0%25B0">Hough transform</a> , translate the image into the 4-dimensional space of probabilistic parameters of the rectangle (width, length, angle, offset from the origin), and look for a maximum there.  But I approached the task of workers and peasants, and to begin with, I made a ‚Äúhistogram‚Äù of removing points of a rectangle from its geometric center: <br><br><pre> <code class="hljs perl">PointF c = new PointF(bounds.Left + (float)bounds.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, bounds.Top + (float)bounds.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] hist = new <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">400</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">400</span></span>; i++) hist[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxdist = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> = bounds.Left; <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> &lt;= bounds.Right; <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> = bounds.Top; <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> &lt;= bounds.Bottom; <span class="hljs-keyword"><span class="hljs-keyword">y</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (belong[<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">y</span></span>] == biggest_id) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dist = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Sqrt(S<span class="hljs-string"><span class="hljs-string">qr(x - cX)</span></span> + S<span class="hljs-string"><span class="hljs-string">qr(y - cY)</span></span>); hist[dist]++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &gt; maxdist) maxdist = dist; }</code> </pre><br><br><img src="https://habrastorage.org/storage2/b86/034/e72/b86034e7294c824cc756896e61149240.png"><br><br>  The gray chart is the histogram, the dark bar on it is the maximum, i.e.  the greatest number of points is precisely at such a distance from the center of the rectangle.  (A dark circle corresponding to this distance is drawn on the rectangle.) It is easy to understand that this distance is precisely the half-width of the rectangle: before it ‚Äî the circles are entirely inside the rectangle, and the histogram grows linearly (with coefficient <i>œÄ</i> );  then the histogram slowly decreases until it reaches the half-length of the rectangle;  from now on, only four ‚Äúcorners‚Äù of circles are placed inside the rectangle, and the histogram drops sharply.  Unfortunately, it is impossible to find the length through this ‚Äúbreak‚Äù on the histogram - the edges of the rectangle turn out to be too ragged, and the end of the histogram rustles.  We will go the other way, and consider a circle 5 pixels wider than the rectangle.  There will be two black ‚Äúsides‚Äù just on the transverse axis of the rectangle: <br><br><img src="https://habrastorage.org/storage2/9f6/011/95d/9f601195dc3a5bc5633769d6817f5542.png"><br><br>  Carefully find the centers of mass of these "sides": the difficulty here is to separate them.  We consider separately the center of mass in each ‚Äúquadrant‚Äù, then combine the ‚Äúquadrants‚Äù into two pairs by the proximity of the centers. <br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> incircle radius <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> = maxdist; <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hist[<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>] &gt; hist[r1]) r1 = <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rSample = r1 + <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] voters = new <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; Point[] sums = new Point[<span class="hljs-number"><span class="hljs-number">4</span></span>]; Point sampleOrg = new Point(Math.Max((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(cX - rSample), <span class="hljs-number"><span class="hljs-number">0</span></span>), Math.Max((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(cY - rSample), <span class="hljs-number"><span class="hljs-number">0</span></span>)); Rectangle sample = new Rectangle(sampleOrg, new Size( Math.Min((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(cX + rSample), <span class="hljs-number"><span class="hljs-number">319</span></span>) - sampleOrg.X, Math.Min((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(cY + rSample), <span class="hljs-number"><span class="hljs-number">239</span></span>) - sampleOrg.Y)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> = sample.Left; <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> &lt;= sample.Right; <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> = sample.Top; <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> &lt;= sample.Bottom; <span class="hljs-keyword"><span class="hljs-keyword">y</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (belong[<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">y</span></span>] != biggest_id) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dist = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Sqrt(S<span class="hljs-string"><span class="hljs-string">qr(x - cX)</span></span> + S<span class="hljs-string"><span class="hljs-string">qr(y - cY)</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &gt; r1 &amp;&amp; dist &lt;= rSample) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> &lt; cY ? (<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> &lt; cX ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> &lt; cX ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>); voters[idx]++; sums[idx].X += <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>; sums[idx].Y += <span class="hljs-keyword"><span class="hljs-keyword">y</span></span>; } } PointF adjusted = new PointF(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vAbove = voters[<span class="hljs-number"><span class="hljs-number">0</span></span>] + voters[<span class="hljs-number"><span class="hljs-number">1</span></span>], vBelow = voters[<span class="hljs-number"><span class="hljs-number">2</span></span>] + voters[<span class="hljs-number"><span class="hljs-number">3</span></span>], vLeft = voters[<span class="hljs-number"><span class="hljs-number">2</span></span>] + voters[<span class="hljs-number"><span class="hljs-number">1</span></span>], vRight = voters[<span class="hljs-number"><span class="hljs-number">0</span></span>] + voters[<span class="hljs-number"><span class="hljs-number">3</span></span>], allVoters = vAbove + vBelow; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (allVoters == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> abort: <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> black pixels found } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vAbove &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; vBelow &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> vertically PointF above = new PointF((float)(sums[<span class="hljs-number"><span class="hljs-number">0</span></span>].X + sums[<span class="hljs-number"><span class="hljs-number">1</span></span>].X) / vAbove - cX, (float)(sums[<span class="hljs-number"><span class="hljs-number">0</span></span>].Y + sums[<span class="hljs-number"><span class="hljs-number">1</span></span>].Y) / vAbove - cY), below = new PointF((float)(sums[<span class="hljs-number"><span class="hljs-number">2</span></span>].X + sums[<span class="hljs-number"><span class="hljs-number">3</span></span>].X) / vBelow - cX, (float)(sums[<span class="hljs-number"><span class="hljs-number">2</span></span>].Y + sums[<span class="hljs-number"><span class="hljs-number">3</span></span>].Y) / vBelow - cY); double dAbove = Math.Sqrt(above.X * above.X + above.Y * above.Y), dBelow = Math.Sqrt(below.X * below.X + below.Y * below.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dAbove &gt;= r1 &amp;&amp; dAbove &lt;= rSample &amp;&amp; dBelow &gt;= r1 &amp;&amp; dBelow &lt;= rSample) // the <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> is valid adjusted = new PointF((above.X * vAbove - below.X * vBelow) / allVoters, (above.Y * vAbove - below.Y * vBelow) / allVoters); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adjusted.X == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; adjusted.Y == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; vLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; vRight &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> horizontally PointF toleft = new PointF((float)(sums[<span class="hljs-number"><span class="hljs-number">2</span></span>].X + sums[<span class="hljs-number"><span class="hljs-number">1</span></span>].X) / vLeft - cX, (float)(sums[<span class="hljs-number"><span class="hljs-number">2</span></span>].Y + sums[<span class="hljs-number"><span class="hljs-number">1</span></span>].Y) / vLeft - cY), toright = new PointF((float)(sums[<span class="hljs-number"><span class="hljs-number">0</span></span>].X + sums[<span class="hljs-number"><span class="hljs-number">3</span></span>].X) / vRight - cX, (float)(sums[<span class="hljs-number"><span class="hljs-number">0</span></span>].Y + sums[<span class="hljs-number"><span class="hljs-number">3</span></span>].Y) / vRight - cY); double dLeft = Math.Sqrt(toleft.X * toleft.X + toleft.Y * toleft.Y), dRight = Math.Sqrt(toright.X * toright.X + toright.Y * toright.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dLeft &gt;= r1 &amp;&amp; dLeft &lt;= rSample &amp;&amp; dRight &gt;= r1 &amp;&amp; dRight &lt;= rSample) // the <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> is valid adjusted = new PointF((toleft.X * vLeft - toright.X * vRight) / allVoters, (toleft.Y * vLeft - toright.Y * vRight) / allVoters); } }</code> </pre><br>  The <code>adjusted</code> point now points from the center of the rectangle along its transverse axis: <br><img src="http://habrastorage.org/storage2/c26/46e/1c8/c2646e1c8653775b4965d4ab1556a256.png"><br><br>  Well, that's the whole orientation.  It remains a bit of pure geometry to calculate the length of the rectangle and check whether the ratio of length to width looks like a real window. <br><br>  I will demonstrate the work on another example - when the window is not fully captured.  Due to the fact that we do not use the ‚Äúend‚Äù of the histogram for recognition, we are not at all confused by the incomplete window. <br><br><div class="spoiler">  <b class="spoiler_title">Second example</b> <div class="spoiler_text">  Source Image: <br><img src="http://habrastorage.org/storage2/dfe/4a3/2ee/dfe4a32eef67ea5401f667561c3c250c.jpg"><br><br>  After separation: <br><img src="http://habrastorage.org/storage2/71e/d1f/f84/71ed1ff8437df4c8d9f065ca0113846f.jpg"><br><br>  After filtering: <br><img src="http://habrastorage.org/storage2/5f4/0b8/54c/5f40b854ca12d7c34b0fc84cea14d866.jpg"><br><br>  Bar chart: <br><img src="http://habrastorage.org/storage2/5d1/bcd/733/5d1bcd73326b95fd93460f13b2dac563.png"><br><br>  Circle with sides: <br><img src="http://habrastorage.org/storage2/cfc/e65/bfb/cfce65bfb863305c151e6d9d35852dd3.png"><br><br>  Transverse axis: <br><img src="http://habrastorage.org/storage2/18e/8fd/e76/18e8fde76f53440131a414b788058190.png"><br></div></div><br>  The code I <code>WindowDetector</code> in the MRDS service <code>WindowDetector</code> - in the image and likeness of standard <code>Technologies\Vision\ColorSegment</code> .  My service is tied to the video camera, and for each frame update it sends to subscribers <code>UpdateFoundWindow</code> with the angle of the window in the frame.  The MRDS service that manages the robot binds to the <code>WindowDetector</code> in the same way as it binds to a barcode scanner, and processes messages from both quite similarly - correcting the course in the first case and the position in the other case. <br><br>  With the window detector, my robot traveled through the warehouse rather briskly: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/6QWEAwoBqUg%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhiqKYAGHcrBtkN-xgTgSgEvHSRs8w" frameborder="0" allowfullscreen=""></iframe><br><br>  The fate of the robot is sad.  Just an hour after shooting this video, the wheel sensor clogged with warehouse dust, and the robot stopped monitoring its position.  At the initial assembly of the robot, this sensor is placed very first, i.e.  to replace it, you need to essentially disassemble everything and then assemble it in a new way.  I decided to try replacing the sensor with a ‚Äúlive‚Äù robot, but due to clumsiness I short-circuited the battery about something inside the robot, and it stopped driving altogether.  I had to leave it on the storage shelf next to the last year's robot - that based on Roomba.  Right rokladradishche, not the regiment. <br><br>  So before I left Britain, I didn‚Äôt have time to make Eddie a working loader robot.  But already this spring I will most likely return there with spare parts, revive it, and continue testing. </div><p>Source: <a href="https://habr.com/ru/post/164979/">https://habr.com/ru/post/164979/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164969/index.html">Developing a game for Windows Phone</a></li>
<li><a href="../164971/index.html">Lego introduced Mindstorms EV3</a></li>
<li><a href="../164973/index.html">Create a Visual Studio extension to generate C ++ #define directives in a header file</a></li>
<li><a href="../164975/index.html">What part of the web is archived</a></li>
<li><a href="../164977/index.html">Adobe distributes Creative Suite 2 for free (or doesn't it?)</a></li>
<li><a href="../164981/index.html">Instagram blind man</a></li>
<li><a href="../164987/index.html">Three whales of success</a></li>
<li><a href="../164989/index.html">Electric cars and hybrids, is it too early?</a></li>
<li><a href="../164991/index.html">Bay Fascists, or BLE for iOS</a></li>
<li><a href="../164997/index.html">GIS: determining the nesting of administrative districts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>