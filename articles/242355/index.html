<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MultiTouch + Gestures support in Delphi XE4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Somehow, all these new developments, in the form of active monitors, which the user can poke fingers with, have passed unnoticed by me. And I wouldn‚Äôt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MultiTouch + Gestures support in Delphi XE4</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/66f/57b/fe5/66f57bfe574148dc97ffcc9c3f8d2ede.jpg"></div><br><br>  Somehow, all these new developments, in the form of active monitors, which the user can poke fingers with, have passed unnoticed by me.  And I wouldn‚Äôt have known about them, if only three months ago the authorities didn‚Äôt get a laptop that can be broken into two parts (the screen is separate, the keyboard is separate), and not some Surface, MS MS, but the most passive from users - from <a href="http://www.asus.com/in-search-of-incredible/ru-ru/asus-transformer-book-t300">ASUS</a> , for much less money (relatively). <br>  Yes, and this device was purchased for a reason - the task grew from where it was not expected. <br><br>  De jure: we conduct a huge number of seminars a month, and it was on them that our lecturers began to demonstrate the incompatibility of our software with this notorious tachim. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      De facto: the angry emails of users of the plan began to pour on the support mail - ‚ÄúI tapped twice, but it didn‚Äôt tapnul, maybe I didn‚Äôt tap it?‚Äù <br>  And the authorities carefully scrutinized all this on their ‚Äúportable‚Äù laptop and prepared TK. <br><br>  And then came the day.  I had a third monitor erected on my desktop, <a href="http://www.ixbt.com/monitor/lg-23et63v.shtml">23 inches from LG</a> (with support for touch input with as many as 10 fingers) and the task was set - it should work within three days! <br><br>  And then I work in XE4 - trouble. <br><a name="habracut"></a><br><h4>  0. Analysis of the problem </h4><br>  Fortunately, I am familiar with a lot of competent comrades (including Embarcadero MVP), with whom you can consult with which side to approach Touch support in general, but ... having thoroughly read the links to technical articles (sent by them) about multitouch support, I realized that in XE4 nothing shines.  VCL features available to me are very limited. <br><br>  After reading a bit about the Embarcadero conference, I found out that multitouch, with some restrictions, became available only in XE7 (however). <br><br>  I‚Äôm not sure what the authorities would appreciate if I said that the easiest way to solve the problem looks like an update on XE7 (plus time the cost of checking the code for compatibility after apa). <br><br>  Therefore, we look at what is available to me in XE4: <br>  <b>pros:</b> <br>  - she knows about gestures (Gesture). <br>  <b>minuses:</b> <br>  - she does not know about the Touch (knows, but does not provide an external handler); <br>  - she does not know about Gesture with the help of two entry points (with two or more fingers). <br><br>  And now let's see what is not available to me: <br><br><ol><li>  I cannot extend the TRealTimeStylus class by introducing support for the interface IRealTimeStylus3 to IStylusAsyncPlugin simply because it is hidden from me inside TPlatformGestureEngine right in the strict private type of the class section. </li><li>  I have not been provided with a full-fledged WM_TOUCH message handler, although this message is processed inside TWinControl.WndProc: </li></ol><br><br><pre><code class="delphi hljs">WM_TOUCH: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> FTouchManager <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GestureEngine &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (efTouchEvents <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> GestureEngine.Flags) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> GestureEngine.Notification(<span class="hljs-keyword"><span class="hljs-keyword">Message</span></span>);</code> </pre> <br><br>  As you can see by the code, the control goes directly to the gesture recognition engine. <br>  Although it would seem - why do I need the guestbooks if I want to move five pictures along the canvas in the order that the guestbooks obviously do not recognize? <br><br>  Of course, in the second case I can block WM_TOUCH myself, but since someone took it up and got the data, why not give it away, saving the developer from re-dubbing the code? <br><br>  Therefore, let us go from the other side. <br><br><h4>  1. Statement of the problem </h4><br>  Our software is essentially very sophisticated Excel, but with sharpening for a certain contingent of users, in this case, estimators.  However, to paraphrase a bit: the distance between the capabilities of our software and Excel is about the same as the difference between MsPaint and Adobe Photoshop. <br>  Our users can also implement in Excel a certain document in the form of a budget, as well as a drawing in MsPaint.  The whole tsimus as a result. <br><br>  The project was developed according to the ideology WYSIWYG, and in 90 percent of cases there is a certain custom class (from TCustomControl) that implements the grid in which the user works, as well as with a regular paper document. <br><br>  It looks like this: (the screenshot was taken during the operation of the DragDrop position, do not pay attention to the arrow, the picture is torn from some kind of technical support and indicates a floating Hint, such as a chip. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c5c/a93/2a6/c5ca932a6210486ea4600c09a377c143.png"></div><br><br>  In this control, there are no standard concepts such as scrolling.  Of course, it is there, but it emulates column manipulation in the case of horizontal movement, or in the case of vertical displacement, the transition to the next row of the sheet. <br>  It does not accept standard scrolling messages. <br><br>  In the basic version (which is issued by the OS), it is able to receive mouse click events emulated by the system via tap on the touchscreen, and WM_MOUSEMOVE, also emulated by the system via the touch. <br><br>  <b>And what you need:</b> <br><br><ul><li>  The only thing that the current Gesture can do is tap with two fingers to call PopupMenu at tap coordinates; </li><li>  Scrolling left / right / up / down by means of a swipe with two fingers on the touchscreen; </li><li>  Emulation of commands "back / forward", by swiping with three fingers on the touchscreen. </li></ul><br>  Taking into account the fact that Gesture in XE4 is not fundamentally sharpened on multitouch (even at the level of the guest editor), but the task should be solved, I was sad for the whole evening and ... started work in the morning. <br><br><h4>  2. Terms used </h4><br>  As I said earlier, I am not a huge specialist in all these new trends, so in the article I will use the following definitions (it is quite possible that they are wrong): <br><br>  <b>Tap</b> is an analogue of a mouse click, an event that occurs when a single short press of a finger on the touchscreen. <br>  <b>A touch</b> (or a touch point) is something that describes a situation where a finger contacts a touchscreen (and the WM_TOUCH message is processed). <br>  <b>Route</b> - a list of coordinates over which the user ran his finger (the point of the wheel moved). <br>  <b>Session</b> - starts when the finger touches the touchscreen, continues when the user moves on it without releasing the finger, and ends when the finger is removed.  During the session, its route is built. <br>  <b>Gesture</b> (Gesture) - a kind of template reference route, which compares the route of the session.  For example, the user jabbed his finger, pulled it to the left and let go - this is a gesture with the identifier sgiLeft. <br><br><h4>  3. We deal with processing WM_TOUCH </h4><br>  First you need to decide - does our hardware support multi-touch at all? <br>  To do this, just call GetSystemMetrics with the SM_DIGITIZER parameter and check the result for the presence of two flags: NID_READY and NID_MULTI_INPUT. <br><br>  Rough: <br><br><pre> <code class="delphi hljs">tData := GetSystemMetrics(SM_DIGITIZER); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tData <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> NID_READY &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tData <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> NID_MULTI_INPUT &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ...  ,  </code> </pre><br>  Unfortunately, if you do not have multitouch-enabled devices running on Windows OS, then the further part of the article will be just a theory for you, without the possibility of checking the result.  You can try using the emulator tacha from the <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fid%3D26716">Microsoft Surface 2.0 SDK</a> , but I have not experimented with it. <br><br>  BUT!!!  If your device supports multitouch, then you can try to touch it.  To do this, select an arbitrary window (for example, the main form) and say: <br><br><pre> <code class="delphi hljs">RegisterTouchWindow(Handle, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Without calling this function, our selected window will not accept WM_TOUCH messages. <br>  The ‚ÄúUnregisterTouchWindow‚Äù function will help ‚Äúwean‚Äù the window from receiving this message. <br><br>  We declare the WM_TOUCH message handler. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WmTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Msg: TMessage)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> WM_TOUCH;</code> </pre><br>  And we begin to understand - what he gives us at all. <br><br>  So, the WParam parameter of this message contains the number of active points of the wheelbarrow that the system wants to tell us about.  Moreover, this number is stored only in the lower two bytes, which hints that the system can support up to 65535 entry points. <br><br>  I tried to estimate this - it did not work, because my monitor holds a maximum of 10 fingers.  Although, there is a tsimus in this, if you look at modern science fiction films, which show some virtual tables with data that a lot of people work with, who have the opportunity to poke every ten of them there (well, for example, Avatar is the same, or "Oblivion"). <br><br>  Well done, laid out for the future, although, as it turned out, it has been working for a long time without films, I just do not always follow the novelties.  For example, this 46 inch device was presented at the Consumer Electronics Show 2011 exhibition: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6f7/40c/466/6f740c466fc54330b243e2481d60bfce.jpg"></div><br><br>  However, we will not be distracted: <br>  But the LParam of this message is a kind of handle through which you can get more detailed information about the message by calling the function GetTouchInputInfo. <br>  If after calling GetTouchInputInfo a callback of this function is not required, then MSDN recommends saying CloseTouchInputHandle, but this is not necessary, since  data clearing in the heap will still occur automatically when transferring control to DefWindowProc or when attempting to send data via SendMessage / PostMessage. <br>  More <a href="http://msdn.microsoft.com/ru-ru/library/windows/desktop/dd317341(v%3Dvs.85).aspx">details here</a> . <br><br>  What the GetTouchInputInfo function requires of us: <br><br><ol><li>  It needs the handle itself, with which it will work; </li><li>  It needs a dedicated buffer in the form of an array of TTouchInput elements in which it will place all the information about the event; </li><li>  The size of this array; </li><li>  The size of each element of the array. </li></ol><br>  Well done again: with the help of the fourth item, we immediately laid the foundation for the possibility of changing the structure of TTouchInput in the next versions of the OS (it‚Äôs even interesting what else can I add? <br><br>  If very rude, then its call looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Count: Integer; Inputs: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TTouchInput; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Count := Msg.WParam <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $FFFF; SetLength(Inputs, Count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GetTouchInputInfo(Msg.LParam, Count, @Inputs[<span class="hljs-number"><span class="hljs-number">0</span></span>], SizeOf(TTouchInput)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... -     CloseTouchInputHandle(Msg.LParam);</span></span></code> </pre><br>  It's all.  And now let's try to deal with the data stored in the Inputs array. <br><br><h4>  4. Process TTouchInput </h4><br>  From this very moment begins the most interesting. <br><br>  The size of the TTouchInput array depends on how many fingers are attached to the touchscreen. <br>  For each point of the wheelbarrow (finger), the system generates a unique ID, which does not change during the entire session (from the moment you touch it with your finger until ... until we removed it). <br>  This ID is mapped to each TTouchInput element of the array and is stored in the dwID parameter. <br><br>  Speaking of sessions: <br>  Session is ... Well, let's go like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b44/bf1/009/b44bf1009ac64d8e8bde831f99880bc6.png"></div><br>  The picture shows exactly 10 sessions (under each finger), their route is shown (an array of points above which the finger moved during each session), moreover, each session is not yet complete (fingers are still attached to the touchscreen). <br><br>  But back to the structure of TTouchInput. <br>  In fact, for normal operation with such a structure, we need only a few parameters from this structure: <br><br><pre> <code class="delphi hljs">TOUCHINPUT = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> x: Integer; <span class="hljs-comment"><span class="hljs-comment">//   y: Integer; //   hSource: THandle; //  ,   dwID: DWORD; //    dwFlags: DWORD; //    //       dwMask: DWORD; dwTime: DWORD; dwExtraInfo: ULONG_PTR; cxContact: DWORD; cyContact: DWORD; end;</span></span></code> </pre><br>  Let's start immediately with the implementation of the demo application. <br>  Create a new project and place a TMemo on the main form, in which the log of work with the touch will be displayed. <br><br>  In the form constructor, we connect it to the processing of the WM_TOUCH message: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgSimpleTouchDemo</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RegisterTouchWindow(Handle, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Now we write an event handler: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgSimpleTouchDemo</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WmTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Msg: TMessage)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlagToStr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: DWORD)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_MOVE &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'move '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_DOWN &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'down '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_UP &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'up '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_INRANGE &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'ingange '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_PRIMARY &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'primary '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_NOCOALESCE &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'nocoalesce '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_PEN &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'pen '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Value <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_PALM &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := Result + <span class="hljs-string"><span class="hljs-string">'palm '</span></span>; Result := Trim(Result); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputsCount, I: Integer; Inputs: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TTouchInput; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     InputsCount := Msg.WParam and $FFFF; //     SetLength(Inputs, InputsCount); //      if GetTouchInputInfo(Msg.LParam, InputsCount, @Inputs[0], SizeOf(TTouchInput)) then begin //   (    ) CloseTouchInputHandle(Msg.LParam); //     for I := 0 to InputsCount - 1 do Memo1.Lines.Add(Format('TouchInput ‚Ññ: %d, ID: %d, flags: %s', [I, Inputs[I].dwID, FlagToStr(Inputs[I].dwFlags)])); end; end;</span></span></code> </pre><br>  It's all. <br><br>  Agree - just to the impossibility.  All data before eyes. <br>  Try experimenting with this code using a touchscreen and you will notice that the developer, in addition to binding to the ID of each touch, also sends a specific set of flags that are displayed in the log. <br>  According to the log, you can immediately determine the beginning of the session of the touch (the TOUCHEVENTF_DOWN flag), the movement of each finger on the touchscreen (the TOUCHEVENTF_MOVE flag) and the end of the session (the TOUCHEVENTF_UP flag). <br><br>  It looks like this: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/SR0pWZBPks0%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700191,15700253&amp;usg=ALkJrhjcDLDeRZQ481eVvN4a_jZzZY8rsQ" frameborder="0" allowfullscreen=""></iframe><br><br>  At once I will make a reservation about one trouble: messages from the touchscreen with the TOUCHEVENTF_DOWN or TOUCHEVENTF_UP flags will not always come to the WM_TOUCH handler.  This nuance must be taken into account when implementing its ‚Äúwrapper classes‚Äù, which will be discussed below. <br><br>  <b>For example:</b> <br>  Our application currently displays PopupMenu - clicking on the touchscreen will close it, but the WM_TOUCH message with the TOUCHEVENTF_DOWN flag will not come to us, although subsequent ones, with the TOUCHEVENTF_MOVE flag, we will get quite successfully. <br>  The same applies to showing PopupMenu in the TOUCHEVENTF_MOVE event handler. <br>  In this case, the session will fail and WM_TOUCH messages with the TOUCHEVENTF_UP flag should not be waited. <br><br>  This behavior is observed under Windows 7 (32/64 bits), I even admit - under Windows 8 and above something has changed, but I just have no opportunity to check it now (laziness is the second I). <br><br>  However, having received an idea of ‚Äã‚Äãhow ‚Äúit works‚Äù, we will try to write something more interesting. <br><br>  The source code of the example in the folder " <a href="">. \ Demos \ simple \</a> " in the archive with source codes. <br><br><h4>  5. We use multi-player practice. </h4><br>  My monitor holds 10 fingers at the same time, you can even write an application that emulates a piano (although there are pedals in the piano and sensitivity to pressure), but why go immediately from the complex? <br>  The simplest thing that occurred to me was 10 squares on the form canvas, which I can move in all directions by means of a wheelbarrow. <br>  This is quite enough to "feel" multitouch in the most direct sense. <br><br>  Create a new project. <br><br>  Each of the squares will be described in the following structure: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Color: TColor; ARect, StartRect: TRect; StartPoint: TPoint; Touched: Boolean; TouchID: Integer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In fact, the most important field of this structure is TouchID, everything else is secondary. <br><br>  We need to store data for each square somewhere, so we will declare them as such an array: <br><br><pre> <code class="delphi hljs">FData: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TData;</code> </pre><br>  Well, we will execute initialization: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgMultiTouchDemo</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> DoubleBuffered := True; RegisterTouchWindow(Handle, <span class="hljs-number"><span class="hljs-number">0</span></span>); Randomize; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FData[I].Color := Random($FFFFFF); FData[I].ARect.Left := Random(ClientWidth - <span class="hljs-number"><span class="hljs-number">100</span></span>); FData[I].ARect.Top := Random(ClientHeight - <span class="hljs-number"><span class="hljs-number">100</span></span>); FData[I].ARect.Right := FData[I].ARect.Left + <span class="hljs-number"><span class="hljs-number">100</span></span>; FData[I].ARect.Bottom := FData[I].ARect.Top + <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  And also their drawing on the form canvas (for now, do not analyze the FormPaint handler, we will get to it a little lower): <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgMultiTouchDemo</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormPaint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Canvas.Brush.Color := Color; Canvas.FillRect(ClientRect); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Canvas.Pen.Color := FData[I].Color xor $FFFFFF; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FData[I].Touched <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Canvas.Pen.Width := <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Canvas.Pen.Width := <span class="hljs-number"><span class="hljs-number">1</span></span>; Canvas.Brush.Color := FData[I].Color; Canvas.Rectangle(FData[I].ARect); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Run, it turns out something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/988/a66/6de/988a666deea74cc99eb8457889b1cfa9.png"></div><br><br>  The body kit is ready, now we will try to change the image through WM_TOUCH processing. <br><br>  All we need in the handler is to get the index of the square over which the user pressed a finger.  But first, let's translate the coordinates from each point of the wheelbarrow to the window coordinates: <br><br><pre> <code class="delphi hljs">pt.X := TOUCH_COORD_TO_PIXEL(Inputs[I].x); pt.Y := TOUCH_COORD_TO_PIXEL(Inputs[I].y); pt := ScreenToClient(pt);</code> </pre><br>  Having valid coordinates on hands, we can learn an index of a square in an array, by means of call PtInRect. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIndexAtPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pt: TPoint)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PtInRect(FData[I].ARect, pt) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := I; <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  When the user just touched the touchscreen with his finger (considering that each point has its own unique ID), we will assign the given ID to the found square.  It will be useful in the future: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Inputs[I].dwFlags <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_DOWN &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := GetIndexAtPoint(pt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Touched := True; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].TouchID := Inputs[I].dwID; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartRect := FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].ARect; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartPoint := pt; <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  This is, let's say, the initialization of the object and the start of the session of the wheelbarrow. <br><br>  The next message we get is likely to be WM_TOUCH with the TOUCHEVENTF_MOVE flag. <br><br>  <b>There is a nuance:</b> <br>  In the first case, we searched for squares by their coordinates, but now it will be a mistake, if only because the positions of the squares on the form may intersect. <br>  Therefore, in the case of MOVE, we will search for the squares by the ID of the wheelbarrow, which was set using the TouchID parameter: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIndexFromID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID: Integer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FData[I].TouchID = ID <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := I; <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Having found the square we need, we make a shift, focusing on the structure set at the beginning of the touch session: <br><br><pre> <code class="delphi hljs">R := FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartRect; OffsetRect(R, pt.X - FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartPoint.X, pt.Y - FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartPoint.Y); FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].ARect := R;</code> </pre><br><br>  Well, and ending in the form of processing flag TOUCHEVENTF_UP: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Inputs[I].dwFlags <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_UP &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Touched := False; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].TouchID := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In which we disable the square from the touch session and redraw the canvas itself. <br><br>  An extremely simple example, which, however, works and does not ask for money. <br>  Start and test - it turns out quite funny: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/1_BF8AaZkFY%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700191,15700253&amp;usg=ALkJrhhAHwytoVdlcu-ywBIyDGxi91pzQA" frameborder="0" allowfullscreen=""></iframe><br><br>  Just for the ‚Äúcoloriness‚Äù, the Touched parameter of the TData structure is used inside FormPaint and is responsible for the presence of a ‚Äúgreasy‚Äù frame around a floating square. <br><br>  The source code of the example in the folder " <a href="">. \ Demos \ multutouch \</a> " in the archive with source codes. <br><br><h4>  6. Understanding Gesture (gestures) </h4><br>  Multi-touch is only the first step, because we would like to work with multi-gestures, but ... <br>  Let's begin by looking at how gesture recognition is implemented in the VCL based on one touch session (with one finger). <br><br>  This is the responsibility of the TGestureEngine class, from which, in principle, only the IsGesture () function code will be required. <br><br>  Consider it in more detail: <br><br>  It is divided exactly into two parts, where the first part checks the standard gestures in a loop: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// Process standard gestures if gtStandard in GestureTypes then</span></span></code> </pre><br>  And the second - some custom gestures transmitted by the user: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// Process custom gestures if CustomGestureTypes * GestureTypes = CustomGestureTypes then</span></span></code> </pre><br>  Since we do not need custom custom gestures, by definition, we consider only the first part of the function. <br>  Its main idea looks like a search for a gesture descriptor via a call to FindStandardGesture and comparing it with the transmitted route using Recognizer.Match. <br><br>  All other parameters coming to IsGesture, in fact, can be excluded - they are the body kit of the function. <br><br>  The trick is that Recognizer is not an IGestureRecognizer interface, but a VCL wrapper. <br>  This is what we need. <br><br>  But before proceeding to writing a demo example, you need to understand what the gesture itself (Gerture) is: <br><br>  This is the structure of the form: <br><br><pre> <code class="delphi hljs">TStandardGestureData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Points: TGesturePointArray; GestureID: TGestureID; Options: TGestureOptions; Deviation: Integer; ErrorMargin: Integer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  <b>Points</b> is a gesture route with which a similar route is compared from a user's session. <br>  <b>GestureID</b> is a unique identifier for the gesture. <br><br><div class="spoiler">  <b class="spoiler_title">In XE4, they are listed in the Vcl.Controls module:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">// Standard gesture id's sgiNoGesture = 0; sgiLeft = 1; sgiRight = 2; ...</span></span></code> </pre><br></div></div><br>  <b>Options</b> - in this case, they are not interesting to us. <br><br>  <b>Deviation and ErrorMargin</b> are the parameters that indicate the magnitude, let's say: the finger ‚Äútremor‚Äù in the gesture process.  It is unlikely that you will be able to draw a perfectly flat line along the X axis to the left without changing the position along the Y axis, therefore Deviation and ErrorMargin point at the boundaries within which the point moves will be valid. <br><br><div class="spoiler">  <b class="spoiler_title">The declarations of the parameters of standard gestures can be found in the Vcl.Touch.Gestures module:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ Standard gesture definitions }</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDefaultLeft: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TPoint = ((X:<span class="hljs-number"><span class="hljs-number">200</span></span>; Y:<span class="hljs-number"><span class="hljs-number">0</span></span>), (X:<span class="hljs-number"><span class="hljs-number">0</span></span>; Y:<span class="hljs-number"><span class="hljs-number">0</span></span>)); CDefaultLeft: TStandardGestureData = ( GestureID: sgiLeft; Options: [goUniDirectional]; Deviation: <span class="hljs-number"><span class="hljs-number">30</span></span>; ErrorMargin: <span class="hljs-number"><span class="hljs-number">20</span></span>); PDefaultRight: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TPoint = ((X:<span class="hljs-number"><span class="hljs-number">0</span></span>; Y:<span class="hljs-number"><span class="hljs-number">0</span></span>), (X:<span class="hljs-number"><span class="hljs-number">200</span></span>; Y:<span class="hljs-number"><span class="hljs-number">0</span></span>)); CDefaultRight: TStandardGestureData = ( GestureID: sgiRight; Options: [goUniDirectional]; Deviation: <span class="hljs-number"><span class="hljs-number">30</span></span>; ErrorMargin: <span class="hljs-number"><span class="hljs-number">20</span></span>); PDefaultUp: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TPoint = ((X:<span class="hljs-number"><span class="hljs-number">0</span></span>; Y:<span class="hljs-number"><span class="hljs-number">200</span></span>), (X:<span class="hljs-number"><span class="hljs-number">0</span></span>; Y:<span class="hljs-number"><span class="hljs-number">0</span></span>)); CDefaultUp: TStandardGestureData = ( GestureID: sgiUp; Options: [goUniDirectional]; Deviation: <span class="hljs-number"><span class="hljs-number">30</span></span>; ErrorMargin: <span class="hljs-number"><span class="hljs-number">20</span></span>); ...</code> </pre><br></div></div><br>  Thus, knowing the format of gestures, we can prepare our own version of the gesture on our own in runtime by filling out its route (Points) and setting a unique ID. <br>  However, now we will not need it.  Let's see what can be done on the basis of standard gestures. <br><br>  We write the simplest example by which Recognizer will return to us the ID of the gesture identified by it, in which we will build 4 arrays of points that are technically similar to those routes that the user will enter using a touchscreen. <br><br><div class="spoiler">  <b class="spoiler_title">For example, like this:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">program</span></span> recognizer_demo; <span class="hljs-meta"><span class="hljs-meta">{$APPTYPE CONSOLE}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R *.res}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Vcl.Controls, SysUtils, TypInfo, Vcl.Touch.Gestures; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TPointArray = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TPoint; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGestureID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TPointArray)</span></span></span><span class="hljs-function">:</span></span> Byte; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Recognizer: TGestureRecognizer; GestureID: Integer; Data: TStandardGestureData; Weight, TempWeight: Single; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Weight := <span class="hljs-number"><span class="hljs-number">0</span></span>; Result := sgiNone; Recognizer := TGestureRecognizer.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GestureID := sgiLeft <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> sgiDown <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FindStandardGesture(GestureID, Data); TempWeight := Recognizer.Match(Value, Data.Points, Data.Options, GestureID, Data.Deviation, Data.ErrorMargin); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TempWeight &gt; Weight <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Weight := TempWeight; Result := GestureID; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> Recognizer.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gesture_id: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [sgiNone..sgiDown] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ( <span class="hljs-string"><span class="hljs-string">'sgiNone'</span></span>, <span class="hljs-string"><span class="hljs-string">'sgiLeft'</span></span>, <span class="hljs-string"><span class="hljs-string">'sgiRight'</span></span>, <span class="hljs-string"><span class="hljs-string">'sgiUp'</span></span>, <span class="hljs-string"><span class="hljs-string">'sgiDown'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; Data: TPointArray; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(Data, <span class="hljs-number"><span class="hljs-number">11</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     for I := 0 to 10 do begin Data[I].X := I * 10; Data[I].Y := 0; end; Writeln(gesture_id[GetGestureID(Data)]); //     for I := 0 to 10 do begin Data[I].X := 500 - I * 10; Data[I].Y := 0; end; Writeln(gesture_id[GetGestureID(Data)]); //     for I := 0 to 10 do begin Data[I].X := 0; Data[I].Y := 500 - I * 10; end; Writeln(gesture_id[GetGestureID(Data)]); //     for I := 0 to 10 do begin Data[I].X := 0; Data[I].Y := I * 10; end; Writeln(gesture_id[GetGestureID(Data)]); Readln; end.</span></span></code> </pre><br></div></div><br>  After launch, you should see the following image: <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/4f7/82b/d7b/4f782bd7b22749a193937dbb06fa71cf.png"></div><br><br>  What was intended. <br>  The source code of the example in the folder " <a href="">. \ Demos \ recognizer \</a> " in the archive with source codes. <br><br>  And now‚Ä¶ <br><br><h4>  7. Recognize multitouch gestures (Gestures) </h4><br>  This chapter describes the main idea of ‚Äã‚Äãthis article, let's say - a chip, for the sake of which all this text appeared. <br>  Now - no technical details, only the approach itself: <br><br>  <b>So, what is available to us now:</b> <br><ol><li>  We know how to take data from each touch session; </li><li>  We can recognize the gesture of each touch session. </li></ol><br>  <b>For example:</b> <br><ol><li>  The user pressed a finger on the touchscreen and held to the left; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We fixed the beginning of the session in the ON_TOUCH + TOUCHEVENTF_DOWN handler, recorded all route points for the TOUCHEVENTF_MOVE arrival and, at the moment when TOUCHEVENTF_UP arrived, passed the previously recorded array of points to the GetGestureID function; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brought the result. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But imagine that the user did the same thing, only with two fingers at the same time: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For each finger, we start our own session; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We write its route; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the end of each session, we pass it on to the recognition of the gesture. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the ID of gestures from two sessions produced on the same window coincide (for example, it will be sgiLeft), then we can conclude that the swipe has occurred to the left with two fingers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what if all the waypoints of the session contain the same coordinates? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At that time there was no gesture and the so-called tap (with one or many fingers) occurred. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And under this condition will also get the gesture "Press And Tap", with the help of which PopupMenu is usually displayed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, taking into account the main formulation of the problem, we can control all the gestures of gestures we need with one, two, and three fingers (however, even with all ten). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what if the gestures from the two sessions did not match?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyzing them, and although this is not part of the current formulation of the problem, it can be said with confidence that the sgiLeft gesture from the first session plus the sgiRight gesture from the second can be interpreted as Zoom. </font><font style="vertical-align: inherit;">Even Rotate is quite possible to detect based on gestures sgiSemiCircleLeft or sgiSemiCircleRight only on the basis of two touch sessions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penetrated? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the default list of gestures that can be easily emulated in this way: </font></font><br> <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd940543(v%3Dvs.85).aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Touch Gestures Overview</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unfortunately, for some reason, all this is not implemented in XE4 and it became available only from the seventh version (and I‚Äôm not sure about it completely).</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Technical planning engine </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We finished with the theoretical part, now it's time to put all this into practice and immediately consider several problems faced by the developer. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem number one:</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are usually hundreds of windows in the application - most of them are enough that the system generates WM_LBUTTONCLICK and other messages when the screen is tacho and others, which are enough for normal window behavior (for example for buttons, edits, scrolls), but for the same SysListView32 scrolling through a gesture with two fingers does not occur, due to the lack of generation of the WM_SCROLL message. But there are also custom controls. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expanding the window procedure of each window is too much work, so you need to somehow decide which windows should support multitouch, and this should be done most universally.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It follows: we need a certain multitouch manager, in which the windows will be registered and who will be responsible for all the work with multitouch. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem number two:</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since we are writing some kind of universal, without rewriting each TWinControl instance, it is necessary to somehow track the re-creation of the window, since the calls to RecreateWnd are one of the regular mechanisms of the VCL. If we do not do this, then at the first re-creation of the window, the TWinControl previously registered by us will stop receiving WM_TOUCH messages and, thus, all the work of our manager will be leveled. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problem number three:</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The manager must keep all data on the touch-sessions and be able to handle situations of failure of the beginning and end of the sessions (for not all notifications come with the Down and Up flags), and it must be borne in mind that the session length can be long in time, which entails a sufficiently long memory consumption, if you save all waypoint session. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would also like the multitouch manager to distinguish gestures within different windows. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if the user has placed two fingers in the left window and two fingers in the right (four multitouch sessions), after which he joined the fingers in the center, the left window should receive a notice of a two-finger gesture to the right and the right hand of a two-finger gesture to the left.</font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/a7c/2d2/ff3/a7c2d2ff330f4a1d829d59802141b19b.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, unfortunately, it will not work, because </font><font style="vertical-align: inherit;">WM_TOUCH message will only come to the window in which the session started, the other windows will be ignored.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Build a basic frame multitouch engine </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin with we will be defin with nuances of implementation of a class. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Technically, the most convenient, from the point of view of an external programmer, will be the implementation of a kind of universal engine that will take over all the work and notify the developer unless it is a challenge to the final events. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the developer will have only once to register the desired window in the engine and analyze the gestures received from it (aimed at a specific window), processing the necessary one. For example, emulating the same scroll with a two-finger gesture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The engine itself will be implemented as a singleton. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> there is no point in producing class instances that will always do the same thing. This is not a TStringList, sharpened for data storage, but still an engine that implements a single operation logic for all project windows.</font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And secondly:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> there is a small nuance in the implementation of the engine itself (about it a bit later), because of which the implementation in the form of a singleton will be the simplest, otherwise it will be necessary to drastically over-complicate the logic of the class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the engine should provide:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methods of registering the window and removing the window from registration: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A set of external events that the developer must implement. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">External events can be something like this: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnBeginTouch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this event will be triggered when WM_TOUCH message is received. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me explain: in the fourth chapter the following code was given:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//     InputsCount := Msg.WParam and $FFFF;</span></span></code> </pre><br>  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There may be several real points of the wheelbarrow. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we will warn the developer about their quantity. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnTouch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - in this event, we will notify the developer of the data contained in each TTouchInput structure, only slightly more coiffed. (Let us translate the point data into window coordinates, set the correct flags and so on, why load the developer with redundant information and force him to write redundant code?) </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnEndTouch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this will say that the WM_TOUCH message processing cycle is complete, you can, for example, call Repaint. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnGecture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - and the developer will receive this message when the engine decides that the gesture is recognized.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the class is implemented as a singleton, and there will be more than one window registered in it, it will not be possible to declare all four events as class properties. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, more precisely, you can: of course, but the second registered window will immediately reassign event handlers to itself and the first will have to smoke quietly on the sidelines. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, in addition to the list of registered windows, we must keep the engine's event handlers that are attached to them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, now we will try to put all this into practice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a new project and add a new module to it, with the name ... well, for example, SimpleMultiTouchEngine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin with, we will declare flags that are interesting to us when processing WM_TOUCH:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TTouchFlag = ( tfMove, <span class="hljs-comment"><span class="hljs-comment">//   tfDown, //    tfUp //     ); TTouchFlags = set of TTouchFlag;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We describe the structure that we will transmit to the developer about each point: </font></font><br><br><pre> <code class="delphi hljs">TTouchData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Integer; <span class="hljs-comment"><span class="hljs-comment">//      TTouchInput ID: DWORD; //  ID  Position: TPoint; //     Flags: TTouchFlags; //  end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The declaration of the OnTouchBegin event will look like this: </font></font><br><br><pre> <code class="delphi hljs">TTouchBeginEvent = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; nCount: Integer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this is what OnTouch will look like: </font></font><br><br><pre> <code class="delphi hljs">TTouchEvent = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; Control: TWinControl; TouchData: TTouchData)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For OnEndTouch, the usual TNotifyEvent will be sufficient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data about the assigned event handlers assigned to each registered window will be stored in this structure:</font></font><br><br><pre> <code class="delphi hljs">TTouchHandlers = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> BeginTouch: TTouchBeginEvent; Touch: TTouchEvent; EndTouch: TNotifyEvent; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We declare a new class: </font></font><br><br><pre> <code class="delphi hljs"> TSimleMultiTouchEngine = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MaxFingerCount = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TWindowData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Control: TWinControl; Handlers: TTouchHandlers; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FWindows: TList&lt;TWindowData&gt;; FMultiTouchPresent: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoBeginTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TTouchBeginEvent; nCount: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Control: TWinControl; Value: TTouchEvent; TouchData: TTouchData)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoEndTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TNotifyEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Integer; Msg: PMsg)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Msg: PMsg)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TWinControl; Handlers: TTouchHandlers)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnRegisterWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TWinControl)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The MaxFingerCount constant contains the maximum number of tach points that our class can work with. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TWindowData structure - contains a registered window and a list of handlers that the programmer assigned. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Field FWindows: TList - a list of registered windows and handlers, from which we will be dancing throughout the work with the class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The FMultiTouchPresent field is a flag initialized in the class constructor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contains True if our hardware keeps multitouch. Based on this flag, part of the class logic will be disabled (why do we need to do extra gestures when we still cannot complete them?). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first protected section - just for convenience, all external event calls are made.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The HandleTouch procedure is the main engine of the engine, and it is she who is responsible for processing the WM_TOUCH message. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedure HandleMessage - auxiliary. </font><font style="vertical-align: inherit;">Its task is to determine to which of the registered windows the message is sent and call HandleTouch, passing the index of the found window. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Public section - constructor, destructor, registration window and removing it from registration.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before proceeding with the implementation of the class, we will immediately write a singleton kit:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MultiTouchEngine</span></span></span><span class="hljs-function">:</span></span> TSimleMultiTouchEngine; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _MultiTouchEngine: TSimleMultiTouchEngine = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MultiTouchEngine</span></span></span><span class="hljs-function">:</span></span> TSimleMultiTouchEngine; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _MultiTouchEngine = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> _MultiTouchEngine := TSimleMultiTouchEngine.Create; Result := _MultiTouchEngine; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">initialization</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finalization</span></span> _MultiTouchEngine.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, at the end of all, callback traps, with which we will receive WM_TOUCH messages sent to windows registered in the engine.</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FHook: HHOOK = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMsgProc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nCode: Integer; WParam: WPARAM; LParam: LPARAM)</span></span></span><span class="hljs-function">:</span></span> LRESULT; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nCode = HC_ACTION) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (WParam = PM_REMOVE) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PMsg(LParam)^.<span class="hljs-keyword"><span class="hljs-keyword">message</span></span> = WM_TOUCH <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MultiTouchEngine.HandleMessage(PMsg(LParam)); Result := CallNextHookEx(FHook, nCode, WParam, LParam); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just in case, the list of modules used is as follows:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Windows, Messages, Classes, Controls, Generics.Defaults, Generics.Collections, Vcl.Touch.Gestures;</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, now let's go through the implementation of the engine itself. </font><font style="vertical-align: inherit;">Let's start with the designer.</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSimleMultiTouchEngine</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Data: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,     Data := GetSystemMetrics(SM_DIGITIZER); FMultiTouchPresent := (Data and NID_READY &lt;&gt; 0) and (Data and NID_MULTI_INPUT &lt;&gt; 0); //  ,       if not FMultiTouchPresent then Exit; //         FWindows := TList&lt;TWindowData&gt;.Create( //   IndexOf          Control //    TComparer&lt;twindowdata&gt;.Construct( function (const A, B: TWindowData): Integer begin Result := Integer(A.Control) - Integer(B.Control); end) ); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rather simple designer without frills, in the comments you can see all the steps. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, the destructor is also simple:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSimleMultiTouchEngine</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FHook &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> UnhookWindowsHookEx(FHook); FWindows.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only nuance of the destructor is the removal of the trap, if it was previously installed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the implementation of the two only public procedures available to the developer from the outside. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registration window in the engine:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSimleMultiTouchEngine</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TWinControl; Handlers: TTouchHandlers)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> WindowData: TWindowData; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     -  if not FMultiTouchPresent then Exit; //    IndexOf ,     WindowData.Control := Value; //      , //     if FWindows.IndexOf(WindowData) &lt; 0 then begin //    WindowData.Handlers := Handlers; //     RegisterTouchWindow(Value.Handle, 0); //       FWindows.Add(WindowData); end; //      if FHook = 0 then FHook := SetWindowsHookEx(WH_GETMESSAGE, @GetMsgProc, HInstance, GetCurrentThreadId); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything is commented, however, the only nuance with the call IndexOf. In order for it to work not through CompareMem comparing two structures with each other, but only over one field of the structure (Control) and TComparer was implemented in the list class constructor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see from the code, the logic is simple, after adding a window to the general list, the class starts the WH_GETMESSAGE trap (if it has not been previously started), and it works only within the current thread. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separately, focus on the variable FMultiTouchPresent. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As can be seen from the code, it simply acts as a fuse, which disables all the logic of the class in the event that we can not do anything useful.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you remove it, then there will be a small ‚Äúoverhead‚Äù in the message sampling cycle of each window of our application due to the installed trap in the event that our hardware has no idea about the touchscreen at all. </font><font style="vertical-align: inherit;">We need it? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Removing the window from the registration goes the same way, with disabling the trap if there are no more windows:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSimleMultiTouchEngine</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnRegisterWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value: TWinControl)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Integer; WindowData: TWindowData; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     -  if not FMultiTouchPresent then Exit; //    IndexOf ,     WindowData.Control := Value; //   Index := FWindows.IndexOf(WindowData); if Index &gt;= 0 then //  ,     FWindows.Delete(Index); //    ,       if FWindows.Count = 0 then begin //   UnhookWindowsHookEx(FHook); FHook := 0; end; end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actually, the entire logic of the engine is simple: they took the window for registration, started the trap, which, when receiving the WM_TOUCH message, calls the HandleMessage procedure, by referring to the class singleton. </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSimleMultiTouchEngine</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Msg: PMsg)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FWindows.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">//   ,    if FWindows[I].Control.Handle = Msg^.hwnd then begin //      HandleTouch(I, Msg); Break; end; end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And here is the central class procedure, around which all the logic of the work revolves: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TSimleMultiTouchEngine</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Integer; Msg: PMsg)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> TouchData: TTouchData; I, InputsCount: Integer; Inputs: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TTouchInput; Flags: DWORD; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,      InputsCount := Msg^.wParam and $FFFF; if InputsCount = 0 then Exit; //          if InputsCount &gt; MaxFingerCount then InputsCount := MaxFingerCount; //       SetLength(Inputs, InputsCount); if not GetTouchInputInfo(Msg^.LParam, InputsCount, @Inputs[0], SizeOf(TTouchInput)) then Exit; CloseTouchInputHandle(Msg^.LParam); //       //       DoBeginTouch(FWindows[Index].Handlers.BeginTouch, InputsCount); for I := 0 to InputsCount - 1 do begin TouchData.Index := I; //      ID   //        ( Down  Up) //       TouchData.ID := Inputs[I].dwID; //        TouchData.Position.X := TOUCH_COORD_TO_PIXEL(Inputs[I].x); TouchData.Position.Y := TOUCH_COORD_TO_PIXEL(Inputs[I].y); TouchData.Position := FWindows[Index].Control.ScreenToClient(TouchData.Position); //    TouchData.Flags := []; Flags := Inputs[I].dwFlags; if Flags and TOUCHEVENTF_MOVE &lt;&gt; 0 then Include(TouchData.Flags, tfMove); if Flags and TOUCHEVENTF_DOWN &lt;&gt; 0 then Include(TouchData.Flags, tfDown); if Flags and TOUCHEVENTF_UP &lt;&gt; 0 then Include(TouchData.Flags, tfUp); //           DoTouch(FWindows[Index].Control, FWindows[Index].Handlers.Touch, TouchData); end; //       //       DoEndTouch(FWindows[Index].Handlers.EndTouch); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have already seen all this in the fifth chapter of the article; therefore, it does not make sense to give additional explanations on the code. </font><font style="vertical-align: inherit;">Let's go to work with the resulting multitouch engine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of the module SimleMultiTouchEngine.pas in the folder " </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. \ Demos \ multitouch_engine_demo \</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " in the archive with the sources.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. We work with TSimleMultiTouchEngine </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not invent something new and try to reproduce the project from the fifth chapter, in which the main change will be that TSimleMultiTouchEngine will support multitouch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the project created in Chapter 9, add the declaration of the TData structure and the FData array from the fifth chapter, and also copy the FormPaint handler. </font><font style="vertical-align: inherit;">All this will remain unchanged. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We declare two handlers:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; Control: TWinControl; TouchData: TTouchData)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTouchEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We will connect SimleMultiTouchEngine to the modules we use and slightly modify the class constructor: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgMultiTouchEngineDemo</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; Handlers: TTouchHandlers; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> DoubleBuffered := True; <span class="hljs-comment"><span class="hljs-comment">// RegisterTouchWindow(Handle, 0); Randomize; for I := 0 to 9 do begin FData[I].Color := Random($FFFFFF); FData[I].ARect.Left := Random(ClientWidth - 100); FData[I].ARect.Top := Random(ClientHeight - 100); FData[I].ARect.Right := FData[I].ARect.Left + 100; FData[I].ARect.Bottom := FData[I].ARect.Top + 100; end; ZeroMemory(@Handlers, SizeOf(TTouchHandlers)); Handlers.Touch := OnTouch; Handlers.EndTouch := OnTouchEnd; MultiTouchEngine.RegisterWindow(Self, Handlers); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The changes, in fact, are minimal, instead of calling RegisterTouchWindow, we shift the work to the MultiTouchEngine that we just implemented. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The OnTouchEnd handler is simple:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgMultiTouchEngineDemo</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTouchEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Repaint; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just call the redraw of the entire canvas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's see what the code turned into in the OnTouch handler (previously implemented in the WmTouch handler):</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgMultiTouchEngineDemo</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; Control: TWinControl; TouchData: TTouchData)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIndexAtPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pt: TPoint)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> PtInRect(FData[I].ARect, pt) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := I; <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIndexFromID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID: Integer)</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FData[I].TouchID = ID <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := I; <span class="hljs-keyword"><span class="hljs-keyword">Break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Integer; R: TRect; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tfDown <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TouchData.Flags <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := GetIndexAtPoint(TouchData.Position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Touched := True; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].TouchID := TouchData.ID; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartRect := FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].ARect; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartPoint := TouchData.Position; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> := GetIndexFromID(TouchData.ID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tfUp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TouchData.Flags <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Touched := False; FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].TouchID := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (tfMove <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TouchData.Flags) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].Touched <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; R := FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartRect; OffsetRect(R, TouchData.Position.X - FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartPoint.X, TouchData.Position.Y - FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].StartPoint.Y); FData[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>].ARect := R; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ideology has practically not changed, but it is read much easier than in the old version. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And most importantly: it works the same way as the code from the fifth chapter.</font></font><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/LCEgn3ybpN4%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700191,15700253&amp;usg=ALkJrhjhEgCCfBkPnKHyGRpDECSLwYlMcA" frameborder="0" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of the example in the folder " </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. \ Demos \ multitouch_engine_demo \</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " in the archive with source codes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So what is the same Tsimus, most likely you ask. </font><font style="vertical-align: inherit;">After all, the size of the code in the main form and the algorithm of its work practically did not change, plus an additional module appeared already up to 277 lines of code (with comments) in the form of SimleMultiTouchEngine.pas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can it be easier to leave it as it is and implement the WM_TOUCH handler on its own only where it is really necessary? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, so it is - so, the truth is, this engine only solves the first task out of the three, voiced in the eighth chapter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the cymus is this ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. We turn on gesture support in the engine. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the MultiTouchEngine implemented above, there is no solution to the other two points from the planned problems, without solving which it turns into just an extra class in the project hierarchy (of course now this class can provide everyone who suffers with multitouch, but this does not change the essence). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start right away with problem number three. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, let's declare the types of gestures recognized by the engine and the external event handler:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//    TGestureType = ( gtNone, //    gtTap, gt2Tap, gt3Tap, //   (1, 2, 3 ) gtLeft, gtRight, gtUp, gtDown, //      gt2Left, gt2Right, gt2Up, gt2Down, //      gt3Left, gt3Right, gt3Up, gt3Down //      ); //     TGestureEvent = procedure(Sender: TObject; Control: TWinControl; GestureType: TGestureType; Position: TPoint; Completed: Boolean) of object;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our class will have to be able to recognize 15 different gestures (except for gtNone). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note the Completed parameter in the TGestureEvent declaration. </font><font style="vertical-align: inherit;">This flag will inform the developer of the completion of the gesture (the arrival of the WM_TOUCH + TOUCHEVENTF_UP message).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What it is done for: for example, the user clicked on the touchscreen with two fingers and led them to the left, in theory it is necessary to scroll the window, but if you wait for the end of the gesture, it will not work correctly, therefore the multitouch engine will periodically generate an external OnGesture event in which necessary scroll right during the session of the wheelbarrow. It is in this handler that the developer will be able to understand by the Completed parameter - the gesture is completed or not (for example, if we receive gtTap, and the Completed parameter is set to False, so far nothing needs to be done and it‚Äôs worth waiting for the end).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The frequency with which the OnGesture event will be generated during the session directly depends on the GesturePartSize constant, which I set to 10. That is, </font><font style="vertical-align: inherit;">as soon as the number of session points has become a multiple of a constant (the remainder of the modulo division is zero), an event is generated. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data for each session will be stored in this array:</font></font><br><br><pre> <code class="delphi hljs">TPointArray = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TPoint;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, we will declare the structure describing each session like this: </font></font><br><br><pre> <code class="delphi hljs"> TGestureItem = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> ID, <span class="hljs-comment"><span class="hljs-comment">// ID ,     ControlIndex: Integer; //  ,      Data: TList&lt;TPoint&gt;; //  ,        Done: Boolean; //      end;</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains, perhaps, to declare a class that will store data for each touch session:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// ,         //   10  TGesturesData = class ... strict private //      FData: array [0..MaxFingerCount - 1] of TGestureItem; ... public ... //   procedure StartGesture(ID, ControlIndex: Integer; Value: TPoint); //      function AddPoint(ID: Integer; Value: TPoint): Boolean; //   procedure EndGesture(ID: Integer); //         procedure ClearControlGestures(ControlIndex: Integer); //         function GetGesturePath(ID: Integer): TPointArray; //        OnEndAllGestures  OnPartComplete property LastControlIndex: Integer read FLastControlIndex; //         LastControlIndex property OnEndAllGestures: TGesturesDataEvent read FEndAll write FEndAll; //     GesturePartSize       LastControlIndex property OnPartComplete: TGesturesDataEvent read FPart write FPart; end;</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is actually an extremely simple class that does not contain any special frills, so we will not consider the implementation of each function, since you can see everything in the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example of a demo project</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that comes with the article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">His whole task is:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> store incoming data through calls StartGesture and AddPoint; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> after each call to addpoint, check the size of the list </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data: TList &lt;TPoint&gt; </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for each session associated with the ControlIndex window and, if necessary, call OnPartComplete; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> after calling EndGesture, check all sessions with the same ControlIndex and, if they are all completed, call OnEndAllGestures. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is just a session repository for our engine and the TGestureRecognizer will work with the data it stores. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expand our base class by adding the following two fields:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//         FGesturesData: TGesturesData; //        FGestureRecognizer: TGestureRecognizer;</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the constructor, create and initialize our session repository:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs">FGesturesData := TGesturesData.Create; FGesturesData.OnEndAllGestures := OnEndAllGestures; FGesturesData.OnPartComplete := OnPartComplete; FGestureRecognizer := TGestureRecognizer.Create;</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After that, we will return back to the HandleTouch () method, where we will need to slightly expand the code that was responsible for setting the flags in the TouchData structure: </font></font><br><br><pre> <code class="delphi hljs">TouchData.Flags := []; Flags := Inputs[I].dwFlags; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Flags <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> TOUCHEVENTF_MOVE &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Include(TouchData.Flags, tfMove); <span class="hljs-comment"><span class="hljs-comment">//    ,    //  ,     if not FGesturesData.AddPoint(TouchData.ID, TouchData.Position) then //      ,    FGesturesData.StartGesture(TouchData.ID, Index, TouchData.Position); end; if Flags and TOUCHEVENTF_DOWN &lt;&gt; 0 then begin Include(TouchData.Flags, tfDown); //      , //      ID FGesturesData.StartGesture(TouchData.ID, Index, TouchData.Position); end; if Flags and TOUCHEVENTF_UP &lt;&gt; 0 then begin Include(TouchData.Flags, tfUp); //         // -    . //        , //  FGesturesData        FGesturesData.EndGesture(TouchData.ID); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actually, this is almost all active work with the data warehouse for each session. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event handlers for the completion of the touch session and partial completion are quite simple:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// //             //  Values  ID  , //         // ============================================================================= procedure TTouchManager.OnPartComplete(Values: TBytes); var Position: TPoint; GestureType: TGestureType; begin //       ? GestureType := RecognizeGestures(Values, Position); //   ,     if GestureType &lt;&gt; gtNone then DoGesture( FWindows[FGesturesData.LastControlIndex].Control, FWindows[FGesturesData.LastControlIndex].Handlers.Gesture, GestureType, Position, //            False); end;</span></span></code> </pre><br>   ,       : <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// //           //  Values  ID    // ============================================================================= procedure TTouchManager.OnEndAllGestures(Values: TBytes); var Position: TPoint; GestureType: TGestureType; begin try //       ? GestureType := RecognizeGestures(Values, Position); //   ,     if GestureType &lt;&gt; gtNone then DoGesture( FWindows[FGesturesData.LastControlIndex].Control, FWindows[FGesturesData.LastControlIndex].Handlers.Gesture, GestureType, Position, //       True); finally //        FGesturesData.ClearControlGestures(FGesturesData.LastControlIndex); end; end;</span></span></code> </pre><br>     ,   ,       ,     . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, as is clear from the handler code: all the main work goes to the RecognizeGestures function, the logic of which I have already described in the seventh chapter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks like this:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">// //          TGesturesData //  Values  ID  , //         // ============================================================================= function TTouchManager.RecognizeGestures(Values: TBytes; var Position: TPoint): TGestureType; var I, A, ValueLen, GestureLen: Integer; GestureID: Byte; GesturePath: TPointArray; NoMove: Boolean; begin Result := gtNone; //   ,      ValueLen := Length(Values); //     (    ),   if ValueLen &gt; 3 then Exit; //   : //    ID     ( GetGestureID), //      sgiLeft //       ,      ID    , //    -        //          //          //         , //            GestureID := sgiNoGesture; NoMove := True; for I := 0 to ValueLen - 1 do begin // ,       TPoint GesturePath := FGesturesData.GetGesturePath(Values[I]); GestureLen := Length(GesturePath); //      - ,       if GestureLen = 0 then Exit; //       if NoMove then for A := 1 to GestureLen - 1 do if GesturePath[0] &lt;&gt; GesturePath[A] then begin NoMove := False; Break; end; //   . //     .      ,   //     ,           Position := GesturePath[GestureLen - 1]; //  ID     if I = 0 then GestureID := GetGestureID(GesturePath) else //   ID     ,    if GestureID &lt;&gt; GetGestureID(GesturePath) then Exit; end; //     ID         if (GestureID = sgiNoGesture) then begin if NoMove then case ValueLen of 1: Result := gtTap; 2: Result := gt2Tap; 3: Result := gt3Tap; end; end else begin Dec(ValueLen); Result := TGestureType(3 + GestureID + ValueLen * 4); end; end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function requires an auxiliary GetGestureID, the analogue of which has already been shown in the sixth chapter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all these manipulations, we can say that problem number 3, voiced in chapter eight, has been solved. </font><font style="vertical-align: inherit;">That is: we are able to store data about each session and, moreover, we know over which window it is being held. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Very little is left - problem number two.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12. Detect window re-creation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said earlier, calling RecreateWnd is essentially a regular VCL mechanism. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, it can badly spoil the whole logic of the work of our engine, since when re-creating the window, so far no one calls RegisterTouchWindow again on the newly created handle. Thus, even though the window continues to be registered in the engine, WM_TOUCH messages stop coming to it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several ways to approach this problem: for example, since we have set a trap, why not catch WM_CREATE / WM_DESTROY messages before the heap to WM_TOUCH? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But I don‚Äôt want to, because there will be a sea of ‚Äã‚Äãsuch messages within the flow GUI, and why do we need an unnecessary overhead head in the message selection cycle?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, let us log in from the other side and write a certain proxy, which will be an invisible window, to which the window will be displayed as a parent, which we must follow. In this case, when the main window is destroyed, the window of our proxy will be destroyed, which can be detected in the DestroyHandle handler, and the creation of the window after its destruction will be caught in CreateWnd, where the valid handle of the parent, which can be told RegisterTouchWindow by connecting it back to receiving WM_TOUCH messages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This mess looks like this:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//       TWinControlProxy = class(TWinControl) protected procedure DestroyHandle; override; procedure CreateWnd; override; procedure CreateParams(var Params: TCreateParams); override; end; { TWinControlProxy } // //     WS_EX_TRANSPARENT,    . // ============================================================================= procedure TWinControlProxy.CreateParams(var Params: TCreateParams); begin inherited; Params.ExStyle := Params.ExStyle or WS_EX_TRANSPARENT; end; // //         // ============================================================================= procedure TWinControlProxy.CreateWnd; begin inherited CreateWnd; if Parent.HandleAllocated then RegisterTouchWindow(Parent.Handle, 0); Visible := False; end; // //      ,    // ============================================================================= procedure TWinControlProxy.DestroyHandle; begin if Parent.HandleAllocated then UnregisterTouchWindow(Parent.Handle); Visible := True; inherited DestroyHandle; end;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This proxy does not know anything about our engine, and on sly it performs only one single task - to prevent the window from disconnecting from the touchscreen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To support proxy, you need to slightly expand the TWindowData structure by adding a link to the one associated with the proxy window:</font></font><br><br><pre> <code class="delphi hljs">TWindowData = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Control, Proxy: TWinControl;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After that, slightly change the window registration procedure: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FWindows.IndexOf(WindowData) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   , //           WindowData.Proxy := TWinControlProxy.Create(Value); WindowData.Proxy.Parent := Value; //   WindowData.Handlers := Handlers; WindowData.LastClickTime := 0; //     RegisterTouchWindow(Value.Handle, 0); FWindows.Add(WindowData); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and removing the window registration: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//   ,        FWindows[Index].Proxy.Free; //   //      FWindows.Delete(Index); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see how it works.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13. Test test of multitouch engine </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again we create a new project and throw TMemo on the main form, in which the results of the work and the button will be displayed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the button handler, we will recreate the main form in order to test the work of the proxy:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgGesturesText</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RecreateWnd; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the form constructor, connect it to the multitouch engine: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgGesturesText</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Handlers: TTouchHandlers; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ZeroMemory(@Handlers, SizeOf(TTouchHandlers)); Handlers.Gesture := OnGesture; TouchManager.RegisterWindow(Self, Handlers); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we implement the handler itself: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TdlgGesturesText</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGesture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject; Control: TWinControl; GestureType: TGestureType; Position: TPoint; Completed: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Completed <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (GestureType <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [gt2Left..gt2Down]) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Memo1.Lines.Add(Format(<span class="hljs-string"><span class="hljs-string">'Control: "%s" gesture "%s" at %dx%d (completed: %s)'</span></span>, [ Control.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>, GetEnumName(TypeInfo(TGestureType), Integer(GestureType)), Position.X, Position.Y, BoolToStr(Completed, True) ])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bildim, run - voila. </font></font><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/EgabHZIzbLs%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700191,15700253&amp;usg=ALkJrhg_77tDJQJIy3lk-vFbuNG_fDuMUQ" frameborder="0" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The video clearly shows the recognition of all 15 supported gestures and also the work of the proxy that controls the registered window. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, this was the very tsimus that I talked about at the end of Chapter 10 - literally a dozen lines of code and everything works out of the box. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of the example in the " </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. \ Demos \ gestures \</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">folder </font><font style="vertical-align: inherit;">in the source archive.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14. Conclusions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's a pity, of course, that this functionality is missing in XE4. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, if it were not for this moment, I would not have begun to understand that: ‚Äúhow it is there, it all works‚Äù, so there are pluses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The disadvantages of this approach are that the work with WM_GESTURE + WM_POINTS messages has been completely cut out and gesture recognition has been transferred to the code in the engine. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I agree, but it was done intentionally. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you yourself begin to dig in this direction, you will probably end up agreeing with my approach, although who knows. At least you will have a field for fantasy, how can you even approach this problem.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of the Common.TouchManager class provided in the demos for the article is not final and will develop from time to time, though I'm not sure that I will accompany it in public. </font><font style="vertical-align: inherit;">However, your suggestions and comments are welcome. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As always, I thank the participants of the Delphi Masters forum for reading the article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code of demos is available at </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Good luck! <br><br>  <b>Update:</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unfortunately, or fortunately, it turned out that due to some features of Windows 8 and higher, the WH_GETMESSAGE trap will not intercept the WM_TOUCH message, so this code will not work. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To fix this trouble, you need to remove the work with the trap and transfer the processing of the WM_TOUCH message to the proxy, rewriting it as follows:</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-comment"><span class="hljs-comment">//       TWinControlProxy = class(TWinControl) private FOldWndProc: TWndMethod; procedure ParentWndProc(var Message: TMessage); protected procedure DestroyHandle; override; procedure CreateWnd; override; procedure CreateParams(var Params: TCreateParams); override; public destructor Destroy; override; procedure InitParent(Value: TWinControl); end; { TWinControlProxy } // //     WS_EX_TRANSPARENT,    . // ============================================================================= procedure TWinControlProxy.CreateParams(var Params: TCreateParams); begin inherited; Params.ExStyle := Params.ExStyle or WS_EX_TRANSPARENT; end; // //         // ============================================================================= procedure TWinControlProxy.CreateWnd; begin inherited CreateWnd; if Parent.HandleAllocated then RegisterTouchWindow(Parent.Handle, 0); Visible := False; end; // //  ,      // ============================================================================= destructor TWinControlProxy.Destroy; begin if Parent &lt;&gt; nil then Parent.WindowProc := FOldWndProc; inherited; end; // //      ,    // ============================================================================= procedure TWinControlProxy.DestroyHandle; begin if Parent.HandleAllocated then UnregisterTouchWindow(Parent.Handle); Visible := True; inherited DestroyHandle; end; // //   ,     // ============================================================================= procedure TWinControlProxy.InitParent(Value: TWinControl); begin Parent := Value; FOldWndProc := Value.WindowProc; Value.WindowProc := ParentWndProc; end; // //   WM_TOUCH     // ============================================================================= procedure TWinControlProxy.ParentWndProc(var Message: TMessage); var Msg: TMsg; begin if Message.Msg = WM_TOUCH then begin Msg.hwnd := Parent.Handle; Msg.wParam := Message.WParam; Msg.lParam := Message.LParam; TouchManager.HandleMessage(@Msg); end; FOldWndProc(Message); end;</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archive to the article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , these changes have already been made.</font></font></div><p>Source: <a href="https://habr.com/ru/post/242355/">https://habr.com/ru/post/242355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242343/index.html">Online conference Stratoplan PRO + People and the year in Habr√©</a></li>
<li><a href="../242347/index.html">Sam Altman: How to form a start-up team and culture?</a></li>
<li><a href="../242349/index.html">NetApp Certification</a></li>
<li><a href="../242351/index.html">XMonad + XMobar =</a></li>
<li><a href="../242353/index.html">Problems in the implementation and sale of electronic document management systems</a></li>
<li><a href="../242357/index.html">Budget planning: black friday 2014 and gifts for the New Year</a></li>
<li><a href="../242359/index.html">ZeroMQ: sockets in a new way</a></li>
<li><a href="../242361/index.html">New free courses of virtual academy Microsoft Virtual Academy, November 2014</a></li>
<li><a href="../242363/index.html">Mozilla released the first developer browser.</a></li>
<li><a href="../242367/index.html">Alternative firmware OpenWRT BarrierBreaker 14.07</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>