<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write a simple * game physics of the aircraft</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* - in three dimensions. 



 Warning: further reasoning may well be wrong, my experience is limited to playing simulators and the course of theoretic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write a simple * game physics of the aircraft</h1><div class="post__text post__text-html js-mediator-article">  * - in three dimensions. <br><br><img src="https://habrastorage.org/files/990/203/826/990203826e994af18707f38b2ee7ebef.jpg"><br><a name="habracut"></a><br>  <i>Warning: further reasoning may well be wrong, my experience is limited to playing simulators and the course of theoretical mechanics.</i>  <i>Knowledge of aerodynamics and game physics engines is very scarce.</i>  <i>A picture for attracting attention is a photograph, not a screenshot.</i> <br><br>  ‚ÄúWhat could be simpler than a plane?  The lift is proportional to the square of speed, the engine pulls forward, everything is simple ‚Äù- such a thought came to my mind in the summer, and I sat down to write a game.  The summer passed, several rakes were collected, and the list of what I planned to add to the project grew very much. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I will try to write about the physical component, without being distracted by the graphics and other things.  I hope this will help someone - there is not a lot of information on this topic on the Internet. <br><br>  Examples of working and not-so-code will be on Scala (to understand the essence, the language is not necessary to know).  In addition, I use classes for vectors, matrices, and quaternions from libgdx.  If someone has questions on the features of their implementation - the engine code is open.  For convenience, vectors have been added methods of the type + =, * =, as well as +, -, the benefit in scala is so possible.  It also turned out to be convenient to add methods: = for assignment by value. <br><br>  Code: <br><br><pre><code class="scala hljs">v:=(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) v2:=v</code> </pre> <br>  Equivalent to <br><br><pre> <code class="scala hljs">v.set(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) v2.set(v),</code> </pre><br>  With the exception of quaternions: <br><br>  <code>set(x,y,z,w)</code> , but <code>:=(w,x,y,z)</code> <br><br>  The second option is much more familiar to me, and I never use set.  I will not lay out my code yet, there is a little trash, which from time to time is being overwritten beyond recognition. <br><br><h3>  So, let's begin. </h3><br>  Write the class for the model position: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Position</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val pos:</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Vector3f</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val rot:</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Quaternion</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  As you might guess, the class will have two final fields describing the position of the center of mass of the model and its orientation relative to the world. <br>  You can get the matrix in libgdx like this: <code>matrix.idt().translate(position.pos).rotate(position.rot)</code> <br><br>  We introduce a class for the derivative: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derivative</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val linear: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Vector3f</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val angular: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Vector3f</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  This class will be convenient not only to describe the speed (first derivative), but also for accelerations and forces. <br><br>  Stop.  How did the quaternion become a vector?  Indeed, the angular velocity, acceleration and momentum are usually described by vectors.  The essential difference between the angular velocity and orientation is that the orientations are ‚Äúlooped around‚Äù, turning two pi is equivalent to ‚Äúzero‚Äù turning.  On the contrary, the angular velocity is in principle unlimited. <br><br>  You can enter the operation of the logarithm of the quaternion q- vector v, which is directed along the direction of the axis of rotation, and its length is equal to the angle of rotation in radians.  The exhibitor is the inverse operation.  q == exp (v * 2) == exp (v) * exp (v) <br><br>  The mapping of vector-&gt; quaternion is unambiguous, but the opposite is not.  The rotation angle alpha in time dt can correspond to the angular velocity (alpha + 2 * pi * n) / dt, where n is any integer. <br><br>  Obviously, during the time dt at the angular velocity w, the rotation is q = exp (w * dt). <br><br>  Code: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuaternionS</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Quaternion</span></span></span></span>{ ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span></span>:=(log: <span class="hljs-type"><span class="hljs-type">Vector3</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> len = log.len <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &gt; <span class="hljs-number"><span class="hljs-number">0.0001</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = len / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> m = <span class="hljs-type"><span class="hljs-type">Math</span></span>.sin(a).toFloat / len <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> :=(<span class="hljs-type"><span class="hljs-type">Math</span></span>.cos(a).toFloat, log.x * m, log.y * m, log.z * m) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> :=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span></span>(result: <span class="hljs-type"><span class="hljs-type">Vector3</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> xyz = <span class="hljs-type"><span class="hljs-type">Math</span></span>.sqrt(x*x + y*y + z*z) <span class="hljs-comment"><span class="hljs-comment">//      if (xyz &gt; 0.0001f) { val m = (Math.acos(w).toFloat * 2f) / xyz result.set(m * x, m * y, m * z) } else { result.set(0f, 0f, 0f) } } }</span></span></code> </pre><br>  What is an airplane flight from an abstract point of view?  By solving a system of second-order differential equations!  Set the state of the aircraft: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimeStamp</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Long</span></span> <span class="hljs-comment"><span class="hljs-comment">//   } trait VisibleState extends TimeStamp{ def position: Position def speed: Derivative }</span></span></code> </pre><br>  The class for the real state of the aircraft depends on the features of the model and the degree of its physical development, but it will implement this interface, necessary for drawing the aircraft on the screen. <br><br><h3>  The task can be divided into two independent parts. </h3><br>  1) the calculation of the forces acting on the aircraft in a given state <br>  2) numerical solution diffura <br><br>  The first part, as the most interesting, we leave at the end of the article. <br><br>  For the graphic part, we write the interface: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Avatar</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val player: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Player</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val model: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Airplane</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getState</span></span></span></span>(time: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">VisibleState</span></span> }</code> </pre><br>  I will not give the implementation, but the essence is simple - a sequence of states is stored inside with times t1, t2, t3, etc., t (n + 1)&gt; t (n).  States are completed if necessary, in the getState method, the next two are interpolated.  Thus, it is possible, for example, to read physics 10 times per second and at the same time observe smooth motion at 60 fps. <br><br>  We write the following interface: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Airplane</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mass</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Float</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Matrix4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tempM = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Matrix4</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tempQ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">QuaternionS</span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInertiaTensor</span></span></span></span>(orientation: <span class="hljs-type"><span class="hljs-type">Quaternion</span></span>): <span class="hljs-type"><span class="hljs-type">Matrix4</span></span> = { tempM.set(orientation) tempM.mul(<span class="hljs-type"><span class="hljs-type">I</span></span>) tempQ := orientation tempQ.conjugate() tempM.rotate(tempQ) tempM } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getForceAndMoment</span></span></span></span>(state: <span class="hljs-type"><span class="hljs-type">State</span></span>, input: <span class="hljs-type"><span class="hljs-type">PlaneInput</span></span>): <span class="hljs-type"><span class="hljs-type">Derivative</span></span> }</code> </pre><br><br>  The angular momentum is L = I * w, and L and w (angular velocity) are transformed as vectors.  Thus, in the transformation L '= qL, w' = qw it turns out: <br>  L '= I' * w ' <br>  qL = I '* qw <br>  L = q ^ (- 1) * I '* q * w <br><br>  We get I = q ^ (- 1) * I '* q, or I' = q * I * q ^ (- 1). <br><br>  The transformation w '= position.rot * w translates the angular velocity from the local coordinate system to the global one. <br><br>  The getForceAndMoment method will be discussed later, it calculates the forces and torque acting on the aircraft. <br><br>  I do not very well imagine how to accurately calculate the movement of a model that moves and rotates with accelerations, so the simplest method was chosen with a fixed step of 20ms. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateGenerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,           // , ,     private val inversed = new Matrix4() private val omega = new Vector3f() private val iOm = new Vector3f() private val angularAcceleration = new Vector3f() private val inv = new QuaternionS() def nextState(now: State, timeStep: Long, model: Airplane, planeInput: PlaneInput): State = { assert(timeStep &gt; 0) val dt = timeStep * 0.001f //   val next = new State(now.time + timeStep) next.position := now.position next.speed := now.speed //      val forces = model.getForceAndMoment(now, planeInput) //linear next.speed.linear += forces.linear * (dt / model.mass) next.position.pos += (now.speed.linear + next.speed.linear) * (0.5f * dt) //angular val I = model.getInertiaTensor(now.position.rot) inversed.set(I).inv() omega := now.speed.angular iOm := omega iOm.mul(I) angularAcceleration.setCross(iOm, omega) angularAcceleration += forces.angular angularAcceleration.mul(inversed) next.speed.angular.madd(angularAcceleration, dt) next.speed.angular *= 1f - dt * 0.1f //.    .     - 10 . val angSp = (next.speed.angular + now.speed.angular) / 2 next.position.rot := new QuaternionS(angSp * dt) * now.position.rot next //  Scala    return } }</span></span></code> </pre><br>  More information about the rotation can be found in this article: <a href="http://habrahabr.ru/post/264099/">habrahabr.ru/post/264099</a> .  Honestly, I am not a fan of tensors, I just took a formula from there in vector form in order to obtain angular acceleration.  Calculations are made in the coordinate system of the world.  By the way, when external forces were disconnected, I was able to observe a movement quite similar to the Janibekov effect. <br><br><h3>  Forces acting on the aircraft </h3><br>  The plane must be managed: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlaneInput</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimeStamp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yaw</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Float</span></span> <span class="hljs-comment"><span class="hljs-comment">// right is positive def pitch: Float // up is positive def roll: Float // clockwise is positive def engineTrust: Float }</span></span></code> </pre><br>  Values ‚Äã‚Äãare cut to the interval [-1, 1], engine thrust from 0 to 1. <br><br>  Well, let's move on to the most important part - we will find strength.  Here is a little Terra incognita, my knowledge of aerodynamics is very superficial.  Errors and inaccuracies are possible. <br><br>  The first thing that comes to mind is lifting force.  In order not to create garbage, on the Internet, a reference book of aviation profiles was found with charts of lift coefficient depending on the angle of attack.  The essence turned out to be quite simple - Cy (lift coefficient) grows quite linearly to critical angles, reaches about one, and then the flow from the wing breaks down, and the lift begins to decrease.  Also, the graph of the coefficient for the abstract wing can be <a href="https://en.wikipedia.org/wiki/Lift_coefficient">viewed in the English Wikipedia</a> : <br><br>  Then I was trapped by a rake - if you read another <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25BE%25D0%25B1%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25BE%25D0%25BF%25D1%2580%25D0%25BE%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">article on Wikipedia</a> on frontal resistance, you can see that there is some kind of inductive resistance.  The surprise is that the lifting force is considered to be in the direction perpendicular to the direction of speed, and not perpendicular to the surface of the wing (as I thought).  Since the difference in air pressure above and below the wing still leads to a force perpendicular to the surface of the wing, the projection of this force on the direction opposite to the movement is non-zero.  <s>If I understand correctly, this is inductive force.</s> <br>  And no.  See <a href="http://habrahabr.ru/post/266367/">comment</a> below.  Further text and code leave unchanged. <br><br>  If we assume that the lift is directed upwards in the reference system of the aircraft, then the inductive force does not seem to be necessary - it has already been taken into account.  The orientation of the axes is the same as in openGL: <br><br>  Ox - right <br>  Oy - up <br>  Oz - back <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   def cy(angle: Float) = { val pi = 3.1415928535f if (angle &gt; maxAngle) (pi - angle) / (pi - maxAngle) else if (angle &lt; -maxAngle) -(pi + angle) / (pi - maxAngle) else angle / maxAngle } def liftingForce(speed2: Float, angle: Float, airDensity: Float): Float = cy(angle) * airDensity * speed2 * 0.5f * planesS //      . val forceLocal = new Vector3f val speedLocal = state.position.rot^(-1) * state.speed.linear val sp2 = state.speed.linear.length2 val airDensity = WorldParams.atmosphere.aitDensity(state.position.pos) val attackAngle = -Math.asin(speedLocal.y / (speedLocal.length + 0.1f)).toFloat val steeringAngle = Math.asin(speedLocal.x / (speedLocal.length + 0.1f)).toFloat //       ,      ( 0.1 /)   ,   ""  .  -    . forceLocal.y += liftingForce(sp2, attackAngle, airDensity) forceLocal.x -= steeringForce(sp2, steeringAngle, airDensity) forceLocal += speedLocal/(0.1f + speedLocal.length) * -dragForce(sp2, attackAngle, steeringAngle, airDensity)</span></span></code> </pre><br>  In addition to lift, you will need air resistance force: <code>dragForce</code> and the force that occurs when the plane flies a little sideways: <code>steeringForce</code> . <br><br>  I do not have sufficient knowledge in aerodynamics.  The main goal is simplicity of formulas and, if possible, adequate aircraft behavior for flight angles of attack and glide.  0.5f - the consequences of divider 2 in the formulas.  0.1f - the consequences of adjusting the coefficients. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">steeringForce</span></span></span></span>(speed2: <span class="hljs-type"><span class="hljs-type">Float</span></span>, angle: <span class="hljs-type"><span class="hljs-type">Float</span></span>, airDensity: <span class="hljs-type"><span class="hljs-type">Float</span></span>): <span class="hljs-type"><span class="hljs-type">Float</span></span> = angle * airDensity * speed2 * <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * planeSVert <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dragForce</span></span></span></span>(speed2: <span class="hljs-type"><span class="hljs-type">Float</span></span>, attackAngle: <span class="hljs-type"><span class="hljs-type">Float</span></span>, steeringAngle: <span class="hljs-type"><span class="hljs-type">Float</span></span>, airDensity: <span class="hljs-type"><span class="hljs-type">Float</span></span>): <span class="hljs-type"><span class="hljs-type">Float</span></span> = { speed2 * (<span class="hljs-number"><span class="hljs-number">0.5</span></span>f * airDensity * crossSectionalArea + <span class="hljs-type"><span class="hljs-type">Math</span></span>.abs(attackAngle) * <span class="hljs-number"><span class="hljs-number">0.1</span></span>f * planesS + <span class="hljs-type"><span class="hljs-type">Math</span></span>.abs(steeringAngle) * <span class="hljs-number"><span class="hljs-number">0.1</span></span>f * planeSVert) }</code> </pre><br><h4>  Add traction motor </h4><br>  The model is as simple as possible: no propeller steps, let the engine spend all its power to accelerate the aircraft.  No bonuses to the moment of inertia, no torque when changing the number of revolutions.  However, the revolutions either.  Power = force * speed.  To prevent the plane from flying up like a rocket, we will limit the maximum force (using the minimum speed limit). <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> speed = <span class="hljs-type"><span class="hljs-type">Math</span></span>.max(minSpeed, -speedLocal.z) forceLocal.z -= input.engineTrust * maxPower / speed</code> </pre><br><h4>  Control </h4><br>  There is an interesting point - the air accelerated by a screw goes directly to the control planes of the tail, and the plane, in principle, is controlled by the tail a little even on the runway.  In addition, the air resistance is trying to twist the plane in the opposite direction of the screw rotation.  And up to the heap - the engine has a moment of inertia, when increasing / decreasing the speed of rotation, the plane will also ‚Äútwist‚Äù a little.  I will neglect all this ... <br><br>  As with the wing, a familiar multiplier appears with a square of velocity and air density: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mul = spLocal.z * spLocal.z * airDensity result.angular.x = (input.pitch + <span class="hljs-number"><span class="hljs-number">0.3</span></span>f) * mul * <span class="hljs-number"><span class="hljs-number">2</span></span>f result.angular.y = -input.yaw * mul * <span class="hljs-number"><span class="hljs-number">1</span></span>f result.angular.z = -input.roll * mul * <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  There is no symmetry in pitch, the aircraft (and the pilot) are much better tolerated by positive overloads than negative ones.  In addition, the aircraft itself is stable (if it is not the Su-47) and tends to return to the position ‚Äúnose forward‚Äù: <br><br><pre> <code class="scala hljs">result.angular.x -= attackAngle * airDensity * mul * <span class="hljs-number"><span class="hljs-number">5</span></span>f result.angular.y -= steeringAngle * airDensity * mul * <span class="hljs-number"><span class="hljs-number">5</span></span>f</code> </pre><br><h4>  Do not forget anything? </h4><br>  There is another force with which behavior becomes more interesting.  When looking at the plane from the front or from the back, you can see that the wing is slightly bent up by the Latin letter V - this is dictated by concern for the stability of the flight.  If the plane does not fly straight ahead, but slightly moves sideways, the lifting forces on the left and right will be different, and it will begin to rotate. <br><br><pre> <code class="scala hljs">result.angular.z += forceLocal.y * steeringAngle * <span class="hljs-number"><span class="hljs-number">1</span></span>f</code> </pre><br>  forceLocal.y - lifting force <br><br><h4>  Add "friction" to the rotation </h4><br>  Something happened against which my sense of beauty protested, but otherwise I would have to greatly complicate the model.  Before adding strength, I still try to justify it.  If a straight flying plane rotates, for example, with a roll to the left, then the angle of attack of the left wing increases, and the right wing - on the contrary, and this effect slows down the rotation.  On other axes, there is probably something similar (in the StateGenerator class, very slight friction during rotation is made for the stability of the computational scheme, and here it is simply so that the plane does not become like a pendulum): <br><br><pre> <code class="scala hljs">result.angular.mulAdd(spAngLocal, -airDensity * <span class="hljs-number"><span class="hljs-number">5000</span></span>f)</code> </pre><br>  We translate into the global coordinate system: <br><br><pre> <code class="scala hljs">result.angular.mul(state.position.rot) forceLocal.mul(state.position.rot) result.linear := forceLocal</code> </pre><br><h4>  Note </h4><br>  The system of units - meters, kilograms, seconds.  The ‚Äúfitting coefficients‚Äù are given for a reason ‚Äî I tried to match them to the I-16 parameters.  Mass 1400, power 750hp, or (750 * 735.5) Watts.  <s>The moment of inertia (estimated) - 5000 along the OX, OY and much less along the OZ (such as the main mass is concentrated in the fuselage of the aircraft, and it is quite long).</s> <br>  <a href="https://habrahabr.ru/users/imp5/" class="user_link">Imp5</a> reported more accurate data: the main moments of inertia are 2440, 5520, 3080 along the ‚Äúforward‚Äù, ‚Äúup‚Äù and ‚Äúright‚Äù axes, respectively. <br><br>  This physical model does not take into account the rotation of the aircraft, and fall into a spin does not work.  In the future, I plan to take several points on each wing and individually for each point calculate the angles of attack and speed of movement relative to the air.  The control of the tail and ailerons is implemented as a change in the parameters of the wing pieces.  Perhaps then the rotation of the aircraft will honestly fade due to air resistance. <br><br>  The code that calculates the forces and movement of the aircraft can be replaced at any time with something more serious. <br><br>  PS I take off my hat to domestic developers of a simulator about airplanes of the Second World War, from which my interest in aviation once began long ago. <br><br>  It was worth trying to write the physics himself to understand what a titanic work they had done.  For example, the rotation of a longitudinally located engine leads to the fact that with a bend in one direction, the nose of the aircraft leads upwards and in the other - downwards.  I do not have this effect, like many others.  On the one hand, a trifle, but from such trifles a unique behavior for each model is formed. </div><p>Source: <a href="https://habr.com/ru/post/266367/">https://habr.com/ru/post/266367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266355/index.html">Firebase queue: steroids for firebase</a></li>
<li><a href="../266357/index.html">100 out of 100 in Google PageSpeed ‚Äã‚ÄãInsights (Bug or feature)?</a></li>
<li><a href="../266359/index.html">In the guests' sitting "Grasshopper"</a></li>
<li><a href="../266361/index.html">1–°: Programmers Club - Teacher‚Äôs View</a></li>
<li><a href="../266363/index.html">We draw on electronic map tiles in MSSQL</a></li>
<li><a href="../266369/index.html">How to write dizdok</a></li>
<li><a href="../266371/index.html">Announcement of the third meeting of the Java User Group Sevastopol</a></li>
<li><a href="../266373/index.html">Another performance comparison of C ++ and C #</a></li>
<li><a href="../266375/index.html">Customize keyboard shortcuts in Linux like Mac OS X</a></li>
<li><a href="../266377/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 13. "Villa Siena"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>