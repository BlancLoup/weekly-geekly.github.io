<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The simplest image clustering by the k-means method (k-means)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Often when searching for moving objects in video, whether by subtracting the background, time difference, optical flow, we end up with a lot of points...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The simplest image clustering by the k-means method (k-means)</h1><div class="post__text post__text-html js-mediator-article">  Often when searching for moving objects in video, whether by subtracting the background, time difference, optical flow, we end up with a lot of points that, after the action of the above algorithms, are marked as having changed their position relative to the previous frame and are related to the foreground. <br><br><img src="https://habrastorage.org/storage2/b08/8f3/6e2/b088f36e2a810f29c90062168fd0b5f1.jpg" alt="image"><br><br>  After such processing, there is a question about the segmentation of objects by the method of cluster analysis, which will be discussed below and its implementation in C ++. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Object Segmentation </h4><br>  First, a little theory: <br>  Segmentation is the process of splitting a digital image into multiple segments (sets of pixels).  Simply put, this is the thing that allows you to determine which pixels from this set belong to Ferrari, and which to Peugeot. <br>  From the point of view of computing resources, it is very effective to use cluster analysis methods for segmentation.  The essence of clustering is that all source objects (in this case, pixels) are divided into several non-intersecting groups so that objects that fall into one group have similar characteristics, while for objects from different groups these characteristics should significantly differ.  The resulting groups are called clusters.  The initial values ‚Äã‚Äãin the simplest way for clustering are pixel coordinates (x, y), in more complex cases, for example for half-tone images, a three-dimensional vector (x, y, I (x, y)) is used, where I (x, y) - grayscale <br>  and a five-dimensional vector if RGB is used. <br><br><h4>  K-medium method </h4><br>  Centroid - the point which is the center of the cluster. <br>  k-means (k-means) is the most popular clustering method.  The algorithm is widely preferred because of its ease of implementation, high speed (and this is very important when working with video). <br>  The algorithm is such that it seeks to minimize the total square deviation of cluster points from the centers of these clusters.  In common speech, this is an iterative algorithm that divides a given set of pixels into k clusters of points, which are as close as possible to their centers, and the clustering itself occurs due to the displacement of these same centers.  Such a principle of divide and conquer. <br>  You should also stipulate that the k-means method is very sensitive to noise, which can significantly distort the results of clustering. So ideally, before clustering, you need to drive frames through filters designed to reduce it. <br><br>  Here is the very principle of the simplest clustering method K-means: <br><ol><li>  It is necessary to choose from the set of k pixels those pixels that will be the centroids of the corresponding k clusters. <br>  A sample of initial centroids can be either randomly or according to a certain algorithm. <br></li><li>  We enter a cycle that continues until the centroids of the clusters stop changing their position. </li><li>  We go around each pixel and see which centroid of which cluster it is nearby. </li><li>  Found a nearby centroid?  Bind a pixel to the cluster of this centroid. </li><li>  Touched all the pixels?  Now you need to calculate the new coordinates of the centroids of k clusters. </li><li>  Now check the coordinates of the new centroids.  If they are respectively equal to the previous centroids, we exit the cycle, if not, we return to step 3. </li></ol><br>  Here is a picture that roughly demonstrates the operation of the algorithm: <br><img src="https://habrastorage.org/storage2/89c/8ff/626/89c8ff626ac2ac7278a2eb04ac4775ae.png"><br>  Here is a good applet to illustrate the operation of the <a href="http://home.dei.polimi.it/matteucc/Clustering/tutorial_html/AppletKM.html">k-means</a> algorithm. <br><br><h4>  Let's start </h4><br>  First we need a class, let's call it Cluster, which will store the vector of coordinates of pixels belonging to the cluster, the current and previous values ‚Äã‚Äãof the coordinates of the centroid: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cluster</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;POINT&gt; scores; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curX , curY;<span class="hljs-comment"><span class="hljs-comment">//   int lastX, lastY;//   size_t Size(){ return scores.size();}//   inline void Add(POINT pt){ scores.push_back(pt); }//    void SetCenter(); void Clear();//  static Cluster* Bind(int k, Cluster * clusarr, vector&lt;POINT&gt;&amp; vpt); static void InitialCenter(int k, Cluster * clusarr , vector&lt;POINT&gt;&amp; vpt);; static void Start(int k, Cluster * clusarr, vector&lt;POINT&gt;&amp; vpt); inline POINT&amp; at(unsigned i){ return scores.at(i);}//    };</span></span></code> </pre> <br><br>  Now we need to implement a method that will distribute the initial coordinates of the centroids.  Of course, you can do something more complicated, but in our case, even distribution along the vector will do: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Cluster::InitialCenter(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k, Cluster * clusarr, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;POINT&gt;&amp; vpt){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = vpt.size(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step = size/k; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> steper = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;i &lt; k;i++,steper+=step){ clusarr[i].curX = vpt[steper].x; clusarr[i].curY = vpt[steper].y; } }</code> </pre><br><br>  You also need to write a method that will be responsible for finding the centroid coordinates in accordance with paragraph 5. The coordinates of the new centroid can be found by describing a rectangle around the cluster pixels and then the centroid will be the intersection of its diagonals. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Cluster::SetCenter(){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sumX = <span class="hljs-number"><span class="hljs-number">0</span></span>, sumY = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = Size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; i&lt;size;sumX+=scores[i].x,i++);<span class="hljs-comment"><span class="hljs-comment">//the centers of mass by x i = 0; for(; i&lt;size;sumY+=scores[i].y, i++);//the centers of mass by y lastX = curX; lastY = curY; curX = sumX/size; curY = sumY/size; } void Cluster::Clear(){ scores.clear(); }</span></span></code> </pre><br><br>  And now it only remains to make an unpretentious method of ‚Äúattaching‚Äù pixels to a specific cluster itself on the principle of comparing modules of segments: <br><br><pre> <code class="cpp hljs">Cluster * Cluster::Bind(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k, Cluster * clusarr, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;POINT&gt;&amp; vpt){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k;j++) clusarr[j].Clear();<span class="hljs-comment"><span class="hljs-comment">//     int size = vpt.size(); for(int i = 0; i &lt; size; i++){//       int min = sqrt( pow((float)clusarr[0].curX-vpt[i].x,2)+pow((float)clusarr[0].curY-vpt[i].y,2) ); Cluster * cl = &amp;clusarr[0]; for(int j = 1; j &lt; k; j++){ int tmp = sqrt( pow((float)clusarr[j].curX-vpt[i].x,2)+pow((float)clusarr[j].curY-vpt[i].y,2) ); if(min &gt; tmp){ min = tmp; cl = &amp;clusarr[j];}//    } cl-&gt;Add(vpt[i]);//        } return clusarr; }</span></span></code> </pre><br><br>  Finally, the main loop: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Cluster::Start(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k, Cluster * clusarr, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;POINT&gt;&amp; vpt){ Cluster::InitialCenter(k,clusarr,vpt); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;){<span class="hljs-comment"><span class="hljs-comment">//   int chk = 0; Cluster::Bind(k,clusarr,vpt);//    for(int j = 0; j &lt; k;j++)//    clusarr[j].SetCenter(); for(int p = 0; p&lt;k;p++)//       - if(clusarr[p].curX == clusarr[p].lastX &amp;&amp; clusarr[p].curY == clusarr[p].lastY) chk++; if(chk == k) return;//     } }</span></span></code> </pre><br><h4>  And what follows from all this? </h4><br>  Let us return to the picture with machines, clustering moving objects, a problem arises when using the k-means algorithm, namely, we don‚Äôt know how many moving objects there will be in this scene, although we can approximately predict.  For example, a frame with machines, on that scene, it would be reasonable to assume that well, there will be a maximum of 10 machines. Thus, setting the program input to k = 10 and outlining the points of 10 clusters with green rectangles, we get something like this: <br><br><img src="http://habrastorage.org/storage2/968/abf/dee/968abfdeec2ed73160fe847104c82e20.jpg"><br><br>  Now it‚Äôs commonplace to intersect intersecting rectangles, we find the resulting clusters, by circling that with a rectangle we will get an image translated at the beginning of the post. Everything is simple. </div><p>Source: <a href="https://habr.com/ru/post/165087/">https://habr.com/ru/post/165087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165069/index.html">PHP class for convenient and safe work with MySQL</a></li>
<li><a href="../165071/index.html">We write the application for Android on Ruby (Ruboto)</a></li>
<li><a href="../165073/index.html">Writing an extension for google chrome</a></li>
<li><a href="../165077/index.html">Android Conquering fragmentation</a></li>
<li><a href="../165085/index.html">JS module for Java developers</a></li>
<li><a href="../165089/index.html">XIMA Chronicall emergency troubleshooting telephone monitoring and reporting system</a></li>
<li><a href="../165091/index.html">13 reasons not to be a manager</a></li>
<li><a href="../165093/index.html">A brief, incomplete, and mostly incorrect history of programming languages</a></li>
<li><a href="../165095/index.html">Changing the program code during its execution on the example of Common Lisp</a></li>
<li><a href="../165097/index.html">EC2 - price analysis for a startup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>