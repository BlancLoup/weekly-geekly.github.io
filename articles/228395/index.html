<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UNET - new network technology in Unity 3D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, at the Unite Asia conference, we reported on the development of new multiplayer tools, technologies and services for Unity developers. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UNET - new network technology in Unity 3D</h1><div class="post__text post__text-html js-mediator-article">  Some time ago, at the Unite Asia conference, we reported on the development of new multiplayer tools, technologies and services for Unity developers.  The internal name of this project is UNET, which simply means Unity Networking.  But our plans go far beyond simple networking.  As you all know, the main goal of Unity is to democratize the game development process.  The Unity Networking team wants to democratize the development of multiplayer games.  We want all game developers to develop multiplayer games of any type with any number of players.  Of course, this is not the easiest task, but we all have already solved it in the past and really want to do it again (because it is really cool!).  We decided to divide our common goal into several phases, which should be well known to Unity developers.  According to this approach, we will release phase 1, get user feedback, take them into account in our work to make the next phase even better and repeat this cycle.  For UNET, Phase 1 will be what we call the Multiplayer Foundation ‚Äî we‚Äôll tell you about it just below.  Phase 2 will be built on the basis of phase 1 and will provide technology for creating games with authorization on the server, which we call Simulation Server, about it in the next articles.  In phase 3, we will add the ability to coordinate multiple Simulation Servers using the Master Simulation Server system.  As always, the exact release date can not be called, especially given the collection of feedback from our users.  But we can say that phase 1 will be part of the 5.x release cycle, and phase 2 is now at the research stage. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cb/2e1/f17/6cb2e1f17673ed70a988000b7700a1ab.png"><br><a name="habracut"></a><br>  Before joining Unity, members of our network team worked mostly on MMOs like Ultima Online, Lord of the Rings Online, Dungeons and Dragons Online, Marvel Heroes, Need for Speed ‚Äã‚ÄãOnline, and World of Warcraft.  We have a lot of enthusiasm and vast experience in creating multiplayer games, technologies and infrastructure.  Unity's mission was known to each of us and always seemed very attractive.  We could not refuse the opportunity to do something truly great, like the realization of this dream in the field of multiplayer.  So we left previous jobs and joined Unity to make this dream a reality.  Now we are working hard on these tools, technologies and services so that anyone can realize their dream of a multiplayer game. <br><br>  So what do we mean by the Multiplayer Foundation in Phase 1?  Here are its main parts: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - high-performance UDP-based transport protocol supporting all game types <br><br>  - Low-level API (Low Level API - LLAPI), providing full control through a socket-like interface <br><br>  - high-level API (High Level API - HLAPI), providing a simple and secure client / server model <br><br>  - Matchmaker Service, which provides basic functionality for creating rooms and helping players find each other <br><br>  - Relay Server, solving communication problems between players trying to connect through firewalls <br><br>  Considering some of the historical limitations and the ambitious goal, it became obvious to us that we would have to start from scratch.  Since our goal was to support all types of games and any number of connections, we started with a new, high-performance transport layer based on UDP.  We know that TCP is enough for many games, but fast games still require UDP, as TCP delays the last packets if they do not arrive in order. <br><br>  Based on this new transport layer, we built two APIs.  High-level High Level API (HLAPI) provides a simple and secure client-server model.  If you are not a network engineer and just want to make a multiplayer game, you will be interested in HLAPI. <br><br>  We also took into account reviews about the old system: some users wanted low-level access for more control.  Now it has a low-level Low Level API (LLAPI), which provides a more socket-like interface for the transport layer.  If you are a network engineer and want to build your own network model or just fine tune network performance, then you will be interested in LLAPI. <br><br>  Matchmaker Player Recruitment is used to set up rooms in your multiplayer games and help players find each other.  Relay Server ensures that your players can always connect with each other. <br><br>  We learned from our own experience that creating multiplayer games brings a lot of pain.  The Multiplayer Foundation is a new set of easy-to-use, professional networking technologies, tools and infrastructure for seamlessly creating multiplayer games.  As it seems to me, it is quite possible to say that the creation of a multiplayer game requires a good knowledge of networks and protocols.  You either overcome the painfully steep learning curve yourself, or you are looking for a network engineer.  After going through this, you have to solve the problem of providing players with the means to find each other.  Having solved this problem, you have to deal with providing players with the ability to connect with each other, which can be very difficult if they are behind NAT firewalls.  To cope with all this you have to create a decent-sized infrastructure, which is not very nice and has nothing to do with the development of games.  After that, you will have to think about the dynamic scaling of your infrastructure, the proper implementation of which usually requires a certain amount of experience. <br><br>  Phase 1 will save you from all these painful problems.  HLAPI will eliminate the need for a deep understanding of network technologies.  But if you are a network engineer and want to do everything your own way, then LLAPI will always be available to you.  Matchmaker will solve your problems by providing players the opportunity to find each other.  Relay Server will solve your problems by providing players with the ability to truly connect with each other.  We will also solve your problems by building the necessary infrastructure and its dynamic scaling.  Matchmaker and Relay Server will live in the Unity Multiplayer Cloud.  So not only physical servers, but also processes will be scaled depending on demand. <br><br><h2>  High-level API UNET and SyncVar </h2><br><h4>  Introduction and requirements </h4><br>  Some background information.  A common practice for online games is to have a server that owns the objects and clients that need to be informed that the data in these objects has changed.  For example, in a combat game, the player‚Äôs life should be visible to all players.  This requires the presence of a member-variable in the script class, which is sent to all clients when the server changes.  Here is an example of a simple class for combat: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Combat</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Health; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Alive; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeDamage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &gt;= Health) { Alive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Health = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Health -= amount; } } }</code> </pre> <br><br>  When a player on the server receives damage, all players need to be informed about the new meaning of life for this player. <br><br>  It seems simple, but the difficulty is to make the system invisible for developers writing code, efficient in terms of CPU, memory and bandwidth, and flexible enough to support all types that developers want to use.  So the specific goals for this system will be: <br><br>  1. Minimize memory usage without storing shadow copies of variables. <br><br>  2. Minimize the use of bandwidth by sending only those states that have really changed (incremental updates) <br><br>  3. Minimize the use of the processor without constantly checking whether the state has changed <br><br>  4. Minimize protocol and serialization discrepancies without forcing developers to manually write serialization functions <br><br>  5. Do not require developers to directly mark variables as dirty. <br><br>  6. Work with all programming languages ‚Äã‚Äãsupported by Unity <br><br>  7. Do not disturb the current development process. <br><br>  8. Do not enter manual steps that developers would need to do to use the system. <br><br>  9. Allow the system to be guided by meta-data (custom attributes (custom attributes)) <br><br>  10. Process both simple and complex types. <br><br>  11. Do not use reflections at run time. <br><br>  A very ambitious list of requirements! <br><br><h4>  Old network system </h4><br>  In the existing Unity network system, there is a ‚ÄúReliableDeltaCompressed‚Äù type of synchronization that produces state synchronization, providing the OnSerializeNetworkView () function.  This function is embedded in objects with the NetworkView component and the serialization code written by the developer writes to (or reads from) the provided byte stream.  The content of this byte stream is cached by the engine and if the next time the function is called, the result does not match the cached version, the object is considered dirty and its state is sent to the clients.  Here is an example of a possible serialization function: <br><br><pre> <code class="hljs ruby">void OnSerializeNetworkView (Bitstream stream, NetworkMessageInfo info) { float horizontalInput = <span class="hljs-number"><span class="hljs-number">0</span></span>.0f; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stream.isWriting) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Sending horizontalInput = Input.GetAxis (<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); stream.Serialize (horizontalInput); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Receiving stream.Serialize (horizontalInput); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something meaningful with the received variable } }</code> </pre><br><br>  This approach meets some of the requirements in the above list, but not all.  At runtime, it works automatically, since OnSerializeNetworkView () is called by the engine with the frequency of sending data over the network and the developer does not need to mark variables as dirty.  It does not add any additional steps to the build process and does not interrupt the current development process. <br><br>  But its performance is not particularly high - especially when there are many network objects.  CPU time is spent on comparisons, cached copies of byte streams are memory.  It is also prone to mismatch errors in the serialization functions, since they need to be updated manually when new member variables are added that need to be synchronized.  It is not guided by metadata, so the editor and other tools cannot find out which variables are synchronized. <br><br><h4>  Code Generation for SyncVars </h4><br>  In the course of working on a new state synchronization system in UNET, our team developed a solution with code generation based on custom attributes.  In custom code, it looks like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UNetwork; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Combat</span></span> : <span class="hljs-title"><span class="hljs-title">UNetBehaviour</span></span> { [SyncVar] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Health; [SyncVar] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Alive; }</code> </pre><br><br>  This new custom attribute tells the system that the instance variables Health and Alive need to be synchronized.  Now the developer does not need to write the serialization function, since the code generator has data from custom attributes, based on which it will be able to generate excellent serialization and deserialization functions with the correct order and types.  The generated functions will look something like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UNetSerializeVars</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.WriteInt(Health); writer.WriteBool(Alive); }</code> </pre><br><br>  Since this function overrides the virtual function in the base class UNetBehaviour, then when serializing a game object, the script variables will be serialized automatically.  After that, they will be unpacked at the other end using the appropriate deserialization function.  The inconsistencies are impossible, because when you add a new [SyncVar] variable, the code is updated automatically. <br><br>  This data is now available to the editor, so the inspector window can show more information: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4a/031/c02/e4a031c02049798eb6fe027b21625504.png"><br><br>  But with this approach, there are still a number of problems.  The function always sends the entire state ‚Äî it is not incremental, so when changing one member of the object, the state of the entire object is sent.  And how do we know when to call the serialization function?  It is not very efficient to send a state if nothing has changed. <br><br>  We overcame this with properties and dirty flags.  It seems natural that each [SyncVar] variable can be wrapped in a property that will put dirty marks on it as it changes.  This approach has been partially successful.  The presence of a bit mask with dirty marks allowed the code generator to perform incremental updates.  The generated code began to look like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UNetSerializeVars</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UWriter writer</span></span></span><span class="hljs-function">)</span></span> { Writer.Write(m_DirtyFlags) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_DirtyFlags &amp; <span class="hljs-number"><span class="hljs-number">0x01</span></span>) { writer.WriteInt(Health); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_DirtyFlags &amp; <span class="hljs-number"><span class="hljs-number">0x02</span></span>) { writer.WriteBool(Alive); } m_DirtyFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Now the serialization function can read the mask with dirty labels and serialize only those variables that need to be written to the stream.  We get efficient bandwidth usage and the ability to find out if the object is dirty.  For the user, this is still fully automatic.  But how will these properties work? <br><br>  Suppose we are trying to wrap [SyncVar] instance variables: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UNetwork; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Combat : UNetBehaviour { [SyncVar] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Health; // <span class="hljs-keyword"><span class="hljs-keyword">generated</span></span> property <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> HealthSync { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Health; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { m_dirtyFlags |= <span class="hljs-number"><span class="hljs-number">0x01</span></span>; Health = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre><br><br>  This property performs the task, but has the wrong name.  The TakeDamage () function from the above example uses Health, not HealthSync, so it will ignore the property.  The user will not be able to directly use the HealthSync property at all, since it does not exist before the code generation is performed.  It could be done in two steps, when at the first stage the automatic code is generated, and at the second the user updates his code - but this is very fragile.  This approach is prone to compilation errors that cannot be fixed without rewriting large pieces of code. <br><br>  Another option would be to require developers to write the above properties for each [SyncVar] variable.  This approach adds work to programmers and is potentially error prone.  The bitmasks in the user and generated code must match exactly, so adding or removing [SyncVar] variables will be an extremely delicate process. <br><br><h4>  Introducing Mono Cecil </h4><br>  Thus, we need to generate wrapper properties and force the source code to use them even if it is unaware of their existence.  Fortunately, for Mono there is a tool called Cecil that does just that.  Cecil is able to load Mono assemblies in ECMA CIL format, modify them and write them back. <br><br>  At this moment, things get a little crazy.  The UNET code generator creates wrapper properties, then it finds all the places in the code where the source variables are used, and then replaces the references to these variables with references to the wrapper properties and voila!  Now the user code calls the newly created properties without requiring any work from the user. <br><br>  Since Cecil works at the CIL level, there is an additional advantage in the form of support for all languages, since they are all compiled into one format. <br><br>  The generated CIL for the final serialization that is inserted into the build with the script now looks like this: <br><br><pre> <code class="hljs cpp">IL_0000: ldarg<span class="hljs-number"><span class="hljs-number">.2</span></span> IL_0001: brfalse IL_000d IL_0006: ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0007: ldc.i4.m1 IL_0008: stfld uint32 [UnityEngine]UnityEngine.UNetBehaviour::m_DirtyBits IL_000d: nop IL_000e: ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> IL_000f: ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0010: ldfld uint32 [UnityEngine]UnityEngine.UNetBehaviour::m_DirtyBits IL_0015: callvirt instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> [UnityEngine]UnityEngine.UNetwork.UWriter::UWriteUInt32(uint32) IL_001a: ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_001b: ldfld uint32 [UnityEngine]UnityEngine.UNetBehaviour::m_DirtyBits IL_0020: ldc.i4 <span class="hljs-number"><span class="hljs-number">1</span></span> IL_0025: <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> IL_0026: brfalse IL_0037 IL_002b: ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> IL_002c: ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_002d: ldfld valuetype Buf/BufType Powerup::mbuf IL_0032: callvirt instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> [mscorlib]System.IO.BinaryWriter::Write(int32) IL_0037: nop IL_0038: ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_0039: ldc.i4<span class="hljs-number"><span class="hljs-number">.0</span></span> IL_003a: stfld uint32 [UnityEngine]UnityEngine.UNetBehaviour::m_DirtyBits IL_003f: ret</code> </pre><br><br>  Fortunately, ILSpy can convert CIL to C # and vice versa, so that we can view the generated CIL as C #.  ILSpy is a great tool for working with Mono / .Net builds.  C # looks like this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> void UNetSerializeVars(UWriter writer, bool forceAll) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forceAll) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_DirtyBits = <span class="hljs-number"><span class="hljs-number">4294967295</span></span>u; } writer.UWriteUInt32(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_DirtyBits); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_DirtyBits &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>u) != <span class="hljs-number"><span class="hljs-number">0</span></span>u) { writer.Write((int)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mbuf); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.m_DirtyBits = <span class="hljs-number"><span class="hljs-number">0</span></span>u; }</code> </pre><br><br>  Let's see how this meets our requirements: <br><br>  1. No shadow copies of variables <br><br>  2. Incremental updates <br><br>  3. No state change checks. <br><br>  4. No hand-written serialization functions. <br><br>  5. No explicit dirty calls <br><br>  6. Works with all programming languages ‚Äã‚Äãsupported by Unity. <br><br>  7. Does not affect the usual development process <br><br>  8. Does not require developer manual work. <br><br>  9. Based on metadata <br><br>  10. Works with all types (with new serializers UWriter / UReader) <br><br>  11. Does not use reflections at run time. <br><br>  It seems like they are all executed.  The system will be efficient and developer friendly.  I want to believe that it will simplify the development of multiplayer games for Unity for all. <br><br>  We also use Cecil to implement RPC calls to avoid searching functions by name using reflection.  We will tell about this in further articles. <br><br><h2>  Low Level LLAPI and UNET Transport Layer </h2><br>  Starting to design a new network library for Unity, we wanted to understand how the ideal library should look like.  We found out that we (roughly speaking) have two types of users: <br><br>  1. Users who want network tools to give them a ready-to-use result with minimal effort (ideally, no effort at all). <br><br>  2. Users who develop network-oriented games and want very flexible and powerful tools <br><br>  Focusing on these two types, we have divided our network library into two different parts: the high-level HLAPI (high-level API) and the low-level LLAPI (low-level API). <br><br>  In this part, the discussion will focus on the low-level API and library structure, which are based on the following principles: <br><br><h4>  Performance, Productivity, Productivity </h4><br>  LLAPI is a thin layer on top of UDP sockets, most of the work is done in a separate thread (so LLAPI can be configured to use only the main thread).  It has no dynamic memory allocation and no heavy synchronization (most of the library uses synchronization based on memory access barriers (memory barrier synchronization) with a small number of atomic increment / decrement operation). <br><br><h4>  If something can be done on C #, then it should be done on it </h4><br>  We decided to give access only to what our users really need.  Like BSD sockets, LLAPI supports only one abstraction - the exchange of raw binary messages.  There are no tcp-like streams, serializers, or RPC calls, only low-level messages. <br><br><h4>  Flexibility and customizability?  Yes please... </h4><br>  If you look at the implementation of sockets in TCP, you will see a lot of parameters (waiting times, buffer length, and so on) that you can change.  We chose a similar approach and allowed users to change almost all the parameters of our library so that they could adjust them to their needs.  Facing the choice between simple and flexibility, we chose flexibility. <br><br><h4>  Simplicity and pleasantness </h4><br>  We tried to design LLAPI as much as possible similar to the BSD socket API. <br><br><h4>  Network and transport layers </h4><br>  Logically, a low-level UNET library is a set of network protocols built on top of UDP and including a ‚Äúnetwork‚Äù layer and a ‚Äútransport‚Äù layer.  The network layer is used to connect between nodes, deliver packets and control possible leakage and congestion.  The transport layer works with "messages" belonging to various communication channels. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae7/e96/632/ae7e966322c35c051bf2432c4e5efbdb.png"><br><br>  Channels have two purposes, they can separate messages logically and provide various guarantees of delivery and quality of service (delivery or quality of service). <br><br>  Channel setup is part of the setup procedure, which we will cover in future articles.  At the moment, let's just assume that the setting looks like "My system will contain up to 10 connections, each connection will have 5 channels, channel 0 will have this type, channel 1 will have a different type, and so on."  The last part of the sentence is defined as: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b5/3c7/196/9b53c71962456c22939d5bad977bfe91.png"><br><br>  The second parameter is the channel number, the last is the type of channel or quality of service of the channel (delivery grant). <br><br>  UNET (for now) supports the following QOS: <br><br>  <b>- Unreliable</b> : an unreliable message that may be lost due to network problems or an internal buffer overflow, similar to a UDP packet.  Example: short log entries. <br><br>  <b>- UnreliableFragmented: The</b> maximum packet length is unchanged, but at times you will most likely want to send ‚Äúlarge‚Äù messages.  This type of channel before sending will disassemble your messages into fragments and collect them back before receiving.  Since this quality of service is unreliable, delivery is not guaranteed.  Example: a long log. <br><br>  <b>- UnreliableSequenced:</b> The channel provides the order of delivery, but since this quality of service is unreliable, the message may be lost.  Example: voice, video. <br><br>  <b>- Reliable:</b> The channel guarantees access (or disconnection), but does not guarantee order.  Example: transfer damage. <br><br>  <b>- ReliableFragmented:</b> the same as UnreliableFragmented, but in addition to it guarantees delivery.  Example: group damage. <br><br>  <b>- ReliableSequenced:</b> the same as UnreliableSequenced, but additionally guarantees delivery.  This QOS is similar to the TCP stream.  Example: file transfer and patches. <br><br>  <b>- StateUpdate:</b> unreliable channel type, forcibly dropping packets older than received / sent.  If the transfer buffer contains more than one message, only the most recent one will be sent.  If the recipient's buffer when reading contains more than one message, only the most recent one will be delivered.  Example: location transfer. <br><br>  <b>- AllCostDelivery:</b> very similar to Reliable, but there are differences.  A reliable channel will re-send messages based on round trip time value (RTT), which is determined dynamically, while AllCostDelivery will automatically forward messages after a certain period of time (set in the settings).  This can be useful for small but important messages: ‚ÄúI hit player A‚Äôs head‚Äù or ‚ÄúA mini-game is starting.‚Äù  Example: game events like the departure of bullets. <br><br>  Let's look at a typical LLAPI function call: <br><br>  1. Initialization of the library <br><br><img src="https://habrastorage.org/getpro/habr/post_images/889/f03/f3f/889f03f3f01e37343c70a3c1851c0a7f.png"><br><br>  2. Network configuration: topology, number of channels, their types, different timeouts and buffer sizes (this will be discussed in other articles). <br><br>  3. Creating a socket <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ca/204/1c6/7ca2041c6d84ffd384b6aa4273dd2d35.png"><br><br>  This function will open a socket on port 5000 on all network interfaces and return an integer value as the socket description. <br><br>  4. Connecting to another node <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34a/ba2/9d5/34aba29d5312ace2a7d7ad545b7b85ec.png"><br><br>  This function will send a connection request to another host at 127.0.0.1/6000.  It will return an integer value as a description of the connection to this node.  You will receive a connection event when the connection is established or a disconnection event if the connection cannot be established. <br><br>  5. We send the message <br><br><img src="https://habrastorage.org/getpro/habr/post_images/660/06d/123/66006d12315afdadbe88c930b4545de5.png"><br><br>  The last function will send the binary data contained in the buffer via the socket described in hostId for describing the node connectionId using channel 1 (in our case this is a ‚Äúreliable channel‚Äù, so that the delivery of the message will be guaranteed) <br><br>  6. Receive network events <br><br>  To receive network events, we select the survey model.  The user must poll the UTransport.Receive () function to receive notifications about network events.  Note that this model is very similar to the usual select () call with zero timeout.  This function receives 4 different events. <br><br>  <b>UNETEventType.kConnectEvent</b> - someone connects to you or has successfully established a connection requested by UTransport.Connect () <br><br>  <b>UNETEventType.kDisconnectEvent</b> - someone disconnects from you or the connection requested using UTransport.Connect () cannot be established for any reason that is reported by an error code. <br><br>  <b>UNETEventType.kDatatEvent</b> - New data received <br><br>  <b>UNETEventType.kNothing</b> - nothing interesting happened <br><br><img src="https://habrastorage.org/getpro/habr/post_images/371/884/73e/37188473e8b89156605323cf58f87a71.png"><br><br>  7. Send disconnect request <br><br>  This function call will send a disconnect request to the connectionId to the host with the hostId.  The connection will be immediately closed and may be reused in the future. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/671/969/178/671969178863f7512f9a293e8fb66562.png"><br><br><h4>  Notes </h4><br>  1. The article is compiled from three entries in the English Unity blog: <br><br>  <a href="http://blogs.unity3d.com/2014/05/12/announcing-unet-new-unity-multiplayer-technology/">Announcing UNET - New Unity Multiplayer Technology</a> <br>  <a href="http://blogs.unity3d.com/2014/05/29/unet-syncvar/">UNET SyncVar</a> <br>  <a href="http://blogs.unity3d.com/2014/06/11/all-about-the-unity-networking-transport-layer/">All about the Unity networking transport layer</a> <br><br>  2. Examples of source code in the form of pictures were in the original article in English. </div><p>Source: <a href="https://habr.com/ru/post/228395/">https://habr.com/ru/post/228395/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228383/index.html">Serious design of a serious store. Part 3. Card product and not only</a></li>
<li><a href="../228385/index.html">9 things that I learned as a programmer, and that I would like to know when I entered the magistracy</a></li>
<li><a href="../228389/index.html">Elliptics from Yandex. How to use it to create your fault-tolerant storage</a></li>
<li><a href="../228391/index.html">Wind generator energetically pays off in 5-7 months</a></li>
<li><a href="../228393/index.html">Annual online conference MegaIndex.tv 2014</a></li>
<li><a href="../228397/index.html">Brave Octopus Adventure - the brave octopus is ready to conquer your Android smartphones</a></li>
<li><a href="../228401/index.html">Gaming Conferences: DevGamm, White Nights and Health Industry</a></li>
<li><a href="../228405/index.html">Receive notifications from Zabbix in WhatsApp</a></li>
<li><a href="../228409/index.html">Values ‚Äã‚Äãof using email for small and medium businesses</a></li>
<li><a href="../228411/index.html">Django widgets and a couple more tricks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>